DECL|macro|AZT_VERSION
mdefine_line|#define AZT_VERSION &quot;2.60&quot;
multiline_comment|/*      $Id: aztcd.c,v 2.60 1997/11/29 09:51:19 root Exp root $&n;&t;linux/drivers/block/aztcd.c - Aztech CD268 CDROM driver&n;&n;&t;Copyright (C) 1994-98 Werner Zimmermann(Werner.Zimmermann@fht-esslingen.de)&n;&n;&t;based on Mitsumi CDROM driver by  Martin Hariss and preworks by&n;&t;Eberhard Moenkeberg; contains contributions by Joe Nardone and Robby &n;&t;Schirmer.&n;&n;&t;This program is free software; you can redistribute it and/or modify&n;&t;it under the terms of the GNU General Public License as published by&n;&t;the Free Software Foundation; either version 2, or (at your option)&n;&t;any later version.&n;&n;&t;This program is distributed in the hope that it will be useful,&n;&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;&t;GNU General Public License for more details.&n;&n;&t;You should have received a copy of the GNU General Public License&n;&t;along with this program; if not, write to the Free Software&n;&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;&t;HISTORY&n;&t;V0.0    Adaption to Aztech CD268-01A Version 1.3&n;&t;&t;Version is PRE_ALPHA, unresolved points:&n;&t;&t;1. I use busy wait instead of timer wait in STEN_LOW,DTEN_LOW&n;&t;&t;   thus driver causes CPU overhead and is very slow &n;&t;&t;2. could not find a way to stop the drive, when it is&n;&t;&t;   in data read mode, therefore I had to set&n;&t;&t;   msf.end.min/sec/frame to 0:0:1 (in azt_poll); so only one&n;&t;&t;   frame can be read in sequence, this is also the reason for&n;&t;&t;3. getting &squot;timeout in state 4&squot; messages, but nevertheless&n;&t;&t;   it works&n;&t;&t;W.Zimmermann, Oct. 31, 1994&n;&t;V0.1    Version is ALPHA, problems #2 and #3 resolved.  &n;&t;&t;W.Zimmermann, Nov. 3, 1994&n;&t;V0.2    Modification to some comments, debugging aids for partial test&n;&t;&t;with Borland C under DOS eliminated. Timer interrupt wait &n;&t;&t;STEN_LOW_WAIT additionally to busy wait for STEN_LOW implemented; &n;&t;&t;use it only for the &squot;slow&squot; commands (ACMD_GET_Q_CHANNEL, ACMD_&n;&t;&t;SEEK_TO_LEAD_IN), all other commands are so &squot;fast&squot;, that busy &n;&t;&t;waiting seems better to me than interrupt rescheduling.&n;&t;&t;Besides that, when used in the wrong place, STEN_LOW_WAIT causes&n;&t;&t;kernel panic.&n;&t;&t;In function aztPlay command ACMD_PLAY_AUDIO added, should make&n;&t;&t;audio functions work. The Aztech drive needs different commands&n;&t;&t;to read data tracks and play audio tracks.&n;&t;&t;W.Zimmermann, Nov. 8, 1994&n;&t;V0.3    Recognition of missing drive during boot up improved (speeded up).&n;&t;&t;W.Zimmermann, Nov. 13, 1994&n;&t;V0.35   Rewrote the control mechanism in azt_poll (formerly mcd_poll) &n;&t;&t;including removal of all &squot;goto&squot; commands. :-); &n;&t;&t;J. Nardone, Nov. 14, 1994&n;&t;V0.4    Renamed variables and constants to &squot;azt&squot; instead of &squot;mcd&squot;; had&n;&t;&t;to make some &quot;compatibility&quot; defines in azt.h; please note,&n;&t;&t;that the source file was renamed to azt.c, the include file to&n;&t;&t;azt.h                &n;&t;&t;Speeded up drive recognition during init (will be a little bit &n;&t;&t;slower than before if no drive is installed!); suggested by&n;&t;&t;Robby Schirmer.&n;&t;&t;read_count declared volatile and set to AZT_BUF_SIZ to make&n;&t;&t;drive faster (now 300kB/sec, was 60kB/sec before, measured&n;&t;&t;by &squot;time dd if=/dev/cdrom of=/dev/null bs=2048 count=4096&squot;;&n;&t;&t;different AZT_BUF_SIZes were test, above 16 no further im-&n;&t;&t;provement seems to be possible; suggested by E.Moenkeberg.&n;&t;&t;W.Zimmermann, Nov. 18, 1994&n;&t;V0.42   Included getAztStatus command in GetQChannelInfo() to allow&n;&t;&t;reading Q-channel info on audio disks, if drive is stopped, &n;&t;&t;and some other bug fixes in the audio stuff, suggested by &n;&t;&t;Robby Schirmer.&n;&t;&t;Added more ioctls (reading data in mode 1 and mode 2).&n;&t;&t;Completely removed the old azt_poll() routine.&n;&t;&t;Detection of ORCHID CDS-3110 in aztcd_init implemented.&n;&t;&t;Additional debugging aids (see the readme file).&n;&t;&t;W.Zimmermann, Dec. 9, 1994  &n;&t;V0.50   Autodetection of drives implemented.&n;&t;&t;W.Zimmermann, Dec. 12, 1994&n;&t;V0.52   Prepared for including in the standard kernel, renamed most&n;&t;&t;variables to contain &squot;azt&squot;, included autoconf.h&n;&t;&t;W.Zimmermann, Dec. 16, 1994        &n;&t;V0.6    Version for being included in the standard Linux kernel.&n;&t;&t;Renamed source and header file to aztcd.c and aztcd.h&n;&t;&t;W.Zimmermann, Dec. 24, 1994&n;&t;V0.7    Changed VERIFY_READ to VERIFY_WRITE in aztcd_ioctl, case&n;&t;&t;CDROMREADMODE1 and CDROMREADMODE2; bug fix in the ioctl,&n;&t;&t;which causes kernel crashes when playing audio, changed &n;&t;&t;include-files (config.h instead of autoconf.h, removed&n;&t;&t;delay.h)&n;&t;&t;W.Zimmermann, Jan. 8, 1995&n;&t;V0.72   Some more modifications for adaption to the standard kernel.&n;&t;&t;W.Zimmermann, Jan. 16, 1995&n;        V0.80   aztcd is now part of the standard kernel since version 1.1.83.&n;                Modified the SET_TIMER and CLEAR_TIMER macros to comply with&n;                the new timer scheme.&n;                W.Zimmermann, Jan. 21, 1995&n;        V0.90   Included CDROMVOLCTRL, but with my Aztech drive I can only turn&n;                the channels on and off. If it works better with your drive, &n;                please mail me. Also implemented ACMD_CLOSE for CDROMSTART.&n;                W.Zimmermann, Jan. 24, 1995&n;        V1.00   Implemented close and lock tray commands. Patches supplied by&n;&t;&t;Frank Racis        &n;                Added support for loadable MODULEs, so aztcd can now also be&n;                loaded by insmod and removed by rmmod during run time&n;                Werner Zimmermann, Mar. 24, 95&n;        V1.10   Implemented soundcard configuration for Orchid CDS-3110 drives&n;                connected to Soundwave32 cards. Release for LST 2.1.&n;                (still experimental)&n;                Werner Zimmermann, May 8, 95&n;        V1.20   Implemented limited support for DOSEMU0.60&squot;s cdrom.c. Now it works, but&n;                sometimes DOSEMU may hang for 30 seconds or so. A fully functional ver-&n;                sion needs an update of Dosemu0.60&squot;s cdrom.c, which will come with the &n;                next revision of Dosemu.&n;                Also Soundwave32 support now works.&n;                Werner Zimmermann, May 22, 95&n;&t;V1.30   Auto-eject feature. Inspired by Franc Racis (racis@psu.edu)&n;&t;        Werner Zimmermann, July 4, 95&n;&t;V1.40   Started multisession support. Implementation copied from mcdx.c&n;&t;        by Heiko Schlittermann. Not tested yet.&n;&t;        Werner Zimmermann, July 15, 95&n;        V1.50   Implementation of ioctl CDROMRESET, continued multisession, began&n;                XA, but still untested. Heavy modifications to drive status de-&n;                tection.&n;                Werner Zimmermann, July 25, 95&n;        V1.60   XA support now should work. Speeded up drive recognition in cases, &n;                where no drive is installed.&n;                Werner Zimmermann, August 8, 1995&n;        V1.70   Multisession support now is completed, but there is still not &n;                enough testing done. If you can test it, please contact me. For&n;                details please read /usr/src/linux/Documentation/cdrom/aztcd&n;                Werner Zimmermann, August 19, 1995&n;        V1.80   Modification to suit the new kernel boot procedure introduced&n;                with kernel 1.3.33. Will definitely not work with older kernels.&n;                Programming done by Linus himself.&n;                Werner Zimmermann, October 11, 1995&n;&t;V1.90   Support for Conrad TXC drives, thank&squot;s to Jochen Kunz and Olaf Kaluza.&n;&t;        Werner Zimmermann, October 21, 1995&n;        V2.00   Changed #include &quot;blk.h&quot; to &lt;linux/blk.h&gt; as the directory&n;                structure was changed. README.aztcd is now /usr/src/docu-&n;                mentation/cdrom/aztcd&n;                Werner Zimmermann, November 10, 95&n;        V2.10   Started to modify azt_poll to prevent reading beyond end of&n;                tracks.&n;                Werner Zimmermann, December 3, 95&n;        V2.20   Changed some comments&n;                Werner Zimmermann, April 1, 96&n;        V2.30   Implemented support for CyCDROM CR520, CR940, Code for CR520 &n;        &t;delivered by H.Berger with preworks by E.Moenkeberg.&n;                Werner Zimmermann, April 29, 96&n;        V2.40   Reorganized the placement of functions in the source code file&n;                to reflect the layered approach; did not actually change code&n;                Werner Zimmermann, May 1, 96&n;        V2.50   Heiko Eissfeldt suggested to remove some VERIFY_READs in &n;                aztcd_ioctl; check_aztcd_media_change modified &n;                Werner Zimmermann, May 16, 96       &n;&t;V2.60   Implemented Auto-Probing; made changes for kernel&squot;s 2.1.xx blocksize&n;                Adaption to linux kernel &gt; 2.1.0&n;&t;&t;Werner Zimmermann, Nov 29, 97&n;&t;&t;&n;        November 1999 -- Make kernel-parameter implementation work with 2.3.x &n;&t;                 Removed init_module &amp; cleanup_module in favor of &n;&t;&t;&t; module_init &amp; module_exit.&n;&t;&t;&t; Torben Mathiasen &lt;tmm@image.dk&gt;&n;*/
macro_line|#include &lt;linux/version.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR AZTECH_CDROM_MAJOR 
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;aztcd.h&quot;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#ifndef AZT_KERNEL_PRIOR_2_1
macro_line|#include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef AZT_KERNEL_PRIOR_2_1
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#else
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|aztcd_blocksizes
r_static
r_int
id|aztcd_blocksizes
(braket
l_int|1
)braket
op_assign
(brace
l_int|2048
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*###########################################################################&n;  Defines&n;  ###########################################################################&n;*/
DECL|macro|SET_TIMER
mdefine_line|#define SET_TIMER(func, jifs)   delay_timer.expires = jiffies + (jifs); &bslash;&n;                                delay_timer.function = (void *) (func); &bslash;&n;                                add_timer(&amp;delay_timer); 
DECL|macro|CLEAR_TIMER
mdefine_line|#define CLEAR_TIMER             del_timer(&amp;delay_timer);
DECL|macro|RETURNM
mdefine_line|#define RETURNM(message,value) {printk(&quot;aztcd: Warning: %s failed&bslash;n&quot;,message);&bslash;&n;                                return value;}
DECL|macro|RETURN
mdefine_line|#define RETURN(message)        {printk(&quot;aztcd: Warning: %s failed&bslash;n&quot;,message);&bslash;&n;                                return;}
multiline_comment|/* Macros to switch the IDE-interface to the slave device and back to the master*/
DECL|macro|SWITCH_IDE_SLAVE
mdefine_line|#define SWITCH_IDE_SLAVE  outb_p(0xa0,azt_port+6); &bslash;&n;&t;                  outb_p(0x10,azt_port+6); &bslash;&n;&t;                  outb_p(0x00,azt_port+7); &bslash;&n;&t;                  outb_p(0x10,azt_port+6); 
DECL|macro|SWITCH_IDE_MASTER
mdefine_line|#define SWITCH_IDE_MASTER outb_p(0xa0,azt_port+6);
macro_line|#if 0
mdefine_line|#define AZT_TEST
mdefine_line|#define AZT_TEST1 /* &lt;int-..&gt; */
mdefine_line|#define AZT_TEST2 /* do_aztcd_request */
mdefine_line|#define AZT_TEST3 /* AZT_S_state */
mdefine_line|#define AZT_TEST4 /* QUICK_LOOP-counter */
mdefine_line|#define AZT_TEST5 /* port(1) state */
mdefine_line|#define AZT_DEBUG
mdefine_line|#define AZT_DEBUG_MULTISESSION
macro_line|#endif
DECL|macro|CURRENT_VALID
mdefine_line|#define CURRENT_VALID &bslash;&n;  (!QUEUE_EMPTY &amp;&amp; MAJOR(CURRENT -&gt; rq_dev) == MAJOR_NR &amp;&amp; CURRENT -&gt; cmd == READ &bslash;&n;   &amp;&amp; CURRENT -&gt; sector != -1)
DECL|macro|AFL_STATUSorDATA
mdefine_line|#define AFL_STATUSorDATA (AFL_STATUS | AFL_DATA)
DECL|macro|AZT_BUF_SIZ
mdefine_line|#define AZT_BUF_SIZ 16
DECL|macro|READ_TIMEOUT
mdefine_line|#define READ_TIMEOUT 3000
DECL|macro|azt_port
mdefine_line|#define azt_port aztcd  /*needed for the modutils*/
macro_line|#ifndef AZT_KERNEL_PRIOR_2_1 
DECL|macro|memcpy_fromfs
mdefine_line|#define  memcpy_fromfs copy_from_user
DECL|macro|memcpy_tofs
mdefine_line|#define  memcpy_tofs   copy_to_user
macro_line|#endif
multiline_comment|/*##########################################################################&n;  Type Definitions&n;  ##########################################################################&n;*/
DECL|enum|azt_state_e
r_enum
id|azt_state_e
DECL|enumerator|AZT_S_IDLE
(brace
id|AZT_S_IDLE
comma
multiline_comment|/* 0 */
DECL|enumerator|AZT_S_START
id|AZT_S_START
comma
multiline_comment|/* 1 */
DECL|enumerator|AZT_S_MODE
id|AZT_S_MODE
comma
multiline_comment|/* 2 */
DECL|enumerator|AZT_S_READ
id|AZT_S_READ
comma
multiline_comment|/* 3 */
DECL|enumerator|AZT_S_DATA
id|AZT_S_DATA
comma
multiline_comment|/* 4 */
DECL|enumerator|AZT_S_STOP
id|AZT_S_STOP
comma
multiline_comment|/* 5 */
DECL|enumerator|AZT_S_STOPPING
id|AZT_S_STOPPING
multiline_comment|/* 6 */
)brace
suffix:semicolon
DECL|enum|azt_read_modes
r_enum
id|azt_read_modes
DECL|enumerator|AZT_MODE_0
(brace
id|AZT_MODE_0
comma
multiline_comment|/*read mode for audio disks, not supported by Aztech firmware*/
DECL|enumerator|AZT_MODE_1
id|AZT_MODE_1
comma
multiline_comment|/*read mode for normal CD-ROMs*/
DECL|enumerator|AZT_MODE_2
id|AZT_MODE_2
multiline_comment|/*read mode for XA CD-ROMs*/
)brace
suffix:semicolon
multiline_comment|/*##########################################################################&n;  Global Variables&n;  ##########################################################################&n;*/
DECL|variable|aztPresent
r_static
r_int
id|aztPresent
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_transfer_is_active
r_static
r_volatile
r_int
id|azt_transfer_is_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_buf
r_static
r_char
id|azt_buf
(braket
id|CD_FRAMESIZE_RAW
op_star
id|AZT_BUF_SIZ
)braket
suffix:semicolon
multiline_comment|/*buffer for block size conversion*/
macro_line|#if AZT_PRIVATE_IOCTLS
DECL|variable|buf
r_static
r_char
id|buf
(braket
id|CD_FRAMESIZE_RAW
)braket
suffix:semicolon
multiline_comment|/*separate buffer for the ioctls*/
macro_line|#endif
DECL|variable|azt_buf_bn
DECL|variable|azt_next_bn
r_static
r_volatile
r_int
id|azt_buf_bn
(braket
id|AZT_BUF_SIZ
)braket
comma
id|azt_next_bn
suffix:semicolon
DECL|variable|azt_buf_in
DECL|variable|azt_buf_out
r_static
r_volatile
r_int
id|azt_buf_in
comma
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|azt_error
r_static
r_volatile
r_int
id|azt_error
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_open_count
r_static
r_int
id|azt_open_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_state
r_static
r_volatile
r_enum
id|azt_state_e
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
macro_line|#ifdef AZT_TEST3
DECL|variable|azt_state_old
r_static
r_volatile
r_enum
id|azt_state_e
id|azt_state_old
op_assign
id|AZT_S_STOP
suffix:semicolon
DECL|variable|azt_st_old
r_static
r_volatile
r_int
id|azt_st_old
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|azt_read_mode
r_static
r_volatile
r_enum
id|azt_read_modes
id|azt_read_mode
op_assign
id|AZT_MODE_1
suffix:semicolon
DECL|variable|azt_mode
r_static
r_int
id|azt_mode
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|azt_read_count
r_static
r_volatile
r_int
id|azt_read_count
op_assign
l_int|1
suffix:semicolon
DECL|variable|azt_port
r_static
r_int
id|azt_port
op_assign
id|AZT_BASE_ADDR
suffix:semicolon
macro_line|#ifndef AZT_KERNEL_PRIOR_2_1
id|MODULE_PARM
c_func
(paren
id|azt_port
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|azt_port_auto
r_static
r_int
id|azt_port_auto
(braket
l_int|16
)braket
op_assign
id|AZT_BASE_AUTO
suffix:semicolon
DECL|variable|azt_cont
r_static
r_char
id|azt_cont
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_init_end
r_static
r_char
id|azt_init_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_auto_eject
r_static
r_char
id|azt_auto_eject
op_assign
id|AZT_AUTO_EJECT
suffix:semicolon
DECL|variable|AztTimeout
DECL|variable|AztTries
r_static
r_int
id|AztTimeout
comma
id|AztTries
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|azt_waitq
)paren
suffix:semicolon
DECL|variable|delay_timer
r_static
r_struct
id|timer_list
id|delay_timer
suffix:semicolon
DECL|variable|DiskInfo
r_static
r_struct
id|azt_DiskInfo
id|DiskInfo
suffix:semicolon
DECL|variable|Toc
r_static
r_struct
id|azt_Toc
id|Toc
(braket
id|MAX_TRACKS
)braket
suffix:semicolon
DECL|variable|azt_Play
r_static
r_struct
id|azt_Play_msf
id|azt_Play
suffix:semicolon
DECL|variable|aztAudioStatus
r_static
r_int
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
DECL|variable|aztDiskChanged
r_static
r_char
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
DECL|variable|aztTocUpToDate
r_static
r_char
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
DECL|variable|aztIndatum
r_static
r_int
r_char
id|aztIndatum
suffix:semicolon
DECL|variable|aztTimeOutCount
r_static
r_int
r_int
id|aztTimeOutCount
suffix:semicolon
DECL|variable|aztCmd
r_static
r_int
id|aztCmd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*###########################################################################&n;   Function Prototypes&n;  ###########################################################################&n;*/
multiline_comment|/* CDROM Drive Low Level I/O Functions */
r_void
id|op_ok
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|pa_ok
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|sten_low
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|dten_low
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|statusAzt
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|aztStatTimer
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* CDROM Drive Command Functions */
r_static
r_int
id|aztSendCmd
c_func
(paren
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|sendAztCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|azt_Play_msf
op_star
id|params
)paren
suffix:semicolon
r_static
r_int
id|aztSeek
c_func
(paren
r_struct
id|azt_Play_msf
op_star
id|params
)paren
suffix:semicolon
r_static
r_int
id|aztSetDiskType
c_func
(paren
r_int
id|type
)paren
suffix:semicolon
r_static
r_int
id|aztStatus
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|getAztStatus
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztPlay
c_func
(paren
r_struct
id|azt_Play_msf
op_star
id|arg
)paren
suffix:semicolon
r_static
r_void
id|aztCloseDoor
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|aztLockDoor
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|aztUnlockDoor
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztGetValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
suffix:semicolon
r_static
r_int
id|aztGetQChannelInfo
c_func
(paren
r_struct
id|azt_Toc
op_star
id|qp
)paren
suffix:semicolon
r_static
r_int
id|aztUpdateToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztGetDiskInfo
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#if AZT_MULTISESSION 
r_static
r_int
id|aztGetMultiDiskInfo
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|aztGetToc
c_func
(paren
r_int
id|multi
)paren
suffix:semicolon
multiline_comment|/* Kernel Interface Functions */
r_static
r_int
id|check_aztcd_media_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
suffix:semicolon
r_static
r_int
id|aztcd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|azt_transfer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_aztcd_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|azt_invalidate_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|aztcd_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
suffix:semicolon
macro_line|#ifdef AZT_KERNEL_PRIOR_2_1
r_static
r_void
id|aztcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
macro_line|#else
r_static
r_int
id|aztcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
macro_line|#endif
r_int
id|aztcd_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|azt_fops
r_static
r_struct
id|block_device_operations
id|azt_fops
op_assign
(brace
id|open
suffix:colon
id|aztcd_open
comma
id|release
suffix:colon
id|aztcd_release
comma
id|ioctl
suffix:colon
id|aztcd_ioctl
comma
id|check_media_change
suffix:colon
id|check_aztcd_media_change
comma
)brace
suffix:semicolon
multiline_comment|/* Aztcd State Machine: Controls Drive Operating State */
r_static
r_void
id|azt_poll
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Miscellaneous support functions */
r_static
r_void
id|azt_hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
suffix:semicolon
r_static
r_int
id|azt_msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
suffix:semicolon
r_static
r_void
id|azt_bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|azt_bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
suffix:semicolon
multiline_comment|/*##########################################################################&n;  CDROM Drive Low Level I/O Functions&n;  ##########################################################################&n;*/
multiline_comment|/* Macros for the drive hardware interface handshake, these macros use&n;   busy waiting */
multiline_comment|/* Wait for OP_OK = drive answers with AFL_OP_OK after receiving a command*/
DECL|macro|OP_OK
macro_line|# define OP_OK op_ok()
DECL|function|op_ok
r_void
id|op_ok
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait OP_OK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_ne
id|AFL_OP_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for PA_OK = drive answers with AFL_PA_OK after receiving parameters*/
DECL|macro|PA_OK
macro_line|# define PA_OK pa_ok()
DECL|function|pa_ok
r_void
id|pa_ok
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait PA_OK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_ne
id|AFL_PA_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for STEN=Low = handshake signal &squot;AFL_.._OK available or command executed*/
DECL|macro|STEN_LOW
macro_line|# define STEN_LOW  sten_low()
DECL|function|sten_low
r_void
id|sten_low
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
r_if
c_cond
(paren
id|azt_init_end
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait STEN_LOW commands:%x&bslash;n&quot;
comma
id|aztCmd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_STATUS
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for DTEN=Low = handshake signal &squot;Data available&squot;*/
DECL|macro|DTEN_LOW
macro_line|# define DTEN_LOW dten_low()
DECL|function|dten_low
r_void
id|dten_low
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait DTEN_OK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_DATA
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Macro for timer wait on STEN=Low, should only be used for &squot;slow&squot; commands;&n; * may cause kernel panic when used in the wrong place&n;*/
DECL|macro|STEN_LOW_WAIT
mdefine_line|#define STEN_LOW_WAIT   statusAzt()
DECL|function|statusAzt
r_void
id|statusAzt
c_func
(paren
r_void
)paren
(brace
id|AztTimeout
op_assign
id|AZT_STATUS_DELAY
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|aztStatTimer
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|azt_waitq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AztTimeout
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait STEN_LOW_WAIT command:%x&bslash;n&quot;
comma
id|aztCmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|aztStatTimer
r_static
r_void
id|aztStatTimer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUS
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|azt_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|AztTimeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|AztTimeout
op_le
l_int|0
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|azt_waitq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Error aztStatTimer: Timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|aztStatTimer
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/*##########################################################################&n;  CDROM Drive Command Functions&n;  ##########################################################################&n;*/
multiline_comment|/* &n; * Send a single command, return -1 on error, else 0&n;*/
DECL|function|aztSendCmd
r_static
r_int
id|aztSendCmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|retry
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: Executing command %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|azt_port
op_eq
l_int|0x1f0
)paren
op_logical_or
(paren
id|azt_port
op_eq
l_int|0x170
)paren
)paren
id|SWITCH_IDE_SLAVE
suffix:semicolon
multiline_comment|/*switch IDE interface to slave configuration*/
id|aztCmd
op_assign
id|cmd
suffix:semicolon
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUS
)paren
r_break
suffix:semicolon
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* if status left from last command, read and */
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* discard it */
r_do
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_DATA
)paren
r_break
suffix:semicolon
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* if data left from last command, read and */
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* discard it */
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|AZT_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
(paren
r_int
r_char
)paren
id|cmd
comma
id|CMD_PORT
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|AFL_OP_OK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*OP_OK?*/
r_if
c_cond
(paren
id|data
op_eq
id|AFL_OP_ERR
)paren
(brace
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;### Error 1 aztcd: aztSendCmd %x  Error Code %x&bslash;n&quot;
comma
id|cmd
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|AZT_RETRY_ATTEMPTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;### Error 2 aztcd: aztSendCmd %x &bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|azt_error
op_assign
l_int|0xA5
suffix:semicolon
)brace
id|RETURNM
c_func
(paren
l_string|&quot;aztSendCmd&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a play or read command to the drive, return -1 on error, else 0&n;*/
DECL|function|sendAztCmd
r_static
r_int
id|sendAztCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|azt_Play_msf
op_star
id|params
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|retry
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: play start=%02x:%02x:%02x  end=%02x:%02x:%02x&bslash;n&quot;
comma
"&bslash;"
id|params-&gt;start.min
comma
id|params-&gt;start.sec
comma
id|params-&gt;start.frame
comma
"&bslash;"
id|params-&gt;end.min
comma
id|params-&gt;end.sec
comma
id|params-&gt;end.frame
)paren
suffix:semicolon
macro_line|#endif   
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|AZT_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|aztSendCmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.min
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.sec
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.frame
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.min
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.sec
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.frame
comma
id|CMD_PORT
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_OK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*PA_OK ?*/
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_ERR
)paren
(brace
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;### Error 1 aztcd: sendAztCmd %x  Error Code %x&bslash;n&quot;
comma
id|cmd
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|AZT_RETRY_ATTEMPTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;### Error 2 aztcd: sendAztCmd %x&bslash;n &quot;
comma
id|cmd
)paren
suffix:semicolon
id|azt_error
op_assign
l_int|0xA5
suffix:semicolon
)brace
id|RETURNM
c_func
(paren
l_string|&quot;sendAztCmd&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a seek command to the drive, return -1 on error, else 0&n;*/
DECL|function|aztSeek
r_static
r_int
id|aztSeek
c_func
(paren
r_struct
id|azt_Play_msf
op_star
id|params
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|retry
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: aztSeek %02x:%02x:%02x&bslash;n&quot;
comma
"&bslash;"
id|params-&gt;start.min
comma
id|params-&gt;start.sec
comma
id|params-&gt;start.frame
)paren
suffix:semicolon
macro_line|#endif   
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|AZT_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|aztSendCmd
c_func
(paren
id|ACMD_SEEK
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.min
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.sec
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.frame
comma
id|CMD_PORT
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_OK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*PA_OK ?*/
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_ERR
)paren
(brace
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;### Error 1 aztcd: aztSeek&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|AZT_RETRY_ATTEMPTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;### Error 2 aztcd: aztSeek&bslash;n &quot;
)paren
suffix:semicolon
id|azt_error
op_assign
l_int|0xA5
suffix:semicolon
)brace
id|RETURNM
c_func
(paren
l_string|&quot;aztSeek&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Send a Set Disk Type command&n;   does not seem to work with Aztech drives, behavior is completely indepen-&n;   dent on which mode is set ???&n;*/
DECL|function|aztSetDiskType
r_static
r_int
id|aztSetDiskType
c_func
(paren
r_int
id|type
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|retry
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: set disk type command: type= %i&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|AZT_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|aztSendCmd
c_func
(paren
id|ACMD_SET_DISK_TYPE
)paren
suffix:semicolon
id|outb
c_func
(paren
id|type
comma
id|CMD_PORT
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_OK
)paren
multiline_comment|/*PA_OK ?*/
(brace
id|azt_read_mode
op_assign
id|type
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_ERR
)paren
(brace
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;### Error 1 aztcd: aztSetDiskType %x Error Code %x&bslash;n&quot;
comma
id|type
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|AZT_RETRY_ATTEMPTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;### Error 2 aztcd: aztSetDiskType %x&bslash;n &quot;
comma
id|type
)paren
suffix:semicolon
id|azt_error
op_assign
l_int|0xA5
suffix:semicolon
)brace
id|RETURNM
c_func
(paren
l_string|&quot;aztSetDiskType&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* used in azt_poll to poll the status, expects another program to issue a &n; * ACMD_GET_STATUS directly before &n; */
DECL|function|aztStatus
r_static
r_int
id|aztStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|st
suffix:semicolon
multiline_comment|/*&t;int i;&n;&n;&t;i = inb(STATUS_PORT) &amp; AFL_STATUS;    is STEN=0?    ???&n;&t;if (!i)&n;*/
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
OL
id|AZT_TIMEOUT
)paren
(brace
id|st
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|st
suffix:semicolon
)brace
r_else
id|RETURNM
c_func
(paren
l_string|&quot;aztStatus&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the drive status&n; */
DECL|function|getAztStatus
r_static
r_int
id|getAztStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;getAztStatus 1&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: Status = %x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_eq
l_int|0xFF
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_CMD_CHECK
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: AST_CMD_CHECK error or no status available&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|st
op_amp
id|AST_MODE_BITS
)paren
op_ne
id|AST_BUSY
)paren
op_logical_and
(paren
id|aztAudioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
)paren
multiline_comment|/* XXX might be an error? look at q-channel? */
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a &squot;Play&squot; command and get the status.  Use only from the top half.&n; */
DECL|function|aztPlay
r_static
r_int
id|aztPlay
c_func
(paren
r_struct
id|azt_Play_msf
op_star
id|arg
)paren
(brace
r_if
c_cond
(paren
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_AUDIO
comma
id|arg
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztPlay&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Subroutines to automatically close the door (tray) and &n; * lock it closed when the cd is mounted.  Leave the tray&n; * locking as an option&n; */
DECL|function|aztCloseDoor
r_static
r_void
id|aztCloseDoor
c_func
(paren
r_void
)paren
(brace
id|aztSendCmd
c_func
(paren
id|ACMD_CLOSE
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|aztLockDoor
r_static
r_void
id|aztLockDoor
c_func
(paren
r_void
)paren
(brace
macro_line|#if AZT_ALLOW_TRAY_LOCK
id|aztSendCmd
c_func
(paren
id|ACMD_LOCK
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|aztUnlockDoor
r_static
r_void
id|aztUnlockDoor
c_func
(paren
r_void
)paren
(brace
macro_line|#if AZT_ALLOW_TRAY_LOCK
id|aztSendCmd
c_func
(paren
id|ACMD_UNLOCK
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a value from the drive.  Should return quickly, so a busy wait&n; * is used to avoid excessive rescheduling. The read command itself must&n; * be issued with aztSendCmd() directly before&n; */
DECL|function|aztGetValue
r_static
r_int
id|aztGetValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
(brace
r_int
id|s
suffix:semicolon
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: aztGetValue timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|s
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
op_star
id|result
op_assign
(paren
r_int
r_char
)paren
id|s
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the current Q-channel info.  Also used for reading the&n; * table of contents.&n; */
DECL|function|aztGetQChannelInfo
r_int
id|aztGetQChannelInfo
c_func
(paren
r_struct
id|azt_Toc
op_star
id|qp
)paren
(brace
r_int
r_char
id|notUsed
suffix:semicolon
r_int
id|st
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetQChannelInfo  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 1&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_Q_CHANNEL
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 2&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*STEN_LOW_WAIT; ??? Dosemu0.60&squot;s cdrom.c does not like STEN_LOW_WAIT here*/
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|notUsed
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 3&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*??? Nullbyte einlesen*/
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_MODE_BITS
)paren
op_eq
id|AST_INITIAL
)paren
(brace
id|qp-&gt;ctrl_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* when audio stop ACMD_GET_Q_CHANNEL returns */
id|qp-&gt;track
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only one byte with Aztech drives */
id|qp-&gt;pointIndex
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;trackTime.min
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;trackTime.sec
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;trackTime.frame
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;diskTime.min
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;diskTime.sec
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;diskTime.frame
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|ctrl_addr
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|track
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|pointIndex
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.min
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.sec
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.frame
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|notUsed
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.min
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.sec
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.frame
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetQChannelInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztGetQChannelInfo  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC) and TOC header if necessary&n; */
DECL|function|aztUpdateToc
r_static
r_int
id|aztUpdateToc
c_func
(paren
)paren
(brace
r_int
id|st
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztUpdateToc  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif  
r_if
c_cond
(paren
id|aztTocUpToDate
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aztGetDiskInfo
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|aztGetToc
c_func
(paren
l_int|0
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*audio disk detection&n;          with my Aztech drive there is no audio status bit, so I use the copy&n;          protection bit of the first track. If this track is copy protected &n;          (copy bit = 0), I assume, it&squot;s an audio  disk. Strange, but works ??? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|Toc
(braket
id|DiskInfo.first
)braket
dot
id|ctrl_addr
op_amp
l_int|0x40
)paren
)paren
id|DiskInfo.audio
op_assign
l_int|1
suffix:semicolon
r_else
id|DiskInfo.audio
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XA detection */
r_if
c_cond
(paren
op_logical_neg
id|DiskInfo.audio
)paren
(brace
id|azt_Play.start.min
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*XA detection only seems to work*/
id|azt_Play.start.sec
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*when we play a track*/
id|azt_Play.start.frame
op_assign
l_int|0
suffix:semicolon
id|azt_Play.end.min
op_assign
l_int|0
suffix:semicolon
id|azt_Play.end.sec
op_assign
l_int|0
suffix:semicolon
id|azt_Play.end.frame
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_READ
comma
op_amp
id|azt_Play
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
r_for
c_loop
(paren
id|st
op_assign
l_int|0
suffix:semicolon
id|st
OL
id|CD_FRAMESIZE
suffix:semicolon
id|st
op_increment
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
id|DiskInfo.xa
op_assign
id|getAztStatus
c_func
(paren
)paren
op_amp
id|AST_MODE
suffix:semicolon
r_if
c_cond
(paren
id|DiskInfo.xa
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: XA support experimental - mail results to Werner.Zimmermann@fht-esslingen.de&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*multisession detection&n;          support for multisession CDs is done automatically with Aztech drives,&n;          we don&squot;t have to take care about TOC redirection; if we want the isofs&n;          to take care about redirection, we have to set AZT_MULTISESSION to 1*/
id|DiskInfo.multi
op_assign
l_int|0
suffix:semicolon
macro_line|#if AZT_MULTISESSION
r_if
c_cond
(paren
id|DiskInfo.xa
)paren
(brace
id|aztGetMultiDiskInfo
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*here Disk.Info.multi is set*/
)brace
macro_line|#endif
r_if
c_cond
(paren
id|DiskInfo.multi
)paren
(brace
id|DiskInfo.lastSession.min
op_assign
id|Toc
(braket
id|DiskInfo.next
)braket
dot
id|diskTime.min
suffix:semicolon
id|DiskInfo.lastSession.sec
op_assign
id|Toc
(braket
id|DiskInfo.next
)braket
dot
id|diskTime.sec
suffix:semicolon
id|DiskInfo.lastSession.frame
op_assign
id|Toc
(braket
id|DiskInfo.next
)braket
dot
id|diskTime.frame
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Multisession support experimental&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|DiskInfo.lastSession.min
op_assign
id|Toc
(braket
id|DiskInfo.first
)braket
dot
id|diskTime.min
suffix:semicolon
id|DiskInfo.lastSession.sec
op_assign
id|Toc
(braket
id|DiskInfo.first
)braket
dot
id|diskTime.sec
suffix:semicolon
id|DiskInfo.lastSession.frame
op_assign
id|Toc
(braket
id|DiskInfo.first
)braket
dot
id|diskTime.frame
suffix:semicolon
)brace
id|aztTocUpToDate
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztUpdateToc  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the table of contents header, i.e. no. of tracks and start of first &n; * track&n; */
DECL|function|aztGetDiskInfo
r_static
r_int
id|aztGetDiskInfo
c_func
(paren
)paren
(brace
r_int
id|limit
suffix:semicolon
r_int
r_char
id|test
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetDiskInfo  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_SEEK_TO_LEADIN
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetDiskInfo 1&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
id|test
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetDiskInfo 2&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA0
)paren
multiline_comment|/*Number of FirstTrack*/
(brace
id|DiskInfo.first
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.first
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.first
)paren
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x01
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA1
)paren
multiline_comment|/*Number of LastTrack*/
(brace
id|DiskInfo.last
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.last
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.last
)paren
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x02
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA2
)paren
multiline_comment|/*DiskLength*/
(brace
id|DiskInfo.diskLength.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.diskLength.sec
op_assign
id|qInfo.diskTime.sec
suffix:semicolon
id|DiskInfo.diskLength.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|qInfo.pointIndex
op_eq
id|DiskInfo.first
)paren
op_logical_and
(paren
id|test
op_amp
l_int|0x01
)paren
)paren
multiline_comment|/*StartTime of First Track*/
(brace
id|DiskInfo.firstTrack.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.firstTrack.sec
op_assign
id|qInfo.diskTime.sec
suffix:semicolon
id|DiskInfo.firstTrack.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x08
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test
op_eq
l_int|0x0F
)paren
r_break
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
(paren
l_string|&quot;aztcd: exiting aztGetDiskInfo  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Disk Info: first %d last %d length %02X:%02X.%02X dez  first %02X:%02X.%02X dez&bslash;n&quot;
comma
id|DiskInfo.first
comma
id|DiskInfo.last
comma
id|DiskInfo.diskLength.min
comma
id|DiskInfo.diskLength.sec
comma
id|DiskInfo.diskLength.frame
comma
id|DiskInfo.firstTrack.min
comma
id|DiskInfo.firstTrack.sec
comma
id|DiskInfo.firstTrack.frame
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test
op_ne
l_int|0x0F
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if AZT_MULTISESSION
multiline_comment|/*&n; * Get Multisession Disk Info&n; */
DECL|function|aztGetMultiDiskInfo
r_static
r_int
id|aztGetMultiDiskInfo
c_func
(paren
r_void
)paren
(brace
r_int
id|limit
comma
id|k
op_assign
l_int|5
suffix:semicolon
r_int
r_char
id|test
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetMultiDiskInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|azt_Play.start.min
op_assign
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime.min
suffix:semicolon
id|azt_Play.start.sec
op_assign
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime.sec
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime.frame
suffix:semicolon
id|test
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|30
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
multiline_comment|/*Seek for LeadIn of next session*/
(brace
r_if
c_cond
(paren
id|aztSeek
c_func
(paren
op_amp
id|azt_Play
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetMultiDiskInfo 1&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetMultiDiskInfo 2&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qInfo.track
op_eq
l_int|0
)paren
op_logical_and
(paren
id|qInfo.pointIndex
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*LeadIn found*/
r_if
c_cond
(paren
(paren
id|azt_Play.start.sec
op_add_assign
l_int|10
)paren
OG
l_int|59
)paren
(brace
id|azt_Play.start.sec
op_assign
l_int|0
suffix:semicolon
id|azt_Play.start.min
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|limit
)paren
r_break
suffix:semicolon
multiline_comment|/*Check, if a leadin track was found, if not we&squot;re&n;                             at the end of the disk*/
macro_line|#ifdef AZT_DEBUG_MULTISESSION
id|printk
c_func
(paren
l_string|&quot;leadin found track %d  pointIndex %x  limit %d&bslash;n&quot;
comma
id|qInfo.track
comma
id|qInfo.pointIndex
comma
id|limit
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_increment
id|azt_Play.start.frame
OG
l_int|74
)paren
(brace
id|azt_Play.start.frame
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|azt_Play.start.sec
OG
l_int|59
)paren
(brace
id|azt_Play.start.sec
op_assign
l_int|0
suffix:semicolon
id|azt_Play.start.min
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|aztSeek
c_func
(paren
op_amp
id|azt_Play
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetMultiDiskInfo 3&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetMultiDiskInfo 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA0
)paren
multiline_comment|/*Number of NextTrack*/
(brace
id|DiskInfo.next
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.next
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.next
)paren
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x01
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA1
)paren
multiline_comment|/*Number of LastTrack*/
(brace
id|DiskInfo.last
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.last
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.last
)paren
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x02
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA2
)paren
multiline_comment|/*DiskLength*/
(brace
id|DiskInfo.diskLength.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.diskLength.sec
op_assign
id|qInfo.diskTime.sec
suffix:semicolon
id|DiskInfo.diskLength.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|qInfo.pointIndex
op_eq
id|DiskInfo.next
)paren
op_logical_and
(paren
id|test
op_amp
l_int|0x01
)paren
)paren
multiline_comment|/*StartTime of Next Track*/
(brace
id|DiskInfo.nextSession.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.nextSession.sec
op_assign
id|qInfo.diskTime.sec
suffix:semicolon
id|DiskInfo.nextSession.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x08
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test
op_eq
l_int|0x0F
)paren
r_break
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG_MULTISESSION
id|printk
(paren
l_string|&quot;MultiDisk Info: first %d next %d last %d length %02x:%02x.%02x dez  first %02x:%02x.%02x dez  next %02x:%02x.%02x dez&bslash;n&quot;
comma
id|DiskInfo.first
comma
id|DiskInfo.next
comma
id|DiskInfo.last
comma
id|DiskInfo.diskLength.min
comma
id|DiskInfo.diskLength.sec
comma
id|DiskInfo.diskLength.frame
comma
id|DiskInfo.firstTrack.min
comma
id|DiskInfo.firstTrack.sec
comma
id|DiskInfo.firstTrack.frame
comma
id|DiskInfo.nextSession.min
comma
id|DiskInfo.nextSession.sec
comma
id|DiskInfo.nextSession.frame
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test
op_ne
l_int|0x0F
)paren
r_break
suffix:semicolon
r_else
id|DiskInfo.multi
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*found TOC of more than one session*/
id|aztGetToc
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|k
)paren
(brace
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
(paren
l_string|&quot;aztcd: exiting aztGetMultiDiskInfo  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Read the table of contents (TOC)&n; */
DECL|function|aztGetToc
r_static
r_int
id|aztGetToc
c_func
(paren
r_int
id|multi
)paren
(brace
r_int
id|i
comma
id|px
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetToc  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|multi
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TRACKS
suffix:semicolon
id|i
op_increment
)paren
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|DiskInfo.last
op_plus
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|DiskInfo.next
suffix:semicolon
id|i
OL
id|MAX_TRACKS
suffix:semicolon
id|i
op_increment
)paren
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|DiskInfo.last
op_plus
l_int|4
op_minus
id|DiskInfo.next
suffix:semicolon
)brace
multiline_comment|/*Is there a good reason to stop motor before TOC read?&n;  if (aztSendCmd(ACMD_STOP)) RETURNM(&quot;aztGetToc 1&quot;,-1);&n;      STEN_LOW_WAIT;&n;*/
r_if
c_cond
(paren
op_logical_neg
id|multi
)paren
(brace
id|azt_mode
op_assign
l_int|0x05
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_SEEK_TO_LEADIN
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetToc 2&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|multi
)paren
(brace
r_if
c_cond
(paren
op_increment
id|azt_Play.start.sec
OG
l_int|59
)paren
(brace
id|azt_Play.start.sec
op_assign
l_int|0
suffix:semicolon
id|azt_Play.start.min
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztSeek
c_func
(paren
op_amp
id|azt_Play
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztGetToc 3&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|px
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|px
OG
l_int|0
op_logical_and
id|px
OL
id|MAX_TRACKS
op_logical_and
id|qInfo.track
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|Toc
(braket
id|px
)braket
dot
id|pointIndex
op_eq
l_int|0
)paren
(brace
id|Toc
(braket
id|px
)braket
op_assign
id|qInfo
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime
op_assign
id|DiskInfo.diskLength
suffix:semicolon
id|Toc
(braket
id|DiskInfo.last
)braket
dot
id|trackTime
op_assign
id|DiskInfo.diskLength
suffix:semicolon
macro_line|#ifdef AZT_DEBUG_MULTISESSION 
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztGetToc&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|DiskInfo.last
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X dez  %02X:%02X.%02X dez&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
OL
l_int|103
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X dez  %02X:%02X.%02X dez&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
id|limit
OG
l_int|0
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*##########################################################################&n;  Kernel Interface Functions&n;  ##########################################################################&n;*/
macro_line|#ifndef MODULE
DECL|function|aztcd_setup
r_static
r_int
id|__init
id|aztcd_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|azt_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|1
)paren
id|azt_cont
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;aztcd=&quot;
comma
id|aztcd_setup
)paren
suffix:semicolon
macro_line|#endif /* !MODULE */
multiline_comment|/* &n; * Checking if the media has been changed&n;*/
DECL|function|check_aztcd_media_change
r_static
r_int
id|check_aztcd_media_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_if
c_cond
(paren
id|aztDiskChanged
)paren
multiline_comment|/* disk changed */
(brace
id|aztDiskChanged
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no change */
)brace
multiline_comment|/*&n; * Kernel IO-controls&n;*/
DECL|function|aztcd_ioctl
r_static
r_int
id|aztcd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
comma
id|st
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tocHdr
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|azt_Toc
op_star
id|tocPtr
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztcd_ioctl - Command:%x   Time: %li&bslash;n&quot;
comma
id|cmd
comma
id|jiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd Status %x&bslash;n&quot;
comma
id|getAztStatus
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 1&quot;
comma
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getAztStatus
c_func
(paren
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 2&quot;
comma
op_minus
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|aztTocUpToDate
)paren
op_logical_or
(paren
id|aztDiskChanged
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_assign
id|aztUpdateToc
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 3&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* error reading TOC */
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive. Don&squot;t know, what to do,&n;&t;                        at least close the tray */
macro_line|#if AZT_PRIVATE_IOCTLS 
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_CLOSE
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 4&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 5&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
multiline_comment|/* should we do anything if it fails? */
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
r_if
c_cond
(paren
id|aztAudioStatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* didn&squot;t get q channel info */
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 7&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
id|azt_Play.start
op_assign
id|qInfo.diskTime
suffix:semicolon
multiline_comment|/* remember restart point */
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_PAUSE
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;aztcd_ioctl 8&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Play it again, Sam */
r_if
c_cond
(paren
id|aztAudioStatus
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* restart the drive at the saved position. */
id|i
op_assign
id|aztPlay
c_func
(paren
op_amp
id|azt_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMMULTISESSION
suffix:colon
multiline_comment|/*multisession support -- experimental*/
(brace
r_struct
id|cdrom_multisession
id|ms
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd ioctl MULTISESSION&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ms
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_MSF
)paren
(brace
id|ms.addr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.lastSession.min
)paren
suffix:semicolon
id|ms.addr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.lastSession.sec
)paren
suffix:semicolon
id|ms.addr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.lastSession.frame
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_LBA
)paren
id|ms.addr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|DiskInfo.lastSession
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms.xa_flag
op_assign
id|DiskInfo.xa
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ms
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
macro_line|#ifdef AZT_DEBUG 
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_MSF
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd multisession xa:%d, msf:%02x:%02x.%02x [%02x:%02x.%02x])&bslash;n&quot;
comma
id|ms.xa_flag
comma
id|ms.addr.msf.minute
comma
id|ms.addr.msf.second
comma
id|ms.addr.msf.frame
comma
id|DiskInfo.lastSession.min
comma
id|DiskInfo.lastSession.sec
comma
id|DiskInfo.lastSession.frame
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;aztcd multisession %d, lba:0x%08x [%02x:%02x.%02x])&bslash;n&quot;
comma
id|ms.xa_flag
comma
id|ms.addr.lba
comma
id|DiskInfo.lastSession.min
comma
id|DiskInfo.lastSession.sec
comma
id|DiskInfo.lastSession.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
template_param
id|DiskInfo.last
op_logical_or
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|DiskInfo.last
)paren
id|ti.cdti_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|azt_Play.start
op_assign
id|Toc
(braket
id|ti.cdti_trk0
)braket
dot
id|diskTime
suffix:semicolon
id|azt_Play.end
op_assign
id|Toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|diskTime
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|azt_Play.start.min
comma
id|azt_Play.start.sec
comma
id|azt_Play.start.frame
comma
id|azt_Play.end.min
comma
id|azt_Play.end.sec
comma
id|azt_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|aztPlay
c_func
(paren
op_amp
id|azt_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
multiline_comment|/*              if (aztAudioStatus == CDROM_AUDIO_PLAY) &n;&t;&t;{ if (aztSendCmd(ACMD_STOP)) RETURNM(&quot;aztcd_ioctl 9&quot;,-1);&n;&t;&t;  STEN_LOW;&n;&t;&t;  aztAudioStatus = CDROM_AUDIO_NO_STATUS;&n;&t;&t;}&n;*/
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
multiline_comment|/* convert to bcd */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min1
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec1
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame1
)paren
suffix:semicolon
id|azt_Play.start.min
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|azt_Play.start.sec
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
id|azt_Play.end.min
op_assign
id|msf.cdmsf_min1
suffix:semicolon
id|azt_Play.end.sec
op_assign
id|msf.cdmsf_sec1
suffix:semicolon
id|azt_Play.end.frame
op_assign
id|msf.cdmsf_frame1
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|azt_Play.start.min
comma
id|azt_Play.start.sec
comma
id|azt_Play.start.frame
comma
id|azt_Play.end.min
comma
id|azt_Play.end.sec
comma
id|azt_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|aztPlay
c_func
(paren
op_amp
id|azt_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|tocHdr.cdth_trk0
op_assign
id|DiskInfo.first
suffix:semicolon
id|tocHdr.cdth_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocHdr
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read an entry in the table of contents */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|aztTocUpToDate
)paren
op_logical_or
id|aztDiskChanged
)paren
id|aztUpdateToc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|DiskInfo.last
op_logical_or
id|entry.cdte_track
OL
id|DiskInfo.first
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|entry.cdte_track
)braket
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_LBA
)paren
id|entry.cdte_addr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|tocPtr
op_member_access_from_pointer
id|diskTime
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry.cdte_addr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.min
)paren
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.sec
)paren
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.frame
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
(brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztcd_ioctl - Error 1 - Command:%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
id|st
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_if
c_cond
(paren
id|st
)paren
(brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztcd_ioctl - Error 3 - Command:%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|subchnl.cdsc_audiostatus
op_assign
id|aztAudioStatus
suffix:semicolon
id|subchnl.cdsc_adr
op_assign
id|qInfo.ctrl_addr
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|qInfo.ctrl_addr
op_rshift
l_int|4
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.track
)paren
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|subchnl.cdsc_absaddr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|qInfo.diskTime
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|qInfo.trackTime
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/*default*/
(brace
id|subchnl.cdsc_format
op_assign
id|CDROM_MSF
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.diskTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.diskTime.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.trackTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.trackTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.trackTime.frame
)paren
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
(paren
r_struct
id|cdrom_subchnl
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control &n;&t; * With my Aztech CD268-01A volume control does not work, I can only&n;&t;   turn the channels on (any value !=0) or off (value==0). Maybe it&n;           works better with your drive */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|azt_Play.start.min
op_assign
l_int|0x21
suffix:semicolon
id|azt_Play.start.sec
op_assign
l_int|0x84
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|volctrl.channel0
suffix:semicolon
id|azt_Play.end.min
op_assign
id|volctrl.channel1
suffix:semicolon
id|azt_Play.end.sec
op_assign
id|volctrl.channel2
suffix:semicolon
id|azt_Play.end.frame
op_assign
id|volctrl.channel3
suffix:semicolon
id|sendAztCmd
c_func
(paren
id|ACMD_SET_VOLUME
comma
op_amp
id|azt_Play
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
id|aztUnlockDoor
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Assume user knows what they&squot;re doing */
multiline_comment|/* all drives can at least stop! */
r_if
c_cond
(paren
id|aztAudioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;azt_ioctl 10&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_EJECT
)paren
)paren
id|RETURNM
c_func
(paren
l_string|&quot;azt_ioctl 11&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMEJECT_SW
suffix:colon
id|azt_auto_eject
op_assign
(paren
r_char
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESET
suffix:colon
id|outb
c_func
(paren
id|ACMD_SOFT_RESET
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*send reset*/
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_ne
id|AFL_OP_OK
)paren
multiline_comment|/*OP_OK?*/
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: AZTECH CD-ROM drive does not respond&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*Take care, the following code is not compatible with other CD-ROM drivers,&n;  use it at your own risk with cdplay.c. Set AZT_PRIVATE_IOCTLS to 0 in aztcd.h,&n;  if you do not want to use it!&n;*/
macro_line|#if AZT_PRIVATE_IOCTLS 
r_case
id|CDROMREADCOOKED
suffix:colon
multiline_comment|/*read data in mode 1 (2048 Bytes)*/
r_case
id|CDROMREADRAW
suffix:colon
multiline_comment|/*read data in mode 2 (2336 Bytes)*/
(brace
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
multiline_comment|/* convert to bcd */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|msf.cdmsf_min1
op_assign
l_int|0
suffix:semicolon
id|msf.cdmsf_sec1
op_assign
l_int|0
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*read only one frame*/
id|azt_Play.start.min
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|azt_Play.start.sec
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
id|azt_Play.end.min
op_assign
id|msf.cdmsf_min1
suffix:semicolon
id|azt_Play.end.sec
op_assign
id|msf.cdmsf_sec1
suffix:semicolon
id|azt_Play.end.frame
op_assign
id|msf.cdmsf_frame1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMREADRAW
)paren
(brace
r_if
c_cond
(paren
id|DiskInfo.xa
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*XA Disks can&squot;t be read raw*/
)brace
r_else
(brace
r_if
c_cond
(paren
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_READ_RAW
comma
op_amp
id|azt_Play
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
id|insb
c_func
(paren
id|DATA_PORT
comma
id|buf
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/*CDROMREADCOOKED*/
(brace
r_if
c_cond
(paren
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_READ
comma
op_amp
id|azt_Play
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
id|insb
c_func
(paren
id|DATA_PORT
comma
id|buf
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|CDROMSEEK
suffix:colon
multiline_comment|/*seek msf address*/
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
multiline_comment|/* convert to bcd */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|azt_Play.start.min
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|azt_Play.start.sec
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
r_if
c_cond
(paren
id|aztSeek
c_func
(paren
op_amp
id|azt_Play
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /*end of incompatible code*/       
r_case
id|CDROMREADMODE1
suffix:colon
multiline_comment|/*set read data in mode 1*/
r_return
id|aztSetDiskType
c_func
(paren
id|AZT_MODE_1
)paren
suffix:semicolon
r_case
id|CDROMREADMODE2
suffix:colon
multiline_comment|/*set read data in mode 2*/
r_return
id|aztSetDiskType
c_func
(paren
id|AZT_MODE_2
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztcd_ioctl Command:%x  Time:%li&bslash;n&quot;
comma
id|cmd
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
DECL|function|azt_transfer
r_static
r_void
id|azt_transfer
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef AZT_TEST
id|printk
c_func
(paren
l_string|&quot;aztcd: executing azt_transfer Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_while
c_loop
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
(brace
r_int
id|bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AZT_BUF_SIZ
op_logical_and
id|azt_buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|AZT_BUF_SIZ
)paren
(brace
r_int
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
r_int
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_buf_out
op_ne
id|i
)paren
(brace
id|azt_buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|azt_buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT
op_member_access_from_pointer
id|buffer
comma
id|azt_buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|do_aztcd_request
r_static
r_void
id|do_aztcd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
macro_line|#ifdef AZT_TEST
id|printk
c_func
(paren
l_string|&quot; do_aztcd_request(%ld+%ld) Time:%li&bslash;n&quot;
comma
id|CURRENT
op_member_access_from_pointer
id|sector
comma
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DiskInfo.audio
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error, tried to mount an Audio CD&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|azt_transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|azt_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Want to read a block not in buffer */
r_if
c_cond
(paren
id|azt_state
op_eq
id|AZT_S_IDLE
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|aztTocUpToDate
)paren
op_logical_or
id|aztDiskChanged
)paren
(brace
r_if
c_cond
(paren
id|aztUpdateToc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|AztTries
op_assign
l_int|5
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|azt_poll
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|azt_transfer_is_active
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef AZT_TEST2
id|printk
c_func
(paren
l_string|&quot;azt_next_bn:%x  azt_buf_in:%x azt_buf_out:%x  azt_buf_bn:%x&bslash;n&quot;
comma
"&bslash;"
id|azt_next_bn
comma
id|azt_buf_in
comma
id|azt_buf_out
comma
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; do_aztcd_request ends  Time:%li&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|azt_invalidate_buffers
r_static
r_void
id|azt_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: executing azt_invalidate_buffers&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AZT_BUF_SIZ
suffix:semicolon
op_increment
id|i
)paren
id|azt_buf_bn
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the device special file.  Check that a disk is in.&n; */
DECL|function|aztcd_open
r_int
id|aztcd_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_int
id|st
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztcd_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|aztPresent
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* no hardware */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|azt_open_count
op_logical_and
id|azt_state
op_eq
id|AZT_S_IDLE
)paren
(brace
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check drive status */
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* drive doesn&squot;t respond */
r_if
c_cond
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
(brace
multiline_comment|/* close door, then get the status again. */
id|printk
c_func
(paren
l_string|&quot;aztcd: Door Open?&bslash;n&quot;
)paren
suffix:semicolon
id|aztCloseDoor
c_func
(paren
)paren
suffix:semicolon
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
)paren
multiline_comment|/*no disk in drive or changed*/
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Disk Changed or No Disk in Drive?&bslash;n&quot;
)paren
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztUpdateToc
c_func
(paren
)paren
)paren
r_goto
id|err_out
suffix:semicolon
)brace
op_increment
id|azt_open_count
suffix:semicolon
id|aztLockDoor
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztcd_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * On close, we flush all azt blocks from the buffer cache.&n; */
macro_line|#ifdef AZT_KERNEL_PRIOR_2_1
DECL|function|aztcd_release
r_static
r_void
id|aztcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
macro_line|#else
r_static
r_int
id|aztcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
macro_line|#endif
(brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: executing aztcd_release&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;inode: %p, inode-&gt;i_rdev: %x    file: %p&bslash;n&quot;
comma
id|inode
comma
id|inode-&gt;i_rdev
comma
id|file
)paren
suffix:semicolon
macro_line|#endif
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|azt_open_count
)paren
(brace
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|aztUnlockDoor
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_auto_eject
)paren
id|aztSendCmd
c_func
(paren
id|ACMD_EJECT
)paren
suffix:semicolon
id|CLEAR_TIMER
suffix:semicolon
)brace
macro_line|#ifdef AZT_KERNEL_PRIOR_2_1
r_return
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Test for presence of drive and initialize it.  Called at boot time.&n; */
DECL|function|aztcd_init
r_int
id|__init
id|aztcd_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|count
comma
id|max_count
suffix:semicolon
r_int
r_char
id|result
(braket
l_int|50
)braket
suffix:semicolon
r_int
id|st
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|azt_port
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no Aztech CD-ROM Initialization&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aztcd: AZTECH, ORCHID, OKANO, WEARNES, TXC, CyDROM CD-ROM Driver&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: (C) 1994-98 W.Zimmermann&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_port
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: KernelVersion=%s DriverVersion=%s For IDE/ATAPI-drives use ide-cd.c&bslash;n&quot;
comma
id|UTS_RELEASE
comma
id|AZT_VERSION
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;aztcd: DriverVersion=%s BaseAddress=0x%x  For IDE/ATAPI-drives use ide-cd.c&bslash;n&quot;
comma
id|AZT_VERSION
comma
id|azt_port
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: If you have problems, read /usr/src/linux/Documentation/cdrom/aztcd&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef AZT_SW32   /*CDROM connected to Soundwave32 card*/
r_if
c_cond
(paren
(paren
l_int|0xFF00
op_amp
id|inw
c_func
(paren
id|AZT_SW32_ID_REG
)paren
)paren
op_ne
l_int|0x4500
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no Soundwave32 card detected at base:%x init:%x config:%x id:%x&bslash;n&quot;
comma
id|AZT_SW32_BASE_ADDR
comma
id|AZT_SW32_INIT
comma
id|AZT_SW32_CONFIG_REG
comma
id|AZT_SW32_ID_REG
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aztcd: Soundwave32 card detected at %x  Version %x&bslash;n&quot;
comma
id|AZT_SW32_BASE_ADDR
comma
id|inw
c_func
(paren
id|AZT_SW32_ID_REG
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|AZT_SW32_INIT
comma
id|AZT_SW32_CONFIG_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|10000
suffix:semicolon
id|count
op_increment
)paren
suffix:semicolon
multiline_comment|/*delay a bit*/
)brace
macro_line|#endif&t;
multiline_comment|/* check for presence of drive */
r_if
c_cond
(paren
id|azt_port
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* autoprobing */
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|azt_port_auto
(braket
id|i
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
OL
l_int|16
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|azt_port
op_assign
id|azt_port_auto
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Autoprobing BaseAddress=0x%x &bslash;n&quot;
comma
id|azt_port
)paren
suffix:semicolon
id|st
op_assign
id|check_region
c_func
(paren
id|azt_port
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/*proprietary interfaces need 4 bytes*/
r_if
c_cond
(paren
id|st
)paren
r_continue
suffix:semicolon
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACMD_GET_VERSION
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*Try to get version info*/
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_FAST_TIMEOUT
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_eq
id|AFL_OP_OK
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|azt_port_auto
(braket
id|i
)braket
op_eq
l_int|0
)paren
op_logical_or
(paren
id|i
op_eq
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no AZTECH CD-ROM drive found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* no autoprobing */
(brace
r_if
c_cond
(paren
(paren
id|azt_port
op_eq
l_int|0x1f0
)paren
op_logical_or
(paren
id|azt_port
op_eq
l_int|0x170
)paren
)paren
id|st
op_assign
id|check_region
c_func
(paren
id|azt_port
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*IDE-interfaces need 8 bytes*/
r_else
id|st
op_assign
id|check_region
c_func
(paren
id|azt_port
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/*proprietary interfaces need 4 bytes*/
r_if
c_cond
(paren
id|st
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: conflict, I/O port (%X) already used&bslash;n&quot;
comma
id|azt_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|azt_port
op_eq
l_int|0x1f0
)paren
op_logical_or
(paren
id|azt_port
op_eq
l_int|0x170
)paren
)paren
id|SWITCH_IDE_SLAVE
suffix:semicolon
multiline_comment|/*switch IDE interface to slave configuration*/
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACMD_GET_VERSION
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*Try to get version info*/
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_FAST_TIMEOUT
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_ne
id|AFL_OP_OK
)paren
multiline_comment|/*OP_OK? If not, reset and try again*/
(brace
macro_line|#ifndef MODULE
r_if
c_cond
(paren
id|azt_cont
op_ne
l_int|0x79
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no AZTECH CD-ROM drive found-Try boot parameter aztcd=&lt;BaseAddress&gt;,0x79&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#else        
r_if
c_cond
(paren
l_int|0
)paren
(brace
)brace
macro_line|#endif&t;     
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: drive reset - please wait&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|50
suffix:semicolon
id|count
op_increment
)paren
(brace
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
multiline_comment|/*removing all data from earlier tries*/
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|getAztStatus
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*trap errors*/
id|outb
c_func
(paren
id|ACMD_SOFT_RESET
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*send reset*/
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_ne
id|AFL_OP_OK
)paren
multiline_comment|/*OP_OK?*/
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no AZTECH CD-ROM drive found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|AZT_TIMEOUT
suffix:semicolon
id|count
op_increment
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Stop gcc 2.96 being smart */
r_if
c_cond
(paren
(paren
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Drive Status Error Status=%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: Status = %x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACMD_GET_VERSION
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*GetVersion*/
id|STEN_LOW
suffix:semicolon
id|OP_OK
suffix:semicolon
)brace
)brace
)brace
id|azt_init_end
op_assign
l_int|1
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|result
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/*reading in a null byte???*/
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
l_int|50
suffix:semicolon
id|count
op_increment
)paren
multiline_comment|/*Reading version string*/
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*here we must implement STEN_LOW differently*/
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
multiline_comment|/*because we want to exit by timeout*/
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_FAST_TIMEOUT
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_FAST_TIMEOUT
)paren
r_break
suffix:semicolon
multiline_comment|/*all chars read?*/
id|result
(braket
id|count
)braket
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|30
)paren
id|max_count
op_assign
l_int|30
suffix:semicolon
multiline_comment|/*print max.30 chars of the version string*/
r_else
id|max_count
op_assign
id|count
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aztcd: FirmwareVersion=&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
id|max_count
suffix:semicolon
id|count
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|result
(braket
id|count
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&lt;&gt;&gt; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|1
)braket
op_eq
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|2
)braket
op_eq
l_char|&squot;Z&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|3
)braket
op_eq
l_char|&squot;T&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AZTECH drive detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*AZTECH*/
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|2
)braket
op_eq
l_char|&squot;C&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|3
)braket
op_eq
l_char|&squot;D&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|4
)braket
op_eq
l_char|&squot;D&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ORCHID or WEARNES drive detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*ORCHID or WEARNES*/
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|1
)braket
op_eq
l_int|0x03
)paren
op_logical_and
(paren
id|result
(braket
l_int|2
)braket
op_eq
l_char|&squot;5&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TXC or CyCDROM drive detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*Conrad TXC, CyCDROM*/
)brace
r_else
multiline_comment|/*OTHERS or none*/
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nunknown drive or firmware version detected&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd may not run stable, if you want to try anyhow,&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;boot with: aztcd=&lt;BaseAddress&gt;,0x79&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|azt_cont
op_ne
l_int|0x79
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: FirmwareVersion=&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
l_int|5
suffix:semicolon
id|count
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|result
(braket
id|count
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&lt;&gt;&gt; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;aztcd&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFBLK
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
op_amp
id|azt_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;aztcd&quot;
comma
op_amp
id|azt_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Unable to get major %d for Aztech CD-ROM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
macro_line|#ifndef AZT_KERNEL_PRIOR_2_1
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|aztcd_blocksizes
suffix:semicolon
macro_line|#endif
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
comma
l_int|1
comma
op_amp
id|azt_fops
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|azt_port
op_eq
l_int|0x1f0
)paren
op_logical_or
(paren
id|azt_port
op_eq
l_int|0x170
)paren
)paren
id|request_region
c_func
(paren
id|azt_port
comma
l_int|8
comma
l_string|&quot;aztcd&quot;
)paren
suffix:semicolon
multiline_comment|/*IDE-interface*/
r_else
id|request_region
c_func
(paren
id|azt_port
comma
l_int|4
comma
l_string|&quot;aztcd&quot;
)paren
suffix:semicolon
multiline_comment|/*proprietary interface*/
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|aztPresent
op_assign
l_int|1
suffix:semicolon
id|aztCloseDoor
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|aztcd_exit
r_void
id|__exit
id|aztcd_exit
c_func
(paren
r_void
)paren
(brace
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;aztcd&quot;
comma
l_int|0
comma
l_int|0
comma
id|DEVFS_SPECIAL_BLK
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;aztcd&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;What&squot;s that: can&squot;t unregister aztcd&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|azt_port
op_eq
l_int|0x1f0
)paren
op_logical_or
(paren
id|azt_port
op_eq
l_int|0x170
)paren
)paren
(brace
id|SWITCH_IDE_MASTER
suffix:semicolon
id|release_region
c_func
(paren
id|azt_port
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*IDE-interface*/
)brace
r_else
id|release_region
c_func
(paren
id|azt_port
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/*proprietary interface*/
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aztcd module released.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|aztcd_init
id|module_init
c_func
(paren
id|aztcd_init
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|aztcd_exit
id|module_exit
c_func
(paren
id|aztcd_exit
)paren
suffix:semicolon
multiline_comment|/*##########################################################################&n;  Aztcd State Machine: Controls Drive Operating State&n;  ##########################################################################&n;*/
DECL|function|azt_poll
r_static
r_void
id|azt_poll
c_func
(paren
r_void
)paren
(brace
r_int
id|st
op_assign
l_int|0
suffix:semicolon
r_int
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|azt_error
)paren
(brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_ERROR
)paren
)paren
id|RETURN
c_func
(paren
l_string|&quot;azt_poll 1&quot;
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|azt_error
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: I/O error 0x%02x&bslash;n&quot;
comma
id|azt_error
)paren
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|AztTries
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Read of Block %d Failed - Maybe Audio Disk?&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|AztTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Read of Block %d Failed, Maybe Audio Disk? Giving up&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|AztTries
op_assign
l_int|0
suffix:semicolon
id|loop_ctl
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|AztTries
op_assign
l_int|5
suffix:semicolon
)brace
id|azt_error
op_assign
l_int|0
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
)brace
r_while
c_loop
(paren
id|loop_ctl
)paren
(brace
id|loop_ctl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* each case must flip this back to 1 if we want&n;&t;&t;&t; to come back up here */
r_switch
c_cond
(paren
id|azt_state
)paren
(brace
r_case
id|AZT_S_IDLE
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_IDLE&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
r_case
id|AZT_S_START
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_START&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
(brace
id|RETURN
c_func
(paren
l_string|&quot;azt_poll 2&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*result will be checked by aztStatus() */
id|azt_state
op_assign
id|azt_mode
op_eq
l_int|1
ques
c_cond
id|AZT_S_READ
suffix:colon
id|AZT_S_MODE
suffix:semicolon
id|AztTimeout
op_assign
l_int|3000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AZT_S_MODE
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_MODE&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|aztStatus
c_func
(paren
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Disk Changed or Not Ready 1 - Unmount Disk!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Disk Changed or Not Ready 2 - Unmount Disk!&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;aztcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;aztcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* goto immediately */
r_break
suffix:semicolon
)brace
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&t;  if (aztSendCmd(ACMD_SET_MODE)) RETURN(&quot;azt_poll 3&quot;);&n;&t;  outb(0x01, DATA_PORT);          &n;&t;  PA_OK;&n;&t;  STEN_LOW;&n;*/
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
id|RETURN
c_func
(paren
l_string|&quot;azt_poll 4&quot;
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|azt_mode
op_assign
l_int|1
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_READ
suffix:semicolon
id|AztTimeout
op_assign
l_int|3000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AZT_S_READ
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_READ&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|aztStatus
c_func
(paren
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Disk Changed or Not Ready 3 - Unmount Disk!&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;aztcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;aztcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_struct
id|azt_Play_msf
id|msf
suffix:semicolon
r_int
id|i
suffix:semicolon
id|azt_next_bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|azt_hsg2msf
c_func
(paren
id|azt_next_bn
comma
op_amp
id|msf.start
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* find out in which track we are */
r_while
c_loop
(paren
id|azt_msf2hsg
c_func
(paren
op_amp
id|msf.start
)paren
OG
id|azt_msf2hsg
c_func
(paren
op_amp
id|Toc
(braket
op_increment
id|i
)braket
dot
id|trackTime
)paren
)paren
(brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|azt_msf2hsg
c_func
(paren
op_amp
id|msf.start
)paren
OL
id|azt_msf2hsg
c_func
(paren
op_amp
id|Toc
(braket
id|i
)braket
dot
id|trackTime
)paren
op_minus
id|AZT_BUF_SIZ
)paren
(brace
id|azt_read_count
op_assign
id|AZT_BUF_SIZ
suffix:semicolon
multiline_comment|/*fast, because we read ahead*/
multiline_comment|/*azt_read_count=CURRENT-&gt;nr_sectors;    slow, no read ahead*/
)brace
r_else
multiline_comment|/* don&squot;t read beyond end of track */
macro_line|#if AZT_MULTISESSION 
(brace
id|azt_read_count
op_assign
(paren
id|azt_msf2hsg
c_func
(paren
op_amp
id|Toc
(braket
id|i
)braket
dot
id|trackTime
)paren
op_div
l_int|4
)paren
op_star
l_int|4
op_minus
id|azt_msf2hsg
c_func
(paren
op_amp
id|msf.start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_read_count
OL
l_int|0
)paren
id|azt_read_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|azt_read_count
OG
id|AZT_BUF_SIZ
)paren
id|azt_read_count
op_assign
id|AZT_BUF_SIZ
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: warning - trying to read beyond end of track&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*               printk(&quot;%i %i %li %li&bslash;n&quot;,i,azt_read_count,azt_msf2hsg(&amp;msf.start),azt_msf2hsg(&amp;Toc[i].trackTime));&n;*/
)brace
macro_line|#else
(brace
id|azt_read_count
op_assign
id|AZT_BUF_SIZ
suffix:semicolon
)brace
macro_line|#endif
id|msf.end.min
op_assign
l_int|0
suffix:semicolon
id|msf.end.sec
op_assign
l_int|0
suffix:semicolon
id|msf.end.frame
op_assign
id|azt_read_count
suffix:semicolon
multiline_comment|/*Mitsumi here reads 0xffffff sectors*/
macro_line|#ifdef AZT_TEST3
id|printk
c_func
(paren
l_string|&quot;---reading msf-address %x:%x:%x  %x:%x:%x&bslash;n&quot;
comma
id|msf.start.min
comma
id|msf.start.sec
comma
id|msf.start.frame
comma
id|msf.end.min
comma
id|msf.end.sec
comma
id|msf.end.frame
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;azt_next_bn:%x  azt_buf_in:%x azt_buf_out:%x  azt_buf_bn:%x&bslash;n&quot;
comma
"&bslash;"
id|azt_next_bn
comma
id|azt_buf_in
comma
id|azt_buf_out
comma
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif 
r_if
c_cond
(paren
id|azt_read_mode
op_eq
id|AZT_MODE_2
)paren
(brace
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_READ_RAW
comma
op_amp
id|msf
)paren
suffix:semicolon
multiline_comment|/*XA disks in raw mode*/
)brace
r_else
(brace
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_READ
comma
op_amp
id|msf
)paren
suffix:semicolon
multiline_comment|/*others in cooked mode*/
)brace
id|azt_state
op_assign
id|AZT_S_DATA
suffix:semicolon
id|AztTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AZT_S_DATA
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_DATA&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|st
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUSorDATA
suffix:semicolon
r_switch
c_cond
(paren
id|st
)paren
(brace
r_case
id|AFL_DATA
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|st
op_ne
id|azt_st_old
)paren
(brace
id|azt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---AFL_DATA st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|AztTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Read of Block %d Failed, Maybe Audio Disk ? Giving up&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|AztTries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|AztTries
op_assign
l_int|5
suffix:semicolon
)brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|AztTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFL_STATUSorDATA
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|st
op_ne
id|azt_st_old
)paren
(brace
id|azt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---AFL_STATUSorDATA st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|st
op_ne
id|azt_st_old
)paren
(brace
id|azt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---default: st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
macro_line|#endif
id|AztTries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
op_logical_and
id|azt_buf_in
op_eq
id|azt_buf_out
)paren
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|azt_read_count
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: warning - try to read 0 frames&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|azt_read_count
)paren
multiline_comment|/*??? fast read ahead loop*/
(brace
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
multiline_comment|/*??? unsolved problem, very&n;&t;&t;&t;&t;&t;&t;      seldom we get timeouts&n;&t;&t;&t;&t;&t;&t;      here, don&squot;t now the real&n;&t;&t;&t;&t;&t;&t;      reason. With my drive this&n;&t;&t;&t;&t;&t;&t;      sometimes also happens with&n;&t;&t;&t;&t;&t;&t;      Aztech&squot;s original driver under&n;&t;&t;&t;&t;&t;&t;      DOS. Is it a hardware bug? &n;&t;&t;&t;&t;&t;&t;      I tried to recover from such&n;&t;&t;&t;&t;&t;&t;      situations here. Zimmermann*/
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;read_count:%d CURRENT-&gt;nr_sectors:%ld azt_buf_in:%d&bslash;n&quot;
comma
id|azt_read_count
comma
id|CURRENT-&gt;nr_sectors
comma
id|azt_buf_in
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;azt_transfer_is_active:%x&bslash;n&quot;
comma
id|azt_transfer_is_active
)paren
suffix:semicolon
id|azt_read_count
op_assign
l_int|0
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*should we have here (1) or (0)? */
)brace
r_else
(brace
r_if
c_cond
(paren
id|azt_read_mode
op_eq
id|AZT_MODE_2
)paren
(brace
id|insb
c_func
(paren
id|DATA_PORT
comma
id|azt_buf
op_plus
id|CD_FRAMESIZE_RAW
op_star
id|azt_buf_in
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
r_else
(brace
id|insb
c_func
(paren
id|DATA_PORT
comma
id|azt_buf
op_plus
id|CD_FRAMESIZE
op_star
id|azt_buf_in
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
)brace
id|azt_read_count
op_decrement
suffix:semicolon
macro_line|#ifdef AZT_TEST3
id|printk
c_func
(paren
l_string|&quot;AZT_S_DATA; ---I&squot;ve read data- read_count: %d&bslash;n&quot;
comma
id|azt_read_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;azt_next_bn:%d  azt_buf_in:%d azt_buf_out:%d  azt_buf_bn:%d&bslash;n&quot;
comma
"&bslash;"
id|azt_next_bn
comma
id|azt_buf_in
comma
id|azt_buf_out
comma
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
op_assign
id|azt_next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|azt_buf_out
op_eq
op_minus
l_int|1
)paren
id|azt_buf_out
op_assign
id|azt_buf_in
suffix:semicolon
id|azt_buf_in
op_assign
id|azt_buf_in
op_plus
l_int|1
op_eq
id|AZT_BUF_SIZ
ques
c_cond
l_int|0
suffix:colon
id|azt_buf_in
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|azt_transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
id|azt_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
op_logical_and
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
template_param
id|azt_next_bn
op_plus
id|AZT_BUF_SIZ
)paren
)paren
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|AztTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|azt_read_count
op_eq
l_int|0
)paren
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AZT_S_STOP
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_STOP&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|azt_read_count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: discard data=%x frames&bslash;n&quot;
comma
id|azt_read_count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|azt_read_count
op_ne
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_DATA
)paren
)paren
(brace
r_if
c_cond
(paren
id|azt_read_mode
op_eq
id|AZT_MODE_2
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_FRAMESIZE_RAW
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_FRAMESIZE
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
id|azt_read_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
id|RETURN
c_func
(paren
l_string|&quot;azt_poll 5&quot;
)paren
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOPPING
suffix:semicolon
id|AztTimeout
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AZT_S_STOPPING
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_STOPPING&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|aztStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
op_logical_and
id|AztTimeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: Disk Changed or Not Ready 4 - Unmount Disk!&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef AZT_TEST3
id|printk
c_func
(paren
l_string|&quot;CURRENT_VALID %d azt_mode %d&bslash;n&quot;
comma
id|CURRENT_VALID
comma
id|azt_mode
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|azt_mode
op_eq
l_int|1
)paren
(brace
id|azt_state
op_assign
id|AZT_S_READ
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_MODE
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|AztTimeout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aztcd: invalid state %d&bslash;n&quot;
comma
id|azt_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* case */
)brace
multiline_comment|/* while */
r_if
c_cond
(paren
op_logical_neg
id|AztTimeout
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: timeout in state %d&bslash;n&quot;
comma
id|azt_state
)paren
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
id|RETURN
c_func
(paren
l_string|&quot;azt_poll 6&quot;
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
)brace
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|azt_poll
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/*###########################################################################&n; * Miscellaneous support functions&n;  ###########################################################################&n;*/
DECL|function|azt_hsg2msf
r_static
r_void
id|azt_hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf
op_member_access_from_pointer
id|min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf
op_member_access_from_pointer
id|sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf
op_member_access_from_pointer
id|frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
r_if
c_cond
(paren
id|msf-&gt;min
op_ge
l_int|70
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error hsg2msf address Minutes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf-&gt;sec
op_ge
l_int|60
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error hsg2msf address Seconds&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf-&gt;frame
op_ge
l_int|75
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error hsg2msf address Frames&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|sec
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|frame
)paren
suffix:semicolon
)brace
DECL|function|azt_msf2hsg
r_static
r_int
id|azt_msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
r_return
id|azt_bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|frame
)paren
op_plus
id|azt_bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|sec
)paren
op_star
l_int|75
op_plus
id|azt_bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|min
)paren
op_star
l_int|4500
op_minus
id|CD_MSF_OFFSET
suffix:semicolon
)brace
DECL|function|azt_bin2bcd
r_static
r_void
id|azt_bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_int
id|u
comma
id|t
suffix:semicolon
id|u
op_assign
op_star
id|p
op_mod
l_int|10
suffix:semicolon
id|t
op_assign
op_star
id|p
op_div
l_int|10
suffix:semicolon
op_star
id|p
op_assign
id|u
op_or
(paren
id|t
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|azt_bcd2bin
r_static
r_int
id|azt_bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0xF
)paren
suffix:semicolon
)brace
eof
