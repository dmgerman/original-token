multiline_comment|/*&t;$Id: optcd.c,v 1.3 1995/08/24 19:54:27 root Exp root $&n;&t;linux/drivers/block/optcd.c - Optics Storage 8000 AT CDROM driver&n;&n;&t;Copyright (C) 1995 Leo Spiekman (spiekman@dutette.et.tudelft.nl)&n;&n;&t;Based on Aztech CD268 CDROM driver by Werner Zimmermann and preworks&n;&t;by Eberhard Moenkeberg (emoenke@gwdg.de). ISP16 detection and&n;&t;configuration by Eric van der Maarel (maarel@marin.nl), with some data&n;&t;communicated by Vadim V. Model (vadim@rbrf.msk.su).&n;&n;&t;This program is free software; you can redistribute it and/or modify&n;&t;it under the terms of the GNU General Public License as published by&n;&t;the Free Software Foundation; either version 2, or (at your option)&n;&t;any later version.&n;&n;&t;This program is distributed in the hope that it will be useful,&n;&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n;&t;GNU General Public License for more details.&n;&n;&t;You should have received a copy of the GNU General Public License&n;&t;along with this program; if not, write to the Free Software&n;&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;&t;History&n;&t;14-5-95&t;&t;v0.0&t;Plays sound tracks. No reading of data CDs yet.&n;&t;&t;&t;&t;Detection of disk change doesn&squot;t work.&n;&t;21-5-95&t;&t;v0.1&t;First ALPHA version. CD can be mounted. The&n;&t;&t;&t;&t;device major nr is borrowed from the Aztech&n;&t;&t;&t;&t;driver. Speed is around 240 kb/s, as measured&n;&t;&t;&t;&t;with &quot;time dd if=/dev/cdrom of=/dev/null &bslash;&n;&t;&t;&t;&t;bs=2048 count=4096&quot;.&n;&t;24-6-95&t;&t;v0.2&t;Reworked the #defines for the command codes&n;&t;&t;&t;&t;and the like, as well as the structure of&n;&t;&t;&t;&t;the hardware communication protocol, to&n;&t;&t;&t;&t;reflect the &quot;official&quot; documentation, kindly&n;&t;&t;&t;&t;supplied by C.K. Tan, Optics Storage Pte. Ltd.&n;&t;&t;&t;&t;Also tidied up the state machine somewhat.&n;&t;28-6-95&t;&t;v0.3&t;Removed the ISP-16 interface code, as this&n;&t;&t;&t;&t;should go into its own driver. The driver now&n;&t;&t;&t;&t;has its own major nr.&n;&t;&t;&t;&t;Disk change detection now seems to work, too.&n;&t;&t;&t;&t;This version became part of the standard&n;&t;&t;&t;&t;kernel as of version 1.3.7&n;&t;24-9-95&t;&t;v0.4&t;Re-inserted ISP-16 interface code which I&n;&t;&t;&t;&t;copied from sjcd.c, with a few changes.&n;&t;&t;&t;&t;Updated README.optcd. Submitted for&n;&t;&t;&t;&t;inclusion in 1.3.21&n;&t;29-9-95&t;&t;v0.4a&t;Fixed bug that prevented compilation as module&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR OPTICS_CDROM_MAJOR
macro_line|# include &lt;linux/blk.h&gt;
DECL|macro|optcd_port
mdefine_line|#define optcd_port optcd&t;/* Needed for the modutils. */
macro_line|# include &lt;linux/optcd.h&gt;
multiline_comment|/* Some (Media)Magic */
multiline_comment|/* define types of drive the interface on an ISP16 card may be looking at */
DECL|macro|ISP16_DRIVE_X
mdefine_line|#define ISP16_DRIVE_X 0x00
DECL|macro|ISP16_SONY
mdefine_line|#define ISP16_SONY  0x02
DECL|macro|ISP16_PANASONIC0
mdefine_line|#define ISP16_PANASONIC0 0x02
DECL|macro|ISP16_SANYO0
mdefine_line|#define ISP16_SANYO0 0x02
DECL|macro|ISP16_MITSUMI
mdefine_line|#define ISP16_MITSUMI  0x04
DECL|macro|ISP16_PANASONIC1
mdefine_line|#define ISP16_PANASONIC1 0x06
DECL|macro|ISP16_SANYO1
mdefine_line|#define ISP16_SANYO1 0x06
DECL|macro|ISP16_DRIVE_NOT_USED
mdefine_line|#define ISP16_DRIVE_NOT_USED 0x08  /* not used */
DECL|macro|ISP16_DRIVE_SET_MASK
mdefine_line|#define ISP16_DRIVE_SET_MASK 0xF1  /* don&squot;t change 0-bit or 4-7-bits*/
multiline_comment|/* ...for port */
DECL|macro|ISP16_DRIVE_SET_PORT
mdefine_line|#define ISP16_DRIVE_SET_PORT 0xF8D
multiline_comment|/* set io parameters */
DECL|macro|ISP16_BASE_340
mdefine_line|#define ISP16_BASE_340  0x00
DECL|macro|ISP16_BASE_330
mdefine_line|#define ISP16_BASE_330  0x40
DECL|macro|ISP16_BASE_360
mdefine_line|#define ISP16_BASE_360  0x80
DECL|macro|ISP16_BASE_320
mdefine_line|#define ISP16_BASE_320  0xC0
DECL|macro|ISP16_IRQ_X
mdefine_line|#define ISP16_IRQ_X  0x00
DECL|macro|ISP16_IRQ_5
mdefine_line|#define ISP16_IRQ_5  0x04  /* shouldn&squot;t be used due to soundcard conflicts */
DECL|macro|ISP16_IRQ_7
mdefine_line|#define ISP16_IRQ_7  0x08  /* shouldn&squot;t be used due to soundcard conflicts */
DECL|macro|ISP16_IRQ_3
mdefine_line|#define ISP16_IRQ_3  0x0C
DECL|macro|ISP16_IRQ_9
mdefine_line|#define ISP16_IRQ_9  0x10
DECL|macro|ISP16_IRQ_10
mdefine_line|#define ISP16_IRQ_10  0x14
DECL|macro|ISP16_IRQ_11
mdefine_line|#define ISP16_IRQ_11  0x18
DECL|macro|ISP16_DMA_X
mdefine_line|#define ISP16_DMA_X  0x03
DECL|macro|ISP16_DMA_3
mdefine_line|#define ISP16_DMA_3  0x00
DECL|macro|ISP16_DMA_5
mdefine_line|#define ISP16_DMA_5  0x00
DECL|macro|ISP16_DMA_6
mdefine_line|#define ISP16_DMA_6  0x01
DECL|macro|ISP16_DMA_7
mdefine_line|#define ISP16_DMA_7  0x02
DECL|macro|ISP16_IO_SET_MASK
mdefine_line|#define ISP16_IO_SET_MASK  0x20  /* don&squot;t change 5-bit */
multiline_comment|/* ...for port */
DECL|macro|ISP16_IO_SET_PORT
mdefine_line|#define ISP16_IO_SET_PORT  0xF8E
multiline_comment|/* enable the drive */
DECL|macro|ISP16_NO_IDE__ENABLE_CDROM_PORT
mdefine_line|#define ISP16_NO_IDE__ENABLE_CDROM_PORT  0xF90  /* ISP16 without IDE interface */
DECL|macro|ISP16_IDE__ENABLE_CDROM_PORT
mdefine_line|#define ISP16_IDE__ENABLE_CDROM_PORT  0xF91  /* ISP16 with IDE interface */
DECL|macro|ISP16_ENABLE_CDROM
mdefine_line|#define ISP16_ENABLE_CDROM  0x80  /* seven bit */
multiline_comment|/* the magic stuff */
DECL|macro|ISP16_CTRL_PORT
mdefine_line|#define ISP16_CTRL_PORT  0xF8F
DECL|macro|ISP16_NO_IDE__CTRL
mdefine_line|#define ISP16_NO_IDE__CTRL  0xE2  /* ISP16 without IDE interface */
DECL|macro|ISP16_IDE__CTRL
mdefine_line|#define ISP16_IDE__CTRL  0xE3  /* ISP16 with IDE interface */
r_static
r_int
id|isp16_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|isp16_no_ide__detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|isp16_with_ide__detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|isp16_config
c_func
(paren
r_int
id|base
comma
id|u_char
id|drive_type
comma
r_int
id|irq
comma
r_int
id|dma
)paren
suffix:semicolon
DECL|variable|isp16_type
r_static
r_int
id|isp16_type
suffix:semicolon
multiline_comment|/* dependent on type of interface card */
DECL|variable|isp16_ctrl
r_static
id|u_char
id|isp16_ctrl
suffix:semicolon
DECL|variable|isp16_enable_cdrom_port
r_static
id|u_short
id|isp16_enable_cdrom_port
suffix:semicolon
DECL|variable|optcd_port
r_static
r_int
id|optcd_port
op_assign
id|OPTCD_PORTBASE
suffix:semicolon
multiline_comment|/* Read current status/data availability flags */
DECL|function|optFlags
r_inline
r_static
r_int
id|optFlags
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_STDT
suffix:semicolon
)brace
multiline_comment|/* Wait for status available; return TRUE on timeout */
DECL|function|sten_low
r_static
r_int
id|sten_low
c_func
(paren
r_void
)paren
(brace
r_int
id|no_status
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|no_status
op_assign
(paren
id|optFlags
c_func
(paren
)paren
op_amp
id|FL_STEN
)paren
)paren
)paren
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|BUSY_TIMEOUT
)paren
r_break
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
r_if
c_cond
(paren
id|no_status
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: timeout waiting for STEN low&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;optcd: STEN low after %ld&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|no_status
suffix:semicolon
)brace
multiline_comment|/* Wait for data available; return TRUE on timeout */
DECL|function|dten_low
r_static
r_int
id|dten_low
c_func
(paren
r_void
)paren
(brace
r_int
id|no_data
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|no_data
op_assign
(paren
id|optFlags
c_func
(paren
)paren
op_amp
id|FL_DTEN
)paren
)paren
)paren
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|BUSY_TIMEOUT
)paren
r_break
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
r_if
c_cond
(paren
id|no_data
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: timeout waiting for DTEN low&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;optcd: DTEN low after %ld&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|no_data
suffix:semicolon
)brace
multiline_comment|/* Facilities for polled waiting for status or data */
DECL|variable|sleep_timeout
r_static
r_int
id|sleep_timeout
suffix:semicolon
multiline_comment|/* Max amount of time still to sleep */
DECL|variable|sleep_flags
r_static
r_int
r_char
id|sleep_flags
suffix:semicolon
multiline_comment|/* Flags read last time around */
DECL|variable|waitq
r_static
r_struct
id|wait_queue
op_star
id|waitq
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|delay_timer
r_static
r_struct
id|timer_list
id|delay_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* Timer routine: wake up when either of FL_STEN or FL_DTEN goes down,&n; * or when timeout expires. Otherwise wait some more.&n; */
DECL|function|sleep_timer
r_static
r_void
id|sleep_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|sleep_flags
op_assign
id|optFlags
c_func
(paren
)paren
)paren
op_ne
id|FL_STDT
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|sleep_timeout
op_le
l_int|0
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|sleep_timer
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Sleep until any of FL_STEN or FL_DTEN go down, or until timeout.&n; * sleep_timeout must be set first.&n; */
DECL|function|sleep_status
r_static
r_int
id|sleep_status
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: sleeping %d on status&bslash;n&quot;
comma
id|sleep_timeout
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sleep_timeout
op_le
l_int|0
)paren
multiline_comment|/* timeout immediately */
r_return
id|FL_STDT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sleep_flags
op_assign
id|optFlags
c_func
(paren
)paren
)paren
op_eq
id|FL_STDT
)paren
(brace
id|SET_TIMER
c_func
(paren
id|sleep_timer
comma
l_int|1
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|waitq
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: woken up with %d to go, flags %d&bslash;n&quot;
comma
id|sleep_timeout
comma
id|sleep_flags
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sleep_flags
suffix:semicolon
)brace
multiline_comment|/* Sleep until status available; return TRUE on timeout */
DECL|function|sleep_sten_low
r_inline
r_static
r_int
id|sleep_sten_low
c_func
(paren
r_void
)paren
(brace
r_int
id|flags
suffix:semicolon
id|sleep_timeout
op_assign
id|SLEEP_TIMEOUT
suffix:semicolon
id|flags
op_assign
id|sleep_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|FL_DTEN
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: DTEN while waiting for STEN&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|flags
op_amp
id|FL_STEN
suffix:semicolon
)brace
multiline_comment|/* Sleep until data available; return TRUE on timeout */
DECL|function|sleep_dten_low
r_inline
r_static
r_int
id|sleep_dten_low
c_func
(paren
r_void
)paren
(brace
r_int
id|flags
suffix:semicolon
id|sleep_timeout
op_assign
id|SLEEP_TIMEOUT
suffix:semicolon
id|flags
op_assign
id|sleep_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|FL_STEN
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: STEN while waiting for DTEN&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|flags
op_amp
id|FL_DTEN
suffix:semicolon
)brace
multiline_comment|/* Send command code. Return &lt;0 indicates error */
DECL|function|optSendCmd
r_static
r_int
id|optSendCmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
r_char
id|ack
suffix:semicolon
macro_line|#if defined(DEBUG_DRIVE_IF)||defined(DEBUG_COMMANDS)
id|printk
c_func
(paren
l_string|&quot;optcd: executing command 0x%02x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|HCON_DTS
comma
id|HCON_PORT
)paren
suffix:semicolon
multiline_comment|/* Enable Suspend Data Transfer */
id|outb
c_func
(paren
id|cmd
comma
id|COMIN_PORT
)paren
suffix:semicolon
multiline_comment|/* Send command code */
r_if
c_cond
(paren
id|sten_low
c_func
(paren
)paren
)paren
multiline_comment|/* Wait for status available */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|ack
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command acknowledge */
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: acknowledge code 0x%02x&bslash;n&quot;
comma
id|ack
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|HCON_SDRQB
comma
id|HCON_PORT
)paren
suffix:semicolon
multiline_comment|/* Disable Suspend Data Transfer */
r_return
id|ack
op_eq
id|ST_OP_OK
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ack
suffix:semicolon
)brace
multiline_comment|/* Send command parameters. Return &lt;0 indicates error */
DECL|function|optSendParams
r_static
r_int
id|optSendParams
c_func
(paren
r_struct
id|opt_Play_msf
op_star
id|params
)paren
(brace
r_int
r_char
id|ack
suffix:semicolon
macro_line|#if defined(DEBUG_DRIVE_IF)||defined(DEBUG_COMMANDS)
id|printk
c_func
(paren
l_string|&quot;optcd: params %02x:%02x:%02x %02x:%02x:%02x&bslash;n&quot;
comma
id|params-&gt;start.min
comma
id|params-&gt;start.sec
comma
id|params-&gt;start.frame
comma
id|params-&gt;end.min
comma
id|params-&gt;end.sec
comma
id|params-&gt;end.frame
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.min
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.sec
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.frame
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.min
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.sec
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.frame
comma
id|COMIN_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sten_low
c_func
(paren
)paren
)paren
multiline_comment|/* Wait for status available */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|ack
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command acknowledge */
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: acknowledge code 0x%02x&bslash;n&quot;
comma
id|ack
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ack
op_eq
id|ST_PA_OK
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ack
suffix:semicolon
)brace
multiline_comment|/* Return execution status for quick response commands, i.e. busy wait.&n; * Return value &lt;0 indicates timeout.&n; */
DECL|function|optGetExecStatus
r_static
r_int
id|optGetExecStatus
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|exec_status
suffix:semicolon
r_if
c_cond
(paren
id|sten_low
c_func
(paren
)paren
)paren
multiline_comment|/* Wait for status available */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|exec_status
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command execution status */
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: returned execution status: 0x%02x&bslash;n&quot;
comma
id|exec_status
)paren
suffix:semicolon
macro_line|#endif
r_return
id|exec_status
suffix:semicolon
)brace
multiline_comment|/* Return execution status for slow commands. Only use when no data is&n; * expected. Return value &lt;0 indicates timeout.&n; */
DECL|function|optSleepTillExecStatus
r_static
r_int
id|optSleepTillExecStatus
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|exec_status
suffix:semicolon
r_if
c_cond
(paren
id|sleep_sten_low
c_func
(paren
)paren
)paren
multiline_comment|/* Wait for status available */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|exec_status
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command execution status */
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: returned execution status: 0x%02x&bslash;n&quot;
comma
id|exec_status
)paren
suffix:semicolon
macro_line|#endif
r_return
id|exec_status
suffix:semicolon
)brace
multiline_comment|/* Fetch status that has previously been waited for. &lt;0 means not available */
DECL|function|optStatus
r_inline
r_static
r_int
id|optStatus
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|optFlags
c_func
(paren
)paren
op_amp
id|FL_STEN
)paren
r_return
op_minus
id|ERR_IF_NOSTAT
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: read status: 0x%02x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Wait for extra byte of data that a command returns */
DECL|function|optGetData
r_static
r_int
id|optGetData
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_if
c_cond
(paren
id|sten_low
c_func
(paren
)paren
)paren
r_return
op_minus
id|ERR_IF_DATA_TIMEOUT
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: read data: 0x%02x&bslash;n&quot;
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/* Read data that has previously been waited for. */
DECL|function|optReadData
r_inline
r_static
r_void
id|optReadData
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|n
)paren
(brace
id|insb
c_func
(paren
id|DATA_PORT
comma
id|buf
comma
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush status and data fifos */
DECL|function|optFlushData
r_inline
r_static
r_void
id|optFlushData
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|optFlags
c_func
(paren
)paren
op_ne
id|FL_STDT
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Write something to RESET_PORT and wait. Return TRUE upon success. */
DECL|function|optResetDrive
r_static
r_int
id|optResetDrive
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
id|printk
c_func
(paren
l_string|&quot;optcd: reset drive&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0
comma
id|RESET_PORT
)paren
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|count
OL
id|RESET_WAIT
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|flags
op_assign
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_RESET
)paren
)paren
op_ne
id|FL_RESET
)paren
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|BUSY_TIMEOUT
)paren
r_break
suffix:semicolon
macro_line|#ifdef DEBUG_DRIVE_IF
r_if
c_cond
(paren
id|flags
op_eq
id|FL_RESET
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: drive reset&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;optcd: reset failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|flags
op_ne
id|FL_RESET
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset failed */
id|outb
c_func
(paren
id|HCON_SDRQB
comma
id|HCON_PORT
)paren
suffix:semicolon
multiline_comment|/* Disable Suspend Data Transfer */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Reset succeeded */
)brace
multiline_comment|/* Command protocol */
multiline_comment|/* Send a simple command and wait for response */
DECL|function|optCmd
r_inline
r_static
r_int
id|optCmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
id|ack
op_assign
id|optSendCmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_if
c_cond
(paren
id|cmd
OL
id|COMFETCH
)paren
multiline_comment|/* Quick response command */
r_return
id|optGetExecStatus
c_func
(paren
)paren
suffix:semicolon
r_else
multiline_comment|/* Slow command */
r_return
id|optSleepTillExecStatus
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send a command with parameters and wait for response */
DECL|function|optPlayCmd
r_inline
r_static
r_int
id|optPlayCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|opt_Play_msf
op_star
id|params
)paren
(brace
r_int
id|ack
op_assign
id|optSendCmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ack
op_assign
id|optSendParams
c_func
(paren
id|params
)paren
)paren
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_return
id|optSleepTillExecStatus
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send a command with parameters. Don&squot;t wait for the response,&n; * which consists of the data blocks read. */
DECL|function|optReadCmd
r_inline
r_static
r_int
id|optReadCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|opt_Play_msf
op_star
id|params
)paren
(brace
r_int
id|ack
op_assign
id|optSendCmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_return
id|optSendParams
c_func
(paren
id|params
)paren
suffix:semicolon
)brace
multiline_comment|/* Address conversion routines */
multiline_comment|/* Binary to BCD (2 digits) */
DECL|function|bin2bcd
r_inline
r_static
r_int
r_char
id|bin2bcd
c_func
(paren
r_int
r_char
id|p
)paren
(brace
macro_line|#ifdef DEBUG_CONV
r_if
c_cond
(paren
id|p
OG
l_int|99
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: error bin2bcd %d&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|p
op_mod
l_int|10
)paren
op_or
(paren
(paren
id|p
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Linear address to minute, second, frame form */
DECL|function|hsg2msf
r_static
r_void
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf
op_member_access_from_pointer
id|min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf
op_member_access_from_pointer
id|sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf
op_member_access_from_pointer
id|frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
macro_line|#ifdef DEBUG_CONV
r_if
c_cond
(paren
id|msf
op_member_access_from_pointer
id|min
op_ge
l_int|70
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: Error hsg2msf address Minutes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf
op_member_access_from_pointer
id|sec
op_ge
l_int|60
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: Error hsg2msf address Seconds&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf
op_member_access_from_pointer
id|frame
op_ge
l_int|75
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: Error hsg2msf address Frames&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|msf
op_member_access_from_pointer
id|min
op_assign
id|bin2bcd
c_func
(paren
id|msf
op_member_access_from_pointer
id|min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|msf
op_member_access_from_pointer
id|sec
op_assign
id|bin2bcd
c_func
(paren
id|msf
op_member_access_from_pointer
id|sec
)paren
suffix:semicolon
id|msf
op_member_access_from_pointer
id|frame
op_assign
id|bin2bcd
c_func
(paren
id|msf
op_member_access_from_pointer
id|frame
)paren
suffix:semicolon
)brace
multiline_comment|/* Two BCD digits to binary */
DECL|function|bcd2bin
r_inline
r_static
r_int
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/* Minute, second, frame address to linear address */
DECL|function|msf2hsg
r_static
r_int
id|msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
macro_line|#ifdef DEBUG_CONV
r_if
c_cond
(paren
id|mp
op_member_access_from_pointer
id|min
op_ge
l_int|70
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: Error msf2hsg address Minutes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_member_access_from_pointer
id|sec
op_ge
l_int|60
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: Error msf2hsg address Seconds&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_member_access_from_pointer
id|frame
op_ge
l_int|75
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: Error msf2hsg address Frames&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|frame
)paren
op_plus
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|sec
)paren
op_star
l_int|75
op_plus
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|min
)paren
op_star
l_int|4500
op_minus
l_int|150
suffix:semicolon
)brace
multiline_comment|/* Drive status and table of contents */
DECL|variable|optAudioStatus
r_static
r_int
id|optAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
DECL|variable|optDiskChanged
r_static
r_char
id|optDiskChanged
op_assign
l_int|1
suffix:semicolon
DECL|variable|optTocUpToDate
r_static
r_char
id|optTocUpToDate
op_assign
l_int|0
suffix:semicolon
DECL|variable|DiskInfo
r_static
r_struct
id|opt_DiskInfo
id|DiskInfo
suffix:semicolon
DECL|variable|Toc
r_static
r_struct
id|opt_Toc
id|Toc
(braket
id|MAX_TRACKS
)braket
suffix:semicolon
multiline_comment|/* Get CDROM status, flagging completion of audio play and disk changes. */
DECL|function|optGetStatus
r_static
r_int
id|optGetStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optCmd
c_func
(paren
id|COMIOCTLISTAT
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
l_int|0xff
)paren
r_return
op_minus
id|ERR_IF_NOSTAT
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|st
op_amp
id|ST_MODE_BITS
)paren
op_ne
id|ST_M_AUDIO
)paren
op_logical_and
(paren
id|optAudioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
)paren
(brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_amp
id|ST_DSK_CHG
)paren
(brace
id|optDiskChanged
op_assign
l_int|1
suffix:semicolon
id|optTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|optAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the current Q-channel info. Also used for reading the&n; * table of contents.&n; */
DECL|function|optGetQChannelInfo
r_static
r_int
id|optGetQChannelInfo
c_func
(paren
r_struct
id|opt_Toc
op_star
id|qp
)paren
(brace
r_int
id|st
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: starting optGetQChannelInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optGetStatus
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optCmd
c_func
(paren
id|COMSUBQ
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|ctrl_addr
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|track
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|pointIndex
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|trackTime.min
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|trackTime.sec
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|trackTime.frame
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
multiline_comment|/* byte not used */
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|diskTime.min
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|diskTime.sec
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|diskTime.frame
op_assign
id|st
op_assign
id|optGetData
c_func
(paren
)paren
)paren
comma
id|st
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: exiting optGetQChannelInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|QINFO_FIRSTTRACK
mdefine_line|#define QINFO_FIRSTTRACK&t;0xa0
DECL|macro|QINFO_LASTTRACK
mdefine_line|#define QINFO_LASTTRACK&t;&t;0xa1
DECL|macro|QINFO_DISKLENGTH
mdefine_line|#define QINFO_DISKLENGTH&t;0xa2
DECL|function|optGetDiskInfo
r_static
r_int
id|optGetDiskInfo
c_func
(paren
r_void
)paren
(brace
r_int
id|st
comma
id|limit
suffix:semicolon
r_int
r_char
id|test
op_assign
l_int|0
suffix:semicolon
r_struct
id|opt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: starting optGetDiskInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|optDiskChanged
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optCmd
c_func
(paren
id|COMLEADIN
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
(paren
id|limit
OG
l_int|0
)paren
op_logical_and
(paren
id|test
op_ne
l_int|0x0f
)paren
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
r_switch
c_cond
(paren
id|qInfo.pointIndex
)paren
(brace
r_case
id|QINFO_FIRSTTRACK
suffix:colon
id|DiskInfo.first
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: got first: %d&bslash;n&quot;
comma
id|DiskInfo.first
)paren
suffix:semicolon
macro_line|#endif
id|test
op_or_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QINFO_LASTTRACK
suffix:colon
id|DiskInfo.last
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: got last: %d&bslash;n&quot;
comma
id|DiskInfo.last
)paren
suffix:semicolon
macro_line|#endif
id|test
op_or_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QINFO_DISKLENGTH
suffix:colon
id|DiskInfo.diskLength.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.diskLength.sec
op_assign
id|qInfo.diskTime.sec
op_minus
l_int|2
suffix:semicolon
id|DiskInfo.diskLength.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: got length: %x:%x.%x&bslash;n&quot;
comma
id|DiskInfo.diskLength.min
comma
id|DiskInfo.diskLength.sec
comma
id|DiskInfo.diskLength.frame
)paren
suffix:semicolon
macro_line|#endif
id|test
op_or_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|test
op_amp
l_int|0x01
)paren
multiline_comment|/* Got no of first track */
op_logical_and
(paren
id|qInfo.pointIndex
op_eq
id|DiskInfo.first
)paren
)paren
(brace
multiline_comment|/* StartTime of First Track */
id|DiskInfo.firstTrack.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.firstTrack.sec
op_assign
id|qInfo.diskTime.sec
suffix:semicolon
id|DiskInfo.firstTrack.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: got start: %x:%x.%x&bslash;n&quot;
comma
id|DiskInfo.firstTrack.min
comma
id|DiskInfo.firstTrack.sec
comma
id|DiskInfo.firstTrack.frame
)paren
suffix:semicolon
macro_line|#endif
id|test
op_or_assign
l_int|0x08
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: exiting optGetDiskInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test
op_ne
l_int|0x0f
)paren
r_return
op_minus
id|ERR_TOC_MISSINGINFO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|optGetToc
r_static
r_int
id|optGetToc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Presumes we have got DiskInfo */
r_int
id|st
comma
id|count
comma
id|px
comma
id|limit
suffix:semicolon
r_struct
id|opt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: starting optGetToc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|MAX_TRACKS
suffix:semicolon
id|count
op_increment
)paren
id|Toc
(braket
id|count
)braket
dot
id|pointIndex
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optCmd
c_func
(paren
id|COMLEADIN
)paren
)paren
OL
l_int|0
)paren
r_return
id|st
suffix:semicolon
id|st
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
id|DiskInfo.last
op_plus
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
(paren
id|limit
OG
l_int|0
)paren
op_logical_and
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|px
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|px
OG
l_int|0
op_logical_and
id|px
OL
id|MAX_TRACKS
op_logical_and
id|qInfo.track
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|Toc
(braket
id|px
)braket
dot
id|pointIndex
op_eq
l_int|0
)paren
(brace
id|Toc
(braket
id|px
)braket
op_assign
id|qInfo
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime
op_assign
id|DiskInfo.diskLength
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: exiting optGetToc&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|DiskInfo.last
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %3d ctl-adr = %02x track %2d px &quot;
l_string|&quot;%02x %02x:%02x.%02x %02x:%02x.%02x&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
OL
l_int|103
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %3d ctl-adr = %02x track %2d px &quot;
l_string|&quot;%02x %02x:%02x.%02x %02x:%02x.%02x&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
id|count
ques
c_cond
op_minus
id|ERR_TOC_MISSINGENTRY
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|optUpdateToc
r_static
r_int
id|optUpdateToc
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: starting optUpdateToc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|optTocUpToDate
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|optGetDiskInfo
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|optGetToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|optTocUpToDate
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG_TOC
id|printk
c_func
(paren
l_string|&quot;optcd: exiting optUpdateToc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Buffers */
DECL|macro|OPT_BUF_SIZ
mdefine_line|#define OPT_BUF_SIZ&t;&t;16
DECL|macro|OPT_BLOCKSIZE
mdefine_line|#define OPT_BLOCKSIZE&t;&t;2048
DECL|macro|OPT_BLOCKSIZE_RAW
mdefine_line|#define OPT_BLOCKSIZE_RAW&t;2336
DECL|macro|OPT_BLOCKSIZE_ALL
mdefine_line|#define OPT_BLOCKSIZE_ALL&t;2646
DECL|macro|OPT_NOBUF
mdefine_line|#define OPT_NOBUF&t;&t;-1
multiline_comment|/* Buffer for block size conversion. */
DECL|variable|opt_buf
r_static
r_char
id|opt_buf
(braket
id|OPT_BLOCKSIZE
op_star
id|OPT_BUF_SIZ
)braket
suffix:semicolon
DECL|variable|opt_buf_bn
DECL|variable|opt_next_bn
r_static
r_volatile
r_int
id|opt_buf_bn
(braket
id|OPT_BUF_SIZ
)braket
comma
id|opt_next_bn
suffix:semicolon
DECL|variable|opt_buf_in
DECL|variable|opt_buf_out
r_static
r_volatile
r_int
id|opt_buf_in
op_assign
l_int|0
comma
id|opt_buf_out
op_assign
id|OPT_NOBUF
suffix:semicolon
DECL|function|opt_invalidate_buffers
r_inline
r_static
r_void
id|opt_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG_BUFFERS
id|printk
c_func
(paren
l_string|&quot;optcd: executing opt_invalidate_buffers&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPT_BUF_SIZ
suffix:semicolon
id|i
op_increment
)paren
id|opt_buf_bn
(braket
id|i
)braket
op_assign
id|OPT_NOBUF
suffix:semicolon
id|opt_buf_out
op_assign
id|OPT_NOBUF
suffix:semicolon
)brace
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
DECL|function|opt_transfer
r_static
r_void
id|opt_transfer
c_func
(paren
r_void
)paren
(brace
macro_line|#if (defined DEBUG_BUFFERS) || (defined DEBUG_REQUEST)
id|printk
c_func
(paren
l_string|&quot;optcd: executing opt_transfer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
(brace
r_int
id|bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
r_int
id|i
comma
id|offs
comma
id|nr_sectors
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPT_BUF_SIZ
op_logical_and
id|opt_buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_REQUEST
id|printk
c_func
(paren
l_string|&quot;optcd: found %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|i
op_ge
id|OPT_BUF_SIZ
)paren
(brace
id|opt_buf_out
op_assign
id|OPT_NOBUF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_buf_out
op_ne
id|i
)paren
(brace
id|opt_buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|opt_buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|opt_buf_out
op_assign
id|OPT_NOBUF
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT
op_member_access_from_pointer
id|buffer
comma
id|opt_buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
)brace
multiline_comment|/* State machine for reading disk blocks */
DECL|enum|opt_state_e
r_enum
id|opt_state_e
(brace
DECL|enumerator|OPT_S_IDLE
id|OPT_S_IDLE
comma
multiline_comment|/* 0 */
DECL|enumerator|OPT_S_START
id|OPT_S_START
comma
multiline_comment|/* 1 */
DECL|enumerator|OPT_S_READ
id|OPT_S_READ
comma
multiline_comment|/* 2 */
DECL|enumerator|OPT_S_DATA
id|OPT_S_DATA
comma
multiline_comment|/* 3 */
DECL|enumerator|OPT_S_STOP
id|OPT_S_STOP
comma
multiline_comment|/* 4 */
DECL|enumerator|OPT_S_STOPPING
id|OPT_S_STOPPING
multiline_comment|/* 5 */
)brace
suffix:semicolon
DECL|variable|opt_state
r_static
r_volatile
r_enum
id|opt_state_e
id|opt_state
op_assign
id|OPT_S_IDLE
suffix:semicolon
macro_line|#ifdef DEBUG_STATE
DECL|variable|opt_state_old
r_static
r_volatile
r_enum
id|opt_state_e
id|opt_state_old
op_assign
id|OPT_S_STOP
suffix:semicolon
DECL|variable|opt_st_old
r_static
r_volatile
r_int
id|opt_st_old
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_state_n
r_static
r_volatile
r_int
id|opt_state_n
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|opt_transfer_is_active
r_static
r_volatile
r_int
id|opt_transfer_is_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_error
r_static
r_volatile
r_int
id|opt_error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do something with this?? */
DECL|variable|optTries
r_static
r_int
id|optTries
suffix:semicolon
multiline_comment|/* ibid?? */
DECL|function|opt_poll
r_static
r_void
id|opt_poll
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|optTimeout
suffix:semicolon
r_static
r_volatile
r_int
id|opt_read_count
op_assign
l_int|1
suffix:semicolon
r_int
id|st
op_assign
l_int|0
suffix:semicolon
r_int
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|opt_error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: I/O error 0x%02x&bslash;n&quot;
comma
id|opt_error
)paren
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|optTries
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: read block %d failed; audio disk?&bslash;n&quot;
comma
id|opt_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|optTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: read block %d failed; Giving up&bslash;n&quot;
comma
id|opt_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_transfer_is_active
)paren
(brace
id|optTries
op_assign
l_int|0
suffix:semicolon
id|loop_ctl
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|optTries
op_assign
l_int|5
suffix:semicolon
)brace
id|opt_error
op_assign
l_int|0
suffix:semicolon
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
)brace
r_while
c_loop
(paren
id|loop_ctl
)paren
(brace
id|loop_ctl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* each case must flip this back to 1 if we want&n;&t;&t;                 to come back up here */
macro_line|#ifdef DEBUG_STATE
r_if
c_cond
(paren
id|opt_state
op_eq
id|opt_state_old
)paren
id|opt_state_n
op_increment
suffix:semicolon
r_else
(brace
id|opt_state_old
op_assign
id|opt_state
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|opt_state_n
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: %ld times in previous state&bslash;n&quot;
comma
id|opt_state_n
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: state %d&bslash;n&quot;
comma
id|opt_state
)paren
suffix:semicolon
id|opt_state_n
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|opt_state
)paren
(brace
r_case
id|OPT_S_IDLE
suffix:colon
r_return
suffix:semicolon
r_case
id|OPT_S_START
suffix:colon
r_if
c_cond
(paren
id|optSendCmd
c_func
(paren
id|COMDRVST
)paren
)paren
r_return
suffix:semicolon
id|opt_state
op_assign
id|OPT_S_READ
suffix:semicolon
id|optTimeout
op_assign
l_int|3000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_S_READ
suffix:colon
(brace
r_struct
id|opt_Play_msf
id|msf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optStatus
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|ST_DSK_CHG
)paren
(brace
id|optDiskChanged
op_assign
l_int|1
suffix:semicolon
id|optTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|ST_DOOR_OPEN
)paren
op_logical_or
(paren
id|st
op_amp
id|ST_DRVERR
)paren
)paren
(brace
id|optDiskChanged
op_assign
l_int|1
suffix:semicolon
id|optTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
(paren
id|st
op_amp
id|ST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;optcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;optcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_transfer_is_active
)paren
(brace
id|opt_state
op_assign
id|OPT_S_START
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|opt_state
op_assign
id|OPT_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
)paren
(brace
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|opt_next_bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|hsg2msf
c_func
(paren
id|opt_next_bn
comma
op_amp
id|msf.start
)paren
suffix:semicolon
id|opt_read_count
op_assign
id|OPT_BUF_SIZ
suffix:semicolon
id|msf.end.min
op_assign
l_int|0
suffix:semicolon
id|msf.end.sec
op_assign
l_int|0
suffix:semicolon
id|msf.end.frame
op_assign
id|opt_read_count
suffix:semicolon
macro_line|#ifdef DEBUG_REQUEST
id|printk
c_func
(paren
l_string|&quot;optcd: reading %x:%x.%x %x:%x.%x&bslash;n&quot;
comma
id|msf.start.min
comma
id|msf.start.sec
comma
id|msf.start.frame
comma
id|msf.end.min
comma
id|msf.end.sec
comma
id|msf.end.frame
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: opt_next_bn:%d opt_buf_in:%d opt_buf_out:%d opt_buf_bn:%d&bslash;n&quot;
comma
id|opt_next_bn
comma
id|opt_buf_in
comma
id|opt_buf_out
comma
id|opt_buf_bn
(braket
id|opt_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif
id|optReadCmd
c_func
(paren
id|COMREAD
comma
op_amp
id|msf
)paren
suffix:semicolon
id|opt_state
op_assign
id|OPT_S_DATA
suffix:semicolon
id|optTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|OPT_S_DATA
suffix:colon
id|st
op_assign
id|optFlags
c_func
(paren
)paren
op_amp
(paren
id|FL_STEN
op_or
id|FL_DTEN
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_STATE
r_if
c_cond
(paren
id|st
op_ne
id|opt_st_old
)paren
(brace
id|opt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_eq
id|FL_STEN
)paren
id|printk
c_func
(paren
l_string|&quot;timeout cnt: %d&bslash;n&quot;
comma
id|optTimeout
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|st
)paren
(brace
r_case
id|FL_DTEN
suffix:colon
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|optTries
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: read block %d failed; audio disk?&bslash;n&quot;
comma
id|opt_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|optTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: read block %d failed; Giving up&bslash;n&quot;
comma
id|opt_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_transfer_is_active
)paren
(brace
id|optTries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|optTries
op_assign
l_int|5
suffix:semicolon
)brace
id|opt_state
op_assign
id|OPT_S_START
suffix:semicolon
id|optTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_case
(paren
id|FL_STEN
op_or
id|FL_DTEN
)paren
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|optTries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
op_logical_and
id|opt_buf_in
op_eq
id|opt_buf_out
)paren
(brace
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_read_count
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: warning - try to read 0 frames&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|opt_read_count
)paren
(brace
id|opt_buf_bn
(braket
id|opt_buf_in
)braket
op_assign
id|OPT_NOBUF
suffix:semicolon
r_if
c_cond
(paren
id|dten_low
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* should be no waiting here!?? */
id|printk
c_func
(paren
l_string|&quot;read_count:%d CURRENT-&gt;nr_sectors:%ld opt_buf_in:%d&bslash;n&quot;
comma
id|opt_read_count
comma
id|CURRENT-&gt;nr_sectors
comma
id|opt_buf_in
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;opt_transfer_is_active:%x&bslash;n&quot;
comma
id|opt_transfer_is_active
)paren
suffix:semicolon
id|opt_read_count
op_assign
l_int|0
suffix:semicolon
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|optReadData
c_func
(paren
id|opt_buf
op_plus
id|OPT_BLOCKSIZE
op_star
id|opt_buf_in
comma
id|OPT_BLOCKSIZE
)paren
suffix:semicolon
id|opt_read_count
op_decrement
suffix:semicolon
macro_line|#ifdef DEBUG_REQUEST
id|printk
c_func
(paren
l_string|&quot;OPT_S_DATA; ---I&squot;ve read data- read_count: %d&bslash;n&quot;
comma
id|opt_read_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;opt_next_bn:%d  opt_buf_in:%d opt_buf_out:%d  opt_buf_bn:%d&bslash;n&quot;
comma
id|opt_next_bn
comma
id|opt_buf_in
comma
id|opt_buf_out
comma
id|opt_buf_bn
(braket
id|opt_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif
id|opt_buf_bn
(braket
id|opt_buf_in
)braket
op_assign
id|opt_next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opt_buf_out
op_eq
id|OPT_NOBUF
)paren
id|opt_buf_out
op_assign
id|opt_buf_in
suffix:semicolon
id|opt_buf_in
op_assign
id|opt_buf_in
op_plus
l_int|1
op_eq
id|OPT_BUF_SIZ
ques
c_cond
l_int|0
suffix:colon
id|opt_buf_in
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opt_transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
id|opt_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
op_logical_and
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
template_param
id|opt_next_bn
op_plus
id|OPT_BUF_SIZ
)paren
)paren
(brace
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|optTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|opt_read_count
op_eq
l_int|0
)paren
(brace
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|OPT_S_STOP
suffix:colon
r_if
c_cond
(paren
id|opt_read_count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;optcd: discard data=%x frames&bslash;n&quot;
comma
id|opt_read_count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|opt_read_count
op_ne
l_int|0
)paren
(brace
id|optFlushData
c_func
(paren
)paren
suffix:semicolon
id|opt_read_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|optSendCmd
c_func
(paren
id|COMDRVST
)paren
)paren
r_return
suffix:semicolon
id|opt_state
op_assign
id|OPT_S_STOPPING
suffix:semicolon
id|optTimeout
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_S_STOPPING
suffix:colon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optStatus
c_func
(paren
)paren
)paren
OL
l_int|0
op_logical_and
id|optTimeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|st
op_amp
id|ST_DSK_CHG
)paren
)paren
(brace
id|optDiskChanged
op_assign
l_int|1
suffix:semicolon
id|optTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
(brace
id|opt_state
op_assign
id|OPT_S_READ
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|opt_state
op_assign
id|OPT_S_START
suffix:semicolon
id|optTimeout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|opt_state
op_assign
id|OPT_S_IDLE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;optcd: invalid state %d&bslash;n&quot;
comma
id|opt_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* case */
)brace
multiline_comment|/* while */
r_if
c_cond
(paren
op_logical_neg
id|optTimeout
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: timeout in state %d&bslash;n&quot;
comma
id|opt_state
)paren
suffix:semicolon
id|opt_state
op_assign
id|OPT_S_STOP
suffix:semicolon
r_if
c_cond
(paren
id|optCmd
c_func
(paren
id|COMSTOP
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|opt_poll
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_optcd_request
r_static
r_void
id|do_optcd_request
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_REQUEST
id|printk
c_func
(paren
l_string|&quot;optcd: do_optcd_request(%ld+%ld)&bslash;n&quot;
comma
id|CURRENT
op_member_access_from_pointer
id|sector
comma
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|opt_transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|opt_transfer
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* First try to transfer block from buffers */
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Want to read a block not in buffer */
id|opt_buf_out
op_assign
id|OPT_NOBUF
suffix:semicolon
r_if
c_cond
(paren
id|opt_state
op_eq
id|OPT_S_IDLE
)paren
(brace
multiline_comment|/* Should this block the request queue?? */
r_if
c_cond
(paren
id|optUpdateToc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Start state machine */
id|opt_state
op_assign
id|OPT_S_START
suffix:semicolon
id|optTries
op_assign
l_int|5
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|opt_poll
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* why not start right away?? */
)brace
r_break
suffix:semicolon
)brace
)brace
id|opt_transfer_is_active
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_REQUEST
id|printk
c_func
(paren
l_string|&quot;opt_next_bn:%d  opt_buf_in:%d opt_buf_out:%d  opt_buf_bn:%d&bslash;n&quot;
comma
id|opt_next_bn
comma
id|opt_buf_in
comma
id|opt_buf_out
comma
id|opt_buf_bn
(braket
id|opt_buf_in
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: do_optcd_request ends&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* VFS calls */
DECL|function|opt_ioctl
r_static
r_int
id|opt_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_static
r_struct
id|opt_Play_msf
id|opt_Play
suffix:semicolon
multiline_comment|/* pause position */
r_int
id|err
suffix:semicolon
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: starting opt_ioctl, command 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|optGetStatus
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|optUpdateToc
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMPAUSE
suffix:colon
(brace
r_struct
id|opt_Toc
id|qInfo
suffix:semicolon
r_if
c_cond
(paren
id|optAudioStatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|optGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* didn&squot;t get q channel info */
id|optAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|opt_Play.start
op_assign
id|qInfo.diskTime
suffix:semicolon
multiline_comment|/* restart point */
r_if
c_cond
(paren
id|optCmd
c_func
(paren
id|COMPAUSEON
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|optAudioStatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMRESUME
suffix:colon
r_if
c_cond
(paren
id|optAudioStatus
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|optPlayCmd
c_func
(paren
id|COMPLAY
comma
op_amp
id|opt_Play
)paren
OL
l_int|0
)paren
(brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|opt_Play.start.min
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|opt_Play.start.sec
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|opt_Play.start.frame
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|opt_Play.end.min
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_min1
)paren
suffix:semicolon
id|opt_Play.end.sec
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_sec1
)paren
suffix:semicolon
id|opt_Play.end.frame
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_frame1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|optPlayCmd
c_func
(paren
id|COMPLAY
comma
op_amp
id|opt_Play
)paren
OL
l_int|0
)paren
(brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
template_param
id|DiskInfo.last
op_logical_or
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|DiskInfo.last
)paren
id|ti.cdti_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|opt_Play.start
op_assign
id|Toc
(braket
id|ti.cdti_trk0
)braket
dot
id|diskTime
suffix:semicolon
id|opt_Play.end
op_assign
id|Toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|diskTime
suffix:semicolon
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: play %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|opt_Play.start.min
comma
id|opt_Play.start.sec
comma
id|opt_Play.start.frame
comma
id|opt_Play.end.min
comma
id|opt_Play.end.sec
comma
id|opt_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|optPlayCmd
c_func
(paren
id|COMPLAY
comma
op_amp
id|opt_Play
)paren
OL
l_int|0
)paren
(brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|optAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
multiline_comment|/* Read the table of contents header. */
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tocHdr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|tocHdr
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|optTocUpToDate
)paren
id|optGetDiskInfo
c_func
(paren
)paren
suffix:semicolon
id|tocHdr.cdth_trk0
op_assign
id|DiskInfo.first
suffix:semicolon
id|tocHdr.cdth_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocHdr
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
multiline_comment|/* Read a table of contents entry. */
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|opt_Toc
op_star
id|tocPtr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|optTocUpToDate
)paren
id|optGetDiskInfo
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|DiskInfo.last
op_logical_or
id|entry.cdte_track
OL
id|DiskInfo.first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|entry.cdte_track
)braket
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
op_rshift
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|entry.cdte_format
)paren
(brace
r_case
id|CDROM_LBA
suffix:colon
id|entry.cdte_addr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|tocPtr
op_member_access_from_pointer
id|diskTime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_MSF
suffix:colon
id|entry.cdte_addr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.min
)paren
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.sec
)paren
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.frame
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMSTOP
suffix:colon
id|optCmd
c_func
(paren
id|COMSTOP
)paren
suffix:semicolon
id|optAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
id|optCmd
c_func
(paren
id|COMCLOSE
)paren
suffix:semicolon
multiline_comment|/* What else can we do? */
r_break
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
id|optCmd
c_func
(paren
id|COMUNLOCK
)paren
suffix:semicolon
id|optCmd
c_func
(paren
id|COMOPEN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|opt_Play.start.min
op_assign
l_int|0x10
suffix:semicolon
id|opt_Play.start.sec
op_assign
l_int|0x32
suffix:semicolon
id|opt_Play.start.frame
op_assign
id|volctrl.channel0
suffix:semicolon
id|opt_Play.end.min
op_assign
id|volctrl.channel1
suffix:semicolon
id|opt_Play.end.sec
op_assign
id|volctrl.channel2
suffix:semicolon
id|opt_Play.end.frame
op_assign
id|volctrl.channel3
suffix:semicolon
r_if
c_cond
(paren
id|optPlayCmd
c_func
(paren
id|COMCHCTRL
comma
op_amp
id|opt_Play
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
multiline_comment|/* Get subchannel info */
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
r_struct
id|opt_Toc
id|qInfo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|optGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|subchnl.cdsc_audiostatus
op_assign
id|optAudioStatus
suffix:semicolon
id|subchnl.cdsc_adr
op_assign
id|qInfo.ctrl_addr
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|qInfo.ctrl_addr
op_rshift
l_int|4
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.track
)paren
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|subchnl.cdsc_format
)paren
(brace
r_case
id|CDROM_LBA
suffix:colon
id|subchnl.cdsc_absaddr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|qInfo.diskTime
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|qInfo.trackTime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_MSF
suffix:colon
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.frame
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMREADMODE1
suffix:colon
(brace
r_int
id|st
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_char
id|buf
(braket
id|OPT_BLOCKSIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|OPT_BLOCKSIZE
)paren
)paren
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|opt_Play.start.min
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|opt_Play.start.sec
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|opt_Play.start.frame
op_assign
id|bin2bcd
c_func
(paren
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|opt_Play.end.min
op_assign
l_int|0
suffix:semicolon
id|opt_Play.end.sec
op_assign
l_int|0
suffix:semicolon
id|opt_Play.end.frame
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* read only one frame */
id|st
op_assign
id|optReadCmd
c_func
(paren
id|COMREAD
comma
op_amp
id|opt_Play
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: COMREAD status 0x%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
id|sleep_dten_low
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* error checking here?? */
id|optReadData
c_func
(paren
id|buf
comma
id|OPT_BLOCKSIZE
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf
comma
id|OPT_BLOCKSIZE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CDROMMULTISESSION
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* unluckily, not implemented yet */
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: exiting opt_ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|optPresent
r_static
r_int
id|optPresent
op_assign
l_int|0
suffix:semicolon
DECL|variable|opt_open_count
r_static
r_int
id|opt_open_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Open device special file; check that a disk is in. */
DECL|function|opt_open
r_static
r_int
id|opt_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: starting opt_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|optPresent
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* no hardware */
r_if
c_cond
(paren
op_logical_neg
id|opt_open_count
op_logical_and
id|opt_state
op_eq
id|OPT_S_IDLE
)paren
(brace
r_int
id|st
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optGetStatus
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|ST_DOOR_OPEN
)paren
(brace
id|optCmd
c_func
(paren
id|COMCLOSE
)paren
suffix:semicolon
multiline_comment|/* close door */
r_if
c_cond
(paren
(paren
id|st
op_assign
id|optGetStatus
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
multiline_comment|/* try again */
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_amp
(paren
id|ST_DOOR_OPEN
op_or
id|ST_DRVERR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: no disk or door open&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|optUpdateToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|opt_open_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|optCmd
c_func
(paren
id|COMLOCK
)paren
suffix:semicolon
multiline_comment|/* Lock door */
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: exiting opt_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Release device special file; flush all blocks from the buffer cache */
DECL|function|opt_release
r_static
r_void
id|opt_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
macro_line|#ifdef DEBUG_VFS
id|printk
c_func
(paren
l_string|&quot;optcd: executing opt_release&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;inode: %p, inode -&gt; i_rdev: 0x%x, file: %p&bslash;n&quot;
comma
id|ip
comma
id|ip
op_member_access_from_pointer
id|i_rdev
comma
id|fp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|opt_open_count
)paren
(brace
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|ip
op_member_access_from_pointer
id|i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|ip
op_member_access_from_pointer
id|i_rdev
)paren
suffix:semicolon
id|CLEAR_TIMER
suffix:semicolon
id|optCmd
c_func
(paren
id|COMUNLOCK
)paren
suffix:semicolon
multiline_comment|/* Unlock door */
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Initialisation */
DECL|function|version_ok
r_static
r_int
id|version_ok
c_func
(paren
r_void
)paren
(brace
r_char
id|devname
(braket
l_int|100
)braket
suffix:semicolon
r_int
id|count
comma
id|i
comma
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|optCmd
c_func
(paren
id|COMVERSION
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_assign
id|optGetData
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ch
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|optGetData
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|99
)paren
id|devname
(braket
id|i
op_increment
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|devname
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: Device %s detected&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_return
(paren
(paren
id|devname
(braket
l_int|0
)braket
op_eq
l_char|&squot;D&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|1
)braket
op_eq
l_char|&squot;O&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|2
)braket
op_eq
l_char|&squot;L&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|3
)braket
op_eq
l_char|&squot;P&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|4
)braket
op_eq
l_char|&squot;H&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|5
)braket
op_eq
l_char|&squot;I&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|6
)braket
op_eq
l_char|&squot;N&squot;
)paren
)paren
suffix:semicolon
)brace
DECL|variable|opt_fops
r_static
r_struct
id|file_operations
id|opt_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|opt_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|opt_open
comma
multiline_comment|/* open */
id|opt_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* media change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/* Get kernel parameter when used as a kernel driver */
DECL|function|optcd_setup
r_void
id|optcd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|optcd_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Test for presence of drive and initialize it. Called at boot time.&n; */
DECL|function|optcd_init
r_int
id|optcd_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|optcd_port
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: no Optics Storage CDROM Initialization&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|optcd_port
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: conflict, I/O port 0x%x already used&bslash;n&quot;
comma
id|optcd_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|ISP16_DRIVE_SET_PORT
comma
l_int|5
)paren
)paren
(brace
multiline_comment|/* If someone else has&squot;nt already reserved these ports,&n;&t;   probe for an ISP16 interface card, and enable SONY mode&n;&t;   with no interrupts and no DMA. (As far as I know, all optics&n;&t;   drives come with a SONY interface.) */
r_if
c_cond
(paren
(paren
id|isp16_type
op_assign
id|isp16_detect
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;No ISP16 cdrom interface found.&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|u_char
id|expected_drive
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ISP16 cdrom interface (%s optional IDE) detected.&bslash;n&quot;
comma
(paren
id|isp16_type
op_eq
l_int|2
)paren
ques
c_cond
l_string|&quot;with&quot;
suffix:colon
l_string|&quot;without&quot;
)paren
suffix:semicolon
id|expected_drive
op_assign
(paren
id|isp16_type
ques
c_cond
id|ISP16_SANYO1
suffix:colon
id|ISP16_SANYO0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isp16_config
c_func
(paren
id|optcd_port
comma
id|ISP16_SONY
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ISP16 cdrom interface has not been properly configured.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|optResetDrive
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: drive at 0x%x not ready&bslash;n&quot;
comma
id|optcd_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|version_ok
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: unknown drive detected; aborting&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|optCmd
c_func
(paren
id|COMINITDOUBLE
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: cannot init double speed mode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;optcd&quot;
comma
op_amp
id|opt_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: unable to get major %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
id|request_region
c_func
(paren
id|optcd_port
comma
l_int|4
comma
l_string|&quot;optcd&quot;
)paren
suffix:semicolon
id|optPresent
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: 8000 AT CDROM at 0x%x&bslash;n&quot;
comma
id|optcd_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|optcd_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;optcd&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;optcd: what&squot;s that: can&squot;t unregister&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|optcd_port
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;optcd: module released.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif MODULE
multiline_comment|/*&n; * -- ISP16 detection and configuration&n; *&n; *    Copyright (c) 1995, Eric van der Maarel &lt;maarel@marin.nl&gt;&n; *&n; *    Version 0.5&n; *&n; *    Detect cdrom interface on ISP16 soundcard.&n; *    Configure cdrom interface.&n; *&n; *    Algorithm for the card with no IDE support option taken&n; *    from the CDSETUP.SYS driver for MSDOS,&n; *    by OPTi Computers, version 2.03.&n; *    Algorithm for the IDE supporting ISP16 as communicated&n; *    to me by Vadim Model and Leo Spiekman.&n; *&n; *    Use, modifification or redistribution of this software is&n; *    allowed under the terms of the GPL.&n; *&n; */
DECL|macro|ISP16_IN
mdefine_line|#define ISP16_IN(p) (outb(isp16_ctrl,ISP16_CTRL_PORT), inb(p))
DECL|macro|ISP16_OUT
mdefine_line|#define ISP16_OUT(p,b) (outb(isp16_ctrl,ISP16_CTRL_PORT), outb(b,p))
r_static
r_int
DECL|function|isp16_detect
id|isp16_detect
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|isp16_with_ide__detect
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_else
r_return
id|isp16_no_ide__detect
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|isp16_no_ide__detect
id|isp16_no_ide__detect
c_func
(paren
r_void
)paren
(brace
id|u_char
id|ctrl
suffix:semicolon
id|u_char
id|enable_cdrom
suffix:semicolon
id|u_char
id|io
suffix:semicolon
r_int
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
id|isp16_ctrl
op_assign
id|ISP16_NO_IDE__CTRL
suffix:semicolon
id|isp16_enable_cdrom_port
op_assign
id|ISP16_NO_IDE__ENABLE_CDROM_PORT
suffix:semicolon
multiline_comment|/* read&squot; and write&squot; are a special read and write, respectively */
multiline_comment|/* read&squot; ISP16_CTRL_PORT, clear last two bits and write&squot; back the result */
id|ctrl
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_CTRL_PORT
)paren
op_amp
l_int|0xFC
suffix:semicolon
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* read&squot; 3,4 and 5-bit from the cdrom enable port */
id|enable_cdrom
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_NO_IDE__ENABLE_CDROM_PORT
)paren
op_amp
l_int|0x38
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|enable_cdrom
op_amp
l_int|0x20
)paren
)paren
(brace
multiline_comment|/* 5-bit not set */
multiline_comment|/* read&squot; last 2 bits of ISP16_IO_SET_PORT */
id|io
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_IO_SET_PORT
)paren
op_amp
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|io
op_amp
l_int|0x01
)paren
op_lshift
l_int|1
)paren
op_eq
(paren
id|io
op_amp
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* bits are the same */
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ...the same and 0 */
id|i
op_assign
l_int|0
suffix:semicolon
id|enable_cdrom
op_or_assign
l_int|0x20
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ...the same and 1 */
multiline_comment|/* my card, first time &squot;round */
id|i
op_assign
l_int|1
suffix:semicolon
id|enable_cdrom
op_or_assign
l_int|0x28
suffix:semicolon
)brace
id|ISP16_OUT
c_func
(paren
id|ISP16_NO_IDE__ENABLE_CDROM_PORT
comma
id|enable_cdrom
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* bits are not the same */
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
multiline_comment|/* -&gt; not detected: possibly incorrect conclusion */
)brace
)brace
r_else
r_if
c_cond
(paren
id|enable_cdrom
op_eq
l_int|0x20
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|enable_cdrom
op_eq
l_int|0x28
)paren
multiline_comment|/* my card, already initialised */
id|i
op_assign
l_int|1
suffix:semicolon
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_static
r_int
DECL|function|isp16_with_ide__detect
id|isp16_with_ide__detect
c_func
(paren
r_void
)paren
(brace
id|u_char
id|ctrl
suffix:semicolon
id|u_char
id|tmp
suffix:semicolon
id|isp16_ctrl
op_assign
id|ISP16_IDE__CTRL
suffix:semicolon
id|isp16_enable_cdrom_port
op_assign
id|ISP16_IDE__ENABLE_CDROM_PORT
suffix:semicolon
multiline_comment|/* read&squot; and write&squot; are a special read and write, respectively */
multiline_comment|/* read&squot; ISP16_CTRL_PORT and save */
id|ctrl
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_CTRL_PORT
)paren
suffix:semicolon
multiline_comment|/* write&squot; zero to the ctrl port and get response */
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
l_int|0
)paren
suffix:semicolon
id|tmp
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_CTRL_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|2
)paren
multiline_comment|/* isp16 with ide option not detected */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* restore ctrl port value */
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_static
r_int
DECL|function|isp16_config
id|isp16_config
c_func
(paren
r_int
id|base
comma
id|u_char
id|drive_type
comma
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
id|u_char
id|base_code
suffix:semicolon
id|u_char
id|irq_code
suffix:semicolon
id|u_char
id|dma_code
suffix:semicolon
id|u_char
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive_type
op_eq
id|ISP16_MITSUMI
)paren
op_logical_and
(paren
id|dma
op_ne
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Mitsumi cdrom drive has no dma support.&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|base
)paren
(brace
r_case
l_int|0x340
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_340
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x330
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_330
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x360
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_360
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x320
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_320
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Base address 0x%03X not supported by cdrom interface on ISP16.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|0
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_X
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* disable irq */
r_case
l_int|5
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_5
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Irq 5 shouldn&squot;t be used by cdrom interface on ISP16,&quot;
l_string|&quot; due to possible conflicts with the soundcard.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_7
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Irq 7 shouldn&squot;t be used by cdrom interface on ISP16,&quot;
l_string|&quot; due to possible conflicts with the soundcard.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_9
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_11
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Irq %d not supported by cdrom interface on ISP16.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dma
)paren
(brace
r_case
l_int|0
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_X
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* disable dma */
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Dma 1 cannot be used by cdrom interface on ISP16,&quot;
l_string|&quot; due to conflict with the soundcard.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Dma %d not supported by cdrom interface on ISP16.&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive_type
op_ne
id|ISP16_SONY
op_logical_and
id|drive_type
op_ne
id|ISP16_PANASONIC0
op_logical_and
id|drive_type
op_ne
id|ISP16_PANASONIC1
op_logical_and
id|drive_type
op_ne
id|ISP16_SANYO0
op_logical_and
id|drive_type
op_ne
id|ISP16_SANYO1
op_logical_and
id|drive_type
op_ne
id|ISP16_MITSUMI
op_logical_and
id|drive_type
op_ne
id|ISP16_DRIVE_X
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Drive type (code 0x%02X) not supported by cdrom&quot;
l_string|&quot; interface on ISP16.&bslash;n&quot;
comma
id|drive_type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set type of interface */
id|i
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_DRIVE_SET_PORT
)paren
op_amp
id|ISP16_DRIVE_SET_MASK
suffix:semicolon
multiline_comment|/* clear some bits */
id|ISP16_OUT
c_func
(paren
id|ISP16_DRIVE_SET_PORT
comma
id|i
op_or
id|drive_type
)paren
suffix:semicolon
multiline_comment|/* enable cdrom on interface with ide support */
r_if
c_cond
(paren
id|isp16_type
OG
l_int|1
)paren
id|ISP16_OUT
c_func
(paren
id|isp16_enable_cdrom_port
comma
id|ISP16_ENABLE_CDROM
)paren
suffix:semicolon
multiline_comment|/* set base address, irq and dma */
id|i
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_IO_SET_PORT
)paren
op_amp
id|ISP16_IO_SET_MASK
suffix:semicolon
multiline_comment|/* keep some bits */
id|ISP16_OUT
c_func
(paren
id|ISP16_IO_SET_PORT
comma
id|i
op_or
id|base_code
op_or
id|irq_code
op_or
id|dma_code
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
