multiline_comment|/*&t;linux/drivers/cdrom/optcd.c - Optics Storage 8000 AT CDROM driver&n;&t;$Id: optcd.c,v 1.11 1997/01/26 07:13:00 davem Exp $&n;&n;&t;Copyright (C) 1995 Leo Spiekman (spiekman@dutette.et.tudelft.nl)&n;&n;&n;&t;Based on Aztech CD268 CDROM driver by Werner Zimmermann and preworks&n;&t;by Eberhard Moenkeberg (emoenke@gwdg.de). &n;&n;&t;This program is free software; you can redistribute it and/or modify&n;&t;it under the terms of the GNU General Public License as published by&n;&t;the Free Software Foundation; either version 2, or (at your option)&n;&t;any later version.&n;&n;&t;This program is distributed in the hope that it will be useful,&n;&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n;&t;GNU General Public License for more details.&n;&n;&t;You should have received a copy of the GNU General Public License&n;&t;along with this program; if not, write to the Free Software&n;&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
"&f;"
multiline_comment|/*&t;Revision history&n;&n;&n;&t;14-5-95&t;&t;v0.0&t;Plays sound tracks. No reading of data CDs yet.&n;&t;&t;&t;&t;Detection of disk change doesn&squot;t work.&n;&t;21-5-95&t;&t;v0.1&t;First ALPHA version. CD can be mounted. The&n;&t;&t;&t;&t;device major nr is borrowed from the Aztech&n;&t;&t;&t;&t;driver. Speed is around 240 kb/s, as measured&n;&t;&t;&t;&t;with &quot;time dd if=/dev/cdrom of=/dev/null &bslash;&n;&t;&t;&t;&t;bs=2048 count=4096&quot;.&n;&t;24-6-95&t;&t;v0.2&t;Reworked the #defines for the command codes&n;&t;&t;&t;&t;and the like, as well as the structure of&n;&t;&t;&t;&t;the hardware communication protocol, to&n;&t;&t;&t;&t;reflect the &quot;official&quot; documentation, kindly&n;&t;&t;&t;&t;supplied by C.K. Tan, Optics Storage Pte. Ltd.&n;&t;&t;&t;&t;Also tidied up the state machine somewhat.&n;&t;28-6-95&t;&t;v0.3&t;Removed the ISP-16 interface code, as this&n;&t;&t;&t;&t;should go into its own driver. The driver now&n;&t;&t;&t;&t;has its own major nr.&n;&t;&t;&t;&t;Disk change detection now seems to work, too.&n;&t;&t;&t;&t;This version became part of the standard&n;&t;&t;&t;&t;kernel as of version 1.3.7&n;&t;24-9-95&t;&t;v0.4&t;Re-inserted ISP-16 interface code which I&n;&t;&t;&t;&t;copied from sjcd.c, with a few changes.&n;&t;&t;&t;&t;Updated README.optcd. Submitted for&n;&t;&t;&t;&t;inclusion in 1.3.21&n;&t;29-9-95&t;&t;v0.4a&t;Fixed bug that prevented compilation as module&n;&t;25-10-95&t;v0.5&t;Started multisession code. Implementation&n;&t;&t;&t;&t;copied from Werner Zimmermann, who copied it&n;&t;&t;&t;&t;from Heiko Schlittermann&squot;s mcdx.&n;&t;17-1-96&t;&t;v0.6&t;Multisession works; some cleanup too.&n;&t;18-4-96&t;&t;v0.7&t;Increased some timing constants;&n;&t;&t;&t;&t;thanks to Luke McFarlane. Also tidied up some&n;&t;&t;&t;&t;printk behaviour. ISP16 initialization&n;&t;&t;&t;&t;is now handled by a separate driver.&n;&t;&t;&t;&t;&n;&t;09-11-99 &t;  &t;Make kernel-parameter implementation work with 2.3.x &n;&t;                 &t;Removed init_module &amp; cleanup_module in favor of &n;&t;&t;&t; &t;module_init &amp; module_exit.&n;&t;&t;&t; &t;Torben Mathiasen &lt;tmm@image.dk&gt;&n;*/
"&f;"
multiline_comment|/* Includes */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR OPTICS_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &quot;optcd.h&quot;
macro_line|#include &lt;asm/uaccess.h&gt;
"&f;"
multiline_comment|/* Debug support */
multiline_comment|/* Don&squot;t forget to add new debug flags here. */
macro_line|#if DEBUG_DRIVE_IF | DEBUG_VFS | DEBUG_CONV | DEBUG_TOC | &bslash;&n;    DEBUG_BUFFERS | DEBUG_REQUEST | DEBUG_STATE | DEBUG_MULTIS
DECL|macro|DEBUG
mdefine_line|#define DEBUG(x) debug x
DECL|function|debug
r_static
r_void
id|debug
c_func
(paren
r_int
id|debug_this
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_char
id|s
(braket
l_int|1024
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|debug_this
)paren
r_return
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|s
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: %s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG(x)
macro_line|#endif
DECL|variable|blksize
r_static
r_int
id|blksize
op_assign
l_int|2048
suffix:semicolon
DECL|variable|hsecsize
r_static
r_int
id|hsecsize
op_assign
l_int|2048
suffix:semicolon
"&f;"
multiline_comment|/* Drive hardware/firmware characteristics&n;   Identifiers in accordance with Optics Storage documentation */
DECL|macro|optcd_port
mdefine_line|#define optcd_port optcd&t;&t;&t;/* Needed for the modutils. */
DECL|variable|optcd_port
r_static
r_int
id|optcd_port
op_assign
id|OPTCD_PORTBASE
suffix:semicolon
multiline_comment|/* I/O base of drive. */
id|MODULE_PARM
c_func
(paren
id|optcd_port
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
multiline_comment|/* Drive registers, read */
DECL|macro|DATA_PORT
mdefine_line|#define DATA_PORT&t;optcd_port&t;/* Read data/status */
DECL|macro|STATUS_PORT
mdefine_line|#define STATUS_PORT&t;optcd_port+1&t;/* Indicate data/status availability */
multiline_comment|/* Drive registers, write */
DECL|macro|COMIN_PORT
mdefine_line|#define COMIN_PORT&t;optcd_port&t;/* For passing command/parameter */
DECL|macro|RESET_PORT
mdefine_line|#define RESET_PORT&t;optcd_port+1&t;/* Write anything and wait 0.5 sec */
DECL|macro|HCON_PORT
mdefine_line|#define HCON_PORT&t;optcd_port+2&t;/* Host Xfer Configuration */
multiline_comment|/* Command completion/status read from DATA register */
DECL|macro|ST_DRVERR
mdefine_line|#define ST_DRVERR&t;&t;0x80
DECL|macro|ST_DOOR_OPEN
mdefine_line|#define ST_DOOR_OPEN&t;&t;0x40
DECL|macro|ST_MIXEDMODE_DISK
mdefine_line|#define ST_MIXEDMODE_DISK&t;0x20
DECL|macro|ST_MODE_BITS
mdefine_line|#define ST_MODE_BITS&t;&t;0x1c
DECL|macro|ST_M_STOP
mdefine_line|#define ST_M_STOP&t;&t;0x00
DECL|macro|ST_M_READ
mdefine_line|#define ST_M_READ&t;&t;0x04
DECL|macro|ST_M_AUDIO
mdefine_line|#define ST_M_AUDIO&t;&t;0x04
DECL|macro|ST_M_PAUSE
mdefine_line|#define ST_M_PAUSE&t;&t;0x08
DECL|macro|ST_M_INITIAL
mdefine_line|#define ST_M_INITIAL&t;&t;0x0c
DECL|macro|ST_M_ERROR
mdefine_line|#define ST_M_ERROR&t;&t;0x10
DECL|macro|ST_M_OTHERS
mdefine_line|#define ST_M_OTHERS&t;&t;0x14
DECL|macro|ST_MODE2TRACK
mdefine_line|#define&t;ST_MODE2TRACK&t;&t;0x02
DECL|macro|ST_DSK_CHG
mdefine_line|#define&t;ST_DSK_CHG&t;&t;0x01
DECL|macro|ST_L_LOCK
mdefine_line|#define ST_L_LOCK&t;&t;0x01
DECL|macro|ST_CMD_OK
mdefine_line|#define ST_CMD_OK&t;&t;0x00
DECL|macro|ST_OP_OK
mdefine_line|#define ST_OP_OK&t;&t;0x01
DECL|macro|ST_PA_OK
mdefine_line|#define ST_PA_OK&t;&t;0x02
DECL|macro|ST_OP_ERROR
mdefine_line|#define ST_OP_ERROR&t;&t;0x05
DECL|macro|ST_PA_ERROR
mdefine_line|#define ST_PA_ERROR&t;&t;0x06
multiline_comment|/* Error codes (appear as command completion code from DATA register) */
multiline_comment|/* Player related errors */
DECL|macro|ERR_ILLCMD
mdefine_line|#define ERR_ILLCMD&t;0x11&t;/* Illegal command to player module */
DECL|macro|ERR_ILLPARM
mdefine_line|#define ERR_ILLPARM&t;0x12&t;/* Illegal parameter to player module */
DECL|macro|ERR_SLEDGE
mdefine_line|#define ERR_SLEDGE&t;0x13
DECL|macro|ERR_FOCUS
mdefine_line|#define ERR_FOCUS&t;0x14
DECL|macro|ERR_MOTOR
mdefine_line|#define ERR_MOTOR&t;0x15
DECL|macro|ERR_RADIAL
mdefine_line|#define ERR_RADIAL&t;0x16
DECL|macro|ERR_PLL
mdefine_line|#define ERR_PLL&t;&t;0x17&t;/* PLL lock error */
DECL|macro|ERR_SUB_TIM
mdefine_line|#define ERR_SUB_TIM&t;0x18&t;/* Subcode timeout error */
DECL|macro|ERR_SUB_NF
mdefine_line|#define ERR_SUB_NF&t;0x19&t;/* Subcode not found error */
DECL|macro|ERR_TRAY
mdefine_line|#define ERR_TRAY&t;0x1a
DECL|macro|ERR_TOC
mdefine_line|#define ERR_TOC&t;&t;0x1b&t;/* Table of Contents read error */
DECL|macro|ERR_JUMP
mdefine_line|#define ERR_JUMP&t;0x1c
multiline_comment|/* Data errors */
DECL|macro|ERR_MODE
mdefine_line|#define ERR_MODE&t;0x21
DECL|macro|ERR_FORM
mdefine_line|#define ERR_FORM&t;0x22
DECL|macro|ERR_HEADADDR
mdefine_line|#define ERR_HEADADDR&t;0x23&t;/* Header Address not found */
DECL|macro|ERR_CRC
mdefine_line|#define ERR_CRC&t;&t;0x24
DECL|macro|ERR_ECC
mdefine_line|#define ERR_ECC&t;&t;0x25&t;/* Uncorrectable ECC error */
DECL|macro|ERR_CRC_UNC
mdefine_line|#define ERR_CRC_UNC&t;0x26&t;/* CRC error and uncorrectable error */
DECL|macro|ERR_ILLBSYNC
mdefine_line|#define ERR_ILLBSYNC&t;0x27&t;/* Illegal block sync error */
DECL|macro|ERR_VDST
mdefine_line|#define ERR_VDST&t;0x28&t;/* VDST not found */
multiline_comment|/* Timeout errors */
DECL|macro|ERR_READ_TIM
mdefine_line|#define ERR_READ_TIM&t;0x31&t;/* Read timeout error */
DECL|macro|ERR_DEC_STP
mdefine_line|#define ERR_DEC_STP&t;0x32&t;/* Decoder stopped */
DECL|macro|ERR_DEC_TIM
mdefine_line|#define ERR_DEC_TIM&t;0x33&t;/* Decoder interrupt timeout error */
multiline_comment|/* Function abort codes */
DECL|macro|ERR_KEY
mdefine_line|#define ERR_KEY&t;&t;0x41&t;/* Key -Detected abort */
DECL|macro|ERR_READ_FINISH
mdefine_line|#define ERR_READ_FINISH&t;0x42&t;/* Read Finish */
multiline_comment|/* Second Byte diagnostic codes */
DECL|macro|ERR_NOBSYNC
mdefine_line|#define ERR_NOBSYNC&t;0x01&t;/* No block sync */
DECL|macro|ERR_SHORTB
mdefine_line|#define ERR_SHORTB&t;0x02&t;/* Short block */
DECL|macro|ERR_LONGB
mdefine_line|#define ERR_LONGB&t;0x03&t;/* Long block */
DECL|macro|ERR_SHORTDSP
mdefine_line|#define ERR_SHORTDSP&t;0x04&t;/* Short DSP word */
DECL|macro|ERR_LONGDSP
mdefine_line|#define ERR_LONGDSP&t;0x05&t;/* Long DSP word */
multiline_comment|/* Status availability flags read from STATUS register */
DECL|macro|FL_EJECT
mdefine_line|#define FL_EJECT&t;0x20
DECL|macro|FL_WAIT
mdefine_line|#define FL_WAIT&t;&t;0x10&t;/* active low */
DECL|macro|FL_EOP
mdefine_line|#define FL_EOP&t;&t;0x08&t;/* active low */
DECL|macro|FL_STEN
mdefine_line|#define FL_STEN&t;&t;0x04&t;/* Status available when low */
DECL|macro|FL_DTEN
mdefine_line|#define FL_DTEN&t;&t;0x02&t;/* Data available when low */
DECL|macro|FL_DRQ
mdefine_line|#define FL_DRQ&t;&t;0x01&t;/* active low */
DECL|macro|FL_RESET
mdefine_line|#define FL_RESET&t;0xde&t;/* These bits are high after a reset */
DECL|macro|FL_STDT
mdefine_line|#define FL_STDT&t;&t;(FL_STEN|FL_DTEN)
multiline_comment|/* Transfer mode, written to HCON register */
DECL|macro|HCON_DTS
mdefine_line|#define HCON_DTS&t;0x08
DECL|macro|HCON_SDRQB
mdefine_line|#define HCON_SDRQB&t;0x04
DECL|macro|HCON_LOHI
mdefine_line|#define HCON_LOHI&t;0x02
DECL|macro|HCON_DMA16
mdefine_line|#define HCON_DMA16&t;0x01
multiline_comment|/* Drive command set, written to COMIN register */
multiline_comment|/* Quick response commands */
DECL|macro|COMDRVST
mdefine_line|#define COMDRVST&t;0x20&t;/* Drive Status Read */
DECL|macro|COMERRST
mdefine_line|#define COMERRST&t;0x21&t;/* Error Status Read */
DECL|macro|COMIOCTLISTAT
mdefine_line|#define COMIOCTLISTAT&t;0x22&t;/* Status Read; reset disk changed bit */
DECL|macro|COMINITSINGLE
mdefine_line|#define COMINITSINGLE&t;0x28&t;/* Initialize Single Speed */
DECL|macro|COMINITDOUBLE
mdefine_line|#define COMINITDOUBLE&t;0x29&t;/* Initialize Double Speed */
DECL|macro|COMUNLOCK
mdefine_line|#define COMUNLOCK&t;0x30&t;/* Unlock */
DECL|macro|COMLOCK
mdefine_line|#define COMLOCK&t;&t;0x31&t;/* Lock */
DECL|macro|COMLOCKST
mdefine_line|#define COMLOCKST&t;0x32&t;/* Lock/Unlock Status */
DECL|macro|COMVERSION
mdefine_line|#define COMVERSION&t;0x40&t;/* Get Firmware Revision */
DECL|macro|COMVOIDREADMODE
mdefine_line|#define COMVOIDREADMODE&t;0x50&t;/* Void Data Read Mode */
multiline_comment|/* Read commands */
DECL|macro|COMFETCH
mdefine_line|#define COMFETCH&t;0x60&t;/* Prefetch Data */
DECL|macro|COMREAD
mdefine_line|#define COMREAD&t;&t;0x61&t;/* Read */
DECL|macro|COMREADRAW
mdefine_line|#define COMREADRAW&t;0x62&t;/* Read Raw Data */
DECL|macro|COMREADALL
mdefine_line|#define COMREADALL&t;0x63&t;/* Read All 2646 Bytes */
multiline_comment|/* Player control commands */
DECL|macro|COMLEADIN
mdefine_line|#define COMLEADIN&t;0x70&t;/* Seek To Lead-in */
DECL|macro|COMSEEK
mdefine_line|#define COMSEEK&t;&t;0x71&t;/* Seek */
DECL|macro|COMPAUSEON
mdefine_line|#define COMPAUSEON&t;0x80&t;/* Pause On */
DECL|macro|COMPAUSEOFF
mdefine_line|#define COMPAUSEOFF&t;0x81&t;/* Pause Off */
DECL|macro|COMSTOP
mdefine_line|#define COMSTOP&t;&t;0x82&t;/* Stop */
DECL|macro|COMOPEN
mdefine_line|#define COMOPEN&t;&t;0x90&t;/* Open Tray Door */
DECL|macro|COMCLOSE
mdefine_line|#define COMCLOSE&t;0x91&t;/* Close Tray Door */
DECL|macro|COMPLAY
mdefine_line|#define COMPLAY&t;&t;0xa0&t;/* Audio Play */
DECL|macro|COMPLAY_TNO
mdefine_line|#define COMPLAY_TNO&t;0xa2&t;/* Audio Play By Track Number */
DECL|macro|COMSUBQ
mdefine_line|#define COMSUBQ&t;&t;0xb0&t;/* Read Sub-q Code */
DECL|macro|COMLOCATION
mdefine_line|#define COMLOCATION&t;0xb1&t;/* Read Head Position */
multiline_comment|/* Audio control commands */
DECL|macro|COMCHCTRL
mdefine_line|#define COMCHCTRL&t;0xc0&t;/* Audio Channel Control */
multiline_comment|/* Miscellaneous (test) commands */
DECL|macro|COMDRVTEST
mdefine_line|#define COMDRVTEST&t;0xd0&t;/* Write Test Bytes */
DECL|macro|COMTEST
mdefine_line|#define COMTEST&t;&t;0xd1&t;/* Diagnostic Test */
"&f;"
multiline_comment|/* Low level drive interface. Only here we do actual I/O&n;   Waiting for status / data available */
multiline_comment|/* Busy wait until FLAG goes low. Return 0 on timeout. */
DECL|function|flag_low
r_inline
r_static
r_int
id|flag_low
c_func
(paren
r_int
id|flag
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|flag_high
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|flag_high
op_assign
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|flag
)paren
)paren
)paren
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|timeout
)paren
r_break
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;flag_low 0x%x count %ld%s&quot;
comma
id|flag
comma
id|count
comma
id|flag_high
ques
c_cond
l_string|&quot; timeout&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
r_return
op_logical_neg
id|flag_high
suffix:semicolon
)brace
multiline_comment|/* Timed waiting for status or data */
DECL|variable|sleep_timeout
r_static
r_int
id|sleep_timeout
suffix:semicolon
multiline_comment|/* max # of ticks to sleep */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|waitq
)paren
suffix:semicolon
r_static
r_void
id|sleep_timer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
DECL|variable|delay_timer
r_static
r_struct
id|timer_list
id|delay_timer
op_assign
(brace
id|function
suffix:colon
id|sleep_timer
)brace
suffix:semicolon
multiline_comment|/* Timer routine: wake up when desired flag goes low,&n;   or when timeout expires. */
DECL|function|sleep_timer
r_static
r_void
id|sleep_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
id|flags
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_STDT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|FL_STDT
op_logical_and
op_decrement
id|sleep_timeout
OG
l_int|0
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|delay_timer
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/* multi-statement macro */
)brace
r_else
id|wake_up
c_func
(paren
op_amp
id|waitq
)paren
suffix:semicolon
)brace
multiline_comment|/* Sleep until FLAG goes low. Return 0 on timeout or wrong flag low. */
DECL|function|sleep_flag_low
r_static
r_int
id|sleep_flag_low
c_func
(paren
r_int
id|flag
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|flag_high
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;sleep_flag_low&quot;
)paren
)paren
suffix:semicolon
id|sleep_timeout
op_assign
id|timeout
suffix:semicolon
id|flag_high
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|flag_high
op_logical_and
id|sleep_timeout
OG
l_int|0
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|delay_timer
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|waitq
)paren
suffix:semicolon
id|flag_high
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|flag
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;flag 0x%x count %ld%s&quot;
comma
id|flag
comma
id|timeout
comma
id|flag_high
ques
c_cond
l_string|&quot; timeout&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
r_return
op_logical_neg
id|flag_high
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Low level drive interface. Only here we do actual I/O&n;   Sending commands and parameters */
multiline_comment|/* Errors in the command protocol */
DECL|macro|ERR_IF_CMD_TIMEOUT
mdefine_line|#define ERR_IF_CMD_TIMEOUT&t;0x100
DECL|macro|ERR_IF_ERR_TIMEOUT
mdefine_line|#define ERR_IF_ERR_TIMEOUT&t;0x101
DECL|macro|ERR_IF_RESP_TIMEOUT
mdefine_line|#define ERR_IF_RESP_TIMEOUT&t;0x102
DECL|macro|ERR_IF_DATA_TIMEOUT
mdefine_line|#define ERR_IF_DATA_TIMEOUT&t;0x103
DECL|macro|ERR_IF_NOSTAT
mdefine_line|#define ERR_IF_NOSTAT&t;&t;0x104
multiline_comment|/* Send command code. Return &lt;0 indicates error */
DECL|function|send_cmd
r_static
r_int
id|send_cmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
r_char
id|ack
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;sending command 0x%02x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|HCON_DTS
comma
id|HCON_PORT
)paren
suffix:semicolon
multiline_comment|/* Enable Suspend Data Transfer */
id|outb
c_func
(paren
id|cmd
comma
id|COMIN_PORT
)paren
suffix:semicolon
multiline_comment|/* Send command code */
r_if
c_cond
(paren
op_logical_neg
id|flag_low
c_func
(paren
id|FL_STEN
comma
id|BUSY_TIMEOUT
)paren
)paren
multiline_comment|/* Wait for status */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|ack
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command acknowledge */
id|outb
c_func
(paren
id|HCON_SDRQB
comma
id|HCON_PORT
)paren
suffix:semicolon
multiline_comment|/* Disable Suspend Data Transfer */
r_return
id|ack
op_eq
id|ST_OP_OK
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ack
suffix:semicolon
)brace
multiline_comment|/* Send command parameters. Return &lt;0 indicates error */
DECL|function|send_params
r_static
r_int
id|send_params
c_func
(paren
r_struct
id|cdrom_msf
op_star
id|params
)paren
(brace
r_int
r_char
id|ack
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;sending parameters&quot;
l_string|&quot; %02x:%02x:%02x&quot;
l_string|&quot; %02x:%02x:%02x&quot;
comma
id|params-&gt;cdmsf_min0
comma
id|params-&gt;cdmsf_sec0
comma
id|params-&gt;cdmsf_frame0
comma
id|params-&gt;cdmsf_min1
comma
id|params-&gt;cdmsf_sec1
comma
id|params-&gt;cdmsf_frame1
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_min0
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_sec0
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_frame0
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_min1
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_sec1
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_frame1
comma
id|COMIN_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag_low
c_func
(paren
id|FL_STEN
comma
id|BUSY_TIMEOUT
)paren
)paren
multiline_comment|/* Wait for status */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|ack
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command acknowledge */
r_return
id|ack
op_eq
id|ST_PA_OK
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ack
suffix:semicolon
)brace
multiline_comment|/* Send parameters for SEEK command. Return &lt;0 indicates error */
DECL|function|send_seek_params
r_static
r_int
id|send_seek_params
c_func
(paren
r_struct
id|cdrom_msf
op_star
id|params
)paren
(brace
r_int
r_char
id|ack
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;sending seek parameters&quot;
l_string|&quot; %02x:%02x:%02x&quot;
comma
id|params-&gt;cdmsf_min0
comma
id|params-&gt;cdmsf_sec0
comma
id|params-&gt;cdmsf_frame0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_min0
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_sec0
comma
id|COMIN_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params-&gt;cdmsf_frame0
comma
id|COMIN_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag_low
c_func
(paren
id|FL_STEN
comma
id|BUSY_TIMEOUT
)paren
)paren
multiline_comment|/* Wait for status */
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|ack
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read command acknowledge */
r_return
id|ack
op_eq
id|ST_PA_OK
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ack
suffix:semicolon
)brace
multiline_comment|/* Wait for command execution status. Choice between busy waiting&n;   and sleeping. Return value &lt;0 indicates timeout. */
DECL|function|get_exec_status
r_inline
r_static
r_int
id|get_exec_status
c_func
(paren
r_int
id|busy_waiting
)paren
(brace
r_int
r_char
id|exec_status
suffix:semicolon
r_if
c_cond
(paren
id|busy_waiting
ques
c_cond
op_logical_neg
id|flag_low
c_func
(paren
id|FL_STEN
comma
id|BUSY_TIMEOUT
)paren
suffix:colon
op_logical_neg
id|sleep_flag_low
c_func
(paren
id|FL_STEN
comma
id|SLEEP_TIMEOUT
)paren
)paren
r_return
op_minus
id|ERR_IF_CMD_TIMEOUT
suffix:semicolon
id|exec_status
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;returned exec status 0x%02x&quot;
comma
id|exec_status
)paren
)paren
suffix:semicolon
r_return
id|exec_status
suffix:semicolon
)brace
multiline_comment|/* Wait busy for extra byte of data that a command returns.&n;   Return value &lt;0 indicates timeout. */
DECL|function|get_data
r_inline
r_static
r_int
id|get_data
c_func
(paren
r_int
id|short_timeout
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag_low
c_func
(paren
id|FL_STEN
comma
id|short_timeout
ques
c_cond
id|FAST_TIMEOUT
suffix:colon
id|BUSY_TIMEOUT
)paren
)paren
r_return
op_minus
id|ERR_IF_DATA_TIMEOUT
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;returned data 0x%02x&quot;
comma
id|data
)paren
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if failed */
DECL|function|reset_drive
r_static
r_int
id|reset_drive
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;reset drive&quot;
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|RESET_PORT
)paren
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|count
OL
id|RESET_WAIT
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|flags
op_assign
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_RESET
)paren
)paren
op_ne
id|FL_RESET
)paren
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|BUSY_TIMEOUT
)paren
r_break
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;reset %s&quot;
comma
id|flags
op_eq
id|FL_RESET
ques
c_cond
l_string|&quot;succeeded&quot;
suffix:colon
l_string|&quot;failed&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
id|FL_RESET
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset failed */
id|outb
c_func
(paren
id|HCON_SDRQB
comma
id|HCON_PORT
)paren
suffix:semicolon
multiline_comment|/* Disable Suspend Data Transfer */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Reset succeeded */
)brace
multiline_comment|/* Facilities for asynchronous operation */
multiline_comment|/* Read status/data availability flags FL_STEN and FL_DTEN */
DECL|function|stdt_flags
r_inline
r_static
r_int
id|stdt_flags
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_STDT
suffix:semicolon
)brace
multiline_comment|/* Fetch status that has previously been waited for. &lt;0 means not available */
DECL|function|fetch_status
r_inline
r_static
r_int
id|fetch_status
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_STEN
)paren
r_return
op_minus
id|ERR_IF_NOSTAT
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;fetched exec status 0x%02x&quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Fetch data that has previously been waited for. */
DECL|function|fetch_data
r_inline
r_static
r_void
id|fetch_data
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|n
)paren
(brace
id|insb
c_func
(paren
id|DATA_PORT
comma
id|buf
comma
id|n
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;fetched 0x%x bytes&quot;
comma
id|n
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush status and data fifos */
DECL|function|flush_data
r_inline
r_static
r_void
id|flush_data
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|FL_STDT
)paren
op_ne
id|FL_STDT
)paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;flushed fifos&quot;
)paren
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Command protocol */
multiline_comment|/* Send a simple command and wait for response. Command codes &lt; COMFETCH&n;   are quick response commands */
DECL|function|exec_cmd
r_inline
r_static
r_int
id|exec_cmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
id|ack
op_assign
id|send_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_return
id|get_exec_status
c_func
(paren
id|cmd
OL
id|COMFETCH
)paren
suffix:semicolon
)brace
multiline_comment|/* Send a command with parameters. Don&squot;t wait for the response,&n; * which consists of data blocks read from the CD. */
DECL|function|exec_read_cmd
r_inline
r_static
r_int
id|exec_read_cmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|cdrom_msf
op_star
id|params
)paren
(brace
r_int
id|ack
op_assign
id|send_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_return
id|send_params
c_func
(paren
id|params
)paren
suffix:semicolon
)brace
multiline_comment|/* Send a seek command with parameters and wait for response */
DECL|function|exec_seek_cmd
r_inline
r_static
r_int
id|exec_seek_cmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|cdrom_msf
op_star
id|params
)paren
(brace
r_int
id|ack
op_assign
id|send_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
id|ack
op_assign
id|send_seek_params
c_func
(paren
id|params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send a command with parameters and wait for response */
DECL|function|exec_long_cmd
r_inline
r_static
r_int
id|exec_long_cmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|cdrom_msf
op_star
id|params
)paren
(brace
r_int
id|ack
op_assign
id|exec_read_cmd
c_func
(paren
id|cmd
comma
id|params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
OL
l_int|0
)paren
r_return
id|ack
suffix:semicolon
r_return
id|get_exec_status
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Address conversion routines */
multiline_comment|/* Binary to BCD (2 digits) */
DECL|function|single_bin2bcd
r_inline
r_static
r_void
id|single_bin2bcd
c_func
(paren
id|u_char
op_star
id|p
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_CONV
comma
l_string|&quot;bin2bcd %02d&quot;
comma
op_star
id|p
)paren
)paren
suffix:semicolon
op_star
id|p
op_assign
(paren
op_star
id|p
op_mod
l_int|10
)paren
op_or
(paren
(paren
op_star
id|p
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert entire msf struct */
DECL|function|bin2bcd
r_static
r_void
id|bin2bcd
c_func
(paren
r_struct
id|cdrom_msf
op_star
id|msf
)paren
(brace
id|single_bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_min0
)paren
suffix:semicolon
id|single_bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_sec0
)paren
suffix:semicolon
id|single_bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_frame0
)paren
suffix:semicolon
id|single_bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_min1
)paren
suffix:semicolon
id|single_bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_sec1
)paren
suffix:semicolon
id|single_bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_frame1
)paren
suffix:semicolon
)brace
multiline_comment|/* Linear block address to minute, second, frame form */
DECL|macro|CD_FPM
mdefine_line|#define CD_FPM&t;(CD_SECS * CD_FRAMES)&t;/* frames per minute */
DECL|function|lba2msf
r_static
r_void
id|lba2msf
c_func
(paren
r_int
id|lba
comma
r_struct
id|cdrom_msf
op_star
id|msf
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_CONV
comma
l_string|&quot;lba2msf %d&quot;
comma
id|lba
)paren
)paren
suffix:semicolon
id|lba
op_add_assign
id|CD_MSF_OFFSET
suffix:semicolon
id|msf-&gt;cdmsf_min0
op_assign
id|lba
op_div
id|CD_FPM
suffix:semicolon
id|lba
op_mod_assign
id|CD_FPM
suffix:semicolon
id|msf-&gt;cdmsf_sec0
op_assign
id|lba
op_div
id|CD_FRAMES
suffix:semicolon
id|msf-&gt;cdmsf_frame0
op_assign
id|lba
op_mod
id|CD_FRAMES
suffix:semicolon
id|msf-&gt;cdmsf_min1
op_assign
l_int|0
suffix:semicolon
id|msf-&gt;cdmsf_sec1
op_assign
l_int|0
suffix:semicolon
id|msf-&gt;cdmsf_frame1
op_assign
l_int|0
suffix:semicolon
id|bin2bcd
c_func
(paren
id|msf
)paren
suffix:semicolon
)brace
multiline_comment|/* Two BCD digits to binary */
DECL|function|bcd2bin
r_inline
r_static
id|u_char
id|bcd2bin
c_func
(paren
id|u_char
id|bcd
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_CONV
comma
l_string|&quot;bcd2bin %x%02x&quot;
comma
id|bcd
)paren
)paren
suffix:semicolon
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
DECL|function|msf2lba
r_static
r_void
id|msf2lba
c_func
(paren
r_union
id|cdrom_addr
op_star
id|addr
)paren
(brace
id|addr-&gt;lba
op_assign
id|addr-&gt;msf.minute
op_star
id|CD_FPM
op_plus
id|addr-&gt;msf.second
op_star
id|CD_FRAMES
op_plus
id|addr-&gt;msf.frame
op_minus
id|CD_MSF_OFFSET
suffix:semicolon
)brace
multiline_comment|/* Minute, second, frame address BCD to binary or to linear address,&n;   depending on MODE */
DECL|function|msf_bcd2bin
r_static
r_void
id|msf_bcd2bin
c_func
(paren
r_union
id|cdrom_addr
op_star
id|addr
)paren
(brace
id|addr-&gt;msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|addr-&gt;msf.minute
)paren
suffix:semicolon
id|addr-&gt;msf.second
op_assign
id|bcd2bin
c_func
(paren
id|addr-&gt;msf.second
)paren
suffix:semicolon
id|addr-&gt;msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|addr-&gt;msf.frame
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* High level drive commands */
DECL|variable|audio_status
r_static
r_int
id|audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
DECL|variable|toc_uptodate
r_static
r_char
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
DECL|variable|disk_changed
r_static
r_char
id|disk_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Get drive status, flagging completion of audio play and disk changes. */
DECL|function|drive_status
r_static
r_int
id|drive_status
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMIOCTLISTAT
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_DRIVE_IF
comma
l_string|&quot;IOCTLISTAT: %03x&quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0xff
)paren
multiline_comment|/* No status available */
r_return
op_minus
id|ERR_IF_NOSTAT
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|status
op_amp
id|ST_MODE_BITS
)paren
op_ne
id|ST_M_AUDIO
)paren
op_logical_and
(paren
id|audio_status
op_eq
id|CDROM_AUDIO_PLAY
)paren
)paren
(brace
id|audio_status
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ST_DSK_CHG
)paren
(brace
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|disk_changed
op_assign
l_int|1
suffix:semicolon
id|audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Read the current Q-channel info. Also used for reading the&n;   table of contents. qp-&gt;cdsc_format must be set on entry to&n;   indicate the desired address format */
DECL|function|get_q_channel
r_static
r_int
id|get_q_channel
c_func
(paren
r_struct
id|cdrom_subchnl
op_star
id|qp
)paren
(brace
r_int
id|status
comma
id|d1
comma
id|d2
comma
id|d3
comma
id|d4
comma
id|d5
comma
id|d6
comma
id|d7
comma
id|d8
comma
id|d9
comma
id|d10
suffix:semicolon
id|status
op_assign
id|drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
id|qp-&gt;cdsc_audiostatus
op_assign
id|audio_status
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMSUBQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
id|d1
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d1
OL
l_int|0
)paren
r_return
id|d1
suffix:semicolon
id|qp-&gt;cdsc_adr
op_assign
id|d1
suffix:semicolon
id|qp-&gt;cdsc_ctrl
op_assign
id|d1
op_rshift
l_int|4
suffix:semicolon
id|d2
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d2
OL
l_int|0
)paren
r_return
id|d2
suffix:semicolon
id|qp-&gt;cdsc_trk
op_assign
id|bcd2bin
c_func
(paren
id|d2
)paren
suffix:semicolon
id|d3
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d3
OL
l_int|0
)paren
r_return
id|d3
suffix:semicolon
id|qp-&gt;cdsc_ind
op_assign
id|bcd2bin
c_func
(paren
id|d3
)paren
suffix:semicolon
id|d4
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d4
OL
l_int|0
)paren
r_return
id|d4
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.minute
op_assign
id|d4
suffix:semicolon
id|d5
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d5
OL
l_int|0
)paren
r_return
id|d5
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.second
op_assign
id|d5
suffix:semicolon
id|d6
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d6
OL
l_int|0
)paren
r_return
id|d6
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.frame
op_assign
id|d6
suffix:semicolon
id|d7
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d7
OL
l_int|0
)paren
r_return
id|d7
suffix:semicolon
multiline_comment|/* byte not used */
id|d8
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d8
OL
l_int|0
)paren
r_return
id|d8
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.minute
op_assign
id|d8
suffix:semicolon
id|d9
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d9
OL
l_int|0
)paren
r_return
id|d9
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.second
op_assign
id|d9
suffix:semicolon
id|d10
op_assign
id|get_data
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d10
OL
l_int|0
)paren
r_return
id|d10
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.frame
op_assign
id|d10
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x&quot;
comma
id|d1
comma
id|d2
comma
id|d3
comma
id|d4
comma
id|d5
comma
id|d6
comma
id|d7
comma
id|d8
comma
id|d9
comma
id|d10
)paren
)paren
suffix:semicolon
id|msf_bcd2bin
c_func
(paren
op_amp
id|qp-&gt;cdsc_absaddr
)paren
suffix:semicolon
id|msf_bcd2bin
c_func
(paren
op_amp
id|qp-&gt;cdsc_reladdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qp-&gt;cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|msf2lba
c_func
(paren
op_amp
id|qp-&gt;cdsc_absaddr
)paren
suffix:semicolon
id|msf2lba
c_func
(paren
op_amp
id|qp-&gt;cdsc_reladdr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Table of contents handling */
multiline_comment|/* Errors in table of contents */
DECL|macro|ERR_TOC_MISSINGINFO
mdefine_line|#define ERR_TOC_MISSINGINFO&t;0x120
DECL|macro|ERR_TOC_MISSINGENTRY
mdefine_line|#define ERR_TOC_MISSINGENTRY&t;0x121
DECL|struct|cdrom_disk_info
r_struct
id|cdrom_disk_info
(brace
DECL|member|first
r_int
r_char
id|first
suffix:semicolon
DECL|member|last
r_int
r_char
id|last
suffix:semicolon
DECL|member|disk_length
r_struct
id|cdrom_msf0
id|disk_length
suffix:semicolon
DECL|member|first_track
r_struct
id|cdrom_msf0
id|first_track
suffix:semicolon
multiline_comment|/* Multisession info: */
DECL|member|next
r_int
r_char
id|next
suffix:semicolon
DECL|member|next_session
r_struct
id|cdrom_msf0
id|next_session
suffix:semicolon
DECL|member|last_session
r_struct
id|cdrom_msf0
id|last_session
suffix:semicolon
DECL|member|multi
r_int
r_char
id|multi
suffix:semicolon
DECL|member|xa
r_int
r_char
id|xa
suffix:semicolon
DECL|member|audio
r_int
r_char
id|audio
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|disk_info
r_static
r_struct
id|cdrom_disk_info
id|disk_info
suffix:semicolon
DECL|macro|MAX_TRACKS
mdefine_line|#define MAX_TRACKS&t;&t;111
DECL|variable|toc
r_static
r_struct
id|cdrom_subchnl
id|toc
(braket
id|MAX_TRACKS
)braket
suffix:semicolon
DECL|macro|QINFO_FIRSTTRACK
mdefine_line|#define QINFO_FIRSTTRACK&t;100 /* bcd2bin(0xa0) */
DECL|macro|QINFO_LASTTRACK
mdefine_line|#define QINFO_LASTTRACK&t;&t;101 /* bcd2bin(0xa1) */
DECL|macro|QINFO_DISKLENGTH
mdefine_line|#define QINFO_DISKLENGTH&t;102 /* bcd2bin(0xa2) */
DECL|macro|QINFO_NEXTSESSION
mdefine_line|#define QINFO_NEXTSESSION&t;110 /* bcd2bin(0xb0) */
DECL|macro|I_FIRSTTRACK
mdefine_line|#define I_FIRSTTRACK&t;0x01
DECL|macro|I_LASTTRACK
mdefine_line|#define I_LASTTRACK&t;0x02
DECL|macro|I_DISKLENGTH
mdefine_line|#define I_DISKLENGTH&t;0x04
DECL|macro|I_NEXTSESSION
mdefine_line|#define I_NEXTSESSION&t;0x08
DECL|macro|I_ALL
mdefine_line|#define I_ALL&t;(I_FIRSTTRACK | I_LASTTRACK | I_DISKLENGTH)
macro_line|#if DEBUG_TOC
DECL|function|toc_debug_info
r_void
id|toc_debug_info
c_func
(paren
r_int
id|i
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;#%3d ctl %1x, adr %1x, track %2d index %3d&quot;
l_string|&quot;  %2d:%02d.%02d %2d:%02d.%02d&bslash;n&quot;
comma
id|i
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_ctrl
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_adr
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_trk
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_ind
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_reladdr.msf.minute
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_reladdr.msf.second
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_reladdr.msf.frame
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_absaddr.msf.minute
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_absaddr.msf.second
comma
id|toc
(braket
id|i
)braket
dot
id|cdsc_absaddr.msf.frame
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|read_toc
r_static
r_int
id|read_toc
c_func
(paren
r_void
)paren
(brace
r_int
id|status
comma
id|limit
comma
id|count
suffix:semicolon
r_int
r_char
id|got_info
op_assign
l_int|0
suffix:semicolon
r_struct
id|cdrom_subchnl
id|q_info
suffix:semicolon
macro_line|#if DEBUG_TOC
r_int
id|i
suffix:semicolon
macro_line|#endif
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;starting read_toc&quot;
)paren
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|60
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_int
id|index
suffix:semicolon
id|q_info.cdsc_format
op_assign
id|CDROM_MSF
suffix:semicolon
id|status
op_assign
id|get_q_channel
c_func
(paren
op_amp
id|q_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
id|index
op_assign
id|q_info.cdsc_ind
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
l_int|0
op_logical_and
id|index
OL
id|MAX_TRACKS
op_logical_and
id|q_info.cdsc_trk
op_eq
l_int|0
op_logical_and
id|toc
(braket
id|index
)braket
dot
id|cdsc_ind
op_eq
l_int|0
)paren
(brace
id|toc
(braket
id|index
)braket
op_assign
id|q_info
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;got %d&quot;
comma
id|index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
l_int|100
)paren
id|count
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|q_info.cdsc_ind
)paren
(brace
r_case
id|QINFO_FIRSTTRACK
suffix:colon
id|got_info
op_or_assign
id|I_FIRSTTRACK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QINFO_LASTTRACK
suffix:colon
id|got_info
op_or_assign
id|I_LASTTRACK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QINFO_DISKLENGTH
suffix:colon
id|got_info
op_or_assign
id|I_DISKLENGTH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QINFO_NEXTSESSION
suffix:colon
id|got_info
op_or_assign
id|I_NEXTSESSION
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|got_info
op_amp
id|I_ALL
)paren
op_eq
id|I_ALL
op_logical_and
id|toc
(braket
id|QINFO_FIRSTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
op_plus
id|count
op_ge
id|toc
(braket
id|QINFO_LASTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
op_plus
l_int|1
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Construct disk_info from TOC */
r_if
c_cond
(paren
id|disk_info.first
op_eq
l_int|0
)paren
(brace
id|disk_info.first
op_assign
id|toc
(braket
id|QINFO_FIRSTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|disk_info.first_track.minute
op_assign
id|toc
(braket
id|disk_info.first
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|disk_info.first_track.second
op_assign
id|toc
(braket
id|disk_info.first
)braket
dot
id|cdsc_absaddr.msf.second
suffix:semicolon
id|disk_info.first_track.frame
op_assign
id|toc
(braket
id|disk_info.first
)braket
dot
id|cdsc_absaddr.msf.frame
suffix:semicolon
)brace
id|disk_info.last
op_assign
id|toc
(braket
id|QINFO_LASTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|disk_info.disk_length.minute
op_assign
id|toc
(braket
id|QINFO_DISKLENGTH
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|disk_info.disk_length.second
op_assign
id|toc
(braket
id|QINFO_DISKLENGTH
)braket
dot
id|cdsc_absaddr.msf.second
op_minus
l_int|2
suffix:semicolon
id|disk_info.disk_length.frame
op_assign
id|toc
(braket
id|QINFO_DISKLENGTH
)braket
dot
id|cdsc_absaddr.msf.frame
suffix:semicolon
id|disk_info.next_session.minute
op_assign
id|toc
(braket
id|QINFO_NEXTSESSION
)braket
dot
id|cdsc_reladdr.msf.minute
suffix:semicolon
id|disk_info.next_session.second
op_assign
id|toc
(braket
id|QINFO_NEXTSESSION
)braket
dot
id|cdsc_reladdr.msf.second
suffix:semicolon
id|disk_info.next_session.frame
op_assign
id|toc
(braket
id|QINFO_NEXTSESSION
)braket
dot
id|cdsc_reladdr.msf.frame
suffix:semicolon
id|disk_info.next
op_assign
id|toc
(braket
id|QINFO_FIRSTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|disk_info.last_session.minute
op_assign
id|toc
(braket
id|disk_info.next
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|disk_info.last_session.second
op_assign
id|toc
(braket
id|disk_info.next
)braket
dot
id|cdsc_absaddr.msf.second
suffix:semicolon
id|disk_info.last_session.frame
op_assign
id|toc
(braket
id|disk_info.next
)braket
dot
id|cdsc_absaddr.msf.frame
suffix:semicolon
id|toc
(braket
id|disk_info.last
op_plus
l_int|1
)braket
dot
id|cdsc_absaddr.msf.minute
op_assign
id|disk_info.disk_length.minute
suffix:semicolon
id|toc
(braket
id|disk_info.last
op_plus
l_int|1
)braket
dot
id|cdsc_absaddr.msf.second
op_assign
id|disk_info.disk_length.second
suffix:semicolon
id|toc
(braket
id|disk_info.last
op_plus
l_int|1
)braket
dot
id|cdsc_absaddr.msf.frame
op_assign
id|disk_info.disk_length.frame
suffix:semicolon
macro_line|#if DEBUG_TOC
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|disk_info.last
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|toc_debug_info
c_func
(paren
id|i
)paren
suffix:semicolon
id|toc_debug_info
c_func
(paren
id|QINFO_FIRSTTRACK
)paren
suffix:semicolon
id|toc_debug_info
c_func
(paren
id|QINFO_LASTTRACK
)paren
suffix:semicolon
id|toc_debug_info
c_func
(paren
id|QINFO_DISKLENGTH
)paren
suffix:semicolon
id|toc_debug_info
c_func
(paren
id|QINFO_NEXTSESSION
)paren
suffix:semicolon
macro_line|#endif
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;exiting read_toc, got_info %x, count %d&quot;
comma
id|got_info
comma
id|count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|got_info
op_amp
id|I_ALL
)paren
op_ne
id|I_ALL
op_logical_or
id|toc
(braket
id|QINFO_FIRSTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
op_plus
id|count
OL
id|toc
(braket
id|QINFO_LASTTRACK
)braket
dot
id|cdsc_absaddr.msf.minute
op_plus
l_int|1
)paren
r_return
op_minus
id|ERR_TOC_MISSINGINFO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MULTISESSION
DECL|function|get_multi_disk_info
r_static
r_int
id|get_multi_disk_info
c_func
(paren
r_void
)paren
(brace
r_int
id|sessions
comma
id|status
suffix:semicolon
r_struct
id|cdrom_msf
id|multi_index
suffix:semicolon
r_for
c_loop
(paren
id|sessions
op_assign
l_int|2
suffix:semicolon
id|sessions
OL
l_int|10
multiline_comment|/* %%for now */
suffix:semicolon
id|sessions
op_increment
)paren
(brace
r_int
id|count
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|100
suffix:semicolon
id|count
OL
id|MAX_TRACKS
suffix:semicolon
id|count
op_increment
)paren
id|toc
(braket
id|count
)braket
dot
id|cdsc_ind
op_assign
l_int|0
suffix:semicolon
id|multi_index.cdmsf_min0
op_assign
id|disk_info.next_session.minute
suffix:semicolon
id|multi_index.cdmsf_sec0
op_assign
id|disk_info.next_session.second
suffix:semicolon
id|multi_index.cdmsf_frame0
op_assign
id|disk_info.next_session.frame
suffix:semicolon
r_if
c_cond
(paren
id|multi_index.cdmsf_sec0
op_ge
l_int|20
)paren
id|multi_index.cdmsf_sec0
op_sub_assign
l_int|20
suffix:semicolon
r_else
(brace
id|multi_index.cdmsf_sec0
op_add_assign
l_int|40
suffix:semicolon
id|multi_index.cdmsf_min0
op_decrement
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_MULTIS
comma
l_string|&quot;Try %d: %2d:%02d.%02d&quot;
comma
id|sessions
comma
id|multi_index.cdmsf_min0
comma
id|multi_index.cdmsf_sec0
comma
id|multi_index.cdmsf_frame0
)paren
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|multi_index
)paren
suffix:semicolon
id|multi_index.cdmsf_min1
op_assign
l_int|0
suffix:semicolon
id|multi_index.cdmsf_sec1
op_assign
l_int|0
suffix:semicolon
id|multi_index.cdmsf_frame1
op_assign
l_int|1
suffix:semicolon
id|status
op_assign
id|exec_read_cmd
c_func
(paren
id|COMREAD
comma
op_amp
id|multi_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;exec_read_cmd COMREAD: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|sleep_flag_low
c_func
(paren
id|FL_DTEN
comma
id|MULTI_SEEK_TIMEOUT
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ERR_TOC_MISSINGINFO
suffix:semicolon
id|flush_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;sleep_flag_low: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|read_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;read_toc: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|disk_info.multi
op_assign
l_int|1
suffix:semicolon
)brace
id|exec_cmd
c_func
(paren
id|COMSTOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif MULTISESSION
DECL|function|update_toc
r_static
r_int
id|update_toc
c_func
(paren
r_void
)paren
(brace
r_int
id|status
comma
id|count
suffix:semicolon
r_if
c_cond
(paren
id|toc_uptodate
)paren
r_return
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;starting update_toc&quot;
)paren
)paren
suffix:semicolon
id|disk_info.first
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|MAX_TRACKS
suffix:semicolon
id|count
op_increment
)paren
id|toc
(braket
id|count
)braket
dot
id|cdsc_ind
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMLEADIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|status
op_assign
id|read_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;read_toc: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Audio disk detection. Look at first track. */
id|disk_info.audio
op_assign
(paren
id|toc
(braket
id|disk_info.first
)braket
dot
id|cdsc_ctrl
op_amp
id|CDROM_DATA_TRACK
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* XA detection */
id|disk_info.xa
op_assign
id|drive_status
c_func
(paren
)paren
op_amp
id|ST_MODE2TRACK
suffix:semicolon
multiline_comment|/* Multisession detection: if we want this, define MULTISESSION */
id|disk_info.multi
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MULTISESSION
r_if
c_cond
(paren
id|disk_info.xa
)paren
id|get_multi_disk_info
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Here disk_info.multi is set */
macro_line|#endif MULTISESSION
r_if
c_cond
(paren
id|disk_info.multi
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;optcd: Multisession support experimental, &quot;
l_string|&quot;see linux/Documentation/cdrom/optcd&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_TOC
comma
l_string|&quot;exiting update_toc&quot;
)paren
)paren
suffix:semicolon
id|toc_uptodate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Request handling */
DECL|macro|CURRENT_VALID
mdefine_line|#define CURRENT_VALID &bslash;&n;&t;(!QUEUE_EMPTY &amp;&amp; MAJOR(CURRENT -&gt; rq_dev) == MAJOR_NR &bslash;&n;&t; &amp;&amp; CURRENT -&gt; cmd == READ &amp;&amp; CURRENT -&gt; sector != -1)
multiline_comment|/* Buffers for block size conversion. */
DECL|macro|NOBUF
mdefine_line|#define NOBUF&t;&t;-1
DECL|variable|buf
r_static
r_char
id|buf
(braket
id|CD_FRAMESIZE
op_star
id|N_BUFS
)braket
suffix:semicolon
DECL|variable|buf_bn
DECL|variable|next_bn
r_static
r_volatile
r_int
id|buf_bn
(braket
id|N_BUFS
)braket
comma
id|next_bn
suffix:semicolon
DECL|variable|buf_in
DECL|variable|buf_out
r_static
r_volatile
r_int
id|buf_in
op_assign
l_int|0
comma
id|buf_out
op_assign
id|NOBUF
suffix:semicolon
DECL|function|opt_invalidate_buffers
r_inline
r_static
r_void
id|opt_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_BUFFERS
comma
l_string|&quot;executing opt_invalidate_buffers&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_BUFS
suffix:semicolon
id|i
op_increment
)paren
id|buf_bn
(braket
id|i
)braket
op_assign
id|NOBUF
suffix:semicolon
id|buf_out
op_assign
id|NOBUF
suffix:semicolon
)brace
multiline_comment|/* Take care of the different block sizes between cdrom and Linux.&n;   When Linux gets variable block sizes this will probably go away. */
DECL|function|transfer
r_static
r_void
id|transfer
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG_BUFFERS | DEBUG_REQUEST
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: executing transfer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
(brace
r_int
id|bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
r_int
id|i
comma
id|offs
comma
id|nr_sectors
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_BUFS
op_logical_and
id|buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;found %d&quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|N_BUFS
)paren
(brace
id|buf_out
op_assign
id|NOBUF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf_out
op_ne
id|i
)paren
(brace
id|buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|buf_out
op_assign
id|NOBUF
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT
op_member_access_from_pointer
id|buffer
comma
id|buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
)brace
multiline_comment|/* State machine for reading disk blocks */
DECL|enum|state_e
r_enum
id|state_e
(brace
DECL|enumerator|S_IDLE
id|S_IDLE
comma
multiline_comment|/* 0 */
DECL|enumerator|S_START
id|S_START
comma
multiline_comment|/* 1 */
DECL|enumerator|S_READ
id|S_READ
comma
multiline_comment|/* 2 */
DECL|enumerator|S_DATA
id|S_DATA
comma
multiline_comment|/* 3 */
DECL|enumerator|S_STOP
id|S_STOP
comma
multiline_comment|/* 4 */
DECL|enumerator|S_STOPPING
id|S_STOPPING
multiline_comment|/* 5 */
)brace
suffix:semicolon
DECL|variable|state
r_static
r_volatile
r_enum
id|state_e
id|state
op_assign
id|S_IDLE
suffix:semicolon
macro_line|#if DEBUG_STATE
DECL|variable|state_old
r_static
r_volatile
r_enum
id|state_e
id|state_old
op_assign
id|S_STOP
suffix:semicolon
DECL|variable|flags_old
r_static
r_volatile
r_int
id|flags_old
op_assign
l_int|0
suffix:semicolon
DECL|variable|state_n
r_static
r_volatile
r_int
id|state_n
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Used as mutex to keep do_optcd_request (and other processes calling&n;   ioctl) out while some process is inside a VFS call.&n;   Reverse is accomplished by checking if state = S_IDLE upon entry&n;   of opt_ioctl and opt_media_change. */
DECL|variable|in_vfs
r_static
r_int
id|in_vfs
op_assign
l_int|0
suffix:semicolon
DECL|variable|transfer_is_active
r_static
r_volatile
r_int
id|transfer_is_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|error
r_static
r_volatile
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* %% do something with this?? */
DECL|variable|tries
r_static
r_int
id|tries
suffix:semicolon
multiline_comment|/* ibid?? */
DECL|variable|timeout
r_static
r_int
id|timeout
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|poll
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
DECL|variable|req_timer
r_static
r_struct
id|timer_list
id|req_timer
op_assign
(brace
id|function
suffix:colon
id|poll
)brace
suffix:semicolon
DECL|function|poll
r_static
r_void
id|poll
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_static
r_volatile
r_int
id|read_count
op_assign
l_int|1
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|loop_again
op_assign
l_int|1
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: I/O error 0x%02x&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tries
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: read block %d failed;&quot;
l_string|&quot; Giving up&bslash;n&quot;
comma
id|next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transfer_is_active
)paren
id|loop_again
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|tries
op_assign
l_int|5
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|state
op_assign
id|S_STOP
suffix:semicolon
)brace
r_while
c_loop
(paren
id|loop_again
)paren
(brace
id|loop_again
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* each case must flip this back to 1 if we want&n;&t;&t;                 to come back up here */
macro_line|#if DEBUG_STATE
r_if
c_cond
(paren
id|state
op_eq
id|state_old
)paren
id|state_n
op_increment
suffix:semicolon
r_else
(brace
id|state_old
op_assign
id|state
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|state_n
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: %ld times &quot;
l_string|&quot;in previous state&bslash;n&quot;
comma
id|state_n
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: state %d&bslash;n&quot;
comma
id|state
)paren
suffix:semicolon
id|state_n
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|S_IDLE
suffix:colon
r_return
suffix:semicolon
r_case
id|S_START
suffix:colon
r_if
c_cond
(paren
id|in_vfs
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|send_cmd
c_func
(paren
id|COMDRVST
)paren
)paren
(brace
id|state
op_assign
id|S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|state
op_assign
id|S_READ
suffix:semicolon
id|timeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_READ
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
id|status
op_assign
id|fetch_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ST_DSK_CHG
)paren
(brace
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ST_DOOR_OPEN
)paren
op_logical_or
(paren
id|status
op_amp
id|ST_DRVERR
)paren
)paren
(brace
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;optcd: %s&bslash;n&quot;
comma
(paren
id|status
op_amp
id|ST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;door open&quot;
suffix:colon
l_string|&quot;disk removed&quot;
)paren
suffix:semicolon
id|state
op_assign
id|S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
)paren
(brace
id|state
op_assign
id|S_STOP
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|next_bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|lba2msf
c_func
(paren
id|next_bn
comma
op_amp
id|msf
)paren
suffix:semicolon
id|read_count
op_assign
id|N_BUFS
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
id|read_count
suffix:semicolon
multiline_comment|/* Not BCD! */
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;reading %x:%x.%x %x:%x.%x&quot;
comma
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
comma
id|msf.cdmsf_min1
comma
id|msf.cdmsf_sec1
comma
id|msf.cdmsf_frame1
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;next_bn:%d buf_in:%d&quot;
l_string|&quot; buf_out:%d buf_bn:%d&quot;
comma
id|next_bn
comma
id|buf_in
comma
id|buf_out
comma
id|buf_bn
(braket
id|buf_in
)braket
)paren
)paren
suffix:semicolon
id|exec_read_cmd
c_func
(paren
id|COMREAD
comma
op_amp
id|msf
)paren
suffix:semicolon
id|state
op_assign
id|S_DATA
suffix:semicolon
id|timeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|S_DATA
suffix:colon
id|flags
op_assign
id|stdt_flags
c_func
(paren
)paren
op_amp
(paren
id|FL_STEN
op_or
id|FL_DTEN
)paren
suffix:semicolon
macro_line|#if DEBUG_STATE
r_if
c_cond
(paren
id|flags
op_ne
id|flags_old
)paren
(brace
id|flags_old
op_assign
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: flags:%x&bslash;n&quot;
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_eq
id|FL_STEN
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;timeout cnt: %d&bslash;n&quot;
comma
id|timeout
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|FL_DTEN
suffix:colon
multiline_comment|/* only STEN low */
r_if
c_cond
(paren
op_logical_neg
id|tries
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: read block %d failed; &quot;
l_string|&quot;Giving up&bslash;n&quot;
comma
id|next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transfer_is_active
)paren
(brace
id|tries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|tries
op_assign
l_int|5
suffix:semicolon
)brace
id|state
op_assign
id|S_START
suffix:semicolon
id|timeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
r_case
(paren
id|FL_STEN
op_or
id|FL_DTEN
)paren
suffix:colon
multiline_comment|/* both high */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* DTEN low */
id|tries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
op_logical_and
id|buf_in
op_eq
id|buf_out
)paren
(brace
id|state
op_assign
id|S_STOP
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_count
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;optcd: warning - try to read&quot;
l_string|&quot; 0 frames&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|read_count
)paren
(brace
id|buf_bn
(braket
id|buf_in
)braket
op_assign
id|NOBUF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag_low
c_func
(paren
id|FL_DTEN
comma
id|BUSY_TIMEOUT
)paren
)paren
(brace
multiline_comment|/* should be no waiting here!?? */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;read_count:%d &quot;
l_string|&quot;CURRENT-&gt;nr_sectors:%ld &quot;
l_string|&quot;buf_in:%d&bslash;n&quot;
comma
id|read_count
comma
id|CURRENT-&gt;nr_sectors
comma
id|buf_in
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;transfer active: %x&bslash;n&quot;
comma
id|transfer_is_active
)paren
suffix:semicolon
id|read_count
op_assign
l_int|0
suffix:semicolon
id|state
op_assign
id|S_STOP
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fetch_data
c_func
(paren
id|buf
op_plus
id|CD_FRAMESIZE
op_star
id|buf_in
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|read_count
op_decrement
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;S_DATA; ---I&squot;ve read data- &quot;
l_string|&quot;read_count: %d&quot;
comma
id|read_count
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;next_bn:%d  buf_in:%d &quot;
l_string|&quot;buf_out:%d  buf_bn:%d&quot;
comma
id|next_bn
comma
id|buf_in
comma
id|buf_out
comma
id|buf_bn
(braket
id|buf_in
)braket
)paren
)paren
suffix:semicolon
id|buf_bn
(braket
id|buf_in
)braket
op_assign
id|next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buf_out
op_eq
id|NOBUF
)paren
id|buf_out
op_assign
id|buf_in
suffix:semicolon
id|buf_in
op_assign
id|buf_in
op_plus
l_int|1
op_eq
id|N_BUFS
ques
c_cond
l_int|0
suffix:colon
id|buf_in
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
id|transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
op_logical_and
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
template_param
id|next_bn
op_plus
id|N_BUFS
)paren
)paren
(brace
id|state
op_assign
id|S_STOP
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|timeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|read_count
op_eq
l_int|0
)paren
(brace
id|state
op_assign
id|S_STOP
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|S_STOP
suffix:colon
r_if
c_cond
(paren
id|read_count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: discard data=%x frames&bslash;n&quot;
comma
id|read_count
)paren
suffix:semicolon
id|flush_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_cmd
c_func
(paren
id|COMDRVST
)paren
)paren
(brace
id|state
op_assign
id|S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|state
op_assign
id|S_STOPPING
suffix:semicolon
id|timeout
op_assign
id|STOP_TIMEOUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_STOPPING
suffix:colon
id|status
op_assign
id|fetch_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
op_logical_and
id|timeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_ge
l_int|0
)paren
op_logical_and
(paren
id|status
op_amp
id|ST_DSK_CHG
)paren
)paren
(brace
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
(brace
id|state
op_assign
id|S_READ
suffix:semicolon
id|loop_again
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|state
op_assign
id|S_START
suffix:semicolon
id|timeout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|state
op_assign
id|S_IDLE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: invalid state %d&bslash;n&quot;
comma
id|state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* case */
)brace
multiline_comment|/* while */
r_if
c_cond
(paren
op_logical_neg
id|timeout
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: timeout in state %d&bslash;n&quot;
comma
id|state
)paren
suffix:semicolon
id|state
op_assign
id|S_STOP
suffix:semicolon
r_if
c_cond
(paren
id|exec_cmd
c_func
(paren
id|COMSTOP
)paren
OL
l_int|0
)paren
(brace
id|state
op_assign
id|S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|mod_timer
c_func
(paren
op_amp
id|req_timer
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
DECL|function|do_optcd_request
r_static
r_void
id|do_optcd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;do_optcd_request(%ld+%ld)&quot;
comma
id|CURRENT
op_member_access_from_pointer
id|sector
comma
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk_info.audio
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;optcd: tried to mount an Audio CD&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|transfer
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* First try to transfer block from buffers */
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Want to read a block not in buffer */
id|buf_out
op_assign
id|NOBUF
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|S_IDLE
)paren
(brace
multiline_comment|/* %% Should this block the request queue?? */
r_if
c_cond
(paren
id|update_toc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Start state machine */
id|state
op_assign
id|S_START
suffix:semicolon
id|timeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
id|tries
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* %% why not start right away?? */
id|mod_timer
c_func
(paren
op_amp
id|req_timer
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|transfer_is_active
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;next_bn:%d  buf_in:%d buf_out:%d  buf_bn:%d&quot;
comma
id|next_bn
comma
id|buf_in
comma
id|buf_out
comma
id|buf_bn
(braket
id|buf_in
)braket
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_REQUEST
comma
l_string|&quot;do_optcd_request ends&quot;
)paren
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* IOCTLs */
DECL|variable|auto_eject
r_static
r_char
id|auto_eject
op_assign
l_int|0
suffix:semicolon
DECL|function|cdrompause
r_static
r_int
id|cdrompause
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|audio_status
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMPAUSEON
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMPAUSEON: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromresume
r_static
r_int
id|cdromresume
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|audio_status
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMPAUSEOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMPAUSEOFF: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
id|audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromplaymsf
r_static
r_int
id|cdromplaymsf
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
)paren
suffix:semicolon
id|status
op_assign
id|exec_long_cmd
c_func
(paren
id|COMPLAY
comma
op_amp
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_long_cmd COMPLAY: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
id|audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromplaytrkind
r_static
r_int
id|cdromplaytrkind
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
template_param
id|disk_info.last
op_logical_or
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|disk_info.last
)paren
id|ti.cdti_trk1
op_assign
id|disk_info.last
suffix:semicolon
id|msf.cdmsf_min0
op_assign
id|toc
(braket
id|ti.cdti_trk0
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|msf.cdmsf_sec0
op_assign
id|toc
(braket
id|ti.cdti_trk0
)braket
dot
id|cdsc_absaddr.msf.second
suffix:semicolon
id|msf.cdmsf_frame0
op_assign
id|toc
(braket
id|ti.cdti_trk0
)braket
dot
id|cdsc_absaddr.msf.frame
suffix:semicolon
id|msf.cdmsf_min1
op_assign
id|toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|cdsc_absaddr.msf.minute
suffix:semicolon
id|msf.cdmsf_sec1
op_assign
id|toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|cdsc_absaddr.msf.second
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
id|toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|cdsc_absaddr.msf.frame
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;play %02d:%02d.%02d to %02d:%02d.%02d&quot;
comma
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
comma
id|msf.cdmsf_min1
comma
id|msf.cdmsf_sec1
comma
id|msf.cdmsf_frame1
)paren
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
)paren
suffix:semicolon
id|status
op_assign
id|exec_long_cmd
c_func
(paren
id|COMPLAY
comma
op_amp
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_long_cmd COMPLAY: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
id|audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromreadtochdr
r_static
r_int
id|cdromreadtochdr
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tochdr
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|tochdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|tochdr.cdth_trk0
op_assign
id|disk_info.first
suffix:semicolon
id|tochdr.cdth_trk1
op_assign
id|disk_info.last
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tochdr
comma
r_sizeof
id|tochdr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromreadtocentry
r_static
r_int
id|cdromreadtocentry
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|cdrom_subchnl
op_star
id|tocptr
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tocptr
op_assign
op_amp
id|toc
(braket
id|disk_info.last
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|disk_info.last
op_logical_or
id|entry.cdte_track
OL
id|disk_info.first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tocptr
op_assign
op_amp
id|toc
(braket
id|entry.cdte_track
)braket
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tocptr-&gt;cdsc_adr
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tocptr-&gt;cdsc_ctrl
suffix:semicolon
id|entry.cdte_addr.msf.minute
op_assign
id|tocptr-&gt;cdsc_absaddr.msf.minute
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|tocptr-&gt;cdsc_absaddr.msf.second
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|tocptr-&gt;cdsc_absaddr.msf.frame
suffix:semicolon
multiline_comment|/* %% What should go into entry.cdte_datamode? */
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_LBA
)paren
id|msf2lba
c_func
(paren
op_amp
id|entry.cdte_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_ne
id|CDROM_MSF
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromvolctrl
r_static
r_int
id|cdromvolctrl
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|volctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|volctrl
)paren
suffix:semicolon
id|msf.cdmsf_min0
op_assign
l_int|0x10
suffix:semicolon
id|msf.cdmsf_sec0
op_assign
l_int|0x32
suffix:semicolon
id|msf.cdmsf_frame0
op_assign
id|volctrl.channel0
suffix:semicolon
id|msf.cdmsf_min1
op_assign
id|volctrl.channel1
suffix:semicolon
id|msf.cdmsf_sec1
op_assign
id|volctrl.channel2
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
id|volctrl.channel3
suffix:semicolon
id|status
op_assign
id|exec_long_cmd
c_func
(paren
id|COMCHCTRL
comma
op_amp
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_long_cmd COMCHCTRL: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromsubchnl
r_static
r_int
id|cdromsubchnl
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_ne
id|CDROM_LBA
op_logical_and
id|subchnl.cdsc_format
op_ne
id|CDROM_MSF
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|status
op_assign
id|get_q_channel
c_func
(paren
op_amp
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;get_q_channel: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromread
r_static
r_int
id|cdromread
c_func
(paren
r_int
r_int
id|arg
comma
r_int
id|blocksize
comma
r_int
id|cmd
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_char
id|buf
(braket
id|CD_FRAMESIZE_RAWER
)braket
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
)paren
suffix:semicolon
id|msf.cdmsf_min1
op_assign
l_int|0
suffix:semicolon
id|msf.cdmsf_sec1
op_assign
l_int|0
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* read only one frame */
id|status
op_assign
id|exec_read_cmd
c_func
(paren
id|cmd
comma
op_amp
id|msf
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;read cmd status 0x%x&quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sleep_flag_low
c_func
(paren
id|FL_DTEN
comma
id|SLEEP_TIMEOUT
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|fetch_data
c_func
(paren
id|buf
comma
id|blocksize
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf
comma
id|blocksize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdromseek
r_static
r_int
id|cdromseek
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
)paren
suffix:semicolon
id|status
op_assign
id|exec_seek_cmd
c_func
(paren
id|COMSEEK
comma
op_amp
id|msf
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;COMSEEK status 0x%x&quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MULTISESSION
DECL|function|cdrommultisession
r_static
r_int
id|cdrommultisession
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|cdrom_multisession
id|ms
suffix:semicolon
id|status
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ms
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|ms
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ms
)paren
suffix:semicolon
id|ms.addr.msf.minute
op_assign
id|disk_info.last_session.minute
suffix:semicolon
id|ms.addr.msf.second
op_assign
id|disk_info.last_session.second
suffix:semicolon
id|ms.addr.msf.frame
op_assign
id|disk_info.last_session.frame
suffix:semicolon
r_if
c_cond
(paren
id|ms.addr_format
op_ne
id|CDROM_LBA
op_logical_and
id|ms.addr_format
op_ne
id|CDROM_MSF
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_LBA
)paren
id|msf2lba
c_func
(paren
op_amp
id|ms.addr
)paren
suffix:semicolon
id|ms.xa_flag
op_assign
id|disk_info.xa
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ms
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG_MULTIS
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_MSF
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: multisession xa:%d, msf:%02d:%02d.%02d&bslash;n&quot;
comma
id|ms.xa_flag
comma
id|ms.addr.msf.minute
comma
id|ms.addr.msf.second
comma
id|ms.addr.msf.frame
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;optcd: multisession %d, lba:0x%08x [%02d:%02d.%02d])&bslash;n&quot;
comma
id|ms.xa_flag
comma
id|ms.addr.lba
comma
id|disk_info.last_session.minute
comma
id|disk_info.last_session.second
comma
id|disk_info.last_session.frame
)paren
suffix:semicolon
macro_line|#endif DEBUG_MULTIS
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif MULTISESSION
DECL|function|cdromreset
r_static
r_int
id|cdromreset
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|state
op_ne
id|S_IDLE
)paren
(brace
id|error
op_assign
l_int|1
suffix:semicolon
id|tries
op_assign
l_int|0
suffix:semicolon
)brace
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|disk_changed
op_assign
l_int|1
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reset_drive
c_func
(paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* VFS calls */
DECL|function|opt_ioctl
r_static
r_int
id|opt_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|status
comma
id|err
comma
id|retval
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;starting opt_ioctl&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMRESET
)paren
r_return
id|cdromreset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* is do_optcd_request or another ioctl busy? */
r_if
c_cond
(paren
id|state
op_ne
id|S_IDLE
op_logical_or
id|in_vfs
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|in_vfs
op_assign
l_int|1
suffix:semicolon
id|status
op_assign
id|drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;drive_status: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
id|in_vfs
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ST_DOOR_OPEN
)paren
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Actions that can be taken with door open */
r_case
id|CDROMCLOSETRAY
suffix:colon
multiline_comment|/* We do this before trying to read the toc. */
id|err
op_assign
id|exec_cmd
c_func
(paren
id|COMCLOSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMCLOSE: %02x&quot;
comma
op_minus
id|err
)paren
)paren
suffix:semicolon
id|in_vfs
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|in_vfs
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|err
op_assign
id|update_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;update_toc: %02x&quot;
comma
op_minus
id|err
)paren
)paren
suffix:semicolon
id|in_vfs
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;ioctl cmd 0x%x&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMPAUSE
suffix:colon
id|retval
op_assign
id|cdrompause
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
id|retval
op_assign
id|cdromresume
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
id|retval
op_assign
id|cdromplaymsf
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
id|retval
op_assign
id|cdromplaytrkind
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
id|retval
op_assign
id|cdromreadtochdr
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
id|retval
op_assign
id|cdromreadtocentry
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
id|err
op_assign
id|exec_cmd
c_func
(paren
id|COMSTOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMSTOP: %02x&quot;
comma
op_minus
id|err
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* This is a no-op */
r_case
id|CDROMEJECT
suffix:colon
id|err
op_assign
id|exec_cmd
c_func
(paren
id|COMUNLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMUNLOCK: %02x&quot;
comma
op_minus
id|err
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|err
op_assign
id|exec_cmd
c_func
(paren
id|COMOPEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMOPEN: %02x&quot;
comma
op_minus
id|err
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
id|retval
op_assign
id|cdromvolctrl
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
id|retval
op_assign
id|cdromsubchnl
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The drive detects the mode and automatically delivers the&n;&t;   correct 2048 bytes, so we don&squot;t need these IOCTLs */
r_case
id|CDROMREADMODE2
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADMODE1
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Drive doesn&squot;t support reading audio */
r_case
id|CDROMREADAUDIO
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMEJECT_SW
suffix:colon
id|auto_eject
op_assign
(paren
r_char
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef MULTISESSION
r_case
id|CDROMMULTISESSION
suffix:colon
id|retval
op_assign
id|cdrommultisession
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|CDROM_GET_MCN
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* not implemented */
r_case
id|CDROMVOLREAD
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* not implemented */
r_case
id|CDROMREADRAW
suffix:colon
multiline_comment|/* this drive delivers 2340 bytes in raw mode */
id|retval
op_assign
id|cdromread
c_func
(paren
id|arg
comma
id|CD_FRAMESIZE_RAW1
comma
id|COMREADRAW
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADCOOKED
suffix:colon
id|retval
op_assign
id|cdromread
c_func
(paren
id|arg
comma
id|CD_FRAMESIZE
comma
id|COMREAD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADALL
suffix:colon
id|retval
op_assign
id|cdromread
c_func
(paren
id|arg
comma
id|CD_FRAMESIZE_RAWER
comma
id|COMREADALL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSEEK
suffix:colon
id|retval
op_assign
id|cdromseek
c_func
(paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYBLK
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* not implemented */
r_case
id|CDROMCLOSETRAY
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* The action was taken earlier */
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|in_vfs
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|open_count
r_static
r_int
id|open_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Open device special file; check that a disk is in. */
DECL|function|opt_open
r_static
r_int
id|opt_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;starting opt_open&quot;
)paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|open_count
op_logical_and
id|state
op_eq
id|S_IDLE
)paren
(brace
r_int
id|status
suffix:semicolon
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMCLOSE
)paren
suffix:semicolon
multiline_comment|/* close door */
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMCLOSE: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
)brace
id|status
op_assign
id|drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;drive_status: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;status: %02x&quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ST_DOOR_OPEN
)paren
op_logical_or
(paren
id|status
op_amp
id|ST_DRVERR
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;optcd: no disk or door open&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMLOCK
)paren
suffix:semicolon
multiline_comment|/* Lock door */
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMLOCK: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
)brace
id|status
op_assign
id|update_toc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Read table of contents */
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;update_toc: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMUNLOCK
)paren
suffix:semicolon
multiline_comment|/* Unlock door */
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMUNLOCK: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
)brace
r_goto
id|err_out
suffix:semicolon
)brace
id|open_count
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exiting opt_open&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Release device special file; flush all blocks from the buffer cache */
DECL|function|opt_release
r_static
r_int
id|opt_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_int
id|status
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;executing opt_release&quot;
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;inode: %p, inode -&gt; i_rdev: 0x%x, file: %p&bslash;n&quot;
comma
id|ip
comma
id|ip
op_member_access_from_pointer
id|i_rdev
comma
id|fp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|open_count
)paren
(brace
id|toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|opt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMUNLOCK
)paren
suffix:semicolon
multiline_comment|/* Unlock door */
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMUNLOCK: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_eject
)paren
(brace
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMOPEN
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMOPEN: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|delay_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|req_timer
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check if disk has been changed */
DECL|function|opt_media_change
r_static
r_int
id|opt_media_change
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;executing opt_media_change&quot;
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;dev: 0x%x; disk_changed = %d&bslash;n&quot;
comma
id|dev
comma
id|disk_changed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk_changed
)paren
(brace
id|disk_changed
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Driver initialisation */
multiline_comment|/* Returns 1 if a drive is detected with a version string&n;   starting with &quot;DOLPHIN&quot;. Otherwise 0. */
DECL|function|version_ok
r_static
r_int
id|__init
id|version_ok
c_func
(paren
r_void
)paren
(brace
r_char
id|devname
(braket
l_int|100
)braket
suffix:semicolon
r_int
id|count
comma
id|i
comma
id|ch
comma
id|status
suffix:semicolon
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMVERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMVERSION: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|count
op_assign
id|get_data
c_func
(paren
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;get_data(1): %02x&quot;
comma
op_minus
id|count
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ch
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|get_data
c_func
(paren
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;get_data(1): %02x&quot;
comma
op_minus
id|ch
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|99
)paren
id|devname
(braket
id|i
op_increment
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|devname
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;optcd: Device %s detected&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_return
(paren
(paren
id|devname
(braket
l_int|0
)braket
op_eq
l_char|&squot;D&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|1
)braket
op_eq
l_char|&squot;O&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|2
)braket
op_eq
l_char|&squot;L&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|3
)braket
op_eq
l_char|&squot;P&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|4
)braket
op_eq
l_char|&squot;H&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|5
)braket
op_eq
l_char|&squot;I&squot;
)paren
op_logical_and
(paren
id|devname
(braket
l_int|6
)braket
op_eq
l_char|&squot;N&squot;
)paren
)paren
suffix:semicolon
)brace
DECL|variable|opt_fops
r_static
r_struct
id|block_device_operations
id|opt_fops
op_assign
(brace
id|open
suffix:colon
id|opt_open
comma
id|release
suffix:colon
id|opt_release
comma
id|ioctl
suffix:colon
id|opt_ioctl
comma
id|check_media_change
suffix:colon
id|opt_media_change
comma
)brace
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/* Get kernel parameter when used as a kernel driver */
DECL|function|optcd_setup
r_static
r_int
id|optcd_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|optcd_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;optcd=&quot;
comma
id|optcd_setup
)paren
suffix:semicolon
macro_line|#endif MODULE
multiline_comment|/* Test for presence of drive and initialize it. Called at boot time&n;   or during module initialisation. */
DECL|function|optcd_init
r_int
id|__init
id|optcd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|optcd_port
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;optcd: no Optics Storage CDROM Initialization&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|optcd_port
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: conflict, I/O port 0x%x already used&bslash;n&quot;
comma
id|optcd_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reset_drive
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: drive at 0x%x not ready&bslash;n&quot;
comma
id|optcd_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|version_ok
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: unknown drive detected; aborting&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|status
op_assign
id|exec_cmd
c_func
(paren
id|COMINITDOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: cannot init double speed mode&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
(paren
id|DEBUG_VFS
comma
l_string|&quot;exec_cmd COMINITDOUBLE: %02x&quot;
comma
op_minus
id|status
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;optcd&quot;
comma
op_amp
id|opt_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: unable to get major %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;optcd&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFBLK
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
op_amp
id|opt_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|hsecsize
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|blksize
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
id|request_region
c_func
(paren
id|optcd_port
comma
l_int|4
comma
l_string|&quot;optcd&quot;
)paren
suffix:semicolon
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
comma
l_int|1
comma
op_amp
id|opt_fops
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;optcd: DOLPHIN 8000 AT CDROM at 0x%x&bslash;n&quot;
comma
id|optcd_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|optcd_exit
r_void
id|__exit
id|optcd_exit
c_func
(paren
r_void
)paren
(brace
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;optcd&quot;
comma
l_int|0
comma
l_int|0
comma
id|DEVFS_SPECIAL_BLK
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;optcd&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;optcd: what&squot;s that: can&squot;t unregister&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|optcd_port
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;optcd: module released.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|optcd_init
id|module_init
c_func
(paren
id|optcd_init
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|optcd_exit
id|module_exit
c_func
(paren
id|optcd_exit
)paren
suffix:semicolon
eof
