multiline_comment|/*&n; * Sony CDU-535 interface device driver&n; *&n; * This is a modified version of the CDU-31A device driver (see below).&n; * Changes were made using documentation for the CDU-531 (which Sony&n; * assures me is very similar to the 535) and partial disassembly of the&n; * DOS driver.  I used Minyard&squot;s driver and replaced the CDU-31A&n; * commands with the CDU-531 commands.  This was complicated by a different&n; * interface protocol with the drive.  The driver is still polled.&n; *&n; * Data transfer rate is about 110 Kb/sec, theoretical maximum is 150 Kb/sec.&n; * I tried polling without the sony_sleep during the data transfers but&n; * it did not speed things up any.&n; *&n; * 1993-05-23 (rgj) changed the major number to 21 to get rid of conflict&n; * with CDU-31A driver.  This is the also the number from the Linux&n; * Device Driver Registry for the Sony Drive.  Hope nobody else is using it.&n; *&n; * 1993-08-29 (rgj) remove the configuring of the interface board address&n; * from the top level configuration, you have to modify it in this file.&n; *&n; * 1995-01-26 Made module-capable (Joel Katz &lt;Stimpson@Panix.COM&gt;)&n; *&n; * 1995-05-20&n; *  Modified to support CDU-510/515 series&n; *      (Claudio Porfiri&lt;C.Porfiri@nisms.tei.ericsson.se&gt;)&n; *  Fixed to report verify_area() failures&n; *      (Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt;)&n; *&n; * 1995-06-01&n; *  More changes to support CDU-510/515 series&n; *      (Claudio Porfiri&lt;C.Porfiri@nisms.tei.ericsson.se&gt;)&n; *&n; * November 1999 -- Make kernel-parameter implementation work with 2.3.x &n; *&t;            Removed init_module &amp; cleanup_module in favor of &n; *&t;            module_init &amp; module_exit.&n; *                  Torben Mathiasen &lt;tmm@image.dk&gt;&n; *&n; * Things to do:&n; *  - handle errors and status better, put everything into a single word&n; *  - use interrupts (code mostly there, but a big hole still missing)&n; *  - handle multi-session CDs?&n; *  - use DMA?&n; *&n; *  Known Bugs:&n; *  -&n; *&n; *   Ken Pizzini (ken@halcyon.com)&n; *&n; * Original by:&n; *   Ron Jeppesen (ronj.an@site007.saic.com)&n; *&n; *&n; *------------------------------------------------------------------------&n; * Sony CDROM interface device driver.&n; *&n; * Corey Minyard (minyard@wf-rch.cirr.com) (CDU-535 complaints to Ken above)&n; *&n; * Colossians 3:17&n; *&n; * The Sony interface device driver handles Sony interface CDROM&n; * drives and provides a complete block-level interface as well as an&n; * ioctl() interface compatible with the Sun (as specified in&n; * include/linux/cdrom.h).  With this interface, CDROMs can be&n; * accessed and standard audio CDs can be played back normally.&n; *&n; * This interface is (unfortunately) a polled interface.  This is&n; * because most Sony interfaces are set up with DMA and interrupts&n; * disables.  Some (like mine) do not even have the capability to&n; * handle interrupts or DMA.  For this reason you will see a bit of&n; * the following:&n; *&n; *   snap = jiffies;&n; *   while (jiffies-snap &lt; SONY_JIFFIES_TIMEOUT)&n; *   {&n; *&t;&t;if (some_condition())&n; *         break;&n; *      sony_sleep();&n; *   }&n; *   if (some_condition not met)&n; *   {&n; *      return an_error;&n; *   }&n; *&n; * This ugly hack waits for something to happen, sleeping a little&n; * between every try.  (The conditional is written so that jiffies&n; * wrap-around is handled properly.)&n; *&n; * One thing about these drives: They talk in MSF (Minute Second Frame) format.&n; * There are 75 frames a second, 60 seconds a minute, and up to 75 minutes on a&n; * disk.  The funny thing is that these are sent to the drive in BCD, but the&n; * interface wants to see them in decimal.  A lot of conversion goes on.&n; *&n; *  Copyright (C) 1993  Corey Minyard&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
macro_line|# include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR CDU535_CDROM_MAJOR
macro_line|# include &lt;linux/blk.h&gt;
DECL|macro|sony535_cd_base_io
mdefine_line|#define sony535_cd_base_io sonycd535 /* for compatible parameter passing with &quot;insmod&quot; */
macro_line|#include &quot;sonycd535.h&quot;
multiline_comment|/*&n; * this is the base address of the interface card for the Sony CDU-535&n; * CDROM drive.  If your jumpers are set for an address other than&n; * this one (the default), change the following line to the&n; * proper address.&n; */
macro_line|#ifndef CDU535_ADDRESS
DECL|macro|CDU535_ADDRESS
macro_line|# define CDU535_ADDRESS&t;&t;&t;0x340
macro_line|#endif
macro_line|#ifndef CDU535_INTERRUPT
DECL|macro|CDU535_INTERRUPT
macro_line|# define CDU535_INTERRUPT&t;&t;0
macro_line|#endif
macro_line|#ifndef CDU535_HANDLE
DECL|macro|CDU535_HANDLE
macro_line|# define CDU535_HANDLE&t;&t;&t;&quot;cdu535&quot;
macro_line|#endif
macro_line|#ifndef CDU535_MESSAGE_NAME
DECL|macro|CDU535_MESSAGE_NAME
macro_line|# define CDU535_MESSAGE_NAME&t;&quot;Sony CDU-535&quot;
macro_line|#endif
DECL|macro|CDU535_BLOCK_SIZE
mdefine_line|#define CDU535_BLOCK_SIZE&t;2048 
macro_line|#ifndef MAX_SPINUP_RETRY
DECL|macro|MAX_SPINUP_RETRY
macro_line|# define MAX_SPINUP_RETRY&t;&t;3&t;/* 1 is sufficient for most drives... */
macro_line|#endif
macro_line|#ifndef RETRY_FOR_BAD_STATUS
DECL|macro|RETRY_FOR_BAD_STATUS
macro_line|# define RETRY_FOR_BAD_STATUS&t;100&t;/* in 10th of second */
macro_line|#endif
macro_line|#ifndef DEBUG
DECL|macro|DEBUG
macro_line|# define DEBUG&t;1
macro_line|#endif
multiline_comment|/*&n; *  SONY535_BUFFER_SIZE determines the size of internal buffer used&n; *  by the drive.  It must be at least 2K and the larger the buffer&n; *  the better the transfer rate.  It does however take system memory.&n; *  On my system I get the following transfer rates using dd to read&n; *  10 Mb off /dev/cdrom.&n; *&n; *    8K buffer      43 Kb/sec&n; *   16K buffer      66 Kb/sec&n; *   32K buffer      91 Kb/sec&n; *   64K buffer     111 Kb/sec&n; *  128K buffer     123 Kb/sec&n; *  512K buffer     123 Kb/sec&n; */
DECL|macro|SONY535_BUFFER_SIZE
mdefine_line|#define SONY535_BUFFER_SIZE&t;(64*1024)
multiline_comment|/*&n; *  if LOCK_DOORS is defined then the eject button is disabled while&n; * the device is open.&n; */
macro_line|#ifndef NO_LOCK_DOORS
DECL|macro|LOCK_DOORS
macro_line|# define LOCK_DOORS
macro_line|#endif
r_static
r_int
id|read_subcode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sony_get_toc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|cdu_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_inline
r_int
r_int
id|int_to_bcd
c_func
(paren
r_int
r_int
id|val
)paren
suffix:semicolon
r_static
r_int
r_int
id|bcd_to_int
c_func
(paren
r_int
r_int
id|bcd
)paren
suffix:semicolon
r_static
r_int
id|do_sony_cmd
c_func
(paren
id|Byte
op_star
id|cmd
comma
r_int
id|nCmd
comma
id|Byte
id|status
(braket
l_int|2
)braket
comma
id|Byte
op_star
id|response
comma
r_int
id|n_response
comma
r_int
id|ignoreStatusBit7
)paren
suffix:semicolon
multiline_comment|/* The base I/O address of the Sony Interface.  This is a variable (not a&n;   #define) so it can be easily changed via some future ioctl() */
DECL|variable|sony535_cd_base_io
r_static
r_int
r_int
id|sony535_cd_base_io
op_assign
id|CDU535_ADDRESS
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sony535_cd_base_io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * The following are I/O addresses of the various registers for the drive.  The&n; * comment for the base address also applies here.&n; */
DECL|variable|select_unit_reg
r_static
r_int
r_int
id|select_unit_reg
suffix:semicolon
DECL|variable|result_reg
r_static
r_int
r_int
id|result_reg
suffix:semicolon
DECL|variable|command_reg
r_static
r_int
r_int
id|command_reg
suffix:semicolon
DECL|variable|read_status_reg
r_static
r_int
r_int
id|read_status_reg
suffix:semicolon
DECL|variable|data_reg
r_static
r_int
r_int
id|data_reg
suffix:semicolon
DECL|variable|initialized
r_static
r_int
id|initialized
suffix:semicolon
multiline_comment|/* Has the drive been initialized? */
DECL|variable|sony_disc_changed
r_static
r_int
id|sony_disc_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Has the disk been changed&n;&t;&t;&t;&t;&t;   since the last check? */
DECL|variable|sony_toc_read
r_static
r_int
id|sony_toc_read
suffix:semicolon
multiline_comment|/* Has the table of contents been&n;&t;&t;&t;&t;&t;   read? */
DECL|variable|sony_buffer_size
r_static
r_int
r_int
id|sony_buffer_size
suffix:semicolon
multiline_comment|/* Size in bytes of the read-ahead&n;&t;&t;&t;&t;&t;   buffer. */
DECL|variable|sony_buffer_sectors
r_static
r_int
r_int
id|sony_buffer_sectors
suffix:semicolon
multiline_comment|/* Size (in 2048 byte records) of&n;&t;&t;&t;&t;&t;&t;   the read-ahead buffer. */
DECL|variable|sony_usage
r_static
r_int
r_int
id|sony_usage
suffix:semicolon
multiline_comment|/* How many processes have the&n;&t;&t;&t;&t;&t;   drive open. */
DECL|variable|sony_first_block
r_static
r_int
id|sony_first_block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* First OS block (512 byte) in&n;&t;&t;&t;&t;&t;   the read-ahead buffer */
DECL|variable|sony_last_block
r_static
r_int
id|sony_last_block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Last OS block (512 byte) in&n;&t;&t;&t;&t;&t;   the read-ahead buffer */
DECL|variable|sony_toc
r_static
r_struct
id|s535_sony_toc
op_star
id|sony_toc
suffix:semicolon
multiline_comment|/* Points to the table of&n;&t;&t;&t;&t;&t;   contents. */
DECL|variable|last_sony_subcode
r_static
r_struct
id|s535_sony_subcode
op_star
id|last_sony_subcode
suffix:semicolon
multiline_comment|/* Points to the last&n;&t;&t;&t;&t;&t;&t;&t;&t;   subcode address read */
DECL|variable|sony_buffer
r_static
id|Byte
op_star
op_star
id|sony_buffer
suffix:semicolon
multiline_comment|/* Points to the pointers&n;&t;&t;&t;&t;&t;   to the sector buffers */
DECL|variable|sony_inuse
r_static
r_int
id|sony_inuse
suffix:semicolon
multiline_comment|/* is the drive in use? Only one&n;&t;&t;&t;&t;&t;   open at a time allowed */
multiline_comment|/*&n; * The audio status uses the values from read subchannel data as specified&n; * in include/linux/cdrom.h.&n; */
DECL|variable|sony_audio_status
r_static
r_int
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
multiline_comment|/*&n; * The following are a hack for pausing and resuming audio play.  The drive&n; * does not work as I would expect it, if you stop it then start it again,&n; * the drive seeks back to the beginning and starts over.  This holds the&n; * position during a pause so a resume can restart it.  It uses the&n; * audio status variable above to tell if it is paused.&n; *   I just kept the CDU-31A driver behavior rather than using the PAUSE&n; * command on the CDU-535.&n; */
DECL|variable|cur_pos_msf
r_static
id|Byte
id|cur_pos_msf
(braket
l_int|3
)braket
suffix:semicolon
DECL|variable|final_pos_msf
r_static
id|Byte
id|final_pos_msf
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* What IRQ is the drive using?  0 if none. */
DECL|variable|sony535_irq_used
r_static
r_int
id|sony535_irq_used
op_assign
id|CDU535_INTERRUPT
suffix:semicolon
multiline_comment|/* The interrupt handler will wake this queue up when it gets an interrupt. */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|cdu535_irq_wait
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine returns 1 if the disk has been changed since the last&n; * check or 0 if it hasn&squot;t.  Setting flag to 0 resets the changed flag.&n; */
r_static
r_int
DECL|function|cdu535_check_media_change
id|cdu535_check_media_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|full_dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if driver is not initialized, always return 0 */
id|retval
op_assign
id|initialized
ques
c_cond
id|sony_disc_changed
suffix:colon
l_int|0
suffix:semicolon
id|sony_disc_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|enable_interrupts
id|enable_interrupts
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef USE_IRQ
multiline_comment|/*&n;&t; * This code was taken from cdu31a.c; it will not&n;&t; * directly work for the cdu535 as written...&n;&t; */
id|curr_control_reg
op_or_assign
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|disable_interrupts
id|disable_interrupts
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef USE_IRQ
multiline_comment|/*&n;&t; * This code was taken from cdu31a.c; it will not&n;&t; * directly work for the cdu535 as written...&n;&t; */
id|curr_control_reg
op_and_assign
op_complement
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|cdu535_interrupt
id|cdu535_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|cdu535_irq_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|cdu535_irq_wait
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: Got an interrupt but nothing was waiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait a little while.&n; */
r_static
r_inline
r_void
DECL|function|sony_sleep
id|sony_sleep
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|sony535_irq_used
op_le
l_int|0
)paren
(brace
multiline_comment|/* poll */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Interrupt driven */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|enable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|cdu535_irq_wait
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------start of SONY CDU535 very specific ---------------------*/
multiline_comment|/****************************************************************************&n; * void select_unit( int unit_no )&n; *&n; *  Select the specified unit (0-3) so that subsequent commands reference it&n; ****************************************************************************/
r_static
r_void
DECL|function|select_unit
id|select_unit
c_func
(paren
r_int
id|unit_no
)paren
(brace
r_int
r_int
id|select_mask
op_assign
op_complement
(paren
l_int|1
op_lshift
id|unit_no
)paren
suffix:semicolon
id|outb
c_func
(paren
id|select_mask
comma
id|select_unit_reg
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * int read_result_reg( Byte *data_ptr )&n; *&n; *  Read a result byte from the Sony CDU controller, store in location pointed&n; * to by data_ptr.  Return zero on success, TIME_OUT if we did not receive&n; * data.&n; ***************************************************************************/
r_static
r_int
DECL|function|read_result_reg
id|read_result_reg
c_func
(paren
id|Byte
op_star
id|data_ptr
)paren
(brace
r_int
r_int
id|snap
suffix:semicolon
r_int
id|read_status
suffix:semicolon
id|snap
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
op_minus
id|snap
OL
id|SONY_JIFFIES_TIMEOUT
)paren
(brace
id|read_status
op_assign
id|inb
c_func
(paren
id|read_status_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|read_status
op_amp
id|SONY535_RESULT_NOT_READY_BIT
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if DEBUG &gt; 1
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: read_result_reg(): readStatReg = 0x%x&bslash;n&quot;
comma
id|read_status
)paren
suffix:semicolon
macro_line|#endif
op_star
id|data_ptr
op_assign
id|inb
c_func
(paren
id|result_reg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; read_result_reg: TIME OUT!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TIME_OUT
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * int read_exec_status( Byte status[2] )&n; *&n; *  Read the execution status of the last command and put into status.&n; * Handles reading second status word if available.  Returns 0 on success,&n; * TIME_OUT on failure.&n; ****************************************************************************/
r_static
r_int
DECL|function|read_exec_status
id|read_exec_status
c_func
(paren
id|Byte
id|status
(braket
l_int|2
)braket
)paren
(brace
id|status
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
op_amp
(paren
id|status
(braket
l_int|0
)braket
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* byte two follows */
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
op_amp
(paren
id|status
(braket
l_int|1
)braket
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
)brace
macro_line|#if DEBUG &gt; 1
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: read_exec_status: read 0x%x 0x%x&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
comma
id|status
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * int check_drive_status( void )&n; *&n; *  Check the current drive status.  Using this before executing a command&n; * takes care of the problem of unsolicited drive status-2 messages.&n; * Add a check of the audio status if we think the disk is playing.&n; ****************************************************************************/
r_static
r_int
DECL|function|check_drive_status
id|check_drive_status
c_func
(paren
r_void
)paren
(brace
id|Byte
id|status
comma
id|e_status
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|CDD
comma
id|ATN
suffix:semicolon
id|Byte
id|cmd
suffix:semicolon
id|select_unit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sony_audio_status
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
multiline_comment|/* check status */
id|outb
c_func
(paren
id|SONY535_REQUEST_AUDIO_STATUS
comma
id|command_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
op_amp
id|status
)paren
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0x0
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* play in progress */
r_case
l_int|0x1
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* paused */
r_case
l_int|0x3
suffix:colon
multiline_comment|/* audio play completed */
r_case
l_int|0x5
suffix:colon
multiline_comment|/* play not requested */
id|sony_audio_status
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
id|read_subcode
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4
suffix:colon
multiline_comment|/* error during play */
id|sony_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* now check drive status */
id|outb
c_func
(paren
id|SONY535_REQUEST_DRIVE_STATUS_2
comma
id|command_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
op_amp
id|status
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
macro_line|#if DEBUG &gt; 1
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: check_drive_status() got 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|ATN
op_assign
id|status
op_amp
l_int|0xf
suffix:semicolon
id|CDD
op_assign
(paren
id|status
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
suffix:semicolon
r_switch
c_cond
(paren
id|ATN
)paren
(brace
r_case
l_int|0x0
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* go on to CDD stuff */
r_case
id|SONY535_ATN_BUSY
suffix:colon
r_if
c_cond
(paren
id|initialized
)paren
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error: drive busy&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|CD_BUSY
suffix:semicolon
r_case
id|SONY535_ATN_EJECT_IN_PROGRESS
suffix:colon
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error: eject in progress&bslash;n&quot;
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
r_return
id|CD_BUSY
suffix:semicolon
r_case
id|SONY535_ATN_RESET_OCCURRED
suffix:colon
r_case
id|SONY535_ATN_DISC_CHANGED
suffix:colon
r_case
id|SONY535_ATN_RESET_AND_DISC_CHANGED
suffix:colon
macro_line|#if DEBUG &gt; 0
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; notice: reset occurred or disc changed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sony_disc_changed
op_assign
l_int|1
suffix:semicolon
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|sony_first_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|sony_last_block
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|initialized
)paren
(brace
id|cmd
op_assign
id|SONY535_SPIN_UP
suffix:semicolon
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd
comma
l_int|1
comma
id|e_status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error: drive busy (ATN=0x%x)&bslash;n&quot;
comma
id|ATN
)paren
suffix:semicolon
r_return
id|CD_BUSY
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CDD
)paren
(brace
multiline_comment|/* the 531 docs are not helpful in decoding this */
r_case
l_int|0x0
suffix:colon
multiline_comment|/* just use the values from the DOS driver */
r_case
l_int|0x2
suffix:colon
r_case
l_int|0xa
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* no error */
r_case
l_int|0xc
suffix:colon
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: check_drive_status(): CDD = 0xc! Not properly handled!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|CD_BUSY
suffix:semicolon
multiline_comment|/* ? */
r_default
suffix:colon
r_return
id|CD_BUSY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check_drive_status() */
multiline_comment|/*****************************************************************************&n; * int do_sony_cmd( Byte *cmd, int n_cmd, Byte status[2],&n; *                Byte *response, int n_response, int ignore_status_bit7 )&n; *&n; *  Generic routine for executing commands.  The command and its parameters&n; *  should be placed in the cmd[] array, number of bytes in the command is&n; *  stored in nCmd.  The response from the command will be stored in the&n; *  response array.  The number of bytes you expect back (excluding status)&n; *  should be passed in n_response.  Finally, some&n; *  commands set bit 7 of the return status even when there is no second&n; *  status byte, on these commands set ignoreStatusBit7 TRUE.&n; *    If the command was sent and data received back, then we return 0,&n; *  else we return TIME_OUT.  You still have to check the status yourself.&n; *    You should call check_drive_status() before calling this routine&n; *  so that you do not lose notifications of disk changes, etc.&n; ****************************************************************************/
r_static
r_int
DECL|function|do_sony_cmd
id|do_sony_cmd
c_func
(paren
id|Byte
op_star
id|cmd
comma
r_int
id|n_cmd
comma
id|Byte
id|status
(braket
l_int|2
)braket
comma
id|Byte
op_star
id|response
comma
r_int
id|n_response
comma
r_int
id|ignore_status_bit7
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* write out the command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_cmd
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|cmd
(braket
id|i
)braket
comma
id|command_reg
)paren
suffix:semicolon
multiline_comment|/* read back the status */
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
id|status
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_status_bit7
op_logical_and
(paren
(paren
id|status
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* get second status byte */
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
id|status
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
)brace
r_else
(brace
id|status
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if DEBUG &gt; 2
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: do_sony_cmd %x: %x %x&bslash;n&quot;
comma
op_star
id|cmd
comma
id|status
(braket
l_int|0
)braket
comma
id|status
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* do not know about when I should read set of data and when not to */
r_if
c_cond
(paren
(paren
id|status
(braket
l_int|0
)braket
op_amp
(paren
(paren
id|ignore_status_bit7
ques
c_cond
l_int|0x7f
suffix:colon
l_int|0xff
)paren
op_amp
l_int|0x8f
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* else, read in rest of data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|0
OL
id|n_response
suffix:semicolon
id|n_response
op_decrement
comma
id|i
op_increment
)paren
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
id|response
op_plus
id|i
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* do_sony_cmd() */
multiline_comment|/**************************************************************************&n; * int set_drive_mode( int mode, Byte status[2] )&n; *&n; *  Set the drive mode to the specified value (mode=0 is audio, mode=e0&n; * is mode-1 CDROM&n; **************************************************************************/
r_static
r_int
DECL|function|set_drive_mode
id|set_drive_mode
c_func
(paren
r_int
id|mode
comma
id|Byte
id|status
(braket
l_int|2
)braket
)paren
(brace
id|Byte
id|cmd_buff
(braket
l_int|2
)braket
suffix:semicolon
id|Byte
id|ret_buff
(braket
l_int|1
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SET_DRIVE_MODE
suffix:semicolon
id|cmd_buff
(braket
l_int|1
)braket
op_assign
id|mode
suffix:semicolon
r_return
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|2
comma
id|status
comma
id|ret_buff
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * int seek_and_read_N_blocks( Byte params[], int n_blocks, Byte status[2],&n; *                             Byte *data_buff, int buff_size )&n; *&n; *  Read n_blocks of data from the CDROM starting at position params[0:2],&n; *  number of blocks in stored in params[3:5] -- both these are already&n; *  int bcd format.&n; *  Transfer the data into the buffer pointed at by data_buff.  buff_size&n; *  gives the number of bytes available in the buffer.&n; *    The routine returns number of bytes read in if successful, otherwise&n; *  it returns one of the standard error returns.&n; ***************************************************************************/
r_static
r_int
DECL|function|seek_and_read_N_blocks
id|seek_and_read_N_blocks
c_func
(paren
id|Byte
id|params
(braket
)braket
comma
r_int
id|n_blocks
comma
id|Byte
id|status
(braket
l_int|2
)braket
comma
id|Byte
op_star
op_star
id|buff
comma
r_int
id|buf_size
)paren
(brace
id|Byte
id|cmd_buff
(braket
l_int|7
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|read_status
suffix:semicolon
r_int
r_int
id|snap
suffix:semicolon
id|Byte
op_star
id|data_buff
suffix:semicolon
r_int
id|sector_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf_size
OL
id|CDU535_BLOCK_SIZE
op_star
id|n_blocks
)paren
r_return
id|NO_ROOM
suffix:semicolon
id|set_drive_mode
c_func
(paren
id|SONY535_CDROM_DRIVE_MODE
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* send command to read the data */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SEEK_AND_READ_N_BLOCKS_1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|cmd_buff
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|params
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|cmd_buff
(braket
id|i
)braket
comma
id|command_reg
)paren
suffix:semicolon
multiline_comment|/* read back the data one block at a time */
r_while
c_loop
(paren
l_int|0
OL
id|n_blocks
op_decrement
)paren
(brace
multiline_comment|/* wait for data to be ready */
r_int
id|data_valid
op_assign
l_int|0
suffix:semicolon
id|snap
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
op_minus
id|snap
OL
id|SONY_JIFFIES_TIMEOUT
)paren
(brace
id|read_status
op_assign
id|inb
c_func
(paren
id|read_status_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|read_status
op_amp
id|SONY535_RESULT_NOT_READY_BIT
)paren
op_eq
l_int|0
)paren
(brace
id|read_exec_status
c_func
(paren
id|status
)paren
suffix:semicolon
r_return
id|BAD_STATUS
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|read_status
op_amp
id|SONY535_DATA_NOT_READY_BIT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* data is ready, read it */
id|data_buff
op_assign
id|buff
(braket
id|sector_count
op_increment
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CDU535_BLOCK_SIZE
suffix:semicolon
id|i
op_increment
)paren
op_star
id|data_buff
op_increment
op_assign
id|inb
c_func
(paren
id|data_reg
)paren
suffix:semicolon
multiline_comment|/* unrolling this loop does not seem to help */
id|data_valid
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* exit the timeout loop */
)brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* data not ready, sleep a while */
)brace
r_if
c_cond
(paren
op_logical_neg
id|data_valid
)paren
r_return
id|TIME_OUT
suffix:semicolon
multiline_comment|/* if we reach this stage */
)brace
multiline_comment|/* read all the data, now read the status */
r_if
c_cond
(paren
(paren
id|i
op_assign
id|read_exec_status
c_func
(paren
id|status
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|i
suffix:semicolon
r_return
id|CDU535_BLOCK_SIZE
op_star
id|sector_count
suffix:semicolon
)brace
multiline_comment|/* seek_and_read_N_blocks() */
multiline_comment|/****************************************************************************&n; * int request_toc_data( Byte status[2], struct s535_sony_toc *toc )&n; *&n; *  Read in the table of contents data.  Converts all the bcd data&n; * into integers in the toc structure.&n; ****************************************************************************/
r_static
r_int
DECL|function|request_toc_data
id|request_toc_data
c_func
(paren
id|Byte
id|status
(braket
l_int|2
)braket
comma
r_struct
id|s535_sony_toc
op_star
id|toc
)paren
(brace
r_int
id|to_status
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|n_tracks
comma
id|track_no
suffix:semicolon
r_int
id|first_track_num
comma
id|last_track_num
suffix:semicolon
id|Byte
id|cmd_no
op_assign
l_int|0xb2
suffix:semicolon
id|Byte
id|track_address_buffer
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* read the fixed portion of the table of contents */
r_if
c_cond
(paren
(paren
id|to_status
op_assign
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd_no
comma
l_int|1
comma
id|status
comma
(paren
id|Byte
op_star
)paren
id|toc
comma
l_int|15
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|to_status
suffix:semicolon
multiline_comment|/* convert the data into integers so we can use them */
id|first_track_num
op_assign
id|bcd_to_int
c_func
(paren
id|toc-&gt;first_track_num
)paren
suffix:semicolon
id|last_track_num
op_assign
id|bcd_to_int
c_func
(paren
id|toc-&gt;last_track_num
)paren
suffix:semicolon
id|n_tracks
op_assign
id|last_track_num
op_minus
id|first_track_num
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* read each of the track address descriptors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_tracks
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* read the descriptor into a temporary buffer */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|5
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|read_result_reg
c_func
(paren
id|track_address_buffer
op_plus
id|j
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|1
)paren
multiline_comment|/* need to convert from bcd */
id|track_no
op_assign
id|bcd_to_int
c_func
(paren
id|track_address_buffer
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the descriptor to proper location - sonycd.c just fills */
id|memcpy
c_func
(paren
id|toc-&gt;tracks
op_plus
id|i
comma
id|track_address_buffer
comma
l_int|5
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* request_toc_data() */
multiline_comment|/***************************************************************************&n; * int spin_up_drive( Byte status[2] )&n; *&n; *  Spin up the drive (unless it is already spinning).&n; ***************************************************************************/
r_static
r_int
DECL|function|spin_up_drive
id|spin_up_drive
c_func
(paren
id|Byte
id|status
(braket
l_int|2
)braket
)paren
(brace
id|Byte
id|cmd
suffix:semicolon
multiline_comment|/* first see if the drive is already spinning */
id|cmd
op_assign
id|SONY535_REQUEST_DRIVE_STATUS_1
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
id|TIME_OUT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
(braket
l_int|0
)braket
op_amp
id|SONY535_STATUS1_NOT_SPINNING
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* it&squot;s already spinning */
multiline_comment|/* otherwise, give the spin-up command */
id|cmd
op_assign
id|SONY535_SPIN_UP
suffix:semicolon
r_return
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*--------------------end of SONY CDU535 very specific ---------------------*/
multiline_comment|/* Convert from an integer 0-99 to BCD */
r_static
r_inline
r_int
r_int
DECL|function|int_to_bcd
id|int_to_bcd
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
(paren
id|val
op_div
l_int|10
)paren
op_lshift
l_int|4
suffix:semicolon
id|retval
op_assign
id|retval
op_or
id|val
op_mod
l_int|10
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Convert from BCD to an integer from 0-99 */
r_static
r_int
r_int
DECL|function|bcd_to_int
id|bcd_to_int
c_func
(paren
r_int
r_int
id|bcd
)paren
(brace
r_return
(paren
(paren
(paren
id|bcd
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|bcd
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a logical sector value (like the OS would want to use for&n; * a block device) to an MSF format.&n; */
r_static
r_void
DECL|function|log_to_msf
id|log_to_msf
c_func
(paren
r_int
r_int
id|log
comma
id|Byte
op_star
id|msf
)paren
(brace
id|log
op_assign
id|log
op_plus
id|LOG_START_OFFSET
suffix:semicolon
id|msf
(braket
l_int|0
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|4500
)paren
suffix:semicolon
id|log
op_assign
id|log
op_mod
l_int|4500
suffix:semicolon
id|msf
(braket
l_int|1
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|75
)paren
suffix:semicolon
id|msf
(braket
l_int|2
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_mod
l_int|75
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an MSF format to a logical sector.&n; */
r_static
r_int
r_int
DECL|function|msf_to_log
id|msf_to_log
c_func
(paren
id|Byte
op_star
id|msf
)paren
(brace
r_int
r_int
id|log
suffix:semicolon
id|log
op_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|log
op_add_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|1
)braket
)paren
op_star
l_int|75
suffix:semicolon
id|log
op_add_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|0
)braket
)paren
op_star
l_int|4500
suffix:semicolon
id|log
op_assign
id|log
op_minus
id|LOG_START_OFFSET
suffix:semicolon
r_return
id|log
suffix:semicolon
)brace
multiline_comment|/*&n; * Take in integer size value and put it into a buffer like&n; * the drive would want to see a number-of-sector value.&n; */
r_static
r_void
DECL|function|size_to_buf
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
id|Byte
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|size
op_div
l_int|65536
suffix:semicolon
id|size
op_assign
id|size
op_mod
l_int|65536
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|size
op_div
l_int|256
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|size
op_mod
l_int|256
suffix:semicolon
)brace
multiline_comment|/*&n; * The OS calls this to perform a read or write operation to the drive.&n; * Write obviously fail.  Reads to a read ahead of sony_buffer_size&n; * bytes to help speed operations.  This especially helps since the OS&n; * may use 1024 byte blocks and the drive uses 2048 byte blocks.  Since most&n; * data access on a CD is done sequentially, this saves a lot of operations.&n; */
r_static
r_void
DECL|function|do_cdu535_request
id|do_cdu535_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_int
r_int
id|dev
suffix:semicolon
r_int
r_int
id|read_size
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|nsect
suffix:semicolon
r_int
id|copyoff
suffix:semicolon
r_int
id|spin_up_retry
suffix:semicolon
id|Byte
id|params
(braket
l_int|10
)braket
suffix:semicolon
id|Byte
id|status
(braket
l_int|2
)braket
suffix:semicolon
id|Byte
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * The beginning here is stolen from the hard disk driver.  I hope&n;&t;&t; * it&squot;s right.&n;&t;&t; */
r_if
c_cond
(paren
id|QUEUE_EMPTY
op_logical_or
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
suffix:semicolon
)brace
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * If the block address is invalid or the request goes beyond the end of&n;&t;&t;&t; * the media, return an error.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sony_toc-&gt;lead_out_start_lba
op_le
(paren
id|block
op_div
l_int|4
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_toc-&gt;lead_out_start_lba
op_le
(paren
(paren
id|block
op_plus
id|nsect
)paren
op_div
l_int|4
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
OL
id|nsect
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the requested sector is not currently in the read-ahead buffer,&n;&t;&t;&t;&t; * it must be read in.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|block
OL
id|sony_first_block
)paren
op_logical_or
(paren
id|sony_last_block
OL
id|block
)paren
)paren
(brace
id|sony_first_block
op_assign
(paren
id|block
op_div
l_int|4
)paren
op_star
l_int|4
suffix:semicolon
id|log_to_msf
c_func
(paren
id|block
op_div
l_int|4
comma
id|params
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the full read-ahead would go beyond the end of the media, trim&n;&t;&t;&t;&t;&t; * it back to read just till the end of the media.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sony_toc-&gt;lead_out_start_lba
op_le
(paren
(paren
id|block
op_div
l_int|4
)paren
op_plus
id|sony_buffer_sectors
)paren
)paren
(brace
id|sony_last_block
op_assign
(paren
id|sony_toc-&gt;lead_out_start_lba
op_star
l_int|4
)paren
op_minus
l_int|1
suffix:semicolon
id|read_size
op_assign
id|sony_toc-&gt;lead_out_start_lba
op_minus
(paren
id|block
op_div
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|sony_last_block
op_assign
id|sony_first_block
op_plus
(paren
id|sony_buffer_sectors
op_star
l_int|4
)paren
op_minus
l_int|1
suffix:semicolon
id|read_size
op_assign
id|sony_buffer_sectors
suffix:semicolon
)brace
id|size_to_buf
c_func
(paren
id|read_size
comma
op_amp
id|params
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Read the data.  If the drive was not spinning,&n;&t;&t;&t;&t;&t; * spin it up and try some more.&n;&t;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|spin_up_retry
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
op_increment
id|spin_up_retry
)paren
(brace
multiline_comment|/* This loop has been modified to support the Sony&n;&t;&t;&t;&t;&t;&t; * CDU-510/515 series, thanks to Claudio Porfiri &n;&t;&t;&t;&t;&t;&t; * &lt;C.Porfiri@nisms.tei.ericsson.se&gt;.&n;&t;&t;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * This part is to deal with very slow hardware.  We&n;&t;&t;&t;&t;&t;&t; * try at most MAX_SPINUP_RETRY times to read the same&n;&t;&t;&t;&t;&t;&t; * block.  A check for seek_and_read_N_blocks&squot; result is&n;&t;&t;&t;&t;&t;&t; * performed; if the result is wrong, the CDROM&squot;s engine&n;&t;&t;&t;&t;&t;&t; * is restarted and the operation is tried again.&n;&t;&t;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * 1995-06-01: The system got problems when downloading&n;&t;&t;&t;&t;&t;&t; * from Slackware CDROM, the problem seems to be:&n;&t;&t;&t;&t;&t;&t; * seek_and_read_N_blocks returns BAD_STATUS and we&n;&t;&t;&t;&t;&t;&t; * should wait for a while before retrying, so a new&n;&t;&t;&t;&t;&t;&t; * part was added to discriminate the return value from&n;&t;&t;&t;&t;&t;&t; * seek_and_read_N_blocks for the various cases.&n;&t;&t;&t;&t;&t;&t; */
r_int
id|readStatus
op_assign
id|seek_and_read_N_blocks
c_func
(paren
id|params
comma
id|read_size
comma
id|status
comma
id|sony_buffer
comma
(paren
id|read_size
op_star
id|CDU535_BLOCK_SIZE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|readStatus
)paren
multiline_comment|/* Good data; common case, placed first */
r_break
suffix:semicolon
r_if
c_cond
(paren
id|readStatus
op_eq
id|NO_ROOM
op_logical_or
id|spin_up_retry
op_eq
id|MAX_SPINUP_RETRY
)paren
(brace
multiline_comment|/* give up */
r_if
c_cond
(paren
id|readStatus
op_eq
id|NO_ROOM
)paren
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; No room to read from CD&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; Read error: 0x%.2x&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sony_first_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|sony_last_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readStatus
op_eq
id|BAD_STATUS
)paren
(brace
multiline_comment|/* Sleep for a while, then retry */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|RETRY_FOR_BAD_STATUS
op_star
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG &gt; 0
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; debug: calling spin up when reading data!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|cmd
(braket
l_int|0
)braket
op_assign
id|SONY535_SPIN_UP
suffix:semicolon
id|do_sony_cmd
c_func
(paren
id|cmd
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * The data is in memory now, copy it to the buffer and advance to the&n;&t;&t;&t;&t; * next block to read.&n;&t;&t;&t;&t; */
id|copyoff
op_assign
id|block
op_minus
id|sony_first_block
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|sony_buffer
(braket
id|copyoff
op_div
l_int|4
)braket
op_plus
l_int|512
op_star
(paren
id|copyoff
op_mod
l_int|4
)paren
comma
l_int|512
)paren
suffix:semicolon
id|block
op_add_assign
l_int|1
suffix:semicolon
id|nsect
op_sub_assign
l_int|1
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
l_int|512
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unknown SONY CD cmd&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Read the table of contents from the drive and set sony_toc_read if&n; * successful.&n; */
r_static
r_void
DECL|function|sony_get_toc
id|sony_get_toc
c_func
(paren
r_void
)paren
(brace
id|Byte
id|status
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
multiline_comment|/* do not call check_drive_status() from here since it can call this routine */
r_if
c_cond
(paren
id|request_toc_data
c_func
(paren
id|status
comma
id|sony_toc
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|sony_toc-&gt;lead_out_start_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc-&gt;lead_out_start_msf
)paren
suffix:semicolon
id|sony_toc_read
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Search for a specific track in the table of contents.  track is&n; * passed in bcd format&n; */
r_static
r_int
DECL|function|find_track
id|find_track
c_func
(paren
r_int
id|track
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|num_tracks
suffix:semicolon
id|num_tracks
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;last_track_num
)paren
op_minus
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;first_track_num
)paren
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_tracks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sony_toc-&gt;tracks
(braket
id|i
)braket
dot
id|track
op_eq
id|track
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the subcode and put it int last_sony_subcode for future use.&n; */
r_static
r_int
DECL|function|read_subcode
id|read_subcode
c_func
(paren
r_void
)paren
(brace
id|Byte
id|cmd
op_assign
id|SONY535_REQUEST_SUB_Q_DATA
suffix:semicolon
id|Byte
id|status
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|dsc_status
suffix:semicolon
r_if
c_cond
(paren
id|check_drive_status
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dsc_status
op_assign
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd
comma
l_int|1
comma
id|status
comma
(paren
id|Byte
op_star
)paren
id|last_sony_subcode
comma
r_sizeof
(paren
r_struct
id|s535_sony_subcode
)paren
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x, %d (read_subcode)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
comma
id|dsc_status
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the subchannel info like the CDROMSUBCHNL command wants to see it.  If&n; * the drive is playing, the subchannel needs to be read (since it would be&n; * changing).  If the drive is paused or completed, the subcode information has&n; * already been stored, just use that.  The ioctl call wants things in decimal&n; * (not BCD), so all the conversions are done.&n; */
r_static
r_int
DECL|function|sony_get_subchnl_info
id|sony_get_subchnl_info
c_func
(paren
r_int
id|arg
)paren
(brace
r_struct
id|cdrom_subchnl
id|schi
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Get attention stuff */
r_if
c_cond
(paren
id|check_drive_status
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
multiline_comment|/* and read */
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|schi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|schi
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|schi
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sony_audio_status
)paren
(brace
r_case
id|CDROM_AUDIO_PLAY
suffix:colon
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_PAUSED
suffix:colon
r_case
id|CDROM_AUDIO_COMPLETED
suffix:colon
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_NO_STATUS
suffix:colon
id|schi.cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|schi
comma
r_sizeof
id|schi
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_INVALID
suffix:colon
r_case
id|CDROM_AUDIO_ERROR
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|schi.cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|schi.cdsc_adr
op_assign
id|last_sony_subcode-&gt;address
suffix:semicolon
id|schi.cdsc_ctrl
op_assign
id|last_sony_subcode-&gt;control
suffix:semicolon
id|schi.cdsc_trk
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;track_num
)paren
suffix:semicolon
id|schi.cdsc_ind
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;index_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|schi.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|schi.cdsc_absaddr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|schi.cdsc_absaddr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|schi.cdsc_absaddr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|schi.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|schi.cdsc_absaddr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
)paren
suffix:semicolon
id|schi.cdsc_reladdr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
)paren
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|schi
comma
r_sizeof
id|schi
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The big ugly ioctl handler.&n; */
r_static
r_int
DECL|function|cdu_ioctl
id|cdu_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|dev
suffix:semicolon
id|Byte
id|status
(braket
l_int|2
)braket
suffix:semicolon
id|Byte
id|cmd_buff
(braket
l_int|10
)braket
comma
id|params
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|dsc_status
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_drive_status
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive */
r_if
c_cond
(paren
id|spin_up_drive
c_func
(paren
id|status
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMSTART)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_HOLD
suffix:semicolon
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Spin the drive down, ignoring the error if the disk was&n;&t;&t; * already not spinning.&n;&t;&t; */
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SPIN_DOWN
suffix:semicolon
id|dsc_status
op_assign
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|dsc_status
OL
l_int|0
)paren
op_logical_and
(paren
id|dsc_status
op_ne
id|BAD_STATUS
)paren
)paren
op_logical_or
(paren
(paren
id|status
(braket
l_int|0
)braket
op_amp
op_complement
(paren
id|SONY535_STATUS1_NOT_SPINNING
)paren
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMSTOP)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_HOLD
suffix:semicolon
multiline_comment|/* CDU-31 driver uses AUDIO_STOP, not pause */
r_if
c_cond
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMPAUSE)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Get the current position and save it for resuming */
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cur_pos_msf
(braket
l_int|0
)braket
op_assign
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|0
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|1
)braket
op_assign
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|1
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|2
)braket
op_assign
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|2
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Start the drive after being paused */
id|set_drive_mode
c_func
(paren
id|SONY535_AUDIO_DRIVE_MODE
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sony_audio_status
op_ne
id|CDROM_AUDIO_PAUSED
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_up_drive
c_func
(paren
id|status
)paren
suffix:semicolon
multiline_comment|/* Start the drive at the saved position. */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_PLAY_AUDIO
suffix:semicolon
id|cmd_buff
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* play back starting at this address */
id|cmd_buff
(braket
l_int|2
)braket
op_assign
id|cur_pos_msf
(braket
l_int|0
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|3
)braket
op_assign
id|cur_pos_msf
(braket
l_int|1
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|4
)braket
op_assign
id|cur_pos_msf
(braket
l_int|2
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|5
)braket
op_assign
id|SONY535_PLAY_AUDIO
suffix:semicolon
id|cmd_buff
(braket
l_int|6
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* set ending address */
id|cmd_buff
(braket
l_int|7
)braket
op_assign
id|final_pos_msf
(braket
l_int|0
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|8
)braket
op_assign
id|final_pos_msf
(braket
l_int|1
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|9
)braket
op_assign
id|final_pos_msf
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|5
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
op_plus
l_int|5
comma
l_int|5
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMRESUME)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|spin_up_drive
c_func
(paren
id|status
)paren
suffix:semicolon
id|set_drive_mode
c_func
(paren
id|SONY535_AUDIO_DRIVE_MODE
comma
id|status
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|params
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* The parameters are given in int, must be converted */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cmd_buff
(braket
l_int|2
op_plus
id|i
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|params
(braket
id|i
)braket
)paren
suffix:semicolon
id|cmd_buff
(braket
l_int|7
op_plus
id|i
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|params
(braket
id|i
op_plus
l_int|3
)braket
)paren
suffix:semicolon
)brace
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_PLAY_AUDIO
suffix:semicolon
id|cmd_buff
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* play back starting at this address */
multiline_comment|/* cmd_buff[2-4] are filled in for loop above */
id|cmd_buff
(braket
l_int|5
)braket
op_assign
id|SONY535_PLAY_AUDIO
suffix:semicolon
id|cmd_buff
(braket
l_int|6
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* set ending address */
multiline_comment|/* cmd_buff[7-9] are filled in for loop above */
r_if
c_cond
(paren
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|5
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
op_plus
l_int|5
comma
l_int|5
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMPLAYMSF)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|cmd_buff
(braket
l_int|7
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|cmd_buff
(braket
l_int|8
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|cmd_buff
(braket
l_int|9
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
(brace
r_struct
id|cdrom_tochdr
op_star
id|hdr
suffix:semicolon
r_struct
id|cdrom_tochdr
id|loc_hdr
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|hdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|hdr
comma
r_sizeof
op_star
id|hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|loc_hdr.cdth_trk0
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;first_track_num
)paren
suffix:semicolon
id|loc_hdr.cdth_trk1
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;last_track_num
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|hdr
comma
op_amp
id|loc_hdr
comma
r_sizeof
op_star
id|hdr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read a given table of contents entry */
(brace
r_struct
id|cdrom_tocentry
op_star
id|entry
suffix:semicolon
r_struct
id|cdrom_tocentry
id|loc_entry
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
id|Byte
op_star
id|msf_val
op_assign
l_int|NULL
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|entry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
multiline_comment|/* and read */
comma
id|entry
comma
r_sizeof
op_star
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|loc_entry
comma
id|entry
comma
r_sizeof
id|loc_entry
)paren
suffix:semicolon
multiline_comment|/* Lead out is handled separately since it is special. */
r_if
c_cond
(paren
id|loc_entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
(brace
id|loc_entry.cdte_adr
op_assign
l_int|0
multiline_comment|/*sony_toc-&gt;address2 */
suffix:semicolon
id|loc_entry.cdte_ctrl
op_assign
id|sony_toc-&gt;control2
suffix:semicolon
id|msf_val
op_assign
id|sony_toc-&gt;lead_out_start_msf
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|loc_entry.cdte_track
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|loc_entry.cdte_adr
op_assign
l_int|0
multiline_comment|/*sony_toc-&gt;tracks[track_idx].address */
suffix:semicolon
id|loc_entry.cdte_ctrl
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|control
suffix:semicolon
id|msf_val
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
suffix:semicolon
)brace
multiline_comment|/* Logical buffer address or MSF format requested? */
r_if
c_cond
(paren
id|loc_entry.cdte_format
op_eq
id|CDROM_LBA
)paren
(brace
id|loc_entry.cdte_addr.lba
op_assign
id|msf_to_log
c_func
(paren
id|msf_val
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|loc_entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|loc_entry.cdte_addr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
op_star
id|msf_val
)paren
suffix:semicolon
id|loc_entry.cdte_addr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
op_star
(paren
id|msf_val
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|loc_entry.cdte_addr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
op_star
(paren
id|msf_val
op_plus
l_int|2
)paren
)paren
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
id|entry
comma
op_amp
id|loc_entry
comma
r_sizeof
op_star
id|entry
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
(brace
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|ti
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ti.cdti_trk0
OL
id|sony_toc-&gt;first_track_num
)paren
op_logical_or
(paren
id|sony_toc-&gt;last_track_num
OL
id|ti.cdti_trk0
)paren
op_logical_or
(paren
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|ti.cdti_trk0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we want to stop after the last track, use the lead-out&n;&t;&t;&t; * MSF to do that.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;last_track_num
)paren
op_le
id|ti.cdti_trk1
)paren
(brace
id|log_to_msf
c_func
(paren
id|msf_to_log
c_func
(paren
id|sony_toc-&gt;lead_out_start_msf
)paren
op_minus
l_int|1
comma
op_amp
(paren
id|params
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|ti.cdti_trk1
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|log_to_msf
c_func
(paren
id|msf_to_log
c_func
(paren
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
)paren
op_minus
l_int|1
comma
op_amp
(paren
id|params
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|spin_up_drive
c_func
(paren
id|status
)paren
suffix:semicolon
id|set_drive_mode
c_func
(paren
id|SONY535_AUDIO_DRIVE_MODE
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* Start the drive at the saved position. */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_PLAY_AUDIO
suffix:semicolon
id|cmd_buff
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* play back starting at this address */
id|cmd_buff
(braket
l_int|2
)braket
op_assign
id|params
(braket
l_int|1
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|3
)braket
op_assign
id|params
(braket
l_int|2
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|4
)braket
op_assign
id|params
(braket
l_int|3
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|5
)braket
op_assign
id|SONY535_PLAY_AUDIO
suffix:semicolon
id|cmd_buff
(braket
l_int|6
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* set ending address */
id|cmd_buff
(braket
l_int|7
)braket
op_assign
id|params
(braket
l_int|4
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|8
)braket
op_assign
id|params
(braket
l_int|5
)braket
suffix:semicolon
id|cmd_buff
(braket
l_int|9
)braket
op_assign
id|params
(braket
l_int|6
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|5
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
op_plus
l_int|5
comma
l_int|5
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMPLAYTRKIND)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;... Params: %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|params
(braket
l_int|0
)braket
comma
id|params
(braket
l_int|1
)braket
comma
id|params
(braket
l_int|2
)braket
comma
id|params
(braket
l_int|3
)braket
comma
id|params
(braket
l_int|4
)braket
comma
id|params
(braket
l_int|5
)braket
comma
id|params
(braket
l_int|6
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|params
(braket
l_int|4
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|params
(braket
l_int|5
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|params
(braket
l_int|6
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
r_return
id|sony_get_subchnl_info
c_func
(paren
id|arg
)paren
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control.  What volume does this change, anyway? */
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|volctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
id|volctrl
)paren
suffix:semicolon
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SET_VOLUME
suffix:semicolon
id|cmd_buff
(braket
l_int|1
)braket
op_assign
id|volctrl.channel0
suffix:semicolon
id|cmd_buff
(braket
l_int|2
)braket
op_assign
id|volctrl.channel1
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|3
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMVOLCTRL)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
multiline_comment|/* Eject the drive */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_STOP
suffix:semicolon
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SPIN_DOWN
suffix:semicolon
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_EJECT_CADDY
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (CDROMEJECT)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Open the drive for operations.  Spin the drive up and read the table of&n; * contents if these have not already been done.&n; */
r_static
r_int
DECL|function|cdu_open
id|cdu_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|Byte
id|status
(braket
l_int|2
)braket
comma
id|cmd_buff
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sony_inuse
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|check_drive_status
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|spin_up_drive
c_func
(paren
id|status
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot; error 0x%.2x (cdu_open, spin up)&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SPIN_DOWN
suffix:semicolon
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
id|sony_usage
op_increment
suffix:semicolon
macro_line|#ifdef LOCK_DOORS
multiline_comment|/* disable the eject button while mounted */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_DISABLE_EJECT_BUTTON
suffix:semicolon
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the drive.  Spin it down if no task is using it.  The spin&n; * down will fail if playing audio, so audio play is OK.&n; */
r_static
r_int
DECL|function|cdu_release
id|cdu_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|Byte
id|status
(braket
l_int|2
)braket
comma
id|cmd_no
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|sony_usage
)paren
(brace
id|sony_usage
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_usage
op_eq
l_int|0
)paren
(brace
id|check_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sony_audio_status
op_ne
id|CDROM_AUDIO_PLAY
)paren
(brace
id|cmd_no
op_assign
id|SONY535_SPIN_DOWN
suffix:semicolon
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd_no
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef LOCK_DOORS
multiline_comment|/* enable the eject button after umount */
id|cmd_no
op_assign
id|SONY535_ENABLE_EJECT_BUTTON
suffix:semicolon
id|do_sony_cmd
c_func
(paren
op_amp
id|cmd_no
comma
l_int|1
comma
id|status
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cdu_fops
r_static
r_struct
id|block_device_operations
id|cdu_fops
op_assign
(brace
id|open
suffix:colon
id|cdu_open
comma
id|release
suffix:colon
id|cdu_release
comma
id|ioctl
suffix:colon
id|cdu_ioctl
comma
id|check_media_change
suffix:colon
id|cdu535_check_media_change
comma
)brace
suffix:semicolon
DECL|variable|sonycd535_block_size
r_static
r_int
id|sonycd535_block_size
op_assign
id|CDU535_BLOCK_SIZE
suffix:semicolon
multiline_comment|/*&n; * Initialize the driver.&n; */
r_int
id|__init
DECL|function|sony535_init
id|sony535_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|s535_sony_drive_config
id|drive_config
suffix:semicolon
id|Byte
id|cmd_buff
(braket
l_int|3
)braket
suffix:semicolon
id|Byte
id|ret_buff
(braket
l_int|2
)braket
suffix:semicolon
id|Byte
id|status
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|snap
suffix:semicolon
r_int
id|got_result
op_assign
l_int|0
suffix:semicolon
r_int
id|tmp_irq
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Setting the base I/O address to 0 will disable it. */
r_if
c_cond
(paren
(paren
id|sony535_cd_base_io
op_eq
l_int|0xffff
)paren
op_logical_or
(paren
id|sony535_cd_base_io
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Set up all the register locations */
id|result_reg
op_assign
id|sony535_cd_base_io
suffix:semicolon
id|command_reg
op_assign
id|sony535_cd_base_io
suffix:semicolon
id|data_reg
op_assign
id|sony535_cd_base_io
op_plus
l_int|1
suffix:semicolon
id|read_status_reg
op_assign
id|sony535_cd_base_io
op_plus
l_int|2
suffix:semicolon
id|select_unit_reg
op_assign
id|sony535_cd_base_io
op_plus
l_int|3
suffix:semicolon
macro_line|#ifndef USE_IRQ
id|sony535_irq_used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* polling only until this is ready... */
macro_line|#endif
multiline_comment|/* we need to poll until things get initialized */
id|tmp_irq
op_assign
id|sony535_irq_used
suffix:semicolon
id|sony535_irq_used
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG &gt; 0
id|printk
c_func
(paren
id|KERN_INFO
id|CDU535_MESSAGE_NAME
l_string|&quot;: probing base address %03X&bslash;n&quot;
comma
id|sony535_cd_base_io
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|sony535_cd_base_io
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: my base address is not free!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* look for the CD-ROM, follows the procedure in the DOS driver */
id|inb
c_func
(paren
id|select_unit_reg
)paren
suffix:semicolon
multiline_comment|/* wait for 40 18 Hz ticks (reverse-engineered from DOS driver) */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
(paren
id|HZ
op_plus
l_int|17
)paren
op_star
l_int|40
op_div
l_int|18
)paren
suffix:semicolon
id|inb
c_func
(paren
id|result_reg
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|read_status_reg
)paren
suffix:semicolon
multiline_comment|/* does a reset? */
id|snap
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
op_minus
id|snap
OL
id|SONY_JIFFIES_TIMEOUT
)paren
(brace
id|select_unit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|result_reg
)paren
op_ne
l_int|0xff
)paren
(brace
id|got_result
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|got_result
op_logical_and
(paren
id|check_drive_status
c_func
(paren
)paren
op_ne
id|TIME_OUT
)paren
)paren
(brace
multiline_comment|/* CD-ROM drive responded --  get the drive configuration */
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_INQUIRY
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|1
comma
id|status
comma
(paren
id|Byte
op_star
)paren
op_amp
id|drive_config
comma
l_int|28
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* was able to get the configuration,&n;&t;&t;&t; * set drive mode as rest of init&n;&t;&t;&t; */
macro_line|#if DEBUG &gt; 0
multiline_comment|/* 0x50 == CADDY_NOT_INSERTED | NOT_SPINNING */
r_if
c_cond
(paren
(paren
id|status
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_ne
l_int|0
op_logical_and
(paren
id|status
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_ne
l_int|0x50
)paren
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;Inquiry command returned status = 0x%x&bslash;n&quot;
comma
id|status
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* now ready to use interrupts, if available */
id|sony535_irq_used
op_assign
id|tmp_irq
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/* This code is not in MODULEs by default, since the autoirq stuff might&n; * not be in the module-accessible symbol table.&n; */
multiline_comment|/* A negative sony535_irq_used will attempt an autoirq. */
r_if
c_cond
(paren
id|sony535_irq_used
OL
l_int|0
)paren
(brace
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|enable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|read_status_reg
)paren
suffix:semicolon
multiline_comment|/* does a reset? */
id|sony535_irq_used
op_assign
id|autoirq_report
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|sony535_irq_used
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|sony535_irq_used
comma
id|cdu535_interrupt
comma
id|SA_INTERRUPT
comma
id|CDU535_HANDLE
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the &quot;
id|CDU535_MESSAGE_NAME
l_string|&quot; driver; polling instead.&bslash;n&quot;
comma
id|sony535_irq_used
)paren
suffix:semicolon
id|sony535_irq_used
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|cmd_buff
(braket
l_int|0
)braket
op_assign
id|SONY535_SET_DRIVE_MODE
suffix:semicolon
id|cmd_buff
(braket
l_int|1
)braket
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* default audio */
r_if
c_cond
(paren
id|do_sony_cmd
c_func
(paren
id|cmd_buff
comma
l_int|2
comma
id|status
comma
id|ret_buff
comma
l_int|1
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* set the drive mode successful, we are set! */
id|sony_buffer_size
op_assign
id|SONY535_BUFFER_SIZE
suffix:semicolon
id|sony_buffer_sectors
op_assign
id|sony_buffer_size
op_div
id|CDU535_BLOCK_SIZE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|CDU535_MESSAGE_NAME
l_string|&quot; I/F CDROM : %8.8s %16.16s %4.4s&quot;
comma
id|drive_config.vendor_id
comma
id|drive_config.product_id
comma
id|drive_config.product_rev_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  base address %03X, &quot;
comma
id|sony535_cd_base_io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_irq
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;IRQ%d, &quot;
comma
id|tmp_irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;using %d byte buffer&bslash;n&quot;
comma
id|sony_buffer_size
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
id|CDU535_HANDLE
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFBLK
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
op_amp
id|cdu_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|CDU535_HANDLE
comma
op_amp
id|cdu_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for %s&bslash;n&quot;
comma
id|MAJOR_NR
comma
id|CDU535_MESSAGE_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|sonycd535_block_size
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read-ahead */
id|sony_toc
op_assign
(paren
r_struct
id|s535_sony_toc
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|sony_toc
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sony_toc
op_eq
l_int|NULL
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|last_sony_subcode
op_assign
(paren
r_struct
id|s535_sony_subcode
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|last_sony_subcode
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_sony_subcode
op_eq
l_int|NULL
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sony_toc
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sony_buffer
op_assign
(paren
id|Byte
op_star
op_star
)paren
id|kmalloc
c_func
(paren
l_int|4
op_star
id|sony_buffer_sectors
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sony_buffer
op_eq
l_int|NULL
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sony_toc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|last_sony_subcode
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sony_buffer_sectors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sony_buffer
(braket
id|i
)braket
op_assign
(paren
id|Byte
op_star
)paren
id|kmalloc
c_func
(paren
id|CDU535_BLOCK_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sony_buffer
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
id|kfree
c_func
(paren
id|sony_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sony_buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sony_toc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|last_sony_subcode
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|initialized
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Did not find a &quot;
id|CDU535_MESSAGE_NAME
l_string|&quot; drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|sony535_cd_base_io
comma
l_int|4
comma
id|CDU535_HANDLE
)paren
suffix:semicolon
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
comma
l_int|1
comma
op_amp
id|cdu_fops
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * accept &quot;kernel command line&quot; parameters&n; * (added by emoenke@gwdg.de)&n; *&n; * use: tell LILO:&n; *                 sonycd535=0x320&n; *&n; * the address value has to be the existing CDROM port address.&n; */
r_static
r_int
id|__init
DECL|function|sonycd535_setup
id|sonycd535_setup
c_func
(paren
r_char
op_star
id|strings
)paren
(brace
r_int
id|ints
(braket
l_int|3
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|strings
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
multiline_comment|/* if IRQ change and default io base desired,&n;&t; * then call with io base of 0&n;&t; */
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
id|sony535_cd_base_io
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|sony535_irq_used
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|strings
op_ne
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|strings
op_ne
l_char|&squot;&bslash;0&squot;
)paren
)paren
id|printk
c_func
(paren
id|CDU535_MESSAGE_NAME
l_string|&quot;: Warning: Unknown interface type: %s&bslash;n&quot;
comma
id|strings
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;sonycd535=&quot;
comma
id|sonycd535_setup
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
r_void
id|__exit
DECL|function|sony535_exit
id|sony535_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|release_region
c_func
(paren
id|sony535_cd_base_io
comma
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sony_buffer_sectors
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|sony_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sony_buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|last_sony_subcode
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sony_toc
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
id|CDU535_HANDLE
comma
l_int|0
comma
l_int|0
comma
id|DEVFS_SPECIAL_BLK
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|CDU535_HANDLE
)paren
op_eq
op_minus
id|EINVAL
)paren
id|printk
c_func
(paren
l_string|&quot;Uh oh, couldn&squot;t unregister &quot;
id|CDU535_HANDLE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
id|CDU535_HANDLE
l_string|&quot; module released&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|sony535_init
id|module_init
c_func
(paren
id|sony535_init
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|sony535_exit
id|module_exit
c_func
(paren
id|sony535_exit
)paren
suffix:semicolon
eof
