multiline_comment|/* linux/drivers/cdrom/cdrom.c. &n;   Copyright (c) 1996, 1997 David A. van Leeuwen.&n;   Copyright (c) 1997, 1998 Erik Andersen &lt;andersee@debian.org&gt;&n;   Copyright (c) 1998, 1999 Jens Axboe &lt;axboe@image.dk&gt;&n;&n;   May be copied or modified under the terms of the GNU General Public&n;   License.  See linux/COPYING for more information.&n;&n;   Uniform CD-ROM driver for Linux.&n;   See Documentation/cdrom/cdrom-standard.tex for usage information.&n;&n;   The routines in the file provide a uniform interface between the&n;   software that uses CD-ROMs and the various low-level drivers that&n;   actually talk to the hardware. Suggestions are welcome.&n;   Patches that work are more welcome though.  ;-)&n;&n; To Do List:&n; ----------------------------------&n;&n; -- Modify sysctl/proc interface. I plan on having one directory per&n; drive, with entries for outputing general drive information, and sysctl&n; based tunable parameters such as whether the tray should auto-close for&n; that drive. Suggestions (or patches) for this welcome!&n;&n;&n; Revision History&n; ----------------------------------&n; 1.00  Date Unknown -- David van Leeuwen &lt;david@tm.tno.nl&gt;&n; -- Initial version by David A. van Leeuwen. I don&squot;t have a detailed&n;  changelog for the 1.x series, David?&n;&n;2.00  Dec  2, 1997 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- New maintainer! As David A. van Leeuwen has been too busy to activly&n;  maintain and improve this driver, I am now carrying on the torch. If&n;  you have a problem with this driver, please feel free to contact me.&n;&n;  -- Added (rudimentary) sysctl interface. I realize this is really weak&n;  right now, and is _very_ badly implemented. It will be improved...&n;&n;  -- Modified CDROM_DISC_STATUS so that it is now incorporated into&n;  the Uniform CD-ROM driver via the cdrom_count_tracks function.&n;  The cdrom_count_tracks function helps resolve some of the false&n;  assumptions of the CDROM_DISC_STATUS ioctl, and is also used to check&n;  for the correct media type when mounting or playing audio from a CD.&n;&n;  -- Remove the calls to verify_area and only use the copy_from_user and&n;  copy_to_user stuff, since these calls now provide their own memory&n;  checking with the 2.1.x kernels.&n;&n;  -- Major update to return codes so that errors from low-level drivers&n;  are passed on through (thanks to Gerd Knorr for pointing out this&n;  problem).&n;&n;  -- Made it so if a function isn&squot;t implemented in a low-level driver,&n;  ENOSYS is now returned instead of EINVAL.&n;&n;  -- Simplified some complex logic so that the source code is easier to read.&n;&n;  -- Other stuff I probably forgot to mention (lots of changes).&n;&n;2.01 to 2.11 Dec 1997-Jan 1998&n;  -- TO-DO!  Write changelogs for 2.01 to 2.12.&n;&n;2.12  Jan  24, 1998 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- Fixed a bug in the IOCTL_IN and IOCTL_OUT macros.  It turns out that&n;  copy_*_user does not return EFAULT on error, but instead returns the number &n;  of bytes not copied.  I was returning whatever non-zero stuff came back from &n;  the copy_*_user functions directly, which would result in strange errors.&n;&n;2.13  July 17, 1998 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- Fixed a bug in CDROM_SELECT_SPEED where you couldn&squot;t lower the speed&n;  of the drive.  Thanks to Tobias Ringstr|m &lt;tori@prosolvia.se&gt; for pointing&n;  this out and providing a simple fix.&n;  -- Fixed the procfs-unload-module bug with the fill_inode procfs callback.&n;  thanks to Andrea Arcangeli&n;  -- Fixed it so that the /proc entry now also shows up when cdrom is&n;  compiled into the kernel.  Before it only worked when loaded as a module.&n;&n;  2.14 August 17, 1998 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- Fixed a bug in cdrom_media_changed and handling of reporting that&n;  the media had changed for devices that _don&squot;t_ implement media_changed.  &n;  Thanks to Grant R. Guenther &lt;grant@torque.net&gt; for spotting this bug.&n;  -- Made a few things more pedanticly correct.&n;&n;2.50 Oct 19, 1998 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- New maintainers! Erik was too busy to continue the work on the driver,&n;  so now Chris Zwilling &lt;chris@cloudnet.com&gt; and Jens Axboe &lt;axboe@image.dk&gt;&n;  will do their best to follow in his footsteps&n;  &n;  2.51 Dec 20, 1998 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Check if drive is capable of doing what we ask before blindly changing&n;  cdi-&gt;options in various ioctl.&n;  -- Added version to proc entry.&n;  &n;  2.52 Jan 16, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Fixed an error in open_for_data where we would sometimes not return&n;  the correct error value. Thanks Huba Gaspar &lt;huba@softcell.hu&gt;.&n;  -- Fixed module usage count - usage was based on /proc/sys/dev&n;  instead of /proc/sys/dev/cdrom. This could lead to an oops when other&n;  modules had entries in dev. Feb 02 - real bug was in sysctl.c where&n;  dev would be removed even though it was used. cdrom.c just illuminated&n;  that bug.&n;  &n;  2.53 Feb 22, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Fixup of several ioctl calls, in particular CDROM_SET_OPTIONS has&n;  been &quot;rewritten&quot; because capabilities and options aren&squot;t in sync. They&n;  should be...&n;  -- Added CDROM_LOCKDOOR ioctl. Locks the door and keeps it that way.&n;  -- Added CDROM_RESET ioctl.&n;  -- Added CDROM_DEBUG ioctl. Enable debug messages on-the-fly.&n;  -- Added CDROM_GET_CAPABILITY ioctl. This relieves userspace programs&n;  from parsing /proc/sys/dev/cdrom/info.&n;  &n;  2.54 Mar 15, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Check capability mask from low level driver when counting tracks as&n;  per suggestion from Corey J. Scotts &lt;cstotts@blue.weeg.uiowa.edu&gt;.&n;  &n;  2.55 Apr 25, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- autoclose was mistakenly checked against CDC_OPEN_TRAY instead of&n;  CDC_CLOSE_TRAY.&n;  -- proc info didn&squot;t mask against capabilities mask.&n;  &n;  3.00 Aug 5, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Unified audio ioctl handling across CD-ROM drivers. A lot of the&n;  code was duplicated before. Drives that support the generic packet&n;  interface are now being fed packets from here instead.&n;  -- First attempt at adding support for MMC2 commands - for DVD and&n;  CD-R(W) drives. Only the DVD parts are in now - the interface used is&n;  the same as for the audio ioctls.&n;  -- ioctl cleanups. if a drive couldn&squot;t play audio, it didn&squot;t get&n;  a change to perform device specific ioctls as well.&n;  -- Defined CDROM_CAN(CDC_XXX) for checking the capabilities.&n;  -- Put in sysctl files for autoclose, autoeject, check_media, debug,&n;  and lock.&n;  -- /proc/sys/dev/cdrom/info has been updated to also contain info about&n;  CD-Rx and DVD capabilities.&n;  -- Now default to checking media type.&n;  -- CDROM_SEND_PACKET ioctl added. The infrastructure was in place for&n;  doing this anyway, with the generic_packet addition.&n;  &n;  3.01 Aug 6, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Fix up the sysctl handling so that the option flags get set&n;  correctly.&n;  -- Fix up ioctl handling so the device specific ones actually get&n;  called :).&n;  &n;  3.02 Aug 8, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Fixed volume control on SCSI drives (or others with longer audio&n;  page).&n;  -- Fixed a couple of DVD minors. Thanks to Andrew T. Veliath&n;  &lt;andrewtv@usa.net&gt; for telling me and for having defined the various&n;  DVD structures and ioctls in the first place! He designed the original&n;  DVD patches for ide-cd and while I rearranged and unified them, the&n;  interface is still the same.&n;  &n;  3.03 Sep 1, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Moved the rest of the audio ioctls from the CD-ROM drivers here. Only&n;  CDROMREADTOCENTRY and CDROMREADTOCHDR are left.&n;  -- Moved the CDROMREADxxx ioctls in here.&n;  -- Defined the cdrom_get_last_written and cdrom_get_next_block as ioctls&n;  and exported functions.&n;  -- Erik Andersen &lt;andersen@xmission.com&gt; modified all SCMD_ commands&n;  to now read GPCMD_ for the new generic packet interface. All low level&n;  drivers are updated as well.&n;  -- Various other cleanups.&n;&n;  3.04 Sep 12, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Fixed a couple of possible memory leaks (if an operation failed and&n;  we didn&squot;t free the buffer before returning the error).&n;  -- Integrated Uniform CD Changer handling from Richard Sharman&n;  &lt;rsharman@pobox.com&gt;.&n;  -- Defined CD_DVD and CD_CHANGER log levels.&n;  -- Fixed the CDROMREADxxx ioctls.&n;  -- CDROMPLAYTRKIND uses the GPCMD_PLAY_AUDIO_MSF command - too few&n;  drives supported it. We loose the index part, however.&n;  -- Small modifications to accomodate opens of /dev/hdc1, required&n;  for ide-cd to handle multisession discs.&n;  -- Export cdrom_mode_sense and cdrom_mode_select.&n;  -- init_cdrom_command() for setting up a cgc command.&n;  &n;  3.05 Oct 24, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Changed the interface for CDROM_SEND_PACKET. Before it was virtually&n;  impossible to send the drive data in a sensible way.&n;  -- Lowered stack usage in mmc_ioctl(), dvd_read_disckey(), and&n;  dvd_read_manufact.&n;  -- Added setup of write mode for packet writing.&n;  -- Fixed CDDA ripping with cdda2wav - accept much larger requests of&n;  number of frames and split the reads in blocks of 8.&n;&n;  3.06 Dec 13, 1999 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Added support for changing the region of DVD drives.&n;  -- Added sense data to generic command.&n;&n;  3.07 Feb 2, 2000 - Jens Axboe &lt;axboe@suse.de&gt;&n;  -- Do same &quot;read header length&quot; trick in cdrom_get_disc_info() as&n;  we do in cdrom_get_track_info() -- some drive don&squot;t obey specs and&n;  fail if they can&squot;t supply the full Mt Fuji size table.&n;  -- Deleted stuff related to setting up write modes. It has a different&n;  home now.&n;  -- Clear header length in mode_select unconditionally.&n;  -- Removed the register_disk() that was added, not needed here.&n;&n;  3.08 May 1, 2000 - Jens Axboe &lt;axboe@suse.de&gt;&n;  -- Fix direction flag in setup_send_key and setup_report_key. This&n;  gave some SCSI adapters problems.&n;  -- Always return -EROFS for write opens&n;  -- Convert to module_init/module_exit style init and remove some&n;  of the #ifdef MODULE stuff&n;  -- Fix several dvd errors - DVD_LU_SEND_ASF should pass agid,&n;  DVD_HOST_SEND_RPC_STATE did not set buffer size in cdb, and&n;  dvd_do_auth passed uninitialized data to drive because init_cdrom_command&n;  did not clear a 0 sized buffer.&n;  &n;  3.09 May 12, 2000 - Jens Axboe &lt;axboe@suse.de&gt;&n;  -- Fix Video-CD on SCSI drives that don&squot;t support READ_CD command. In&n;  that case switch block size and issue plain READ_10 again, then switch&n;  back.&n;&n;  3.10 Jun 10, 2000 - Jens Axboe &lt;axboe@suse.de&gt;&n;  -- Fix volume control on CD&squot;s - old SCSI-II drives now use their own&n;  code, as doing MODE6 stuff in here is really not my intention.&n;  -- Use READ_DISC_INFO for more reliable end-of-disc.&n;&n;  3.11 Jun 12, 2000 - Jens Axboe &lt;axboe@suse.de&gt;&n;  -- Fix bug in getting rpc phase 2 region info.&n;  -- Reinstate &quot;correct&quot; CDROMPLAYTRKIND&n;&n;   3.12 Oct 18, 2000 - Jens Axboe &lt;axboe@suse.de&gt;&n;  -- Use quiet bit on packet commands not known to work&n;&n;-------------------------------------------------------------------------*/
DECL|macro|REVISION
mdefine_line|#define REVISION &quot;Revision: 3.12&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;Id: cdrom.c 3.12 2000/10/18&quot;
multiline_comment|/* I use an error-log mask to give fine grain control over the type of&n;   messages dumped to the system logs.  The available masks include: */
DECL|macro|CD_NOTHING
mdefine_line|#define CD_NOTHING      0x0
DECL|macro|CD_WARNING
mdefine_line|#define CD_WARNING&t;0x1
DECL|macro|CD_REG_UNREG
mdefine_line|#define CD_REG_UNREG&t;0x2
DECL|macro|CD_DO_IOCTL
mdefine_line|#define CD_DO_IOCTL&t;0x4
DECL|macro|CD_OPEN
mdefine_line|#define CD_OPEN&t;&t;0x8
DECL|macro|CD_CLOSE
mdefine_line|#define CD_CLOSE&t;0x10
DECL|macro|CD_COUNT_TRACKS
mdefine_line|#define CD_COUNT_TRACKS 0x20
DECL|macro|CD_CHANGER
mdefine_line|#define CD_CHANGER&t;0x40
DECL|macro|CD_DVD
mdefine_line|#define CD_DVD&t;&t;0x80
multiline_comment|/* Define this to remove _all_ the debugging messages */
multiline_comment|/* #define ERRLOGMASK CD_NOTHING */
DECL|macro|ERRLOGMASK
mdefine_line|#define ERRLOGMASK (CD_WARNING)
multiline_comment|/* #define ERRLOGMASK (CD_WARNING|CD_OPEN|CD_COUNT_TRACKS|CD_CLOSE) */
multiline_comment|/* #define ERRLOGMASK (CD_WARNING|CD_REG_UNREG|CD_DO_IOCTL|CD_OPEN|CD_CLOSE|CD_COUNT_TRACKS) */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt; 
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/fcntl.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* used to tell the module to turn on full debugging messages */
DECL|variable|debug
r_static
r_int
id|debug
suffix:semicolon
multiline_comment|/* used to keep tray locked at all times */
DECL|variable|keeplocked
r_static
r_int
id|keeplocked
suffix:semicolon
multiline_comment|/* default compatibility mode */
DECL|variable|autoclose
r_static
r_int
id|autoclose
op_assign
l_int|1
suffix:semicolon
DECL|variable|autoeject
r_static
r_int
id|autoeject
suffix:semicolon
DECL|variable|lockdoor
r_static
r_int
id|lockdoor
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* will we ever get to use this... sigh. */
DECL|variable|check_media_type
r_static
r_int
id|check_media_type
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|autoclose
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|autoeject
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|lockdoor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|check_media_type
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#if (ERRLOGMASK!=CD_NOTHING)
DECL|macro|cdinfo
mdefine_line|#define cdinfo(type, fmt, args...) &bslash;&n;        if ((ERRLOGMASK &amp; type) || debug==1 ) &bslash;&n;            printk(KERN_INFO &quot;cdrom: &quot; fmt, ## args)
macro_line|#else
DECL|macro|cdinfo
mdefine_line|#define cdinfo(type, fmt, args...) 
macro_line|#endif
multiline_comment|/* These are used to simplify getting data in from and back to user land */
DECL|macro|IOCTL_IN
mdefine_line|#define IOCTL_IN(arg, type, in)&t;&t;&t;&t;&t;&bslash;&n;&t;if (copy_from_user(&amp;in, (type *) arg, sizeof in))&t;&bslash;&n;&t;&t;return -EFAULT;
DECL|macro|IOCTL_OUT
mdefine_line|#define IOCTL_OUT(arg, type, out) &bslash;&n;&t;if (copy_to_user((type *) arg, &amp;out, sizeof out))&t;&bslash;&n;&t;&t;return -EFAULT;
multiline_comment|/* The (cdo-&gt;capability &amp; ~cdi-&gt;mask &amp; CDC_XXX) construct was used in&n;   a lot of places. This macro makes the code more clear. */
DECL|macro|CDROM_CAN
mdefine_line|#define CDROM_CAN(type) (cdi-&gt;ops-&gt;capability &amp; ~cdi-&gt;mask &amp; (type))
multiline_comment|/* used in the audio ioctls */
DECL|macro|CHECKAUDIO
mdefine_line|#define CHECKAUDIO if ((ret=check_for_audio_disc(cdi, cdo))) return ret
multiline_comment|/* Not-exported routines. */
r_static
r_int
id|cdrom_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
suffix:semicolon
r_static
r_int
id|cdrom_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
suffix:semicolon
r_static
r_int
id|cdrom_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|cdrom_media_changed
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_int
id|open_for_data
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
suffix:semicolon
r_static
r_int
id|check_for_audio_disc
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_device_ops
op_star
id|cdo
)paren
suffix:semicolon
r_static
r_void
id|sanitize_format
c_func
(paren
r_union
id|cdrom_addr
op_star
id|addr
comma
id|u_char
op_star
id|curr
comma
id|u_char
id|requested
)paren
suffix:semicolon
r_static
r_int
id|mmc_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_int
id|cdrom_get_last_written
c_func
(paren
id|kdev_t
id|dev
comma
r_int
op_star
id|last_written
)paren
suffix:semicolon
r_int
id|cdrom_get_next_writable
c_func
(paren
id|kdev_t
id|dev
comma
r_int
op_star
id|next_writable
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
r_static
r_void
id|cdrom_sysctl_register
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */ 
DECL|variable|topCdromPtr
r_static
r_struct
id|cdrom_device_info
op_star
id|topCdromPtr
suffix:semicolon
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|variable|cdrom_fops
r_struct
id|block_device_operations
id|cdrom_fops
op_assign
(brace
id|open
suffix:colon
id|cdrom_open
comma
id|release
suffix:colon
id|cdrom_release
comma
id|ioctl
suffix:colon
id|cdrom_ioctl
comma
id|check_media_change
suffix:colon
id|cdrom_media_changed
comma
)brace
suffix:semicolon
multiline_comment|/* This macro makes sure we don&squot;t have to check on cdrom_device_ops&n; * existence in the run-time routines below. Change_capability is a&n; * hack to have the capability flags defined const, while we can still&n; * change it here without gcc complaining at every line.&n; */
DECL|macro|ENSURE
mdefine_line|#define ENSURE(call, bits) if (cdo-&gt;call == NULL) *change_capability &amp;= ~(bits)
DECL|function|register_cdrom
r_int
id|register_cdrom
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_static
r_char
id|banner_printed
suffix:semicolon
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|cdi-&gt;dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_int
op_star
id|change_capability
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cdo-&gt;capability
suffix:semicolon
multiline_comment|/* hack */
r_char
id|vname
(braket
l_int|16
)braket
suffix:semicolon
r_static
r_int
r_int
id|cdrom_counter
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering register_cdrom&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;open
op_eq
l_int|NULL
op_logical_or
id|cdo-&gt;release
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|banner_printed
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Uniform CD-ROM driver &quot;
id|REVISION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|banner_printed
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|cdrom_sysctl_register
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */ 
)brace
id|ENSURE
c_func
(paren
id|drive_status
comma
id|CDC_DRIVE_STATUS
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|media_changed
comma
id|CDC_MEDIA_CHANGED
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|tray_move
comma
id|CDC_CLOSE_TRAY
op_or
id|CDC_OPEN_TRAY
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|lock_door
comma
id|CDC_LOCK
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|select_speed
comma
id|CDC_SELECT_SPEED
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|get_last_session
comma
id|CDC_MULTI_SESSION
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|get_mcn
comma
id|CDC_MCN
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|reset
comma
id|CDC_RESET
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|audio_ioctl
comma
id|CDC_PLAY_AUDIO
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|dev_ioctl
comma
id|CDC_IOCTLS
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|generic_packet
comma
id|CDC_GENERIC_PACKET
)paren
suffix:semicolon
id|cdi-&gt;mc_flags
op_assign
l_int|0
suffix:semicolon
id|cdo-&gt;n_minors
op_assign
l_int|0
suffix:semicolon
id|cdi-&gt;options
op_assign
id|CDO_USE_FFLAGS
suffix:semicolon
r_if
c_cond
(paren
id|autoclose
op_eq
l_int|1
op_logical_and
id|CDROM_CAN
c_func
(paren
id|CDC_CLOSE_TRAY
)paren
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_AUTO_CLOSE
suffix:semicolon
r_if
c_cond
(paren
id|autoeject
op_eq
l_int|1
op_logical_and
id|CDROM_CAN
c_func
(paren
id|CDC_OPEN_TRAY
)paren
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_AUTO_EJECT
suffix:semicolon
r_if
c_cond
(paren
id|lockdoor
op_eq
l_int|1
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_LOCK
suffix:semicolon
r_if
c_cond
(paren
id|check_media_type
op_eq
l_int|1
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_CHECK_TYPE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devfs_handle
)paren
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;cdroms&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|sprintf
(paren
id|vname
comma
l_string|&quot;cdrom%u&quot;
comma
id|cdrom_counter
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;de
)paren
(brace
r_int
id|pos
suffix:semicolon
id|devfs_handle_t
id|slave
suffix:semicolon
r_char
id|rname
(braket
l_int|64
)braket
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
(paren
id|cdi-&gt;de
comma
id|rname
op_plus
l_int|3
comma
r_sizeof
id|rname
op_minus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
(brace
id|strncpy
(paren
id|rname
op_plus
id|pos
comma
l_string|&quot;../&quot;
comma
l_int|3
)paren
suffix:semicolon
id|devfs_mk_symlink
(paren
id|devfs_handle
comma
id|vname
comma
id|DEVFS_FL_DEFAULT
comma
id|rname
op_plus
id|pos
comma
op_amp
id|slave
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_auto_unregister
(paren
id|cdi-&gt;de
comma
id|slave
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|cdi-&gt;de
op_assign
id|devfs_register
(paren
id|devfs_handle
comma
id|vname
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR
(paren
id|cdi-&gt;dev
)paren
comma
id|MINOR
(paren
id|cdi-&gt;dev
)paren
comma
id|S_IFBLK
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
op_amp
id|cdrom_fops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_REG_UNREG
comma
l_string|&quot;drive &bslash;&quot;/dev/%s&bslash;&quot; registered&bslash;n&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
id|cdi-&gt;next
op_assign
id|topCdromPtr
suffix:semicolon
id|topCdromPtr
op_assign
id|cdi
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|ENSURE
macro_line|#undef ENSURE
DECL|function|unregister_cdrom
r_int
id|unregister_cdrom
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|unreg
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
op_star
id|prev
suffix:semicolon
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|unreg-&gt;dev
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering unregister_cdrom&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
r_while
c_loop
(paren
id|cdi
op_ne
l_int|NULL
op_logical_and
id|cdi-&gt;dev
op_ne
id|unreg-&gt;dev
)paren
(brace
id|prev
op_assign
id|cdi
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|cdi-&gt;next
suffix:semicolon
r_else
id|topCdromPtr
op_assign
id|cdi-&gt;next
suffix:semicolon
id|cdi-&gt;ops-&gt;n_minors
op_decrement
suffix:semicolon
id|devfs_unregister
(paren
id|cdi-&gt;de
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_REG_UNREG
comma
l_string|&quot;drive &bslash;&quot;/dev/%s&bslash;&quot; unregistered&bslash;n&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdrom_find_device
r_struct
id|cdrom_device_info
op_star
id|cdrom_find_device
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
suffix:semicolon
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
r_while
c_loop
(paren
id|cdi
op_ne
l_int|NULL
op_logical_and
id|cdi-&gt;dev
op_ne
id|dev
)paren
id|cdi
op_assign
id|cdi-&gt;next
suffix:semicolon
r_return
id|cdi
suffix:semicolon
)brace
multiline_comment|/* We use the open-option O_NONBLOCK to indicate that the&n; * purpose of opening is only for subsequent ioctl() calls; no device&n; * integrity checks are performed.&n; *&n; * We hope that all cd-player programs will adopt this convention. It&n; * is in their own interest: device control becomes a lot easier&n; * this way.&n; */
r_static
DECL|function|cdrom_open
r_int
id|cdrom_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|ip-&gt;i_rdev
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering cdrom_open&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_DVD_RAM
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* if this was a O_NONBLOCK open and we should honor the flags,&n;&t; * do a quick open without drive/disc integrity checks. */
r_if
c_cond
(paren
(paren
id|fp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
(paren
id|cdi-&gt;options
op_amp
id|CDO_USE_FFLAGS
)paren
)paren
id|ret
op_assign
id|cdi-&gt;ops
op_member_access_from_pointer
id|open
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|open_for_data
c_func
(paren
id|cdi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|cdi-&gt;use_count
op_increment
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;Use count for &bslash;&quot;/dev/%s&bslash;&quot; now %d&bslash;n&quot;
comma
id|cdi-&gt;name
comma
id|cdi-&gt;use_count
)paren
suffix:semicolon
multiline_comment|/* Do this on open.  Don&squot;t wait for mount, because they might&n;&t;    not be mounting, but opening with O_NONBLOCK */
id|check_disk_change
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
DECL|function|open_for_data
r_int
id|open_for_data
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|tracktype
id|tracks
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering open_for_data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if the driver can report drive status.  If it can, we&n;&t;   can do clever things.  If it can&squot;t, well, we at least tried! */
r_if
c_cond
(paren
id|cdo-&gt;drive_status
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;drive_status=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is open...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* can/may i close it? */
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_CLOSE_TRAY
)paren
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_AUTO_CLOSE
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;trying to close the tray.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. tried to close the tray but failed.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Ignore the error from the low&n;&t;&t;&t;&t;&t;level driver.  We don&squot;t care why it&n;&t;&t;&t;&t;&t;couldn&squot;t close the tray.  We only care &n;&t;&t;&t;&t;&t;that there is no disc in the drive, &n;&t;&t;&t;&t;&t;since that is the _REAL_ problem here.*/
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. this drive can&squot;t close the tray.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
multiline_comment|/* Ok, the door should be closed now.. Check again */
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
id|CDS_NO_DISC
)paren
op_logical_or
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. the tray is still not closed.&bslash;n&quot;
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;tray might not contain a medium.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is now closed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|CDS_DISC_OK
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
)brace
id|cdrom_count_tracks
c_func
(paren
id|cdi
comma
op_amp
id|tracks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tracks.error
op_eq
id|CDS_NO_DISC
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. no disc.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
multiline_comment|/* CD-Players which don&squot;t use O_NONBLOCK, workman&n;&t; * for example, need bit CDO_CHECK_TYPE cleared! */
r_if
c_cond
(paren
id|tracks.data
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cdi-&gt;options
op_amp
id|CDO_CHECK_TYPE
)paren
(brace
multiline_comment|/* give people a warning shot, now that CDO_CHECK_TYPE&n;&t;&t;       is the default case! */
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. wrong media type.&bslash;n&quot;
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;pid %d must open device O_NONBLOCK!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|current-&gt;pid
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EMEDIUMTYPE
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
r_else
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;wrong media type, but CDO_CHECK_TYPE not set.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;all seems well, opening the device.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* all seems well, we can open the device */
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|open
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* open for data */
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;opening the device gave me %d.&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* After all this careful checking, we shouldn&squot;t have problems&n;&t;   opening the device, but we don&squot;t want the device locked if &n;&t;   this somehow fails... */
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;open device failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_LOCK
)paren
(brace
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;door locked.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;device opened successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
multiline_comment|/* Something failed.  Try to unlock the drive, because some drivers&n;&t;(notably ide-cd) lock the drive after every command.  This produced&n;&t;a nasty bug where after mount failed, the drive would remain locked!  &n;&t;This ensures that the drive gets unlocked after a mount fails.  This &n;&t;is a goto to avoid bloating the driver with redundant code. */
id|clean_up_and_return
suffix:colon
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;open failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_LOCK
)paren
(brace
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;door unlocked.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This code is similar to that in open_for_data. The routine is called&n;   whenever an audio play operation is requested.&n;*/
DECL|function|check_for_audio_disc
r_int
id|check_for_audio_disc
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_device_ops
op_star
id|cdo
)paren
(brace
r_int
id|ret
suffix:semicolon
id|tracktype
id|tracks
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering check_for_audio_disc&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdi-&gt;options
op_amp
id|CDO_CHECK_TYPE
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;drive_status
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;drive_status=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is open...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* can/may i close it? */
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_CLOSE_TRAY
)paren
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_AUTO_CLOSE
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;trying to close the tray.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. tried to close tray but failed.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Ignore the error from the low&n;&t;&t;&t;&t;&t;level driver.  We don&squot;t care why it&n;&t;&t;&t;&t;&t;couldn&squot;t close the tray.  We only care &n;&t;&t;&t;&t;&t;that there is no disc in the drive, &n;&t;&t;&t;&t;&t;since that is the _REAL_ problem here.*/
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
)brace
)brace
r_else
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. this driver can&squot;t close the tray.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
)brace
multiline_comment|/* Ok, the door should be closed now.. Check again */
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
id|CDS_NO_DISC
)paren
op_logical_or
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. the tray is still not closed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|CDS_DISC_OK
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. disc isn&squot;t ready.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is now closed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|cdrom_count_tracks
c_func
(paren
id|cdi
comma
op_amp
id|tracks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tracks.error
)paren
r_return
id|tracks.error
suffix:semicolon
r_if
c_cond
(paren
id|tracks.audio
op_eq
l_int|0
)paren
r_return
op_minus
id|EMEDIUMTYPE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Admittedly, the logic below could be performed in a nicer way. */
r_static
DECL|function|cdrom_release
r_int
id|cdrom_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
id|kdev_t
id|dev
op_assign
id|ip-&gt;i_rdev
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_int
id|opened_for_data
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_CLOSE
comma
l_string|&quot;entering cdrom_release&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
OG
l_int|0
)paren
id|cdi-&gt;use_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_eq
l_int|0
)paren
id|cdinfo
c_func
(paren
id|CD_CLOSE
comma
l_string|&quot;Use count for &bslash;&quot;/dev/%s&bslash;&quot; now zero&bslash;n&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_eq
l_int|0
op_logical_and
id|cdo-&gt;capability
op_amp
id|CDC_LOCK
op_logical_and
op_logical_neg
id|keeplocked
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_CLOSE
comma
l_string|&quot;Unlocking door!&bslash;n&quot;
)paren
suffix:semicolon
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
)brace
id|opened_for_data
op_assign
op_logical_neg
(paren
id|cdi-&gt;options
op_amp
id|CDO_USE_FFLAGS
)paren
op_logical_or
op_logical_neg
(paren
id|fp
op_logical_and
id|fp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|cdo
op_member_access_from_pointer
id|release
c_func
(paren
id|cdi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* last process that closes dev*/
r_if
c_cond
(paren
id|opened_for_data
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_AUTO_EJECT
op_logical_and
id|CDROM_CAN
c_func
(paren
id|CDC_OPEN_TRAY
)paren
)paren
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdrom_read_mech_status
r_static
r_int
id|cdrom_read_mech_status
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_changer_info
op_star
id|buf
)paren
(brace
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_int
id|length
suffix:semicolon
multiline_comment|/*&n;&t; * Sanyo changer isn&squot;t spec compliant (doesn&squot;t use regular change&n;&t; * LOAD_UNLOAD command, and it doesn&squot;t implement the mech status&n;&t; * command below&n;&t; */
r_if
c_cond
(paren
id|cdi-&gt;sanyo_slot
)paren
(brace
id|buf-&gt;hdr.nslots
op_assign
l_int|3
suffix:semicolon
id|buf-&gt;hdr.curslot
op_assign
id|cdi-&gt;sanyo_slot
op_eq
l_int|3
ques
c_cond
l_int|0
suffix:colon
id|cdi-&gt;sanyo_slot
suffix:semicolon
r_for
c_loop
(paren
id|length
op_assign
l_int|0
suffix:semicolon
id|length
OL
l_int|3
suffix:semicolon
id|length
op_increment
)paren
(brace
id|buf-&gt;slots
(braket
id|length
)braket
dot
id|disc_present
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;slots
(braket
id|length
)braket
dot
id|change
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|length
op_assign
r_sizeof
(paren
r_struct
id|cdrom_mechstat_header
)paren
op_plus
id|cdi-&gt;capacity
op_star
r_sizeof
(paren
r_struct
id|cdrom_slot
)paren
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
id|length
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_MECHANISM_STATUS
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
(paren
id|length
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|9
)braket
op_assign
id|length
op_amp
l_int|0xff
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_slot_status
r_static
r_int
id|cdrom_slot_status
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot
)paren
(brace
r_struct
id|cdrom_changer_info
id|info
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_CHANGER
comma
l_string|&quot;entering cdrom_slot_status()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;sanyo_slot
)paren
r_return
id|CDS_NO_INFO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_read_mech_status
c_func
(paren
id|cdi
comma
op_amp
id|info
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|info.slots
(braket
id|slot
)braket
dot
id|disc_present
)paren
r_return
id|CDS_DISC_OK
suffix:semicolon
r_else
r_return
id|CDS_NO_DISC
suffix:semicolon
)brace
multiline_comment|/* Return the number of slots for an ATAPI/SCSI cdrom, &n; * return 1 if not a changer. &n; */
DECL|function|cdrom_number_of_slots
r_int
id|cdrom_number_of_slots
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|nslots
op_assign
l_int|1
suffix:semicolon
r_struct
id|cdrom_changer_info
id|info
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_CHANGER
comma
l_string|&quot;entering cdrom_number_of_slots()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* cdrom_read_mech_status requires a valid value for capacity: */
id|cdi-&gt;capacity
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|cdrom_read_mech_status
c_func
(paren
id|cdi
comma
op_amp
id|info
)paren
)paren
op_eq
l_int|0
)paren
id|nslots
op_assign
id|info.hdr.nslots
suffix:semicolon
r_return
id|nslots
suffix:semicolon
)brace
multiline_comment|/* If SLOT &lt; 0, unload the current slot.  Otherwise, try to load SLOT. */
DECL|function|cdrom_load_unload
r_static
r_int
id|cdrom_load_unload
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot
)paren
(brace
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_CHANGER
comma
l_string|&quot;entering cdrom_load_unload()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;sanyo_slot
op_logical_and
id|slot
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
l_int|NULL
comma
l_int|0
comma
id|CGC_DATA_NONE
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_LOAD_UNLOAD
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|slot
op_ge
l_int|0
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|slot
suffix:semicolon
multiline_comment|/* The Sanyo 3 CD changer uses byte 7 of the &n;&t;GPCMD_TEST_UNIT_READY to command to switch CDs instead of&n;&t;using the GPCMD_LOAD_UNLOAD opcode. */
r_if
c_cond
(paren
id|cdi-&gt;sanyo_slot
op_logical_and
op_minus
l_int|1
OL
id|slot
)paren
(brace
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_TEST_UNIT_READY
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|slot
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|cdi-&gt;sanyo_slot
op_assign
id|slot
ques
c_cond
id|slot
suffix:colon
l_int|3
suffix:semicolon
)brace
r_return
id|cdi-&gt;ops
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_select_disc
r_int
id|cdrom_select_disc
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot
)paren
(brace
r_struct
id|cdrom_changer_info
id|info
suffix:semicolon
r_int
id|curslot
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_CHANGER
comma
l_string|&quot;entering cdrom_select_disc()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_DISC
)paren
)paren
r_return
op_minus
id|EDRIVE_CANT_DO_THIS
suffix:semicolon
(paren
r_void
)paren
id|cdi-&gt;ops
op_member_access_from_pointer
id|media_changed
c_func
(paren
id|cdi
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|CDSL_NONE
)paren
(brace
multiline_comment|/* set media changed bits, on both queues */
id|cdi-&gt;mc_flags
op_assign
l_int|0x3
suffix:semicolon
r_return
id|cdrom_load_unload
c_func
(paren
id|cdi
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_read_mech_status
c_func
(paren
id|cdi
comma
op_amp
id|info
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|curslot
op_assign
id|info.hdr.curslot
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
OG
l_int|1
op_logical_or
id|keeplocked
)paren
(brace
r_if
c_cond
(paren
id|slot
op_eq
id|CDSL_CURRENT
)paren
(brace
r_return
id|curslot
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/* Specifying CDSL_CURRENT will attempt to load the currnet slot,&n;&t;which is useful if it had been previously unloaded.&n;&t;Whether it can or not, it returns the current slot. &n;&t;Similarly,  if slot happens to be the current one, we still&n;&t;try and load it. */
r_if
c_cond
(paren
id|slot
op_eq
id|CDSL_CURRENT
)paren
id|slot
op_assign
id|curslot
suffix:semicolon
multiline_comment|/* set media changed bits on both queues */
id|cdi-&gt;mc_flags
op_assign
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_load_unload
c_func
(paren
id|cdi
comma
id|slot
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_return
id|slot
suffix:semicolon
)brace
multiline_comment|/* We want to make media_changed accessible to the user through an&n; * ioctl. The main problem now is that we must double-buffer the&n; * low-level implementation, to assure that the VFS and the user both&n; * see a medium change once.&n; */
r_static
DECL|function|media_changed
r_int
id|media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|queue
)paren
(brace
r_int
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
(paren
id|queue
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
op_logical_neg
op_logical_neg
(paren
id|cdi-&gt;mc_flags
op_amp
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_MEDIA_CHANGED
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* changed since last call? */
r_if
c_cond
(paren
id|cdi-&gt;ops
op_member_access_from_pointer
id|media_changed
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
)paren
(brace
id|cdi-&gt;mc_flags
op_assign
l_int|0x3
suffix:semicolon
multiline_comment|/* set bit on both queues */
id|ret
op_or_assign
l_int|1
suffix:semicolon
)brace
id|cdi-&gt;mc_flags
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/* clear bit */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cdrom_media_changed
r_static
r_int
id|cdrom_media_changed
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* This talks to the VFS, which doesn&squot;t like errors - just 1 or 0.  &n;&t; * Returning &quot;0&quot; is always safe (media hasn&squot;t been changed). Do that &n;&t; * if the low-level cdrom driver dosn&squot;t support media changed. */
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
op_logical_or
id|cdi-&gt;ops-&gt;media_changed
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_MEDIA_CHANGED
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|media_changed
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* badly broken, I know. Is due for a fixup anytime. */
DECL|function|cdrom_count_tracks
r_void
id|cdrom_count_tracks
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|tracktype
op_star
id|tracks
)paren
(brace
r_struct
id|cdrom_tochdr
id|header
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
id|tracks-&gt;data
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;audio
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;cdi
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;xa
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;error
op_assign
l_int|0
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_COUNT_TRACKS
comma
l_string|&quot;entering cdrom_count_tracks&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
(brace
id|tracks-&gt;error
op_assign
id|CDS_NO_INFO
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grab the TOC header so we can see how many tracks there are */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdi-&gt;ops
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|CDROMREADTOCHDR
comma
op_amp
id|header
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOMEDIUM
)paren
id|tracks-&gt;error
op_assign
id|CDS_NO_DISC
suffix:semicolon
r_else
id|tracks-&gt;error
op_assign
id|CDS_NO_INFO
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check what type of tracks are on this disc */
id|entry.cdte_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|header.cdth_trk0
suffix:semicolon
id|i
op_le
id|header.cdth_trk1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|entry.cdte_track
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;ops
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|CDROMREADTOCENTRY
comma
op_amp
id|entry
)paren
)paren
(brace
id|tracks-&gt;error
op_assign
id|CDS_NO_INFO
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry.cdte_ctrl
op_amp
id|CDROM_DATA_TRACK
)paren
(brace
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
l_int|0x10
)paren
id|tracks-&gt;cdi
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
l_int|0x20
)paren
id|tracks-&gt;xa
op_increment
suffix:semicolon
r_else
id|tracks-&gt;data
op_increment
suffix:semicolon
)brace
r_else
id|tracks-&gt;audio
op_increment
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_COUNT_TRACKS
comma
l_string|&quot;track %d: format=%d, ctrl=%d&bslash;n&quot;
comma
id|i
comma
id|entry.cdte_format
comma
id|entry.cdte_ctrl
)paren
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_COUNT_TRACKS
comma
l_string|&quot;disc has %d tracks: %d=audio %d=data %d=Cd-I %d=XA&bslash;n&quot;
comma
id|header.cdth_trk1
comma
id|tracks-&gt;audio
comma
id|tracks-&gt;data
comma
id|tracks-&gt;cdi
comma
id|tracks-&gt;xa
)paren
suffix:semicolon
)brace
multiline_comment|/* Requests to the low-level drivers will /always/ be done in the&n;   following format convention:&n;&n;   CDROM_LBA: all data-related requests.&n;   CDROM_MSF: all audio-related requests.&n;&n;   However, a low-level implementation is allowed to refuse this&n;   request, and return information in its own favorite format.&n;&n;   It doesn&squot;t make sense /at all/ to ask for a play_audio in LBA&n;   format, or ask for multi-session info in MSF format. However, for&n;   backward compatibility these format requests will be satisfied, but&n;   the requests to the low-level drivers will be sanitized in the more&n;   meaningful format indicated above.&n; */
r_static
DECL|function|sanitize_format
r_void
id|sanitize_format
c_func
(paren
r_union
id|cdrom_addr
op_star
id|addr
comma
id|u_char
op_star
id|curr
comma
id|u_char
id|requested
)paren
(brace
r_if
c_cond
(paren
op_star
id|curr
op_eq
id|requested
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing to be done! */
r_if
c_cond
(paren
id|requested
op_eq
id|CDROM_LBA
)paren
(brace
id|addr-&gt;lba
op_assign
(paren
r_int
)paren
id|addr-&gt;msf.frame
op_plus
l_int|75
op_star
(paren
id|addr-&gt;msf.second
op_minus
l_int|2
op_plus
l_int|60
op_star
id|addr-&gt;msf.minute
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* CDROM_MSF */
r_int
id|lba
op_assign
id|addr-&gt;lba
suffix:semicolon
id|addr-&gt;msf.frame
op_assign
id|lba
op_mod
l_int|75
suffix:semicolon
id|lba
op_div_assign
l_int|75
suffix:semicolon
id|lba
op_add_assign
l_int|2
suffix:semicolon
id|addr-&gt;msf.second
op_assign
id|lba
op_mod
l_int|60
suffix:semicolon
id|addr-&gt;msf.minute
op_assign
id|lba
op_div
l_int|60
suffix:semicolon
)brace
op_star
id|curr
op_assign
id|requested
suffix:semicolon
)brace
DECL|function|init_cdrom_command
r_void
id|init_cdrom_command
c_func
(paren
r_struct
id|cdrom_generic_command
op_star
id|cgc
comma
r_void
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|type
)paren
(brace
id|memset
c_func
(paren
id|cgc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cdrom_generic_command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|cgc-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
id|cgc-&gt;buflen
op_assign
id|len
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|type
suffix:semicolon
id|cgc-&gt;timeout
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
multiline_comment|/* DVD handling */
DECL|macro|copy_key
mdefine_line|#define copy_key(dest,src)&t;memcpy((dest), (src), sizeof(dvd_key))
DECL|macro|copy_chal
mdefine_line|#define copy_chal(dest,src)&t;memcpy((dest), (src), sizeof(dvd_challenge))
DECL|function|setup_report_key
r_static
r_void
id|setup_report_key
c_func
(paren
r_struct
id|cdrom_generic_command
op_star
id|cgc
comma
r_int
id|agid
comma
r_int
id|type
)paren
(brace
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_REPORT_KEY
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|10
)braket
op_assign
id|type
op_or
(paren
id|agid
op_lshift
l_int|6
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|5
suffix:colon
(brace
id|cgc-&gt;buflen
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
(brace
id|cgc-&gt;buflen
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
r_case
l_int|4
suffix:colon
(brace
id|cgc-&gt;buflen
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|cgc-&gt;cmd
(braket
l_int|9
)braket
op_assign
id|cgc-&gt;buflen
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|CGC_DATA_READ
suffix:semicolon
)brace
DECL|function|setup_send_key
r_static
r_void
id|setup_send_key
c_func
(paren
r_struct
id|cdrom_generic_command
op_star
id|cgc
comma
r_int
id|agid
comma
r_int
id|type
)paren
(brace
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_SEND_KEY
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|10
)braket
op_assign
id|type
op_or
(paren
id|agid
op_lshift
l_int|6
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|1
suffix:colon
(brace
id|cgc-&gt;buflen
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|3
suffix:colon
(brace
id|cgc-&gt;buflen
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|6
suffix:colon
(brace
id|cgc-&gt;buflen
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|cgc-&gt;cmd
(braket
l_int|9
)braket
op_assign
id|cgc-&gt;buflen
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|CGC_DATA_WRITE
suffix:semicolon
)brace
DECL|function|dvd_do_auth
r_static
r_int
id|dvd_do_auth
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_authinfo
op_star
id|ai
)paren
(brace
r_int
id|ret
suffix:semicolon
id|u_char
id|buf
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|rpc_state_t
id|rpc_state
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
l_int|0
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ai-&gt;type
)paren
(brace
multiline_comment|/* LU data send */
r_case
id|DVD_LU_SEND_AGID
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_LU_SEND_AGID&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;lsa.agid
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ai-&gt;lsa.agid
op_assign
id|buf
(braket
l_int|7
)braket
op_rshift
l_int|6
suffix:semicolon
multiline_comment|/* Returning data, let host change state */
r_break
suffix:semicolon
r_case
id|DVD_LU_SEND_KEY1
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_LU_SEND_KEY1&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;lsk.agid
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|copy_key
c_func
(paren
id|ai-&gt;lsk.key
comma
op_amp
id|buf
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* Returning data, let host change state */
r_break
suffix:semicolon
r_case
id|DVD_LU_SEND_CHALLENGE
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_LU_SEND_CHALLENGE&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;lsc.agid
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|copy_chal
c_func
(paren
id|ai-&gt;lsc.chal
comma
op_amp
id|buf
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* Returning data, let host change state */
r_break
suffix:semicolon
multiline_comment|/* Post-auth key */
r_case
id|DVD_LU_SEND_TITLE_KEY
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_LU_SEND_TITLE_KEY&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;lstk.agid
comma
l_int|4
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|5
)braket
op_assign
id|ai-&gt;lstk.lba
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
id|ai-&gt;lstk.lba
op_rshift
l_int|8
suffix:semicolon
id|cgc.cmd
(braket
l_int|3
)braket
op_assign
id|ai-&gt;lstk.lba
op_rshift
l_int|16
suffix:semicolon
id|cgc.cmd
(braket
l_int|2
)braket
op_assign
id|ai-&gt;lstk.lba
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ai-&gt;lstk.cpm
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_rshift
l_int|7
)paren
op_amp
l_int|1
suffix:semicolon
id|ai-&gt;lstk.cp_sec
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_rshift
l_int|6
)paren
op_amp
l_int|1
suffix:semicolon
id|ai-&gt;lstk.cgms
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|3
suffix:semicolon
id|copy_key
c_func
(paren
id|ai-&gt;lstk.title_key
comma
op_amp
id|buf
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* Returning data, let host change state */
r_break
suffix:semicolon
r_case
id|DVD_LU_SEND_ASF
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_LU_SEND_ASF&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;lsasf.agid
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ai-&gt;lsasf.asf
op_assign
id|buf
(braket
l_int|7
)braket
op_amp
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* LU data receive (LU changes state) */
r_case
id|DVD_HOST_SEND_CHALLENGE
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_HOST_SEND_CHALLENGE&bslash;n&quot;
)paren
suffix:semicolon
id|setup_send_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;hsc.agid
comma
l_int|1
)paren
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0xe
suffix:semicolon
id|copy_chal
c_func
(paren
op_amp
id|buf
(braket
l_int|4
)braket
comma
id|ai-&gt;hsc.chal
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ai-&gt;type
op_assign
id|DVD_LU_SEND_KEY1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DVD_HOST_SEND_KEY2
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_HOST_SEND_KEY2&bslash;n&quot;
)paren
suffix:semicolon
id|setup_send_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;hsk.agid
comma
l_int|3
)paren
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0xa
suffix:semicolon
id|copy_key
c_func
(paren
op_amp
id|buf
(braket
l_int|4
)braket
comma
id|ai-&gt;hsk.key
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
(brace
id|ai-&gt;type
op_assign
id|DVD_AUTH_FAILURE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ai-&gt;type
op_assign
id|DVD_AUTH_ESTABLISHED
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Misc */
r_case
id|DVD_INVALIDATE_AGID
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_INVALIDATE_AGID&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
id|ai-&gt;lsa.agid
comma
l_int|0x3f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Get region settings */
r_case
id|DVD_LU_SEND_RPC_STATE
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_LU_SEND_RPC_STATE&bslash;n&quot;
)paren
suffix:semicolon
id|setup_report_key
c_func
(paren
op_amp
id|cgc
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rpc_state
comma
l_int|0
comma
r_sizeof
(paren
id|rpc_state_t
)paren
)paren
suffix:semicolon
id|cgc.buffer
op_assign
(paren
r_char
op_star
)paren
op_amp
id|rpc_state
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ai-&gt;lrpcs.type
op_assign
id|rpc_state.type_code
suffix:semicolon
id|ai-&gt;lrpcs.vra
op_assign
id|rpc_state.vra
suffix:semicolon
id|ai-&gt;lrpcs.ucca
op_assign
id|rpc_state.ucca
suffix:semicolon
id|ai-&gt;lrpcs.region_mask
op_assign
id|rpc_state.region_mask
suffix:semicolon
id|ai-&gt;lrpcs.rpc_scheme
op_assign
id|rpc_state.rpc_scheme
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Set region settings */
r_case
id|DVD_HOST_SEND_RPC_STATE
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DVD
comma
l_string|&quot;entering DVD_HOST_SEND_RPC_STATE&bslash;n&quot;
)paren
suffix:semicolon
id|setup_send_key
c_func
(paren
op_amp
id|cgc
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|6
suffix:semicolon
id|buf
(braket
l_int|4
)braket
op_assign
id|ai-&gt;hrpcs.pdrc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;Invalid DVD key ioctl (%d)&bslash;n&quot;
comma
id|ai-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvd_read_physical
r_static
r_int
id|dvd_read_physical
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_struct
op_star
id|s
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
id|u_char
id|buf
(braket
l_int|4
op_plus
l_int|4
op_star
l_int|20
)braket
comma
op_star
id|base
suffix:semicolon
r_struct
id|dvd_layer
op_star
id|layer
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DVD_STRUCTURE
suffix:semicolon
id|cgc.cmd
(braket
l_int|6
)braket
op_assign
id|s-&gt;physical.layer_num
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|s-&gt;type
suffix:semicolon
id|cgc.cmd
(braket
l_int|9
)braket
op_assign
id|cgc.buflen
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|base
op_assign
op_amp
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|layer
op_assign
op_amp
id|s-&gt;physical.layer
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* place the data... really ugly, but at least we won&squot;t have to&n;&t;   worry about endianess in userspace or here. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
comma
id|base
op_add_assign
l_int|20
comma
op_increment
id|layer
)paren
(brace
id|memset
c_func
(paren
id|layer
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|layer
)paren
)paren
suffix:semicolon
id|layer-&gt;book_version
op_assign
id|base
(braket
l_int|0
)braket
op_amp
l_int|0xf
suffix:semicolon
id|layer-&gt;book_type
op_assign
id|base
(braket
l_int|0
)braket
op_rshift
l_int|4
suffix:semicolon
id|layer-&gt;min_rate
op_assign
id|base
(braket
l_int|1
)braket
op_amp
l_int|0xf
suffix:semicolon
id|layer-&gt;disc_size
op_assign
id|base
(braket
l_int|1
)braket
op_rshift
l_int|4
suffix:semicolon
id|layer-&gt;layer_type
op_assign
id|base
(braket
l_int|2
)braket
op_amp
l_int|0xf
suffix:semicolon
id|layer-&gt;track_path
op_assign
(paren
id|base
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|1
suffix:semicolon
id|layer-&gt;nlayers
op_assign
(paren
id|base
(braket
l_int|2
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|3
suffix:semicolon
id|layer-&gt;track_density
op_assign
id|base
(braket
l_int|3
)braket
op_amp
l_int|0xf
suffix:semicolon
id|layer-&gt;linear_density
op_assign
id|base
(braket
l_int|3
)braket
op_rshift
l_int|4
suffix:semicolon
id|layer-&gt;start_sector
op_assign
id|base
(braket
l_int|5
)braket
op_lshift
l_int|16
op_or
id|base
(braket
l_int|6
)braket
op_lshift
l_int|8
op_or
id|base
(braket
l_int|7
)braket
suffix:semicolon
id|layer-&gt;end_sector
op_assign
id|base
(braket
l_int|9
)braket
op_lshift
l_int|16
op_or
id|base
(braket
l_int|10
)braket
op_lshift
l_int|8
op_or
id|base
(braket
l_int|11
)braket
suffix:semicolon
id|layer-&gt;end_sector_l0
op_assign
id|base
(braket
l_int|13
)braket
op_lshift
l_int|16
op_or
id|base
(braket
l_int|14
)braket
op_lshift
l_int|8
op_or
id|base
(braket
l_int|15
)braket
suffix:semicolon
id|layer-&gt;bca
op_assign
id|base
(braket
l_int|16
)braket
op_rshift
l_int|7
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvd_read_copyright
r_static
r_int
id|dvd_read_copyright
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_struct
op_star
id|s
)paren
(brace
r_int
id|ret
suffix:semicolon
id|u_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DVD_STRUCTURE
suffix:semicolon
id|cgc.cmd
(braket
l_int|6
)braket
op_assign
id|s-&gt;copyright.layer_num
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|s-&gt;type
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
op_rshift
l_int|8
suffix:semicolon
id|cgc.cmd
(braket
l_int|9
)braket
op_assign
id|cgc.buflen
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|s-&gt;copyright.cpst
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|s-&gt;copyright.rmi
op_assign
id|buf
(braket
l_int|5
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvd_read_disckey
r_static
r_int
id|dvd_read_disckey
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_struct
op_star
id|s
)paren
(brace
r_int
id|ret
comma
id|size
suffix:semicolon
id|u_char
op_star
id|buf
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
id|s-&gt;disckey.value
)paren
op_plus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buf
op_assign
(paren
id|u_char
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
id|size
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DVD_STRUCTURE
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|s-&gt;type
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|size
op_rshift
l_int|8
suffix:semicolon
id|cgc.cmd
(braket
l_int|9
)braket
op_assign
id|size
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|10
)braket
op_assign
id|s-&gt;disckey.agid
op_lshift
l_int|6
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|s-&gt;disckey.value
comma
op_amp
id|buf
(braket
l_int|4
)braket
comma
r_sizeof
(paren
id|s-&gt;disckey.value
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dvd_read_bca
r_static
r_int
id|dvd_read_bca
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_struct
op_star
id|s
)paren
(brace
r_int
id|ret
suffix:semicolon
id|u_char
id|buf
(braket
l_int|4
op_plus
l_int|188
)braket
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DVD_STRUCTURE
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|s-&gt;type
suffix:semicolon
id|cgc.cmd
(braket
l_int|9
)braket
op_assign
id|cgc.buflen
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|s-&gt;bca.len
op_assign
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|8
op_or
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;bca.len
template_param
l_int|188
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;Received invalid BCA length (%d)&bslash;n&quot;
comma
id|s-&gt;bca.len
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|s-&gt;bca.value
comma
op_amp
id|buf
(braket
l_int|4
)braket
comma
id|s-&gt;bca.len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvd_read_manufact
r_static
r_int
id|dvd_read_manufact
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_struct
op_star
id|s
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|size
suffix:semicolon
id|u_char
op_star
id|buf
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
id|s-&gt;manufact.value
)paren
op_plus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buf
op_assign
(paren
id|u_char
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
id|size
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DVD_STRUCTURE
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|s-&gt;type
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|size
op_rshift
l_int|8
suffix:semicolon
id|cgc.cmd
(braket
l_int|9
)braket
op_assign
id|size
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|s-&gt;manufact.len
op_assign
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|8
op_or
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;manufact.len
template_param
l_int|2048
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;Received invalid manufacture info length&quot;
l_string|&quot; (%d)&bslash;n&quot;
comma
id|s-&gt;bca.len
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|s-&gt;manufact.value
comma
op_amp
id|buf
(braket
l_int|4
)braket
comma
id|s-&gt;manufact.len
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dvd_read_struct
r_static
r_int
id|dvd_read_struct
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|dvd_struct
op_star
id|s
)paren
(brace
r_switch
c_cond
(paren
id|s-&gt;type
)paren
(brace
r_case
id|DVD_STRUCT_PHYSICAL
suffix:colon
r_return
id|dvd_read_physical
c_func
(paren
id|cdi
comma
id|s
)paren
suffix:semicolon
r_case
id|DVD_STRUCT_COPYRIGHT
suffix:colon
r_return
id|dvd_read_copyright
c_func
(paren
id|cdi
comma
id|s
)paren
suffix:semicolon
r_case
id|DVD_STRUCT_DISCKEY
suffix:colon
r_return
id|dvd_read_disckey
c_func
(paren
id|cdi
comma
id|s
)paren
suffix:semicolon
r_case
id|DVD_STRUCT_BCA
suffix:colon
r_return
id|dvd_read_bca
c_func
(paren
id|cdi
comma
id|s
)paren
suffix:semicolon
r_case
id|DVD_STRUCT_MANUFACT
suffix:colon
r_return
id|dvd_read_manufact
c_func
(paren
id|cdi
comma
id|s
)paren
suffix:semicolon
r_default
suffix:colon
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;: Invalid DVD structure read requested (%d)&bslash;n&quot;
comma
id|s-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|cdrom_mode_sense
r_int
id|cdrom_mode_sense
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_generic_command
op_star
id|cgc
comma
r_int
id|page_code
comma
r_int
id|page_control
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|memset
c_func
(paren
id|cgc-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|cgc-&gt;cmd
)paren
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_MODE_SENSE_10
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|2
)braket
op_assign
id|page_code
op_or
(paren
id|page_control
op_lshift
l_int|6
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|7
)braket
op_assign
id|cgc-&gt;buflen
op_rshift
l_int|8
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|8
)braket
op_assign
id|cgc-&gt;buflen
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|CGC_DATA_READ
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_mode_select
r_int
id|cdrom_mode_select
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_generic_command
op_star
id|cgc
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|memset
c_func
(paren
id|cgc-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|cgc-&gt;cmd
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cgc-&gt;buffer
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_MODE_SELECT_10
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* PF */
id|cgc-&gt;cmd
(braket
l_int|7
)braket
op_assign
id|cgc-&gt;buflen
op_rshift
l_int|8
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|8
)braket
op_assign
id|cgc-&gt;buflen
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|CGC_DATA_WRITE
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_read_subchannel
r_static
r_int
id|cdrom_read_subchannel
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_subchnl
op_star
id|subchnl
comma
r_int
id|mcn
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_char
id|buffer
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buffer
comma
l_int|16
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_SUBCHANNEL
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* MSF addressing */
id|cgc.cmd
(braket
l_int|2
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* request subQ data */
id|cgc.cmd
(braket
l_int|3
)braket
op_assign
id|mcn
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|subchnl-&gt;cdsc_audiostatus
op_assign
id|cgc.buffer
(braket
l_int|1
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_format
op_assign
id|CDROM_MSF
suffix:semicolon
id|subchnl-&gt;cdsc_ctrl
op_assign
id|cgc.buffer
(braket
l_int|5
)braket
op_amp
l_int|0xf
suffix:semicolon
id|subchnl-&gt;cdsc_trk
op_assign
id|cgc.buffer
(braket
l_int|6
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_ind
op_assign
id|cgc.buffer
(braket
l_int|7
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.minute
op_assign
id|cgc.buffer
(braket
l_int|13
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.second
op_assign
id|cgc.buffer
(braket
l_int|14
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.frame
op_assign
id|cgc.buffer
(braket
l_int|15
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.minute
op_assign
id|cgc.buffer
(braket
l_int|9
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.second
op_assign
id|cgc.buffer
(braket
l_int|10
)braket
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.frame
op_assign
id|cgc.buffer
(braket
l_int|11
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Specific READ_10 interface&n; */
DECL|function|cdrom_read_cd
r_static
r_int
id|cdrom_read_cd
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_generic_command
op_star
id|cgc
comma
r_int
id|lba
comma
r_int
id|blocksize
comma
r_int
id|nblocks
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cgc-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|cgc-&gt;cmd
)paren
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_10
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|2
)braket
op_assign
(paren
id|lba
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|3
)braket
op_assign
(paren
id|lba
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|4
)braket
op_assign
(paren
id|lba
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|5
)braket
op_assign
id|lba
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|6
)braket
op_assign
(paren
id|nblocks
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|7
)braket
op_assign
(paren
id|nblocks
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|8
)braket
op_assign
id|nblocks
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;buflen
op_assign
id|blocksize
op_star
id|nblocks
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
id|cgc
)paren
suffix:semicolon
)brace
multiline_comment|/* very generic interface for reading the various types of blocks */
DECL|function|cdrom_read_block
r_static
r_int
id|cdrom_read_block
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_generic_command
op_star
id|cgc
comma
r_int
id|lba
comma
r_int
id|nblocks
comma
r_int
id|format
comma
r_int
id|blksize
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cgc-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|cgc-&gt;cmd
)paren
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_CD
suffix:semicolon
multiline_comment|/* expected sector size - cdda,mode1,etc. */
id|cgc-&gt;cmd
(braket
l_int|1
)braket
op_assign
id|format
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/* starting address */
id|cgc-&gt;cmd
(braket
l_int|2
)braket
op_assign
(paren
id|lba
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|3
)braket
op_assign
(paren
id|lba
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|4
)braket
op_assign
(paren
id|lba
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|5
)braket
op_assign
id|lba
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* number of blocks */
id|cgc-&gt;cmd
(braket
l_int|6
)braket
op_assign
(paren
id|nblocks
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|7
)braket
op_assign
(paren
id|nblocks
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|8
)braket
op_assign
id|nblocks
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;buflen
op_assign
id|blksize
op_star
id|nblocks
suffix:semicolon
multiline_comment|/* set the header info returned */
r_switch
c_cond
(paren
id|blksize
)paren
(brace
r_case
id|CD_FRAMESIZE_RAW0
suffix:colon
id|cgc-&gt;cmd
(braket
l_int|9
)braket
op_assign
l_int|0x58
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CD_FRAMESIZE_RAW1
suffix:colon
id|cgc-&gt;cmd
(braket
l_int|9
)braket
op_assign
l_int|0x78
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CD_FRAMESIZE_RAW
suffix:colon
id|cgc-&gt;cmd
(braket
l_int|9
)braket
op_assign
l_int|0xf8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cgc-&gt;cmd
(braket
l_int|9
)braket
op_assign
l_int|0x10
suffix:semicolon
)brace
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
id|cgc
)paren
suffix:semicolon
)brace
multiline_comment|/* Just about every imaginable ioctl is supported in the Uniform layer&n; * these days. ATAPI / SCSI specific code now mainly resides in&n; * mmc_ioct().&n; */
DECL|function|cdrom_ioctl
r_static
r_int
id|cdrom_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|kdev_t
id|dev
op_assign
id|ip-&gt;i_rdev
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* the first few commands do not deal with audio drive_info, but&n;&t;   only with routines in cdrom device operations. */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_struct
id|cdrom_multisession
id|ms_info
suffix:semicolon
id|u_char
id|requested_format
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMMULTISESSION&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_MULTI_SESSION
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_multisession
comma
id|ms_info
)paren
suffix:semicolon
id|requested_format
op_assign
id|ms_info.addr_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested_format
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested_format
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms_info.addr_format
op_assign
id|CDROM_LBA
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|get_last_session
c_func
(paren
id|cdi
comma
op_amp
id|ms_info
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|ms_info.addr
comma
op_amp
id|ms_info.addr_format
comma
id|requested_format
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_multisession
comma
id|ms_info
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;CDROMMULTISESSION successful&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMEJECT&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_OPEN_TRAY
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_ne
l_int|1
op_logical_or
id|keeplocked
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
)brace
r_case
id|CDROMCLOSETRAY
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMCLOSETRAY&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_CLOSE_TRAY
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|CDROMEJECT_SW
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMEJECT_SW&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_OPEN_TRAY
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|keeplocked
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|cdi-&gt;options
op_and_assign
op_complement
(paren
id|CDO_AUTO_CLOSE
op_or
id|CDO_AUTO_EJECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|cdi-&gt;options
op_or_assign
id|CDO_AUTO_CLOSE
op_or
id|CDO_AUTO_EJECT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROM_MEDIA_CHANGED
suffix:colon
(brace
r_struct
id|cdrom_changer_info
id|info
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_MEDIA_CHANGED&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_MEDIA_CHANGED
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* cannot select disc or select current disc */
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_DISC
)paren
op_logical_or
id|arg
op_eq
id|CDSL_CURRENT
)paren
r_return
id|media_changed
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|arg
op_ge
id|cdi-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_read_mech_status
c_func
(paren
id|cdi
comma
op_amp
id|info
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_return
id|info.slots
(braket
id|arg
)braket
dot
id|change
suffix:semicolon
)brace
r_case
id|CDROM_SET_OPTIONS
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SET_OPTIONS&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* options need to be in sync with capability. too late for&n;&t;&t;   that, so we have to check each one separately... */
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|CDO_USE_FFLAGS
suffix:colon
r_case
id|CDO_CHECK_TYPE
suffix:colon
r_break
suffix:semicolon
r_case
id|CDO_LOCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
id|cdi-&gt;options
suffix:semicolon
multiline_comment|/* default is basically CDO_[AUTO_CLOSE|AUTO_EJECT] */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|arg
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|arg
suffix:semicolon
r_return
id|cdi-&gt;options
suffix:semicolon
)brace
r_case
id|CDROM_CLEAR_OPTIONS
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_CLEAR_OPTIONS&bslash;n&quot;
)paren
suffix:semicolon
id|cdi-&gt;options
op_and_assign
op_complement
(paren
r_int
)paren
id|arg
suffix:semicolon
r_return
id|cdi-&gt;options
suffix:semicolon
)brace
r_case
id|CDROM_SELECT_SPEED
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SELECT_SPEED&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_SPEED
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|select_speed
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
r_case
id|CDROM_SELECT_DISC
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SELECT_DISC&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_DISC
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
op_ne
id|CDSL_CURRENT
)paren
op_logical_and
(paren
id|arg
op_ne
id|CDSL_NONE
)paren
)paren
r_if
c_cond
(paren
(paren
r_int
)paren
id|arg
op_ge
id|cdi-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* cdo-&gt;select_disc is a hook to allow a driver-specific&n;&t;&t; * way of seleting disc.  However, since there is no&n;&t;&t; * equiv hook for cdrom_slot_status this may not &n;&t;&t; * actually be useful...&n;&t;&t; */
r_if
c_cond
(paren
id|cdo-&gt;select_disc
op_ne
l_int|NULL
)paren
r_return
id|cdo
op_member_access_from_pointer
id|select_disc
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* no driver specific select_disc(), call our own */
id|cdinfo
c_func
(paren
id|CD_CHANGER
comma
l_string|&quot;Using generic cdrom_select_disc()&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|cdrom_select_disc
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
r_case
id|CDROMRESET
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_RESET&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_RESET
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|reset
c_func
(paren
id|cdi
)paren
suffix:semicolon
)brace
r_case
id|CDROM_LOCKDOOR
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;%socking door.&bslash;n&quot;
comma
id|arg
ques
c_cond
l_string|&quot;L&quot;
suffix:colon
l_string|&quot;Unl&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
)paren
r_return
op_minus
id|EDRIVE_CANT_DO_THIS
suffix:semicolon
id|keeplocked
op_assign
id|arg
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t unlock the door on multiple opens,but allow root&n;&t;&t; * to do so */
r_if
c_cond
(paren
(paren
id|cdi-&gt;use_count
op_ne
l_int|1
)paren
op_logical_and
op_logical_neg
id|arg
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
r_case
id|CDROM_DEBUG
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;%sabling debug.&bslash;n&quot;
comma
id|arg
ques
c_cond
l_string|&quot;En&quot;
suffix:colon
l_string|&quot;Dis&quot;
)paren
suffix:semicolon
id|debug
op_assign
id|arg
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
id|debug
suffix:semicolon
)brace
r_case
id|CDROM_GET_CAPABILITY
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_GET_CAPABILITY&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
)paren
suffix:semicolon
)brace
multiline_comment|/* The following function is implemented, although very few audio&n; * discs give Universal Product Code information, which should just be&n; * the Medium Catalog Number on the box.  Note, that the way the code&n; * is written on the CD is /not/ uniform across all discs!&n; */
r_case
id|CDROM_GET_MCN
suffix:colon
(brace
r_struct
id|cdrom_mcn
id|mcn
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_GET_MCN&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_MCN
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|get_mcn
c_func
(paren
id|cdi
comma
op_amp
id|mcn
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_mcn
comma
id|mcn
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;CDROM_GET_MCN successful&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROM_DRIVE_STATUS
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_DRIVE_STATUS&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_DRIVE_STATUS
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_DISC
)paren
)paren
r_return
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|CDSL_CURRENT
)paren
op_logical_or
(paren
id|arg
op_eq
id|CDSL_NONE
)paren
)paren
r_return
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|arg
op_ge
id|cdi-&gt;capacity
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_slot_status
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, this is where problems start.  The current interface for the&n;&t;   CDROM_DISC_STATUS ioctl is flawed.  It makes the false assumption&n;&t;   that CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.  Unfortunatly,&n;&t;   while this is often the case, it is also very common for CDs to&n;&t;   have some tracks with data, and some tracks with audio.  Just &n;&t;   because I feel like it, I declare the following to be the best&n;&t;   way to cope.  If the CD has ANY data tracks on it, it will be&n;&t;   returned as a data CD.  If it has any XA tracks, I will return&n;&t;   it as that.  Now I could simplify this interface by combining these &n;&t;   returns with the above, but this more clearly demonstrates&n;&t;   the problem with the current interface.  Too bad this wasn&squot;t &n;&t;   designed to use bitmasks...         -Erik &n;&n;&t;   Well, now we have the option CDS_MIXED: a mixed-type CD. &n;&t;   User level programmers might feel the ioctl is not very useful.&n;&t;   &t;&t;&t;&t;&t;---david&n;&t;*/
r_case
id|CDROM_DISC_STATUS
suffix:colon
(brace
id|tracktype
id|tracks
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_DISC_STATUS&bslash;n&quot;
)paren
suffix:semicolon
id|cdrom_count_tracks
c_func
(paren
id|cdi
comma
op_amp
id|tracks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tracks.error
)paren
r_return
id|tracks.error
suffix:semicolon
multiline_comment|/* Policy mode on */
r_if
c_cond
(paren
id|tracks.audio
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tracks.data
op_eq
l_int|0
op_logical_and
id|tracks.cdi
op_eq
l_int|0
op_logical_and
id|tracks.xa
op_eq
l_int|0
)paren
r_return
id|CDS_AUDIO
suffix:semicolon
r_else
r_return
id|CDS_MIXED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tracks.cdi
OG
l_int|0
)paren
r_return
id|CDS_XA_2_2
suffix:semicolon
r_if
c_cond
(paren
id|tracks.xa
OG
l_int|0
)paren
r_return
id|CDS_XA_2_1
suffix:semicolon
r_if
c_cond
(paren
id|tracks.data
OG
l_int|0
)paren
r_return
id|CDS_DATA_1
suffix:semicolon
multiline_comment|/* Policy mode off */
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;This disc doesn&squot;t have any tracks I recognize!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|CDS_NO_INFO
suffix:semicolon
)brace
r_case
id|CDROM_CHANGER_NSLOTS
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_CHANGER_NSLOTS&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|cdi-&gt;capacity
suffix:semicolon
)brace
)brace
multiline_comment|/* use the ioctls that are implemented through the generic_packet()&n;&t;   interface. this may look at bit funny, but if -ENOTTY is&n;&t;   returned that particular ioctl is not implemented and we&n;&t;   let it go through the device specific ones. */
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_GENERIC_PACKET
)paren
)paren
(brace
id|ret
op_assign
id|mmc_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOTTY
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* note: most of the cdinfo() calls are commented out here,&n;&t;   because they fill up the sys log when CD players poll&n;&t;   the drive. */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|cdrom_subchnl
id|q
suffix:semicolon
id|u_char
id|requested
comma
id|back
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL,&quot;entering CDROMSUBCHNL&bslash;n&quot;);*/
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_subchnl
comma
id|q
)paren
suffix:semicolon
id|requested
op_assign
id|q.cdsc_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q.cdsc_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|q
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|back
op_assign
id|q.cdsc_format
suffix:semicolon
multiline_comment|/* local copy */
id|sanitize_format
c_func
(paren
op_amp
id|q.cdsc_absaddr
comma
op_amp
id|back
comma
id|requested
)paren
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|q.cdsc_reladdr
comma
op_amp
id|q.cdsc_format
comma
id|requested
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_subchnl
comma
id|q
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMSUBCHNL successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
id|header
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;entering CDROMREADTOCHDR&bslash;n&quot;); */
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tochdr
comma
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|header
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tochdr
comma
id|header
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMREADTOCHDR successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
id|u_char
id|requested_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;entering CDROMREADTOCENTRY&bslash;n&quot;); */
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tocentry
comma
id|entry
)paren
suffix:semicolon
id|requested_format
op_assign
id|entry.cdte_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested_format
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested_format
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* make interface to low-level uniform */
id|entry.cdte_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|entry
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|entry.cdte_addr
comma
op_amp
id|entry.cdte_format
comma
id|requested_format
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tocentry
comma
id|entry
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMREADTOCENTRY successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPLAYMSF&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_msf
comma
id|msf
)paren
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|msf
)paren
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPLAYTRKIND&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_ti
comma
id|ti
)paren
suffix:semicolon
id|CHECKAUDIO
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|ti
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volume
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMVOLCTRL&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_volctrl
comma
id|volume
)paren
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|volume
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLREAD
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volume
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMVOLREAD&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|volume
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_volctrl
comma
id|volume
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTART
suffix:colon
r_case
id|CDROMSTOP
suffix:colon
r_case
id|CDROMPAUSE
suffix:colon
r_case
id|CDROMRESUME
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;doing audio ioctl (start/stop/pause/resume)&bslash;n&quot;
)paren
suffix:semicolon
id|CHECKAUDIO
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* switch */
multiline_comment|/* do the device specific ioctls */
r_if
c_cond
(paren
id|CDROM_CAN
c_func
(paren
id|CDC_IOCTLS
)paren
)paren
r_return
id|cdo
op_member_access_from_pointer
id|dev_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_static
r_inline
DECL|function|msf_to_lba
r_int
id|msf_to_lba
c_func
(paren
r_char
id|m
comma
r_char
id|s
comma
r_char
id|f
)paren
(brace
r_return
(paren
(paren
(paren
id|m
op_star
id|CD_SECS
)paren
op_plus
id|s
)paren
op_star
id|CD_FRAMES
op_plus
id|f
)paren
op_minus
id|CD_MSF_OFFSET
suffix:semicolon
)brace
multiline_comment|/*&n; * Required when we need to use READ_10 to issue other than 2048 block&n; * reads&n; */
DECL|function|cdrom_switch_blocksize
r_static
r_int
id|cdrom_switch_blocksize
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|size
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_struct
id|modesel_head
id|mh
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mh
comma
l_int|0
comma
r_sizeof
(paren
id|mh
)paren
)paren
suffix:semicolon
id|mh.block_desc_length
op_assign
l_int|0x08
suffix:semicolon
id|mh.block_length_med
op_assign
(paren
id|size
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mh.block_length_lo
op_assign
id|size
op_amp
l_int|0xff
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cgc
comma
l_int|0
comma
r_sizeof
(paren
id|cgc
)paren
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
l_int|0x15
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|1
op_lshift
l_int|4
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
l_int|12
suffix:semicolon
id|cgc.buflen
op_assign
r_sizeof
(paren
id|mh
)paren
suffix:semicolon
id|cgc.buffer
op_assign
(paren
r_char
op_star
)paren
op_amp
id|mh
suffix:semicolon
id|cgc.data_direction
op_assign
id|CGC_DATA_WRITE
suffix:semicolon
id|mh.block_desc_length
op_assign
l_int|0x08
suffix:semicolon
id|mh.block_length_med
op_assign
(paren
id|size
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mh.block_length_lo
op_assign
id|size
op_amp
l_int|0xff
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_cmd
r_static
r_int
id|cdrom_do_cmd
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_generic_command
op_star
id|cgc
)paren
(brace
r_struct
id|request_sense
op_star
id|usense
comma
id|sense
suffix:semicolon
r_int
r_char
op_star
id|ubuf
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|cgc-&gt;data_direction
op_eq
id|CGC_DATA_UNKNOWN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cgc-&gt;buflen
OL
l_int|0
op_logical_or
id|cgc-&gt;buflen
op_ge
l_int|131072
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ubuf
op_assign
id|cgc-&gt;buffer
)paren
)paren
(brace
id|cgc-&gt;buffer
op_assign
id|kmalloc
c_func
(paren
id|cgc-&gt;buflen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cgc-&gt;buffer
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|usense
op_assign
id|cgc-&gt;sense
suffix:semicolon
id|cgc-&gt;sense
op_assign
op_amp
id|sense
suffix:semicolon
r_if
c_cond
(paren
id|usense
op_logical_and
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|usense
comma
r_sizeof
(paren
op_star
id|usense
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|cgc-&gt;data_direction
op_eq
id|CGC_DATA_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|ubuf
comma
id|cgc-&gt;buflen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cgc-&gt;data_direction
op_eq
id|CGC_DATA_WRITE
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|cgc-&gt;buffer
comma
id|ubuf
comma
id|cgc-&gt;buflen
)paren
)paren
(brace
id|kfree
c_func
(paren
id|cgc-&gt;buffer
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|cdi-&gt;ops
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
id|cgc
)paren
suffix:semicolon
id|__copy_to_user
c_func
(paren
id|usense
comma
id|cgc-&gt;sense
comma
r_sizeof
(paren
op_star
id|usense
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|cgc-&gt;data_direction
op_eq
id|CGC_DATA_READ
)paren
id|__copy_to_user
c_func
(paren
id|ubuf
comma
id|cgc-&gt;buffer
comma
id|cgc-&gt;buflen
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cgc-&gt;buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|mmc_ioctl
r_static
r_int
id|mmc_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|cdi-&gt;dev
suffix:semicolon
r_char
id|buffer
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cgc
comma
l_int|0
comma
r_sizeof
(paren
id|cgc
)paren
)paren
suffix:semicolon
multiline_comment|/* build a unified command and queue it through&n;&t;   cdo-&gt;generic_packet() */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMREADRAW
suffix:colon
r_case
id|CDROMREADMODE1
suffix:colon
r_case
id|CDROMREADMODE2
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|blocksize
op_assign
l_int|0
comma
id|format
op_assign
l_int|0
comma
id|lba
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMREADRAW
suffix:colon
id|blocksize
op_assign
id|CD_FRAMESIZE_RAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADMODE1
suffix:colon
id|blocksize
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|format
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADMODE2
suffix:colon
id|blocksize
op_assign
id|CD_FRAMESIZE_RAW0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_msf
comma
id|msf
)paren
suffix:semicolon
id|lba
op_assign
id|msf_to_lba
c_func
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
multiline_comment|/* FIXME: we need upper bound checking, too!! */
r_if
c_cond
(paren
id|lba
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cgc.buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|blocksize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cgc.buffer
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|cgc.data_direction
op_assign
id|CGC_DATA_READ
suffix:semicolon
id|ret
op_assign
id|cdrom_read_block
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|lba
comma
l_int|1
comma
id|format
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * SCSI-II devices are not required to support&n;&t;&t;&t; * READ_CD, so let&squot;s try switching block size&n;&t;&t;&t; */
multiline_comment|/* FIXME: switch back again... */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_switch_blocksize
c_func
(paren
id|cdi
comma
id|blocksize
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|cgc.buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|cgc.sense
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|cdrom_read_cd
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|lba
comma
id|blocksize
comma
l_int|1
)paren
suffix:semicolon
id|ret
op_or_assign
id|cdrom_switch_blocksize
c_func
(paren
id|cdi
comma
id|blocksize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
id|cgc.buffer
comma
id|blocksize
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree
c_func
(paren
id|cgc.buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_case
id|CDROMREADAUDIO
suffix:colon
(brace
r_struct
id|cdrom_read_audio
id|ra
suffix:semicolon
r_int
id|lba
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_read_audio
comma
id|ra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_MSF
)paren
id|lba
op_assign
id|msf_to_lba
c_func
(paren
id|ra.addr.msf.minute
comma
id|ra.addr.msf.second
comma
id|ra.addr.msf.frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_LBA
)paren
id|lba
op_assign
id|ra.addr.lba
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FIXME: we need upper bound checking, too!! */
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|ra.nframes
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cgc.buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|CD_FRAMESIZE_RAW
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|ra.buf
comma
id|ra.nframes
op_star
id|CD_FRAMESIZE_RAW
)paren
)paren
(brace
id|kfree
c_func
(paren
id|cgc.buffer
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|cgc.data_direction
op_assign
id|CGC_DATA_READ
suffix:semicolon
r_while
c_loop
(paren
id|ra.nframes
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|cdrom_read_block
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|lba
comma
l_int|1
comma
l_int|1
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
id|__copy_to_user
c_func
(paren
id|ra.buf
comma
id|cgc.buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
id|ra.buf
op_add_assign
id|CD_FRAMESIZE_RAW
suffix:semicolon
id|ra.nframes
op_decrement
suffix:semicolon
id|lba
op_increment
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|cgc.buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|cdrom_subchnl
id|q
suffix:semicolon
id|u_char
id|requested
comma
id|back
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_subchnl
comma
id|q
)paren
suffix:semicolon
id|requested
op_assign
id|q.cdsc_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q.cdsc_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_read_subchannel
c_func
(paren
id|cdi
comma
op_amp
id|q
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|back
op_assign
id|q.cdsc_format
suffix:semicolon
multiline_comment|/* local copy */
id|sanitize_format
c_func
(paren
op_amp
id|q.cdsc_absaddr
comma
op_amp
id|back
comma
id|requested
)paren
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|q.cdsc_reladdr
comma
op_amp
id|q.cdsc_format
comma
id|requested
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_subchnl
comma
id|q
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMSUBCHNL successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPLAYMSF&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_msf
comma
id|msf
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_PLAY_AUDIO_MSF
suffix:semicolon
id|cgc.cmd
(braket
l_int|3
)braket
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|cgc.cmd
(braket
l_int|5
)braket
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
id|cgc.cmd
(braket
l_int|6
)braket
op_assign
id|msf.cdmsf_min1
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
id|msf.cdmsf_sec1
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|msf.cdmsf_frame1
suffix:semicolon
id|cgc.data_direction
op_assign
id|CGC_DATA_NONE
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|CDROMPLAYBLK
suffix:colon
(brace
r_struct
id|cdrom_blk
id|blk
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPLAYBLK&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_blk
comma
id|blk
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_PLAY_AUDIO_10
suffix:semicolon
id|cgc.cmd
(braket
l_int|2
)braket
op_assign
(paren
id|blk.from
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|3
)braket
op_assign
(paren
id|blk.from
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
(paren
id|blk.from
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|5
)braket
op_assign
id|blk.from
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|7
)braket
op_assign
(paren
id|blk.len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|blk.len
op_amp
l_int|0xff
suffix:semicolon
id|cgc.data_direction
op_assign
id|CGC_DATA_NONE
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
r_case
id|CDROMVOLREAD
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_char
id|mask
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMVOLUME&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_volctrl
comma
id|volctrl
)paren
suffix:semicolon
id|cgc.buffer
op_assign
id|buffer
suffix:semicolon
id|cgc.buflen
op_assign
l_int|24
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_mode_sense
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|GPMODE_AUDIO_CTL_PAGE
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* some drives have longer pages, adjust and reread. */
r_if
c_cond
(paren
id|buffer
(braket
l_int|1
)braket
OG
id|cgc.buflen
)paren
(brace
id|cgc.buflen
op_assign
id|buffer
(braket
l_int|1
)braket
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_mode_sense
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|GPMODE_AUDIO_CTL_PAGE
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* get the offset from the length of the page. length&n;&t;&t;   is measure from byte 2 an on, thus the 14. */
id|offset
op_assign
id|buffer
(braket
l_int|1
)braket
op_minus
l_int|14
suffix:semicolon
multiline_comment|/* now we have the current volume settings. if it was only&n;&t;&t;   a CDROMVOLREAD, return these values */
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMVOLREAD
)paren
(brace
id|volctrl.channel0
op_assign
id|buffer
(braket
id|offset
op_plus
l_int|9
)braket
suffix:semicolon
id|volctrl.channel1
op_assign
id|buffer
(braket
id|offset
op_plus
l_int|11
)braket
suffix:semicolon
id|volctrl.channel2
op_assign
id|buffer
(braket
id|offset
op_plus
l_int|13
)braket
suffix:semicolon
id|volctrl.channel3
op_assign
id|buffer
(braket
id|offset
op_plus
l_int|15
)braket
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_volctrl
comma
id|volctrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get the volume mask */
id|cgc.buffer
op_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_mode_sense
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|GPMODE_AUDIO_CTL_PAGE
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|buffer
(braket
id|offset
op_plus
l_int|9
)braket
op_assign
id|volctrl.channel0
op_amp
id|mask
(braket
id|offset
op_plus
l_int|9
)braket
suffix:semicolon
id|buffer
(braket
id|offset
op_plus
l_int|11
)braket
op_assign
id|volctrl.channel1
op_amp
id|mask
(braket
id|offset
op_plus
l_int|11
)braket
suffix:semicolon
id|buffer
(braket
id|offset
op_plus
l_int|13
)braket
op_assign
id|volctrl.channel2
op_amp
id|mask
(braket
id|offset
op_plus
l_int|13
)braket
suffix:semicolon
id|buffer
(braket
id|offset
op_plus
l_int|15
)braket
op_assign
id|volctrl.channel3
op_amp
id|mask
(braket
id|offset
op_plus
l_int|15
)braket
suffix:semicolon
multiline_comment|/* set volume */
id|cgc.buffer
op_assign
id|buffer
suffix:semicolon
r_return
id|cdrom_mode_select
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|CDROMSTART
suffix:colon
r_case
id|CDROMSTOP
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMSTART/CDROMSTOP&bslash;n&quot;
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_START_STOP_UNIT
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
(paren
id|cmd
op_eq
id|CDROMSTART
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|cgc.data_direction
op_assign
id|CGC_DATA_NONE
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
r_case
id|CDROMRESUME
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPAUSE/CDROMRESUME&bslash;n&quot;
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_PAUSE_RESUME
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
(paren
id|cmd
op_eq
id|CDROMRESUME
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|cgc.data_direction
op_assign
id|CGC_DATA_NONE
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|DVD_READ_STRUCT
suffix:colon
(brace
id|dvd_struct
op_star
id|s
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
id|dvd_struct
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_DVD
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
(paren
id|dvd_struct
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering DVD_READ_STRUCT&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|s
comma
(paren
id|dvd_struct
op_star
)paren
id|arg
comma
id|size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dvd_read_struct
c_func
(paren
id|cdi
comma
id|s
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
id|dvd_struct
op_star
)paren
id|arg
comma
id|s
comma
id|size
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_case
id|DVD_AUTH
suffix:colon
(brace
id|dvd_authinfo
id|ai
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_DVD
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering DVD_AUTH&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|dvd_authinfo
comma
id|ai
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dvd_do_auth
(paren
id|cdi
comma
op_amp
id|ai
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|dvd_authinfo
comma
id|ai
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROM_SEND_PACKET
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_GENERIC_PACKET
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SEND_PACKET&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_generic_command
comma
id|cgc
)paren
suffix:semicolon
r_return
id|cdrom_do_cmd
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|CDROM_NEXT_WRITABLE
suffix:colon
(brace
r_int
id|next
op_assign
l_int|0
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_NEXT_WRITABLE&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_next_writable
c_func
(paren
id|dev
comma
op_amp
id|next
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_int
comma
id|next
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROM_LAST_WRITTEN
suffix:colon
(brace
r_int
id|last
op_assign
l_int|0
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_LAST_WRITTEN&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_last_written
c_func
(paren
id|dev
comma
op_amp
id|last
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_int
comma
id|last
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* switch */
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
DECL|function|cdrom_get_track_info
r_int
id|cdrom_get_track_info
c_func
(paren
id|kdev_t
id|dev
comma
id|__u16
id|track
comma
id|__u8
id|type
comma
id|track_information
op_star
id|ti
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|ti
comma
l_int|8
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_TRACK_RZONE_INFO
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
id|type
op_amp
l_int|3
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
(paren
id|track
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
id|cgc.cmd
(braket
l_int|5
)braket
op_assign
id|track
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|8
suffix:semicolon
id|cgc.quiet
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
op_assign
id|be16_to_cpu
c_func
(paren
id|ti-&gt;track_information_length
)paren
op_plus
r_sizeof
(paren
id|ti-&gt;track_information_length
)paren
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
multiline_comment|/* requires CD R/RW */
DECL|function|cdrom_get_disc_info
r_int
id|cdrom_get_disc_info
c_func
(paren
id|kdev_t
id|dev
comma
id|disc_information
op_star
id|di
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* set up command and get the disc info */
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|di
comma
r_sizeof
(paren
op_star
id|di
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DISC_INFO
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
op_assign
l_int|2
suffix:semicolon
id|cgc.quiet
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* not all drives have the same disc_info length, so requeue&n;&t; * packet with the length the drive tells us it can supply&n;&t; */
id|cgc.buflen
op_assign
id|be16_to_cpu
c_func
(paren
id|di-&gt;disc_information_length
)paren
op_plus
r_sizeof
(paren
id|di-&gt;disc_information_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cgc.buflen
OG
r_sizeof
(paren
id|disc_information
)paren
)paren
id|cgc.buflen
op_assign
r_sizeof
(paren
id|disc_information
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|generic_packet
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
multiline_comment|/* return the last written block on the CD-R media. this is for the udf&n;   file system. */
DECL|function|cdrom_get_last_written
r_int
id|cdrom_get_last_written
c_func
(paren
id|kdev_t
id|dev
comma
r_int
op_star
id|last_written
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_tocentry
id|toc
suffix:semicolon
id|disc_information
id|di
suffix:semicolon
id|track_information
id|ti
suffix:semicolon
id|__u32
id|last_track
suffix:semicolon
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_GENERIC_PACKET
)paren
)paren
r_goto
id|use_toc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_disc_info
c_func
(paren
id|dev
comma
op_amp
id|di
)paren
)paren
)paren
r_goto
id|use_toc
suffix:semicolon
id|last_track
op_assign
(paren
id|di.last_track_msb
op_lshift
l_int|8
)paren
op_or
id|di.last_track_lsb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_track_info
c_func
(paren
id|dev
comma
id|last_track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
r_goto
id|use_toc
suffix:semicolon
multiline_comment|/* if this track is blank, try the previous. */
r_if
c_cond
(paren
id|ti.blank
)paren
(brace
id|last_track
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_track_info
c_func
(paren
id|dev
comma
id|last_track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
r_goto
id|use_toc
suffix:semicolon
)brace
multiline_comment|/* if last recorded field is valid, return it. */
r_if
c_cond
(paren
id|ti.lra_v
)paren
(brace
op_star
id|last_written
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.last_rec_address
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make it up instead */
op_star
id|last_written
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.track_start
)paren
op_plus
id|be32_to_cpu
c_func
(paren
id|ti.track_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.free_blocks
)paren
op_star
id|last_written
op_sub_assign
(paren
id|be32_to_cpu
c_func
(paren
id|ti.free_blocks
)paren
op_plus
l_int|7
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* this is where we end up if the drive either can&squot;t do a&n;&t;   GPCMD_READ_DISC_INFO or GPCMD_READ_TRACK_RZONE_INFO or if&n;&t;   it fails. then we return the toc contents. */
id|use_toc
suffix:colon
id|toc.cdte_format
op_assign
id|CDROM_MSF
suffix:semicolon
id|toc.cdte_track
op_assign
id|CDROM_LEADOUT
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;ops
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|CDROMREADTOCENTRY
comma
op_amp
id|toc
)paren
)paren
r_return
id|ret
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|toc.cdte_addr
comma
op_amp
id|toc.cdte_format
comma
id|CDROM_LBA
)paren
suffix:semicolon
op_star
id|last_written
op_assign
id|toc.cdte_addr.lba
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return the next writable block. also for udf file system. */
DECL|function|cdrom_get_next_writable
r_int
id|cdrom_get_next_writable
c_func
(paren
id|kdev_t
id|dev
comma
r_int
op_star
id|next_writable
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|disc_information
id|di
suffix:semicolon
id|track_information
id|ti
suffix:semicolon
id|__u16
id|last_track
suffix:semicolon
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CAN
c_func
(paren
id|CDC_GENERIC_PACKET
)paren
)paren
r_goto
id|use_last_written
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_disc_info
c_func
(paren
id|dev
comma
op_amp
id|di
)paren
)paren
)paren
r_goto
id|use_last_written
suffix:semicolon
id|last_track
op_assign
(paren
id|di.last_track_msb
op_lshift
l_int|8
)paren
op_or
id|di.last_track_lsb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_track_info
c_func
(paren
id|dev
comma
id|last_track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
r_goto
id|use_last_written
suffix:semicolon
multiline_comment|/* if this track is blank, try the previous. */
r_if
c_cond
(paren
id|ti.blank
)paren
(brace
id|last_track
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_track_info
c_func
(paren
id|dev
comma
id|last_track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
r_goto
id|use_last_written
suffix:semicolon
)brace
multiline_comment|/* if next recordable address field is valid, use it. */
r_if
c_cond
(paren
id|ti.nwa_v
)paren
op_star
id|next_writable
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.next_writable
)paren
suffix:semicolon
r_else
r_goto
id|use_last_written
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|use_last_written
suffix:colon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_get_last_written
c_func
(paren
id|dev
comma
id|next_writable
)paren
)paren
)paren
(brace
op_star
id|next_writable
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
op_star
id|next_writable
op_add_assign
l_int|7
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|cdrom_get_disc_info
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_get_disc_info
)paren
suffix:semicolon
DECL|variable|cdrom_get_track_info
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_get_track_info
)paren
suffix:semicolon
DECL|variable|cdrom_get_next_writable
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_get_next_writable
)paren
suffix:semicolon
DECL|variable|cdrom_get_last_written
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_get_last_written
)paren
suffix:semicolon
DECL|variable|cdrom_count_tracks
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_count_tracks
)paren
suffix:semicolon
DECL|variable|register_cdrom
id|EXPORT_SYMBOL
c_func
(paren
id|register_cdrom
)paren
suffix:semicolon
DECL|variable|unregister_cdrom
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_cdrom
)paren
suffix:semicolon
DECL|variable|cdrom_fops
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_fops
)paren
suffix:semicolon
DECL|variable|cdrom_number_of_slots
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_number_of_slots
)paren
suffix:semicolon
DECL|variable|cdrom_select_disc
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_select_disc
)paren
suffix:semicolon
DECL|variable|cdrom_mode_select
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_mode_select
)paren
suffix:semicolon
DECL|variable|cdrom_mode_sense
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_mode_sense
)paren
suffix:semicolon
DECL|variable|init_cdrom_command
id|EXPORT_SYMBOL
c_func
(paren
id|init_cdrom_command
)paren
suffix:semicolon
DECL|variable|cdrom_find_device
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_find_device
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
DECL|macro|CDROM_STR_SIZE
mdefine_line|#define CDROM_STR_SIZE 1000
DECL|struct|cdrom_sysctl_settings
r_struct
id|cdrom_sysctl_settings
(brace
DECL|member|info
r_char
id|info
(braket
id|CDROM_STR_SIZE
)braket
suffix:semicolon
multiline_comment|/* general info */
DECL|member|autoclose
r_int
id|autoclose
suffix:semicolon
multiline_comment|/* close tray upon mount, etc */
DECL|member|autoeject
r_int
id|autoeject
suffix:semicolon
multiline_comment|/* eject on umount */
DECL|member|debug
r_int
id|debug
suffix:semicolon
multiline_comment|/* turn on debugging messages */
DECL|member|lock
r_int
id|lock
suffix:semicolon
multiline_comment|/* lock the door on device open */
DECL|member|check
r_int
id|check
suffix:semicolon
multiline_comment|/* check media type */
DECL|variable|cdrom_sysctl_settings
)brace
id|cdrom_sysctl_settings
suffix:semicolon
DECL|function|cdrom_sysctl_info
r_int
id|cdrom_sysctl_info
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|pos
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
suffix:semicolon
r_char
op_star
id|info
op_assign
id|cdrom_sysctl_settings.info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|lenp
op_logical_or
(paren
id|filp-&gt;f_pos
op_logical_and
op_logical_neg
id|write
)paren
)paren
(brace
op_star
id|lenp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pos
op_assign
id|sprintf
c_func
(paren
id|info
comma
l_string|&quot;CD-ROM information, &quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;ndrive name:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%s&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;ndrive speed:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|cdi-&gt;speed
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;ndrive # of slots:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|cdi-&gt;capacity
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan close tray:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_CLOSE_TRAY
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan open tray:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_OPEN_TRAY
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan lock tray:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan change speed:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_SPEED
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan select disk:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_SELECT_DISC
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan read multisession:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_MULTI_SESSION
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan read MCN:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_MCN
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nReports media changed:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_MEDIA_CHANGED
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan play audio:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_PLAY_AUDIO
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan write CD-R:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_CD_R
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan write CD-RW:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_CD_RW
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan read DVD:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_DVD
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan write DVD-R:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_DVD_R
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan write DVD-RAM:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|CDROM_CAN
c_func
(paren
id|CDC_DVD_RAM
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|info
op_plus
id|pos
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|proc_dostring
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
)brace
multiline_comment|/* Unfortunately, per device settings are not implemented through&n;   procfs/sysctl yet. When they are, this will naturally disappear. For now&n;   just update all drives. Later this will become the template on which&n;   new registered drives will be based. */
DECL|function|cdrom_update_settings
r_void
id|cdrom_update_settings
c_func
(paren
r_void
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|autoclose
op_logical_and
id|CDROM_CAN
c_func
(paren
id|CDC_CLOSE_TRAY
)paren
)paren
id|cdi-&gt;options
op_or_assign
id|CDO_AUTO_CLOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|autoclose
)paren
id|cdi-&gt;options
op_and_assign
op_complement
id|CDO_AUTO_CLOSE
suffix:semicolon
r_if
c_cond
(paren
id|autoeject
op_logical_and
id|CDROM_CAN
c_func
(paren
id|CDC_OPEN_TRAY
)paren
)paren
id|cdi-&gt;options
op_or_assign
id|CDO_AUTO_EJECT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|autoeject
)paren
id|cdi-&gt;options
op_and_assign
op_complement
id|CDO_AUTO_EJECT
suffix:semicolon
r_if
c_cond
(paren
id|lockdoor
op_logical_and
id|CDROM_CAN
c_func
(paren
id|CDC_LOCK
)paren
)paren
id|cdi-&gt;options
op_or_assign
id|CDO_LOCK
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|lockdoor
)paren
id|cdi-&gt;options
op_and_assign
op_complement
id|CDO_LOCK
suffix:semicolon
r_if
c_cond
(paren
id|check_media_type
)paren
id|cdi-&gt;options
op_or_assign
id|CDO_CHECK_TYPE
suffix:semicolon
r_else
id|cdi-&gt;options
op_and_assign
op_complement
id|CDO_CHECK_TYPE
suffix:semicolon
)brace
)brace
DECL|function|cdrom_sysctl_handler
r_static
r_int
id|cdrom_sysctl_handler
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
op_star
id|valp
op_assign
id|ctl-&gt;data
suffix:semicolon
r_int
id|val
op_assign
op_star
id|valp
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|proc_dointvec
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
op_logical_and
op_star
id|valp
op_ne
id|val
)paren
(brace
multiline_comment|/* we only care for 1 or 0. */
r_if
c_cond
(paren
op_star
id|valp
)paren
op_star
id|valp
op_assign
l_int|1
suffix:semicolon
r_else
op_star
id|valp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ctl-&gt;ctl_name
)paren
(brace
r_case
id|DEV_CDROM_AUTOCLOSE
suffix:colon
(brace
r_if
c_cond
(paren
id|valp
op_eq
op_amp
id|cdrom_sysctl_settings.autoclose
)paren
id|autoclose
op_assign
id|cdrom_sysctl_settings.autoclose
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|DEV_CDROM_AUTOEJECT
suffix:colon
(brace
r_if
c_cond
(paren
id|valp
op_eq
op_amp
id|cdrom_sysctl_settings.autoeject
)paren
id|autoeject
op_assign
id|cdrom_sysctl_settings.autoeject
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|DEV_CDROM_DEBUG
suffix:colon
(brace
r_if
c_cond
(paren
id|valp
op_eq
op_amp
id|cdrom_sysctl_settings.debug
)paren
id|debug
op_assign
id|cdrom_sysctl_settings.debug
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|DEV_CDROM_LOCK
suffix:colon
(brace
r_if
c_cond
(paren
id|valp
op_eq
op_amp
id|cdrom_sysctl_settings.lock
)paren
id|lockdoor
op_assign
id|cdrom_sysctl_settings.lock
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|DEV_CDROM_CHECK_MEDIA
suffix:colon
(brace
r_if
c_cond
(paren
id|valp
op_eq
op_amp
id|cdrom_sysctl_settings.check
)paren
id|check_media_type
op_assign
id|cdrom_sysctl_settings.check
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* update the option flags according to the changes. we&n;&t;&t;   don&squot;t have per device options through sysctl yet,&n;&t;&t;   but we will have and then this will disappear. */
id|cdrom_update_settings
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Place files in /proc/sys/dev/cdrom */
DECL|variable|cdrom_table
id|ctl_table
id|cdrom_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_CDROM_INFO
comma
l_string|&quot;info&quot;
comma
op_amp
id|cdrom_sysctl_settings.info
comma
id|CDROM_STR_SIZE
comma
l_int|0444
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_info
)brace
comma
(brace
id|DEV_CDROM_AUTOCLOSE
comma
l_string|&quot;autoclose&quot;
comma
op_amp
id|cdrom_sysctl_settings.autoclose
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_handler
)brace
comma
(brace
id|DEV_CDROM_AUTOEJECT
comma
l_string|&quot;autoeject&quot;
comma
op_amp
id|cdrom_sysctl_settings.autoeject
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_handler
)brace
comma
(brace
id|DEV_CDROM_DEBUG
comma
l_string|&quot;debug&quot;
comma
op_amp
id|cdrom_sysctl_settings.debug
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_handler
)brace
comma
(brace
id|DEV_CDROM_LOCK
comma
l_string|&quot;lock&quot;
comma
op_amp
id|cdrom_sysctl_settings.lock
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_handler
)brace
comma
(brace
id|DEV_CDROM_CHECK_MEDIA
comma
l_string|&quot;check_media&quot;
comma
op_amp
id|cdrom_sysctl_settings.check
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_handler
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|cdrom_cdrom_table
id|ctl_table
id|cdrom_cdrom_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_CDROM
comma
l_string|&quot;cdrom&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|cdrom_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Make sure that /proc/sys/dev is there */
DECL|variable|cdrom_root_table
id|ctl_table
id|cdrom_root_table
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_PROC_FS
(brace
id|CTL_DEV
comma
l_string|&quot;dev&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|cdrom_cdrom_table
)brace
comma
macro_line|#endif /* CONFIG_PROC_FS */
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|cdrom_sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|cdrom_sysctl_header
suffix:semicolon
DECL|function|cdrom_sysctl_register
r_static
r_void
id|cdrom_sysctl_register
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|initialized
suffix:semicolon
r_if
c_cond
(paren
id|initialized
op_eq
l_int|1
)paren
r_return
suffix:semicolon
id|cdrom_sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|cdrom_root_table
comma
l_int|1
)paren
suffix:semicolon
id|cdrom_root_table-&gt;child-&gt;de-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
multiline_comment|/* set the defaults */
id|cdrom_sysctl_settings.autoclose
op_assign
id|autoclose
suffix:semicolon
id|cdrom_sysctl_settings.autoeject
op_assign
id|autoeject
suffix:semicolon
id|cdrom_sysctl_settings.debug
op_assign
id|debug
suffix:semicolon
id|cdrom_sysctl_settings.lock
op_assign
id|lockdoor
suffix:semicolon
id|cdrom_sysctl_settings.check
op_assign
id|check_media_type
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|cdrom_sysctl_unregister
r_static
r_void
id|cdrom_sysctl_unregister
c_func
(paren
r_void
)paren
(brace
id|unregister_sysctl_table
c_func
(paren
id|cdrom_sysctl_header
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SYSCTL */
DECL|function|cdrom_init
r_static
r_int
id|__init
id|cdrom_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SYSCTL
id|cdrom_sysctl_register
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|devfs_handle
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|NULL
comma
l_string|&quot;cdroms&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdrom_exit
r_static
r_void
id|__exit
id|cdrom_exit
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Uniform CD-ROM driver unloaded&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|cdrom_sysctl_unregister
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|devfs_unregister
c_func
(paren
id|devfs_handle
)paren
suffix:semicolon
)brace
DECL|variable|cdrom_init
id|module_init
c_func
(paren
id|cdrom_init
)paren
suffix:semicolon
DECL|variable|cdrom_exit
id|module_exit
c_func
(paren
id|cdrom_exit
)paren
suffix:semicolon
eof
