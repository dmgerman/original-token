multiline_comment|/* linux/drivers/cdrom/cdrom.c. &n;   Copyright (c) 1996, 1997 David A. van Leeuwen.&n;   Copyright (c) 1997, 1998 Erik Andersen &lt;andersee@debian.org&gt;&n;   Copyright (c) 1998 Jens Axboe and Chris Zwilling&n;&n;   May be copied or modified under the terms of the GNU General Public&n;   License.  See linux/COPYING for more information.&n;&n;   Uniform CD-ROM driver for Linux.&n;   See Documentation/cdrom/cdrom-standard.tex for usage information.&n;&n;   The routines in the file provide a uniform interface between the&n;   software that uses CD-ROMs and the various low-level drivers that&n;   actually talk to the hardware. Suggestions are welcome.&n;   Patches that work are more welcome though.  ;-)&n;&n; To Do List:&n; ----------------------------------&n;&n; -- Modify sysctl/proc interface. I plan on having one directory per&n; drive, with entries for outputing general drive information, and sysctl&n; based tunable parameters such as whether the tray should auto-close for&n; that drive. Suggestions (or patches) for this welcome!&n;&n; -- Change the CDROMREADMODE1, CDROMREADMODE2, CDROMREADAUDIO, and &n; CDROMREADRAW ioctls so they go through the Uniform CD-ROM driver.&n;&n;&n;&n;&n; Revision History&n; ----------------------------------&n; 1.00  Date Unknown -- David van Leeuwen &lt;david@tm.tno.nl&gt;&n; -- Initial version by David A. van Leeuwen. I don&squot;t have a detailed&n;  changelog for the 1.x series, David?&n;&n;2.00  Dec  2, 1997 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- New maintainer! As David A. van Leeuwen has been too busy to activly&n;  maintain and improve this driver, I am now carrying on the torch. If&n;  you have a problem with this driver, please feel free to contact me.&n;&n;  -- Added (rudimentary) sysctl interface. I realize this is really weak&n;  right now, and is _very_ badly implemented. It will be improved...&n;&n;  -- Modified CDROM_DISC_STATUS so that it is now incorporated into&n;  the Uniform CD-ROM driver via the cdrom_count_tracks function.&n;  The cdrom_count_tracks function helps resolve some of the false&n;  assumptions of the CDROM_DISC_STATUS ioctl, and is also used to check&n;  for the correct media type when mounting or playing audio from a CD.&n;&n;  -- Remove the calls to verify_area and only use the copy_from_user and&n;  copy_to_user stuff, since these calls now provide their own memory&n;  checking with the 2.1.x kernels.&n;&n;  -- Major update to return codes so that errors from low-level drivers&n;  are passed on through (thanks to Gerd Knorr for pointing out this&n;  problem).&n;&n;  -- Made it so if a function isn&squot;t implemented in a low-level driver,&n;  ENOSYS is now returned instead of EINVAL.&n;&n;  -- Simplified some complex logic so that the source code is easier to read.&n;&n;  -- Other stuff I probably forgot to mention (lots of changes).&n;&n;2.01 to 2.11 Dec 1997-Jan 1998&n;  -- TO-DO!  Write changelogs for 2.01 to 2.12.&n;&n;2.12  Jan  24, 1998 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- Fixed a bug in the IOCTL_IN and IOCTL_OUT macros.  It turns out that&n;  copy_*_user does not return EFAULT on error, but instead returns the number &n;  of bytes not copied.  I was returning whatever non-zero stuff came back from &n;  the copy_*_user functions directly, which would result in strange errors.&n;&n;2.13  July 17, 1998 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- Fixed a bug in CDROM_SELECT_SPEED where you couldn&squot;t lower the speed&n;  of the drive.  Thanks to Tobias Ringstr|m &lt;tori@prosolvia.se&gt; for pointing&n;  this out and providing a simple fix.&n;  -- Fixed the procfs-unload-module bug with the fill_inode procfs callback.&n;  thanks to Andrea Arcangeli&n;  -- Fixed it so that the /proc entry now also shows up when cdrom is&n;  compiled into the kernel.  Before it only worked when loaded as a module.&n;&n;  2.14 August 17, 1998 -- Erik Andersen &lt;andersee@debian.org&gt;&n;  -- Fixed a bug in cdrom_media_changed and handling of reporting that&n;  the media had changed for devices that _don&squot;t_ implement media_changed.  &n;  Thanks to Grant R. Guenther &lt;grant@torque.net&gt; for spotting this bug.&n;  -- Made a few things more pedanticly correct.&n;&n;2.50 Oct 19, 1998 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- New maintainers! Erik was too busy to continue the work on the driver,&n;  so now Chris Zwilling &lt;chris@cloudnet.com&gt; and Jens Axboe &lt;axboe@image.dk&gt;&n;  will do their best to follow in his footsteps&n;  &n;  2.51 Dec 20, 1998 - Jens Axboe &lt;axboe@image.dk&gt;&n;  -- Check if drive is capable of doing what we ask before blindly changing&n;  cdi-&gt;options in various ioctl.&n;  -- Added version to proc entry.&n;&n;-------------------------------------------------------------------------*/
DECL|macro|REVISION
mdefine_line|#define REVISION &quot;Revision: 2.51&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;Id: cdrom.c 2.51 1998/12/20&quot;
multiline_comment|/* I use an error-log mask to give fine grain control over the type of&n;   messages dumped to the system logs.  The available masks include: */
DECL|macro|CD_NOTHING
mdefine_line|#define CD_NOTHING      0x0
DECL|macro|CD_WARNING
mdefine_line|#define CD_WARNING&t;0x1
DECL|macro|CD_REG_UNREG
mdefine_line|#define CD_REG_UNREG&t;0x2
DECL|macro|CD_DO_IOCTL
mdefine_line|#define CD_DO_IOCTL&t;0x4
DECL|macro|CD_OPEN
mdefine_line|#define CD_OPEN&t;&t;0x8
DECL|macro|CD_CLOSE
mdefine_line|#define CD_CLOSE&t;0x10
DECL|macro|CD_COUNT_TRACKS
mdefine_line|#define CD_COUNT_TRACKS 0x20
multiline_comment|/* Define this to remove _all_ the debugging messages */
multiline_comment|/* #define ERRLOGMASK CD_NOTHING */
DECL|macro|ERRLOGMASK
mdefine_line|#define ERRLOGMASK (CD_WARNING)
multiline_comment|/* #define ERRLOGMASK (CD_WARNING|CD_OPEN|CD_COUNT_TRACKS|CD_CLOSE) */
multiline_comment|/* #define ERRLOGMASK (CD_WARNING|CD_REG_UNREG|CD_DO_IOCTL|CD_OPEN|CD_CLOSE|CD_COUNT_TRACKS) */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt; 
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/fcntl.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* used to tell the module to turn on full debugging messages */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default compatibility mode */
DECL|variable|autoclose
r_static
r_int
id|autoclose
op_assign
l_int|1
suffix:semicolon
DECL|variable|autoeject
r_static
r_int
id|autoeject
op_assign
l_int|0
suffix:semicolon
DECL|variable|lockdoor
r_static
r_int
id|lockdoor
op_assign
l_int|1
suffix:semicolon
DECL|variable|check_media_type
r_static
r_int
id|check_media_type
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|autoclose
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|autoeject
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|lockdoor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|check_media_type
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#if (ERRLOGMASK!=CD_NOTHING)
DECL|macro|cdinfo
mdefine_line|#define cdinfo(type, fmt, args...) &bslash;&n;        if ((ERRLOGMASK &amp; type) || debug==1 ) &bslash;&n;            printk(KERN_INFO &quot;cdrom: &quot; fmt, ## args)
macro_line|#else
DECL|macro|cdinfo
mdefine_line|#define cdinfo(type, fmt, args...) 
macro_line|#endif
multiline_comment|/* These are used to simplify getting data in from and back to user land */
DECL|macro|IOCTL_IN
mdefine_line|#define IOCTL_IN(arg, type, in) { &bslash;&n;            if ( copy_from_user(&amp;in, (type *) arg, sizeof in) ) &bslash;&n;            &t;return -EFAULT; }
DECL|macro|IOCTL_OUT
mdefine_line|#define IOCTL_OUT(arg, type, out) { &bslash;&n;            if ( copy_to_user((type *) arg, &amp;out, sizeof out) ) &bslash;&n;            &t;return -EFAULT; }
DECL|macro|FM_WRITE
mdefine_line|#define FM_WRITE&t;0x2                 /* file mode write bit */
multiline_comment|/* Not-exported routines. */
r_static
r_int
id|cdrom_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
suffix:semicolon
r_static
r_int
id|cdrom_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
suffix:semicolon
r_static
r_int
id|cdrom_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|cdrom_media_changed
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_int
id|open_for_data
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
suffix:semicolon
r_static
r_int
id|check_for_audio_disc
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_device_ops
op_star
id|cdo
)paren
suffix:semicolon
r_static
r_void
id|sanitize_format
c_func
(paren
r_union
id|cdrom_addr
op_star
id|addr
comma
id|u_char
op_star
id|curr
comma
id|u_char
id|requested
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
r_static
r_void
id|cdrom_sysctl_register
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */ 
DECL|variable|topCdromPtr
r_static
r_struct
id|cdrom_device_info
op_star
id|topCdromPtr
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|cdrom_fops
r_struct
id|file_operations
id|cdrom_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* poll */
id|cdrom_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|cdrom_open
comma
multiline_comment|/* open */
l_int|NULL
comma
multiline_comment|/* flush */
id|cdrom_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|cdrom_media_changed
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/* This macro makes sure we don&squot;t have to check on cdrom_device_ops&n; * existence in the run-time routines below. Change_capability is a&n; * hack to have the capability flags defined const, while we can still&n; * change it here without gcc complaining at every line.&n; */
DECL|macro|ENSURE
mdefine_line|#define ENSURE(call, bits) if (cdo-&gt;call == NULL) *change_capability &amp;= ~(bits)
DECL|function|register_cdrom
r_int
id|register_cdrom
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_static
r_char
id|banner_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|major
op_assign
id|MAJOR
(paren
id|cdi-&gt;dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_int
op_star
id|change_capability
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cdo-&gt;capability
suffix:semicolon
multiline_comment|/* hack */
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering register_cdrom&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;open
op_eq
l_int|NULL
op_logical_or
id|cdo-&gt;release
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|banner_printed
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Uniform CDROM driver &quot;
id|REVISION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|banner_printed
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|cdrom_sysctl_register
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */ 
)brace
id|ENSURE
c_func
(paren
id|drive_status
comma
id|CDC_DRIVE_STATUS
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|media_changed
comma
id|CDC_MEDIA_CHANGED
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|tray_move
comma
id|CDC_CLOSE_TRAY
op_or
id|CDC_OPEN_TRAY
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|lock_door
comma
id|CDC_LOCK
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|select_speed
comma
id|CDC_SELECT_SPEED
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|select_disc
comma
id|CDC_SELECT_DISC
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|get_last_session
comma
id|CDC_MULTI_SESSION
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|get_mcn
comma
id|CDC_MCN
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|reset
comma
id|CDC_RESET
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|audio_ioctl
comma
id|CDC_PLAY_AUDIO
)paren
suffix:semicolon
id|ENSURE
c_func
(paren
id|dev_ioctl
comma
id|CDC_IOCTLS
)paren
suffix:semicolon
id|cdi-&gt;mc_flags
op_assign
l_int|0
suffix:semicolon
id|cdo-&gt;n_minors
op_assign
l_int|0
suffix:semicolon
id|cdi-&gt;options
op_assign
id|CDO_USE_FFLAGS
suffix:semicolon
r_if
c_cond
(paren
id|autoclose
op_eq
l_int|1
op_logical_and
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_OPEN_TRAY
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_AUTO_CLOSE
suffix:semicolon
r_if
c_cond
(paren
id|autoeject
op_eq
l_int|1
op_logical_and
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_OPEN_TRAY
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_AUTO_EJECT
suffix:semicolon
r_if
c_cond
(paren
id|lockdoor
op_eq
l_int|1
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_LOCK
suffix:semicolon
r_if
c_cond
(paren
id|check_media_type
op_eq
l_int|1
)paren
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|CDO_CHECK_TYPE
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_REG_UNREG
comma
l_string|&quot;drive &bslash;&quot;/dev/%s&bslash;&quot; registered&bslash;n&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
id|cdi-&gt;next
op_assign
id|topCdromPtr
suffix:semicolon
id|topCdromPtr
op_assign
id|cdi
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|ENSURE
macro_line|#undef ENSURE
DECL|function|unregister_cdrom
r_int
id|unregister_cdrom
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|unreg
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
op_star
id|prev
suffix:semicolon
r_int
id|major
op_assign
id|MAJOR
(paren
id|unreg-&gt;dev
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering unregister_cdrom&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
r_while
c_loop
(paren
id|cdi
op_ne
l_int|NULL
op_logical_and
id|cdi-&gt;dev
op_ne
id|unreg-&gt;dev
)paren
(brace
id|prev
op_assign
id|cdi
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|cdi-&gt;next
suffix:semicolon
r_else
id|topCdromPtr
op_assign
id|cdi-&gt;next
suffix:semicolon
id|cdi-&gt;ops-&gt;n_minors
op_decrement
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_REG_UNREG
comma
l_string|&quot;drive &bslash;&quot;/dev/%s&bslash;&quot; unregistered&bslash;n&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|cdrom_find_device
r_struct
id|cdrom_device_info
op_star
id|cdrom_find_device
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
suffix:semicolon
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
r_while
c_loop
(paren
id|cdi
op_ne
l_int|NULL
op_logical_and
id|cdi-&gt;dev
op_ne
id|dev
)paren
id|cdi
op_assign
id|cdi-&gt;next
suffix:semicolon
r_return
id|cdi
suffix:semicolon
)brace
multiline_comment|/* We use the open-option O_NONBLOCK to indicate that the&n; * purpose of opening is only for subsequent ioctl() calls; no device&n; * integrity checks are performed.&n; *&n; * We hope that all cd-player programs will adopt this convention. It&n; * is in their own interest: device control becomes a lot easier&n; * this way.&n; */
r_static
DECL|function|cdrom_open
r_int
id|cdrom_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
id|kdev_t
id|dev
op_assign
id|ip-&gt;i_rdev
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|purpose
op_assign
op_logical_neg
op_logical_neg
(paren
id|fp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering cdrom_open&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
id|FM_WRITE
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|purpose
op_assign
id|purpose
op_logical_or
op_logical_neg
(paren
id|cdi-&gt;options
op_amp
id|CDO_USE_FFLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_logical_or
id|purpose
)paren
id|ret
op_assign
id|cdi-&gt;ops
op_member_access_from_pointer
id|open
c_func
(paren
id|cdi
comma
id|purpose
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|open_for_data
c_func
(paren
id|cdi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|cdi-&gt;use_count
op_increment
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;Use count for &bslash;&quot;/dev/%s&bslash;&quot; now %d&bslash;n&quot;
comma
id|cdi-&gt;name
comma
id|cdi-&gt;use_count
)paren
suffix:semicolon
multiline_comment|/* Do this on open.  Don&squot;t wait for mount, because they might&n;&t;    not be mounting, but opening with O_NONBLOCK */
id|check_disk_change
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
DECL|function|open_for_data
r_int
id|open_for_data
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
id|tracktype
id|tracks
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering open_for_data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if the driver can report drive status.  If it can, we&n;&t;   can do clever things.  If it can&squot;t, well, we at least tried! */
r_if
c_cond
(paren
id|cdo-&gt;drive_status
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;drive_status=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is open...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* can/may i close it? */
r_if
c_cond
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_CLOSE_TRAY
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_AUTO_CLOSE
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;trying to close the tray.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. tried to close the tray but failed.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Ignore the error from the low&n;&t;&t;&t;&t;&t;level driver.  We don&squot;t care why it&n;&t;&t;&t;&t;&t;couldn&squot;t close the tray.  We only care &n;&t;&t;&t;&t;&t;that there is no disc in the drive, &n;&t;&t;&t;&t;&t;since that is the _REAL_ problem here.*/
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. this driver can&squot;t close the tray.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
multiline_comment|/* Ok, the door should be closed now.. Check again */
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
id|CDS_NO_DISC
)paren
op_logical_or
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. the tray is still not closed.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is now closed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|CDS_DISC_OK
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
)brace
id|cdrom_count_tracks
c_func
(paren
id|cdi
comma
op_amp
id|tracks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tracks.error
op_eq
id|CDS_NO_DISC
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. no disc.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
multiline_comment|/* CD-Players which don&squot;t use O_NONBLOCK, workman&n;&t; * for example, need bit CDO_CHECK_TYPE cleared! */
r_if
c_cond
(paren
id|tracks.data
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cdi-&gt;options
op_amp
id|CDO_CHECK_TYPE
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. wrong media type.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EMEDIUMTYPE
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
r_else
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;wrong media type, but CDO_CHECK_TYPE not set.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;all seems well, opening the device.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* all seems well, we can open the device */
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|open
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* open for data */
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;opening the device gave me %d.&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* After all this careful checking, we shouldn&squot;t have problems&n;&t;   opening the device, but we don&squot;t want the device locked if &n;&t;   this somehow fails... */
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;open device failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|clean_up_and_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_LOCK
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_LOCK
)paren
(brace
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;door locked.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;device opened successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
multiline_comment|/* Something failed.  Try to unlock the drive, because some drivers&n;&t;(notably ide-cd) lock the drive after every command.  This produced&n;&t;a nasty bug where after mount failed, the drive would remain locked!  &n;&t;This ensures that the drive gets unlocked after a mount fails.  This &n;&t;is a goto to avoid bloating the driver with redundant code. */
id|clean_up_and_return
suffix:colon
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;open failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_LOCK
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_LOCK
)paren
(brace
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;door unlocked.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This code is similar to that in open_for_data. The routine is called&n;   whenever an audio play operation is requested.&n;*/
DECL|function|check_for_audio_disc
r_int
id|check_for_audio_disc
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_device_ops
op_star
id|cdo
)paren
(brace
r_int
id|ret
suffix:semicolon
id|tracktype
id|tracks
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;entering check_for_audio_disc&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdi-&gt;options
op_amp
id|CDO_CHECK_TYPE
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;drive_status
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;drive_status=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is open...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* can/may i close it? */
r_if
c_cond
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_CLOSE_TRAY
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_AUTO_CLOSE
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;trying to close the tray.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. tried to close tray but failed.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Ignore the error from the low&n;&t;&t;&t;&t;&t;level driver.  We don&squot;t care why it&n;&t;&t;&t;&t;&t;couldn&squot;t close the tray.  We only care &n;&t;&t;&t;&t;&t;that there is no disc in the drive, &n;&t;&t;&t;&t;&t;since that is the _REAL_ problem here.*/
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
)brace
)brace
r_else
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. this driver can&squot;t close the tray.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
)brace
multiline_comment|/* Ok, the door should be closed now.. Check again */
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
id|CDS_NO_DISC
)paren
op_logical_or
(paren
id|ret
op_eq
id|CDS_TRAY_OPEN
)paren
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. the tray is still not closed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|CDS_DISC_OK
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;bummer. disc isn&squot;t ready.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_OPEN
comma
l_string|&quot;the tray is now closed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|cdrom_count_tracks
c_func
(paren
id|cdi
comma
op_amp
id|tracks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tracks.error
)paren
r_return
id|tracks.error
suffix:semicolon
r_if
c_cond
(paren
id|tracks.audio
op_eq
l_int|0
)paren
r_return
op_minus
id|EMEDIUMTYPE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Admittedly, the logic below could be performed in a nicer way. */
r_static
DECL|function|cdrom_release
r_int
id|cdrom_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
id|kdev_t
id|dev
op_assign
id|ip-&gt;i_rdev
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
r_int
id|opened_for_data
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_CLOSE
comma
l_string|&quot;entering cdrom_release&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
OG
l_int|0
)paren
id|cdi-&gt;use_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_eq
l_int|0
)paren
id|cdinfo
c_func
(paren
id|CD_CLOSE
comma
l_string|&quot;Use count for &bslash;&quot;/dev/%s&bslash;&quot; now zero&bslash;n&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_eq
l_int|0
op_logical_and
multiline_comment|/* last process that closes dev*/
id|cdo-&gt;capability
op_amp
id|CDC_LOCK
)paren
(brace
id|cdinfo
c_func
(paren
id|CD_CLOSE
comma
l_string|&quot;Unlocking door!&bslash;n&quot;
)paren
suffix:semicolon
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
)brace
id|opened_for_data
op_assign
op_logical_neg
(paren
id|cdi-&gt;options
op_amp
id|CDO_USE_FFLAGS
)paren
op_logical_or
op_logical_neg
(paren
id|fp
op_logical_and
id|fp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|cdo
op_member_access_from_pointer
id|release
c_func
(paren
id|cdi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* last process that closes dev*/
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|sync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sb
op_assign
id|get_super
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opened_for_data
op_logical_and
id|cdi-&gt;options
op_amp
id|CDO_AUTO_EJECT
op_logical_and
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_OPEN_TRAY
)paren
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We want to make media_changed accessible to the user through an&n; * ioctl. The main problem now is that we must double-buffer the&n; * low-level implementation, to assure that the VFS and the user both&n; * see a medium change once.&n; */
r_static
DECL|function|media_changed
r_int
id|media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|queue
)paren
(brace
r_int
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
(paren
id|queue
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_int
id|ret
op_assign
op_logical_neg
op_logical_neg
(paren
id|cdi-&gt;mc_flags
op_amp
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_MEDIA_CHANGED
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* changed since last call? */
r_if
c_cond
(paren
id|cdi-&gt;ops
op_member_access_from_pointer
id|media_changed
c_func
(paren
id|cdi
comma
id|CDSL_CURRENT
)paren
)paren
(brace
id|cdi-&gt;mc_flags
op_assign
l_int|0x3
suffix:semicolon
multiline_comment|/* set bit on both queues */
id|ret
op_or_assign
l_int|1
suffix:semicolon
)brace
id|cdi-&gt;mc_flags
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/* clear bit */
r_return
id|ret
suffix:semicolon
)brace
r_static
DECL|function|cdrom_media_changed
r_int
id|cdrom_media_changed
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* This talks to the VFS, which doesn&squot;t like errors - just 1 or 0.  &n;&t; * Returning &quot;0&quot; is always safe (media hasn&squot;t been changed). Do that &n;&t; * if the low-level cdrom driver dosn&squot;t support media changed. */
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;ops-&gt;media_changed
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_MEDIA_CHANGED
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|media_changed
c_func
(paren
id|cdi
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|cdrom_count_tracks
r_void
id|cdrom_count_tracks
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
id|tracktype
op_star
id|tracks
)paren
(brace
r_struct
id|cdrom_tochdr
id|header
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
id|tracks-&gt;data
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;audio
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;cdi
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;xa
op_assign
l_int|0
suffix:semicolon
id|tracks-&gt;error
op_assign
l_int|0
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_COUNT_TRACKS
comma
l_string|&quot;entering cdrom_count_tracks&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_PLAY_AUDIO
)paren
)paren
(brace
id|tracks-&gt;error
op_assign
id|CDS_NO_INFO
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grab the TOC header so we can see how many tracks there are */
id|ret
op_assign
id|cdi-&gt;ops
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|CDROMREADTOCHDR
comma
op_amp
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|tracks-&gt;error
op_assign
(paren
id|ret
op_eq
op_minus
id|ENOMEDIUM
)paren
ques
c_cond
id|CDS_NO_DISC
suffix:colon
id|CDS_NO_INFO
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check what type of tracks are on this disc */
id|entry.cdte_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|header.cdth_trk0
suffix:semicolon
id|i
op_le
id|header.cdth_trk1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|entry.cdte_track
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;ops
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|CDROMREADTOCENTRY
comma
op_amp
id|entry
)paren
)paren
(brace
id|tracks-&gt;error
op_assign
id|CDS_NO_INFO
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry.cdte_ctrl
op_amp
id|CDROM_DATA_TRACK
)paren
(brace
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
l_int|0x10
)paren
id|tracks-&gt;cdi
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
l_int|0x20
)paren
id|tracks-&gt;xa
op_increment
suffix:semicolon
r_else
id|tracks-&gt;data
op_increment
suffix:semicolon
)brace
r_else
id|tracks-&gt;audio
op_increment
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_COUNT_TRACKS
comma
l_string|&quot;track %d: format=%d, ctrl=%d&bslash;n&quot;
comma
id|i
comma
id|entry.cdte_format
comma
id|entry.cdte_ctrl
)paren
suffix:semicolon
)brace
id|cdinfo
c_func
(paren
id|CD_COUNT_TRACKS
comma
l_string|&quot;disc has %d tracks: %d=audio %d=data %d=Cd-I %d=XA&bslash;n&quot;
comma
id|header.cdth_trk1
comma
id|tracks-&gt;audio
comma
id|tracks-&gt;data
comma
id|tracks-&gt;cdi
comma
id|tracks-&gt;xa
)paren
suffix:semicolon
)brace
multiline_comment|/* Requests to the low-level drivers will /always/ be done in the&n;   following format convention:&n;&n;   CDROM_LBA: all data-related requests.&n;   CDROM_MSF: all audio-related requests.&n;&n;   However, a low-level implementation is allowed to refuse this&n;   request, and return information in its own favorite format.&n;&n;   It doesn&squot;t make sense /at all/ to ask for a play_audio in LBA&n;   format, or ask for multi-session info in MSF format. However, for&n;   backward compatibility these format requests will be satisfied, but&n;   the requests to the low-level drivers will be sanitized in the more&n;   meaningful format indicated above.&n; */
r_static
DECL|function|sanitize_format
r_void
id|sanitize_format
c_func
(paren
r_union
id|cdrom_addr
op_star
id|addr
comma
id|u_char
op_star
id|curr
comma
id|u_char
id|requested
)paren
(brace
r_if
c_cond
(paren
op_star
id|curr
op_eq
id|requested
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing to be done! */
r_if
c_cond
(paren
id|requested
op_eq
id|CDROM_LBA
)paren
(brace
id|addr-&gt;lba
op_assign
(paren
r_int
)paren
id|addr-&gt;msf.frame
op_plus
l_int|75
op_star
(paren
id|addr-&gt;msf.second
op_minus
l_int|2
op_plus
l_int|60
op_star
id|addr-&gt;msf.minute
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* CDROM_MSF */
r_int
id|lba
op_assign
id|addr-&gt;lba
suffix:semicolon
id|addr-&gt;msf.frame
op_assign
id|lba
op_mod
l_int|75
suffix:semicolon
id|lba
op_div_assign
l_int|75
suffix:semicolon
id|lba
op_add_assign
l_int|2
suffix:semicolon
id|addr-&gt;msf.second
op_assign
id|lba
op_mod
l_int|60
suffix:semicolon
id|addr-&gt;msf.minute
op_assign
id|lba
op_div
l_int|60
suffix:semicolon
)brace
op_star
id|curr
op_assign
id|requested
suffix:semicolon
)brace
multiline_comment|/* Some of the cdrom ioctls are not implemented here, because these&n; * appear to be either too device-specific, or it is not clear to me&n; * what use they are. These are (number of drivers that support them&n; * in parenthesis): CDROMREADMODE1 (2+ide), CDROMREADMODE2 (2+ide),&n; * CDROMREADAUDIO (2+ide), CDROMREADRAW (2), CDROMREADCOOKED (2),&n; * CDROMSEEK (2), CDROMPLAYBLK (scsi), CDROMREADALL (1). Read-audio,&n; * OK (although i guess the record companies aren&squot;t too happy with&n; * this, most drives therefore refuse to transport audio data).  But&n; * why are there 5 different READs defined? For now, these functions&n; * are left over to the device-specific ioctl routine,&n; * cdo-&gt;dev_ioctl. Note that as a result of this, no&n; * memory-verification is performed for these ioctls.&n; */
r_static
DECL|function|cdrom_ioctl
r_int
id|cdrom_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|kdev_t
id|dev
op_assign
id|ip-&gt;i_rdev
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
id|cdrom_find_device
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|cdrom_device_ops
op_star
id|cdo
suffix:semicolon
r_if
c_cond
(paren
id|cdi
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|cdo
op_assign
id|cdi-&gt;ops
suffix:semicolon
multiline_comment|/* the first few commands do not deal with audio drive_info, but&n;&t;   only with routines in cdrom device operations. */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* maybe we should order cases after statistics of use? */
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_multisession
id|ms_info
suffix:semicolon
id|u_char
id|requested_format
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMMULTISESSION&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_MULTI_SESSION
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_multisession
comma
id|ms_info
)paren
suffix:semicolon
id|requested_format
op_assign
id|ms_info.addr_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested_format
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested_format
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms_info.addr_format
op_assign
id|CDROM_LBA
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|get_last_session
c_func
(paren
id|cdi
comma
op_amp
id|ms_info
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|ms_info.addr
comma
op_amp
id|ms_info.addr_format
comma
id|requested_format
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_multisession
comma
id|ms_info
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;CDROMMULTISESSION successful&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMEJECT&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_OPEN_TRAY
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|cdi-&gt;use_count
op_ne
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_LOCK
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|lock_door
c_func
(paren
id|cdi
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
r_return
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
)brace
r_case
id|CDROMCLOSETRAY
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMCLOSETRAY&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_OPEN_TRAY
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
r_case
id|CDROMEJECT_SW
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMEJECT_SW&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_OPEN_TRAY
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdi-&gt;options
op_and_assign
op_complement
(paren
id|CDO_AUTO_CLOSE
op_or
id|CDO_AUTO_EJECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|cdi-&gt;options
op_or_assign
id|CDO_AUTO_CLOSE
op_or
id|CDO_AUTO_EJECT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROM_MEDIA_CHANGED
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_MEDIA_CHANGED&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_MEDIA_CHANGED
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_SELECT_DISC
)paren
op_logical_or
id|arg
op_eq
id|CDSL_CURRENT
)paren
multiline_comment|/* cannot select disc or select current disc */
r_return
id|media_changed
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|arg
op_ge
id|cdi-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdo-&gt;media_changed
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
r_case
id|CDROM_SET_OPTIONS
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SET_OPTIONS&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdo-&gt;capability
op_amp
id|arg
op_amp
op_complement
id|cdi-&gt;mask
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|cdi-&gt;options
op_or_assign
(paren
r_int
)paren
id|arg
suffix:semicolon
r_return
id|cdi-&gt;options
suffix:semicolon
r_case
id|CDROM_CLEAR_OPTIONS
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_CLEAR_OPTIONS&bslash;n&quot;
)paren
suffix:semicolon
id|cdi-&gt;options
op_and_assign
op_complement
(paren
r_int
)paren
id|arg
suffix:semicolon
r_return
id|cdi-&gt;options
suffix:semicolon
r_case
id|CDROM_SELECT_SPEED
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SELECT_SPEED&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_SELECT_SPEED
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|select_speed
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
r_case
id|CDROM_SELECT_DISC
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_SELECT_DISC&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
op_complement
id|cdi-&gt;mask
op_amp
id|CDC_SELECT_DISC
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|CDSL_CURRENT
)paren
op_logical_or
(paren
id|arg
op_eq
id|CDSL_NONE
)paren
)paren
r_return
id|cdo
op_member_access_from_pointer
id|select_disc
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|arg
op_ge
id|cdi-&gt;capacity
)paren
r_return
op_minus
id|EDRIVE_CANT_DO_THIS
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|select_disc
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* The following function is implemented, although very few audio&n; * discs give Universal Product Code information, which should just be&n; * the Medium Catalog Number on the box.  Note, that the way the code&n; * is written on the CD is /not/ uniform across all discs!&n; */
r_case
id|CDROM_GET_MCN
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_mcn
id|mcn
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_GET_MCN&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_MCN
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|get_mcn
c_func
(paren
id|cdi
comma
op_amp
id|mcn
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_mcn
comma
id|mcn
)paren
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;CDROM_GET_MCN successful&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROM_DRIVE_STATUS
suffix:colon
(brace
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_DRIVE_STATUS&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_DRIVE_STATUS
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|CDSL_CURRENT
)paren
op_logical_or
(paren
id|arg
op_eq
id|CDSL_NONE
)paren
)paren
r_return
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|arg
OG
id|cdi-&gt;capacity
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|drive_status
c_func
(paren
id|cdi
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, this is where problems start.  The current interface for the&n;&t;   CDROM_DISC_STATUS ioctl is flawed.  It makes the false assumption&n;&t;   that CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.  Unfortunatly,&n;&t;   while this is often the case, it is also very common for CDs to&n;&t;   have some tracks with data, and some tracks with audio.  Just &n;&t;   because I feel like it, I declare the following to be the best&n;&t;   way to cope.  If the CD has ANY data tracks on it, it will be&n;&t;   returned as a data CD.  If it has any XA tracks, I will return&n;&t;   it as that.  Now I could simplify this interface by combining these &n;&t;   returns with the above, but this more clearly demonstrates&n;&t;   the problem with the current interface.  Too bad this wasn&squot;t &n;&t;   designed to use bitmasks...         -Erik &n;&n;&t;   Well, now we have the option CDS_MIXED: a mixed-type CD. &n;&t;   User level programmers might feel the ioctl is not very useful.&n;&t;   &t;&t;&t;&t;&t;---david&n;&t;*/
r_case
id|CDROM_DISC_STATUS
suffix:colon
(brace
id|tracktype
id|tracks
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_DISC_STATUS&bslash;n&quot;
)paren
suffix:semicolon
id|cdrom_count_tracks
c_func
(paren
id|cdi
comma
op_amp
id|tracks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tracks.error
)paren
r_return
id|tracks.error
suffix:semicolon
multiline_comment|/* Policy mode on */
r_if
c_cond
(paren
id|tracks.audio
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tracks.data
op_eq
l_int|0
op_logical_and
id|tracks.cdi
op_eq
l_int|0
op_logical_and
id|tracks.xa
op_eq
l_int|0
)paren
r_return
id|CDS_AUDIO
suffix:semicolon
r_else
r_return
id|CDS_MIXED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tracks.cdi
OG
l_int|0
)paren
r_return
id|CDS_XA_2_2
suffix:semicolon
r_if
c_cond
(paren
id|tracks.xa
OG
l_int|0
)paren
r_return
id|CDS_XA_2_1
suffix:semicolon
r_if
c_cond
(paren
id|tracks.data
OG
l_int|0
)paren
r_return
id|CDS_DATA_1
suffix:semicolon
multiline_comment|/* Policy mode off */
id|cdinfo
c_func
(paren
id|CD_WARNING
comma
l_string|&quot;This disc doesn&squot;t have any tracks I recognise!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|CDS_NO_INFO
suffix:semicolon
)brace
r_case
id|CDROM_CHANGER_NSLOTS
suffix:colon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROM_CHANGER_NSLOTS&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|cdi-&gt;capacity
suffix:semicolon
multiline_comment|/* The following is not implemented, because there are too many&n; * different data types. We could support /1/ raw mode, that is large&n; * enough to hold everything.&n; */
macro_line|#if 0
r_case
id|CDROMREADMODE1
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_char
id|buf
(braket
id|CD_FRAMESIZE
)braket
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMREADMODE1&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_msf
comma
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|read_audio
c_func
(paren
id|dev
comma
id|cmd
comma
op_amp
id|msf
comma
op_amp
id|buf
comma
id|cdi
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|__typeof__
c_func
(paren
id|buf
)paren
comma
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* switch */
multiline_comment|/* Now all the audio-ioctls follow, they are all routed through the&n;   same call audio_ioctl(). */
DECL|macro|CHECKAUDIO
mdefine_line|#define CHECKAUDIO if ((ret=check_for_audio_disc(cdi, cdo))) return ret
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_PLAY_AUDIO
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_else
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_subchnl
id|q
suffix:semicolon
id|u_char
id|requested
comma
id|back
suffix:semicolon
multiline_comment|/* comment out the cdinfo calls here because they&n;&t;&t;&t;   fill up the sys logs when CD players poll the drive*/
multiline_comment|/* cdinfo(CD_DO_IOCTL,&quot;entering CDROMSUBCHNL&bslash;n&quot;);*/
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_subchnl
comma
id|q
)paren
suffix:semicolon
id|requested
op_assign
id|q.cdsc_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q.cdsc_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|q
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|back
op_assign
id|q.cdsc_format
suffix:semicolon
multiline_comment|/* local copy */
id|sanitize_format
c_func
(paren
op_amp
id|q.cdsc_absaddr
comma
op_amp
id|back
comma
id|requested
)paren
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|q.cdsc_reladdr
comma
op_amp
id|q.cdsc_format
comma
id|requested
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_subchnl
comma
id|q
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMSUBCHNL successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_tochdr
id|header
suffix:semicolon
multiline_comment|/* comment out the cdinfo calls here because they&n;&t;&t;&t;   fill up the sys logs when CD players poll the drive*/
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;entering CDROMREADTOCHDR&bslash;n&quot;); */
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tochdr
comma
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|header
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tochdr
comma
id|header
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMREADTOCHDR successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
id|u_char
id|requested_format
suffix:semicolon
multiline_comment|/* comment out the cdinfo calls here because they&n;&t;&t;&t;   fill up the sys logs when CD players poll the drive*/
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;entering CDROMREADTOCENTRY&bslash;n&quot;); */
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tocentry
comma
id|entry
)paren
suffix:semicolon
id|requested_format
op_assign
id|entry.cdte_format
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|requested_format
op_eq
id|CDROM_MSF
)paren
op_logical_or
(paren
id|requested_format
op_eq
id|CDROM_LBA
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* make interface to low-level uniform */
id|entry.cdte_format
op_assign
id|CDROM_MSF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|entry
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|sanitize_format
c_func
(paren
op_amp
id|entry.cdte_addr
comma
op_amp
id|entry.cdte_format
comma
id|requested_format
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_tocentry
comma
id|entry
)paren
suffix:semicolon
multiline_comment|/* cdinfo(CD_DO_IOCTL, &quot;CDROMREADTOCENTRY successful&bslash;n&quot;); */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPLAYMSF&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_msf
comma
id|msf
)paren
suffix:semicolon
id|CHECKAUDIO
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|msf
)paren
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMPLAYTRKIND&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_ti
comma
id|ti
)paren
suffix:semicolon
id|CHECKAUDIO
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|ti
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volume
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMVOLCTRL&bslash;n&quot;
)paren
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
r_struct
id|cdrom_volctrl
comma
id|volume
)paren
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|volume
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLREAD
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|cdrom_volctrl
id|volume
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;entering CDROMVOLREAD&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
op_amp
id|volume
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
r_struct
id|cdrom_volctrl
comma
id|volume
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTART
suffix:colon
r_case
id|CDROMSTOP
suffix:colon
r_case
id|CDROMPAUSE
suffix:colon
r_case
id|CDROMRESUME
suffix:colon
(brace
r_int
id|ret
suffix:semicolon
id|cdinfo
c_func
(paren
id|CD_DO_IOCTL
comma
l_string|&quot;doing audio ioctl (start/stop/pause/resume)&bslash;n&quot;
)paren
suffix:semicolon
id|CHECKAUDIO
suffix:semicolon
r_return
id|cdo
op_member_access_from_pointer
id|audio_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* switch */
)brace
multiline_comment|/* device specific ioctls? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cdo-&gt;capability
op_amp
id|CDC_IOCTLS
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_else
r_return
id|cdo
op_member_access_from_pointer
id|dev_ioctl
c_func
(paren
id|cdi
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|cdrom_count_tracks
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_count_tracks
)paren
suffix:semicolon
DECL|variable|register_cdrom
id|EXPORT_SYMBOL
c_func
(paren
id|register_cdrom
)paren
suffix:semicolon
DECL|variable|unregister_cdrom
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_cdrom
)paren
suffix:semicolon
DECL|variable|cdrom_fops
id|EXPORT_SYMBOL
c_func
(paren
id|cdrom_fops
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
DECL|macro|CDROM_STR_SIZE
mdefine_line|#define CDROM_STR_SIZE 1000
DECL|variable|cdrom_drive_info
r_static
r_char
id|cdrom_drive_info
(braket
id|CDROM_STR_SIZE
)braket
op_assign
l_string|&quot;info&bslash;n&quot;
suffix:semicolon
DECL|function|cdrom_sysctl_info
r_int
id|cdrom_sysctl_info
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|retv
comma
id|pos
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
suffix:semicolon
id|pos
op_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
comma
l_string|&quot;CD-ROM information, &quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;ndrive name:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%s&quot;
comma
id|cdi-&gt;name
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;ndrive speed:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|cdi-&gt;speed
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;ndrive # of slots:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
id|cdi-&gt;capacity
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan close tray:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_CLOSE_TRAY
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan open tray:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_OPEN_TRAY
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan lock tray:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_LOCK
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan change speed:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_SELECT_SPEED
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan select disk:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_SELECT_DISC
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan read multisession:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_MULTI_SESSION
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan read MCN:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_MCN
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nReports media changed:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_MEDIA_CHANGED
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;nCan play audio:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdi
op_assign
id|topCdromPtr
suffix:semicolon
id|cdi
op_ne
l_int|NULL
suffix:semicolon
id|cdi
op_assign
id|cdi-&gt;next
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;t%d&quot;
comma
(paren
(paren
id|cdi-&gt;ops-&gt;capability
op_amp
id|CDC_PLAY_AUDIO
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|cdrom_drive_info
op_plus
id|pos
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|lenp
op_assign
id|pos
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
id|retv
op_assign
id|proc_dostring
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
)brace
r_else
id|retv
op_assign
id|proc_dostring
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/* Place files in /proc/sys/dev/cdrom */
DECL|variable|cdrom_table
id|ctl_table
id|cdrom_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_CDROM_INFO
comma
l_string|&quot;info&quot;
comma
op_amp
id|cdrom_drive_info
comma
id|CDROM_STR_SIZE
op_star
r_sizeof
(paren
r_char
)paren
comma
l_int|0444
comma
l_int|NULL
comma
op_amp
id|cdrom_sysctl_info
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|cdrom_cdrom_table
id|ctl_table
id|cdrom_cdrom_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_CDROM
comma
l_string|&quot;cdrom&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|cdrom_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Make sure that /proc/sys/dev is there */
DECL|variable|cdrom_root_table
id|ctl_table
id|cdrom_root_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_DEV
comma
l_string|&quot;dev&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|cdrom_cdrom_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|cdrom_sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|cdrom_sysctl_header
suffix:semicolon
multiline_comment|/*&n; * This is called as the fill_inode function when an inode&n; * is going into (fill = 1) or out of service (fill = 0).&n; * We use it here to manage the module use counts.&n; *&n; * Note: only the top-level directory needs to do this; if&n; * a lower level is referenced, the parent will be as well.&n; */
DECL|function|cdrom_procfs_modcount
r_static
r_void
id|cdrom_procfs_modcount
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
(brace
r_if
c_cond
(paren
id|fill
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_else
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|cdrom_sysctl_register
r_static
r_void
id|cdrom_sysctl_register
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|initialized
op_eq
l_int|1
)paren
r_return
suffix:semicolon
id|cdrom_sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|cdrom_root_table
comma
l_int|0
)paren
suffix:semicolon
id|cdrom_root_table-&gt;de-&gt;fill_inode
op_assign
op_amp
id|cdrom_procfs_modcount
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|cdrom_sysctl_unregister
r_static
r_void
id|cdrom_sysctl_unregister
c_func
(paren
r_void
)paren
(brace
id|unregister_sysctl_table
c_func
(paren
id|cdrom_sysctl_header
)paren
suffix:semicolon
)brace
macro_line|#endif /* endif MODULE */
macro_line|#endif /* endif CONFIG_SYSCTL */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SYSCTL
id|cdrom_sysctl_register
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */ 
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Uniform CD-ROM driver unloaded&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|cdrom_sysctl_unregister
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */ 
)brace
macro_line|#endif /* endif MODULE */
multiline_comment|/*&n; * Local variables:&n; * comment-column: 40&n; * compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -pipe -fno-strength-reduce -m486 -DCPU=486 -DMODULE -DMODVERSIONS -include /usr/src/linux/include/linux/modversions.h  -c -o cdrom.o cdrom.c&quot;&n; * End:&n; */
eof
