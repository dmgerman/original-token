multiline_comment|/* cm206.c. A linux-driver for the cm206 cdrom player with cm260 adapter card.&n;   Copyright (c) 1995--1997 David A. van Leeuwen.&n;   $Id: cm206.c,v 1.5 1997/12/26 11:02:51 david Exp $&n;   &n;     This program is free software; you can redistribute it and/or modify&n;     it under the terms of the GNU General Public License as published by&n;     the Free Software Foundation; either version 2 of the License, or&n;     (at your option) any later version.&n;     &n;     This program is distributed in the hope that it will be useful,&n;     but WITHOUT ANY WARRANTY; without even the implied warranty of&n;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;     GNU General Public License for more details.&n;     &n;     You should have received a copy of the GNU General Public License&n;     along with this program; if not, write to the Free Software&n;     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;History:&n; Started 25 jan 1994. Waiting for documentation...&n; 22 feb 1995: 0.1a first reasonably safe polling driver.&n;&t;      Two major bugs, one in read_sector and one in &n;&t;      do_cm206_request, happened to cancel!&n; 25 feb 1995: 0.2a first reasonable interrupt driven version of above.&n;              uart writes are still done in polling mode. &n; 25 feb 1995: 0.21a writes also in interrupt mode, still some&n;&t;      small bugs to be found... Larger buffer. &n;  2 mrt 1995: 0.22 Bug found (cd-&gt; nowhere, interrupt was called in&n;              initialization), read_ahead of 16. Timeouts implemented.&n;&t;      unclear if they do something...&n;  7 mrt 1995: 0.23 Start of background read-ahead.&n; 18 mrt 1995: 0.24 Working background read-ahead. (still problems)&n; 26 mrt 1995: 0.25 Multi-session ioctl added (kernel v1.2).&n;              Statistics implemented, though separate stats206.h.&n;&t;      Accessible trough ioctl 0x1000 (just a number).&n;&t;      Hard to choose between v1.2 development and 1.1.75.&n;&t;      Bottom-half doesn&squot;t work with 1.2...&n;&t;      0.25a: fixed... typo. Still problems...&n;  1 apr 1995: 0.26 Module support added. Most bugs found. Use kernel 1.2.n.&n;  5 apr 1995: 0.27 Auto-probe for the adapter card base address.&n;              Auto-probe for the adaptor card irq line.&n;  7 apr 1995: 0.28 Added lilo setup support for base address and irq.&n;              Use major number 32 (not in this source), officially&n;&t;      assigned to this driver.&n;  9 apr 1995: 0.29 Added very limited audio support. Toc_header, stop, pause,&n;              resume, eject. Play_track ignores track info, because we can&squot;t &n;&t;      read a table-of-contents entry. Toc_entry is implemented&n;&t;      as a `placebo&squot; function: always returns start of disc. &n;  3 may 1995: 0.30 Audio support completed. The get_toc_entry function&n;              is implemented as a binary search. &n; 15 may 1995: 0.31 More work on audio stuff. Workman is not easy to &n;              satisfy; changed binary search into linear search.&n;&t;      Auto-probe for base address somewhat relaxed.&n;  1 jun 1995: 0.32 Removed probe_irq_on/off for module version.&n; 10 jun 1995: 0.33 Workman still behaves funny, but you should be&n;              able to eject and substitute another disc.&n;&n; An adaptation of 0.33 is included in linux-1.3.7 by Eberhard Moenkeberg&n;&n; 18 jul 1995: 0.34 Patch by Heiko Eissfeldt included, mainly considering &n;              verify_area&squot;s in the ioctls. Some bugs introduced by &n;&t;      EM considering the base port and irq fixed. &n;&n; 18 dec 1995: 0.35 Add some code for error checking... no luck...&n;&n; We jump to reach our goal: version 1.0 in the next stable linux kernel.&n;&n; 19 mar 1996: 0.95 Different implementation of CDROM_GET_UPC, on&n;&t;      request of Thomas Quinot. &n; 25 mar 1996: 0.96 Interpretation of opening with O_WRONLY or O_RDWR:&n;&t;      open only for ioctl operation, e.g., for operation of&n;&t;      tray etc.&n; 4 apr 1996:  0.97 First implementation of layer between VFS and cdrom&n;              driver, a generic interface. Much of the functionality&n;&t;      of cm206_open() and cm206_ioctl() is transferred to a&n;&t;      new file cdrom.c and its header ucdrom.h. &n;&n;&t;      Upgrade to Linux kernel 1.3.78. &n;&n; 11 apr 1996  0.98 Upgrade to Linux kernel 1.3.85&n;              More code moved to cdrom.c&n; &n; &t;      0.99 Some more small changes to decrease number&n; &t;      of oopses at module load; &n; &n; 27 jul 1996  0.100 Many hours of debugging, kernel change from 1.2.13&n;&t;      to 2.0.7 seems to have introduced some weird behavior&n;&t;      in (interruptible_)sleep_on(&amp;cd-&gt;data): the process&n;&t;      seems to be woken without any explicit wake_up in my own&n;&t;      code. Patch to try 100x in case such untriggered wake_up&squot;s &n;&t;      occur. &n;&n; 28 jul 1996  0.101 Rewriting of the code that receives the command echo,&n;&t;      using a fifo to store echoed bytes. &n;&n; &t;      Branch from 0.99:&n; &n; &t;      0.99.1.0 Update to kernel release 2.0.10 dev_t -&gt; kdev_t&n; &t;      (emoenke) various typos found by others.  extra&n; &t;      module-load oops protection.&n; &n; &t;      0.99.1.1 Initialization constant cdrom_dops.speed&n; &t;      changed from float (2.0) to int (2); Cli()-sti() pair&n; &t;      around cm260_reset() in module initialization code.&n; &n; &t;      0.99.1.2 Changes literally as proposed by Scott Snyder&n; &t;      &lt;snyder@d0sgif.fnal.gov&gt; for the 2.1 kernel line, which&n; &t;      have to do mainly with the poor minor support i had. The&n; &t;      major new concept is to change a cdrom driver&squot;s&n; &t;      operations struct from the capabilities struct. This&n; &t;      reflects the fact that there is one major for a driver,&n; &t;      whilst there can be many minors whith completely&n; &t;      different capabilities.&n;&n;&t;      0.99.1.3 More changes for operations/info separation.&n;&n;&t;      0.99.1.4 Added speed selection (someone had to do this&n;&t;      first).&n;&n;  23 jan 1997 0.99.1.5 MODULE_PARMS call added.&n;&n;  23 jan 1997 0.100.1.2--0.100.1.5 following similar lines as &n;  &t;      0.99.1.1--0.99.1.5. I get too many complaints about the&n;&t;      drive making read errors. What&squot;t wrong with the 2.0+&n;&t;      kernel line? Why get i (and othe cm206 owners) weird&n;&t;      results? Why were things good in the good old 1.1--1.2 &n;&t;      era? Why don&squot;t i throw away the drive?&n;&n; 2 feb 1997   0.102 Added `volatile&squot; to values in cm206_struct. Seems to &n; &t;      reduce many of the problems. Rewrote polling routines&n;&t;      to use fixed delays between polls. &n;&t;      0.103 Changed printk behavior. &n;&t;      0.104 Added a 0.100 -&gt; 0.100.1.1 change&n;&n;11 feb 1997   0.105 Allow auto_probe during module load, disable&n;              with module option &quot;auto_probe=0&quot;. Moved some debugging&n;&t;      statements to lower priority. Implemented select_speed()&n;&t;      function. &n;&n;13 feb 1997   1.0 Final version for 2.0 kernel line. &n;&n;&t;      All following changes will be for the 2.1 kernel line. &n;&n;15 feb 1997   1.1 Keep up with kernel 2.1.26, merge in changes from &n;              cdrom.c 0.100.1.1--1.0. Add some more MODULE_PARMS. &n;&n;14 sep 1997   1.2 Upgrade to Linux 2.1.55.  Added blksize_size[], patch&n;              sent by James Bottomley &lt;James.Bottomley@columbiasc.ncr.com&gt;.&n;&n;21 dec 1997   1.4 Upgrade to Linux 2.1.72.  &n;&n;24 jan 1998   Removed the cm206_disc_status() function, as it was now dead&n;              code.  The Uniform CDROM driver now provides this functionality.&n;&t;      &n;9 Nov. 1999   Make kernel-parameter implementation work with 2.3.x &n;&t;      Removed init_module &amp; cleanup_module in favor of &n;&t;      module_init &amp; module_exit.&n;&t;      Torben Mathiasen &lt;tmm@image.dk&gt;&n; * &n; * Parts of the code are based upon lmscd.c written by Kai Petzke,&n; * sbpcd.c written by Eberhard Moenkeberg, and mcd.c by Martin&n; * Harriss, but any off-the-shelf dynamic programming algorithm won&squot;t&n; * be able to find them.&n; *&n; * The cm206 drive interface and the cm260 adapter card seem to be &n; * sufficiently different from their cm205/cm250 counterparts&n; * in order to write a complete new driver.&n; * &n; * I call all routines connected to the Linux kernel something&n; * with `cm206&squot; in it, as this stuff is too series-dependent. &n; * &n; * Currently, my limited knowledge is based on:&n; * - The Linux Kernel Hacker&squot;s guide, v. 0.5, by Michael K. Johnson&n; * - Linux Kernel Programmierung, by Michael Beck and others&n; * - Philips/LMS cm206 and cm226 product specification&n; * - Philips/LMS cm260 product specification&n; *&n; * David van Leeuwen, david@tm.tno.nl.  */
DECL|macro|REVISION
mdefine_line|#define REVISION &quot;$Revision: 1.5 $&quot;
macro_line|#include &lt;linux/module.h&gt;&t;
macro_line|#include &lt;linux/errno.h&gt;&t;/* These include what we really need */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
multiline_comment|/* #include &lt;linux/ucdrom.h&gt; */
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR CM206_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|STATISTICS
mdefine_line|#define STATISTICS&t;&t;/* record times and frequencies of events */
DECL|macro|AUTO_PROBE_MODULE
mdefine_line|#define AUTO_PROBE_MODULE
DECL|macro|USE_INSW
mdefine_line|#define USE_INSW
macro_line|#include &quot;cm206.h&quot;
multiline_comment|/* This variable defines whether or not to probe for adapter base port &n;   address and interrupt request. It can be overridden by the boot &n;   parameter `auto&squot;.&n;*/
DECL|variable|auto_probe
r_static
r_int
id|auto_probe
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Yes, why not? */
DECL|variable|cm206_base
r_static
r_int
id|cm206_base
op_assign
id|CM206_BASE
suffix:semicolon
DECL|variable|cm206_irq
r_static
r_int
id|cm206_irq
op_assign
id|CM206_IRQ
suffix:semicolon
DECL|variable|cm206
r_static
r_int
id|cm206
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* for compatible `insmod&squot; parameter passing */
id|MODULE_PARM
c_func
(paren
id|cm206_base
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* base */
id|MODULE_PARM
c_func
(paren
id|cm206_irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* irq */
id|MODULE_PARM
c_func
(paren
id|cm206
comma
l_string|&quot;1-2i&quot;
)paren
suffix:semicolon
multiline_comment|/* base,irq or irq,base */
id|MODULE_PARM
c_func
(paren
id|auto_probe
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* auto probe base and irq */
DECL|macro|POLLOOP
mdefine_line|#define POLLOOP 100&t;&t;/* milliseconds */
DECL|macro|READ_AHEAD
mdefine_line|#define READ_AHEAD 1&t;&t;/* defines private buffer, waste! */
DECL|macro|BACK_AHEAD
mdefine_line|#define BACK_AHEAD 1&t;&t;/* defines adapter-read ahead */
DECL|macro|DATA_TIMEOUT
mdefine_line|#define DATA_TIMEOUT (3*HZ)&t;/* measured in jiffies (10 ms) */
DECL|macro|UART_TIMEOUT
mdefine_line|#define UART_TIMEOUT (5*HZ/100)
DECL|macro|DSB_TIMEOUT
mdefine_line|#define DSB_TIMEOUT (7*HZ)&t;/* time for the slowest command to finish */
DECL|macro|UR_SIZE
mdefine_line|#define UR_SIZE 4&t;&t;/* uart receive buffer fifo size */
DECL|macro|LINUX_BLOCK_SIZE
mdefine_line|#define LINUX_BLOCK_SIZE 512&t;/* WHERE is this defined? */
DECL|macro|RAW_SECTOR_SIZE
mdefine_line|#define RAW_SECTOR_SIZE 2352&t;/* ok, is also defined in cdrom.h */
DECL|macro|ISO_SECTOR_SIZE
mdefine_line|#define ISO_SECTOR_SIZE 2048
DECL|macro|BLOCKS_ISO
mdefine_line|#define BLOCKS_ISO (ISO_SECTOR_SIZE/LINUX_BLOCK_SIZE) /* 4 */
DECL|macro|CD_SYNC_HEAD
mdefine_line|#define CD_SYNC_HEAD 16&t;&t;/* CD_SYNC + CD_HEAD */
macro_line|#ifdef STATISTICS&t;&t;/* keep track of errors in counters */
DECL|macro|stats
mdefine_line|#define stats(i) { ++cd-&gt;stats[st_ ## i]; &bslash;&n;&t;&t;     cd-&gt;last_stat[st_ ## i] = cd-&gt;stat_counter++; &bslash;&n;&t;&t; }
macro_line|#else
DECL|macro|stats
mdefine_line|#define stats(i) (void) 0;
macro_line|#endif
DECL|macro|Debug
mdefine_line|#define Debug(a) {printk (KERN_DEBUG); printk a;}
macro_line|#ifdef DEBUG
DECL|macro|debug
mdefine_line|#define debug(a) Debug(a)
macro_line|#else
DECL|macro|debug
mdefine_line|#define debug(a) (void) 0;
macro_line|#endif
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
multiline_comment|/* 8-bits */
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
multiline_comment|/* 16-bits */
DECL|struct|toc_struct
r_struct
id|toc_struct
(brace
multiline_comment|/* private copy of Table of Contents */
DECL|member|track
DECL|member|fsm
DECL|member|q0
id|uch
id|track
comma
id|fsm
(braket
l_int|3
)braket
comma
id|q0
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cm206_blocksizes
r_static
r_int
id|cm206_blocksizes
(braket
l_int|1
)braket
op_assign
(brace
l_int|2048
)brace
suffix:semicolon
DECL|struct|cm206_struct
r_struct
id|cm206_struct
(brace
DECL|member|intr_ds
r_volatile
id|ush
id|intr_ds
suffix:semicolon
multiline_comment|/* data status read on last interrupt */
DECL|member|intr_ls
r_volatile
id|ush
id|intr_ls
suffix:semicolon
multiline_comment|/* uart line status read on last interrupt*/
DECL|member|ur
r_volatile
id|uch
id|ur
(braket
id|UR_SIZE
)braket
suffix:semicolon
multiline_comment|/* uart receive buffer fifo */
DECL|member|ur_w
DECL|member|ur_r
r_volatile
id|uch
id|ur_w
comma
id|ur_r
suffix:semicolon
multiline_comment|/* write/read buffer index */
DECL|member|dsb
DECL|member|cc
r_volatile
id|uch
id|dsb
comma
id|cc
suffix:semicolon
multiline_comment|/* drive status byte and condition (error) code */
DECL|member|command
r_int
id|command
suffix:semicolon
multiline_comment|/* command to be written to the uart */
DECL|member|openfiles
r_int
id|openfiles
suffix:semicolon
DECL|member|sector
id|ush
id|sector
(braket
id|READ_AHEAD
op_star
id|RAW_SECTOR_SIZE
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* buffered cd-sector */
DECL|member|sector_first
DECL|member|sector_last
r_int
id|sector_first
comma
id|sector_last
suffix:semicolon
multiline_comment|/* range of these sectors */
DECL|member|uart
id|wait_queue_head_t
id|uart
suffix:semicolon
multiline_comment|/* wait queues for interrupt */
DECL|member|data
id|wait_queue_head_t
id|data
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* time-out */
DECL|member|timed_out
r_char
id|timed_out
suffix:semicolon
DECL|member|max_sectors
r_int
r_char
id|max_sectors
suffix:semicolon
multiline_comment|/* number of sectors that fit in adapter mem */
DECL|member|wait_back
r_char
id|wait_back
suffix:semicolon
multiline_comment|/* we&squot;re waiting for a background-read */
DECL|member|background
r_char
id|background
suffix:semicolon
multiline_comment|/* is a read going on in the background? */
DECL|member|adapter_first
r_int
id|adapter_first
suffix:semicolon
multiline_comment|/* if so, that&squot;s the starting sector */
DECL|member|adapter_last
r_int
id|adapter_last
suffix:semicolon
DECL|member|fifo_overflowed
r_char
id|fifo_overflowed
suffix:semicolon
DECL|member|disc_status
id|uch
id|disc_status
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* result of get_disc_status command */
macro_line|#ifdef STATISTICS
DECL|member|stats
r_int
id|stats
(braket
id|NR_STATS
)braket
suffix:semicolon
DECL|member|last_stat
r_int
id|last_stat
(braket
id|NR_STATS
)braket
suffix:semicolon
multiline_comment|/* `time&squot; at which stat was stat */
DECL|member|stat_counter
r_int
id|stat_counter
suffix:semicolon
macro_line|#endif  
DECL|member|toc
r_struct
id|toc_struct
id|toc
(braket
l_int|101
)braket
suffix:semicolon
multiline_comment|/* The whole table of contents + lead-out */
DECL|member|q
id|uch
id|q
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Last read q-channel info */
DECL|member|audio_status
id|uch
id|audio_status
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* last read position on pause */
DECL|member|media_changed
id|uch
id|media_changed
suffix:semicolon
multiline_comment|/* record if media changed */
)brace
suffix:semicolon
DECL|macro|DISC_STATUS
mdefine_line|#define DISC_STATUS cd-&gt;disc_status[0]
DECL|macro|FIRST_TRACK
mdefine_line|#define FIRST_TRACK cd-&gt;disc_status[1]
DECL|macro|LAST_TRACK
mdefine_line|#define LAST_TRACK cd-&gt;disc_status[2]
DECL|macro|PAUSED
mdefine_line|#define PAUSED cd-&gt;audio_status[0] /* misuse this memory byte! */
DECL|macro|PLAY_TO
mdefine_line|#define PLAY_TO cd-&gt;toc[0]&t;/* toc[0] records end-time in play */
DECL|variable|cd
r_static
r_struct
id|cm206_struct
op_star
id|cd
suffix:semicolon
multiline_comment|/* the main memory structure */
multiline_comment|/* First, we define some polling functions. These are actually&n;   only being used in the initialization. */
DECL|function|send_command_polled
r_void
id|send_command_polled
c_func
(paren
r_int
id|command
)paren
(brace
r_int
id|loop
op_assign
id|POLLOOP
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_transmitter_buffer_empty
)paren
op_logical_and
id|loop
OG
l_int|0
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* one millisec delay */
op_decrement
id|loop
suffix:semicolon
)brace
id|outw
c_func
(paren
id|command
comma
id|r_uart_transmit
)paren
suffix:semicolon
)brace
DECL|function|receive_echo_polled
id|uch
id|receive_echo_polled
c_func
(paren
r_void
)paren
(brace
r_int
id|loop
op_assign
id|POLLOOP
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_receive_buffer_full
)paren
op_logical_and
id|loop
OG
l_int|0
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
op_decrement
id|loop
suffix:semicolon
)brace
r_return
(paren
(paren
id|uch
)paren
id|inw
c_func
(paren
id|r_uart_receive
)paren
)paren
suffix:semicolon
)brace
DECL|function|send_receive_polled
id|uch
id|send_receive_polled
c_func
(paren
r_int
id|command
)paren
(brace
id|send_command_polled
c_func
(paren
id|command
)paren
suffix:semicolon
r_return
id|receive_echo_polled
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|clear_ur
r_inline
r_void
id|clear_ur
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;ur_r
op_ne
id|cd-&gt;ur_w
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Deleting bytes from fifo:&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cd-&gt;ur_r
op_ne
id|cd-&gt;ur_w
suffix:semicolon
id|cd-&gt;ur_r
op_increment
comma
id|cd-&gt;ur_r
op_mod_assign
id|UR_SIZE
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot; 0x%x&quot;
comma
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
)paren
)paren
suffix:semicolon
)brace
id|debug
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The interrupt handler. When the cm260 generates an interrupt, very&n;   much care has to be taken in reading out the registers in the right&n;   order; in case of a receive_buffer_full interrupt, first the&n;   uart_receive must be read, and then the line status again to&n;   de-assert the interrupt line. It took me a couple of hours to find&n;   this out:-( &n;&n;   The function reset_cm206 appears to cause an interrupt, because&n;   pulling up the INIT line clears both the uart-write-buffer /and/&n;   the uart-write-buffer-empty mask. We call this a `lost interrupt,&squot;&n;   as there seems so reason for this to happen.&n;*/
DECL|function|cm206_interrupt
r_static
r_void
id|cm206_interrupt
c_func
(paren
r_int
id|sig
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
multiline_comment|/* you rang? */
(brace
r_volatile
id|ush
id|fool
suffix:semicolon
id|cd-&gt;intr_ds
op_assign
id|inw
c_func
(paren
id|r_data_status
)paren
suffix:semicolon
multiline_comment|/* resets data_ready, data_error,&n;&t;&t;&t;&t;       crc_error, sync_error, toc_ready &n;&t;&t;&t;&t;       interrupts */
id|cd-&gt;intr_ls
op_assign
id|inw
c_func
(paren
id|r_line_status
)paren
suffix:semicolon
multiline_comment|/* resets overrun bit */
id|debug
c_func
(paren
(paren
l_string|&quot;Intr, 0x%x 0x%x, %d&bslash;n&quot;
comma
id|cd-&gt;intr_ds
comma
id|cd-&gt;intr_ls
comma
id|cd-&gt;background
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;intr_ls
op_amp
id|ls_attention
)paren
id|stats
c_func
(paren
id|attention
)paren
suffix:semicolon
multiline_comment|/* receive buffer full? */
r_if
c_cond
(paren
id|cd-&gt;intr_ls
op_amp
id|ls_receive_buffer_full
)paren
(brace
id|cd-&gt;ur
(braket
id|cd-&gt;ur_w
)braket
op_assign
id|inb
c_func
(paren
id|r_uart_receive
)paren
suffix:semicolon
multiline_comment|/* get order right! */
id|cd-&gt;intr_ls
op_assign
id|inw
c_func
(paren
id|r_line_status
)paren
suffix:semicolon
multiline_comment|/* resets rbf interrupt */
id|debug
c_func
(paren
(paren
l_string|&quot;receiving #%d: 0x%x&bslash;n&quot;
comma
id|cd-&gt;ur_w
comma
id|cd-&gt;ur
(braket
id|cd-&gt;ur_w
)braket
)paren
)paren
suffix:semicolon
id|cd-&gt;ur_w
op_increment
suffix:semicolon
id|cd-&gt;ur_w
op_mod_assign
id|UR_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;ur_w
op_eq
id|cd-&gt;ur_r
)paren
id|debug
c_func
(paren
(paren
l_string|&quot;cd-&gt;ur overflow!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|cd-&gt;uart
)paren
op_logical_and
id|cd-&gt;background
OL
l_int|2
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|cd-&gt;timer
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|cd-&gt;uart
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* data ready in fifo? */
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_data_ready
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
op_increment
id|cd-&gt;adapter_last
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|cd-&gt;data
)paren
op_logical_and
(paren
id|cd-&gt;wait_back
op_logical_or
op_logical_neg
id|cd-&gt;background
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|cd-&gt;timer
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|cd-&gt;data
)paren
suffix:semicolon
)brace
id|stats
c_func
(paren
id|data_ready
)paren
suffix:semicolon
)brace
multiline_comment|/* ready to issue a write command? */
r_else
r_if
c_cond
(paren
id|cd-&gt;command
op_logical_and
id|cd-&gt;intr_ls
op_amp
id|ls_transmitter_buffer_empty
)paren
(brace
id|outw
c_func
(paren
id|dc_normal
op_or
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
l_int|0x7f
)paren
comma
id|r_data_control
)paren
suffix:semicolon
id|outw
c_func
(paren
id|cd-&gt;command
comma
id|r_uart_transmit
)paren
suffix:semicolon
id|cd-&gt;command
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;background
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|cd-&gt;uart
)paren
suffix:semicolon
)brace
multiline_comment|/* now treat errors (at least, identify them for debugging) */
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_fifo_overflow
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Fifo overflow at sectors 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|fool
op_assign
id|inw
c_func
(paren
id|r_fifo_output_buffer
)paren
suffix:semicolon
multiline_comment|/* de-assert the interrupt */
id|cd-&gt;fifo_overflowed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* signal one word less should be read */
id|stats
c_func
(paren
id|fifo_overflow
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_data_error
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Data error at sector 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|data_error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_crc_error
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;CRC error at sector 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|crc_error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_sync_error
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Sync at sector 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|sync_error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_toc_ready
)paren
(brace
multiline_comment|/* do something appropriate */
)brace
multiline_comment|/* couldn&squot;t see why this interrupt, maybe due to init */
r_else
(brace
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|stats
c_func
(paren
id|lost_intr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cd-&gt;background
op_logical_and
(paren
id|cd-&gt;adapter_last
op_minus
id|cd-&gt;adapter_first
op_eq
id|cd-&gt;max_sectors
op_logical_or
id|cd-&gt;fifo_overflowed
)paren
)paren
id|mark_bh
c_func
(paren
id|CM206_BH
)paren
suffix:semicolon
multiline_comment|/* issue a stop read command */
id|stats
c_func
(paren
id|interrupt
)paren
suffix:semicolon
)brace
multiline_comment|/* we have put the address of the wait queue in who */
DECL|function|cm206_timeout
r_void
id|cm206_timeout
c_func
(paren
r_int
r_int
id|who
)paren
(brace
id|cd-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;Timing out&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
(paren
id|wait_queue_head_t
op_star
)paren
id|who
)paren
suffix:semicolon
)brace
multiline_comment|/* This function returns 1 if a timeout occurred, 0 if an interrupt&n;   happened */
DECL|function|sleep_or_timeout
r_int
id|sleep_or_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|wait
comma
r_int
id|timeout
)paren
(brace
id|cd-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|wait
suffix:semicolon
id|cd-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|cd-&gt;timer
)paren
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;going to sleep&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|wait
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|cd-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;timed_out
)paren
(brace
id|cd-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_delay
r_void
id|cm206_delay
c_func
(paren
r_int
id|nr_jiffies
)paren
(brace
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wait
)paren
suffix:semicolon
id|sleep_or_timeout
c_func
(paren
op_amp
id|wait
comma
id|nr_jiffies
)paren
suffix:semicolon
)brace
DECL|function|send_command
r_void
id|send_command
c_func
(paren
r_int
id|command
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Sending 0x%x&bslash;n&quot;
comma
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_transmitter_buffer_empty
)paren
)paren
(brace
id|cd-&gt;command
op_assign
id|command
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t interrupt before sleep */
id|outw
c_func
(paren
id|dc_mask_sync_error
op_or
id|dc_no_stop_on_error
op_or
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
l_int|0x7f
)paren
comma
id|r_data_control
)paren
suffix:semicolon
multiline_comment|/* interrupt routine sends command */
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;uart
comma
id|UART_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Time out on write-buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|write_timeout
)paren
suffix:semicolon
id|outw
c_func
(paren
id|command
comma
id|r_uart_transmit
)paren
suffix:semicolon
)brace
id|debug
c_func
(paren
(paren
l_string|&quot;Write commmand delayed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|outw
c_func
(paren
id|command
comma
id|r_uart_transmit
)paren
suffix:semicolon
)brace
DECL|function|receive_byte
id|uch
id|receive_byte
c_func
(paren
r_int
id|timeout
)paren
(brace
id|uch
id|ret
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;cli&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;ur_r
op_ne
id|cd-&gt;ur_w
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;returning #%d: 0x%x&bslash;n&quot;
comma
id|cd-&gt;ur_r
comma
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
)paren
)paren
suffix:semicolon
id|cd-&gt;ur_r
op_increment
suffix:semicolon
id|cd-&gt;ur_r
op_mod_assign
id|UR_SIZE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;uart
comma
id|timeout
)paren
)paren
(brace
multiline_comment|/* does sti() */
id|debug
c_func
(paren
(paren
l_string|&quot;Time out on receive-buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#ifdef STATISTICS
r_if
c_cond
(paren
id|timeout
op_eq
id|UART_TIMEOUT
)paren
id|stats
c_func
(paren
id|receive_timeout
)paren
multiline_comment|/* no `;&squot;! */
r_else
id|stats
c_func
(paren
id|dsb_timeout
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0xda
suffix:semicolon
)brace
id|ret
op_assign
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;slept; returning #%d: 0x%x&bslash;n&quot;
comma
id|cd-&gt;ur_r
comma
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
)paren
)paren
suffix:semicolon
id|cd-&gt;ur_r
op_increment
suffix:semicolon
id|cd-&gt;ur_r
op_mod_assign
id|UR_SIZE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|receive_echo
r_inline
id|uch
id|receive_echo
c_func
(paren
r_void
)paren
(brace
r_return
id|receive_byte
c_func
(paren
id|UART_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|send_receive
r_inline
id|uch
id|send_receive
c_func
(paren
r_int
id|command
)paren
(brace
id|send_command
c_func
(paren
id|command
)paren
suffix:semicolon
r_return
id|receive_echo
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|wait_dsb
r_inline
id|uch
id|wait_dsb
c_func
(paren
r_void
)paren
(brace
r_return
id|receive_byte
c_func
(paren
id|DSB_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|type_0_command
r_int
id|type_0_command
c_func
(paren
r_int
id|command
comma
r_int
id|expect_dsb
)paren
(brace
r_int
id|e
suffix:semicolon
id|clear_ur
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
op_ne
(paren
id|e
op_assign
id|send_receive
c_func
(paren
id|command
)paren
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;command 0x%x echoed as 0x%x&bslash;n&quot;
comma
id|command
comma
id|e
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|echo
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expect_dsb
)paren
(brace
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for command to finish */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|type_1_command
r_int
id|type_1_command
c_func
(paren
r_int
id|command
comma
r_int
id|bytes
comma
id|uch
op_star
id|status
)paren
multiline_comment|/* returns info */
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|type_0_command
c_func
(paren
id|command
comma
l_int|0
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bytes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|status
(braket
id|i
)braket
op_assign
id|send_receive
c_func
(paren
id|c_gimme
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function resets the adapter card. We&squot;d better not do this too&n; * often, because it tends to generate `lost interrupts.&squot; */
DECL|function|reset_cm260
r_void
id|reset_cm260
c_func
(paren
r_void
)paren
(brace
id|outw
c_func
(paren
id|dc_normal
op_or
id|dc_initialize
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 3.3 mu sec minimum */
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
)brace
multiline_comment|/* fsm: frame-sec-min from linear address; one of many */
DECL|function|fsm
r_void
id|fsm
c_func
(paren
r_int
id|lba
comma
id|uch
op_star
id|fsm
)paren
(brace
id|fsm
(braket
l_int|0
)braket
op_assign
id|lba
op_mod
l_int|75
suffix:semicolon
id|lba
op_div_assign
l_int|75
suffix:semicolon
id|lba
op_add_assign
l_int|2
suffix:semicolon
id|fsm
(braket
l_int|1
)braket
op_assign
id|lba
op_mod
l_int|60
suffix:semicolon
id|fsm
(braket
l_int|2
)braket
op_assign
id|lba
op_div
l_int|60
suffix:semicolon
)brace
DECL|function|fsm2lba
r_inline
r_int
id|fsm2lba
c_func
(paren
id|uch
op_star
id|fsm
)paren
(brace
r_return
id|fsm
(braket
l_int|0
)braket
op_plus
l_int|75
op_star
(paren
id|fsm
(braket
l_int|1
)braket
op_minus
l_int|2
op_plus
l_int|60
op_star
id|fsm
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|f_s_m2lba
r_inline
r_int
id|f_s_m2lba
c_func
(paren
id|uch
id|f
comma
id|uch
id|s
comma
id|uch
id|m
)paren
(brace
r_return
id|f
op_plus
l_int|75
op_star
(paren
id|s
op_minus
l_int|2
op_plus
l_int|60
op_star
id|m
)paren
suffix:semicolon
)brace
DECL|function|start_read
r_int
id|start_read
c_func
(paren
r_int
id|start
)paren
(brace
id|uch
id|read_sector
(braket
l_int|4
)braket
op_assign
(brace
id|c_read_data
comma
)brace
suffix:semicolon
r_int
id|i
comma
id|e
suffix:semicolon
id|fsm
c_func
(paren
id|start
comma
op_amp
id|read_sector
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|clear_ur
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|read_sector
(braket
id|i
)braket
op_ne
(paren
id|e
op_assign
id|send_receive
c_func
(paren
id|read_sector
(braket
id|i
)braket
)paren
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;read_sector: %x echoes %x&bslash;n&quot;
comma
id|read_sector
(braket
id|i
)braket
comma
id|e
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|echo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* this seems to happen often */
id|e
op_assign
id|receive_echo
c_func
(paren
)paren
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;Second try %x&bslash;n&quot;
comma
id|e
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_ne
id|read_sector
(braket
id|i
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|stop_read
r_int
id|stop_read
c_func
(paren
r_void
)paren
(brace
r_int
id|e
suffix:semicolon
id|type_0_command
c_func
(paren
id|c_stop
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e
op_assign
id|receive_echo
c_func
(paren
)paren
)paren
op_ne
l_int|0xff
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;c_stop didn&squot;t send 0xff, but 0x%x&bslash;n&quot;
comma
id|e
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|stop_0xff
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function starts to read sectors in adapter memory, the&n;   interrupt routine should stop the read. In fact, the bottom_half&n;   routine takes care of this. Set a flag `background&squot; in the cd&n;   struct to indicate the process. */
DECL|function|read_background
r_int
id|read_background
c_func
(paren
r_int
id|start
comma
r_int
id|reading
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* can&squot;t do twice */
id|outw
c_func
(paren
id|dc_normal
op_or
id|BACK_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reading
op_logical_and
id|start_read
c_func
(paren
id|start
)paren
)paren
r_return
op_minus
l_int|2
suffix:semicolon
id|cd-&gt;adapter_first
op_assign
id|cd-&gt;adapter_last
op_assign
id|start
suffix:semicolon
id|cd-&gt;background
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flag a read is going on */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef USE_INSW
DECL|macro|transport_data
mdefine_line|#define transport_data insw
macro_line|#else
multiline_comment|/* this routine implements insw(,,). There was a time i had the&n;   impression that there would be any difference in error-behaviour. */
DECL|function|transport_data
r_void
id|transport_data
c_func
(paren
r_int
id|port
comma
id|ush
op_star
id|dest
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
id|ush
op_star
id|d
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|d
op_assign
id|dest
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|d
op_increment
)paren
op_star
id|d
op_assign
id|inw
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|MAX_TRIES
mdefine_line|#define MAX_TRIES 100
DECL|function|read_sector
r_int
id|read_sector
c_func
(paren
r_int
id|start
)paren
(brace
r_int
id|tries
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;background
)paren
(brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalidate adapter memory */
id|stop_read
c_func
(paren
)paren
suffix:semicolon
)brace
id|cd-&gt;fifo_overflowed
op_assign
l_int|0
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* empty fifo etc. */
r_if
c_cond
(paren
id|start_read
c_func
(paren
id|start
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;data
comma
id|DATA_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Read timed out sector 0x%x&bslash;n&quot;
comma
id|start
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|read_timeout
)paren
suffix:semicolon
id|stop_read
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|3
suffix:semicolon
)brace
id|tries
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_fifo_empty
op_logical_and
id|tries
OL
id|MAX_TRIES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tries
OG
l_int|1
)paren
id|debug
c_func
(paren
(paren
l_string|&quot;Took me some tries&bslash;n&quot;
)paren
)paren
r_else
r_if
c_cond
(paren
id|tries
op_eq
id|MAX_TRIES
)paren
id|debug
c_func
(paren
(paren
l_string|&quot;MAX_TRIES tries for read sector&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|transport_data
c_func
(paren
id|r_fifo_output_buffer
comma
id|cd-&gt;sector
comma
id|READ_AHEAD
op_star
id|RAW_SECTOR_SIZE
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_background
c_func
(paren
id|start
op_plus
id|READ_AHEAD
comma
l_int|1
)paren
)paren
id|stats
c_func
(paren
id|read_background
)paren
suffix:semicolon
id|cd-&gt;sector_first
op_assign
id|start
suffix:semicolon
id|cd-&gt;sector_last
op_assign
id|start
op_plus
id|READ_AHEAD
suffix:semicolon
id|stats
c_func
(paren
id|read_restarted
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The function of bottom-half is to send a stop command to the drive&n;   This isn&squot;t easy because the routine is not `owned&squot; by any process;&n;   we can&squot;t go to sleep! The variable cd-&gt;background gives the status:&n;   0 no read pending&n;   1 a read is pending&n;   2 c_stop waits for write_buffer_empty&n;   3 c_stop waits for receive_buffer_full: echo&n;   4 c_stop waits for receive_buffer_full: 0xff&n;*/
DECL|function|cm206_bh
r_void
id|cm206_bh
c_func
(paren
r_void
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;bh: %d&bslash;n&quot;
comma
id|cd-&gt;background
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cd-&gt;background
)paren
(brace
r_case
l_int|1
suffix:colon
id|stats
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cd-&gt;intr_ls
op_amp
id|ls_transmitter_buffer_empty
)paren
)paren
(brace
id|cd-&gt;command
op_assign
id|c_stop
suffix:semicolon
id|outw
c_func
(paren
id|dc_mask_sync_error
op_or
id|dc_no_stop_on_error
op_or
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
l_int|0x7f
)paren
comma
id|r_data_control
)paren
suffix:semicolon
id|cd-&gt;background
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* we&squot;d better not time-out here! */
)brace
r_else
id|outw
c_func
(paren
id|c_stop
comma
id|r_uart_transmit
)paren
suffix:semicolon
multiline_comment|/* fall into case 2: */
r_case
l_int|2
suffix:colon
multiline_comment|/* the write has been satisfied by interrupt routine */
id|cd-&gt;background
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|cd-&gt;ur_r
op_ne
id|cd-&gt;ur_w
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
op_ne
id|c_stop
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;cm206_bh: c_stop echoed 0x%x&bslash;n&quot;
comma
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|echo
)paren
suffix:semicolon
)brace
id|cd-&gt;ur_r
op_increment
suffix:semicolon
id|cd-&gt;ur_r
op_mod_assign
id|UR_SIZE
suffix:semicolon
)brace
id|cd-&gt;background
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|cd-&gt;ur_r
op_ne
id|cd-&gt;ur_w
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
op_ne
l_int|0xff
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;cm206_bh: c_stop reacted with 0x%x&bslash;n&quot;
comma
id|cd-&gt;ur
(braket
id|cd-&gt;ur_r
)braket
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|stop_0xff
)paren
suffix:semicolon
)brace
id|cd-&gt;ur_r
op_increment
suffix:semicolon
id|cd-&gt;ur_r
op_mod_assign
id|UR_SIZE
suffix:semicolon
)brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* This command clears the dsb_possible_media_change flag, so we must &n; * retain it.&n; */
DECL|function|get_drive_status
r_void
id|get_drive_status
c_func
(paren
r_void
)paren
(brace
id|uch
id|status
(braket
l_int|2
)braket
suffix:semicolon
id|type_1_command
c_func
(paren
id|c_drive_status
comma
l_int|2
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* this might be done faster */
id|cd-&gt;dsb
op_assign
id|status
(braket
l_int|0
)braket
suffix:semicolon
id|cd-&gt;cc
op_assign
id|status
(braket
l_int|1
)braket
suffix:semicolon
id|cd-&gt;media_changed
op_or_assign
op_logical_neg
op_logical_neg
(paren
id|cd-&gt;dsb
op_amp
(paren
id|dsb_possible_media_change
op_or
id|dsb_drive_not_ready
op_or
id|dsb_tray_not_closed
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_disc_status
r_void
id|get_disc_status
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|type_1_command
c_func
(paren
id|c_disc_status
comma
l_int|7
comma
id|cd-&gt;disc_status
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;get_disc_status: error&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The new open. The real opening strategy is defined in cdrom.c. */
DECL|function|cm206_open
r_static
r_int
id|cm206_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;openfiles
)paren
(brace
multiline_comment|/* reset only first time */
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalidate adapter memory */
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
op_increment
id|cd-&gt;openfiles
suffix:semicolon
id|stats
c_func
(paren
id|open
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_release
r_static
r_void
id|cm206_release
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;openfiles
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
(brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
id|stop_read
c_func
(paren
)paren
suffix:semicolon
)brace
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Make our internal buffer invalid */
id|FIRST_TRACK
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No valid disc status */
)brace
op_decrement
id|cd-&gt;openfiles
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Empty buffer empties $sectors$ sectors of the adapter card buffer,&n; * and then reads a sector in kernel memory.  */
DECL|function|empty_buffer
r_void
id|empty_buffer
c_func
(paren
r_int
id|sectors
)paren
(brace
r_while
c_loop
(paren
id|sectors
op_ge
l_int|0
)paren
(brace
id|transport_data
c_func
(paren
id|r_fifo_output_buffer
comma
id|cd-&gt;sector
op_plus
id|cd-&gt;fifo_overflowed
comma
id|RAW_SECTOR_SIZE
op_div
l_int|2
op_minus
id|cd-&gt;fifo_overflowed
)paren
suffix:semicolon
op_decrement
id|sectors
suffix:semicolon
op_increment
id|cd-&gt;adapter_first
suffix:semicolon
multiline_comment|/* update the current adapter sector */
id|cd-&gt;fifo_overflowed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset overflow bit */
id|stats
c_func
(paren
id|sector_transferred
)paren
suffix:semicolon
)brace
id|cd-&gt;sector_first
op_assign
id|cd-&gt;adapter_first
op_minus
l_int|1
suffix:semicolon
id|cd-&gt;sector_last
op_assign
id|cd-&gt;adapter_first
suffix:semicolon
multiline_comment|/* update the buffer sector */
)brace
multiline_comment|/* try_adapter. This function determines if the requested sector is&n;   in adapter memory, or will appear there soon. Returns 0 upon&n;   success */
DECL|function|try_adapter
r_int
id|try_adapter
c_func
(paren
r_int
id|sector
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;adapter_first
op_le
id|sector
op_logical_and
id|sector
OL
id|cd-&gt;adapter_last
)paren
(brace
multiline_comment|/* sector is in adapter memory */
id|empty_buffer
c_func
(paren
id|sector
op_minus
id|cd-&gt;adapter_first
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;background
op_eq
l_int|1
op_logical_and
id|cd-&gt;adapter_first
op_le
id|sector
op_logical_and
id|sector
OL
id|cd-&gt;adapter_first
op_plus
id|cd-&gt;max_sectors
)paren
(brace
multiline_comment|/* a read is going on, we can wait for it */
id|cd-&gt;wait_back
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|sector
op_ge
id|cd-&gt;adapter_last
)paren
(brace
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;data
comma
id|DATA_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Timed out during background wait: %d %d %d %d&bslash;n&quot;
comma
id|sector
comma
id|cd-&gt;adapter_last
comma
id|cd-&gt;adapter_first
comma
id|cd-&gt;background
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|back_read_timeout
)paren
suffix:semicolon
id|cd-&gt;wait_back
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|cd-&gt;wait_back
op_assign
l_int|0
suffix:semicolon
id|empty_buffer
c_func
(paren
id|sector
op_minus
id|cd-&gt;adapter_first
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/* This is not a very smart implementation. We could optimize for &n;   consecutive block numbers. I&squot;m not convinced this would really&n;   bring down the processor load. */
DECL|function|do_cm206_request
r_static
r_void
id|do_cm206_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_int
r_int
id|i
comma
id|cd_sec_no
suffix:semicolon
r_int
id|quarter
comma
id|error
suffix:semicolon
id|uch
op_star
id|source
comma
op_star
id|dest
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* repeat until all requests have been satisfied */
id|INIT_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|QUEUE_EMPTY
op_logical_or
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_ne
id|READ
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Non-read command %d on cdrom&bslash;n&quot;
comma
id|CURRENT-&gt;cmd
)paren
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|e1
comma
id|e2
suffix:semicolon
id|cd_sec_no
op_assign
(paren
id|CURRENT-&gt;sector
op_plus
id|i
)paren
op_div
id|BLOCKS_ISO
suffix:semicolon
multiline_comment|/* 4 times 512 bytes */
id|quarter
op_assign
(paren
id|CURRENT-&gt;sector
op_plus
id|i
)paren
op_mod
id|BLOCKS_ISO
suffix:semicolon
id|dest
op_assign
id|CURRENT-&gt;buffer
op_plus
id|i
op_star
id|LINUX_BLOCK_SIZE
suffix:semicolon
multiline_comment|/* is already in buffer memory? */
r_if
c_cond
(paren
id|cd-&gt;sector_first
op_le
id|cd_sec_no
op_logical_and
id|cd_sec_no
OL
id|cd-&gt;sector_last
)paren
(brace
id|source
op_assign
(paren
(paren
id|uch
op_star
)paren
id|cd-&gt;sector
)paren
op_plus
l_int|16
op_plus
id|quarter
op_star
id|LINUX_BLOCK_SIZE
op_plus
(paren
id|cd_sec_no
op_minus
id|cd-&gt;sector_first
)paren
op_star
id|RAW_SECTOR_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|source
comma
id|LINUX_BLOCK_SIZE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|e1
op_assign
id|try_adapter
c_func
(paren
id|cd_sec_no
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|e2
op_assign
id|read_sector
c_func
(paren
id|cd_sec_no
)paren
)paren
)paren
(brace
id|source
op_assign
(paren
(paren
id|uch
op_star
)paren
id|cd-&gt;sector
)paren
op_plus
l_int|16
op_plus
id|quarter
op_star
id|LINUX_BLOCK_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|source
comma
id|LINUX_BLOCK_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
l_int|1
suffix:semicolon
id|debug
c_func
(paren
(paren
l_string|&quot;cm206_request: %d %d&bslash;n&quot;
comma
id|e1
comma
id|e2
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|end_request
c_func
(paren
op_logical_neg
id|error
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Audio support. I&squot;ve tried very hard, but the cm206 drive doesn&squot;t &n;   seem to have a get_toc (table-of-contents) function, while i&squot;m&n;   pretty sure it must read the toc upon disc insertion. Therefore&n;   this function has been implemented through a binary search &n;   strategy. All track starts that happen to be found are stored in&n;   cd-&gt;toc[], for future use. &n;&n;   I&squot;ve spent a whole day on a bug that only shows under Workman---&n;   I don&squot;t get it. Tried everything, nothing works. If workman asks&n;   for track# 0xaa, it&squot;ll get the wrong time back. Any other program&n;   receives the correct value. I&squot;m stymied.&n;*/
multiline_comment|/* seek seeks to address lba. It does wait to arrive there. */
DECL|function|seek
r_void
id|seek
c_func
(paren
r_int
id|lba
)paren
(brace
r_int
id|i
suffix:semicolon
id|uch
id|seek_command
(braket
l_int|4
)braket
op_assign
initialization_block
suffix:semicolon
id|fsm
c_func
(paren
id|lba
comma
op_amp
id|seek_command
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
id|seek_command
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|bcdbin
id|uch
id|bcdbin
c_func
(paren
r_int
r_char
id|bcd
)paren
multiline_comment|/* stolen from mcd.c! */
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0xf
)paren
suffix:semicolon
)brace
DECL|function|normalize_track
r_inline
id|uch
id|normalize_track
c_func
(paren
id|uch
id|track
)paren
(brace
r_if
c_cond
(paren
id|track
OL
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|track
OG
id|LAST_TRACK
)paren
r_return
id|LAST_TRACK
op_plus
l_int|1
suffix:semicolon
r_return
id|track
suffix:semicolon
)brace
multiline_comment|/* This function does a binary search for track start. It records all&n; * tracks seen in the process. Input $track$ must be between 1 and&n; * #-of-tracks+1.  Note that the start of the disc must be in toc[1].fsm. &n; */
DECL|function|get_toc_lba
r_int
id|get_toc_lba
c_func
(paren
id|uch
id|track
)paren
(brace
r_int
id|max
op_assign
l_int|74
op_star
l_int|60
op_star
l_int|75
op_minus
l_int|150
comma
id|min
op_assign
id|fsm2lba
c_func
(paren
id|cd-&gt;toc
(braket
l_int|1
)braket
dot
id|fsm
)paren
suffix:semicolon
r_int
id|i
comma
id|lba
comma
id|l
comma
id|old_lba
op_assign
l_int|0
suffix:semicolon
id|uch
op_star
id|q
op_assign
id|cd-&gt;q
suffix:semicolon
id|uch
id|ct
suffix:semicolon
multiline_comment|/* current track */
r_int
id|binary
op_assign
l_int|0
suffix:semicolon
r_const
r_int
id|skip
op_assign
l_int|3
op_star
l_int|60
op_star
l_int|75
suffix:semicolon
multiline_comment|/* 3 minutes */
r_for
c_loop
(paren
id|i
op_assign
id|track
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|cd-&gt;toc
(braket
id|i
)braket
dot
id|track
)paren
(brace
id|min
op_assign
id|fsm2lba
c_func
(paren
id|cd-&gt;toc
(braket
id|i
)braket
dot
id|fsm
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lba
op_assign
id|min
op_plus
id|skip
suffix:semicolon
r_do
(brace
id|seek
c_func
(paren
id|lba
)paren
suffix:semicolon
id|type_1_command
c_func
(paren
id|c_read_current_q
comma
l_int|10
comma
id|q
)paren
suffix:semicolon
id|ct
op_assign
id|normalize_track
c_func
(paren
id|q
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|track
)paren
(brace
id|l
op_assign
id|q
(braket
l_int|9
)braket
op_minus
id|bcdbin
c_func
(paren
id|q
(braket
l_int|5
)braket
)paren
op_plus
l_int|75
op_star
(paren
id|q
(braket
l_int|8
)braket
op_minus
id|bcdbin
c_func
(paren
id|q
(braket
l_int|4
)braket
)paren
op_minus
l_int|2
op_plus
l_int|60
op_star
(paren
id|q
(braket
l_int|7
)braket
op_minus
id|bcdbin
c_func
(paren
id|q
(braket
l_int|3
)braket
)paren
)paren
)paren
suffix:semicolon
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|track
op_assign
id|q
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* lead out still 0xaa */
id|fsm
c_func
(paren
id|l
comma
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|fsm
)paren
suffix:semicolon
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|q0
op_assign
id|q
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* contains adr and ctrl info */
r_if
c_cond
(paren
id|ct
op_eq
id|track
)paren
r_return
id|l
suffix:semicolon
)brace
id|old_lba
op_assign
id|lba
suffix:semicolon
r_if
c_cond
(paren
id|binary
)paren
(brace
r_if
c_cond
(paren
id|ct
OL
id|track
)paren
id|min
op_assign
id|lba
suffix:semicolon
r_else
id|max
op_assign
id|lba
suffix:semicolon
id|lba
op_assign
(paren
id|min
op_plus
id|max
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ct
OL
id|track
)paren
(brace
id|lba
op_add_assign
id|skip
suffix:semicolon
)brace
r_else
(brace
id|binary
op_assign
l_int|1
suffix:semicolon
id|max
op_assign
id|lba
suffix:semicolon
id|min
op_assign
id|lba
op_minus
id|skip
suffix:semicolon
id|lba
op_assign
(paren
id|min
op_plus
id|max
)paren
op_div
l_int|2
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|lba
op_ne
id|old_lba
)paren
suffix:semicolon
r_return
id|lba
suffix:semicolon
)brace
DECL|function|update_toc_entry
r_void
id|update_toc_entry
c_func
(paren
id|uch
id|track
)paren
(brace
id|track
op_assign
id|normalize_track
c_func
(paren
id|track
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|track
)paren
id|get_toc_lba
c_func
(paren
id|track
)paren
suffix:semicolon
)brace
multiline_comment|/* return 0 upon success */
DECL|function|read_toc_header
r_int
id|read_toc_header
c_func
(paren
r_struct
id|cdrom_tochdr
op_star
id|hp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|FIRST_TRACK
)paren
id|get_disc_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hp
)paren
(brace
r_int
id|i
suffix:semicolon
id|hp-&gt;cdth_trk0
op_assign
id|FIRST_TRACK
suffix:semicolon
id|hp-&gt;cdth_trk1
op_assign
id|LAST_TRACK
suffix:semicolon
multiline_comment|/* fill in first track position */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|cd-&gt;toc
(braket
l_int|1
)braket
dot
id|fsm
(braket
id|i
)braket
op_assign
id|cd-&gt;disc_status
(braket
l_int|3
op_plus
id|i
)braket
suffix:semicolon
id|update_toc_entry
c_func
(paren
id|LAST_TRACK
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* find most entries */
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|play_from_to_msf
r_void
id|play_from_to_msf
c_func
(paren
r_struct
id|cdrom_msf
op_star
id|msfp
)paren
(brace
id|uch
id|play_command
(braket
)braket
op_assign
(brace
id|c_play
comma
id|msfp-&gt;cdmsf_frame0
comma
id|msfp-&gt;cdmsf_sec0
comma
id|msfp-&gt;cdmsf_min0
comma
id|msfp-&gt;cdmsf_frame1
comma
id|msfp-&gt;cdmsf_sec1
comma
id|msfp-&gt;cdmsf_min1
comma
l_int|2
comma
l_int|2
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
id|play_command
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|PLAY_TO.fsm
(braket
id|i
)braket
op_assign
id|play_command
(braket
id|i
op_plus
l_int|4
)braket
suffix:semicolon
id|PLAY_TO.track
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* say no track end */
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|play_from_to_track
r_void
id|play_from_to_track
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|uch
id|play_command
(braket
l_int|8
)braket
op_assign
(brace
id|c_play
comma
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|from
op_eq
l_int|0
)paren
(brace
multiline_comment|/* continue paused play */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|play_command
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cd-&gt;audio_status
(braket
id|i
op_plus
l_int|2
)braket
suffix:semicolon
id|play_command
(braket
id|i
op_plus
l_int|4
)braket
op_assign
id|PLAY_TO.fsm
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
id|update_toc_entry
c_func
(paren
id|from
)paren
suffix:semicolon
id|update_toc_entry
c_func
(paren
id|to
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|play_command
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cd-&gt;toc
(braket
id|from
)braket
dot
id|fsm
(braket
id|i
)braket
suffix:semicolon
id|PLAY_TO.fsm
(braket
id|i
)braket
op_assign
id|play_command
(braket
id|i
op_plus
l_int|4
)braket
op_assign
id|cd-&gt;toc
(braket
id|to
op_plus
l_int|1
)braket
dot
id|fsm
(braket
id|i
)braket
suffix:semicolon
)brace
id|PLAY_TO.track
op_assign
id|to
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
id|play_command
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
l_int|0x2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* volume */
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|get_current_q
r_int
id|get_current_q
c_func
(paren
r_struct
id|cdrom_subchnl
op_star
id|qp
)paren
(brace
r_int
id|i
suffix:semicolon
id|uch
op_star
id|q
op_assign
id|cd-&gt;q
suffix:semicolon
r_if
c_cond
(paren
id|type_1_command
c_func
(paren
id|c_read_current_q
comma
l_int|10
comma
id|q
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*  q[0] = bcdbin(q[0]); Don&squot;t think so! */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|q
(braket
id|i
)braket
op_assign
id|bcdbin
c_func
(paren
id|q
(braket
id|i
)braket
)paren
suffix:semicolon
id|qp-&gt;cdsc_adr
op_assign
id|q
(braket
l_int|0
)braket
op_amp
l_int|0xf
suffix:semicolon
id|qp-&gt;cdsc_ctrl
op_assign
id|q
(braket
l_int|0
)braket
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* from mcd.c */
id|qp-&gt;cdsc_trk
op_assign
id|q
(braket
l_int|1
)braket
suffix:semicolon
id|qp-&gt;cdsc_ind
op_assign
id|q
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|qp-&gt;cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|qp-&gt;cdsc_reladdr.msf.minute
op_assign
id|q
(braket
l_int|3
)braket
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.second
op_assign
id|q
(braket
l_int|4
)braket
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.frame
op_assign
id|q
(braket
l_int|5
)braket
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.minute
op_assign
id|q
(braket
l_int|7
)braket
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.second
op_assign
id|q
(braket
l_int|8
)braket
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.frame
op_assign
id|q
(braket
l_int|9
)braket
suffix:semicolon
)brace
r_else
(brace
id|qp-&gt;cdsc_reladdr.lba
op_assign
id|f_s_m2lba
c_func
(paren
id|q
(braket
l_int|5
)braket
comma
id|q
(braket
l_int|4
)braket
comma
id|q
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|qp-&gt;cdsc_absaddr.lba
op_assign
id|f_s_m2lba
c_func
(paren
id|q
(braket
l_int|9
)braket
comma
id|q
(braket
l_int|8
)braket
comma
id|q
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_play_in_progress
)paren
id|qp-&gt;cdsc_audiostatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PAUSED
)paren
id|qp-&gt;cdsc_audiostatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_else
id|qp-&gt;cdsc_audiostatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|invalidate_toc
r_void
id|invalidate_toc
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|cd-&gt;toc
comma
l_int|0
comma
r_sizeof
(paren
id|cd-&gt;toc
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cd-&gt;disc_status
comma
l_int|0
comma
r_sizeof
(paren
id|cd-&gt;disc_status
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* cdrom.c guarantees that cdte_format == CDROM_MSF */
DECL|function|get_toc_entry
r_void
id|get_toc_entry
c_func
(paren
r_struct
id|cdrom_tocentry
op_star
id|ep
)paren
(brace
id|uch
id|track
op_assign
id|normalize_track
c_func
(paren
id|ep-&gt;cdte_track
)paren
suffix:semicolon
id|update_toc_entry
c_func
(paren
id|track
)paren
suffix:semicolon
id|ep-&gt;cdte_addr.msf.frame
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
(braket
l_int|0
)braket
suffix:semicolon
id|ep-&gt;cdte_addr.msf.second
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
(braket
l_int|1
)braket
suffix:semicolon
id|ep-&gt;cdte_addr.msf.minute
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
(braket
l_int|2
)braket
suffix:semicolon
id|ep-&gt;cdte_adr
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|q0
op_amp
l_int|0xf
suffix:semicolon
id|ep-&gt;cdte_ctrl
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|q0
op_rshift
l_int|4
suffix:semicolon
id|ep-&gt;cdte_datamode
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Audio ioctl.  Ioctl commands connected to audio are in such an&n; * idiosyncratic i/o format, that we leave these untouched. Return 0&n; * upon success. Memory checking has been done by cdrom_ioctl(), the&n; * calling function, as well as LBA/MSF sanitization.&n;*/
DECL|function|cm206_audio_ioctl
r_int
id|cm206_audio_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMREADTOCHDR
suffix:colon
r_return
id|read_toc_header
c_func
(paren
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
id|get_toc_entry
c_func
(paren
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
id|play_from_to_msf
c_func
(paren
(paren
r_struct
id|cdrom_msf
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* admittedly, not particularly beautiful */
id|play_from_to_track
c_func
(paren
(paren
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|cdti_trk0
comma
(paren
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|cdti_trk1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
id|PAUSED
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_play_in_progress
)paren
r_return
id|type_0_command
c_func
(paren
id|c_stop
comma
l_int|1
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_play_in_progress
)paren
(brace
id|type_0_command
c_func
(paren
id|c_stop
comma
l_int|1
)paren
suffix:semicolon
id|type_1_command
c_func
(paren
id|c_audio_status
comma
l_int|5
comma
id|cd-&gt;audio_status
)paren
suffix:semicolon
id|PAUSED
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* say we&squot;re paused */
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
r_if
c_cond
(paren
id|PAUSED
)paren
id|play_from_to_track
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|PAUSED
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
r_case
id|CDROMVOLCTRL
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
r_return
id|get_current_q
c_func
(paren
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* Ioctl. These ioctls are specific to the cm206 driver. I have made&n;   some driver statistics accessible through ioctl calls.&n; */
DECL|function|cm206_ioctl
r_static
r_int
id|cm206_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#ifdef STATISTICS
r_case
id|CM206CTL_GET_STAT
suffix:colon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_STATS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_return
id|cd-&gt;stats
(braket
id|arg
)braket
suffix:semicolon
r_case
id|CM206CTL_GET_LAST_STAT
suffix:colon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_STATS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_return
id|cd-&gt;last_stat
(braket
id|arg
)braket
suffix:semicolon
macro_line|#endif    
r_default
suffix:colon
id|debug
c_func
(paren
(paren
l_string|&quot;Unknown ioctl call 0x%x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|cm206_media_changed
r_int
id|cm206_media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|disc_nr
)paren
(brace
r_if
c_cond
(paren
id|cd
op_ne
l_int|NULL
)paren
(brace
r_int
id|r
suffix:semicolon
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ensure cd-&gt;media_changed OK */
id|r
op_assign
id|cd-&gt;media_changed
suffix:semicolon
id|cd-&gt;media_changed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear bit */
r_return
id|r
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* The new generic cdrom support. Routines should be concise, most of&n;   the logic should be in cdrom.c */
multiline_comment|/* returns number of times device is in use */
DECL|function|cm206_open_files
r_int
id|cm206_open_files
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_if
c_cond
(paren
id|cd
)paren
r_return
id|cd-&gt;openfiles
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* controls tray movement */
DECL|function|cm206_tray_move
r_int
id|cm206_tray_move
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
(brace
r_if
c_cond
(paren
id|position
)paren
(brace
multiline_comment|/* 1: eject */
id|type_0_command
c_func
(paren
id|c_open_tray
comma
l_int|1
)paren
suffix:semicolon
id|invalidate_toc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|type_0_command
c_func
(paren
id|c_close_tray
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 0: close */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* gives current state of the drive */
DECL|function|cm206_drive_status
r_int
id|cm206_drive_status
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_tray_not_closed
)paren
r_return
id|CDS_TRAY_OPEN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cd-&gt;dsb
op_amp
id|dsb_disc_present
)paren
)paren
r_return
id|CDS_NO_DISC
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_drive_not_ready
)paren
r_return
id|CDS_DRIVE_NOT_READY
suffix:semicolon
r_return
id|CDS_DISC_OK
suffix:semicolon
)brace
multiline_comment|/* locks or unlocks door lock==1: lock; return 0 upon success */
DECL|function|cm206_lock_door
r_int
id|cm206_lock_door
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|lock
)paren
(brace
id|uch
id|command
op_assign
(paren
id|lock
)paren
ques
c_cond
id|c_lock_tray
suffix:colon
id|c_unlock_tray
suffix:semicolon
id|type_0_command
c_func
(paren
id|command
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait and get dsb */
multiline_comment|/* the logic calculates the success, 0 means successful */
r_return
id|lock
op_xor
(paren
(paren
id|cd-&gt;dsb
op_amp
id|dsb_tray_locked
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Although a session start should be in LBA format, we return it in &n;   MSF format because it is slightly easier, and the new generic ioctl&n;   will take care of the necessary conversion. */
DECL|function|cm206_get_last_session
r_int
id|cm206_get_last_session
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_multisession
op_star
id|mssp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|FIRST_TRACK
)paren
id|get_disc_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mssp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|DISC_STATUS
op_amp
id|cds_multi_session
)paren
(brace
multiline_comment|/* multi-session */
id|mssp-&gt;addr.msf.frame
op_assign
id|cd-&gt;disc_status
(braket
l_int|3
)braket
suffix:semicolon
id|mssp-&gt;addr.msf.second
op_assign
id|cd-&gt;disc_status
(braket
l_int|4
)braket
suffix:semicolon
id|mssp-&gt;addr.msf.minute
op_assign
id|cd-&gt;disc_status
(braket
l_int|5
)braket
suffix:semicolon
id|mssp-&gt;addr_format
op_assign
id|CDROM_MSF
suffix:semicolon
id|mssp-&gt;xa_flag
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|mssp-&gt;xa_flag
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_get_upc
r_int
id|cm206_get_upc
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_mcn
op_star
id|mcn
)paren
(brace
id|uch
id|upc
(braket
l_int|10
)braket
suffix:semicolon
r_char
op_star
id|ret
op_assign
id|mcn-&gt;medium_catalog_number
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|type_1_command
c_func
(paren
id|c_read_upc
comma
l_int|10
comma
id|upc
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|13
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|w
op_assign
id|i
op_div
l_int|2
op_plus
l_int|1
comma
id|r
op_assign
id|i
op_mod
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|ret
(braket
id|i
)braket
op_assign
l_int|0x30
op_or
(paren
id|upc
(braket
id|w
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_else
id|ret
(braket
id|i
)braket
op_assign
l_int|0x30
op_or
(paren
(paren
id|upc
(braket
id|w
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
id|ret
(braket
l_int|13
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_reset
r_int
id|cm206_reset
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
id|stop_read
c_func
(paren
)paren
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|dc_break
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 750 musec minimum */
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* flag no data buffered */
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
id|invalidate_toc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_select_speed
r_int
id|cm206_select_speed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|speed
)paren
(brace
r_int
id|r
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
l_int|0
suffix:colon
id|r
op_assign
id|type_0_command
c_func
(paren
id|c_auto_mode
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|r
op_assign
id|type_0_command
c_func
(paren
id|c_force_1x
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|r
op_assign
id|type_0_command
c_func
(paren
id|c_force_2x
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_return
id|r
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|cm206_dops
r_static
r_struct
id|cdrom_device_ops
id|cm206_dops
op_assign
(brace
id|open
suffix:colon
id|cm206_open
comma
id|release
suffix:colon
id|cm206_release
comma
id|drive_status
suffix:colon
id|cm206_drive_status
comma
id|media_changed
suffix:colon
id|cm206_media_changed
comma
id|tray_move
suffix:colon
id|cm206_tray_move
comma
id|lock_door
suffix:colon
id|cm206_lock_door
comma
id|select_speed
suffix:colon
id|cm206_select_speed
comma
id|get_last_session
suffix:colon
id|cm206_get_last_session
comma
id|get_mcn
suffix:colon
id|cm206_get_upc
comma
id|reset
suffix:colon
id|cm206_reset
comma
id|audio_ioctl
suffix:colon
id|cm206_audio_ioctl
comma
id|dev_ioctl
suffix:colon
id|cm206_ioctl
comma
id|capability
suffix:colon
id|CDC_CLOSE_TRAY
op_or
id|CDC_OPEN_TRAY
op_or
id|CDC_LOCK
op_or
id|CDC_MULTI_SESSION
op_or
id|CDC_MEDIA_CHANGED
op_or
id|CDC_MCN
op_or
id|CDC_PLAY_AUDIO
op_or
id|CDC_SELECT_SPEED
op_or
id|CDC_IOCTLS
op_or
id|CDC_DRIVE_STATUS
comma
id|n_minors
suffix:colon
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|cm206_info
r_static
r_struct
id|cdrom_device_info
id|cm206_info
op_assign
(brace
id|ops
suffix:colon
op_amp
id|cm206_dops
comma
id|speed
suffix:colon
l_int|2
comma
id|capacity
suffix:colon
l_int|1
comma
id|name
suffix:colon
l_string|&quot;cm206&quot;
comma
)brace
suffix:semicolon
multiline_comment|/* This routine gets called during initialization if things go wrong,&n; * can be used in cleanup_module as well. */
DECL|function|cleanup
r_static
r_void
id|cleanup
c_func
(paren
r_int
id|level
)paren
(brace
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|unregister_cdrom
c_func
(paren
op_amp
id|cm206_info
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister cdrom cm206&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cm206&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister major cm206&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
id|free_irq
c_func
(paren
id|cm206_irq
comma
l_int|NULL
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|1
suffix:colon
id|kfree
c_func
(paren
id|cd
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|cm206_base
comma
l_int|16
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
multiline_comment|/* This function probes for the adapter card. It returns the base&n;   address if it has found the adapter card. One can specify a base &n;   port to probe specifically, or 0 which means span all possible&n;   bases. &n;&n;   Linus says it is too dangerous to use writes for probing, so we&n;   stick with pure reads for a while. Hope that 8 possible ranges,&n;   check_region, 15 bits of one port and 6 of another make things&n;   likely enough to accept the region on the first hit...&n; */
DECL|function|probe_base_port
r_int
id|__init
id|probe_base_port
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|b
op_assign
l_int|0x300
comma
id|e
op_assign
l_int|0x370
suffix:semicolon
multiline_comment|/* this is the range of start addresses */
r_volatile
r_int
id|fool
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
id|b
op_assign
id|e
op_assign
id|base
suffix:semicolon
r_for
c_loop
(paren
id|base
op_assign
id|b
suffix:semicolon
id|base
op_le
id|e
suffix:semicolon
id|base
op_add_assign
l_int|0x10
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|0x10
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|fool
op_assign
id|inw
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* empty possibly uart_receive_buffer */
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|base
op_plus
l_int|6
)paren
op_amp
l_int|0xffef
)paren
op_ne
l_int|0x0001
op_logical_or
multiline_comment|/* line_status */
(paren
id|inw
c_func
(paren
id|base
)paren
op_amp
l_int|0xad00
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* data status */
r_continue
suffix:semicolon
)brace
r_return
id|base
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if !defined(MODULE) || defined(AUTO_PROBE_MODULE)
multiline_comment|/* Probe for irq# nr. If nr==0, probe for all possible irq&squot;s. */
DECL|function|probe_irq
r_int
id|__init
(def_block
id|probe_irq
c_func
(paren
r_int
id|nr
)paren
(brace
r_int
id|irqs
comma
id|irq
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
multiline_comment|/* disable irq-generation */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* causes interrupt */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for it */
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
multiline_comment|/* services interrupt */
r_if
c_cond
(paren
id|nr
op_logical_and
id|irq
op_ne
id|nr
op_logical_and
id|irq
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* wrong interrupt happened */
r_else
r_return
id|irq
suffix:semicolon
)brace
)def_block
macro_line|#endif
DECL|function|cm206_init
r_int
id|__init
id|cm206_init
c_func
(paren
r_void
)paren
(brace
id|uch
id|e
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|size
op_assign
r_sizeof
(paren
r_struct
id|cm206_struct
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cm206 cdrom driver &quot;
id|REVISION
)paren
suffix:semicolon
id|cm206_base
op_assign
id|probe_base_port
c_func
(paren
id|auto_probe
ques
c_cond
l_int|0
suffix:colon
id|cm206_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cm206_base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; can&squot;t find adapter!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; adapter at 0x%x&quot;
comma
id|cm206_base
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|cm206_base
comma
l_int|16
comma
l_string|&quot;cm206&quot;
)paren
suffix:semicolon
id|cd
op_assign
(paren
r_struct
id|cm206_struct
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Now we have found the adaptor card, try to reset it. As we have&n;   * found out earlier, this process generates an interrupt as well,&n;   * so we might just exploit that fact for irq probing! */
macro_line|#if !defined(MODULE) || defined(AUTO_PROBE_MODULE)
id|cm206_irq
op_assign
id|probe_irq
c_func
(paren
id|auto_probe
ques
c_cond
l_int|0
suffix:colon
id|cm206_irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cm206_irq
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;can&squot;t find IRQ!&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; IRQ %d found&bslash;n&quot;
comma
id|cm206_irq
)paren
suffix:semicolon
macro_line|#else
id|cli
c_func
(paren
)paren
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now, the problem here is that reset_cm260 can generate an&n;     interrupt. It seems that this can cause a kernel oops some time&n;     later. So we wait a while and `service&squot; this interrupt. */
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; using IRQ %d&bslash;n&quot;
comma
id|cm206_irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|send_receive_polled
c_func
(paren
id|c_drive_configuration
)paren
op_ne
id|c_drive_configuration
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; drive not there&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|e
op_assign
id|send_receive_polled
c_func
(paren
id|c_gimme
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Firmware revision %d&quot;
comma
id|e
op_amp
id|dcf_revision_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_amp
id|dcf_transfer_rate
)paren
id|printk
c_func
(paren
l_string|&quot; double&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; single&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; speed drive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_amp
id|dcf_motorized_tray
)paren
id|printk
c_func
(paren
l_string|&quot;, motorized tray&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cm206_irq
comma
id|cm206_interrupt
comma
l_int|0
comma
l_string|&quot;cm206&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nUnable to reserve IRQ---aborted&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cm206&quot;
comma
op_amp
id|cdrom_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Cannot register for major %d!&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cm206_info.dev
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_cdrom
c_func
(paren
op_amp
id|cm206_info
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Cannot register for cdrom %d!&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|cm206_blocksizes
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* reads ahead what? */
id|init_bh
c_func
(paren
id|CM206_BH
comma
id|cm206_bh
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cd
)paren
)paren
suffix:semicolon
multiline_comment|/* give&squot;m some reasonable value */
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* flag no data buffered */
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
id|cd-&gt;timer.function
op_assign
id|cm206_timeout
suffix:semicolon
id|cd-&gt;max_sectors
op_assign
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
id|ds_ram_size
)paren
ques
c_cond
l_int|24
suffix:colon
l_int|97
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d kB adapter memory available, &quot;
l_string|&quot; %ld bytes kernel memory used.&bslash;n&quot;
comma
id|cd-&gt;max_sectors
op_star
l_int|2
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|parse_options
r_static
r_void
id|__init
id|parse_options
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
l_int|0x300
op_le
id|cm206
(braket
id|i
)braket
op_logical_and
id|i
op_le
l_int|0x370
op_logical_and
id|cm206
(braket
id|i
)braket
op_mod
l_int|0x10
op_eq
l_int|0
)paren
(brace
id|cm206_base
op_assign
id|cm206
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|3
op_le
id|cm206
(braket
id|i
)braket
op_logical_and
id|cm206
(braket
id|i
)braket
op_le
l_int|15
)paren
(brace
id|cm206_irq
op_assign
id|cm206
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
DECL|function|__cm206_init
r_int
id|__cm206_init
c_func
(paren
r_void
)paren
(brace
id|parse_options
c_func
(paren
)paren
suffix:semicolon
macro_line|#if !defined(AUTO_PROBE_MODULE)
id|auto_probe
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
id|cm206_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cm206_exit
r_void
id|__exit
id|cm206_exit
c_func
(paren
r_void
)paren
(brace
id|cleanup
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cm206 removed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|__cm206_init
id|module_init
c_func
(paren
id|__cm206_init
)paren
suffix:semicolon
DECL|variable|cm206_exit
id|module_exit
c_func
(paren
id|cm206_exit
)paren
suffix:semicolon
macro_line|#else /* !MODULE */
multiline_comment|/* This setup function accepts either `auto&squot; or numbers in the range&n; * 3--11 (for irq) or 0x300--0x370 (for base port) or both. */
DECL|function|cm206_setup
r_static
r_int
id|__init
id|cm206_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|p
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|s
comma
id|ARRAY_SIZE
c_func
(paren
id|p
)paren
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;auto&quot;
)paren
)paren
id|auto_probe
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|p
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
l_int|0x300
op_le
id|p
(braket
id|i
)braket
op_logical_and
id|i
op_le
l_int|0x370
op_logical_and
id|p
(braket
id|i
)braket
op_mod
l_int|0x10
op_eq
l_int|0
)paren
(brace
id|cm206_base
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|3
op_le
id|p
(braket
id|i
)braket
op_logical_and
id|p
(braket
id|i
)braket
op_le
l_int|15
)paren
(brace
id|cm206_irq
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;cm206=&quot;
comma
id|cm206_setup
)paren
suffix:semicolon
macro_line|#endif /* !MODULE */
multiline_comment|/*&n; * Local variables:&n; * compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -pipe -fno-strength-reduce -m486 -DMODULE -DMODVERSIONS -include /usr/src/linux/include/linux/modversions.h  -c -o cm206.o cm206.c&quot;&n; * End:&n; */
eof
