multiline_comment|/* -- sjcd.c&n; *&n; *   Sanyo CD-ROM device driver implementation, Version 1.6&n; *   Copyright (C) 1995  Vadim V. Model&n; *&n; *   model@cecmow.enet.dec.com&n; *   vadim@rbrf.ru&n; *   vadim@ipsun.ras.ru&n; *&n; *&n; *  This driver is based on pre-works by Eberhard Moenkeberg (emoenke@gwdg.de);&n; *  it was developed under use of mcd.c from Martin Harriss, with help of&n; *  Eric van der Maarel (H.T.M.v.d.Maarel@marin.nl).&n; *&n; *  It is planned to include these routines into sbpcd.c later - to make&n; *  a &quot;mixed use&quot; on one cable possible for all kinds of drives which use&n; *  the SoundBlaster/Panasonic style CDROM interface. But today, the&n; *  ability to install directly from CDROM is more important than flexibility.&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *  History:&n; *  1.1 First public release with kernel version 1.3.7.&n; *      Written by Vadim Model.&n; *  1.2 Added detection and configuration of cdrom interface&n; *      on ISP16 soundcard.&n; *      Allow for command line options: sjcd=&lt;io_base&gt;,&lt;irq&gt;,&lt;dma&gt;&n; *  1.3 Some minor changes to README.sjcd.&n; *  1.4 MSS Sound support!! Listen to a CD through the speakers.&n; *  1.5 Module support and bugfixes.&n; *      Tray locking.&n; *  1.6 Removed ISP16 code from this driver.&n; *      Allow only to set io base address on command line: sjcd=&lt;io_base&gt;&n; *      Changes to Documentation/cdrom/sjcd&n; *      Added cleanup after any error in the initialisation.&n; *  1.7 Added code to set the sector size tables to prevent the bug present in &n; *      the previous version of this driver.  Coded added by Anthony Barbachan &n; *      from bugfix tip originally suggested by Alan Cox.&n; *&n; *  November 1999 -- Make kernel-parameter implementation work with 2.3.x &n; *&t;             Removed init_module &amp; cleanup_module in favor of &n; *&t;             module_init &amp; module_exit.&n; *&t;             Torben Mathiasen &lt;tmm@image.dk&gt;&n; */
DECL|macro|SJCD_VERSION_MAJOR
mdefine_line|#define SJCD_VERSION_MAJOR 1
DECL|macro|SJCD_VERSION_MINOR
mdefine_line|#define SJCD_VERSION_MINOR 7
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR SANYO_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;sjcd.h&quot;
DECL|variable|sjcd_present
r_static
r_int
id|sjcd_present
op_assign
l_int|0
suffix:semicolon
DECL|macro|SJCD_BUF_SIZ
mdefine_line|#define SJCD_BUF_SIZ 32 /* cdr-h94a has internal 64K buffer */
multiline_comment|/*&n; * buffer for block size conversion&n; */
DECL|variable|sjcd_buf
r_static
r_char
id|sjcd_buf
(braket
l_int|2048
op_star
id|SJCD_BUF_SIZ
)braket
suffix:semicolon
DECL|variable|sjcd_buf_bn
DECL|variable|sjcd_next_bn
r_static
r_volatile
r_int
id|sjcd_buf_bn
(braket
id|SJCD_BUF_SIZ
)braket
comma
id|sjcd_next_bn
suffix:semicolon
DECL|variable|sjcd_buf_in
DECL|variable|sjcd_buf_out
r_static
r_volatile
r_int
id|sjcd_buf_in
comma
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Status.&n; */
DECL|variable|sjcd_status_valid
r_static
r_int
r_int
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_door_closed
r_static
r_int
r_int
id|sjcd_door_closed
suffix:semicolon
DECL|variable|sjcd_door_was_open
r_static
r_int
r_int
id|sjcd_door_was_open
suffix:semicolon
DECL|variable|sjcd_media_is_available
r_static
r_int
r_int
id|sjcd_media_is_available
suffix:semicolon
DECL|variable|sjcd_media_is_changed
r_static
r_int
r_int
id|sjcd_media_is_changed
suffix:semicolon
DECL|variable|sjcd_toc_uptodate
r_static
r_int
r_int
id|sjcd_toc_uptodate
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_command_failed
r_static
r_int
r_int
id|sjcd_command_failed
suffix:semicolon
DECL|variable|sjcd_completion_status
r_static
r_volatile
r_int
r_char
id|sjcd_completion_status
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_completion_error
r_static
r_volatile
r_int
r_char
id|sjcd_completion_error
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_command_is_in_progress
r_static
r_int
r_int
id|sjcd_command_is_in_progress
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_error_reported
r_static
r_int
r_int
id|sjcd_error_reported
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_open_count
r_static
r_int
id|sjcd_open_count
suffix:semicolon
DECL|variable|sjcd_audio_status
r_static
r_int
id|sjcd_audio_status
suffix:semicolon
DECL|variable|sjcd_playing
r_static
r_struct
id|sjcd_play_msf
id|sjcd_playing
suffix:semicolon
DECL|variable|sjcd_base
r_static
r_int
id|sjcd_base
op_assign
id|SJCD_BASE_ADDR
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|sjcd_base
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|sjcd_waitq
)paren
suffix:semicolon
multiline_comment|/*&n; * Data transfer.&n; */
DECL|variable|sjcd_transfer_is_active
r_static
r_volatile
r_int
r_int
id|sjcd_transfer_is_active
op_assign
l_int|0
suffix:semicolon
DECL|enum|sjcd_transfer_state
r_enum
id|sjcd_transfer_state
(brace
DECL|enumerator|SJCD_S_IDLE
id|SJCD_S_IDLE
op_assign
l_int|0
comma
DECL|enumerator|SJCD_S_START
id|SJCD_S_START
op_assign
l_int|1
comma
DECL|enumerator|SJCD_S_MODE
id|SJCD_S_MODE
op_assign
l_int|2
comma
DECL|enumerator|SJCD_S_READ
id|SJCD_S_READ
op_assign
l_int|3
comma
DECL|enumerator|SJCD_S_DATA
id|SJCD_S_DATA
op_assign
l_int|4
comma
DECL|enumerator|SJCD_S_STOP
id|SJCD_S_STOP
op_assign
l_int|5
comma
DECL|enumerator|SJCD_S_STOPPING
id|SJCD_S_STOPPING
op_assign
l_int|6
)brace
suffix:semicolon
DECL|variable|sjcd_transfer_state
r_static
r_enum
id|sjcd_transfer_state
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
DECL|variable|sjcd_transfer_timeout
r_static
r_int
id|sjcd_transfer_timeout
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_read_count
r_static
r_int
id|sjcd_read_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_mode
r_static
r_int
r_char
id|sjcd_mode
op_assign
l_int|0
suffix:semicolon
DECL|macro|SJCD_READ_TIMEOUT
mdefine_line|#define SJCD_READ_TIMEOUT 5000
macro_line|#if defined( SJCD_GATHER_STAT )
multiline_comment|/*&n; * Statistic.&n; */
DECL|variable|statistic
r_static
r_struct
id|sjcd_stat
id|statistic
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Timer.&n; */
DECL|variable|sjcd_delay_timer
r_static
r_struct
id|timer_list
id|sjcd_delay_timer
suffix:semicolon
DECL|macro|SJCD_SET_TIMER
mdefine_line|#define SJCD_SET_TIMER( func, tmout )           &bslash;&n;    ( sjcd_delay_timer.expires = jiffies+tmout,         &bslash;&n;      sjcd_delay_timer.function = ( void * )func, &bslash;&n;      add_timer( &amp;sjcd_delay_timer ) )
DECL|macro|CLEAR_TIMER
mdefine_line|#define CLEAR_TIMER del_timer( &amp;sjcd_delay_timer )
r_static
r_int
id|sjcd_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Set up device, i.e., use command line data to set&n; * base address.&n; */
macro_line|#ifndef MODULE
DECL|function|sjcd_setup
r_static
r_int
id|__init
id|sjcd_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|2
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|sjcd_base
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;sjcd=&quot;
comma
id|sjcd_setup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Special converters.&n; */
DECL|function|bin2bcd
r_static
r_int
r_char
(def_block
id|bin2bcd
c_func
(paren
r_int
id|bin
)paren
(brace
r_int
id|u
comma
id|v
suffix:semicolon
id|u
op_assign
id|bin
op_mod
l_int|10
suffix:semicolon
id|v
op_assign
id|bin
op_div
l_int|10
suffix:semicolon
r_return
id|u
op_or
(paren
id|v
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
)def_block
DECL|function|bcd2bin
r_static
r_int
(def_block
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
)def_block
DECL|function|msf2hsg
r_static
r_int
(def_block
id|msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
r_return
id|bcd2bin
c_func
(paren
id|mp-&gt;frame
)paren
op_plus
id|bcd2bin
c_func
(paren
id|mp-&gt;sec
)paren
op_star
l_int|75
op_plus
id|bcd2bin
c_func
(paren
id|mp-&gt;min
)paren
op_star
l_int|4500
op_minus
l_int|150
suffix:semicolon
)brace
)def_block
DECL|function|hsg2msf
r_static
r_void
(def_block
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf-&gt;min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf-&gt;sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf-&gt;frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
id|msf-&gt;min
op_assign
id|bin2bcd
c_func
(paren
id|msf-&gt;min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|msf-&gt;sec
op_assign
id|bin2bcd
c_func
(paren
id|msf-&gt;sec
)paren
suffix:semicolon
id|msf-&gt;frame
op_assign
id|bin2bcd
c_func
(paren
id|msf-&gt;frame
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a command to cdrom. Invalidate status.&n; */
DECL|function|sjcd_send_cmd
r_static
r_void
(def_block
id|sjcd_send_cmd
c_func
(paren
r_int
r_char
id|cmd
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: send_cmd( 0x%x )&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a command with one arg to cdrom. Invalidate status.&n; */
DECL|function|sjcd_send_1_cmd
r_static
r_void
(def_block
id|sjcd_send_1_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
id|a
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: send_1_cmd( 0x%x, 0x%x )&bslash;n&quot;
comma
id|cmd
comma
id|a
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|a
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a command with four args to cdrom. Invalidate status.&n; */
DECL|function|sjcd_send_4_cmd
r_static
r_void
(def_block
id|sjcd_send_4_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
id|a
comma
r_int
r_char
id|b
comma
r_int
r_char
id|c
comma
r_int
r_char
id|d
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: send_4_cmd( 0x%x )&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|a
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|b
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|c
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|d
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a play or read command to cdrom. Invalidate Status.&n; */
DECL|function|sjcd_send_6_cmd
r_static
r_void
(def_block
id|sjcd_send_6_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_struct
id|sjcd_play_msf
op_star
id|pms
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: send_long_cmd( 0x%x )&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;start.min
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;start.sec
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;start.frame
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;end.min
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;end.sec
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;end.frame
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Get a value from the data port. Should not block, so we use a little&n; * wait for a while. Returns 0 if OK.&n; */
DECL|function|sjcd_load_response
r_static
r_int
(def_block
id|sjcd_load_response
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|resp
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
suffix:semicolon
op_decrement
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|200
suffix:semicolon
id|i
op_decrement
op_logical_and
op_logical_neg
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
op_star
id|resp
op_increment
op_assign
(paren
r_int
r_char
)paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Load and parse command completion status (drive info byte and maybe error).&n; * Sorry, no error classification yet.&n; */
DECL|function|sjcd_load_status
r_static
r_void
(def_block
id|sjcd_load_status
c_func
(paren
r_void
)paren
(brace
id|sjcd_media_is_changed
op_assign
l_int|0
suffix:semicolon
id|sjcd_completion_error
op_assign
l_int|0
suffix:semicolon
id|sjcd_completion_status
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_completion_status
op_amp
id|SST_DOOR_OPENED
)paren
(brace
id|sjcd_door_closed
op_assign
id|sjcd_media_is_available
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sjcd_door_closed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_completion_status
op_amp
id|SST_MEDIA_CHANGED
)paren
(brace
id|sjcd_media_is_available
op_assign
id|sjcd_media_is_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sjcd_completion_status
op_amp
l_int|0x0F
)paren
(brace
multiline_comment|/*&n;       * OK, we seem to catch an error ...&n;       */
r_while
c_loop
(paren
op_logical_neg
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
id|sjcd_completion_error
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sjcd_completion_status
op_amp
l_int|0x08
)paren
op_logical_and
(paren
id|sjcd_completion_error
op_amp
l_int|0x40
)paren
)paren
(brace
id|sjcd_media_is_available
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sjcd_command_failed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|sjcd_media_is_available
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Ok, status loaded successfully.&n;   */
id|sjcd_status_valid
op_assign
l_int|1
comma
id|sjcd_error_reported
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * If the disk is changed, the TOC is not valid.&n;   */
r_if
c_cond
(paren
id|sjcd_media_is_changed
)paren
(brace
id|sjcd_toc_uptodate
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: status %02x.%02x loaded.&bslash;n&quot;
comma
(paren
r_int
)paren
id|sjcd_completion_status
comma
(paren
r_int
)paren
id|sjcd_completion_error
)paren
suffix:semicolon
macro_line|#endif
)brace
)def_block
multiline_comment|/*&n; * Read status from cdrom. Check to see if the status is available.&n; */
DECL|function|sjcd_check_status
r_static
r_int
(def_block
id|sjcd_check_status
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;   * Try to load the response from cdrom into buffer.&n;   */
r_if
c_cond
(paren
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
)paren
(brace
id|sjcd_load_status
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * No status is available.&n;     */
r_return
l_int|0
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * This is just timeout counter, and nothing more. Surprised ? :-)&n; */
DECL|variable|sjcd_status_timeout
r_static
r_volatile
r_int
id|sjcd_status_timeout
suffix:semicolon
multiline_comment|/*&n; * We need about 10 seconds to wait. The longest command takes about 5 seconds&n; * to probe the disk (usually after tray closed or drive reset). Other values&n; * should be thought of for other commands.&n; */
DECL|macro|SJCD_WAIT_FOR_STATUS_TIMEOUT
mdefine_line|#define SJCD_WAIT_FOR_STATUS_TIMEOUT 1000
DECL|function|sjcd_status_timer
r_static
r_void
(def_block
id|sjcd_status_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|sjcd_check_status
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;     * The command completed and status is loaded, stop waiting.&n;     */
id|wake_up
c_func
(paren
op_amp
id|sjcd_waitq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_decrement
id|sjcd_status_timeout
op_le
l_int|0
)paren
(brace
multiline_comment|/*&n;     * We are timed out. &n;     */
id|wake_up
c_func
(paren
op_amp
id|sjcd_waitq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * We have still some time to wait. Try again.&n;     */
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_status_timer
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * Wait for status for 10 sec approx. Returns non-positive when timed out.&n; * Should not be used while reading data CDs.&n; */
DECL|function|sjcd_wait_for_status
r_static
r_int
(def_block
id|sjcd_wait_for_status
c_func
(paren
r_void
)paren
(brace
id|sjcd_status_timeout
op_assign
id|SJCD_WAIT_FOR_STATUS_TIMEOUT
suffix:semicolon
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_status_timer
comma
l_int|1
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|sjcd_waitq
)paren
suffix:semicolon
macro_line|#if defined( SJCD_DIAGNOSTIC ) || defined ( SJCD_TRACE )
r_if
c_cond
(paren
id|sjcd_status_timeout
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: Error Wait For Status.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|sjcd_status_timeout
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_receive_status
r_static
r_int
(def_block
id|sjcd_receive_status
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: receive_status&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Wait a bit for status available.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|200
suffix:semicolon
id|i
op_decrement
op_logical_and
(paren
id|sjcd_check_status
c_func
(paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: long wait for status&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sjcd_wait_for_status
c_func
(paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: Timeout when read status.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Load the status. Issue get status command and wait for status available.&n; */
DECL|function|sjcd_get_status
r_static
r_void
(def_block
id|sjcd_get_status
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: get_status&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_STATUS
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Check the drive if the disk is changed. Should be revised.&n; */
DECL|function|sjcd_disk_change
r_static
r_int
(def_block
id|sjcd_disk_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;SJCD: sjcd_disk_change( 0x%x )&bslash;n&quot;
comma
id|full_dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|full_dev
)paren
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: request error: invalid device minor.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_is_in_progress
)paren
(brace
id|sjcd_get_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|sjcd_status_valid
ques
c_cond
id|sjcd_media_is_changed
suffix:colon
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Read the table of contents (TOC) and TOC header if necessary.&n; * We assume that the drive contains no more than 99 toc entries.&n; */
DECL|variable|sjcd_table_of_contents
r_static
r_struct
id|sjcd_hw_disk_info
id|sjcd_table_of_contents
(braket
id|SJCD_MAX_TRACKS
)braket
suffix:semicolon
DECL|variable|sjcd_first_track_no
DECL|variable|sjcd_last_track_no
r_static
r_int
r_char
id|sjcd_first_track_no
comma
id|sjcd_last_track_no
suffix:semicolon
DECL|macro|sjcd_disk_length
mdefine_line|#define sjcd_disk_length  sjcd_table_of_contents[0].un.track_msf
DECL|function|sjcd_update_toc
r_static
r_int
(def_block
id|sjcd_update_toc
c_func
(paren
r_void
)paren
(brace
r_struct
id|sjcd_hw_disk_info
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: update toc:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * check to see if we need to do anything&n;   */
r_if
c_cond
(paren
id|sjcd_toc_uptodate
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Get the TOC start information.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|SCMD_GET_1_TRACK
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load response about TOC start.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_first_track_no
op_assign
id|bcd2bin
c_func
(paren
id|info.un.track_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: get first failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: TOC start 0x%02x &quot;
comma
id|sjcd_first_track_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Get the TOC finish information.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|SCMD_GET_L_TRACK
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load response about TOC finish.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_last_track_no
op_assign
id|bcd2bin
c_func
(paren
id|info.un.track_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: get last failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: TOC finish 0x%02x &quot;
comma
id|sjcd_last_track_no
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
id|sjcd_first_track_no
suffix:semicolon
id|i
op_le
id|sjcd_last_track_no
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;     * Get the first track information.&n;     */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|bin2bcd
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|sjcd_table_of_contents
(braket
id|i
)braket
comma
r_sizeof
(paren
r_struct
id|sjcd_hw_disk_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load info for %d track&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: get info %d failed&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Get the disk length info.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|SCMD_GET_D_SIZE
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot load response about disk size.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_disk_length.min
op_assign
id|info.un.track_msf.min
suffix:semicolon
id|sjcd_disk_length.sec
op_assign
id|info.un.track_msf.sec
suffix:semicolon
id|sjcd_disk_length.frame
op_assign
id|info.un.track_msf.frame
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: get size failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: (%02x:%02x.%02x)&bslash;n&quot;
comma
id|sjcd_disk_length.min
comma
id|sjcd_disk_length.sec
comma
id|sjcd_disk_length.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Load subchannel information.&n; */
DECL|function|sjcd_get_q_info
r_static
r_int
(def_block
id|sjcd_get_q_info
c_func
(paren
r_struct
id|sjcd_hw_qinfo
op_star
id|qp
)paren
(brace
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: load sub q&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_QINFO
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
id|sjcd_command_failed
op_logical_or
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|sjcd_send_cmd
c_func
(paren
l_int|0xF2
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
id|sjcd_command_failed
op_logical_or
op_logical_neg
id|sjcd_status_valid
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_QINFO
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
id|sjcd_command_failed
op_logical_or
op_logical_neg
id|sjcd_status_valid
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sjcd_media_is_available
)paren
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
id|qp
comma
r_sizeof
(paren
op_star
id|qp
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Start playing from the specified position.&n; */
DECL|function|sjcd_play
r_static
r_int
(def_block
id|sjcd_play
c_func
(paren
r_struct
id|sjcd_play_msf
op_star
id|mp
)paren
(brace
r_struct
id|sjcd_play_msf
id|msf
suffix:semicolon
multiline_comment|/*&n;   * Turn the device to play mode.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_SET_MODE
comma
id|SCMD_MODE_PLAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_receive_status
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Seek to the starting point.&n;   */
id|msf.start
op_assign
id|mp-&gt;start
suffix:semicolon
id|msf.end.min
op_assign
id|msf.end.sec
op_assign
id|msf.end.frame
op_assign
l_int|0x00
suffix:semicolon
id|sjcd_send_6_cmd
c_func
(paren
id|SCMD_SEEK
comma
op_amp
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_receive_status
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Start playing.&n;   */
id|sjcd_send_6_cmd
c_func
(paren
id|SCMD_PLAY
comma
id|mp
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Tray control functions.&n; */
DECL|function|sjcd_tray_close
r_static
r_int
(def_block
id|sjcd_tray_close
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: tray_close&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_CLOSE_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_tray_lock
r_static
r_int
(def_block
id|sjcd_tray_lock
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: tray_lock&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_LOCK_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_tray_unlock
r_static
r_int
(def_block
id|sjcd_tray_unlock
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: tray_unlock&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_UNLOCK_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_tray_open
r_static
r_int
(def_block
id|sjcd_tray_open
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: tray_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_EJECT_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Do some user commands.&n; */
DECL|function|sjcd_ioctl
r_static
r_int
(def_block
id|sjcd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD:ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sjcd_get_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_update_toc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: start&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTOP
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: stop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_PAUSE
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
(brace
r_struct
id|sjcd_hw_qinfo
id|q_info
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: pause&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sjcd_audio_status
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_PAUSE
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_get_q_info
c_func
(paren
op_amp
id|q_info
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_else
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
id|sjcd_playing.start
op_assign
id|q_info.abs
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|CDROMRESUME
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: resume&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sjcd_audio_status
op_eq
id|CDROM_AUDIO_PAUSED
)paren
(brace
multiline_comment|/*&n;       * continue play starting at saved location&n;       */
r_if
c_cond
(paren
id|sjcd_play
c_func
(paren
op_amp
id|sjcd_playing
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: playtrkind&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|copy_from_user
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
OL
id|sjcd_first_track_no
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|sjcd_last_track_no
)paren
(brace
id|ti.cdti_trk1
op_assign
id|sjcd_last_track_no
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk0
OG
id|ti.cdti_trk1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sjcd_playing.start
op_assign
id|sjcd_table_of_contents
(braket
id|ti.cdti_trk0
)braket
dot
id|un.track_msf
suffix:semicolon
id|sjcd_playing.end
op_assign
(paren
id|ti.cdti_trk1
OL
id|sjcd_last_track_no
)paren
ques
c_cond
id|sjcd_table_of_contents
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|un.track_msf
suffix:colon
id|sjcd_table_of_contents
(braket
l_int|0
)braket
dot
id|un.track_msf
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_play
c_func
(paren
op_amp
id|sjcd_playing
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|sjcd_msf
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: playmsf&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sjcd_msf
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sjcd_audio_status
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_PAUSE
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
id|copy_from_user
c_func
(paren
op_amp
id|sjcd_msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sjcd_msf
)paren
)paren
suffix:semicolon
id|sjcd_playing.start.min
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_min0
)paren
suffix:semicolon
id|sjcd_playing.start.sec
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_sec0
)paren
suffix:semicolon
id|sjcd_playing.start.frame
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_frame0
)paren
suffix:semicolon
id|sjcd_playing.end.min
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_min1
)paren
suffix:semicolon
id|sjcd_playing.end.sec
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_sec1
)paren
suffix:semicolon
id|sjcd_playing.end.frame
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_frame1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_play
c_func
(paren
op_amp
id|sjcd_playing
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
id|toc_header
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined (SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: readtocheader&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|toc_header
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|toc_header.cdth_trk0
op_assign
id|sjcd_first_track_no
suffix:semicolon
id|toc_header.cdth_trk1
op_assign
id|sjcd_last_track_no
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|toc_header
comma
r_sizeof
(paren
id|toc_header
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
id|toc_entry
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: readtocentry&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|toc_entry
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|sjcd_hw_disk_info
op_star
id|tp
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|toc_entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|toc_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|toc_entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
(brace
id|tp
op_assign
op_amp
id|sjcd_table_of_contents
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|toc_entry.cdte_track
OL
id|sjcd_first_track_no
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|toc_entry.cdte_track
OG
id|sjcd_last_track_no
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|tp
op_assign
op_amp
id|sjcd_table_of_contents
(braket
id|toc_entry.cdte_track
)braket
suffix:semicolon
id|toc_entry.cdte_adr
op_assign
id|tp-&gt;track_control
op_amp
l_int|0x0F
suffix:semicolon
id|toc_entry.cdte_ctrl
op_assign
id|tp-&gt;track_control
op_rshift
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|toc_entry.cdte_format
)paren
(brace
r_case
id|CDROM_LBA
suffix:colon
id|toc_entry.cdte_addr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
(paren
id|tp-&gt;un.track_msf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_MSF
suffix:colon
id|toc_entry.cdte_addr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|tp-&gt;un.track_msf.min
)paren
suffix:semicolon
id|toc_entry.cdte_addr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|tp-&gt;un.track_msf.sec
)paren
suffix:semicolon
id|toc_entry.cdte_addr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|tp-&gt;un.track_msf.frame
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|toc_entry
comma
r_sizeof
(paren
id|toc_entry
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: subchnl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|sjcd_hw_qinfo
id|q_info
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_get_q_info
c_func
(paren
op_amp
id|q_info
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|subchnl.cdsc_audiostatus
op_assign
id|sjcd_audio_status
suffix:semicolon
id|subchnl.cdsc_adr
op_assign
id|q_info.track_control
op_amp
l_int|0x0F
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|q_info.track_control
op_rshift
l_int|4
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|bcd2bin
c_func
(paren
id|q_info.track_no
)paren
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|bcd2bin
c_func
(paren
id|q_info.x
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|subchnl.cdsc_format
)paren
(brace
r_case
id|CDROM_LBA
suffix:colon
id|subchnl.cdsc_absaddr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
(paren
id|q_info.abs
)paren
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
(paren
id|q_info.rel
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_MSF
suffix:colon
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|q_info.abs.min
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|q_info.abs.sec
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|q_info.abs.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|q_info.rel.min
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|q_info.rel.sec
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|q_info.rel.frame
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|vol_ctrl
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: volctrl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vol_ctrl
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_int
r_char
id|dummy
(braket
l_int|4
)braket
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|vol_ctrl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vol_ctrl
)paren
)paren
suffix:semicolon
id|sjcd_send_4_cmd
c_func
(paren
id|SCMD_SET_VOLUME
comma
id|vol_ctrl.channel0
comma
l_int|0xFF
comma
id|vol_ctrl.channel1
comma
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_receive_status
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
(paren
r_void
)paren
id|sjcd_load_response
c_func
(paren
id|dummy
comma
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: eject&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_is_in_progress
)paren
(brace
id|sjcd_tray_unlock
c_func
(paren
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_EJECT_TRAY
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_case
l_int|0xABCD
suffix:colon
(brace
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ioctl: statistic&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|statistic
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|statistic
comma
r_sizeof
(paren
id|statistic
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * Invalidate internal buffers of the driver.&n; */
DECL|function|sjcd_invalidate_buffers
r_static
r_void
(def_block
id|sjcd_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SJCD_BUF_SIZ
suffix:semicolon
id|sjcd_buf_bn
(braket
id|i
op_increment
)braket
op_assign
op_minus
l_int|1
)paren
(brace
suffix:semicolon
)brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
DECL|macro|CURRENT_IS_VALID
mdefine_line|#define CURRENT_IS_VALID                                      &bslash;&n;    ( !QUEUE_EMPTY &amp;&amp; MAJOR( CURRENT-&gt;rq_dev ) == MAJOR_NR &amp;&amp; &bslash;&n;      CURRENT-&gt;cmd == READ &amp;&amp; CURRENT-&gt;sector != -1 )
DECL|function|sjcd_transfer
r_static
r_void
(def_block
id|sjcd_transfer
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: transfer:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
r_while
c_loop
(paren
id|CURRENT-&gt;nr_sectors
)paren
(brace
r_int
id|i
comma
id|bn
op_assign
id|CURRENT-&gt;sector
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SJCD_BUF_SIZ
op_logical_and
id|sjcd_buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
id|i
op_increment
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|SJCD_BUF_SIZ
)paren
(brace
r_int
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT-&gt;sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
r_int
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT-&gt;sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_buf_out
op_ne
id|i
)paren
(brace
id|sjcd_buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|nr_sectors
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: copy out&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|sjcd_buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: transfer: done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)def_block
DECL|function|sjcd_poll
r_static
r_void
(def_block
id|sjcd_poll
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_GATHER_STAT )
multiline_comment|/*&n;   * Update total number of ticks.&n;   */
id|statistic.ticks
op_increment
suffix:semicolon
id|statistic.tticks
(braket
id|sjcd_transfer_state
)braket
op_increment
suffix:semicolon
macro_line|#endif
id|ReSwitch
suffix:colon
r_switch
c_cond
(paren
id|sjcd_transfer_state
)paren
(brace
r_case
id|SJCD_S_IDLE
suffix:colon
(brace
macro_line|#if defined( SJCD_GATHER_STAT )
id|statistic.idle_ticks
op_increment
suffix:semicolon
macro_line|#endif
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_IDLE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_case
id|SJCD_S_START
suffix:colon
(brace
macro_line|#if defined( SJCD_GATHER_STAT )
id|statistic.start_ticks
op_increment
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_STATUS
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|sjcd_mode
op_eq
id|SCMD_MODE_COOKED
ques
c_cond
id|SJCD_S_READ
suffix:colon
id|SJCD_S_MODE
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_START: goto SJCD_S_%s mode&bslash;n&quot;
comma
id|sjcd_transfer_state
op_eq
id|SJCD_S_READ
ques
c_cond
l_string|&quot;READ&quot;
suffix:colon
l_string|&quot;MODE&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_MODE
suffix:colon
(brace
r_if
c_cond
(paren
id|sjcd_check_status
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;       * Previous command is completed.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_MODE: pre-cmd failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
id|sjcd_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unknown mode; should not be valid when failed */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_SET_MODE
comma
id|SCMD_MODE_COOKED
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_READ
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|1000
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_MODE: goto SJCD_S_READ mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.mode_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_READ
suffix:colon
(brace
r_if
c_cond
(paren
id|sjcd_status_valid
ques
c_cond
l_int|1
suffix:colon
id|sjcd_check_status
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;       * Previous command is completed.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: pre-cmd failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: no disk: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_mode
op_ne
id|SCMD_MODE_COOKED
)paren
(brace
multiline_comment|/*&n;&t; * We seem to come from set mode. So discard one byte of result.&n;&t; */
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|sjcd_mode
comma
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: load failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_mode
op_ne
id|SCMD_MODE_COOKED
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: mode failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
r_struct
id|sjcd_play_msf
id|msf
suffix:semicolon
id|sjcd_next_bn
op_assign
id|CURRENT-&gt;sector
op_div
l_int|4
suffix:semicolon
id|hsg2msf
c_func
(paren
id|sjcd_next_bn
comma
op_amp
id|msf.start
)paren
suffix:semicolon
id|msf.end.min
op_assign
l_int|0
suffix:semicolon
id|msf.end.sec
op_assign
l_int|0
suffix:semicolon
id|msf.end.frame
op_assign
id|sjcd_read_count
op_assign
id|SJCD_BUF_SIZ
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: ---reading msf-address %x:%x:%x  %x:%x:%x&bslash;n&quot;
comma
id|msf.start.min
comma
id|msf.start.sec
comma
id|msf.start.frame
comma
id|msf.end.min
comma
id|msf.end.sec
comma
id|msf.end.frame
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sjcd_next_bn:%x buf_in:%x buf_out:%x buf_bn:%x&bslash;n&quot;
comma
"&bslash;"
id|sjcd_next_bn
comma
id|sjcd_buf_in
comma
id|sjcd_buf_out
comma
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif&t;
id|sjcd_send_6_cmd
c_func
(paren
id|SCMD_DATA_READ
comma
op_amp
id|msf
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_DATA
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: go to SJCD_S_DATA mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: nothing to read: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.read_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_DATA
suffix:colon
(brace
r_int
r_char
id|stat
suffix:semicolon
id|sjcd_s_data
suffix:colon
id|stat
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: status = 0x%02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
multiline_comment|/*&n;       * No data is waiting for us in the drive buffer. Status of operation&n;       * completion is available. Read and parse it.&n;       */
id|sjcd_load_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: read block %d failed, maybe audio disk? Giving up&bslash;n&quot;
comma
id|sjcd_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: pre-cmd failed: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: no disk: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
id|sjcd_transfer_state
op_assign
id|SJCD_S_READ
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SJCD_DATA_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
multiline_comment|/*&n;       * One frame is read into device buffer. We must copy it to our memory.&n;       * Otherwise cdrom hangs up. Check to see if we have something to copy&n;       * to.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_IS_VALID
op_logical_and
id|sjcd_buf_in
op_eq
id|sjcd_buf_out
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: nothing to read: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; ... all the date would be discarded&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
multiline_comment|/*&n;       * Everything seems to be OK. Just read the frame and recalculate&n;       * indices.&n;       */
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ??? */
id|insb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|2
)paren
comma
id|sjcd_buf
op_plus
l_int|2048
op_star
id|sjcd_buf_in
comma
l_int|2048
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: next_bn=%d, buf_in=%d, buf_out=%d, buf_bn=%d&bslash;n&quot;
comma
id|sjcd_next_bn
comma
id|sjcd_buf_in
comma
id|sjcd_buf_out
comma
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
op_assign
id|sjcd_next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_buf_out
op_eq
op_minus
l_int|1
)paren
(brace
id|sjcd_buf_out
op_assign
id|sjcd_buf_in
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|sjcd_buf_in
op_eq
id|SJCD_BUF_SIZ
)paren
(brace
id|sjcd_buf_in
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;       * Only one frame is ready at time. So we should turn over to wait for&n;       * another frame. If we need that, of course.&n;       */
r_if
c_cond
(paren
op_decrement
id|sjcd_read_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t; * OK, request seems to be precessed. Continue transferring...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
multiline_comment|/*&n;&t;     * Continue transferring.&n;&t;     */
id|sjcd_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_IS_VALID
op_logical_and
(paren
id|CURRENT-&gt;sector
op_div
l_int|4
template_param
id|sjcd_next_bn
op_plus
id|SJCD_BUF_SIZ
)paren
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: can&squot;t read: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;       * Now we should turn around rather than wait for while.&n;       */
r_goto
id|sjcd_s_data
suffix:semicolon
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.data_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_STOP
suffix:colon
(brace
id|sjcd_read_count
op_assign
l_int|0
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_STOP
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOPPING
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
macro_line|#if defined( SJCD_GATHER_STAT )
id|statistic.stop_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_STOPPING
suffix:colon
(brace
r_int
r_char
id|stat
suffix:semicolon
id|stat
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_STOP: status = 0x%02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
macro_line|#endif      
r_if
c_cond
(paren
id|SJCD_DATA_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_STOP: discard data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;       * Discard all the data from the pipe. Foolish method.&n;       */
r_for
c_loop
(paren
id|i
op_assign
l_int|2048
suffix:semicolon
id|i
op_decrement
suffix:semicolon
(paren
r_void
)paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|2
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
id|sjcd_load_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_status_valid
op_logical_and
id|sjcd_media_is_changed
)paren
(brace
id|sjcd_toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|sjcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
r_if
c_cond
(paren
id|sjcd_status_valid
)paren
(brace
id|sjcd_transfer_state
op_assign
id|SJCD_S_READ
suffix:semicolon
)brace
r_else
id|sjcd_transfer_state
op_assign
id|SJCD_S_START
suffix:semicolon
)brace
r_else
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.stopping_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SJCD: poll: invalid state %d&bslash;n&quot;
comma
id|sjcd_transfer_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|sjcd_transfer_timeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: timeout in state %d&bslash;n&quot;
comma
id|sjcd_transfer_state
)paren
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_STOP
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
multiline_comment|/*&n;   * Get back in some time. 1 should be replaced with count variable to&n;   * avoid unnecessary testings.&n;   */
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_poll
comma
l_int|1
)paren
suffix:semicolon
)brace
)def_block
DECL|function|do_sjcd_request
r_static
r_void
(def_block
id|do_sjcd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: do_sjcd_request(%ld+%ld)&bslash;n&quot;
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
multiline_comment|/*&n;     * Who of us are paranoiac?&n;     */
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|sjcd_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Want to read a block not in buffer */
r_if
c_cond
(paren
id|sjcd_transfer_state
op_eq
id|SJCD_S_IDLE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_toc_uptodate
)paren
(brace
r_if
c_cond
(paren
id|sjcd_update_toc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: transfer: discard&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|sjcd_transfer_state
op_assign
id|SJCD_S_START
suffix:semicolon
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_poll
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|sjcd_transfer_is_active
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd_next_bn:%x sjcd_buf_in:%x sjcd_buf_out:%x sjcd_buf_bn:%x&bslash;n&quot;
comma
id|sjcd_next_bn
comma
id|sjcd_buf_in
comma
id|sjcd_buf_out
comma
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;do_sjcd_request ends&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)def_block
multiline_comment|/*&n; * Open the device special file. Check disk is in.&n; */
DECL|function|sjcd_open
r_int
(def_block
id|sjcd_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
multiline_comment|/*&n;   * Check the presence of device.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_present
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;   * Only read operations are allowed. Really? (:-)&n;   */
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_open_count
op_eq
l_int|0
)paren
(brace
r_int
id|s
comma
id|sjcd_open_tries
suffix:semicolon
multiline_comment|/* We don&squot;t know that, do we? */
multiline_comment|/*&n;    sjcd_audio_status = CDROM_AUDIO_NO_STATUS;&n;*/
id|sjcd_mode
op_assign
l_int|0
suffix:semicolon
id|sjcd_door_was_open
op_assign
l_int|0
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
id|sjcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Strict status checking.&n;     */
r_for
c_loop
(paren
id|sjcd_open_tries
op_assign
l_int|4
suffix:semicolon
op_decrement
id|sjcd_open_tries
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|sjcd_get_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;SJCD: open: timed out when check status.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|err_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;SJCD: open: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|sjcd_door_closed
)paren
(brace
id|sjcd_door_was_open
op_assign
l_int|1
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: open: close the tray&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|s
op_assign
id|sjcd_tray_close
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;SJCD: open: tray close attempt failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|err_out
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
r_goto
id|err_out
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|s
op_assign
id|sjcd_tray_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;SJCD: open: tray lock attempt failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|err_out
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: open: done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
op_increment
id|sjcd_open_count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * On close, we flush all sjcd blocks from the buffer cache.&n; */
DECL|function|sjcd_release
r_static
r_int
(def_block
id|sjcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_decrement
id|sjcd_open_count
op_eq
l_int|0
)paren
(brace
id|sjcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_tray_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;SJCD: release: tray unlock attempt failed.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|sjcd_door_was_open
)paren
(brace
id|s
op_assign
id|sjcd_tray_open
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;SJCD: release: tray unload attempt failed.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * A list of file operations allowed for this cdrom.&n; */
DECL|variable|sjcd_fops
r_static
r_struct
id|block_device_operations
id|sjcd_fops
op_assign
(brace
id|open
suffix:colon
id|sjcd_open
comma
id|release
suffix:colon
id|sjcd_release
comma
id|ioctl
suffix:colon
id|sjcd_ioctl
comma
id|check_media_change
suffix:colon
id|sjcd_disk_change
comma
)brace
suffix:semicolon
DECL|variable|blksize
r_static
r_int
id|blksize
op_assign
l_int|2048
suffix:semicolon
DECL|variable|secsize
r_static
r_int
id|secsize
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/*&n; * Following stuff is intended for initialization of the cdrom. It&n; * first looks for presence of device. If the device is present, it&n; * will be reset. Then read the version of the drive and load status.&n; * The version is two BCD-coded bytes.&n; */
r_static
r_struct
(brace
DECL|member|major
DECL|member|minor
r_int
r_char
id|major
comma
id|minor
suffix:semicolon
DECL|variable|sjcd_version
)brace
id|sjcd_version
suffix:semicolon
multiline_comment|/*&n; * Test for presence of drive and initialize it. Called at boot time.&n; * Probe cdrom, find out version and status.&n; */
DECL|function|sjcd_init
r_int
id|__init
(def_block
id|sjcd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SJCD: Sanyo CDR-H94A cdrom driver version %d.%d.&bslash;n&quot;
comma
id|SJCD_VERSION_MAJOR
comma
id|SJCD_VERSION_MINOR
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD: sjcd=0x%x: &quot;
comma
id|sjcd_base
)paren
suffix:semicolon
macro_line|#endif  
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|secsize
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|blksize
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;sjcd&quot;
comma
op_amp
id|sjcd_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: Unable to get major %d for Sanyo CD-ROM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
comma
l_int|1
comma
op_amp
id|sjcd_fops
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|sjcd_base
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: Init failed, I/O port (%X) is already in use&bslash;n&quot;
comma
id|sjcd_base
)paren
suffix:semicolon
id|sjcd_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check for card. Since we are booting now, we can&squot;t use standard&n;   * wait algorithm.&n;   */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SJCD: Resetting: &quot;
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_RESET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|sjcd_status_valid
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
r_int
id|timer
suffix:semicolon
multiline_comment|/*&n;     * Wait 10ms approx.&n;     */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
suffix:semicolon
id|time_before_eq
c_func
(paren
id|jiffies
comma
id|timer
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_check_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|sjcd_command_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; reset failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
id|sjcd_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Get and print out cdrom version.&n;   */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SJCD: Getting version: &quot;
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_VERSION
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|sjcd_status_valid
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
r_int
id|timer
suffix:semicolon
multiline_comment|/*&n;     * Wait 10ms approx.&n;     */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
suffix:semicolon
id|time_before_eq
c_func
(paren
id|jiffies
comma
id|timer
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_check_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|sjcd_command_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; get version failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
id|sjcd_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|sjcd_version
comma
r_sizeof
(paren
id|sjcd_version
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %1x.%02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|sjcd_version.major
comma
(paren
r_int
)paren
id|sjcd_version.minor
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; read version failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
id|sjcd_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check and print out the tray state. (if it is needed?).&n;   */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SJCD: Getting status: &quot;
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_STATUS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|sjcd_status_valid
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
r_int
id|timer
suffix:semicolon
multiline_comment|/*&n;       * Wait 10ms approx.&n;       */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
suffix:semicolon
id|time_before_eq
c_func
(paren
id|jiffies
comma
id|timer
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_check_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|sjcd_command_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; get status failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
id|sjcd_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SJCD: Status: port=0x%x.&bslash;n&quot;
comma
id|sjcd_base
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;sjcd&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFBLK
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
op_amp
id|sjcd_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|sjcd_present
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
r_static
r_int
DECL|function|sjcd_cleanup
id|sjcd_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;sjcd&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD: cannot unregister device.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|sjcd_base
comma
l_int|4
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sjcd_exit
r_void
id|__exit
id|sjcd_exit
c_func
(paren
r_void
)paren
(brace
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;sjcd&quot;
comma
l_int|0
comma
l_int|0
comma
id|DEVFS_SPECIAL_BLK
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_cleanup
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;SJCD: module: cannot be removed.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SJCD: module: removed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|sjcd_init
id|module_init
c_func
(paren
id|sjcd_init
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|sjcd_exit
id|module_exit
c_func
(paren
id|sjcd_exit
)paren
suffix:semicolon
eof
