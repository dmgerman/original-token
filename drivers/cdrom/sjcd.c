multiline_comment|/* -- sjcd.c&n; *&n; *   Sanyo CD-ROM device driver implementation, Version 1.5&n; *   Copyright (C) 1995  Vadim V. Model&n; *&n; *   model@cecmow.enet.dec.com&n; *   vadim@rbrf.ru&n; *   vadim@ipsun.ras.ru&n; *&n; *   ISP16 detection and configuration.&n; *   Copyright (C) 1995  Eric van der Maarel (maarel@marin.nl)&n; *                   and Vadim Model (vadim@cecmow.enet.dec.com)&n; *&n; *&n; *  This driver is based on pre-works by Eberhard Moenkeberg (emoenke@gwdg.de);&n; *  it was developed under use of mcd.c from Martin Harriss, with help of&n; *  Eric van der Maarel (maarel@marin.nl).&n; *&n; *  ISP16 detection and configuration by Eric van der Maarel (maarel@marin.nl).&n; *  Sound configuration by Vadim V. Model (model@cecmow.enet.dec.com)&n; *&n; *  It is planned to include these routines into sbpcd.c later - to make&n; *  a &quot;mixed use&quot; on one cable possible for all kinds of drives which use&n; *  the SoundBlaster/Panasonic style CDROM interface. But today, the&n; *  ability to install directly from CDROM is more important than flexibility.&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *  History:&n; *  1.1 First public release with kernel version 1.3.7.&n; *      Written by Vadim Model.&n; *  1.2 Added detection and configuration of cdrom interface&n; *      on ISP16 soundcard.&n; *      Allow for command line options: sjcd=&lt;io_base&gt;,&lt;irq&gt;,&lt;dma&gt;&n; *  1.3 Some minor changes to README.sjcd.&n; *  1.4 MSS Sound support!! Listen to a CD through the speakers.&n; *  1.5 Module support and bugfixes.&n; *      Tray locking.&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR SANYO_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/sjcd.h&gt;
multiline_comment|/* Some (Media)Magic */
multiline_comment|/* define types of drive the interface on an ISP16 card may be looking at */
DECL|macro|ISP16_DRIVE_X
mdefine_line|#define ISP16_DRIVE_X 0x00
DECL|macro|ISP16_SONY
mdefine_line|#define ISP16_SONY  0x02
DECL|macro|ISP16_PANASONIC0
mdefine_line|#define ISP16_PANASONIC0 0x02
DECL|macro|ISP16_SANYO0
mdefine_line|#define ISP16_SANYO0 0x02
DECL|macro|ISP16_MITSUMI
mdefine_line|#define ISP16_MITSUMI  0x04
DECL|macro|ISP16_PANASONIC1
mdefine_line|#define ISP16_PANASONIC1 0x06
DECL|macro|ISP16_SANYO1
mdefine_line|#define ISP16_SANYO1 0x06
DECL|macro|ISP16_DRIVE_NOT_USED
mdefine_line|#define ISP16_DRIVE_NOT_USED 0x08  /* not used */
DECL|macro|ISP16_DRIVE_SET_MASK
mdefine_line|#define ISP16_DRIVE_SET_MASK 0xF1  /* don&squot;t change 0-bit or 4-7-bits*/
multiline_comment|/* ...for port */
DECL|macro|ISP16_DRIVE_SET_PORT
mdefine_line|#define ISP16_DRIVE_SET_PORT 0xF8D
multiline_comment|/* set io parameters */
DECL|macro|ISP16_BASE_340
mdefine_line|#define ISP16_BASE_340  0x00
DECL|macro|ISP16_BASE_330
mdefine_line|#define ISP16_BASE_330  0x40
DECL|macro|ISP16_BASE_360
mdefine_line|#define ISP16_BASE_360  0x80
DECL|macro|ISP16_BASE_320
mdefine_line|#define ISP16_BASE_320  0xC0
DECL|macro|ISP16_IRQ_X
mdefine_line|#define ISP16_IRQ_X  0x00
DECL|macro|ISP16_IRQ_5
mdefine_line|#define ISP16_IRQ_5  0x04  /* shouldn&squot;t be used due to soundcard conflicts */
DECL|macro|ISP16_IRQ_7
mdefine_line|#define ISP16_IRQ_7  0x08  /* shouldn&squot;t be used due to soundcard conflicts */
DECL|macro|ISP16_IRQ_3
mdefine_line|#define ISP16_IRQ_3  0x0C
DECL|macro|ISP16_IRQ_9
mdefine_line|#define ISP16_IRQ_9  0x10
DECL|macro|ISP16_IRQ_10
mdefine_line|#define ISP16_IRQ_10  0x14
DECL|macro|ISP16_IRQ_11
mdefine_line|#define ISP16_IRQ_11  0x18
DECL|macro|ISP16_DMA_X
mdefine_line|#define ISP16_DMA_X  0x03
DECL|macro|ISP16_DMA_3
mdefine_line|#define ISP16_DMA_3  0x00
DECL|macro|ISP16_DMA_5
mdefine_line|#define ISP16_DMA_5  0x00
DECL|macro|ISP16_DMA_6
mdefine_line|#define ISP16_DMA_6  0x01
DECL|macro|ISP16_DMA_7
mdefine_line|#define ISP16_DMA_7  0x02
DECL|macro|ISP16_IO_SET_MASK
mdefine_line|#define ISP16_IO_SET_MASK  0x20  /* don&squot;t change 5-bit */
multiline_comment|/* ...for port */
DECL|macro|ISP16_IO_SET_PORT
mdefine_line|#define ISP16_IO_SET_PORT  0xF8E
multiline_comment|/* enable the card */
DECL|macro|ISP16_C928__ENABLE_PORT
mdefine_line|#define ISP16_C928__ENABLE_PORT  0xF90  /* ISP16 with OPTi 82C928 chip */
DECL|macro|ISP16_C929__ENABLE_PORT
mdefine_line|#define ISP16_C929__ENABLE_PORT  0xF91  /* ISP16 with OPTi 82C929 chip */
DECL|macro|ISP16_ENABLE_CDROM
mdefine_line|#define ISP16_ENABLE_CDROM  0x80  /* seven bit */
multiline_comment|/* the magic stuff */
DECL|macro|ISP16_CTRL_PORT
mdefine_line|#define ISP16_CTRL_PORT  0xF8F
DECL|macro|ISP16_C928__CTRL
mdefine_line|#define ISP16_C928__CTRL  0xE2  /* ISP16 with OPTi 82C928 chip */
DECL|macro|ISP16_C929__CTRL
mdefine_line|#define ISP16_C929__CTRL  0xE3  /* ISP16 with OPTi 82C929 chip */
r_static
r_int
id|isp16_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|isp16_c928__detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|isp16_c929__detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|isp16_cdi_config
c_func
(paren
r_int
id|base
comma
id|u_char
id|drive_type
comma
r_int
id|irq
comma
r_int
id|dma
)paren
suffix:semicolon
r_static
r_void
id|isp16_sound_config
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|isp16_type
r_static
r_int
id|isp16_type
suffix:semicolon
multiline_comment|/* dependent on type of interface card */
DECL|variable|isp16_ctrl
r_static
id|u_char
id|isp16_ctrl
suffix:semicolon
DECL|variable|isp16_enable_port
r_static
id|u_short
id|isp16_enable_port
suffix:semicolon
DECL|variable|sjcd_present
r_static
r_int
id|sjcd_present
op_assign
l_int|0
suffix:semicolon
DECL|variable|special_mask
r_static
id|u_char
id|special_mask
op_assign
l_int|0
suffix:semicolon
DECL|variable|defaults
r_static
r_int
r_char
id|defaults
(braket
l_int|16
)braket
op_assign
(brace
l_int|0xA8
comma
l_int|0xA8
comma
l_int|0x18
comma
l_int|0x18
comma
l_int|0x18
comma
l_int|0x18
comma
l_int|0x8E
comma
l_int|0x8E
comma
l_int|0x03
comma
l_int|0x00
comma
l_int|0x02
comma
l_int|0x00
comma
l_int|0x0A
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
DECL|macro|SJCD_BUF_SIZ
mdefine_line|#define SJCD_BUF_SIZ 32 /* cdr-h94a has internal 64K buffer */
multiline_comment|/*&n; * buffer for block size conversion&n; */
DECL|variable|sjcd_buf
r_static
r_char
id|sjcd_buf
(braket
l_int|2048
op_star
id|SJCD_BUF_SIZ
)braket
suffix:semicolon
DECL|variable|sjcd_buf_bn
DECL|variable|sjcd_next_bn
r_static
r_volatile
r_int
id|sjcd_buf_bn
(braket
id|SJCD_BUF_SIZ
)braket
comma
id|sjcd_next_bn
suffix:semicolon
DECL|variable|sjcd_buf_in
DECL|variable|sjcd_buf_out
r_static
r_volatile
r_int
id|sjcd_buf_in
comma
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Status.&n; */
DECL|variable|sjcd_status_valid
r_static
r_int
r_int
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_door_closed
r_static
r_int
r_int
id|sjcd_door_closed
suffix:semicolon
DECL|variable|sjcd_door_was_open
r_static
r_int
r_int
id|sjcd_door_was_open
suffix:semicolon
DECL|variable|sjcd_media_is_available
r_static
r_int
r_int
id|sjcd_media_is_available
suffix:semicolon
DECL|variable|sjcd_media_is_changed
r_static
r_int
r_int
id|sjcd_media_is_changed
suffix:semicolon
DECL|variable|sjcd_toc_uptodate
r_static
r_int
r_int
id|sjcd_toc_uptodate
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_command_failed
r_static
r_int
r_int
id|sjcd_command_failed
suffix:semicolon
DECL|variable|sjcd_completion_status
r_static
r_volatile
r_int
r_char
id|sjcd_completion_status
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_completion_error
r_static
r_volatile
r_int
r_char
id|sjcd_completion_error
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_command_is_in_progress
r_static
r_int
r_int
id|sjcd_command_is_in_progress
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_error_reported
r_static
r_int
r_int
id|sjcd_error_reported
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_open_count
r_static
r_int
id|sjcd_open_count
suffix:semicolon
DECL|variable|sjcd_audio_status
r_static
r_int
id|sjcd_audio_status
suffix:semicolon
DECL|variable|sjcd_playing
r_static
r_struct
id|sjcd_play_msf
id|sjcd_playing
suffix:semicolon
DECL|variable|sjcd_port
r_static
r_int
id|sjcd_port
op_assign
id|SJCD_BASE_ADDR
suffix:semicolon
DECL|variable|sjcd_irq
r_static
r_int
id|sjcd_irq
op_assign
id|SJCD_INTR_NR
suffix:semicolon
DECL|variable|sjcd_dma
r_static
r_int
id|sjcd_dma
op_assign
id|SJCD_DMA_NR
suffix:semicolon
DECL|variable|sjcd_waitq
r_static
r_struct
id|wait_queue
op_star
id|sjcd_waitq
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Data transfer.&n; */
DECL|variable|sjcd_transfer_is_active
r_static
r_volatile
r_int
r_int
id|sjcd_transfer_is_active
op_assign
l_int|0
suffix:semicolon
DECL|enum|sjcd_transfer_state
r_enum
id|sjcd_transfer_state
(brace
DECL|enumerator|SJCD_S_IDLE
id|SJCD_S_IDLE
op_assign
l_int|0
comma
DECL|enumerator|SJCD_S_START
id|SJCD_S_START
op_assign
l_int|1
comma
DECL|enumerator|SJCD_S_MODE
id|SJCD_S_MODE
op_assign
l_int|2
comma
DECL|enumerator|SJCD_S_READ
id|SJCD_S_READ
op_assign
l_int|3
comma
DECL|enumerator|SJCD_S_DATA
id|SJCD_S_DATA
op_assign
l_int|4
comma
DECL|enumerator|SJCD_S_STOP
id|SJCD_S_STOP
op_assign
l_int|5
comma
DECL|enumerator|SJCD_S_STOPPING
id|SJCD_S_STOPPING
op_assign
l_int|6
)brace
suffix:semicolon
DECL|variable|sjcd_transfer_state
r_static
r_enum
id|sjcd_transfer_state
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
DECL|variable|sjcd_transfer_timeout
r_static
r_int
id|sjcd_transfer_timeout
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_read_count
r_static
r_int
id|sjcd_read_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|sjcd_mode
r_static
r_int
r_char
id|sjcd_mode
op_assign
l_int|0
suffix:semicolon
DECL|macro|SJCD_READ_TIMEOUT
mdefine_line|#define SJCD_READ_TIMEOUT 5000
macro_line|#if defined( SJCD_GATHER_STAT )
multiline_comment|/*&n; * Statistic.&n; */
DECL|variable|statistic
r_static
r_struct
id|sjcd_stat
id|statistic
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Timer.&n; */
DECL|variable|sjcd_delay_timer
r_static
r_struct
id|timer_list
id|sjcd_delay_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|SJCD_SET_TIMER
mdefine_line|#define SJCD_SET_TIMER( func, tmout )           &bslash;&n;    ( sjcd_delay_timer.expires = jiffies+tmout,         &bslash;&n;      sjcd_delay_timer.function = ( void * )func, &bslash;&n;      add_timer( &amp;sjcd_delay_timer ) )
DECL|macro|CLEAR_TIMER
mdefine_line|#define CLEAR_TIMER del_timer( &amp;sjcd_delay_timer )
multiline_comment|/*&n; * Set up device, i.e., use command line data to set&n; * base address, irq and dma.&n; */
DECL|function|sjcd_setup
r_void
id|sjcd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|sjcd_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|sjcd_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|sjcd_dma
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Special converters.&n; */
DECL|function|bin2bcd
r_static
r_int
r_char
(def_block
id|bin2bcd
c_func
(paren
r_int
id|bin
)paren
(brace
r_int
id|u
comma
id|v
suffix:semicolon
id|u
op_assign
id|bin
op_mod
l_int|10
suffix:semicolon
id|v
op_assign
id|bin
op_div
l_int|10
suffix:semicolon
r_return
id|u
op_or
(paren
id|v
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
)def_block
DECL|function|bcd2bin
r_static
r_int
(def_block
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
)def_block
DECL|function|msf2hsg
r_static
r_int
(def_block
id|msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
r_return
id|bcd2bin
c_func
(paren
id|mp-&gt;frame
)paren
op_plus
id|bcd2bin
c_func
(paren
id|mp-&gt;sec
)paren
op_star
l_int|75
op_plus
id|bcd2bin
c_func
(paren
id|mp-&gt;min
)paren
op_star
l_int|4500
op_minus
l_int|150
suffix:semicolon
)brace
)def_block
DECL|function|hsg2msf
r_static
r_void
(def_block
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf-&gt;min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf-&gt;sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf-&gt;frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
id|msf-&gt;min
op_assign
id|bin2bcd
c_func
(paren
id|msf-&gt;min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|msf-&gt;sec
op_assign
id|bin2bcd
c_func
(paren
id|msf-&gt;sec
)paren
suffix:semicolon
id|msf-&gt;frame
op_assign
id|bin2bcd
c_func
(paren
id|msf-&gt;frame
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a command to cdrom. Invalidate status.&n; */
DECL|function|sjcd_send_cmd
r_static
r_void
(def_block
id|sjcd_send_cmd
c_func
(paren
r_int
r_char
id|cmd
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: send_cmd( 0x%x )&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a command with one arg to cdrom. Invalidate status.&n; */
DECL|function|sjcd_send_1_cmd
r_static
r_void
(def_block
id|sjcd_send_1_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
id|a
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: send_1_cmd( 0x%x, 0x%x )&bslash;n&quot;
comma
id|cmd
comma
id|a
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|a
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a command with four args to cdrom. Invalidate status.&n; */
DECL|function|sjcd_send_4_cmd
r_static
r_void
(def_block
id|sjcd_send_4_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
id|a
comma
r_int
r_char
id|b
comma
r_int
r_char
id|c
comma
r_int
r_char
id|d
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: send_4_cmd( 0x%x )&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|a
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|b
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|c
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|d
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Send a play or read command to cdrom. Invalidate Status.&n; */
DECL|function|sjcd_send_6_cmd
r_static
r_void
(def_block
id|sjcd_send_6_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_struct
id|sjcd_play_msf
op_star
id|pms
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: send_long_cmd( 0x%x )&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|cmd
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;start.min
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;start.sec
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;start.frame
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;end.min
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;end.sec
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|pms-&gt;end.frame
comma
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|1
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_failed
op_assign
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Get a value from the data port. Should not block, so we use a little&n; * wait for a while. Returns 0 if OK.&n; */
DECL|function|sjcd_load_response
r_static
r_int
(def_block
id|sjcd_load_response
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|resp
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
suffix:semicolon
op_decrement
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|200
suffix:semicolon
id|i
op_decrement
op_logical_and
op_logical_neg
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
op_star
id|resp
op_increment
op_assign
(paren
r_int
r_char
)paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Load and parse command completion status (drive info byte and maybe error).&n; * Sorry, no error classification yet.&n; */
DECL|function|sjcd_load_status
r_static
r_void
(def_block
id|sjcd_load_status
c_func
(paren
r_void
)paren
(brace
id|sjcd_media_is_changed
op_assign
l_int|0
suffix:semicolon
id|sjcd_completion_error
op_assign
l_int|0
suffix:semicolon
id|sjcd_completion_status
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_completion_status
op_amp
id|SST_DOOR_OPENED
)paren
(brace
id|sjcd_door_closed
op_assign
id|sjcd_media_is_available
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sjcd_door_closed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_completion_status
op_amp
id|SST_MEDIA_CHANGED
)paren
(brace
id|sjcd_media_is_available
op_assign
id|sjcd_media_is_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sjcd_completion_status
op_amp
l_int|0x0F
)paren
(brace
multiline_comment|/*&n;       * OK, we seem to catch an error ...&n;       */
r_while
c_loop
(paren
op_logical_neg
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
id|sjcd_completion_error
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sjcd_completion_status
op_amp
l_int|0x08
)paren
op_logical_and
(paren
id|sjcd_completion_error
op_amp
l_int|0x40
)paren
)paren
(brace
id|sjcd_media_is_available
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sjcd_command_failed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|sjcd_media_is_available
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Ok, status loaded successfully.&n;   */
id|sjcd_status_valid
op_assign
l_int|1
comma
id|sjcd_error_reported
op_assign
l_int|0
suffix:semicolon
id|sjcd_command_is_in_progress
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * If the disk is changed, the TOC is not valid.&n;   */
r_if
c_cond
(paren
id|sjcd_media_is_changed
)paren
(brace
id|sjcd_toc_uptodate
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: status %02x.%02x loaded.&bslash;n&quot;
comma
(paren
r_int
)paren
id|sjcd_completion_status
comma
(paren
r_int
)paren
id|sjcd_completion_error
)paren
suffix:semicolon
macro_line|#endif
)brace
)def_block
multiline_comment|/*&n; * Read status from cdrom. Check to see if the status is available.&n; */
DECL|function|sjcd_check_status
r_static
r_int
(def_block
id|sjcd_check_status
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;   * Try to load the response from cdrom into buffer.&n;   */
r_if
c_cond
(paren
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
)paren
(brace
id|sjcd_load_status
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * No status is available.&n;     */
r_return
l_int|0
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * This is just timout counter, and nothing more. Surprized ? :-)&n; */
DECL|variable|sjcd_status_timeout
r_static
r_volatile
r_int
id|sjcd_status_timeout
suffix:semicolon
multiline_comment|/*&n; * We need about 10 seconds to wait. The longest command takes about 5 seconds&n; * to probe the disk (usually after tray closed or drive reset). Other values&n; * should be thought of for other commands.&n; */
DECL|macro|SJCD_WAIT_FOR_STATUS_TIMEOUT
mdefine_line|#define SJCD_WAIT_FOR_STATUS_TIMEOUT 1000
DECL|function|sjcd_status_timer
r_static
r_void
(def_block
id|sjcd_status_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|sjcd_check_status
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;     * The command completed and status is loaded, stop waiting.&n;     */
id|wake_up
c_func
(paren
op_amp
id|sjcd_waitq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_decrement
id|sjcd_status_timeout
op_le
l_int|0
)paren
(brace
multiline_comment|/*&n;     * We are timed out. &n;     */
id|wake_up
c_func
(paren
op_amp
id|sjcd_waitq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * We have still some time to wait. Try again.&n;     */
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_status_timer
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * Wait for status for 10 sec approx. Returns non-positive when timed out.&n; * Should not be used while reading data CDs.&n; */
DECL|function|sjcd_wait_for_status
r_static
r_int
(def_block
id|sjcd_wait_for_status
c_func
(paren
r_void
)paren
(brace
id|sjcd_status_timeout
op_assign
id|SJCD_WAIT_FOR_STATUS_TIMEOUT
suffix:semicolon
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_status_timer
comma
l_int|1
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|sjcd_waitq
)paren
suffix:semicolon
macro_line|#if defined( SJCD_DIAGNOSTIC ) || defined ( SJCD_TRACE )
r_if
c_cond
(paren
id|sjcd_status_timeout
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sjcd: Error Wait For Status.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|sjcd_status_timeout
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_receive_status
r_static
r_int
(def_block
id|sjcd_receive_status
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: receive_status&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Wait a bit for status available.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|200
suffix:semicolon
id|i
op_decrement
op_logical_and
(paren
id|sjcd_check_status
c_func
(paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: long wait for status&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sjcd_wait_for_status
c_func
(paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sjcd: Timeout when read status.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Load the status. Issue get status command and wait for status available.&n; */
DECL|function|sjcd_get_status
r_static
r_void
(def_block
id|sjcd_get_status
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: get_status&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_STATUS
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Check the drive if the disk is changed. Should be revised.&n; */
DECL|function|sjcd_disk_change
r_static
r_int
(def_block
id|sjcd_disk_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;sjcd_disk_change( 0x%x )&bslash;n&quot;
comma
id|full_dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|full_dev
)paren
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sjcd: request error: invalid device minor.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_is_in_progress
)paren
(brace
id|sjcd_get_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|sjcd_status_valid
ques
c_cond
id|sjcd_media_is_changed
suffix:colon
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Read the table of contents (TOC) and TOC header if necessary.&n; * We assume that the drive contains no more than 99 toc entries.&n; */
DECL|variable|sjcd_table_of_contents
r_static
r_struct
id|sjcd_hw_disk_info
id|sjcd_table_of_contents
(braket
id|SJCD_MAX_TRACKS
)braket
suffix:semicolon
DECL|variable|sjcd_first_track_no
DECL|variable|sjcd_last_track_no
r_static
r_int
r_char
id|sjcd_first_track_no
comma
id|sjcd_last_track_no
suffix:semicolon
DECL|macro|sjcd_disk_length
mdefine_line|#define sjcd_disk_length  sjcd_table_of_contents[0].un.track_msf
DECL|function|sjcd_update_toc
r_static
r_int
(def_block
id|sjcd_update_toc
c_func
(paren
r_void
)paren
(brace
r_struct
id|sjcd_hw_disk_info
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: update toc:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * check to see if we need to do anything&n;   */
r_if
c_cond
(paren
id|sjcd_toc_uptodate
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Get the TOC start information.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|SCMD_GET_1_TRACK
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load response about TOC start.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_first_track_no
op_assign
id|bcd2bin
c_func
(paren
id|info.un.track_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;get first failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;TOC start 0x%02x &quot;
comma
id|sjcd_first_track_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Get the TOC finish information.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|SCMD_GET_L_TRACK
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load response about TOC finish.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_last_track_no
op_assign
id|bcd2bin
c_func
(paren
id|info.un.track_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;get last failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;TOC finish 0x%02x &quot;
comma
id|sjcd_last_track_no
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
id|sjcd_first_track_no
suffix:semicolon
id|i
op_le
id|sjcd_last_track_no
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;     * Get the first track information.&n;     */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|bin2bcd
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|sjcd_table_of_contents
(braket
id|i
)braket
comma
r_sizeof
(paren
r_struct
id|sjcd_hw_disk_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load info for %d track&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;get info %d failed&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Get the disk lenght info.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_GET_DISK_INFO
comma
id|SCMD_GET_D_SIZE
)paren
suffix:semicolon
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load status.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_failed
)paren
(brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot load response about disk size.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_disk_length.min
op_assign
id|info.un.track_msf.min
suffix:semicolon
id|sjcd_disk_length.sec
op_assign
id|info.un.track_msf.sec
suffix:semicolon
id|sjcd_disk_length.frame
op_assign
id|info.un.track_msf.frame
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;get size failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;(%02x:%02x.%02x)&bslash;n&quot;
comma
id|sjcd_disk_length.min
comma
id|sjcd_disk_length.sec
comma
id|sjcd_disk_length.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Load subchannel information.&n; */
DECL|function|sjcd_get_q_info
r_static
r_int
(def_block
id|sjcd_get_q_info
c_func
(paren
r_struct
id|sjcd_hw_qinfo
op_star
id|qp
)paren
(brace
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: load sub q&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_QINFO
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
id|sjcd_command_failed
op_logical_or
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|sjcd_send_cmd
c_func
(paren
l_int|0xF2
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
id|sjcd_command_failed
op_logical_or
op_logical_neg
id|sjcd_status_valid
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_QINFO
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
id|sjcd_command_failed
op_logical_or
op_logical_neg
id|sjcd_status_valid
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sjcd_media_is_available
)paren
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
id|qp
comma
r_sizeof
(paren
op_star
id|qp
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Start playing from the specified position.&n; */
DECL|function|sjcd_play
r_static
r_int
(def_block
id|sjcd_play
c_func
(paren
r_struct
id|sjcd_play_msf
op_star
id|mp
)paren
(brace
r_struct
id|sjcd_play_msf
id|msf
suffix:semicolon
multiline_comment|/*&n;   * Turn the device to play mode.&n;   */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_SET_MODE
comma
id|SCMD_MODE_PLAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_receive_status
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Seek to the starting point.&n;   */
id|msf.start
op_assign
id|mp-&gt;start
suffix:semicolon
id|msf.end.min
op_assign
id|msf.end.sec
op_assign
id|msf.end.frame
op_assign
l_int|0x00
suffix:semicolon
id|sjcd_send_6_cmd
c_func
(paren
id|SCMD_SEEK
comma
op_amp
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_receive_status
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Start playing.&n;   */
id|sjcd_send_6_cmd
c_func
(paren
id|SCMD_PLAY
comma
id|mp
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Tray control functions.&n; */
DECL|function|sjcd_tray_close
r_static
r_int
(def_block
id|sjcd_tray_close
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: tray_close&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_CLOSE_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_tray_lock
r_static
r_int
(def_block
id|sjcd_tray_lock
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: tray_lock&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_LOCK_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_tray_unlock
r_static
r_int
(def_block
id|sjcd_tray_unlock
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: tray_unlock&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_UNLOCK_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sjcd_tray_open
r_static
r_int
(def_block
id|sjcd_tray_open
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: tray_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_EJECT_TRAY
)paren
suffix:semicolon
r_return
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Do some user commands.&n; */
DECL|function|sjcd_ioctl
r_static
r_int
(def_block
id|sjcd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd:ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sjcd_get_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_update_toc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: start&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTOP
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: stop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_PAUSE
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
(brace
r_struct
id|sjcd_hw_qinfo
id|q_info
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: pause&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sjcd_audio_status
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_PAUSE
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_get_q_info
c_func
(paren
op_amp
id|q_info
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_else
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
id|sjcd_playing.start
op_assign
id|q_info.abs
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|CDROMRESUME
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: resume&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sjcd_audio_status
op_eq
id|CDROM_AUDIO_PAUSED
)paren
(brace
multiline_comment|/*&n;       * continue play starting at saved location&n;       */
r_if
c_cond
(paren
id|sjcd_play
c_func
(paren
op_amp
id|sjcd_playing
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: playtrkind&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
OL
id|sjcd_first_track_no
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|sjcd_last_track_no
)paren
(brace
id|ti.cdti_trk1
op_assign
id|sjcd_last_track_no
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk0
OG
id|ti.cdti_trk1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sjcd_playing.start
op_assign
id|sjcd_table_of_contents
(braket
id|ti.cdti_trk0
)braket
dot
id|un.track_msf
suffix:semicolon
id|sjcd_playing.end
op_assign
(paren
id|ti.cdti_trk1
OL
id|sjcd_last_track_no
)paren
ques
c_cond
id|sjcd_table_of_contents
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|un.track_msf
suffix:colon
id|sjcd_table_of_contents
(braket
l_int|0
)braket
dot
id|un.track_msf
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_play
c_func
(paren
op_amp
id|sjcd_playing
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|sjcd_msf
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: playmsf&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sjcd_msf
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sjcd_audio_status
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_PAUSE
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|sjcd_msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sjcd_msf
)paren
)paren
suffix:semicolon
id|sjcd_playing.start.min
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_min0
)paren
suffix:semicolon
id|sjcd_playing.start.sec
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_sec0
)paren
suffix:semicolon
id|sjcd_playing.start.frame
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_frame0
)paren
suffix:semicolon
id|sjcd_playing.end.min
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_min1
)paren
suffix:semicolon
id|sjcd_playing.end.sec
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_sec1
)paren
suffix:semicolon
id|sjcd_playing.end.frame
op_assign
id|bin2bcd
c_func
(paren
id|sjcd_msf.cdmsf_frame1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_play
c_func
(paren
op_amp
id|sjcd_playing
)paren
OL
l_int|0
)paren
(brace
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|sjcd_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
id|toc_header
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined (SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: readtocheader&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|toc_header
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|toc_header.cdth_trk0
op_assign
id|sjcd_first_track_no
suffix:semicolon
id|toc_header.cdth_trk1
op_assign
id|sjcd_last_track_no
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|toc_header
comma
r_sizeof
(paren
id|toc_header
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
id|toc_entry
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: readtocentry&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|toc_entry
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|sjcd_hw_disk_info
op_star
id|tp
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|toc_entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|toc_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|toc_entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
(brace
id|tp
op_assign
op_amp
id|sjcd_table_of_contents
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|toc_entry.cdte_track
OL
id|sjcd_first_track_no
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|toc_entry.cdte_track
OG
id|sjcd_last_track_no
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|tp
op_assign
op_amp
id|sjcd_table_of_contents
(braket
id|toc_entry.cdte_track
)braket
suffix:semicolon
id|toc_entry.cdte_adr
op_assign
id|tp-&gt;track_control
op_amp
l_int|0x0F
suffix:semicolon
id|toc_entry.cdte_ctrl
op_assign
id|tp-&gt;track_control
op_rshift
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|toc_entry.cdte_format
)paren
(brace
r_case
id|CDROM_LBA
suffix:colon
id|toc_entry.cdte_addr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
(paren
id|tp-&gt;un.track_msf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_MSF
suffix:colon
id|toc_entry.cdte_addr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|tp-&gt;un.track_msf.min
)paren
suffix:semicolon
id|toc_entry.cdte_addr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|tp-&gt;un.track_msf.sec
)paren
suffix:semicolon
id|toc_entry.cdte_addr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|tp-&gt;un.track_msf.frame
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|toc_entry
comma
r_sizeof
(paren
id|toc_entry
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: subchnl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|sjcd_hw_qinfo
id|q_info
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_get_q_info
c_func
(paren
op_amp
id|q_info
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|subchnl.cdsc_audiostatus
op_assign
id|sjcd_audio_status
suffix:semicolon
id|subchnl.cdsc_adr
op_assign
id|q_info.track_control
op_amp
l_int|0x0F
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|q_info.track_control
op_rshift
l_int|4
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|bcd2bin
c_func
(paren
id|q_info.track_no
)paren
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|bcd2bin
c_func
(paren
id|q_info.x
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|subchnl.cdsc_format
)paren
(brace
r_case
id|CDROM_LBA
suffix:colon
id|subchnl.cdsc_absaddr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
(paren
id|q_info.abs
)paren
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
(paren
id|q_info.rel
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_MSF
suffix:colon
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|q_info.abs.min
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|q_info.abs.sec
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|q_info.abs.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|q_info.rel.min
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|q_info.rel.sec
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|q_info.rel.frame
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|vol_ctrl
suffix:semicolon
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: volctrl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vol_ctrl
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_int
r_char
id|dummy
(braket
l_int|4
)braket
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|vol_ctrl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vol_ctrl
)paren
)paren
suffix:semicolon
id|sjcd_send_4_cmd
c_func
(paren
id|SCMD_SET_VOLUME
comma
id|vol_ctrl.channel0
comma
l_int|0xFF
comma
id|vol_ctrl.channel1
comma
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_receive_status
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
(paren
r_void
)paren
id|sjcd_load_response
c_func
(paren
id|dummy
comma
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: eject&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|sjcd_command_is_in_progress
)paren
(brace
id|sjcd_tray_unlock
c_func
(paren
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_EJECT_TRAY
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_receive_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_case
l_int|0xABCD
suffix:colon
(brace
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: ioctl: statistic&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|s
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|statistic
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|statistic
comma
r_sizeof
(paren
id|statistic
)paren
)paren
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * Invalidate internal buffers of the driver.&n; */
DECL|function|sjcd_invalidate_buffers
r_static
r_void
(def_block
id|sjcd_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SJCD_BUF_SIZ
suffix:semicolon
id|sjcd_buf_bn
(braket
id|i
op_increment
)braket
op_assign
op_minus
l_int|1
)paren
(brace
suffix:semicolon
)brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
DECL|macro|CURRENT_IS_VALID
mdefine_line|#define CURRENT_IS_VALID                                      &bslash;&n;    ( CURRENT != NULL &amp;&amp; MAJOR( CURRENT-&gt;rq_dev ) == MAJOR_NR &amp;&amp; &bslash;&n;      CURRENT-&gt;cmd == READ &amp;&amp; CURRENT-&gt;sector != -1 )
DECL|function|sjcd_transfer
r_static
r_void
(def_block
id|sjcd_transfer
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: transfer:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
r_while
c_loop
(paren
id|CURRENT-&gt;nr_sectors
)paren
(brace
r_int
id|i
comma
id|bn
op_assign
id|CURRENT-&gt;sector
op_div
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SJCD_BUF_SIZ
op_logical_and
id|sjcd_buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
id|i
op_increment
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|SJCD_BUF_SIZ
)paren
(brace
r_int
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT-&gt;sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
r_int
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT-&gt;sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_buf_out
op_ne
id|i
)paren
(brace
id|sjcd_buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|nr_sectors
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;copy out&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|sjcd_buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: transfer: done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)def_block
DECL|function|sjcd_poll
r_static
r_void
(def_block
id|sjcd_poll
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_GATHER_STAT )
multiline_comment|/*&n;   * Update total number of ticks.&n;   */
id|statistic.ticks
op_increment
suffix:semicolon
id|statistic.tticks
(braket
id|sjcd_transfer_state
)braket
op_increment
suffix:semicolon
macro_line|#endif
id|ReSwitch
suffix:colon
r_switch
c_cond
(paren
id|sjcd_transfer_state
)paren
(brace
r_case
id|SJCD_S_IDLE
suffix:colon
(brace
macro_line|#if defined( SJCD_GATHER_STAT )
id|statistic.idle_ticks
op_increment
suffix:semicolon
macro_line|#endif
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_IDLE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_case
id|SJCD_S_START
suffix:colon
(brace
macro_line|#if defined( SJCD_GATHER_STAT )
id|statistic.start_ticks
op_increment
suffix:semicolon
macro_line|#endif
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_STATUS
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|sjcd_mode
op_eq
id|SCMD_MODE_COOKED
ques
c_cond
id|SJCD_S_READ
suffix:colon
id|SJCD_S_MODE
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_START: goto SJCD_S_%s mode&bslash;n&quot;
comma
id|sjcd_transfer_state
op_eq
id|SJCD_S_READ
ques
c_cond
l_string|&quot;READ&quot;
suffix:colon
l_string|&quot;MODE&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_MODE
suffix:colon
(brace
r_if
c_cond
(paren
id|sjcd_check_status
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;       * Previous command is completed.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_MODE: pre-cmd failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
id|sjcd_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unknown mode; should not be valid when failed */
id|sjcd_send_1_cmd
c_func
(paren
id|SCMD_SET_MODE
comma
id|SCMD_MODE_COOKED
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_READ
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|1000
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_MODE: goto SJCD_S_READ mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.mode_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_READ
suffix:colon
(brace
r_if
c_cond
(paren
id|sjcd_status_valid
ques
c_cond
l_int|1
suffix:colon
id|sjcd_check_status
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;       * Previos command is completed.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: pre-cmd failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: no disk: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_mode
op_ne
id|SCMD_MODE_COOKED
)paren
(brace
multiline_comment|/*&n;&t; * We seem to come from set mode. So discard one byte of result.&n;&t; */
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|sjcd_mode
comma
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: load failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_mode
op_ne
id|SCMD_MODE_COOKED
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: mode failed: goto to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
r_struct
id|sjcd_play_msf
id|msf
suffix:semicolon
id|sjcd_next_bn
op_assign
id|CURRENT-&gt;sector
op_div
l_int|4
suffix:semicolon
id|hsg2msf
c_func
(paren
id|sjcd_next_bn
comma
op_amp
id|msf.start
)paren
suffix:semicolon
id|msf.end.min
op_assign
l_int|0
suffix:semicolon
id|msf.end.sec
op_assign
l_int|0
suffix:semicolon
id|msf.end.frame
op_assign
id|sjcd_read_count
op_assign
id|SJCD_BUF_SIZ
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;---reading msf-address %x:%x:%x  %x:%x:%x&bslash;n&quot;
comma
id|msf.start.min
comma
id|msf.start.sec
comma
id|msf.start.frame
comma
id|msf.end.min
comma
id|msf.end.sec
comma
id|msf.end.frame
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sjcd_next_bn:%x buf_in:%x buf_out:%x buf_bn:%x&bslash;n&quot;
comma
"&bslash;"
id|sjcd_next_bn
comma
id|sjcd_buf_in
comma
id|sjcd_buf_out
comma
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif&t;
id|sjcd_send_6_cmd
c_func
(paren
id|SCMD_DATA_READ
comma
op_amp
id|msf
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_DATA
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: go to SJCD_S_DATA mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_READ: nothing to read: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.read_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_DATA
suffix:colon
(brace
r_int
r_char
id|stat
suffix:semicolon
id|sjcd_s_data
suffix:colon
id|stat
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: status = 0x%02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
multiline_comment|/*&n;       * No data is waiting for us in the drive buffer. Status of operation&n;       * completion is available. Read and parse it.&n;       */
id|sjcd_load_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: read block %d failed, maybe audio disk? Giving up&bslash;n&quot;
comma
id|sjcd_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: pre-cmd failed: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: no disk: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
id|sjcd_transfer_state
op_assign
id|SJCD_S_READ
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SJCD_DATA_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
multiline_comment|/*&n;       * One frame is read into device buffer. We must copy it to our memory.&n;       * Otherwise cdrom hangs up. Check to see if we have something to copy&n;       * to.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_IS_VALID
op_logical_and
id|sjcd_buf_in
op_eq
id|sjcd_buf_out
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: nothing to read: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; ... all the date would be discarded&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
multiline_comment|/*&n;       * Everything seems to be OK. Just read the frame and recalculate&n;       * indecis.&n;       */
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ??? */
id|insb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|2
)paren
comma
id|sjcd_buf
op_plus
l_int|2048
op_star
id|sjcd_buf_in
comma
l_int|2048
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: next_bn=%d, buf_in=%d, buf_out=%d, buf_bn=%d&bslash;n&quot;
comma
id|sjcd_next_bn
comma
id|sjcd_buf_in
comma
id|sjcd_buf_out
comma
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
op_assign
id|sjcd_next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_buf_out
op_eq
op_minus
l_int|1
)paren
(brace
id|sjcd_buf_out
op_assign
id|sjcd_buf_in
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|sjcd_buf_in
op_eq
id|SJCD_BUF_SIZ
)paren
(brace
id|sjcd_buf_in
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;       * Only one frame is ready at time. So we should turn over to wait for&n;       * another frame. If we need that, of course.&n;       */
r_if
c_cond
(paren
op_decrement
id|sjcd_read_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t; * OK, request seems to be precessed. Continue transferring...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
multiline_comment|/*&n;&t;     * Continue transferring.&n;&t;     */
id|sjcd_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_IS_VALID
op_logical_and
(paren
id|CURRENT-&gt;sector
op_div
l_int|4
template_param
id|sjcd_next_bn
op_plus
id|SJCD_BUF_SIZ
)paren
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_DATA: can&squot;t read: go to SJCD_S_STOP mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOP
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;       * Now we should turn around rather than wait for while.&n;       */
r_goto
id|sjcd_s_data
suffix:semicolon
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.data_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_STOP
suffix:colon
(brace
id|sjcd_read_count
op_assign
l_int|0
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_STOP
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_STOPPING
suffix:semicolon
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
macro_line|#if defined( SJCD_GATHER_STAT )
id|statistic.stop_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|SJCD_S_STOPPING
suffix:colon
(brace
r_int
r_char
id|stat
suffix:semicolon
id|stat
op_assign
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_STOP: status = 0x%02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
macro_line|#endif      
r_if
c_cond
(paren
id|SJCD_DATA_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;SJCD_S_STOP: discard data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;       * Discard all the data from the pipe. Foolish method.&n;       */
r_for
c_loop
(paren
id|i
op_assign
l_int|2048
suffix:semicolon
id|i
op_decrement
suffix:semicolon
(paren
r_void
)paren
id|inb
c_func
(paren
id|SJCDPORT
c_func
(paren
l_int|2
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
id|sjcd_transfer_timeout
op_assign
l_int|500
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SJCD_STATUS_AVAILABLE
c_func
(paren
id|stat
)paren
)paren
(brace
id|sjcd_load_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sjcd_status_valid
op_logical_and
id|sjcd_media_is_changed
)paren
(brace
id|sjcd_toc_uptodate
op_assign
l_int|0
suffix:semicolon
id|sjcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_IS_VALID
)paren
(brace
r_if
c_cond
(paren
id|sjcd_status_valid
)paren
(brace
id|sjcd_transfer_state
op_assign
id|SJCD_S_READ
suffix:semicolon
)brace
r_else
id|sjcd_transfer_state
op_assign
id|SJCD_S_START
suffix:semicolon
)brace
r_else
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
macro_line|#if defined( SJCD_GATHER_STAT )
r_else
id|statistic.stopping_ticks
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sjcd_poll: invalid state %d&bslash;n&quot;
comma
id|sjcd_transfer_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|sjcd_transfer_timeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sjcd: timeout in state %d&bslash;n&quot;
comma
id|sjcd_transfer_state
)paren
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sjcd_send_cmd
c_func
(paren
id|SCMD_STOP
)paren
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
r_goto
id|ReSwitch
suffix:semicolon
)brace
multiline_comment|/*&n;   * Get back in some time. 1 should be replaced with count variable to&n;   * avoid unnecessary testings.&n;   */
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_poll
comma
l_int|1
)paren
suffix:semicolon
)brace
)def_block
DECL|function|do_sjcd_request
r_static
r_void
(def_block
id|do_sjcd_request
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: do_sjcd_request(%ld+%ld)&bslash;n&quot;
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|sjcd_transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
multiline_comment|/*&n;     * Who of us are paranoic?&n;     */
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|sjcd_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sjcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Want to read a block not in buffer */
r_if
c_cond
(paren
id|sjcd_transfer_state
op_eq
id|SJCD_S_IDLE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_toc_uptodate
)paren
(brace
r_if
c_cond
(paren
id|sjcd_update_toc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sjcd: transfer: discard&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_IS_VALID
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|sjcd_transfer_state
op_assign
id|SJCD_S_START
suffix:semicolon
id|SJCD_SET_TIMER
c_func
(paren
id|sjcd_poll
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|sjcd_transfer_is_active
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd_next_bn:%x sjcd_buf_in:%x sjcd_buf_out:%x sjcd_buf_bn:%x&bslash;n&quot;
comma
id|sjcd_next_bn
comma
id|sjcd_buf_in
comma
id|sjcd_buf_out
comma
id|sjcd_buf_bn
(braket
id|sjcd_buf_in
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;do_sjcd_request ends&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)def_block
multiline_comment|/*&n; * Open the device special file. Check disk is in.&n; */
DECL|function|sjcd_open
r_int
(def_block
id|sjcd_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
multiline_comment|/*&n;   * Check the presence of device.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_present
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;   * Only read operations are allowed. Really? (:-)&n;   */
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_open_count
op_eq
l_int|0
)paren
(brace
r_int
id|s
comma
id|sjcd_open_tries
suffix:semicolon
multiline_comment|/* We don&squot;t know that, do we? */
multiline_comment|/*&n;    sjcd_audio_status = CDROM_AUDIO_NO_STATUS;&n;*/
id|sjcd_mode
op_assign
l_int|0
suffix:semicolon
id|sjcd_door_was_open
op_assign
l_int|0
suffix:semicolon
id|sjcd_transfer_state
op_assign
id|SJCD_S_IDLE
suffix:semicolon
id|sjcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|sjcd_status_valid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Strict status checking.&n;     */
r_for
c_loop
(paren
id|sjcd_open_tries
op_assign
l_int|4
suffix:semicolon
op_decrement
id|sjcd_open_tries
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|sjcd_get_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;sjcd: open: timed out when check status.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sjcd_media_is_available
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;sjcd: open: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|sjcd_door_closed
)paren
(brace
id|sjcd_door_was_open
op_assign
l_int|1
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: open: close the tray&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|s
op_assign
id|sjcd_tray_close
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;sjcd: open: tray close attempt failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|s
op_assign
id|sjcd_tray_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;sjcd: open: tray lock attempt failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: open: done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
op_increment
id|sjcd_open_count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * On close, we flush all sjcd blocks from the buffer cache.&n; */
DECL|function|sjcd_release
r_static
r_void
(def_block
id|sjcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|s
suffix:semicolon
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd: release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|sjcd_open_count
op_eq
l_int|0
)paren
(brace
id|sjcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|s
op_assign
id|sjcd_tray_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;sjcd: release: tray unlock attempt failed.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|sjcd_door_was_open
)paren
(brace
id|s
op_assign
id|sjcd_tray_open
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
l_int|0
op_logical_or
op_logical_neg
id|sjcd_status_valid
op_logical_or
id|sjcd_command_failed
)paren
(brace
macro_line|#if defined( SJCD_DIAGNOSTIC )
id|printk
c_func
(paren
l_string|&quot;sjcd: release: tray unload attempt failed.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
)brace
)def_block
multiline_comment|/*&n; * A list of file operations allowed for this cdrom.&n; */
DECL|variable|sjcd_fops
r_static
r_struct
id|file_operations
id|sjcd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|sjcd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|sjcd_open
comma
multiline_comment|/* open */
id|sjcd_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|sjcd_disk_change
comma
multiline_comment|/* media change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*&n; * Following stuff is intended for initialization of the cdrom. It&n; * first looks for presence of device. If the device is present, it&n; * will be reset. Then read the version of the drive and load status.&n; * The version is two BCD-coded bytes.&n; */
r_static
r_struct
(brace
DECL|member|major
DECL|member|minor
r_int
r_char
id|major
comma
id|minor
suffix:semicolon
DECL|variable|sjcd_version
)brace
id|sjcd_version
suffix:semicolon
multiline_comment|/*&n; * Test for presence of drive and initialize it. Called at boot time.&n; * Probe cdrom, find out version and status.&n; */
DECL|function|sjcd_init
r_int
(def_block
id|sjcd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isp16_type
op_assign
id|isp16_detect
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;No ISP16 cdrom interface found.&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|u_char
id|expected_drive
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ISP16 cdrom interface (with OPTi 82C92%s chip) detected.&bslash;n&quot;
comma
(paren
id|isp16_type
op_eq
l_int|2
)paren
ques
c_cond
l_string|&quot;9&quot;
suffix:colon
l_string|&quot;8&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ISP16 sound configuration.&bslash;n&quot;
)paren
suffix:semicolon
id|isp16_sound_config
c_func
(paren
)paren
suffix:semicolon
id|expected_drive
op_assign
(paren
id|isp16_type
ques
c_cond
id|ISP16_SANYO1
suffix:colon
id|ISP16_SANYO0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isp16_cdi_config
c_func
(paren
id|sjcd_port
comma
id|expected_drive
comma
id|sjcd_irq
comma
id|sjcd_dma
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ISP16 cdrom interface has not been properly configured.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#if defined( SJCD_TRACE )
id|printk
c_func
(paren
l_string|&quot;sjcd=0x%x,%d: &quot;
comma
id|sjcd_port
comma
id|sjcd_irq
)paren
suffix:semicolon
macro_line|#endif  
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;sjcd&quot;
comma
op_amp
id|sjcd_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for Sanyo CD-ROM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|sjcd_port
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Init failed, I/O port (%X) is already in use&bslash;n&quot;
comma
id|sjcd_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check for card. Since we are booting now, we can&squot;t use standard&n;   * wait algorithm.&n;   */
id|printk
c_func
(paren
l_string|&quot;Sanyo: Resetting: &quot;
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_RESET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
op_decrement
OG
l_int|0
op_logical_and
op_logical_neg
id|sjcd_status_valid
suffix:semicolon
)paren
(brace
r_int
r_int
id|timer
suffix:semicolon
multiline_comment|/*&n;     * Wait 10ms approx.&n;     */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_le
id|timer
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_check_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|sjcd_command_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; reset failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Get and print out cdrom version.&n;   */
id|printk
c_func
(paren
l_string|&quot;Sanyo: Getting version: &quot;
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_VERSION
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|sjcd_status_valid
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
r_int
id|timer
suffix:semicolon
multiline_comment|/*&n;     * Wait 10ms approx.&n;     */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_le
id|timer
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_check_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|sjcd_command_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; get version failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sjcd_load_response
c_func
(paren
op_amp
id|sjcd_version
comma
r_sizeof
(paren
id|sjcd_version
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %1x.%02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|sjcd_version.major
comma
(paren
r_int
)paren
id|sjcd_version.minor
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; read version failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check and print out the tray state. (if it is needed?).&n;   */
r_if
c_cond
(paren
op_logical_neg
id|sjcd_status_valid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sanyo: Getting status: &quot;
)paren
suffix:semicolon
id|sjcd_send_cmd
c_func
(paren
id|SCMD_GET_STATUS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|sjcd_status_valid
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
r_int
id|timer
suffix:semicolon
multiline_comment|/*&n;       * Wait 10ms approx.&n;       */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_le
id|timer
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sjcd_check_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|sjcd_command_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; get status failed, no drive found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;SANYO CDR-H94A: Status: port=0x%x, irq=%d, dma=%d.&bslash;n&quot;
comma
id|sjcd_port
comma
id|sjcd_irq
comma
id|sjcd_dma
)paren
suffix:semicolon
id|sjcd_present
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|sjcd_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
(def_block
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;sjcd&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sjcd: module: can not unregister device.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|sjcd_port
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sjcd: module: removed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)def_block
macro_line|#endif
multiline_comment|/*&n; * -- ISP16 detection and configuration&n; *&n; *    Copyright (c) 1995, Eric van der Maarel &lt;maarel@marin.nl&gt;&n; *&n; *    Version 0.5&n; *&n; *    Detect cdrom interface on ISP16 soundcard.&n; *    Configure cdrom interface.&n; *    Configure sound interface.&n; *&n; *    Algorithm for the card with OPTi 82C928 taken&n; *    from the CDSETUP.SYS driver for MSDOS,&n; *    by OPTi Computers, version 2.03.&n; *    Algorithm for the card with OPTi 82C929 as communicated&n; *    to me by Vadim Model and Leo Spiekman.&n; *&n; *    Use, modifification or redistribution of this software is&n; *    allowed under the terms of the GPL.&n; *&n; */
DECL|macro|ISP16_IN
mdefine_line|#define ISP16_IN(p) (outb(isp16_ctrl,ISP16_CTRL_PORT), inb(p))
DECL|macro|ISP16_OUT
mdefine_line|#define ISP16_OUT(p,b) (outb(isp16_ctrl,ISP16_CTRL_PORT), outb(b,p))
r_static
r_int
DECL|function|isp16_detect
id|isp16_detect
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|isp16_c929__detect
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_else
r_return
id|isp16_c928__detect
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|isp16_c928__detect
id|isp16_c928__detect
c_func
(paren
r_void
)paren
(brace
id|u_char
id|ctrl
suffix:semicolon
id|u_char
id|enable_cdrom
suffix:semicolon
id|u_char
id|io
suffix:semicolon
r_int
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
id|isp16_ctrl
op_assign
id|ISP16_C928__CTRL
suffix:semicolon
id|isp16_enable_port
op_assign
id|ISP16_C928__ENABLE_PORT
suffix:semicolon
multiline_comment|/* read&squot; and write&squot; are a special read and write, respectively */
multiline_comment|/* read&squot; ISP16_CTRL_PORT, clear last two bits and write&squot; back the result */
id|ctrl
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_CTRL_PORT
)paren
op_amp
l_int|0xFC
suffix:semicolon
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* read&squot; 3,4 and 5-bit from the cdrom enable port */
id|enable_cdrom
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_C928__ENABLE_PORT
)paren
op_amp
l_int|0x38
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|enable_cdrom
op_amp
l_int|0x20
)paren
)paren
(brace
multiline_comment|/* 5-bit not set */
multiline_comment|/* read&squot; last 2 bits of ISP16_IO_SET_PORT */
id|io
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_IO_SET_PORT
)paren
op_amp
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|io
op_amp
l_int|0x01
)paren
op_lshift
l_int|1
)paren
op_eq
(paren
id|io
op_amp
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* bits are the same */
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ...the same and 0 */
id|i
op_assign
l_int|0
suffix:semicolon
id|enable_cdrom
op_or_assign
l_int|0x20
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ...the same and 1 */
multiline_comment|/* my card, first time &squot;round */
id|i
op_assign
l_int|1
suffix:semicolon
id|enable_cdrom
op_or_assign
l_int|0x28
suffix:semicolon
)brace
id|ISP16_OUT
c_func
(paren
id|ISP16_C928__ENABLE_PORT
comma
id|enable_cdrom
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* bits are not the same */
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
multiline_comment|/* -&gt; not detected: possibly incorrect conclusion */
)brace
)brace
r_else
r_if
c_cond
(paren
id|enable_cdrom
op_eq
l_int|0x20
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|enable_cdrom
op_eq
l_int|0x28
)paren
multiline_comment|/* my card, already initialised */
id|i
op_assign
l_int|1
suffix:semicolon
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_static
r_int
DECL|function|isp16_c929__detect
id|isp16_c929__detect
c_func
(paren
r_void
)paren
(brace
id|u_char
id|ctrl
suffix:semicolon
id|u_char
id|tmp
suffix:semicolon
id|isp16_ctrl
op_assign
id|ISP16_C929__CTRL
suffix:semicolon
id|isp16_enable_port
op_assign
id|ISP16_C929__ENABLE_PORT
suffix:semicolon
multiline_comment|/* read&squot; and write&squot; are a special read and write, respectively */
multiline_comment|/* read&squot; ISP16_CTRL_PORT and save */
id|ctrl
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_CTRL_PORT
)paren
suffix:semicolon
multiline_comment|/* write&squot; zero to the ctrl port and get response */
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
l_int|0
)paren
suffix:semicolon
id|tmp
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_CTRL_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|2
)paren
multiline_comment|/* isp16 with 82C929 not detected */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* restore ctrl port value */
id|ISP16_OUT
c_func
(paren
id|ISP16_CTRL_PORT
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_static
r_int
DECL|function|isp16_cdi_config
id|isp16_cdi_config
c_func
(paren
r_int
id|base
comma
id|u_char
id|drive_type
comma
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
id|u_char
id|base_code
suffix:semicolon
id|u_char
id|irq_code
suffix:semicolon
id|u_char
id|dma_code
suffix:semicolon
id|u_char
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive_type
op_eq
id|ISP16_MITSUMI
)paren
op_logical_and
(paren
id|dma
op_ne
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Mitsumi cdrom drive has no dma support.&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|base
)paren
(brace
r_case
l_int|0x340
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_340
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x330
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_330
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x360
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_360
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x320
suffix:colon
id|base_code
op_assign
id|ISP16_BASE_320
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Base address 0x%03X not supported by cdrom interface on ISP16.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|0
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_X
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* disable irq */
r_case
l_int|5
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_5
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Irq 5 shouldn&squot;t be used by cdrom interface on ISP16,&quot;
l_string|&quot; due to possible conflicts with the soundcard.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_7
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Irq 7 shouldn&squot;t be used by cdrom interface on ISP16,&quot;
l_string|&quot; due to possible conflicts with the soundcard.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_9
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|irq_code
op_assign
id|ISP16_IRQ_11
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Irq %d not supported by cdrom interface on ISP16.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dma
)paren
(brace
r_case
l_int|0
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_X
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* disable dma */
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Dma 1 cannot be used by cdrom interface on ISP16,&quot;
l_string|&quot; due to conflict with the soundcard.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|dma_code
op_assign
id|ISP16_DMA_7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Dma %d not supported by cdrom interface on ISP16.&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive_type
op_ne
id|ISP16_SONY
op_logical_and
id|drive_type
op_ne
id|ISP16_PANASONIC0
op_logical_and
id|drive_type
op_ne
id|ISP16_PANASONIC1
op_logical_and
id|drive_type
op_ne
id|ISP16_SANYO0
op_logical_and
id|drive_type
op_ne
id|ISP16_SANYO1
op_logical_and
id|drive_type
op_ne
id|ISP16_MITSUMI
op_logical_and
id|drive_type
op_ne
id|ISP16_DRIVE_X
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Drive type (code 0x%02X) not supported by cdrom&quot;
l_string|&quot; interface on ISP16.&bslash;n&quot;
comma
id|drive_type
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set type of interface */
id|i
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_DRIVE_SET_PORT
)paren
op_amp
id|ISP16_DRIVE_SET_MASK
suffix:semicolon
multiline_comment|/* clear some bits */
id|ISP16_OUT
c_func
(paren
id|ISP16_DRIVE_SET_PORT
comma
id|i
op_or
id|drive_type
)paren
suffix:semicolon
multiline_comment|/* enable cdrom on interface with 82C929 chip */
r_if
c_cond
(paren
id|isp16_type
OG
l_int|1
)paren
id|ISP16_OUT
c_func
(paren
id|isp16_enable_port
comma
id|ISP16_ENABLE_CDROM
)paren
suffix:semicolon
multiline_comment|/* set base address, irq and dma */
id|i
op_assign
id|ISP16_IN
c_func
(paren
id|ISP16_IO_SET_PORT
)paren
op_amp
id|ISP16_IO_SET_MASK
suffix:semicolon
multiline_comment|/* keep some bits */
id|ISP16_OUT
c_func
(paren
id|ISP16_IO_SET_PORT
comma
id|i
op_or
id|base_code
op_or
id|irq_code
op_or
id|dma_code
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|isp16_sound_config
r_static
r_void
id|isp16_sound_config
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_char
id|saved
suffix:semicolon
id|saved
op_assign
id|ISP16_IN
c_func
(paren
l_int|0xF8D
)paren
op_amp
l_int|0x8F
suffix:semicolon
id|ISP16_OUT
c_func
(paren
l_int|0xF8D
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now we should wait for a while...&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|16
op_star
l_int|1024
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
id|ISP16_OUT
c_func
(paren
l_int|0xF8D
comma
id|saved
)paren
suffix:semicolon
id|ISP16_OUT
c_func
(paren
l_int|0xF91
comma
l_int|0x1B
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|5
op_star
l_int|64
op_star
l_int|1024
suffix:semicolon
id|i
op_ne
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
l_int|0x534
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
id|saved
op_assign
(paren
id|inb
c_func
(paren
l_int|0x534
)paren
op_amp
l_int|0xE0
)paren
op_or
l_int|0x0A
suffix:semicolon
id|outb
c_func
(paren
id|saved
comma
l_int|0x534
)paren
suffix:semicolon
id|special_mask
op_assign
(paren
id|inb
c_func
(paren
l_int|0x535
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x08
suffix:semicolon
id|saved
op_assign
(paren
id|inb
c_func
(paren
l_int|0x534
)paren
op_amp
l_int|0xE0
)paren
op_or
l_int|0x0C
suffix:semicolon
id|outb
c_func
(paren
id|saved
comma
l_int|0x534
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|inb
c_func
(paren
l_int|0x535
)paren
)paren
(brace
r_case
l_int|0x09
suffix:colon
r_case
l_int|0x0A
suffix:colon
id|special_mask
op_or_assign
l_int|0x05
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8A
suffix:colon
id|special_mask
op_assign
l_int|0x0F
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Strange MediaMagic, but&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Conf:&quot;
)paren
suffix:semicolon
id|saved
op_assign
id|inb
c_func
(paren
l_int|0x534
)paren
op_amp
l_int|0xE0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x20
op_or
(paren
id|u_char
)paren
id|i
comma
l_int|0x534
)paren
suffix:semicolon
id|outb
c_func
(paren
id|defaults
(braket
id|i
)braket
comma
l_int|0x535
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x20
op_or
(paren
id|u_char
)paren
id|i
comma
l_int|0x534
)paren
suffix:semicolon
id|saved
op_assign
id|inb
c_func
(paren
l_int|0x535
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|saved
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ISP16_OUT
c_func
(paren
l_int|0xF91
comma
l_int|0xA0
op_or
id|special_mask
)paren
suffix:semicolon
multiline_comment|/*&n;   * The following have no explaination yet.&n;   */
id|ISP16_OUT
c_func
(paren
l_int|0xF90
comma
l_int|0xA2
)paren
suffix:semicolon
id|ISP16_OUT
c_func
(paren
l_int|0xF92
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/*&n;   * Turn general sound on and set total volume.&n;   */
id|ISP16_OUT
c_func
(paren
l_int|0xF93
comma
l_int|0x0A
)paren
suffix:semicolon
multiline_comment|/*&n;  outb( 0x04, 0x224 );&n;  saved = inb( 0x225 );&n;  outb( 0x04, 0x224 );&n;  outb( saved, 0x225 );&n;*/
)brace
eof
