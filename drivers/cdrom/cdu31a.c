multiline_comment|/*&n;* Sony CDU-31A CDROM interface device driver.&n;*&n;* Corey Minyard (minyard@wf-rch.cirr.com)&n;*&n;* Colossians 3:17&n;*&n;*  See Documentation/cdrom/cdu31a for additional details about this driver.&n;* &n;* The Sony interface device driver handles Sony interface CDROM&n;* drives and provides a complete block-level interface as well as an&n;* ioctl() interface compatible with the Sun (as specified in&n;* include/linux/cdrom.h).  With this interface, CDROMs can be&n;* accessed and standard audio CDs can be played back normally.&n;*&n;* WARNING - &t;All autoprobes have been removed from the driver.&n;*&t;&t;You MUST configure the CDU31A via a LILO config&n;*&t;&t;at boot time or in lilo.conf.  I have the&n;*&t;&t;following in my lilo.conf:&n;*&n;*                append=&quot;cdu31a=0x1f88,0,PAS&quot;&n;*&n;*&t;&t;The first number is the I/O base address of the&n;*&t;&t;card.  The second is the interrupt (0 means none).&n; *&t;&t;The third should be &quot;PAS&quot; if on a Pro-Audio&n; *&t;&t;spectrum, or nothing if on something else.&n; *&n; * This interface is (unfortunately) a polled interface.  This is&n; * because most Sony interfaces are set up with DMA and interrupts&n; * disables.  Some (like mine) do not even have the capability to&n; * handle interrupts or DMA.  For this reason you will see a lot of&n; * the following:&n; *&n; *   retry_count = jiffies+ SONY_JIFFIES_TIMEOUT;&n; *   while (time_before(jiffies, retry_count) &amp;&amp; (! &lt;some condition to wait for))&n; *   {&n; *      while (handle_sony_cd_attention())&n; *         ;&n; *&n; *      sony_sleep();&n; *   }&n; *   if (the condition not met)&n; *   {&n; *      return an error;&n; *   }&n; *&n; * This ugly hack waits for something to happen, sleeping a little&n; * between every try.  it also handles attentions, which are&n; * asynchronous events from the drive informing the driver that a disk&n; * has been inserted, removed, etc.&n; *&n; * NEWS FLASH - The driver now supports interrupts but they are&n; * turned off by default.  Use of interrupts is highly encouraged, it&n; * cuts CPU usage down to a reasonable level.  I had DMA in for a while&n; * but PC DMA is just too slow.  Better to just insb() it.&n; *&n; * One thing about these drives: They talk in MSF (Minute Second Frame) format.&n; * There are 75 frames a second, 60 seconds a minute, and up to 75 minutes on a&n; * disk.  The funny thing is that these are sent to the drive in BCD, but the&n; * interface wants to see them in decimal.  A lot of conversion goes on.&n; *&n; * DRIVER SPECIAL FEATURES&n; * -----------------------&n; *&n; * This section describes features beyond the normal audio and CD-ROM&n; * functions of the drive.&n; *&n; * 2048 byte buffer mode&n; *&n; * If a disk is mounted with -o block=2048, data is copied straight&n; * from the drive data port to the buffer.  Otherwise, the readahead&n; * buffer must be involved to hold the other 1K of data when a 1K&n; * block operation is done.  Note that with 2048 byte blocks you&n; * cannot execute files from the CD.&n; *&n; * XA compatibility&n; *&n; * The driver should support XA disks for both the CDU31A and CDU33A.&n; * It does this transparently, the using program doesn&squot;t need to set it.&n; *&n; * Multi-Session&n; *&n; * A multi-session disk looks just like a normal disk to the user.&n; * Just mount one normally, and all the data should be there.&n; * A special thanks to Koen for help with this!&n; * &n; * Raw sector I/O&n; *&n; * Using the CDROMREADAUDIO it is possible to read raw audio and data&n; * tracks.  Both operations return 2352 bytes per sector.  On the data&n; * tracks, the first 12 bytes is not returned by the drive and the value&n; * of that data is indeterminate.&n; *&n; *&n; *  Copyright (C) 1993  Corey Minyard&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * TODO: &n; *       CDs with form1 and form2 sectors cause problems&n; *       with current read-ahead strategy.&n; *&n; * Credits:&n; *    Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt;&n; *         For finding abug in the return of the track numbers.&n; *         TOC processing redone for proper multisession support.&n; *&n; *&n; *  It probably a little late to be adding a history, but I guess I&n; *  will start.&n; *&n; *  10/24/95 - Added support for disabling the eject button when the&n; *             drive is open.  Note that there is a small problem&n; *             still here, if the eject button is pushed while the&n; *             drive light is flashing, the drive will return a bad&n; *             status and be reset.  It recovers, though.&n; *&n; *  03/07/97 - Fixed a problem with timers.&n; *&n; *&n; *  18 Spetember 1997 -- Ported to Uniform CD-ROM driver by &n; *                 Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt; with additional&n; *                 changes by Erik Andersen &lt;andersee@debian.org&gt;&n; *&n; *  24 January 1998 -- Removed the scd_disc_status() function, which was now&n; *                     just dead code left over from the port.&n; *                          Erik Andersen &lt;andersee@debian.org&gt;&n; *&n; *  16 July 1998 -- Drive donated to Erik Andersen by John Kodis&n; *                   &lt;kodis@jagunet.com&gt;.  Work begun on fixing driver to&n; *                   work under 2.1.X.  Added temporary extra printks&n; *                   which seem to slow it down enough to work.&n; *&n; *  9 November 1999 -- Make kernel-parameter implementation work with 2.3.x &n; *&t;               Removed init_module &amp; cleanup_module in favor of &n; *&t;&t;       module_init &amp; module_exit.&n; *&t;&t;       Torben Mathiasen &lt;tmm@image.dk&gt;&n;*/
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &quot;cdu31a.h&quot;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR CDU31A_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|CDU31A_READAHEAD
mdefine_line|#define CDU31A_READAHEAD 4  /* 128 sector, 64kB, 32 reads read-ahead */
DECL|macro|CDU31A_MAX_CONSECUTIVE_ATTENTIONS
mdefine_line|#define CDU31A_MAX_CONSECUTIVE_ATTENTIONS 10
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
multiline_comment|/* Define the following if you have data corruption problems. */
DECL|macro|SONY_POLL_EACH_BYTE
macro_line|#undef SONY_POLL_EACH_BYTE
multiline_comment|/*&n;** Edit the following data to change interrupts, DMA channels, etc.&n;** Default is polled and no DMA.  DMA is not recommended for double-speed&n;** drives.&n;*/
r_static
r_struct
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* I/O Base Address */
DECL|member|int_num
r_int
id|int_num
suffix:semicolon
multiline_comment|/* Interrupt Number (-1 means scan for it,&n;                                   0 means don&squot;t use) */
DECL|variable|__initdata
)brace
id|cdu31a_addresses
(braket
)braket
id|__initdata
op_assign
(brace
macro_line|#if 0&t;/* No autoconfig any more. See Note at beginning&n;&t;   of this file. */
(brace
l_int|0x340
comma
l_int|0
)brace
comma
multiline_comment|/* Standard configuration Sony Interface */
(brace
l_int|0x1f88
comma
l_int|0
)brace
comma
multiline_comment|/* Fusion CD-16 */
(brace
l_int|0x230
comma
l_int|0
)brace
comma
multiline_comment|/* SoundBlaster 16 card */
(brace
l_int|0x360
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x320
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x330
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x634
comma
l_int|0
)brace
comma
multiline_comment|/* Sound FX SC400 */
(brace
l_int|0x654
comma
l_int|0
)brace
comma
multiline_comment|/* Sound FX SC400 */
macro_line|#endif
(brace
l_int|0
)brace
)brace
suffix:semicolon
r_static
r_int
id|handle_sony_cd_attention
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|read_subcode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sony_get_toc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|scd_spinup
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*static int scd_open(struct inode *inode, struct file *filp);*/
r_static
r_int
id|scd_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|do_sony_cd_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
suffix:semicolon
r_static
r_void
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|buf
)paren
suffix:semicolon
multiline_comment|/* Parameters for the read-ahead. */
DECL|variable|sony_next_block
r_static
r_int
r_int
id|sony_next_block
suffix:semicolon
multiline_comment|/* Next 512 byte block offset */
DECL|variable|sony_blocks_left
r_static
r_int
r_int
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of 512 byte blocks left&n;                                             in the current read command. */
multiline_comment|/* The base I/O address of the Sony Interface.  This is a variable (not a&n;   #define) so it can be easily changed via some future ioctl() */
DECL|variable|cdu31a_port
r_static
r_int
r_int
id|cdu31a_port
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cdu31a_port
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * The following are I/O addresses of the various registers for the drive.  The&n; * comment for the base address also applies here.&n; */
DECL|variable|sony_cd_cmd_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_cmd_reg
suffix:semicolon
DECL|variable|sony_cd_param_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_param_reg
suffix:semicolon
DECL|variable|sony_cd_write_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_write_reg
suffix:semicolon
DECL|variable|sony_cd_control_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_control_reg
suffix:semicolon
DECL|variable|sony_cd_status_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_status_reg
suffix:semicolon
DECL|variable|sony_cd_result_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_result_reg
suffix:semicolon
DECL|variable|sony_cd_read_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_read_reg
suffix:semicolon
DECL|variable|sony_cd_fifost_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_fifost_reg
suffix:semicolon
DECL|variable|sony_spun_up
r_static
r_int
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Has the drive been spun up? */
DECL|variable|sony_speed
r_static
r_int
id|sony_speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Last wanted speed */
DECL|variable|sony_xa_mode
r_static
r_int
id|sony_xa_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is an XA disk in the drive&n;&t;&t;&t;&t;&t;      and the drive a CDU31A? */
DECL|variable|sony_raw_data_mode
r_static
r_int
id|sony_raw_data_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 if data tracks, 0 if audio.&n;                                              For raw data reads. */
DECL|variable|sony_usage
r_static
r_int
r_int
id|sony_usage
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How many processes have the&n;                                              drive open. */
DECL|variable|sony_pas_init
r_static
r_int
id|sony_pas_init
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the Pro-Audio&n;&t;&t;&t;&t;&t;      Spectrum card? */
DECL|variable|single_toc
r_static
r_struct
id|s_sony_session_toc
id|single_toc
suffix:semicolon
multiline_comment|/* Holds the&n;&t;&t;&t;&t;&t;         table of&n;&t;&t;&t;&t;&t;         contents. */
DECL|variable|sony_toc
r_static
r_struct
id|s_all_sessions_toc
id|sony_toc
suffix:semicolon
multiline_comment|/* entries gathered from all&n;                                                sessions */
DECL|variable|sony_toc_read
r_static
r_int
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Has the TOC been read for&n;&t;&t;&t;&t;&t;      the drive? */
DECL|variable|last_sony_subcode
r_static
r_struct
id|s_sony_subcode
id|last_sony_subcode
suffix:semicolon
multiline_comment|/* Points to the last&n;                                                   subcode address read */
DECL|variable|sony_inuse
r_static
r_volatile
r_int
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the drive in use?  Only one operation&n;&t;&t;&t;&t;&t;at a time allowed */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|sony_wait
)paren
suffix:semicolon
multiline_comment|/* Things waiting for the drive */
DECL|variable|has_cd_task
r_static
r_struct
id|task_struct
op_star
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The task that is currently&n;&t;&t;&t;&t;&t;&t;   using the CDROM drive, or&n;&t;&t;&t;&t;&t;&t;   NULL if none. */
DECL|variable|is_double_speed
r_static
r_int
id|is_double_speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* does the drive support double speed ? */
DECL|variable|is_a_cdu31a
r_static
r_int
id|is_a_cdu31a
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Is the drive a CDU31A? */
DECL|variable|is_auto_eject
r_static
r_int
id|is_auto_eject
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Door has been locked? 1=No/0=Yes */
multiline_comment|/*&n; * The audio status uses the values from read subchannel data as specified&n; * in include/linux/cdrom.h.&n; */
DECL|variable|sony_audio_status
r_static
r_volatile
r_int
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
multiline_comment|/*&n; * The following are a hack for pausing and resuming audio play.  The drive&n; * does not work as I would expect it, if you stop it then start it again,&n; * the drive seeks back to the beginning and starts over.  This holds the&n; * position during a pause so a resume can restart it.  It uses the&n; * audio status variable above to tell if it is paused.&n; */
DECL|variable|cur_pos_msf
r_static
r_int
r_volatile
r_char
id|cur_pos_msf
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|final_pos_msf
r_static
r_int
r_volatile
r_char
id|final_pos_msf
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* What IRQ is the drive using?  0 if none. */
DECL|variable|cdu31a_irq
r_static
r_int
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cdu31a_irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* The interrupt handler will wake this queue up when it gets an&n;   interrupts. */
DECL|variable|cdu31a_irq_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|cdu31a_irq_wait
)paren
suffix:semicolon
DECL|variable|curr_control_reg
r_static
r_int
id|curr_control_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Current value of the control register */
multiline_comment|/* A disk changed variable.  When a disk change is detected, it will&n;   all be set to TRUE.  As the upper layers ask for disk_changed status&n;   it will be cleared. */
DECL|variable|disk_changed
r_static
r_char
id|disk_changed
suffix:semicolon
multiline_comment|/* Variable for using the readahead buffer.  The readahead buffer&n;   is used for raw sector reads and for blocksizes that are smaller&n;   than 2048 bytes. */
DECL|variable|readahead_buffer
r_static
r_char
id|readahead_buffer
(braket
id|CD_FRAMESIZE_RAW
)braket
suffix:semicolon
DECL|variable|readahead_dataleft
r_static
r_int
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
DECL|variable|readahead_bad
r_static
r_int
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Used to time a short period to abort an operation after the&n;   drive has been idle for a while.  This keeps the light on&n;   the drive from flashing for very long. */
DECL|variable|cdu31a_abort_timer
r_static
r_struct
id|timer_list
id|cdu31a_abort_timer
suffix:semicolon
multiline_comment|/* Marks if the timeout has started an abort read.  This is used&n;   on entry to the drive to tell the code to read out the status&n;   from the abort read. */
DECL|variable|abort_read_started
r_static
r_int
id|abort_read_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This routine returns 1 if the disk has been changed since the last&n; * check or 0 if it hasn&squot;t.&n; */
r_static
r_int
DECL|function|scd_disk_change
id|scd_disk_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|disk_changed
suffix:semicolon
id|disk_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * report back, if disc has changed from time of last request.&n; */
r_static
r_int
DECL|function|scd_media_changed
id|scd_media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|disc_nr
)paren
(brace
r_return
id|scd_disk_change
c_func
(paren
id|cdi-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * report back, if drive is ready&n; */
DECL|function|scd_drive_status
r_static
r_int
id|scd_drive_status
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
r_if
c_cond
(paren
id|CDSL_CURRENT
op_ne
id|slot_nr
)paren
(brace
multiline_comment|/* we have no changer support */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd_spinup
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
id|sony_spun_up
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|sony_spun_up
ques
c_cond
id|CDS_DISC_OK
suffix:colon
id|CDS_DRIVE_NOT_READY
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|enable_interrupts
id|enable_interrupts
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_or_assign
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|disable_interrupts
id|disable_interrupts
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_and_assign
op_complement
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait a little while (used for polling the drive).  If in initialization,&n; * setting a timeout doesn&squot;t work, so just loop for a while.&n; */
r_static
r_inline
r_void
DECL|function|sony_sleep
id|sony_sleep
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|cdu31a_irq
op_le
l_int|0
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Interrupt driven */
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|enable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following are convenience routine to read various status and set&n; * various conditions in the drive.&n; */
r_static
r_inline
r_int
DECL|function|is_attention
id|is_attention
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_ATTN_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_busy
id|is_busy
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_BUSY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_data_ready
id|is_data_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_DATA_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_data_requested
id|is_data_requested
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_DATA_REQUEST_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_result_ready
id|is_result_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_RES_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_param_write_rdy
id|is_param_write_rdy
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_fifost_reg
)paren
op_amp
id|SONY_PARAM_WRITE_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_result_reg_not_empty
id|is_result_reg_not_empty
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_fifost_reg
)paren
op_amp
id|SONY_RES_REG_NOT_EMP_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|reset_drive
id|reset_drive
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_assign
l_int|0
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|SONY_DRIVE_RESET_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * reset drive and return when it is ready&n; */
DECL|function|scd_reset
r_static
r_int
id|scd_reset
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_int
id|retry_count
suffix:semicolon
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_attention
id|clear_attention
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_ATTN_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_result_ready
id|clear_result_ready
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_RES_RDY_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_data_ready
id|clear_data_ready
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_DATA_RDY_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_param_reg
id|clear_param_reg
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_PARAM_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_status_register
id|read_status_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_result_register
id|read_result_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_result_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_data_register
id|read_data_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_read_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_param
id|write_param
c_func
(paren
r_int
r_char
id|param
)paren
(brace
id|outb
c_func
(paren
id|param
comma
id|sony_cd_param_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_cmd
id|write_cmd
c_func
(paren
r_int
r_char
id|cmd
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_RES_RDY_INT_EN_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmd
comma
id|sony_cd_cmd_reg
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cdu31a_interrupt
id|cdu31a_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_if
c_cond
(paren
id|abort_read_started
)paren
(brace
multiline_comment|/* We might be waiting for an abort to finish.  Don&squot;t&n;         disable interrupts yet, though, because we handle&n;         this one here. */
multiline_comment|/* Clear out the result registers. */
r_while
c_loop
(paren
id|is_result_reg_not_empty
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear out the data */
r_while
c_loop
(paren
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|abort_read_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If something was waiting, wake it up now. */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
)paren
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
)paren
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CDU31A: Got an interrupt but nothing was waiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * give more verbose error messages&n; */
DECL|function|translate_error
r_static
r_int
r_char
op_star
id|translate_error
c_func
(paren
r_int
r_char
id|err_code
)paren
(brace
r_static
r_int
r_char
id|errbuf
(braket
l_int|80
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|err_code
)paren
(brace
r_case
l_int|0x10
suffix:colon
r_return
l_string|&quot;illegal command &quot;
suffix:semicolon
r_case
l_int|0x11
suffix:colon
r_return
l_string|&quot;illegal parameter &quot;
suffix:semicolon
r_case
l_int|0x20
suffix:colon
r_return
l_string|&quot;not loaded &quot;
suffix:semicolon
r_case
l_int|0x21
suffix:colon
r_return
l_string|&quot;no disc &quot;
suffix:semicolon
r_case
l_int|0x22
suffix:colon
r_return
l_string|&quot;not spinning &quot;
suffix:semicolon
r_case
l_int|0x23
suffix:colon
r_return
l_string|&quot;spinning &quot;
suffix:semicolon
r_case
l_int|0x25
suffix:colon
r_return
l_string|&quot;spindle servo &quot;
suffix:semicolon
r_case
l_int|0x26
suffix:colon
r_return
l_string|&quot;focus servo &quot;
suffix:semicolon
r_case
l_int|0x29
suffix:colon
r_return
l_string|&quot;eject mechanism &quot;
suffix:semicolon
r_case
l_int|0x2a
suffix:colon
r_return
l_string|&quot;audio playing &quot;
suffix:semicolon
r_case
l_int|0x2c
suffix:colon
r_return
l_string|&quot;emergency eject &quot;
suffix:semicolon
r_case
l_int|0x30
suffix:colon
r_return
l_string|&quot;focus &quot;
suffix:semicolon
r_case
l_int|0x31
suffix:colon
r_return
l_string|&quot;frame sync &quot;
suffix:semicolon
r_case
l_int|0x32
suffix:colon
r_return
l_string|&quot;subcode address &quot;
suffix:semicolon
r_case
l_int|0x33
suffix:colon
r_return
l_string|&quot;block sync &quot;
suffix:semicolon
r_case
l_int|0x34
suffix:colon
r_return
l_string|&quot;header address &quot;
suffix:semicolon
r_case
l_int|0x40
suffix:colon
r_return
l_string|&quot;illegal track read &quot;
suffix:semicolon
r_case
l_int|0x41
suffix:colon
r_return
l_string|&quot;mode 0 read &quot;
suffix:semicolon
r_case
l_int|0x42
suffix:colon
r_return
l_string|&quot;illegal mode read &quot;
suffix:semicolon
r_case
l_int|0x43
suffix:colon
r_return
l_string|&quot;illegal block size read &quot;
suffix:semicolon
r_case
l_int|0x44
suffix:colon
r_return
l_string|&quot;mode read &quot;
suffix:semicolon
r_case
l_int|0x45
suffix:colon
r_return
l_string|&quot;form read &quot;
suffix:semicolon
r_case
l_int|0x46
suffix:colon
r_return
l_string|&quot;leadout read &quot;
suffix:semicolon
r_case
l_int|0x47
suffix:colon
r_return
l_string|&quot;buffer overrun &quot;
suffix:semicolon
r_case
l_int|0x53
suffix:colon
r_return
l_string|&quot;unrecoverable CIRC &quot;
suffix:semicolon
r_case
l_int|0x57
suffix:colon
r_return
l_string|&quot;unrecoverable LECC &quot;
suffix:semicolon
r_case
l_int|0x60
suffix:colon
r_return
l_string|&quot;no TOC &quot;
suffix:semicolon
r_case
l_int|0x61
suffix:colon
r_return
l_string|&quot;invalid subcode data &quot;
suffix:semicolon
r_case
l_int|0x63
suffix:colon
r_return
l_string|&quot;focus on TOC read &quot;
suffix:semicolon
r_case
l_int|0x64
suffix:colon
r_return
l_string|&quot;frame sync on TOC read &quot;
suffix:semicolon
r_case
l_int|0x65
suffix:colon
r_return
l_string|&quot;TOC data &quot;
suffix:semicolon
r_case
l_int|0x70
suffix:colon
r_return
l_string|&quot;hardware failure &quot;
suffix:semicolon
r_case
l_int|0x91
suffix:colon
r_return
l_string|&quot;leadin &quot;
suffix:semicolon
r_case
l_int|0x92
suffix:colon
r_return
l_string|&quot;leadout &quot;
suffix:semicolon
r_case
l_int|0x93
suffix:colon
r_return
l_string|&quot;data track &quot;
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|errbuf
comma
l_string|&quot;unknown 0x%02x &quot;
comma
id|err_code
)paren
suffix:semicolon
r_return
id|errbuf
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the drive parameters so the drive will auto-spin-up when a&n; * disk is inserted.&n; */
r_static
r_void
DECL|function|set_drive_params
id|set_drive_params
c_func
(paren
r_int
id|want_doublespeed
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|3
)braket
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_AUTO_SPIN_DOWN_TIME
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Never spin down the drive. */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  Unable to set spin-down time: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_MECH_CONTROL
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
id|SONY_AUTO_SPIN_UP_BIT
suffix:semicolon
multiline_comment|/* Set auto spin up */
r_if
c_cond
(paren
id|is_auto_eject
)paren
id|params
(braket
l_int|1
)braket
op_or_assign
id|SONY_AUTO_EJECT_BIT
suffix:semicolon
r_if
c_cond
(paren
id|is_double_speed
op_logical_and
id|want_doublespeed
)paren
(brace
id|params
(braket
l_int|1
)braket
op_or_assign
id|SONY_DOUBLE_SPEED_BIT
suffix:semicolon
multiline_comment|/* Set the drive to double speed if &n;                                             possible */
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  Unable to set mechanical parameters: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * select reading speed for data access&n; */
DECL|function|scd_select_speed
r_static
r_int
id|scd_select_speed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|speed
)paren
(brace
r_if
c_cond
(paren
id|speed
op_eq
l_int|0
)paren
id|sony_speed
op_assign
l_int|1
suffix:semicolon
r_else
id|sony_speed
op_assign
id|speed
op_minus
l_int|1
suffix:semicolon
id|set_drive_params
c_func
(paren
id|sony_speed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * lock or unlock eject button&n; */
DECL|function|scd_lock_door
r_static
r_int
id|scd_lock_door
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|lock
)paren
(brace
r_if
c_cond
(paren
id|lock
op_eq
l_int|0
op_logical_and
id|sony_usage
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Unlock the door, only if nobody is using the drive */
id|is_auto_eject
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|is_auto_eject
op_assign
l_int|0
suffix:semicolon
)brace
id|set_drive_params
c_func
(paren
id|sony_speed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This code will reset the drive and attempt to restore sane parameters.&n; */
r_static
r_void
DECL|function|restart_on_error
id|restart_on_error
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cdu31a: Resetting drive on error&bslash;n&quot;
)paren
suffix:semicolon
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_drive_params
c_func
(paren
id|sony_speed
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Unable to spin up drive: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine writes data to the parameter register.  Since this should&n; * happen fairly fast, it is polled with no OS waits between.&n; */
r_static
r_int
DECL|function|write_params
id|write_params
c_func
(paren
r_int
r_char
op_star
id|params
comma
r_int
id|num_params
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_param_write_rdy
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_param_write_rdy
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
id|num_params
OG
l_int|0
)paren
(brace
id|write_param
c_func
(paren
op_star
id|params
)paren
suffix:semicolon
id|params
op_increment
suffix:semicolon
id|num_params
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The following reads data from the command result register.  It is a&n; * fairly complex routine, all status info flows back through this&n; * interface.  The algorithm is stolen directly from the flowcharts in&n; * the drive manual.&n; */
r_static
r_void
DECL|function|get_result
id|get_result
c_func
(paren
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_char
id|a
comma
id|b
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the result data to be ready */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;    * Get the first two bytes.  This determines what else needs&n;    * to be done.&n;    */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|a
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
op_star
id|result_buffer
op_assign
id|a
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
multiline_comment|/* Check for block error status result. */
r_if
c_cond
(paren
(paren
id|a
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
op_star
id|result_size
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|b
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
op_star
id|result_buffer
op_assign
id|b
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;    * 0x20 means an error occurred.  Byte 2 will have the error code.&n;    * Otherwise, the command succeeded, byte 2 will have the count of&n;    * how many more status bytes are coming.&n;    *&n;    * The result register can be read 10 bytes at a time, a wait for&n;    * result ready to be asserted must be done between every 10 bytes.&n;    */
r_if
c_cond
(paren
(paren
id|a
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|b
OG
l_int|8
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
)brace
id|b
op_assign
id|b
op_minus
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|b
OG
l_int|10
)paren
(brace
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
)brace
id|b
op_assign
id|b
op_minus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
id|b
OG
l_int|0
)paren
(brace
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|b
OG
l_int|0
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
id|b
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Do a command that does not involve data transfer.  This routine must&n; * be re-entrant from the same task to support being called from the&n; * data operation code when an error occurs.&n; */
r_static
r_void
DECL|function|do_sony_cd_cmd
id|do_sony_cd_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
id|num_retries
suffix:semicolon
r_int
id|recursive_call
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
id|has_cd_task
)paren
multiline_comment|/* Allow recursive calls to this routine */
(brace
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_SIGNAL_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
id|recursive_call
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|recursive_call
op_assign
l_int|1
suffix:semicolon
)brace
id|num_retries
op_assign
l_int|0
suffix:semicolon
id|retry_cd_operation
suffix:colon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_params
c_func
(paren
id|params
comma
id|num_params
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|get_result
c_func
(paren
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|result_buffer
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
op_logical_and
(paren
id|num_retries
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_retries
op_increment
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Wait .1 seconds on retries */
r_goto
id|retry_cd_operation
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|recursive_call
)paren
(brace
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle an attention from the drive.  This will return 1 if it found one&n; * or 0 if not (if one is found, the caller might want to call again).&n; *&n; * This routine counts the number of consecutive times it is called&n; * (since this is always called from a while loop until it returns&n; * a 0), and returns a 0 if it happens too many times.  This will help&n; * prevent a lockup.&n; */
r_static
r_int
DECL|function|handle_sony_cd_attention
id|handle_sony_cd_attention
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|atten_code
suffix:semicolon
r_static
r_int
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_volatile
r_int
id|val
suffix:semicolon
macro_line|#if 0*DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering handle_sony_cd_attention&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|is_attention
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_consecutive_attentions
OG
id|CDU31A_MAX_CONSECUTIVE_ATTENTIONS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Too many consecutive attentions: %d&bslash;n&quot;
comma
id|num_consecutive_attentions
)paren
suffix:semicolon
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving handle_sony_cd_attention at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|clear_attention
c_func
(paren
)paren
suffix:semicolon
id|atten_code
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|atten_code
)paren
(brace
multiline_comment|/* Someone changed the CD.  Mark it as changed */
r_case
id|SONY_MECH_LOADED_ATTN
suffix:colon
id|disk_changed
op_assign
l_int|1
suffix:semicolon
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_SPIN_DOWN_COMPLETE_ATTN
suffix:colon
multiline_comment|/* Mark the disk as spun down. */
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_AUDIO_PLAY_DONE_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
id|read_subcode
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_EJECT_PUSHED_ATTN
suffix:colon
r_if
c_cond
(paren
id|is_auto_eject
)paren
(brace
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SONY_LEAD_IN_ERR_ATTN
suffix:colon
r_case
id|SONY_LEAD_OUT_ERR_ATTN
suffix:colon
r_case
id|SONY_DATA_TRACK_ERR_ATTN
suffix:colon
r_case
id|SONY_AUDIO_PLAYBACK_ERR_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num_consecutive_attentions
op_increment
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving handle_sony_cd_attention at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|abort_read_started
)paren
(brace
r_while
c_loop
(paren
id|is_result_reg_not_empty
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear out the data */
r_while
c_loop
(paren
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|abort_read_started
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving handle_sony_cd_attention at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0*DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving handle_sony_cd_attention at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Convert from an integer 0-99 to BCD */
r_static
r_inline
r_int
r_int
DECL|function|int_to_bcd
id|int_to_bcd
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
(paren
id|val
op_div
l_int|10
)paren
op_lshift
l_int|4
suffix:semicolon
id|retval
op_assign
id|retval
op_or
id|val
op_mod
l_int|10
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Convert from BCD to an integer from 0-99 */
r_static
r_int
r_int
DECL|function|bcd_to_int
id|bcd_to_int
c_func
(paren
r_int
r_int
id|bcd
)paren
(brace
r_return
(paren
(paren
(paren
id|bcd
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|bcd
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a logical sector value (like the OS would want to use for&n; * a block device) to an MSF format.&n; */
r_static
r_void
DECL|function|log_to_msf
id|log_to_msf
c_func
(paren
r_int
r_int
id|log
comma
r_int
r_char
op_star
id|msf
)paren
(brace
id|log
op_assign
id|log
op_plus
id|LOG_START_OFFSET
suffix:semicolon
id|msf
(braket
l_int|0
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|4500
)paren
suffix:semicolon
id|log
op_assign
id|log
op_mod
l_int|4500
suffix:semicolon
id|msf
(braket
l_int|1
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|75
)paren
suffix:semicolon
id|msf
(braket
l_int|2
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_mod
l_int|75
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an MSF format to a logical sector.&n; */
r_static
r_int
r_int
DECL|function|msf_to_log
id|msf_to_log
c_func
(paren
r_int
r_char
op_star
id|msf
)paren
(brace
r_int
r_int
id|log
suffix:semicolon
id|log
op_assign
id|msf
(braket
l_int|2
)braket
suffix:semicolon
id|log
op_add_assign
id|msf
(braket
l_int|1
)braket
op_star
l_int|75
suffix:semicolon
id|log
op_add_assign
id|msf
(braket
l_int|0
)braket
op_star
l_int|4500
suffix:semicolon
id|log
op_assign
id|log
op_minus
id|LOG_START_OFFSET
suffix:semicolon
r_return
id|log
suffix:semicolon
)brace
multiline_comment|/*&n; * Take in integer size value and put it into a buffer like&n; * the drive would want to see a number-of-sector value.&n; */
r_static
r_void
DECL|function|size_to_buf
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|size
op_div
l_int|65536
suffix:semicolon
id|size
op_assign
id|size
op_mod
l_int|65536
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|size
op_div
l_int|256
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|size
op_mod
l_int|256
suffix:semicolon
)brace
multiline_comment|/* Starts a read operation. Returns 0 on success and 1 on failure. &n;   The read operation used here allows multiple sequential sectors &n;   to be read and status returned for each sector.  The driver will&n;   read the output one at a time as the requests come and abort the&n;   operation if the requested sector is not the next one from the&n;   drive. */
r_static
r_int
DECL|function|start_request
id|start_request
c_func
(paren
r_int
r_int
id|sector
comma
r_int
r_int
id|nsect
comma
r_int
id|read_nsect_only
)paren
(brace
r_int
r_char
id|params
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_int
id|read_size
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering start_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|log_to_msf
c_func
(paren
id|sector
comma
id|params
)paren
suffix:semicolon
multiline_comment|/* If requested, read exactly what was asked. */
r_if
c_cond
(paren
id|read_nsect_only
)paren
(brace
id|read_size
op_assign
id|nsect
suffix:semicolon
)brace
multiline_comment|/*&n;    * If the full read-ahead would go beyond the end of the media, trim&n;    * it back to read just till the end of the media.&n;    */
r_else
r_if
c_cond
(paren
(paren
id|sector
op_plus
id|nsect
)paren
op_ge
id|sony_toc.lead_out_start_lba
)paren
(brace
id|read_size
op_assign
id|sony_toc.lead_out_start_lba
op_minus
id|sector
suffix:semicolon
)brace
multiline_comment|/* Read the full readahead amount. */
r_else
(brace
id|read_size
op_assign
id|CDU31A_READAHEAD
op_div
l_int|4
suffix:semicolon
)brace
id|size_to_buf
c_func
(paren
id|read_size
comma
op_amp
id|params
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;    * Clear any outstanding attentions and wait for the drive to&n;    * complete any pending operations.&n;    */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Timeout while waiting to issue command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving start_request at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Issue the command */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_params
c_func
(paren
id|params
comma
l_int|6
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|SONY_READ_BLKERR_STAT_CMD
)paren
suffix:semicolon
id|sony_blocks_left
op_assign
id|read_size
op_star
l_int|4
suffix:semicolon
id|sony_next_block
op_assign
id|sector
op_star
l_int|4
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving start_request at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving start_request at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Abort a pending read operation.  Clear all the drive status and&n;   readahead variables. */
r_static
r_void
DECL|function|abort_read
id|abort_read
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|result_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|result_size
suffix:semicolon
r_volatile
r_int
id|val
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_ABORT_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|result_reg
comma
op_amp
id|result_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error aborting read, %s error&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|result_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|is_result_reg_not_empty
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear out the data */
r_while
c_loop
(paren
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called when the timer times out.  This will abort the&n;   pending read operation. */
r_static
r_void
DECL|function|handle_abort_timeout
id|handle_abort_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering handle_abort_timeout&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If it is in use, ignore it. */
r_if
c_cond
(paren
op_logical_neg
id|sony_inuse
)paren
(brace
multiline_comment|/* We can&squot;t use abort_read(), because it will sleep&n;         or schedule in the timer interrupt.  Just start&n;         the operation, finish it on the next access to&n;         the drive. */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|SONY_ABORT_CMD
)paren
suffix:semicolon
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
id|abort_read_started
op_assign
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving handle_abort_timeout&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Actually get data and status from the drive. */
r_static
r_void
DECL|function|input_data
id|input_data
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_int
id|bytesleft
comma
r_int
r_int
id|nblocks
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|skip
)paren
(brace
r_int
id|i
suffix:semicolon
r_volatile
r_int
r_char
id|val
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering input_data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If an XA disk on a CDU31A, skip the first 12 bytes of data from&n;      the disk.  The real data is after that. */
r_if
c_cond
(paren
id|sony_xa_mode
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_XA_HEAD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytesleft
op_eq
l_int|2048
)paren
multiline_comment|/* 2048 byte direct buffer transfer */
(brace
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|buffer
comma
l_int|2048
)paren
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the input read did not align with the beginning of the block,&n;&t; skip the necessary bytes. */
r_if
c_cond
(paren
id|skip
op_ne
l_int|0
)paren
(brace
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|readahead_buffer
comma
id|skip
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the data into the buffer. */
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
op_amp
id|buffer
(braket
id|offset
)braket
comma
id|bytesleft
)paren
suffix:semicolon
multiline_comment|/* Get the rest of the data into the readahead buffer at the&n;&t; proper location. */
id|readahead_dataleft
op_assign
(paren
l_int|2048
op_minus
id|skip
)paren
op_minus
id|bytesleft
suffix:semicolon
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|readahead_buffer
op_plus
id|bytesleft
comma
id|readahead_dataleft
)paren
suffix:semicolon
)brace
id|sony_blocks_left
op_sub_assign
id|nblocks
suffix:semicolon
id|sony_next_block
op_add_assign
id|nblocks
suffix:semicolon
multiline_comment|/* If an XA disk, we have to clear out the rest of the unused&n;      error correction data. */
r_if
c_cond
(paren
id|sony_xa_mode
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_XA_TAIL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving input_data at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* read data from the drive.  Note the nsect must be &lt;= 4. */
r_static
r_void
DECL|function|read_data_block
id|read_data_block
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_int
id|block
comma
r_int
r_int
id|nblocks
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
op_star
id|res_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
r_int
id|bytesleft
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|skip
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering read_data_block&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|res_size
op_assign
l_int|0
suffix:semicolon
id|bytesleft
op_assign
id|nblocks
op_star
l_int|512
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the data in the read-ahead does not match the block offset,&n;      then fix things up. */
r_if
c_cond
(paren
(paren
(paren
id|block
op_mod
l_int|4
)paren
op_star
l_int|512
)paren
op_ne
(paren
(paren
l_int|2048
op_minus
id|readahead_dataleft
)paren
op_mod
l_int|2048
)paren
)paren
(brace
id|sony_next_block
op_add_assign
id|block
op_mod
l_int|4
suffix:semicolon
id|sony_blocks_left
op_sub_assign
id|block
op_mod
l_int|4
suffix:semicolon
id|skip
op_assign
(paren
id|block
op_mod
l_int|4
)paren
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have readahead data in the buffer, get that first before we&n;      decide if a read is necessary. */
r_if
c_cond
(paren
id|readahead_dataleft
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bytesleft
OG
id|readahead_dataleft
)paren
(brace
multiline_comment|/* The readahead will not fill the requested buffer, but&n;&t;    get the data out of the readahead into the buffer. */
id|memcpy
c_func
(paren
id|buffer
comma
id|readahead_buffer
op_plus
(paren
l_int|2048
op_minus
id|readahead_dataleft
)paren
comma
id|readahead_dataleft
)paren
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|bytesleft
op_sub_assign
id|readahead_dataleft
suffix:semicolon
id|offset
op_add_assign
id|readahead_dataleft
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The readahead will fill the whole buffer, get the data&n;&t;    and return. */
id|memcpy
c_func
(paren
id|buffer
comma
id|readahead_buffer
op_plus
(paren
l_int|2048
op_minus
id|readahead_dataleft
)paren
comma
id|bytesleft
)paren
suffix:semicolon
id|readahead_dataleft
op_sub_assign
id|bytesleft
suffix:semicolon
id|bytesleft
op_assign
l_int|0
suffix:semicolon
id|sony_blocks_left
op_sub_assign
id|nblocks
suffix:semicolon
id|sony_next_block
op_add_assign
id|nblocks
suffix:semicolon
multiline_comment|/* If the data in the readahead is bad, return an error so the&n;&t;    driver will abort the buffer. */
r_if
c_cond
(paren
id|readahead_bad
)paren
(brace
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readahead_dataleft
op_eq
l_int|0
)paren
(brace
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Final transfer is done for read command, get final result. */
r_if
c_cond
(paren
id|sony_blocks_left
op_eq
l_int|0
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving read_data_block at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Got result that should have been error: %d&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|input_data
c_func
(paren
id|buffer
comma
id|bytesleft
comma
id|nblocks
comma
id|offset
comma
id|skip
)paren
suffix:semicolon
multiline_comment|/* Wait for the status from the drive. */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
multiline_comment|/* If we got a buffer status, handle that. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_CIRC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_LECC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_RECOV_LECC_ERR_BLK_STAT
)paren
)paren
(brace
multiline_comment|/* The data was successful, but if data was read from&n;&t;&t;  the readahead  and it was bad, set the whole&n;&t;&t;  buffer as bad. */
r_if
c_cond
(paren
id|readahead_bad
)paren
(brace
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data block error: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Data is in the readahead buffer but an error was returned.&n;                  Make sure future requests don&squot;t use the data. */
r_if
c_cond
(paren
id|bytesleft
op_ne
l_int|2048
)paren
(brace
id|readahead_bad
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Final transfer is done for read command, get final result. */
r_if
c_cond
(paren
id|sony_blocks_left
op_eq
l_int|0
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
multiline_comment|/* The drive gave me bad status, I don&squot;t know what to do.&n;               Reset the driver and return an error. */
id|printk
c_func
(paren
l_string|&quot;CDU31A: Invalid block status: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|restart_on_error
c_func
(paren
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving read_data_block at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The OS calls this to perform a read or write operation to the drive.&n; * Write obviously fail.  Reads to a read ahead of sony_buffer_size&n; * bytes to help speed operations.  This especially helps since the OS&n; * uses 1024 byte blocks and the drive uses 2048 byte blocks.  Since most&n; * data access on a CD is done sequentially, this saves a lot of operations.&n; */
r_static
r_void
DECL|function|do_cdu31a_request
id|do_cdu31a_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_int
id|block
suffix:semicolon
r_int
id|nblock
suffix:semicolon
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|num_retries
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering do_cdu31a_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;    * Make sure no one else is using the driver; wait for them&n;    * to finish if it is so.&n;    */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving do_cdu31a_request at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
multiline_comment|/* Get drive status before doing anything. */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we have a valid TOC. */
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* Make sure the timer is cancelled. */
id|del_timer
c_func
(paren
op_amp
id|cdu31a_abort_timer
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cdu31a_request_startover
suffix:colon
multiline_comment|/*&n;       * The beginning here is stolen from the hard disk driver.  I hope&n;       * it&squot;s right.&n;       */
r_if
c_cond
(paren
id|QUEUE_EMPTY
op_logical_or
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_goto
id|end_do_cdu31a_request
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
id|scd_spinup
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* I don&squot;t use INIT_REQUEST because it calls return, which would&n;         return without unlocking the device.  It shouldn&squot;t matter,&n;         but just to be safe... */
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
)brace
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nblock
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: TOC not read&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
multiline_comment|/*&n;          * If the block address is invalid or the request goes beyond the end of&n;          * the media, return an error.&n;          */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|block
op_div
l_int|4
)paren
OL
id|sony_toc.start_track_lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Request before beginning of media&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|block
op_div
l_int|4
)paren
op_ge
id|sony_toc.lead_out_start_lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Request past end of media&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|block
op_plus
id|nblock
)paren
op_div
l_int|4
)paren
op_ge
id|sony_toc.lead_out_start_lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Request past end of media&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
id|num_retries
op_assign
l_int|0
suffix:semicolon
id|try_read_again
suffix:colon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: TOC not read&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
multiline_comment|/* If no data is left to be read from the drive, start the&n;&t;    next request. */
r_if
c_cond
(paren
id|sony_blocks_left
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|block
op_div
l_int|4
comma
id|CDU31A_READAHEAD
op_div
l_int|4
comma
l_int|0
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
)brace
multiline_comment|/* If the requested block is not the next one waiting in&n;&t;    the driver, abort the current operation and start a&n;&t;    new one. */
r_else
r_if
c_cond
(paren
id|block
op_ne
id|sony_next_block
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A Warning: Read for block %d, expected %d&bslash;n&quot;
comma
id|block
comma
id|sony_next_block
)paren
suffix:semicolon
macro_line|#endif
id|abort_read
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: TOC not read&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|block
op_div
l_int|4
comma
id|CDU31A_READAHEAD
op_div
l_int|4
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31a: start request failed&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
)brace
id|read_data_block
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|block
comma
id|nblock
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|num_retries
OG
id|MAX_CDU31A_RETRIES
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
id|num_retries
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: %s error for block %d, nblock %d&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
comma
id|block
comma
id|nblock
)paren
suffix:semicolon
)brace
r_goto
id|try_read_again
suffix:semicolon
)brace
r_else
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;CDU31A: Unknown cmd&quot;
)paren
suffix:semicolon
)brace
)brace
id|end_do_cdu31a_request
suffix:colon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* After finished, cancel any pending operations. */
id|abort_read
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Start a timer to time out after a while to disable&n;      the read. */
id|cdu31a_abort_timer.expires
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Wait 2 seconds */
id|add_timer
c_func
(paren
op_amp
id|cdu31a_abort_timer
)paren
suffix:semicolon
macro_line|#endif
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving do_cdu31a_request at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Read the table of contents from the drive and set up TOC if&n; * successful.&n; */
r_static
r_void
DECL|function|sony_get_toc
id|sony_get_toc
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|parms
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|session
suffix:semicolon
r_int
id|num_spin_ups
suffix:semicolon
r_int
id|totaltracks
op_assign
l_int|0
suffix:semicolon
r_int
id|mint
op_assign
l_int|99
suffix:semicolon
r_int
id|maxt
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering sony_get_toc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|num_spin_ups
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|respinup_on_gettoc
suffix:colon
multiline_comment|/* Ignore the result, since it might error if spinning already. */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;         it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* If the drive is already playing, it&squot;s ok.  */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_AUDIO_PLAYING_ERR
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
)paren
(brace
r_goto
id|gettoc_drive_spinning
suffix:semicolon
)brace
multiline_comment|/* If the drive says it is not spun up (even though we just did it!)&n;            then retry the operation at least a few times. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
op_logical_and
(paren
id|num_spin_ups
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_spin_ups
op_increment
suffix:semicolon
r_goto
id|respinup_on_gettoc
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Error reading TOC: %x %s&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gettoc_drive_spinning
suffix:colon
multiline_comment|/* The idea here is we keep asking for sessions until the command&n;&t; fails.  Then we know what the last valid session on the disk is.&n;&t; No need to check session 0, since session 0 is the same as session&n;         1; the command returns different information if you give it 0. &n;        */
macro_line|#if DEBUG
id|memset
c_func
(paren
op_amp
id|sony_toc
comma
l_int|0x0e
comma
r_sizeof
(paren
id|sony_toc
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|single_toc
comma
l_int|0x0f
comma
r_sizeof
(paren
id|single_toc
)paren
)paren
suffix:semicolon
macro_line|#endif
id|session
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* This seems to slow things down enough to make it work.  This&n; * appears to be a problem in do_sony_cd_cmd.  This printk seems &n; * to address the symptoms...  -Erik */
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;cdu31a: Trying session %d&bslash;n&quot;
comma
id|session
)paren
suffix:semicolon
macro_line|#endif
id|parms
(braket
l_int|0
)braket
op_assign
id|session
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_SPEC_CMD
comma
id|parms
comma
l_int|1
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;%2.2x %2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
multiline_comment|/* An error reading the TOC, this must be past the last session. */
r_if
c_cond
(paren
id|session
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Yikes! Couldn&squot;t read any sessions!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Reading session %d&bslash;n&quot;
comma
id|session
)paren
suffix:semicolon
macro_line|#endif
id|parms
(braket
l_int|0
)braket
op_assign
id|session
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_TOC_DATA_SPEC_CMD
comma
id|parms
comma
l_int|1
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|single_toc
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|single_toc.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Error reading session %d: %x %s&bslash;n&quot;
comma
id|session
comma
id|single_toc.exec_status
(braket
l_int|0
)braket
comma
id|translate_error
c_func
(paren
id|single_toc.exec_status
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* An error reading the TOC.  Return without sony_toc_read&n;&t;       set. */
r_return
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;add0 %01x, con0 %01x, poi0 %02x, 1st trk %d, dsktyp %x, dum0 %x&bslash;n&quot;
comma
id|single_toc.address0
comma
id|single_toc.control0
comma
id|single_toc.point0
comma
id|bcd_to_int
c_func
(paren
id|single_toc.first_track_num
)paren
comma
id|single_toc.disk_type
comma
id|single_toc.dummy0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;add1 %01x, con1 %01x, poi1 %02x, lst trk %d, dummy1 %x, dum2 %x&bslash;n&quot;
comma
id|single_toc.address1
comma
id|single_toc.control1
comma
id|single_toc.point1
comma
id|bcd_to_int
c_func
(paren
id|single_toc.last_track_num
)paren
comma
id|single_toc.dummy1
comma
id|single_toc.dummy2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;add2 %01x, con2 %01x, poi2 %02x leadout start min %d, sec %d, frame %d&bslash;n&quot;
comma
id|single_toc.address2
comma
id|single_toc.control2
comma
id|single_toc.point2
comma
id|bcd_to_int
c_func
(paren
id|single_toc.lead_out_start_msf
(braket
l_int|0
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.lead_out_start_msf
(braket
l_int|1
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.lead_out_start_msf
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_size
OG
l_int|18
op_logical_and
id|single_toc.pointb0
OG
l_int|0xaf
)paren
id|printk
c_func
(paren
l_string|&quot;addb0 %01x, conb0 %01x, poib0 %02x, nextsession min %d, sec %d, frame %d&bslash;n&quot;
l_string|&quot;#mode5_ptrs %02d, max_start_outer_leadout_msf min %d, sec %d, frame %d&bslash;n&quot;
comma
id|single_toc.addressb0
comma
id|single_toc.controlb0
comma
id|single_toc.pointb0
comma
id|bcd_to_int
c_func
(paren
id|single_toc.next_poss_prog_area_msf
(braket
l_int|0
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.next_poss_prog_area_msf
(braket
l_int|1
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.next_poss_prog_area_msf
(braket
l_int|2
)braket
)paren
comma
id|single_toc.num_mode_5_pointers
comma
id|bcd_to_int
c_func
(paren
id|single_toc.max_start_outer_leadout_msf
(braket
l_int|0
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.max_start_outer_leadout_msf
(braket
l_int|1
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.max_start_outer_leadout_msf
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_size
OG
l_int|27
op_logical_and
id|single_toc.pointb1
OG
l_int|0xaf
)paren
id|printk
c_func
(paren
l_string|&quot;addb1 %01x, conb1 %01x, poib1 %02x, %x %x %x %x #skipint_ptrs %d, #skiptrkassign %d %x&bslash;n&quot;
comma
id|single_toc.addressb1
comma
id|single_toc.controlb1
comma
id|single_toc.pointb1
comma
id|single_toc.dummyb0_1
(braket
l_int|0
)braket
comma
id|single_toc.dummyb0_1
(braket
l_int|1
)braket
comma
id|single_toc.dummyb0_1
(braket
l_int|2
)braket
comma
id|single_toc.dummyb0_1
(braket
l_int|3
)braket
comma
id|single_toc.num_skip_interval_pointers
comma
id|single_toc.num_skip_track_assignments
comma
id|single_toc.dummyb0_2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_size
OG
l_int|36
op_logical_and
id|single_toc.pointb2
OG
l_int|0xaf
)paren
id|printk
c_func
(paren
l_string|&quot;addb2 %01x, conb2 %01x, poib2 %02x, %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|single_toc.addressb2
comma
id|single_toc.controlb2
comma
id|single_toc.pointb2
comma
id|single_toc.tracksb2
(braket
l_int|0
)braket
comma
id|single_toc.tracksb2
(braket
l_int|1
)braket
comma
id|single_toc.tracksb2
(braket
l_int|2
)braket
comma
id|single_toc.tracksb2
(braket
l_int|3
)braket
comma
id|single_toc.tracksb2
(braket
l_int|4
)braket
comma
id|single_toc.tracksb2
(braket
l_int|5
)braket
comma
id|single_toc.tracksb2
(braket
l_int|6
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_size
OG
l_int|45
op_logical_and
id|single_toc.pointb3
OG
l_int|0xaf
)paren
id|printk
c_func
(paren
l_string|&quot;addb3 %01x, conb3 %01x, poib3 %02x, %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|single_toc.addressb3
comma
id|single_toc.controlb3
comma
id|single_toc.pointb3
comma
id|single_toc.tracksb3
(braket
l_int|0
)braket
comma
id|single_toc.tracksb3
(braket
l_int|1
)braket
comma
id|single_toc.tracksb3
(braket
l_int|2
)braket
comma
id|single_toc.tracksb3
(braket
l_int|3
)braket
comma
id|single_toc.tracksb3
(braket
l_int|4
)braket
comma
id|single_toc.tracksb3
(braket
l_int|5
)braket
comma
id|single_toc.tracksb3
(braket
l_int|6
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_size
OG
l_int|54
op_logical_and
id|single_toc.pointb4
OG
l_int|0xaf
)paren
id|printk
c_func
(paren
l_string|&quot;addb4 %01x, conb4 %01x, poib4 %02x, %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|single_toc.addressb4
comma
id|single_toc.controlb4
comma
id|single_toc.pointb4
comma
id|single_toc.tracksb4
(braket
l_int|0
)braket
comma
id|single_toc.tracksb4
(braket
l_int|1
)braket
comma
id|single_toc.tracksb4
(braket
l_int|2
)braket
comma
id|single_toc.tracksb4
(braket
l_int|3
)braket
comma
id|single_toc.tracksb4
(braket
l_int|4
)braket
comma
id|single_toc.tracksb4
(braket
l_int|5
)braket
comma
id|single_toc.tracksb4
(braket
l_int|6
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_size
OG
l_int|63
op_logical_and
id|single_toc.pointc0
OG
l_int|0xaf
)paren
id|printk
c_func
(paren
l_string|&quot;addc0 %01x, conc0 %01x, poic0 %02x, %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|single_toc.addressc0
comma
id|single_toc.controlc0
comma
id|single_toc.pointc0
comma
id|single_toc.dummyc0
(braket
l_int|0
)braket
comma
id|single_toc.dummyc0
(braket
l_int|1
)braket
comma
id|single_toc.dummyc0
(braket
l_int|2
)braket
comma
id|single_toc.dummyc0
(braket
l_int|3
)braket
comma
id|single_toc.dummyc0
(braket
l_int|4
)braket
comma
id|single_toc.dummyc0
(braket
l_int|5
)braket
comma
id|single_toc.dummyc0
(braket
l_int|6
)braket
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
id|sony_toc.lead_out_start_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.lead_out_start_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sony_toc.lead_out_start_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.lead_out_start_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sony_toc.lead_out_start_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.lead_out_start_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|sony_toc.lead_out_start_lba
op_assign
id|single_toc.lead_out_start_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc.lead_out_start_msf
)paren
suffix:semicolon
multiline_comment|/* For points that do not exist, move the data over them&n;&t; to the right location. */
r_if
c_cond
(paren
id|single_toc.pointb0
op_ne
l_int|0xb0
)paren
(brace
id|memmove
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|27
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|18
comma
id|res_size
op_minus
l_int|18
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res_size
OG
l_int|18
)paren
(brace
id|sony_toc.lead_out_start_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.max_start_outer_leadout_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sony_toc.lead_out_start_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.max_start_outer_leadout_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sony_toc.lead_out_start_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.max_start_outer_leadout_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|sony_toc.lead_out_start_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc.lead_out_start_msf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|single_toc.pointb1
op_ne
l_int|0xb1
)paren
(brace
id|memmove
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|36
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|27
comma
id|res_size
op_minus
l_int|27
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|single_toc.pointb2
op_ne
l_int|0xb2
)paren
(brace
id|memmove
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|45
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|36
comma
id|res_size
op_minus
l_int|36
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|single_toc.pointb3
op_ne
l_int|0xb3
)paren
(brace
id|memmove
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|54
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|45
comma
id|res_size
op_minus
l_int|45
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|single_toc.pointb4
op_ne
l_int|0xb4
)paren
(brace
id|memmove
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|63
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|54
comma
id|res_size
op_minus
l_int|54
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|single_toc.pointc0
op_ne
l_int|0xc0
)paren
(brace
id|memmove
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|72
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|single_toc
)paren
op_plus
l_int|63
comma
id|res_size
op_minus
l_int|63
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;start track lba %u,  leadout start lba %u&bslash;n&quot;
comma
id|single_toc.start_track_lba
comma
id|single_toc.lead_out_start_lba
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_plus
id|bcd_to_int
c_func
(paren
id|single_toc.last_track_num
)paren
op_minus
id|bcd_to_int
c_func
(paren
id|single_toc.first_track_num
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;trk %02d: add 0x%01x, con 0x%01x,  track %02d, start min %02d, sec %02d, frame %02d&bslash;n&quot;
comma
id|i
comma
id|single_toc.tracks
(braket
id|i
)braket
dot
id|address
comma
id|single_toc.tracks
(braket
id|i
)braket
dot
id|control
comma
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
)paren
comma
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mint
OG
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track
)paren
)paren
id|mint
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxt
OL
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track
)paren
)paren
id|maxt
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;min track number %d,   max track number %d&bslash;n&quot;
comma
id|mint
comma
id|maxt
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* prepare a special table of contents for a CD-I disc. They don&squot;t have one. */
r_if
c_cond
(paren
id|single_toc.disk_type
op_eq
l_int|0x10
op_logical_and
id|single_toc.first_track_num
op_eq
l_int|2
op_logical_and
id|single_toc.last_track_num
op_eq
l_int|2
multiline_comment|/* CD-I */
)paren
(brace
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|address
op_assign
l_int|1
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|control
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* force data tracks */
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
op_assign
l_int|1
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|mint
op_assign
id|maxt
op_assign
l_int|1
suffix:semicolon
id|totaltracks
op_increment
suffix:semicolon
)brace
r_else
multiline_comment|/* gather track entries from this session */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_plus
id|bcd_to_int
c_func
(paren
id|single_toc.last_track_num
)paren
op_minus
id|bcd_to_int
c_func
(paren
id|single_toc.first_track_num
)paren
suffix:semicolon
id|i
op_increment
comma
id|totaltracks
op_increment
)paren
(brace
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|address
op_assign
id|single_toc.tracks
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|control
op_assign
id|single_toc.tracks
(braket
id|i
)braket
dot
id|control
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|single_toc.tracks
(braket
id|i
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|single_toc.start_track_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mint
OG
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
)paren
id|mint
op_assign
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
suffix:semicolon
r_if
c_cond
(paren
id|maxt
OL
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
)paren
id|maxt
op_assign
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
suffix:semicolon
)brace
)brace
id|sony_toc.first_track_num
op_assign
id|mint
suffix:semicolon
id|sony_toc.last_track_num
op_assign
id|maxt
suffix:semicolon
multiline_comment|/* Disk type of last session wins. For example:&n;            CD-Extra has disk type 0 for the first session, so&n;            a dumb HiFi CD player thinks it is a plain audio CD.&n;&t;    We are interested in the disk type of the last session,&n;            which is 0x20 (XA) for CD-Extra, so we can access the&n;            data track ... */
id|sony_toc.disk_type
op_assign
id|single_toc.disk_type
suffix:semicolon
id|sony_toc.sessions
op_assign
id|session
suffix:semicolon
multiline_comment|/* don&squot;t believe everything :-) */
r_if
c_cond
(paren
id|session
op_eq
l_int|1
)paren
id|single_toc.start_track_lba
op_assign
l_int|0
suffix:semicolon
id|sony_toc.start_track_lba
op_assign
id|single_toc.start_track_lba
suffix:semicolon
r_if
c_cond
(paren
id|session
OG
l_int|1
op_logical_and
id|single_toc.pointb0
op_eq
l_int|0xb0
op_logical_and
id|sony_toc.lead_out_start_lba
op_eq
id|single_toc.lead_out_start_lba
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Let&squot;s not get carried away... */
r_if
c_cond
(paren
id|session
OG
l_int|40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: too many sessions: %d&bslash;n&quot;
comma
id|session
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|session
op_increment
suffix:semicolon
)brace
id|sony_toc.track_entries
op_assign
id|totaltracks
suffix:semicolon
multiline_comment|/* add one entry for the LAST track with track number CDROM_LEADOUT */
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|address
op_assign
id|single_toc.address2
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|control
op_assign
id|single_toc.control2
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track
op_assign
id|CDROM_LEADOUT
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
op_assign
id|sony_toc.lead_out_start_msf
(braket
l_int|0
)braket
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
op_assign
id|sony_toc.lead_out_start_msf
(braket
l_int|1
)braket
suffix:semicolon
id|sony_toc.tracks
(braket
id|totaltracks
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
op_assign
id|sony_toc.lead_out_start_msf
(braket
l_int|2
)braket
suffix:semicolon
id|sony_toc_read
op_assign
l_int|1
suffix:semicolon
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Disk session %d, start track: %d, stop track: %d&bslash;n&quot;
comma
id|session
comma
id|single_toc.start_track_lba
comma
id|single_toc.lead_out_start_lba
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving sony_get_toc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * return multisession offset and sector information&n; */
DECL|function|scd_get_last_session
r_static
r_int
id|scd_get_last_session
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_multisession
op_star
id|ms_info
)paren
(brace
r_if
c_cond
(paren
id|ms_info
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
id|ms_info-&gt;addr_format
op_assign
id|CDROM_LBA
suffix:semicolon
id|ms_info-&gt;addr.lba
op_assign
id|sony_toc.start_track_lba
suffix:semicolon
id|ms_info-&gt;xa_flag
op_assign
id|sony_toc.disk_type
op_eq
id|SONY_XA_DISK_TYPE
op_logical_or
id|sony_toc.disk_type
op_eq
l_int|0x10
multiline_comment|/* CDI */
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for a specific track in the table of contents.&n; */
r_static
r_int
DECL|function|find_track
id|find_track
c_func
(paren
r_int
id|track
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|sony_toc.track_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sony_toc.tracks
(braket
id|i
)braket
dot
id|track
op_eq
id|track
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the subcode and put it in last_sony_subcode for future use.&n; */
r_static
r_int
DECL|function|read_subcode
id|read_subcode
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|res_size
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_SUBCODE_ADDRESS_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|last_sony_subcode
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|last_sony_subcode.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error %s (read_subcode)&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|last_sony_subcode.exec_status
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|last_sony_subcode.track_num
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.track_num
)paren
suffix:semicolon
id|last_sony_subcode.index_num
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.index_num
)paren
suffix:semicolon
id|last_sony_subcode.abs_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.abs_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|last_sony_subcode.abs_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.abs_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|last_sony_subcode.abs_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.abs_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|last_sony_subcode.rel_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.rel_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|last_sony_subcode.rel_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.rel_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|last_sony_subcode.rel_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.rel_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * return the media catalog number found on some older audio cds&n; */
r_static
r_int
DECL|function|scd_get_mcn
id|scd_get_mcn
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_mcn
op_star
id|mcn
)paren
(brace
r_int
r_char
id|resbuffer
(braket
l_int|2
op_plus
l_int|14
)braket
suffix:semicolon
r_int
r_char
op_star
id|mcnp
op_assign
id|mcn-&gt;medium_catalog_number
suffix:semicolon
r_int
r_char
op_star
id|resp
op_assign
id|resbuffer
op_plus
l_int|3
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
id|memset
c_func
(paren
id|mcn-&gt;medium_catalog_number
comma
l_int|0
comma
l_int|14
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_UPC_EAN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|resbuffer
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|resbuffer
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* packed bcd to single ASCII digits */
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_increment
op_amp
l_int|0x0f
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_increment
op_amp
l_int|0x0f
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_increment
op_amp
l_int|0x0f
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_increment
op_amp
l_int|0x0f
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_increment
op_amp
l_int|0x0f
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_increment
op_amp
l_int|0x0f
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|mcnp
op_increment
op_assign
(paren
op_star
id|resp
op_rshift
l_int|4
)paren
op_plus
l_char|&squot;0&squot;
suffix:semicolon
)brace
op_star
id|mcnp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the subchannel info like the CDROMSUBCHNL command wants to see it.  If&n; * the drive is playing, the subchannel needs to be read (since it would be&n; * changing).  If the drive is paused or completed, the subcode information has&n; * already been stored, just use that.  The ioctl call wants things in decimal&n; * (not BCD), so all the conversions are done.&n; */
r_static
r_int
DECL|function|sony_get_subchnl_info
id|sony_get_subchnl_info
c_func
(paren
r_struct
id|cdrom_subchnl
op_star
id|schi
)paren
(brace
multiline_comment|/* Get attention stuff */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sony_audio_status
)paren
(brace
r_case
id|CDROM_AUDIO_NO_STATUS
suffix:colon
r_case
id|CDROM_AUDIO_PLAY
suffix:colon
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_PAUSED
suffix:colon
r_case
id|CDROM_AUDIO_COMPLETED
suffix:colon
r_break
suffix:semicolon
macro_line|#if 0
r_case
id|CDROM_AUDIO_NO_STATUS
suffix:colon
id|schi-&gt;cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|CDROM_AUDIO_INVALID
suffix:colon
r_case
id|CDROM_AUDIO_ERROR
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|schi-&gt;cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|schi-&gt;cdsc_adr
op_assign
id|last_sony_subcode.address
suffix:semicolon
id|schi-&gt;cdsc_ctrl
op_assign
id|last_sony_subcode.control
suffix:semicolon
id|schi-&gt;cdsc_trk
op_assign
id|last_sony_subcode.track_num
suffix:semicolon
id|schi-&gt;cdsc_ind
op_assign
id|last_sony_subcode.index_num
suffix:semicolon
r_if
c_cond
(paren
id|schi-&gt;cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|schi-&gt;cdsc_absaddr.msf.minute
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|0
)braket
suffix:semicolon
id|schi-&gt;cdsc_absaddr.msf.second
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|1
)braket
suffix:semicolon
id|schi-&gt;cdsc_absaddr.msf.frame
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|2
)braket
suffix:semicolon
id|schi-&gt;cdsc_reladdr.msf.minute
op_assign
id|last_sony_subcode.rel_msf
(braket
l_int|0
)braket
suffix:semicolon
id|schi-&gt;cdsc_reladdr.msf.second
op_assign
id|last_sony_subcode.rel_msf
(braket
l_int|1
)braket
suffix:semicolon
id|schi-&gt;cdsc_reladdr.msf.frame
op_assign
id|last_sony_subcode.rel_msf
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|schi-&gt;cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|schi-&gt;cdsc_absaddr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode.abs_msf
)paren
suffix:semicolon
id|schi-&gt;cdsc_reladdr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode.rel_msf
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get audio data from the drive.  This is fairly complex because I&n;   am looking for status and data at the same time, but if I get status&n;   then I just look for data.  I need to get the status immediately so&n;   the switch from audio to data tracks will happen quickly. */
r_static
r_void
DECL|function|read_audio_data
id|read_audio_data
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
op_star
id|res_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
id|result_read
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|res_size
op_assign
l_int|0
suffix:semicolon
id|result_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
id|continue_read_audio_wait
suffix:colon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
op_logical_or
id|result_read
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_result_ready
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|result_read
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
multiline_comment|/* Read block status and continue waiting for data. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
id|result_read
op_assign
l_int|1
suffix:semicolon
r_goto
id|continue_read_audio_wait
suffix:semicolon
)brace
multiline_comment|/* Invalid data from the drive.  Shut down the operation. */
r_else
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Got result that should have been error: %d&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If data block, then get 2340 bytes offset by 12. */
r_if
c_cond
(paren
id|sony_raw_data_mode
)paren
(brace
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|buffer
op_plus
id|CD_XA_HEAD
comma
id|CD_FRAMESIZE_RAW1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Audio gets the whole 2352 bytes. */
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
multiline_comment|/* If I haven&squot;t already gotten the result, get it now. */
r_if
c_cond
(paren
op_logical_neg
id|result_read
)paren
(brace
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_CIRC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_LECC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_RECOV_LECC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_ERR_DETECTION_STAT
)paren
)paren
(brace
multiline_comment|/* Ok, nothing to do. */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data block error: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
multiline_comment|/* The drive gave me bad status, I don&squot;t know what to do.&n;            Reset the driver and return an error. */
id|printk
c_func
(paren
l_string|&quot;CDU31A: Invalid block status: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|restart_on_error
c_func
(paren
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Perform a raw data read.  This will automatically detect the&n;   track type and read the proper data (audio or data). */
r_static
r_int
DECL|function|read_audio
id|read_audio
c_func
(paren
r_struct
id|cdrom_read_audio
op_star
id|ra
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_int
id|cframe
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;    * Make sure no one else is using the driver; wait for them&n;    * to finish if it is so.&n;    */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
id|scd_spinup
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the drive to do raw operations. */
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x06
op_or
id|sony_raw_data_mode
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to set decode params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* From here down, we have to goto exit_read_audio instead of returning&n;      because the drive parameters have to be set back to data before&n;      return. */
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start_request clears out any readahead data, so it should be safe. */
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|ra-&gt;addr.lba
comma
id|ra-&gt;nframes
comma
l_int|1
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
multiline_comment|/* For every requested frame. */
id|cframe
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cframe
OL
id|ra-&gt;nframes
)paren
(brace
id|read_audio_data
c_func
(paren
id|readahead_buffer
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_BAD_DATA_ERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data error on audio sector %d&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_ILL_TRACK_R_ERR
)paren
(brace
multiline_comment|/* Illegal track type, change track types and start over. */
id|sony_raw_data_mode
op_assign
(paren
id|sony_raw_data_mode
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Set the drive mode. */
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x06
op_or
id|sony_raw_data_mode
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to set decode params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
multiline_comment|/* Restart the request on the current frame. */
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|ra-&gt;addr.lba
op_plus
id|cframe
comma
id|ra-&gt;nframes
op_minus
id|cframe
comma
l_int|1
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t go back to the top because don&squot;t want to get into&n;               and infinite loop.  A lot of code gets duplicated, but&n;               that&squot;s no big deal, I don&squot;t guess. */
id|read_audio_data
c_func
(paren
id|readahead_buffer
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_BAD_DATA_ERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data error on audio sector %d&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error reading audio data on sector %d: %s&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
)brace
r_else
(brace
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|ra-&gt;buf
op_plus
(paren
id|CD_FRAMESIZE_RAW
op_star
id|cframe
)paren
)paren
comma
(paren
r_char
op_star
)paren
id|readahead_buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error reading audio data on sector %d: %s&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
)brace
r_else
(brace
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|ra-&gt;buf
op_plus
(paren
id|CD_FRAMESIZE_RAW
op_star
id|cframe
)paren
)paren
comma
(paren
r_char
op_star
)paren
id|readahead_buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
id|cframe
op_increment
suffix:semicolon
)brace
id|get_result
c_func
(paren
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error return from audio read: %s&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
id|exit_read_audio
suffix:colon
multiline_comment|/* Set the drive mode back to the proper one for the disk. */
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_xa_mode
)paren
(brace
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x0f
suffix:semicolon
)brace
r_else
(brace
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x07
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to reset decode params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_sony_cd_cmd_chk
id|do_sony_cd_cmd_chk
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|cmd
comma
id|params
comma
id|num_params
comma
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|result_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|result_buffer
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error %s (CDROM%s)&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|result_buffer
(braket
l_int|1
)braket
)paren
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Uniform cdrom interface function&n; * open the tray&n; */
DECL|function|scd_tray_move
r_static
r_int
id|scd_tray_move
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
(brace
r_if
c_cond
(paren
id|position
op_eq
l_int|1
multiline_comment|/* open tray */
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;EJECT&quot;
comma
id|SONY_EJECT_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
l_int|0
op_eq
id|scd_spinup
c_func
(paren
)paren
)paren
id|sony_spun_up
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The big ugly ioctl handler.&n; */
DECL|function|scd_audio_ioctl
r_static
r_int
id|scd_audio_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|7
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive */
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;START&quot;
comma
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/*&n;       * Spin the drive down, ignoring the error if the disk was&n;       * already not spinning.&n;       */
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;STOP&quot;
comma
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
r_if
c_cond
(paren
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;PAUSE&quot;
comma
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Get the current position and save it for resuming */
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cur_pos_msf
(braket
l_int|0
)braket
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|0
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|1
)braket
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|1
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|2
)braket
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|2
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Start the drive after being paused */
r_if
c_cond
(paren
id|sony_audio_status
op_ne
id|CDROM_AUDIO_PAUSED
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* Start the drive at the saved position. */
id|params
(braket
l_int|1
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|cur_pos_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|cur_pos_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|cur_pos_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|4
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|final_pos_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|5
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|final_pos_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|6
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|final_pos_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;RESUME&quot;
comma
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The parameters are given in int, must be converted */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|params
(braket
id|i
)braket
op_assign
id|int_to_bcd
c_func
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
(braket
id|i
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;PLAYMSF&quot;
comma
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|params
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|params
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|params
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
(brace
r_struct
id|cdrom_tochdr
op_star
id|hdr
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
id|hdr-&gt;cdth_trk0
op_assign
id|sony_toc.first_track_num
suffix:semicolon
id|hdr-&gt;cdth_trk1
op_assign
id|sony_toc.last_track_num
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read a given table of contents entry */
(brace
r_struct
id|cdrom_tocentry
op_star
id|entry
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
r_int
r_char
op_star
id|msf_val
op_assign
l_int|NULL
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|entry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
id|track_idx
op_assign
id|find_track
c_func
(paren
id|entry-&gt;cdte_track
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|entry-&gt;cdte_adr
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|address
suffix:semicolon
id|entry-&gt;cdte_ctrl
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|control
suffix:semicolon
id|msf_val
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
suffix:semicolon
multiline_comment|/* Logical buffer address or MSF format requested? */
r_if
c_cond
(paren
id|entry-&gt;cdte_format
op_eq
id|CDROM_LBA
)paren
(brace
id|entry-&gt;cdte_addr.lba
op_assign
id|msf_to_log
c_func
(paren
id|msf_val
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry-&gt;cdte_addr.msf.minute
op_assign
op_star
id|msf_val
suffix:semicolon
id|entry-&gt;cdte_addr.msf.second
op_assign
op_star
(paren
id|msf_val
op_plus
l_int|1
)paren
suffix:semicolon
id|entry-&gt;cdte_addr.msf.frame
op_assign
op_star
(paren
id|msf_val
op_plus
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
(brace
r_struct
id|cdrom_ti
op_star
id|ti
op_assign
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ti-&gt;cdti_trk0
OL
id|sony_toc.first_track_num
)paren
op_logical_or
(paren
id|ti-&gt;cdti_trk0
OG
id|sony_toc.last_track_num
)paren
op_logical_or
(paren
id|ti-&gt;cdti_trk1
OL
id|ti-&gt;cdti_trk0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|ti-&gt;cdti_trk0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|params
(braket
l_int|1
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;          * If we want to stop after the last track, use the lead-out&n;          * MSF to do that.&n;          */
r_if
c_cond
(paren
id|ti-&gt;cdti_trk1
op_ge
id|sony_toc.last_track_num
)paren
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|CDROM_LEADOUT
)paren
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|ti-&gt;cdti_trk1
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|params
(braket
l_int|4
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|5
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|6
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Params: %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|params
(braket
l_int|0
)braket
comma
id|params
(braket
l_int|1
)braket
comma
id|params
(braket
l_int|2
)braket
comma
id|params
(braket
l_int|3
)braket
comma
id|params
(braket
l_int|4
)braket
comma
id|params
(braket
l_int|5
)braket
comma
id|params
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error %s (CDROMPLAYTRKIND)&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|params
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|params
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|bcd_to_int
c_func
(paren
id|params
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control.  What volume does this change, anyway? */
(brace
r_struct
id|cdrom_volctrl
op_star
id|volctrl
op_assign
(paren
r_struct
id|cdrom_volctrl
op_star
)paren
id|arg
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_AUDIO_VOLUME
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
id|volctrl-&gt;channel0
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|volctrl-&gt;channel1
suffix:semicolon
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;VOLCTRL&quot;
comma
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|3
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
r_return
id|sony_get_subchnl_info
c_func
(paren
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|scd_dev_ioctl
r_static
r_int
id|scd_dev_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMREADAUDIO
suffix:colon
multiline_comment|/* Read 2352 byte audio tracks and 2340 byte&n;&t;&t;&t;&t; raw data tracks. */
(brace
r_struct
id|cdrom_read_audio
id|ra
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ra
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ra.nframes
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ra.buf
comma
id|CD_FRAMESIZE_RAW
op_star
id|ra.nframes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_LBA
)paren
(brace
r_if
c_cond
(paren
(paren
id|ra.addr.lba
op_ge
id|sony_toc.lead_out_start_lba
)paren
op_logical_or
(paren
id|ra.addr.lba
op_plus
id|ra.nframes
op_ge
id|sony_toc.lead_out_start_lba
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_MSF
)paren
(brace
r_if
c_cond
(paren
(paren
id|ra.addr.msf.minute
op_ge
l_int|75
)paren
op_logical_or
(paren
id|ra.addr.msf.second
op_ge
l_int|60
)paren
op_logical_or
(paren
id|ra.addr.msf.frame
op_ge
l_int|75
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ra.addr.lba
op_assign
(paren
(paren
id|ra.addr.msf.minute
op_star
l_int|4500
)paren
op_plus
(paren
id|ra.addr.msf.second
op_star
l_int|75
)paren
op_plus
id|ra.addr.msf.frame
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ra.addr.lba
op_ge
id|sony_toc.lead_out_start_lba
)paren
op_logical_or
(paren
id|ra.addr.lba
op_plus
id|ra.nframes
op_ge
id|sony_toc.lead_out_start_lba
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* I know, this can go negative on an unsigned.  However,&n;               the first thing done to the data is to add this value,&n;               so this should compensate and allow direct msf access. */
id|ra.addr.lba
op_sub_assign
id|LOG_START_OFFSET
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|read_audio
c_func
(paren
op_amp
id|ra
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|scd_spinup
r_static
r_int
id|scd_spinup
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|num_spin_ups
suffix:semicolon
id|num_spin_ups
op_assign
l_int|0
suffix:semicolon
id|respinup_on_open
suffix:colon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;      it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM %s error (scd_open, spin up)&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;      it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* If the drive is already playing, it&squot;s ok.  */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_AUDIO_PLAYING_ERR
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the drive says it is not spun up (even though we just did it!)&n;         then retry the operation at least a few times. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
op_logical_and
(paren
id|num_spin_ups
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_spin_ups
op_increment
suffix:semicolon
r_goto
id|respinup_on_open
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error %s (scd_open, read toc)&bslash;n&quot;
comma
id|translate_error
c_func
(paren
id|res_reg
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the drive for operations.  Spin the drive up and read the table of&n; * contents if these have not already been done.&n; */
r_static
r_int
DECL|function|scd_open
id|scd_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|openmode
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|2
)braket
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sony_usage
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|scd_spinup
c_func
(paren
)paren
op_ne
l_int|0
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* For XA on the CDU31A only, we have to do special reads.&n;         The CDU33A handles XA automagically. */
multiline_comment|/* if (   (sony_toc.disk_type == SONY_XA_DISK_TYPE) */
r_if
c_cond
(paren
(paren
id|sony_toc.disk_type
op_ne
l_int|0x00
)paren
op_logical_and
(paren
op_logical_neg
id|is_double_speed
)paren
)paren
(brace
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x07
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to set XA params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|sony_xa_mode
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* A non-XA disk.  Set the parms back if necessary. */
r_else
r_if
c_cond
(paren
id|sony_xa_mode
)paren
(brace
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x0f
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to reset XA params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|sony_xa_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|sony_spun_up
op_assign
l_int|1
suffix:semicolon
)brace
id|sony_usage
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the drive.  Spin it down if no task is using it.  The spin&n; * down will fail if playing audio, so audio play is OK.&n; */
r_static
r_void
DECL|function|scd_release
id|scd_release
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_if
c_cond
(paren
id|sony_usage
op_eq
l_int|1
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
)brace
id|sony_usage
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|variable|scd_dops
r_static
r_struct
id|cdrom_device_ops
id|scd_dops
op_assign
(brace
id|open
suffix:colon
id|scd_open
comma
id|release
suffix:colon
id|scd_release
comma
id|drive_status
suffix:colon
id|scd_drive_status
comma
id|media_changed
suffix:colon
id|scd_media_changed
comma
id|tray_move
suffix:colon
id|scd_tray_move
comma
id|lock_door
suffix:colon
id|scd_lock_door
comma
id|select_speed
suffix:colon
id|scd_select_speed
comma
id|get_last_session
suffix:colon
id|scd_get_last_session
comma
id|get_mcn
suffix:colon
id|scd_get_mcn
comma
id|reset
suffix:colon
id|scd_reset
comma
id|audio_ioctl
suffix:colon
id|scd_audio_ioctl
comma
id|dev_ioctl
suffix:colon
id|scd_dev_ioctl
comma
id|capability
suffix:colon
id|CDC_OPEN_TRAY
op_or
id|CDC_CLOSE_TRAY
op_or
id|CDC_LOCK
op_or
id|CDC_SELECT_SPEED
op_or
id|CDC_MULTI_SESSION
op_or
id|CDC_MULTI_SESSION
op_or
id|CDC_MCN
op_or
id|CDC_MEDIA_CHANGED
op_or
id|CDC_PLAY_AUDIO
op_or
id|CDC_RESET
op_or
id|CDC_IOCTLS
op_or
id|CDC_DRIVE_STATUS
comma
id|n_minors
suffix:colon
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|scd_info
r_static
r_struct
id|cdrom_device_info
id|scd_info
op_assign
(brace
id|ops
suffix:colon
op_amp
id|scd_dops
comma
id|speed
suffix:colon
l_int|2
comma
id|capacity
suffix:colon
l_int|1
comma
id|name
suffix:colon
l_string|&quot;cdu31a&quot;
)brace
suffix:semicolon
multiline_comment|/* The different types of disc loading mechanisms supported */
DECL|variable|__initdata
r_static
r_const
r_char
op_star
id|load_mech
(braket
)braket
id|__initdata
op_assign
(brace
l_string|&quot;caddy&quot;
comma
l_string|&quot;tray&quot;
comma
l_string|&quot;pop-up&quot;
comma
l_string|&quot;unknown&quot;
)brace
suffix:semicolon
r_static
r_void
id|__init
DECL|function|get_drive_configuration
id|get_drive_configuration
c_func
(paren
r_int
r_int
id|base_io
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
r_int
op_star
id|res_size
)paren
(brace
r_int
id|retry_count
suffix:semicolon
multiline_comment|/* Set the base address */
id|cdu31a_port
op_assign
id|base_io
suffix:semicolon
multiline_comment|/* Set up all the register locations */
id|sony_cd_cmd_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_CMD_REG_OFFSET
suffix:semicolon
id|sony_cd_param_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_PARAM_REG_OFFSET
suffix:semicolon
id|sony_cd_write_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_WRITE_REG_OFFSET
suffix:semicolon
id|sony_cd_control_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_CONTROL_REG_OFFSET
suffix:semicolon
id|sony_cd_status_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_STATUS_REG_OFFSET
suffix:semicolon
id|sony_cd_result_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_RESULT_REG_OFFSET
suffix:semicolon
id|sony_cd_read_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_READ_REG_OFFSET
suffix:semicolon
id|sony_cd_fifost_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_FIFOST_REG_OFFSET
suffix:semicolon
multiline_comment|/*&n;    * Check to see if anything exists at the status register location.&n;    * I don&squot;t know if this is a good way to check, but it seems to work&n;    * ok for me.&n;    */
r_if
c_cond
(paren
id|read_status_register
c_func
(paren
)paren
op_ne
l_int|0xff
)paren
(brace
multiline_comment|/*&n;       * Reset the drive and wait for attention from it (to say it&squot;s reset).&n;       * If you don&squot;t wait, the next operation will probably fail.&n;       */
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|retry_count
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* If attention is never seen probably not a CDU31a present */
r_if
c_cond
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
(brace
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;       * Get the drive configuration.&n;       */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_DRIVE_CONFIG_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Return an error */
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * Set up base I/O and interrupts, called from main.c.&n; &n; */
DECL|function|cdu31a_setup
r_static
r_int
id|__init
id|cdu31a_setup
c_func
(paren
r_char
op_star
id|strings
)paren
(brace
r_int
id|ints
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|strings
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
(brace
id|cdu31a_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
(brace
id|cdu31a_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|strings
op_ne
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|strings
op_ne
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|strings
comma
l_string|&quot;PAS&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|sony_pas_init
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unknown interface type: %s&bslash;n&quot;
comma
id|strings
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;cdu31a=&quot;
comma
id|cdu31a_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|cdu31a_block_size
r_static
r_int
id|cdu31a_block_size
suffix:semicolon
multiline_comment|/*&n; * Initialize the driver.&n; */
r_int
id|__init
DECL|function|cdu31a_init
id|cdu31a_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|s_sony_drive_config
id|drive_config
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_char
id|msg
(braket
l_int|255
)braket
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|drive_found
suffix:semicolon
r_int
id|tmp_irq
suffix:semicolon
multiline_comment|/*&n;    * According to Alex Freed (freed@europa.orion.adobe.com), this is&n;    * required for the Fusion CD-16 package.  If the sound driver is&n;    * loaded, it should work fine, but just in case...&n;    *&n;    * The following turn on the CD-ROM interface for a Fusion CD-16.&n;    */
r_if
c_cond
(paren
id|sony_pas_init
)paren
(brace
id|outb
c_func
(paren
l_int|0xbc
comma
l_int|0x9a01
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe2
comma
l_int|0x9a01
)paren
suffix:semicolon
)brace
id|drive_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Setting the base I/O address to 0xffff will disable it. */
r_if
c_cond
(paren
id|cdu31a_port
op_eq
l_int|0xffff
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
id|cdu31a_port
op_ne
l_int|0
)paren
(brace
id|tmp_irq
op_assign
id|cdu31a_irq
suffix:semicolon
multiline_comment|/* Need IRQ 0 because we can&squot;t sleep here. */
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|get_drive_configuration
c_func
(paren
id|cdu31a_port
comma
id|drive_config.exec_status
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OG
l_int|2
)paren
op_logical_and
(paren
(paren
id|drive_config.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x00
)paren
)paren
(brace
id|drive_found
op_assign
l_int|1
suffix:semicolon
)brace
id|cdu31a_irq
op_assign
id|tmp_irq
suffix:semicolon
)brace
r_else
(brace
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
op_ne
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|drive_found
)paren
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
l_int|4
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|get_drive_configuration
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
id|drive_config.exec_status
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OG
l_int|2
)paren
op_logical_and
(paren
(paren
id|drive_config.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x00
)paren
)paren
(brace
id|drive_found
op_assign
l_int|1
suffix:semicolon
id|cdu31a_irq
op_assign
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|int_num
suffix:semicolon
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|drive_found
)paren
(brace
r_int
id|deficiency
op_assign
l_int|0
suffix:semicolon
id|request_region
c_func
(paren
id|cdu31a_port
comma
l_int|4
comma
l_string|&quot;cdu31a&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cdu31a&quot;
comma
op_amp
id|cdrom_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for CDU-31a&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_goto
id|errout2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_DOUBLE_SPEED
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|is_double_speed
op_assign
l_int|1
suffix:semicolon
)brace
id|tmp_irq
op_assign
id|cdu31a_irq
suffix:semicolon
multiline_comment|/* Need IRQ 0 because we can&squot;t sleep here. */
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|set_drive_params
c_func
(paren
id|sony_speed
)paren
suffix:semicolon
id|cdu31a_irq
op_assign
id|tmp_irq
suffix:semicolon
r_if
c_cond
(paren
id|cdu31a_irq
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cdu31a_irq
comma
id|cdu31a_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;cdu31a&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the CDU31A driver&bslash;n&quot;
comma
id|cdu31a_irq
)paren
suffix:semicolon
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|sprintf
c_func
(paren
id|msg
comma
l_string|&quot;Sony I/F CDROM : %8.8s %16.16s %8.8s&bslash;n&quot;
comma
id|drive_config.vendor_id
comma
id|drive_config.product_id
comma
id|drive_config.product_rev_level
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;  Capabilities: %s&quot;
comma
id|load_mech
(braket
id|SONY_HWC_GET_LOAD_MECH
c_func
(paren
id|drive_config
)paren
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|msg
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SONY_HWC_AUDIO_PLAYBACK
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;, audio&quot;
)paren
suffix:semicolon
)brace
r_else
id|deficiency
op_or_assign
id|CDC_PLAY_AUDIO
suffix:semicolon
r_if
c_cond
(paren
id|SONY_HWC_EJECT
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;, eject&quot;
)paren
suffix:semicolon
)brace
r_else
id|deficiency
op_or_assign
id|CDC_OPEN_TRAY
suffix:semicolon
r_if
c_cond
(paren
id|SONY_HWC_LED_SUPPORT
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;, LED&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_ELECTRIC_VOLUME
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;, elec. Vol&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_ELECTRIC_VOLUME_CTL
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;, sep. Vol&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_double_speed
)paren
(brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;, double speed&quot;
)paren
suffix:semicolon
)brace
r_else
id|deficiency
op_or_assign
id|CDC_SELECT_SPEED
suffix:semicolon
r_if
c_cond
(paren
id|cdu31a_irq
OG
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;, irq %d&quot;
comma
id|cdu31a_irq
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|msg
comma
id|buf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|msg
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|is_a_cdu31a
op_assign
id|strcmp
c_func
(paren
l_string|&quot;CD-ROM CDU31A&quot;
comma
id|drive_config.product_id
)paren
op_eq
l_int|0
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
id|CDU31A_READAHEAD
suffix:semicolon
id|cdu31a_block_size
op_assign
l_int|1024
suffix:semicolon
multiline_comment|/* 1kB default block size */
multiline_comment|/* use &squot;mount -o block=2048&squot; */
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|cdu31a_block_size
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|cdu31a_abort_timer
)paren
suffix:semicolon
id|cdu31a_abort_timer.function
op_assign
id|handle_abort_timeout
suffix:semicolon
id|scd_info.dev
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
suffix:semicolon
id|scd_info.mask
op_assign
id|deficiency
suffix:semicolon
id|strncpy
c_func
(paren
id|scd_info.name
comma
l_string|&quot;cdu31a&quot;
comma
r_sizeof
(paren
id|scd_info.name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_cdrom
c_func
(paren
op_amp
id|scd_info
)paren
)paren
(brace
r_goto
id|errout0
suffix:semicolon
)brace
)brace
id|disk_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive_found
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_goto
id|errout3
suffix:semicolon
)brace
id|errout0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unable to register CDU-31a with Uniform cdrom driver&bslash;n&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cdu31a&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister block device for cdu31a&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|errout2
suffix:colon
id|release_region
c_func
(paren
id|cdu31a_port
comma
l_int|4
)paren
suffix:semicolon
id|errout3
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_void
id|__exit
DECL|function|cdu31a_exit
id|cdu31a_exit
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|unregister_cdrom
c_func
(paren
op_amp
id|scd_info
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister cdu31a from Uniform cdrom driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cdu31a&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister cdu31a&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdu31a_irq
OG
l_int|0
)paren
id|free_irq
c_func
(paren
id|cdu31a_irq
comma
l_int|NULL
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|cdu31a_port
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cdu31a module released.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|cdu31a_init
id|module_init
c_func
(paren
id|cdu31a_init
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|cdu31a_exit
id|module_exit
c_func
(paren
id|cdu31a_exit
)paren
suffix:semicolon
eof
