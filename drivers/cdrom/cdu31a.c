multiline_comment|/*&n;* Sony CDU-31A CDROM interface device driver.&n;*&n;* Corey Minyard (minyard@wf-rch.cirr.com)&n;*&n;* Colossians 3:17&n;*&n;* The Sony interface device driver handles Sony interface CDROM&n;* drives and provides a complete block-level interface as well as an&n;* ioctl() interface compatible with the Sun (as specified in&n;* include/linux/cdrom.h).  With this interface, CDROMs can be&n;* accessed and standard audio CDs can be played back normally.&n;*&n;* WARNING - &t;All autoprobes have been removed from the driver.&n;*&t;&t;You MUST configure the CDU31A via a LILO config&n;*&t;&t;at boot time or in lilo.conf.  I have the&n;*&t;&t;following in my lilo.conf:&n;*&n;*                append=&quot;cdu31a=0x1f88,0,PAS&quot;&n;*&n;*&t;&t;The first number is the I/O base address of the&n;*&t;&t;card.  The second is the interrupt (0 means none).&n; *&t;&t;The third should be &quot;PAS&quot; if on a Pro-Audio&n; *&t;&t;spectrum, or nothing if on something else.&n; *&n; * This interface is (unfortunately) a polled interface.  This is&n; * because most Sony interfaces are set up with DMA and interrupts&n; * disables.  Some (like mine) do not even have the capability to&n; * handle interrupts or DMA.  For this reason you will see a lot of&n; * the following:&n; *&n; *   retry_count = jiffies+ SONY_JIFFIES_TIMEOUT;&n; *   while ((retry_count &gt; jiffies) &amp;&amp; (! &lt;some condition to wait for))&n; *   {&n; *      while (handle_sony_cd_attention())&n; *         ;&n; *&n; *      sony_sleep();&n; *   }&n; *   if (the condition not met)&n; *   {&n; *      return an error;&n; *   }&n; *&n; * This ugly hack waits for something to happen, sleeping a little&n; * between every try.  it also handles attentions, which are&n; * asynchronous events from the drive informing the driver that a disk&n; * has been inserted, removed, etc.&n; *&n; * NEWS FLASH - The driver now supports interrupts but they are&n; * turned off by default.  Use of interrupts is highly encouraged, it&n; * cuts CPU usage down to a reasonable level.  I had DMA in for a while&n; * but PC DMA is just too slow.  Better to just insb() it.&n; *&n; * One thing about these drives: They talk in MSF (Minute Second Frame) format.&n; * There are 75 frames a second, 60 seconds a minute, and up to 75 minutes on a&n; * disk.  The funny thing is that these are sent to the drive in BCD, but the&n; * interface wants to see them in decimal.  A lot of conversion goes on.&n; *&n; * DRIVER SPECIAL FEATURES&n; * -----------------------&n; *&n; * This section describes features beyond the normal audio and CD-ROM&n; * functions of the drive.&n; *&n; * 2048 byte buffer mode&n; *&n; * If a disk is mounted with -o block=2048, data is copied straight&n; * from the drive data port to the buffer.  Otherwise, the readahead&n; * buffer must be involved to hold the other 1K of data when a 1K&n; * block operation is done.  Note that with 2048 byte blocks you&n; * cannot execute files from the CD.&n; *&n; * XA compatibility&n; *&n; * The driver should support XA disks for both the CDU31A and CDU33A.&n; * It does this transparently, the using program doesn&squot;t need to set it.&n; *&n; * Multi-Session&n; *&n; * A multi-session disk looks just like a normal disk to the user.&n; * Just mount one normally, and all the data should be there.&n; * A special thanks to Koen for help with this!&n; * &n; * Raw sector I/O&n; *&n; * Using the CDROMREADAUDIO it is possible to read raw audio and data&n; * tracks.  Both operations return 2352 bytes per sector.  On the data&n; * tracks, the first 12 bytes is not returned by the drive and the value&n; * of that data is indeterminate.&n; *&n; *&n; *  Copyright (C) 1993  Corey Minyard&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
multiline_comment|/*&n; *&n; * Setting up the Sony CDU31A/CDU33A drive interface card.  If&n; * You have another card, you are on your own.&n; * &n; *      +----------+-----------------+----------------------+&n; *      |  JP1     |  34 Pin Conn    |                      |&n; *      |  JP2     +-----------------+                      |&n; *      |  JP3                                              |&n; *      |  JP4                                              |&n; *      |                                                   +--+&n; *      |                                                   |  +-+&n; *      |                                                   |  | |  External&n; *      |                                                   |  | |  Connector&n; *      |                                                   |  | |&n; *      |                                                   |  +-+&n; *      |                                                   +--+&n; *      |                                                   |&n; *      |                                          +--------+&n; *      |                                          |&n; *      +------------------------------------------+&n; * &n; *    JP1 sets the Base Address, using the following settings:&n; * &n; *      Address         Pin 1           Pin 2&n; *      -------         -----           -----&n; *      0x320           Short           Short&n; *      0x330           Short           Open&n; *      0x340           Open            Short&n; *      0x360           Open            Open&n; * &n; *    JP2 and JP3 configure the DMA channel; they must be set the same.&n; * &n; *      DMA             Pin 1           Pin 2           Pin 3&n; *      ---             -----           -----           -----&n; *      1               On              Off             On&n; *      2               Off             On              Off&n; *      3               Off             Off             On&n; * &n; *    JP4 Configures the IRQ:&n; * &n; *      IRQ     Pin 1           Pin 2           Pin 3           Pin 4&n; *      ---     -----           -----           -----           -----&n; *      3       Off             Off             On              Off&n; *      4       Off             Off*            Off             On&n; *      5       On              Off             Off             Off&n; *      6       Off             On              Off             Off&n; * &n; *              * The documentation states to set this for interrupt&n; *                4, but I think that is a mistake.&n; *&n; *  It probably a little late to be adding a history, but I guess I&n; *  will start.&n; *&n; *  10/24/95 - Added support for disabling the eject button when the&n; *             drive is open.  Note that there is a small problem&n; *             still here, if the eject button is pushed while the&n; *             drive light is flashing, the drive will return a bad&n; *             status and be reset.  It recovers, though.&n; */
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/cdu31a.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR CDU31A_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
DECL|macro|CDU31A_READAHEAD
mdefine_line|#define CDU31A_READAHEAD 128  /* 128 sector, 64kB, 32 reads read-ahead */
DECL|macro|CDU31A_MAX_CONSECUTIVE_ATTENTIONS
mdefine_line|#define CDU31A_MAX_CONSECUTIVE_ATTENTIONS 10
multiline_comment|/* Define the following if you have data corruption problems. */
DECL|macro|SONY_POLL_EACH_BYTE
macro_line|#undef SONY_POLL_EACH_BYTE
multiline_comment|/*&n;** Edit the following data to change interrupts, DMA channels, etc.&n;** Default is polled and no DMA.  DMA is not recommended for double-speed&n;** drives.&n;*/
r_static
r_struct
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* I/O Base Address */
DECL|member|int_num
r_int
id|int_num
suffix:semicolon
multiline_comment|/* Interrupt Number (-1 means scan for it,&n;                                   0 means don&squot;t use) */
DECL|variable|cdu31a_addresses
)brace
id|cdu31a_addresses
(braket
)braket
op_assign
(brace
macro_line|#if 0&t;/* No autoconfig any more. See Note at beginning&n;&t;   of this file. */
(brace
l_int|0x340
comma
l_int|0
)brace
comma
multiline_comment|/* Standard configuration Sony Interface */
(brace
l_int|0x1f88
comma
l_int|0
)brace
comma
multiline_comment|/* Fusion CD-16 */
(brace
l_int|0x230
comma
l_int|0
)brace
comma
multiline_comment|/* SoundBlaster 16 card */
(brace
l_int|0x360
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x320
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x330
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x634
comma
l_int|0
)brace
comma
multiline_comment|/* Sound FX SC400 */
(brace
l_int|0x654
comma
l_int|0
)brace
comma
multiline_comment|/* Sound FX SC400 */
macro_line|#endif
(brace
l_int|0
)brace
)brace
suffix:semicolon
r_static
r_int
id|handle_sony_cd_attention
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|read_subcode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sony_get_toc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|scd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|do_sony_cd_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
suffix:semicolon
r_static
r_void
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|buf
)paren
suffix:semicolon
multiline_comment|/* Parameters for the read-ahead. */
DECL|variable|sony_next_block
r_static
r_int
r_int
id|sony_next_block
suffix:semicolon
multiline_comment|/* Next 512 byte block offset */
DECL|variable|sony_blocks_left
r_static
r_int
r_int
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of 512 byte blocks left&n;                                             in the current read command. */
multiline_comment|/* The base I/O address of the Sony Interface.  This is a variable (not a&n;   #define) so it can be easily changed via some future ioctl() */
DECL|variable|cdu31a_port
r_static
r_int
r_int
id|cdu31a_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The following are I/O addresses of the various registers for the drive.  The&n; * comment for the base address also applies here.&n; */
DECL|variable|sony_cd_cmd_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_cmd_reg
suffix:semicolon
DECL|variable|sony_cd_param_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_param_reg
suffix:semicolon
DECL|variable|sony_cd_write_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_write_reg
suffix:semicolon
DECL|variable|sony_cd_control_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_control_reg
suffix:semicolon
DECL|variable|sony_cd_status_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_status_reg
suffix:semicolon
DECL|variable|sony_cd_result_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_result_reg
suffix:semicolon
DECL|variable|sony_cd_read_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_read_reg
suffix:semicolon
DECL|variable|sony_cd_fifost_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_fifost_reg
suffix:semicolon
DECL|variable|sony_spun_up
r_static
r_int
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Has the drive been spun up? */
DECL|variable|sony_xa_mode
r_static
r_int
id|sony_xa_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is an XA disk in the drive&n;&t;&t;&t;&t;&t;      and the drive a CDU31A? */
DECL|variable|sony_raw_data_mode
r_static
r_int
id|sony_raw_data_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 if data tracks, 0 if audio.&n;                                              For raw data reads. */
DECL|variable|sony_usage
r_static
r_int
r_int
id|sony_usage
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How many processes have the&n;                                              drive open. */
DECL|variable|sony_pas_init
r_static
r_int
id|sony_pas_init
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the Pro-Audio&n;&t;&t;&t;&t;&t;      Spectrum card? */
DECL|variable|sony_toc
r_static
r_struct
id|s_sony_session_toc
id|sony_toc
suffix:semicolon
multiline_comment|/* Holds the&n;&t;&t;&t;&t;&t;       table of&n;&t;&t;&t;&t;&t;       contents. */
DECL|variable|sony_toc_read
r_static
r_int
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Has the TOC been read for&n;&t;&t;&t;&t;&t;      the drive? */
DECL|variable|last_sony_subcode
r_static
r_struct
id|s_sony_subcode
id|last_sony_subcode
suffix:semicolon
multiline_comment|/* Points to the last&n;                                                   subcode address read */
DECL|variable|sony_inuse
r_static
r_volatile
r_int
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the drive in use?  Only one operation&n;&t;&t;&t;&t;&t;at a time allowed */
DECL|variable|sony_wait
r_static
r_struct
id|wait_queue
op_star
id|sony_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Things waiting for the drive */
DECL|variable|has_cd_task
r_static
r_struct
id|task_struct
op_star
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The task that is currently&n;&t;&t;&t;&t;&t;&t;   using the CDROM drive, or&n;&t;&t;&t;&t;&t;&t;   NULL if none. */
DECL|variable|is_double_speed
r_static
r_int
id|is_double_speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the drive a CDU33A? */
DECL|variable|is_auto_eject
r_static
r_int
id|is_auto_eject
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Door has been locked? 1=No/0=Yes */
multiline_comment|/*&n; * The audio status uses the values from read subchannel data as specified&n; * in include/linux/cdrom.h.&n; */
DECL|variable|sony_audio_status
r_static
r_volatile
r_int
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
multiline_comment|/*&n; * The following are a hack for pausing and resuming audio play.  The drive&n; * does not work as I would expect it, if you stop it then start it again,&n; * the drive seeks back to the beginning and starts over.  This holds the&n; * position during a pause so a resume can restart it.  It uses the&n; * audio status variable above to tell if it is paused.&n; */
DECL|variable|cur_pos_msf
r_static
r_int
r_volatile
r_char
id|cur_pos_msf
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|final_pos_msf
r_static
r_int
r_volatile
r_char
id|final_pos_msf
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* What IRQ is the drive using?  0 if none. */
DECL|variable|cdu31a_irq
r_static
r_int
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The interrupt handler will wake this queue up when it gets an&n;   interrupts. */
DECL|variable|cdu31a_irq_wait
r_static
r_struct
id|wait_queue
op_star
id|cdu31a_irq_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|curr_control_reg
r_static
r_int
id|curr_control_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Current value of the control register */
multiline_comment|/* A disk changed variable.  When a disk change is detected, it will&n;   all be set to TRUE.  As the upper layers ask for disk_changed status&n;   it will be cleared. */
DECL|variable|disk_changed
r_static
r_char
id|disk_changed
suffix:semicolon
multiline_comment|/* Variable for using the readahead buffer.  The readahead buffer&n;   is used for raw sector reads and for blocksizes that are smaller&n;   than 2048 bytes. */
DECL|variable|readahead_buffer
r_static
r_char
id|readahead_buffer
(braket
id|CD_FRAMESIZE_RAW
)braket
suffix:semicolon
DECL|variable|readahead_dataleft
r_static
r_int
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
DECL|variable|readahead_bad
r_static
r_int
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Used to time a short period to abort an operation after the&n;   drive has been idle for a while.  This keeps the light on&n;   the drive from flashing for very long. */
DECL|variable|cdu31a_abort_timer
r_static
r_struct
id|timer_list
id|cdu31a_abort_timer
suffix:semicolon
multiline_comment|/* Marks if the timeout has started an abort read.  This is used&n;   on entry to the drive to tell the code to read out the status&n;   from the abort read. */
DECL|variable|abort_read_started
r_static
r_int
id|abort_read_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This routine returns 1 if the disk has been changed since the last&n; * check or 0 if it hasn&squot;t.&n; */
r_static
r_int
DECL|function|scd_disk_change
id|scd_disk_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|disk_changed
suffix:semicolon
id|disk_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|enable_interrupts
id|enable_interrupts
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_or_assign
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|disable_interrupts
id|disable_interrupts
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_and_assign
op_complement
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait a little while (used for polling the drive).  If in initialization,&n; * setting a timeout doesn&squot;t work, so just loop for a while.&n; */
r_static
r_inline
r_void
DECL|function|sony_sleep
id|sony_sleep
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|cdu31a_irq
op_le
l_int|0
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Interrupt driven */
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|enable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following are convenience routine to read various status and set&n; * various conditions in the drive.&n; */
r_static
r_inline
r_int
DECL|function|is_attention
id|is_attention
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_ATTN_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_busy
id|is_busy
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_BUSY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_data_ready
id|is_data_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_DATA_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_data_requested
id|is_data_requested
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_DATA_REQUEST_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_result_ready
id|is_result_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_RES_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_param_write_rdy
id|is_param_write_rdy
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_fifost_reg
)paren
op_amp
id|SONY_PARAM_WRITE_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_result_reg_not_empty
id|is_result_reg_not_empty
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_fifost_reg
)paren
op_amp
id|SONY_RES_REG_NOT_EMP_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|reset_drive
id|reset_drive
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_assign
l_int|0
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|SONY_DRIVE_RESET_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_attention
id|clear_attention
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_ATTN_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_result_ready
id|clear_result_ready
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_RES_RDY_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_data_ready
id|clear_data_ready
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_DATA_RDY_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_param_reg
id|clear_param_reg
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_PARAM_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_status_register
id|read_status_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_result_register
id|read_result_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_result_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_data_register
id|read_data_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_read_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_param
id|write_param
c_func
(paren
r_int
r_char
id|param
)paren
(brace
id|outb
c_func
(paren
id|param
comma
id|sony_cd_param_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_cmd
id|write_cmd
c_func
(paren
r_int
r_char
id|cmd
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_RES_RDY_INT_EN_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmd
comma
id|sony_cd_cmd_reg
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cdu31a_interrupt
id|cdu31a_interrupt
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_if
c_cond
(paren
id|abort_read_started
)paren
(brace
multiline_comment|/* We might be waiting for an abort to finish.  Don&squot;t&n;         disable interrupts yet, though, because we handle&n;         this one here. */
multiline_comment|/* Clear out the result registers. */
r_while
c_loop
(paren
id|is_result_reg_not_empty
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear out the data */
r_while
c_loop
(paren
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|abort_read_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If something was waiting, wake it up now. */
r_if
c_cond
(paren
id|cdu31a_irq_wait
op_ne
l_int|NULL
)paren
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cdu31a_irq_wait
op_ne
l_int|NULL
)paren
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CDU31A: Got an interrupt but nothing was waiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Set the drive parameters so the drive will auto-spin-up when a&n; * disk is inserted.&n; */
r_static
r_void
DECL|function|set_drive_params
id|set_drive_params
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|3
)braket
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_AUTO_SPIN_DOWN_TIME
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Never spin down the drive. */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  Unable to set spin-down time: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_MECH_CONTROL
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
id|SONY_AUTO_SPIN_UP_BIT
suffix:semicolon
multiline_comment|/* Set auto spin up */
r_if
c_cond
(paren
id|is_auto_eject
)paren
id|params
(braket
l_int|1
)braket
op_or_assign
id|SONY_AUTO_EJECT_BIT
suffix:semicolon
r_if
c_cond
(paren
id|is_double_speed
)paren
(brace
id|params
(braket
l_int|1
)braket
op_or_assign
id|SONY_DOUBLE_SPEED_BIT
suffix:semicolon
multiline_comment|/* Set the drive to double speed if &n;                                             possible */
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  Unable to set mechanical parameters: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This code will reset the drive and attempt to restore sane parameters.&n; */
r_static
r_void
DECL|function|restart_on_error
id|restart_on_error
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cdu31a: Resetting drive on error&bslash;n&quot;
)paren
suffix:semicolon
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Unable to spin up drive: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine writes data to the parameter register.  Since this should&n; * happen fairly fast, it is polled with no OS waits between.&n; */
r_static
r_int
DECL|function|write_params
id|write_params
c_func
(paren
r_int
r_char
op_star
id|params
comma
r_int
id|num_params
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_param_write_rdy
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_param_write_rdy
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
id|num_params
OG
l_int|0
)paren
(brace
id|write_param
c_func
(paren
op_star
id|params
)paren
suffix:semicolon
id|params
op_increment
suffix:semicolon
id|num_params
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The following reads data from the command result register.  It is a&n; * fairly complex routine, all status info flows back through this&n; * interface.  The algorithm is stolen directly from the flowcharts in&n; * the drive manual.&n; */
r_static
r_void
DECL|function|get_result
id|get_result
c_func
(paren
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_char
id|a
comma
id|b
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the result data to be ready */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;    * Get the first two bytes.  This determines what else needs&n;    * to be done.&n;    */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|a
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
op_star
id|result_buffer
op_assign
id|a
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
multiline_comment|/* Check for block error status result. */
r_if
c_cond
(paren
(paren
id|a
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
op_star
id|result_size
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|b
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
op_star
id|result_buffer
op_assign
id|b
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;    * 0x20 means an error occurred.  Byte 2 will have the error code.&n;    * Otherwise, the command succeeded, byte 2 will have the count of&n;    * how many more status bytes are coming.&n;    *&n;    * The result register can be read 10 bytes at a time, a wait for&n;    * result ready to be asserted must be done between every 10 bytes.&n;    */
r_if
c_cond
(paren
(paren
id|a
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|b
OG
l_int|8
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
)brace
id|b
op_assign
id|b
op_minus
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|b
OG
l_int|10
)paren
(brace
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
)brace
id|b
op_assign
id|b
op_minus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
id|b
OG
l_int|0
)paren
(brace
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|b
OG
l_int|0
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
id|b
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Do a command that does not involve data transfer.  This routine must&n; * be re-entrant from the same task to support being called from the&n; * data operation code when an error occurs.&n; */
r_static
r_void
DECL|function|do_sony_cd_cmd
id|do_sony_cd_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
id|num_retries
suffix:semicolon
r_int
id|recursive_call
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
id|has_cd_task
)paren
multiline_comment|/* Allow recursive calls to this routine */
(brace
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_SIGNAL_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
id|recursive_call
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|recursive_call
op_assign
l_int|1
suffix:semicolon
)brace
id|num_retries
op_assign
l_int|0
suffix:semicolon
id|retry_cd_operation
suffix:colon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_params
c_func
(paren
id|params
comma
id|num_params
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|get_result
c_func
(paren
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|result_buffer
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
op_logical_and
(paren
id|num_retries
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_retries
op_increment
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
multiline_comment|/* Wait .1 seconds on retries */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|retry_cd_operation
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|recursive_call
)paren
(brace
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle an attention from the drive.  This will return 1 if it found one&n; * or 0 if not (if one is found, the caller might want to call again).&n; *&n; * This routine counts the number of consecutive times it is called&n; * (since this is always called from a while loop until it returns&n; * a 0), and returns a 0 if it happens too many times.  This will help&n; * prevent a lockup.&n; */
r_static
r_int
DECL|function|handle_sony_cd_attention
id|handle_sony_cd_attention
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|atten_code
suffix:semicolon
r_static
r_int
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_volatile
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|is_attention
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_consecutive_attentions
OG
id|CDU31A_MAX_CONSECUTIVE_ATTENTIONS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Too many consecutive attentions: %d&bslash;n&quot;
comma
id|num_consecutive_attentions
)paren
suffix:semicolon
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|clear_attention
c_func
(paren
)paren
suffix:semicolon
id|atten_code
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|atten_code
)paren
(brace
multiline_comment|/* Someone changed the CD.  Mark it as changed */
r_case
id|SONY_MECH_LOADED_ATTN
suffix:colon
id|disk_changed
op_assign
l_int|1
suffix:semicolon
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_SPIN_DOWN_COMPLETE_ATTN
suffix:colon
multiline_comment|/* Mark the disk as spun down. */
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_AUDIO_PLAY_DONE_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
id|read_subcode
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_EJECT_PUSHED_ATTN
suffix:colon
r_if
c_cond
(paren
id|is_auto_eject
)paren
(brace
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SONY_LEAD_IN_ERR_ATTN
suffix:colon
r_case
id|SONY_LEAD_OUT_ERR_ATTN
suffix:colon
r_case
id|SONY_DATA_TRACK_ERR_ATTN
suffix:colon
r_case
id|SONY_AUDIO_PLAYBACK_ERR_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num_consecutive_attentions
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|abort_read_started
)paren
(brace
r_while
c_loop
(paren
id|is_result_reg_not_empty
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear out the data */
r_while
c_loop
(paren
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|abort_read_started
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Convert from an integer 0-99 to BCD */
r_static
r_inline
r_int
r_int
DECL|function|int_to_bcd
id|int_to_bcd
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
(paren
id|val
op_div
l_int|10
)paren
op_lshift
l_int|4
suffix:semicolon
id|retval
op_assign
id|retval
op_or
id|val
op_mod
l_int|10
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Convert from BCD to an integer from 0-99 */
r_static
r_int
r_int
DECL|function|bcd_to_int
id|bcd_to_int
c_func
(paren
r_int
r_int
id|bcd
)paren
(brace
r_return
(paren
(paren
(paren
id|bcd
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|bcd
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a logical sector value (like the OS would want to use for&n; * a block device) to an MSF format.&n; */
r_static
r_void
DECL|function|log_to_msf
id|log_to_msf
c_func
(paren
r_int
r_int
id|log
comma
r_int
r_char
op_star
id|msf
)paren
(brace
id|log
op_assign
id|log
op_plus
id|LOG_START_OFFSET
suffix:semicolon
id|msf
(braket
l_int|0
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|4500
)paren
suffix:semicolon
id|log
op_assign
id|log
op_mod
l_int|4500
suffix:semicolon
id|msf
(braket
l_int|1
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|75
)paren
suffix:semicolon
id|msf
(braket
l_int|2
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_mod
l_int|75
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an MSF format to a logical sector.&n; */
r_static
r_int
r_int
DECL|function|msf_to_log
id|msf_to_log
c_func
(paren
r_int
r_char
op_star
id|msf
)paren
(brace
r_int
r_int
id|log
suffix:semicolon
id|log
op_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|log
op_add_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|1
)braket
)paren
op_star
l_int|75
suffix:semicolon
id|log
op_add_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|0
)braket
)paren
op_star
l_int|4500
suffix:semicolon
id|log
op_assign
id|log
op_minus
id|LOG_START_OFFSET
suffix:semicolon
r_return
id|log
suffix:semicolon
)brace
multiline_comment|/*&n; * Take in integer size value and put it into a buffer like&n; * the drive would want to see a number-of-sector value.&n; */
r_static
r_void
DECL|function|size_to_buf
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|size
op_div
l_int|65536
suffix:semicolon
id|size
op_assign
id|size
op_mod
l_int|65536
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|size
op_div
l_int|256
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|size
op_mod
l_int|256
suffix:semicolon
)brace
multiline_comment|/* Starts a read operation. Returns 0 on success and 1 on failure. &n;   The read operation used here allows multiple sequential sectors &n;   to be read and status returned for each sector.  The driver will&n;   read the out one at a time as the requests come and abort the&n;   operation if the requested sector is not the next one from the&n;   drive. */
r_static
r_int
DECL|function|start_request
id|start_request
c_func
(paren
r_int
r_int
id|sector
comma
r_int
r_int
id|nsect
comma
r_int
id|read_nsect_only
)paren
(brace
r_int
r_char
id|params
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_int
id|read_size
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
id|log_to_msf
c_func
(paren
id|sector
comma
id|params
)paren
suffix:semicolon
multiline_comment|/* If requested, read exactly what was asked. */
r_if
c_cond
(paren
id|read_nsect_only
)paren
(brace
id|read_size
op_assign
id|nsect
suffix:semicolon
)brace
multiline_comment|/*&n;    * If the full read-ahead would go beyond the end of the media, trim&n;    * it back to read just till the end of the media.&n;    */
r_else
r_if
c_cond
(paren
(paren
id|sector
op_plus
id|nsect
)paren
op_ge
id|sony_toc.lead_out_start_lba
)paren
(brace
id|read_size
op_assign
id|sony_toc.lead_out_start_lba
op_minus
id|sector
suffix:semicolon
)brace
multiline_comment|/* Read the full readahead amount. */
r_else
(brace
id|read_size
op_assign
id|CDU31A_READAHEAD
suffix:semicolon
)brace
id|size_to_buf
c_func
(paren
id|read_size
comma
op_amp
id|params
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;    * Clear any outstanding attentions and wait for the drive to&n;    * complete any pending operations.&n;    */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Timeout while waiting to issue command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Issue the command */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_params
c_func
(paren
id|params
comma
l_int|6
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|SONY_READ_BLKERR_STAT_CMD
)paren
suffix:semicolon
id|sony_blocks_left
op_assign
id|read_size
op_star
l_int|4
suffix:semicolon
id|sony_next_block
op_assign
id|sector
op_star
l_int|4
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Abort a pending read operation.  Clear all the drive status and&n;   readahead variables. */
r_static
r_void
DECL|function|abort_read
id|abort_read
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|result_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|result_size
suffix:semicolon
r_volatile
r_int
id|val
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_ABORT_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|result_reg
comma
op_amp
id|result_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error aborting read, error = 0x%2.2x&bslash;n&quot;
comma
id|result_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|is_result_reg_not_empty
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear out the data */
r_while
c_loop
(paren
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called when the timer times out.  This will abort the&n;   pending read operation. */
r_static
r_void
DECL|function|handle_abort_timeout
id|handle_abort_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
multiline_comment|/* If it is in use, ignore it. */
r_if
c_cond
(paren
op_logical_neg
id|sony_inuse
)paren
(brace
multiline_comment|/* We can&squot;t use abort_read(), because it will sleep&n;         or schedule in the timer interrupt.  Just start&n;         the operation, finish it on the next access to&n;         the drive. */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|SONY_ABORT_CMD
)paren
suffix:semicolon
id|sony_blocks_left
op_assign
l_int|0
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
id|abort_read_started
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Actually get data and status from the drive. */
r_static
r_void
DECL|function|input_data
id|input_data
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_int
id|bytesleft
comma
r_int
r_int
id|nblocks
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|skip
)paren
(brace
r_int
id|i
suffix:semicolon
r_volatile
r_int
r_char
id|val
suffix:semicolon
multiline_comment|/* If an XA disk on a CDU31A, skip the first 12 bytes of data from&n;      the disk.  The real data is after that. */
r_if
c_cond
(paren
id|sony_xa_mode
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_XA_HEAD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytesleft
op_eq
l_int|2048
)paren
multiline_comment|/* 2048 byte direct buffer transfer */
(brace
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|buffer
comma
l_int|2048
)paren
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the input read did not align with the beginning of the block,&n;&t; skip the necessary bytes. */
r_if
c_cond
(paren
id|skip
op_ne
l_int|0
)paren
(brace
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|readahead_buffer
comma
id|skip
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the data into the buffer. */
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
op_amp
id|buffer
(braket
id|offset
)braket
comma
id|bytesleft
)paren
suffix:semicolon
multiline_comment|/* Get the rest of the data into the readahead buffer at the&n;&t; proper location. */
id|readahead_dataleft
op_assign
(paren
l_int|2048
op_minus
id|skip
)paren
op_minus
id|bytesleft
suffix:semicolon
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|readahead_buffer
op_plus
id|bytesleft
comma
id|readahead_dataleft
)paren
suffix:semicolon
)brace
id|sony_blocks_left
op_sub_assign
id|nblocks
suffix:semicolon
id|sony_next_block
op_add_assign
id|nblocks
suffix:semicolon
multiline_comment|/* If an XA disk, we have to clear out the rest of the unused&n;      error correction data. */
r_if
c_cond
(paren
id|sony_xa_mode
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_XA_TAIL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* read data from the drive.  Note the nsect must be &lt;= 4. */
r_static
r_void
DECL|function|read_data_block
id|read_data_block
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_int
id|block
comma
r_int
r_int
id|nblocks
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
op_star
id|res_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
r_int
id|bytesleft
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|skip
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|res_size
op_assign
l_int|0
suffix:semicolon
id|bytesleft
op_assign
id|nblocks
op_star
l_int|512
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the data in the read-ahead does not match the block offset,&n;      then fix things up. */
r_if
c_cond
(paren
(paren
(paren
id|block
op_mod
l_int|4
)paren
op_star
l_int|512
)paren
op_ne
(paren
(paren
l_int|2048
op_minus
id|readahead_dataleft
)paren
op_mod
l_int|2048
)paren
)paren
(brace
id|sony_next_block
op_add_assign
id|block
op_mod
l_int|4
suffix:semicolon
id|sony_blocks_left
op_sub_assign
id|block
op_mod
l_int|4
suffix:semicolon
id|skip
op_assign
(paren
id|block
op_mod
l_int|4
)paren
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have readahead data in the buffer, get that first before we&n;      decide if a read is necessary. */
r_if
c_cond
(paren
id|readahead_dataleft
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bytesleft
OG
id|readahead_dataleft
)paren
(brace
multiline_comment|/* The readahead will not fill the requested buffer, but&n;&t;    get the data out of the readahead into the buffer. */
id|memcpy
c_func
(paren
id|buffer
comma
id|readahead_buffer
op_plus
(paren
l_int|2048
op_minus
id|readahead_dataleft
)paren
comma
id|readahead_dataleft
)paren
suffix:semicolon
id|readahead_dataleft
op_assign
l_int|0
suffix:semicolon
id|bytesleft
op_sub_assign
id|readahead_dataleft
suffix:semicolon
id|offset
op_add_assign
id|readahead_dataleft
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The readahead will fill the whole buffer, get the data&n;&t;    and return. */
id|memcpy
c_func
(paren
id|buffer
comma
id|readahead_buffer
op_plus
(paren
l_int|2048
op_minus
id|readahead_dataleft
)paren
comma
id|bytesleft
)paren
suffix:semicolon
id|readahead_dataleft
op_sub_assign
id|bytesleft
suffix:semicolon
id|bytesleft
op_assign
l_int|0
suffix:semicolon
id|sony_blocks_left
op_sub_assign
id|nblocks
suffix:semicolon
id|sony_next_block
op_add_assign
id|nblocks
suffix:semicolon
multiline_comment|/* If the data in the readahead is bad, return an error so the&n;&t;    driver will abort the buffer. */
r_if
c_cond
(paren
id|readahead_bad
)paren
(brace
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readahead_dataleft
op_eq
l_int|0
)paren
(brace
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Final transfer is done for read command, get final result. */
r_if
c_cond
(paren
id|sony_blocks_left
op_eq
l_int|0
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Got result that should have been error: %d&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|input_data
c_func
(paren
id|buffer
comma
id|bytesleft
comma
id|nblocks
comma
id|offset
comma
id|skip
)paren
suffix:semicolon
multiline_comment|/* Wait for the status from the drive. */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
multiline_comment|/* If we got a buffer status, handle that. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_CIRC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_LECC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_RECOV_LECC_ERR_BLK_STAT
)paren
)paren
(brace
multiline_comment|/* The data was successful, but if data was read from&n;&t;&t;  the readahead  and it was bad, set the whole&n;&t;&t;  buffer as bad. */
r_if
c_cond
(paren
id|readahead_bad
)paren
(brace
id|readahead_bad
op_assign
l_int|0
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data block error: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Data is in the readahead buffer but an error was returned.&n;                  Make sure future requests don&squot;t use the data. */
r_if
c_cond
(paren
id|bytesleft
op_ne
l_int|2048
)paren
(brace
id|readahead_bad
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Final transfer is done for read command, get final result. */
r_if
c_cond
(paren
id|sony_blocks_left
op_eq
l_int|0
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
multiline_comment|/* The drive gave me bad status, I don&squot;t know what to do.&n;               Reset the driver and return an error. */
id|printk
c_func
(paren
l_string|&quot;CDU31A: Invalid block status: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|restart_on_error
c_func
(paren
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * The OS calls this to perform a read or write operation to the drive.&n; * Write obviously fail.  Reads to a read ahead of sony_buffer_size&n; * bytes to help speed operations.  This especially helps since the OS&n; * uses 1024 byte blocks and the drive uses 2048 byte blocks.  Since most&n; * data access on a CD is done sequentially, this saves a lot of operations.&n; */
r_static
r_void
DECL|function|do_cdu31a_request
id|do_cdu31a_request
c_func
(paren
r_void
)paren
(brace
r_int
id|block
suffix:semicolon
r_int
id|nblock
suffix:semicolon
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|num_retries
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;    * Make sure no one else is using the driver; wait for them&n;    * to finish if it is so.&n;    */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_logical_and
id|CURRENT-&gt;rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
multiline_comment|/* Get drive status before doing anything. */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we have a valid TOC. */
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If the timer is running, cancel it. */
r_if
c_cond
(paren
id|cdu31a_abort_timer.next
op_ne
l_int|NULL
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|cdu31a_abort_timer
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cdu31a_request_startover
suffix:colon
multiline_comment|/*&n;       * The beginning here is stolen from the hard disk driver.  I hope&n;       * it&squot;s right.&n;       */
r_if
c_cond
(paren
op_logical_neg
(paren
id|CURRENT
)paren
op_logical_or
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_goto
id|end_do_cdu31a_request
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
r_struct
id|inode
id|in
suffix:semicolon
multiline_comment|/* This is a kludge to get a valid dev in an inode that&n;            scd_open can take.  That&squot;s the only thing scd_open()&n;            uses the inode for. */
id|in.i_rdev
op_assign
id|CURRENT-&gt;rq_dev
suffix:semicolon
id|scd_open
c_func
(paren
op_amp
id|in
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* I don&squot;t use INIT_REQUEST because it calls return, which would&n;         return without unlocking the device.  It shouldn&squot;t matter,&n;         but just to be safe... */
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_lock
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
)brace
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nblock
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: TOC not read&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
multiline_comment|/* Check for base read of multi-session disk.  This will still work&n;         for single session disks, so just do it.  Blocks less than 80&n;         are for the volume info, so offset them by the start track (which&n;         should be zero for a single-session disk). */
r_if
c_cond
(paren
id|block
OL
l_int|80
)paren
(brace
multiline_comment|/* Offset the request into the session. */
id|block
op_add_assign
(paren
id|sony_toc.start_track_lba
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
multiline_comment|/*&n;          * If the block address is invalid or the request goes beyond the end of&n;          * the media, return an error.&n;          */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|block
op_div
l_int|4
)paren
OL
id|sony_toc.start_track_lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Request before beginning of media&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|block
op_div
l_int|4
)paren
op_ge
id|sony_toc.lead_out_start_lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Request past end of media&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|block
op_plus
id|nblock
)paren
op_div
l_int|4
)paren
op_ge
id|sony_toc.lead_out_start_lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Request past end of media&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
id|num_retries
op_assign
l_int|0
suffix:semicolon
id|try_read_again
suffix:colon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: TOC not read&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
multiline_comment|/* If no data is left to be read from the drive, start the&n;&t;    next request. */
r_if
c_cond
(paren
id|sony_blocks_left
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|block
op_div
l_int|4
comma
id|CDU31A_READAHEAD
op_div
l_int|4
comma
l_int|0
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
)brace
multiline_comment|/* If the requested block is not the next one waiting in&n;&t;    the driver, abort the current operation and start a&n;&t;    new one. */
r_else
r_if
c_cond
(paren
id|block
op_ne
id|sony_next_block
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A Warning: Read for block %d, expected %d&bslash;n&quot;
comma
id|block
comma
id|sony_next_block
)paren
suffix:semicolon
macro_line|#endif
id|abort_read
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: TOC not read&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|block
op_div
l_int|4
comma
id|CDU31A_READAHEAD
op_div
l_int|4
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31a: start request failed&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
)brace
id|read_data_block
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|block
comma
id|nblock
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|num_retries
OG
id|MAX_CDU31A_RETRIES
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
id|num_retries
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Read error: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_goto
id|try_read_again
suffix:semicolon
)brace
r_else
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;CDU31A: Unknown cmd&quot;
)paren
suffix:semicolon
)brace
)brace
id|end_do_cdu31a_request
suffix:colon
macro_line|#if 0
multiline_comment|/* After finished, cancel any pending operations. */
id|abort_read
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Start a timer to time out after a while to disable&n;      the read. */
id|cdu31a_abort_timer.expires
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Wait 2 seconds */
id|add_timer
c_func
(paren
op_amp
id|cdu31a_abort_timer
)paren
suffix:semicolon
macro_line|#endif
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy overlapping buffers. */
r_static
r_void
DECL|function|mcovlp
id|mcovlp
c_func
(paren
r_char
op_star
id|dst
comma
r_char
op_star
id|src
comma
r_int
id|size
)paren
(brace
id|src
op_add_assign
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|dst
op_add_assign
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
op_star
id|dst
op_assign
op_star
id|src
suffix:semicolon
id|size
op_decrement
suffix:semicolon
id|dst
op_decrement
suffix:semicolon
id|src
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read the table of contents from the drive and set up TOC if&n; * successful.&n; */
r_static
r_void
DECL|function|sony_get_toc
id|sony_get_toc
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|parms
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|session
suffix:semicolon
r_int
id|num_spin_ups
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Entering sony_get_toc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|num_spin_ups
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|respinup_on_gettoc
suffix:colon
multiline_comment|/* Ignore the result, since it might error if spinning already. */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;         it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* If the drive is already playing, it&squot;s ok.  */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_AUDIO_PLAYING_ERR
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
)paren
(brace
r_goto
id|gettoc_drive_spinning
suffix:semicolon
)brace
multiline_comment|/* If the drive says it is not spun up (even though we just did it!)&n;            then retry the operation at least a few times. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
op_logical_and
(paren
id|num_spin_ups
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_spin_ups
op_increment
suffix:semicolon
r_goto
id|respinup_on_gettoc
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Error reading TOC: %x %x&bslash;n&quot;
comma
id|sony_toc.exec_status
(braket
l_int|0
)braket
comma
id|sony_toc.exec_status
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gettoc_drive_spinning
suffix:colon
multiline_comment|/* The idea here is we keep asking for sessions until the command&n;&t; fails.  Then we know what the last valid session on the disk is.&n;&t; No need to check session 0, since session 0 is the same as session&n;         1; the command returns different information if you give it 0. &n;         Don&squot;t check session 1 because that is the first session, it must&n;         be there. */
id|session
op_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Trying session %d&bslash;n&quot;
comma
id|session
)paren
suffix:semicolon
macro_line|#endif
id|parms
(braket
l_int|0
)braket
op_assign
id|session
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_SPEC_CMD
comma
id|parms
comma
l_int|1
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;%2.2x %2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
multiline_comment|/* An error reading the TOC, this must be past the last session. */
r_break
suffix:semicolon
)brace
id|session
op_increment
suffix:semicolon
multiline_comment|/* Let&squot;s not get carried away... */
r_if
c_cond
(paren
id|session
OG
l_int|20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: too many sessions: %d&bslash;n&quot;
comma
id|session
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|session
op_decrement
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Reading session %d&bslash;n&quot;
comma
id|session
)paren
suffix:semicolon
macro_line|#endif
id|parms
(braket
l_int|0
)braket
op_assign
id|session
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_TOC_DATA_SPEC_CMD
comma
id|parms
comma
l_int|1
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|sony_toc
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|sony_toc.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Error reading session %d: %x %x&bslash;n&quot;
comma
id|session
comma
id|sony_toc.exec_status
(braket
l_int|0
)braket
comma
id|sony_toc.exec_status
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* An error reading the TOC.  Return without sony_toc_read&n;&t;    set. */
r_return
suffix:semicolon
)brace
id|sony_toc_read
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* For points that do not exist, move the data over them&n;&t; to the right location. */
r_if
c_cond
(paren
id|sony_toc.pointb0
op_ne
l_int|0xb0
)paren
(brace
id|mcovlp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|27
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|18
comma
id|res_size
op_minus
l_int|18
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_toc.pointb1
op_ne
l_int|0xb1
)paren
(brace
id|mcovlp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|36
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|27
comma
id|res_size
op_minus
l_int|27
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_toc.pointb2
op_ne
l_int|0xb2
)paren
(brace
id|mcovlp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|45
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|36
comma
id|res_size
op_minus
l_int|36
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_toc.pointb3
op_ne
l_int|0xb3
)paren
(brace
id|mcovlp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|54
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|45
comma
id|res_size
op_minus
l_int|45
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_toc.pointb4
op_ne
l_int|0xb4
)paren
(brace
id|mcovlp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|63
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|54
comma
id|res_size
op_minus
l_int|54
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_toc.pointc0
op_ne
l_int|0xc0
)paren
(brace
id|mcovlp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|72
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|sony_toc
)paren
op_plus
l_int|63
comma
id|res_size
op_minus
l_int|63
)paren
suffix:semicolon
id|res_size
op_add_assign
l_int|9
suffix:semicolon
)brace
id|sony_toc.start_track_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc.tracks
(braket
l_int|0
)braket
dot
id|track_start_msf
)paren
suffix:semicolon
id|sony_toc.lead_out_start_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc.lead_out_start_msf
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Disk session %d, start track: %d, stop track: %d&bslash;n&quot;
comma
id|session
comma
id|sony_toc.start_track_lba
comma
id|sony_toc.lead_out_start_lba
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;Leaving sony_get_toc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Search for a specific track in the table of contents.&n; */
r_static
r_int
DECL|function|find_track
id|find_track
c_func
(paren
r_int
id|track
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|num_tracks
suffix:semicolon
id|num_tracks
op_assign
id|sony_toc.last_track_num
op_minus
id|sony_toc.first_track_num
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_tracks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sony_toc.tracks
(braket
id|i
)braket
dot
id|track
op_eq
id|track
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the subcode and put it int last_sony_subcode for future use.&n; */
r_static
r_int
DECL|function|read_subcode
id|read_subcode
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|res_size
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_SUBCODE_ADDRESS_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|last_sony_subcode
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|last_sony_subcode.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (read_subcode)&bslash;n&quot;
comma
id|last_sony_subcode.exec_status
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the subchannel info like the CDROMSUBCHNL command wants to see it.  If&n; * the drive is playing, the subchannel needs to be read (since it would be&n; * changing).  If the drive is paused or completed, the subcode information has&n; * already been stored, just use that.  The ioctl call wants things in decimal&n; * (not BCD), so all the conversions are done.&n; */
r_static
r_int
DECL|function|sony_get_subchnl_info
id|sony_get_subchnl_info
c_func
(paren
r_int
id|arg
)paren
(brace
r_struct
id|cdrom_subchnl
id|schi
suffix:semicolon
multiline_comment|/* Get attention stuff */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|schi
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sony_audio_status
)paren
(brace
r_case
id|CDROM_AUDIO_PLAY
suffix:colon
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_PAUSED
suffix:colon
r_case
id|CDROM_AUDIO_COMPLETED
suffix:colon
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_NO_STATUS
suffix:colon
id|schi.cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|schi
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_INVALID
suffix:colon
r_case
id|CDROM_AUDIO_ERROR
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|schi.cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|schi.cdsc_adr
op_assign
id|last_sony_subcode.address
suffix:semicolon
id|schi.cdsc_ctrl
op_assign
id|last_sony_subcode.control
suffix:semicolon
id|schi.cdsc_trk
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.track_num
)paren
suffix:semicolon
id|schi.cdsc_ind
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.index_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|schi.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|schi.cdsc_absaddr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.abs_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|schi.cdsc_absaddr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.abs_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|schi.cdsc_absaddr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.abs_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.rel_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.rel_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode.rel_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|schi.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|schi.cdsc_absaddr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode.abs_msf
)paren
suffix:semicolon
id|schi.cdsc_reladdr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode.rel_msf
)paren
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|schi
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get audio data from the drive.  This is fairly complex because I&n;   am looking for status and data at the same time, but if I get status&n;   then I just look for data.  I need to get the status immediately so&n;   the switch from audio to data tracks will happen quickly. */
r_static
r_void
DECL|function|read_audio_data
id|read_audio_data
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
op_star
id|res_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
id|result_read
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|res_size
op_assign
l_int|0
suffix:semicolon
id|result_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
id|continue_read_audio_wait
suffix:colon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
op_logical_or
id|result_read
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_result_ready
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|result_read
)paren
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
multiline_comment|/* Read block status and continue waiting for data. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
id|result_read
op_assign
l_int|1
suffix:semicolon
r_goto
id|continue_read_audio_wait
suffix:semicolon
)brace
multiline_comment|/* Invalid data from the drive.  Shut down the operation. */
r_else
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Got result that should have been error: %d&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If data block, then get 2340 bytes offset by 12. */
r_if
c_cond
(paren
id|sony_raw_data_mode
)paren
(brace
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|buffer
op_plus
id|CD_XA_HEAD
comma
id|CD_FRAMESIZE_XA
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Audio gets the whole 2352 bytes. */
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
multiline_comment|/* If I haven&squot;t already gotten the result, get it now. */
r_if
c_cond
(paren
op_logical_neg
id|result_read
)paren
(brace
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CDU31A timeout out %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
id|abort_read
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|get_result
c_func
(paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x50
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_CIRC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_LECC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_RECOV_LECC_ERR_BLK_STAT
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_eq
id|SONY_NO_ERR_DETECTION_STAT
)paren
)paren
(brace
multiline_comment|/* Ok, nothing to do. */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data block error: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
multiline_comment|/* The drive gave me bad status, I don&squot;t know what to do.&n;            Reset the driver and return an error. */
id|printk
c_func
(paren
l_string|&quot;CDU31A: Invalid block status: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|restart_on_error
c_func
(paren
)paren
suffix:semicolon
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|res_reg
(braket
l_int|1
)braket
op_assign
id|SONY_BAD_DATA_ERR
suffix:semicolon
op_star
id|res_size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Perform a raw data read.  This will automatically detect the&n;   track type and read the proper data (audio or data). */
r_static
r_int
DECL|function|read_audio
id|read_audio
c_func
(paren
r_struct
id|cdrom_read_audio
op_star
id|ra
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_int
id|cframe
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;    * Make sure no one else is using the driver; wait for them&n;    * to finish if it is so.&n;    */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
id|scd_open
(paren
id|inode
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the drive to do raw operations. */
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x06
op_or
id|sony_raw_data_mode
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to set decode params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* From here down, we have to goto exit_read_audio instead of returning&n;      because the drive parameters have to be set back to data before&n;      return. */
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start_request clears out any readahead data, so it should be safe. */
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|ra-&gt;addr.lba
comma
id|ra-&gt;nframes
comma
l_int|1
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
multiline_comment|/* For every requested frame. */
id|cframe
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cframe
OL
id|ra-&gt;nframes
)paren
(brace
id|read_audio_data
c_func
(paren
id|readahead_buffer
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_BAD_DATA_ERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data error on audio sector %d&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_ILL_TRACK_R_ERR
)paren
(brace
multiline_comment|/* Illegal track type, change track types and start over. */
id|sony_raw_data_mode
op_assign
(paren
id|sony_raw_data_mode
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Set the drive mode. */
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x06
op_or
id|sony_raw_data_mode
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to set decode params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
multiline_comment|/* Restart the request on the current frame. */
r_if
c_cond
(paren
id|start_request
c_func
(paren
id|ra-&gt;addr.lba
op_plus
id|cframe
comma
id|ra-&gt;nframes
op_minus
id|cframe
comma
l_int|1
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t go back to the top because don&squot;t want to get into&n;               and infinite loop.  A lot of code gets duplicated, but&n;               that&squot;s no big deal, I don&squot;t guess. */
id|read_audio_data
c_func
(paren
id|readahead_buffer
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_BAD_DATA_ERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Data error on audio sector %d&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error reading audio data on sector %d: 0x%x&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|ra-&gt;buf
op_plus
(paren
id|CD_FRAMESIZE_RAW
op_star
id|cframe
)paren
)paren
comma
(paren
r_char
op_star
)paren
id|readahead_buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error reading audio data on sector %d: 0x%x&bslash;n&quot;
comma
id|ra-&gt;addr.lba
op_plus
id|cframe
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|ra-&gt;buf
op_plus
(paren
id|CD_FRAMESIZE_RAW
op_star
id|cframe
)paren
)paren
comma
(paren
r_char
op_star
)paren
id|readahead_buffer
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
)brace
id|cframe
op_increment
suffix:semicolon
)brace
id|get_result
c_func
(paren
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Error return from audio read: 0x%x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|exit_read_audio
suffix:semicolon
)brace
id|exit_read_audio
suffix:colon
multiline_comment|/* Set the drive mode back to the proper one for the disk. */
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_xa_mode
)paren
(brace
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x0f
suffix:semicolon
)brace
r_else
(brace
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x07
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to reset decode params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_sony_cd_cmd_chk
id|do_sony_cd_cmd_chk
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|cmd
comma
id|params
comma
id|num_params
comma
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|result_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|result_buffer
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROM%s)&bslash;n&quot;
comma
id|result_buffer
(braket
l_int|1
)braket
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The big ugly ioctl handler.&n; */
DECL|function|scd_ioctl
r_static
r_int
id|scd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|7
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive */
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;START&quot;
comma
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/*&n;       * Spin the drive down, ignoring the error if the disk was&n;       * already not spinning.&n;       */
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;STOP&quot;
comma
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
r_if
c_cond
(paren
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;PAUSE&quot;
comma
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Get the current position and save it for resuming */
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cur_pos_msf
(braket
l_int|0
)braket
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|0
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|1
)braket
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|1
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|2
)braket
op_assign
id|last_sony_subcode.abs_msf
(braket
l_int|2
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Start the drive after being paused */
r_if
c_cond
(paren
id|sony_audio_status
op_ne
id|CDROM_AUDIO_PAUSED
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* Start the drive at the saved position. */
id|params
(braket
l_int|1
)braket
op_assign
id|cur_pos_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|cur_pos_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|cur_pos_msf
(braket
l_int|2
)braket
suffix:semicolon
id|params
(braket
l_int|4
)braket
op_assign
id|final_pos_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|5
)braket
op_assign
id|final_pos_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|6
)braket
op_assign
id|final_pos_msf
(braket
l_int|2
)braket
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;RESUME&quot;
comma
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
(paren
id|params
(braket
l_int|1
)braket
)paren
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* The parameters are given in int, must be converted */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|params
(braket
id|i
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|params
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;PLAYMSF&quot;
comma
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|params
(braket
l_int|4
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|params
(braket
l_int|5
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|params
(braket
l_int|6
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
(brace
r_struct
id|cdrom_tochdr
op_star
id|hdr
suffix:semicolon
r_struct
id|cdrom_tochdr
id|loc_hdr
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|loc_hdr.cdth_trk0
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc.first_track_num
)paren
suffix:semicolon
id|loc_hdr.cdth_trk1
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc.last_track_num
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|hdr
comma
op_amp
id|loc_hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read a given table of contents entry */
(brace
r_struct
id|cdrom_tocentry
op_star
id|entry
suffix:semicolon
r_struct
id|cdrom_tocentry
id|loc_entry
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
r_int
r_char
op_star
id|msf_val
op_assign
l_int|NULL
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|entry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|loc_entry
comma
id|entry
comma
r_sizeof
(paren
id|loc_entry
)paren
)paren
suffix:semicolon
multiline_comment|/* Lead out is handled separately since it is special. */
r_if
c_cond
(paren
id|loc_entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
(brace
id|loc_entry.cdte_adr
op_assign
id|sony_toc.address2
suffix:semicolon
id|loc_entry.cdte_ctrl
op_assign
id|sony_toc.control2
suffix:semicolon
id|msf_val
op_assign
id|sony_toc.lead_out_start_msf
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|loc_entry.cdte_track
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|loc_entry.cdte_adr
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|address
suffix:semicolon
id|loc_entry.cdte_ctrl
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|control
suffix:semicolon
id|msf_val
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
suffix:semicolon
)brace
multiline_comment|/* Logical buffer address or MSF format requested? */
r_if
c_cond
(paren
id|loc_entry.cdte_format
op_eq
id|CDROM_LBA
)paren
(brace
id|loc_entry.cdte_addr.lba
op_assign
id|msf_to_log
c_func
(paren
id|msf_val
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|loc_entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|loc_entry.cdte_addr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
op_star
id|msf_val
)paren
suffix:semicolon
id|loc_entry.cdte_addr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
op_star
(paren
id|msf_val
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|loc_entry.cdte_addr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
op_star
(paren
id|msf_val
op_plus
l_int|2
)paren
)paren
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
id|entry
comma
op_amp
id|loc_entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
(brace
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ti.cdti_trk0
OL
id|sony_toc.first_track_num
)paren
op_logical_or
(paren
id|ti.cdti_trk0
OG
id|sony_toc.last_track_num
)paren
op_logical_or
(paren
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|ti.cdti_trk0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|params
(braket
l_int|1
)braket
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;          * If we want to stop after the last track, use the lead-out&n;          * MSF to do that.&n;          */
r_if
c_cond
(paren
id|ti.cdti_trk1
op_ge
id|bcd_to_int
c_func
(paren
id|sony_toc.last_track_num
)paren
)paren
(brace
id|log_to_msf
c_func
(paren
id|msf_to_log
c_func
(paren
id|sony_toc.lead_out_start_msf
)paren
op_minus
l_int|1
comma
op_amp
(paren
id|params
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|ti.cdti_trk1
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|log_to_msf
c_func
(paren
id|msf_to_log
c_func
(paren
id|sony_toc.tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
)paren
op_minus
l_int|1
comma
op_amp
(paren
id|params
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Params: %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|params
(braket
l_int|0
)braket
comma
id|params
(braket
l_int|1
)braket
comma
id|params
(braket
l_int|2
)braket
comma
id|params
(braket
l_int|3
)braket
comma
id|params
(braket
l_int|4
)braket
comma
id|params
(braket
l_int|5
)braket
comma
id|params
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMPLAYTRKIND&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|params
(braket
l_int|4
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|params
(braket
l_int|5
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|params
(braket
l_int|6
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
r_return
id|sony_get_subchnl_info
c_func
(paren
id|arg
)paren
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control.  What volume does this change, anyway? */
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_AUDIO_VOLUME
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
id|volctrl.channel0
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|volctrl.channel1
suffix:semicolon
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;VOLCTRL&quot;
comma
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|3
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
multiline_comment|/* Eject the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
r_return
id|do_sony_cd_cmd_chk
c_func
(paren
l_string|&quot;EJECT&quot;
comma
id|SONY_EJECT_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_case
id|CDROMREADAUDIO
suffix:colon
multiline_comment|/* Read 2352 byte audio tracks and 2340 byte&n;&t;&t;&t;&t; raw data tracks. */
(brace
r_struct
id|cdrom_read_audio
id|ra
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ra
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ra.buf
comma
id|CD_FRAMESIZE_RAW
op_star
id|ra.nframes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_LBA
)paren
(brace
r_if
c_cond
(paren
(paren
id|ra.addr.lba
op_ge
id|sony_toc.lead_out_start_lba
)paren
op_logical_or
(paren
id|ra.addr.lba
op_plus
id|ra.nframes
op_ge
id|sony_toc.lead_out_start_lba
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_MSF
)paren
(brace
r_if
c_cond
(paren
(paren
id|ra.addr.msf.minute
op_ge
l_int|75
)paren
op_logical_or
(paren
id|ra.addr.msf.second
op_ge
l_int|60
)paren
op_logical_or
(paren
id|ra.addr.msf.frame
op_ge
l_int|75
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ra.addr.lba
op_assign
(paren
(paren
id|ra.addr.msf.minute
op_star
l_int|4500
)paren
op_plus
(paren
id|ra.addr.msf.second
op_star
l_int|75
)paren
op_plus
id|ra.addr.msf.frame
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ra.addr.lba
op_ge
id|sony_toc.lead_out_start_lba
)paren
op_logical_or
(paren
id|ra.addr.lba
op_plus
id|ra.nframes
op_ge
id|sony_toc.lead_out_start_lba
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* I know, this can go negative on an unsigned.  However,&n;               the first thing done to the data is to add this value,&n;               so this should compensate and allow direct msf access. */
id|ra.addr.lba
op_sub_assign
id|LOG_START_OFFSET
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|read_audio
c_func
(paren
op_amp
id|ra
comma
id|inode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMEJECT_SW
suffix:colon
id|is_auto_eject
op_assign
id|arg
suffix:semicolon
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Open the drive for operations.  Spin the drive up and read the table of&n; * contents if these have not already been done.&n; */
r_static
r_int
DECL|function|scd_open
id|scd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|num_spin_ups
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|filp
)paren
op_logical_and
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
id|num_spin_ups
op_assign
l_int|0
suffix:semicolon
id|respinup_on_open
suffix:colon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;         it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (scd_open, spin up)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;         it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* If the drive is already playing, it&squot;s ok.  */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_AUDIO_PLAYING_ERR
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
)paren
(brace
r_goto
id|drive_spinning
suffix:semicolon
)brace
multiline_comment|/* If the drive says it is not spun up (even though we just did it!)&n;            then retry the operation at least a few times. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
op_logical_and
(paren
id|num_spin_ups
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_spin_ups
op_increment
suffix:semicolon
r_goto
id|respinup_on_open
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (scd_open, read toc)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* For XA on the CDU31A only, we have to do special reads.&n;         The CDU33A handles XA automagically. */
r_if
c_cond
(paren
(paren
id|sony_toc.disk_type
op_eq
id|SONY_XA_DISK_TYPE
)paren
op_logical_and
(paren
op_logical_neg
id|is_double_speed
)paren
)paren
(brace
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x07
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to set XA params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|sony_xa_mode
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* A non-XA disk.  Set the parms back if necessary. */
r_else
r_if
c_cond
(paren
id|sony_xa_mode
)paren
(brace
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_DECODE_PARAM
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x0f
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unable to reset XA params: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|sony_xa_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|sony_spun_up
op_assign
l_int|1
suffix:semicolon
)brace
id|drive_spinning
suffix:colon
multiline_comment|/* If filp is not NULL (standard open), try a disk change. */
r_if
c_cond
(paren
id|filp
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
id|sony_usage
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* If all is OK (until now...), then lock the door */
id|is_auto_eject
op_assign
l_int|0
suffix:semicolon
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the drive.  Spin it down if no task is using it.  The spin&n; * down will fail if playing audio, so audio play is OK.&n; */
r_static
r_void
DECL|function|scd_release
id|scd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_if
c_cond
(paren
id|sony_usage
OG
l_int|0
)paren
(brace
id|sony_usage
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_usage
op_eq
l_int|0
)paren
(brace
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* Unlock the door, only if nobody is using the drive */
id|is_auto_eject
op_assign
l_int|1
suffix:semicolon
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|scd_fops
r_static
r_struct
id|file_operations
id|scd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|scd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|scd_open
comma
multiline_comment|/* open */
id|scd_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|scd_disk_change
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/* The different types of disc loading mechanisms supported */
DECL|variable|load_mech
r_static
r_const
r_char
op_star
id|load_mech
(braket
)braket
op_assign
(brace
l_string|&quot;caddy&quot;
comma
l_string|&quot;tray&quot;
comma
l_string|&quot;pop-up&quot;
comma
l_string|&quot;unknown&quot;
)brace
suffix:semicolon
r_static
r_void
DECL|function|get_drive_configuration
id|get_drive_configuration
c_func
(paren
r_int
r_int
id|base_io
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
r_int
op_star
id|res_size
)paren
(brace
r_int
id|retry_count
suffix:semicolon
multiline_comment|/* Set the base address */
id|cdu31a_port
op_assign
id|base_io
suffix:semicolon
multiline_comment|/* Set up all the register locations */
id|sony_cd_cmd_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_CMD_REG_OFFSET
suffix:semicolon
id|sony_cd_param_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_PARAM_REG_OFFSET
suffix:semicolon
id|sony_cd_write_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_WRITE_REG_OFFSET
suffix:semicolon
id|sony_cd_control_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_CONTROL_REG_OFFSET
suffix:semicolon
id|sony_cd_status_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_STATUS_REG_OFFSET
suffix:semicolon
id|sony_cd_result_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_RESULT_REG_OFFSET
suffix:semicolon
id|sony_cd_read_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_READ_REG_OFFSET
suffix:semicolon
id|sony_cd_fifost_reg
op_assign
id|cdu31a_port
op_plus
id|SONY_FIFOST_REG_OFFSET
suffix:semicolon
multiline_comment|/*&n;    * Check to see if anything exists at the status register location.&n;    * I don&squot;t know if this is a good way to check, but it seems to work&n;    * ok for me.&n;    */
r_if
c_cond
(paren
id|read_status_register
c_func
(paren
)paren
op_ne
l_int|0xff
)paren
(brace
multiline_comment|/*&n;       * Reset the drive and wait for attention from it (to say it&squot;s reset).&n;       * If you don&squot;t wait, the next operation will probably fail.&n;       */
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* If attention is never seen probably not a CDU31a present */
r_if
c_cond
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
(brace
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;       * Get the drive configuration.&n;       */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_DRIVE_CONFIG_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Return an error */
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * Set up base I/O and interrupts, called from main.c.&n; */
r_void
DECL|function|cdu31a_setup
id|cdu31a_setup
c_func
(paren
r_char
op_star
id|strings
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
(brace
id|cdu31a_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
(brace
id|cdu31a_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|strings
op_ne
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|strings
op_ne
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|strings
comma
l_string|&quot;PAS&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|sony_pas_init
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CDU31A: Unknown interface type: %s&bslash;n&quot;
comma
id|strings
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
DECL|variable|cdu31a_block_size
r_static
r_int
id|cdu31a_block_size
suffix:semicolon
multiline_comment|/*&n; * Initialize the driver.&n; */
macro_line|#ifdef MODULE
DECL|macro|cdu31a_init
mdefine_line|#define cdu31a_init init_module
macro_line|#endif
r_int
DECL|function|cdu31a_init
id|cdu31a_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|s_sony_drive_config
id|drive_config
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|drive_found
suffix:semicolon
r_int
id|tmp_irq
suffix:semicolon
multiline_comment|/*&n;    * According to Alex Freed (freed@europa.orion.adobe.com), this is&n;    * required for the Fusion CD-16 package.  If the sound driver is&n;    * loaded, it should work fine, but just in case...&n;    *&n;    * The following turn on the CD-ROM interface for a Fusion CD-16.&n;    */
r_if
c_cond
(paren
id|sony_pas_init
)paren
(brace
id|outb
c_func
(paren
l_int|0xbc
comma
l_int|0x9a01
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe2
comma
l_int|0x9a01
)paren
suffix:semicolon
)brace
id|drive_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Setting the base I/O address to 0xffff will disable it. */
r_if
c_cond
(paren
id|cdu31a_port
op_eq
l_int|0xffff
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
id|cdu31a_port
op_ne
l_int|0
)paren
(brace
id|tmp_irq
op_assign
id|cdu31a_irq
suffix:semicolon
multiline_comment|/* Need IRQ 0 because we can&squot;t sleep here. */
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|get_drive_configuration
c_func
(paren
id|cdu31a_port
comma
id|drive_config.exec_status
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OG
l_int|2
)paren
op_logical_and
(paren
(paren
id|drive_config.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x00
)paren
)paren
(brace
id|drive_found
op_assign
l_int|1
suffix:semicolon
)brace
id|cdu31a_irq
op_assign
id|tmp_irq
suffix:semicolon
)brace
r_else
(brace
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
op_ne
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|drive_found
)paren
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
l_int|4
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|get_drive_configuration
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
id|drive_config.exec_status
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OG
l_int|2
)paren
op_logical_and
(paren
(paren
id|drive_config.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x00
)paren
)paren
(brace
id|drive_found
op_assign
l_int|1
suffix:semicolon
id|cdu31a_irq
op_assign
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|int_num
suffix:semicolon
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|drive_found
)paren
(brace
id|request_region
c_func
(paren
id|cdu31a_port
comma
l_int|4
comma
l_string|&quot;cdu31a&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cdu31a&quot;
comma
op_amp
id|scd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for CDU-31a&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_DOUBLE_SPEED
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|is_double_speed
op_assign
l_int|1
suffix:semicolon
)brace
id|tmp_irq
op_assign
id|cdu31a_irq
suffix:semicolon
multiline_comment|/* Need IRQ 0 because we can&squot;t sleep here. */
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
id|cdu31a_irq
op_assign
id|tmp_irq
suffix:semicolon
r_if
c_cond
(paren
id|cdu31a_irq
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cdu31a_irq
comma
id|cdu31a_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;cdu31a&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the CDU31A driver&bslash;n&quot;
comma
id|cdu31a_irq
)paren
suffix:semicolon
id|cdu31a_irq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Sony I/F CDROM : %8.8s %16.16s %8.8s&bslash;n&quot;
comma
id|drive_config.vendor_id
comma
id|drive_config.product_id
comma
id|drive_config.product_rev_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Capabilities: %s&quot;
comma
id|load_mech
(braket
id|SONY_HWC_GET_LOAD_MECH
c_func
(paren
id|drive_config
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SONY_HWC_AUDIO_PLAYBACK
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, audio&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_EJECT
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, eject&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_LED_SUPPORT
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, LED&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_ELECTRIC_VOLUME
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, elec. Vol&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_ELECTRIC_VOLUME_CTL
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, sep. Vol&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_double_speed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, double speed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdu31a_irq
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, irq %d&quot;
comma
id|cdu31a_irq
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
id|CDU31A_READAHEAD
suffix:semicolon
id|cdu31a_block_size
op_assign
l_int|1024
suffix:semicolon
multiline_comment|/* 1kB default block size */
multiline_comment|/* use &squot;mount -o block=2048&squot; */
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|cdu31a_block_size
suffix:semicolon
id|cdu31a_abort_timer.next
op_assign
l_int|NULL
suffix:semicolon
id|cdu31a_abort_timer.prev
op_assign
l_int|NULL
suffix:semicolon
id|cdu31a_abort_timer.function
op_assign
id|handle_abort_timeout
suffix:semicolon
)brace
id|disk_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive_found
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cdu31a&quot;
)paren
op_eq
op_minus
id|EINVAL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister cdu31a&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|cdu31a_port
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cdu31a module released.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif MODULE
eof
