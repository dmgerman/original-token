multiline_comment|/* $Id: parport_ieee1284.c,v 1.4 1997/10/19 21:37:21 philip Exp $&n; * IEEE-1284 implementation for parport.&n; *&n; * Authors: Phil Blundell &lt;Philip.Blundell@pobox.com&gt;&n; *          Carsten Gross &lt;carsten@sol.wohnheim.uni-ulm.de&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt; (largely rewritten)&n; *&n; * This file is responsible for IEEE 1284 negotiation, and for handing&n; * read/write requests to low-level drivers.&n; *&n; * Any part of this program may be used in documents licensed under&n; * the GNU Free Documentation License, Version 1.1 or any later version&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG /* undef me for production */
macro_line|#ifdef CONFIG_LP_CONSOLE
DECL|macro|DEBUG
macro_line|#undef DEBUG /* Don&squot;t want a garbled console */
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(stuff...) printk (stuff)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(stuff...)
macro_line|#endif
multiline_comment|/* Make parport_wait_peripheral wake up.&n; * It will be useful to call this from an interrupt handler. */
DECL|function|parport_ieee1284_wakeup
r_void
id|parport_ieee1284_wakeup
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
id|up
(paren
op_amp
id|port-&gt;physport-&gt;ieee1284.irq
)paren
suffix:semicolon
)brace
DECL|variable|port_from_cookie
r_static
r_struct
id|parport
op_star
id|port_from_cookie
(braket
id|PARPORT_MAX
)braket
suffix:semicolon
DECL|function|timeout_waiting_on_port
r_static
r_void
id|timeout_waiting_on_port
(paren
r_int
r_int
id|cookie
)paren
(brace
id|parport_ieee1284_wakeup
(paren
id|port_from_cookie
(braket
id|cookie
op_mod
id|PARPORT_MAX
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_wait_event - wait for an event on a parallel port&n; *&t;@port: port to wait on&n; *&t;@timeout: time to wait (in jiffies)&n; *&n; *&t;This function waits for up to @timeout jiffies for an&n; *&t;interrupt to occur on a parallel port.  If the port timeout is&n; *&t;set to zero, it returns immediately.&n; *&n; *&t;If an interrupt occurs before the timeout period elapses, this&n; *&t;function returns one immediately.  If it times out, it returns&n; *&t;a value greater than zero.  An error code less than zero&n; *&t;indicates an error (most likely a pending signal), and the&n; *&t;calling code should finish what it&squot;s doing as soon as it can.&n; */
DECL|function|parport_wait_event
r_int
id|parport_wait_event
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;physport-&gt;cad-&gt;timeout
)paren
multiline_comment|/* Zero timeout is special, and we can&squot;t down() the&n;&t;&t;   semaphore. */
r_return
l_int|1
suffix:semicolon
id|init_timer
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|timer.function
op_assign
id|timeout_waiting_on_port
suffix:semicolon
id|port_from_cookie
(braket
id|port-&gt;number
op_mod
id|PARPORT_MAX
)braket
op_assign
id|port
suffix:semicolon
id|timer.data
op_assign
id|port-&gt;number
suffix:semicolon
id|add_timer
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|ret
op_assign
id|down_interruptible
(paren
op_amp
id|port-&gt;physport-&gt;ieee1284.irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|del_timer
(paren
op_amp
id|timer
)paren
op_logical_and
op_logical_neg
id|ret
)paren
multiline_comment|/* Timed out. */
id|ret
op_assign
l_int|1
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_poll_peripheral - poll status lines&n; *&t;@port: port to watch&n; *&t;@mask: status lines to watch&n; *&t;@result: desired values of chosen status lines&n; *&t;@usec: timeout&n; *&n; *&t;This function busy-waits until the masked status lines have&n; *&t;the desired values, or until the timeout period elapses.  The&n; *&t;@mask and @result parameters are bitmasks, with the bits&n; *&t;defined by the constants in parport.h: %PARPORT_STATUS_BUSY,&n; *&t;and so on.&n; *&n; *&t;This function does not call schedule(); instead it busy-waits&n; *&t;using udelay().  It currently has a resolution of 5usec.&n; *&n; *&t;If the status lines take on the desired values before the&n; *&t;timeout period elapses, parport_poll_peripheral() returns zero&n; *&t;immediately.  A zero return value greater than zero indicates&n; *&t;a timeout.  An error code (less than zero) indicates an error,&n; *&t;most likely a signal that arrived, and the caller should&n; *&t;finish what it is doing as soon as possible.&n;*/
DECL|function|parport_poll_peripheral
r_int
id|parport_poll_peripheral
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|result
comma
r_int
id|usec
)paren
(brace
multiline_comment|/* Zero return code is success, &gt;0 is timeout. */
r_int
id|counter
op_assign
id|usec
op_div
l_int|5
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|counter
OG
l_int|0
suffix:semicolon
id|counter
op_decrement
)paren
(brace
id|status
op_assign
id|parport_read_status
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|mask
)paren
op_eq
id|result
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
r_break
suffix:semicolon
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_wait_peripheral - wait for status lines to change in 35ms&n; *&t;@port: port to watch&n; *&t;@mask: status lines to watch&n; *&t;@result: desired values of chosen status lines&n; *&n; *&t;This function waits until the masked status lines have the&n; *&t;desired values, or until 35ms have elapsed (see IEEE 1284-1994&n; *&t;page 24 to 25 for why this value in particular is hardcoded).&n; *&t;The @mask and @result parameters are bitmasks, with the bits&n; *&t;defined by the constants in parport.h: %PARPORT_STATUS_BUSY,&n; *&t;and so on.&n; *&n; *&t;The port is polled quickly to start off with, in anticipation&n; *&t;of a fast response from the peripheral.  This fast polling&n; *&t;time is configurable (using /proc), and defaults to 500usec.&n; *&t;If the timeout for this port (see parport_set_timeout()) is&n; *&t;zero, the fast polling time is 35ms, and this function does&n; *&t;not call schedule().&n; *&n; *&t;If the timeout for this port is non-zero, after the fast&n; *&t;polling fails it uses parport_wait_event() to wait for up to&n; *&t;10ms, waking up if an interrupt occurs.&n; */
DECL|function|parport_wait_peripheral
r_int
id|parport_wait_peripheral
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|result
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|usec
suffix:semicolon
r_int
id|deadline
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|usec
op_assign
id|port-&gt;physport-&gt;spintime
suffix:semicolon
multiline_comment|/* usecs of fast polling */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;physport-&gt;cad-&gt;timeout
)paren
multiline_comment|/* A zero timeout is &quot;special&quot;: busy wait for the&n;&t;&t;   entire 35ms. */
id|usec
op_assign
l_int|35000
suffix:semicolon
multiline_comment|/* Fast polling.&n;&t; *&n;&t; * This should be adjustable.&n;&t; * How about making a note (in the device structure) of how long&n;&t; * it takes, so we know for next time?&n;&t; */
id|ret
op_assign
id|parport_poll_peripheral
(paren
id|port
comma
id|mask
comma
id|result
comma
id|usec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|1
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;physport-&gt;cad-&gt;timeout
)paren
multiline_comment|/* We may be in an interrupt handler, so we can&squot;t poll&n;&t;&t; * slowly anyway. */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* 40ms of slow polling. */
id|deadline
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_plus
l_int|24
)paren
op_div
l_int|25
suffix:semicolon
r_while
c_loop
(paren
id|time_before
(paren
id|jiffies
comma
id|deadline
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Wait for 10ms (or until an interrupt occurs if&n;&t;&t; * the handler is set) */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|parport_wait_event
(paren
id|port
comma
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|status
op_assign
id|parport_read_status
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|mask
)paren
op_eq
id|result
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* parport_wait_event didn&squot;t time out, but the&n;&t;&t;&t; * peripheral wasn&squot;t actually ready either.&n;&t;&t;&t; * Wait for another 10ms. */
id|__set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* Terminate a negotiated mode. */
DECL|function|parport_ieee1284_terminate
r_static
r_void
id|parport_ieee1284_terminate
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_int
id|r
suffix:semicolon
id|port
op_assign
id|port-&gt;physport
suffix:semicolon
multiline_comment|/* EPP terminates differently. */
r_switch
c_cond
(paren
id|port-&gt;ieee1284.mode
)paren
(brace
r_case
id|IEEE1284_MODE_EPP
suffix:colon
r_case
id|IEEE1284_MODE_EPPSL
suffix:colon
r_case
id|IEEE1284_MODE_EPPSWE
suffix:colon
multiline_comment|/* Terminate from EPP mode. */
multiline_comment|/* Event 68: Set nInit low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
comma
l_int|0
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Event 69: Set nInit high, nSelectIn low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_SELECT
op_or
id|PARPORT_CONTROL_INIT
comma
id|PARPORT_CONTROL_SELECT
op_or
id|PARPORT_CONTROL_INIT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECP
suffix:colon
r_case
id|IEEE1284_MODE_ECPRLE
suffix:colon
r_case
id|IEEE1284_MODE_ECPSWE
suffix:colon
multiline_comment|/* In ECP we can only terminate from fwd idle phase. */
r_if
c_cond
(paren
id|port-&gt;ieee1284.phase
op_ne
id|IEEE1284_PH_FWD_IDLE
)paren
(brace
multiline_comment|/* Event 47: Set nInit high */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_AUTOFD
)paren
suffix:semicolon
multiline_comment|/* Event 49: PError goes high */
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
id|PARPORT_STATUS_PAPEROUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|DPRINTK
(paren
id|KERN_INFO
l_string|&quot;%s: Timeout at event 49&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|parport_data_forward
(paren
id|port
)paren
suffix:semicolon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: ECP direction: forward&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
)brace
multiline_comment|/* fall-though.. */
r_default
suffix:colon
multiline_comment|/* Terminate from all other modes. */
multiline_comment|/* Event 22: Set nSelectIn low, nAutoFd high */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_SELECT
op_or
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
multiline_comment|/* Event 24: nAck goes low */
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_ACK
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|DPRINTK
(paren
id|KERN_INFO
l_string|&quot;%s: Timeout at event 24&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Event 25: Set nAutoFd low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_AUTOFD
)paren
suffix:semicolon
multiline_comment|/* Event 27: nAck goes high */
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_ACK
comma
id|PARPORT_STATUS_ACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|DPRINTK
(paren
id|KERN_INFO
l_string|&quot;%s: Timeout at event 27&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Event 29: Set nAutoFd high */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_AUTOFD
comma
l_int|0
)paren
suffix:semicolon
)brace
id|port-&gt;ieee1284.mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: In compatibility (forward idle) mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif /* IEEE1284 support */
multiline_comment|/**&n; *&t;parport_negotiate - negotiate an IEEE 1284 mode&n; *&t;@port: port to use&n; *&t;@mode: mode to negotiate to&n; *&n; *&t;Use this to negotiate to a particular IEEE 1284 transfer mode.&n; *&t;The @mode parameter should be one of the constants in&n; *&t;parport.h starting %IEEE1284_MODE_xxx.&n; *&n; *&t;The return value is 0 if the peripheral has accepted the&n; *&t;negotiation to the mode specified, -1 if the peripheral is not&n; *&t;IEEE 1284 compliant (or not present), or 1 if the peripheral&n; *&t;has rejected the negotiation.&n; */
DECL|function|parport_negotiate
r_int
id|parport_negotiate
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
id|mode
)paren
(brace
macro_line|#ifndef CONFIG_PARPORT_1284
r_if
c_cond
(paren
id|mode
op_eq
id|IEEE1284_MODE_COMPAT
)paren
r_return
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;parport: IEEE1284 not supported in this kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#else
r_int
id|m
op_assign
id|mode
op_amp
op_complement
id|IEEE1284_ADDR
suffix:semicolon
r_int
id|r
suffix:semicolon
r_int
r_char
id|xflag
suffix:semicolon
id|port
op_assign
id|port-&gt;physport
suffix:semicolon
multiline_comment|/* Is there anything to do? */
r_if
c_cond
(paren
id|port-&gt;ieee1284.mode
op_eq
id|mode
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Is the difference just an address-or-not bit? */
r_if
c_cond
(paren
(paren
id|port-&gt;ieee1284.mode
op_amp
op_complement
id|IEEE1284_ADDR
)paren
op_eq
(paren
id|mode
op_amp
op_complement
id|IEEE1284_ADDR
)paren
)paren
(brace
id|port-&gt;ieee1284.mode
op_assign
id|mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Go to compability forward idle mode */
r_if
c_cond
(paren
id|port-&gt;ieee1284.mode
op_ne
id|IEEE1284_MODE_COMPAT
)paren
id|parport_ieee1284_terminate
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|IEEE1284_MODE_COMPAT
)paren
multiline_comment|/* Compatibility mode: no negotiation. */
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|IEEE1284_MODE_ECPSWE
suffix:colon
id|m
op_assign
id|IEEE1284_MODE_ECP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_EPPSL
suffix:colon
r_case
id|IEEE1284_MODE_EPPSWE
suffix:colon
id|m
op_assign
id|IEEE1284_MODE_EPP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_BECP
suffix:colon
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* FIXME (implement BECP) */
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|IEEE1284_EXT_LINK
)paren
id|m
op_assign
l_int|1
op_lshift
l_int|7
suffix:semicolon
multiline_comment|/* request extensibility link */
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_NEGOTIATION
suffix:semicolon
multiline_comment|/* Start off with nStrobe and nAutoFd high, and nSelectIn low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_SELECT
comma
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Event 0: Set data */
id|parport_data_forward
(paren
id|port
)paren
suffix:semicolon
id|parport_write_data
(paren
id|port
comma
id|m
)paren
suffix:semicolon
id|udelay
(paren
l_int|400
)paren
suffix:semicolon
multiline_comment|/* Shouldn&squot;t need to wait this long. */
multiline_comment|/* Event 1: Set nSelectIn high, nAutoFd low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_SELECT
op_or
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_AUTOFD
)paren
suffix:semicolon
multiline_comment|/* Event 2: PError, Select, nFault go high, nAck goes low */
r_if
c_cond
(paren
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_ERROR
op_or
id|PARPORT_STATUS_SELECT
op_or
id|PARPORT_STATUS_PAPEROUT
op_or
id|PARPORT_STATUS_ACK
comma
id|PARPORT_STATUS_ERROR
op_or
id|PARPORT_STATUS_SELECT
op_or
id|PARPORT_STATUS_PAPEROUT
)paren
)paren
(brace
multiline_comment|/* Timeout */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_SELECT
op_or
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Peripheral not IEEE1284 compliant (0x%02X)&bslash;n&quot;
comma
id|port-&gt;name
comma
id|parport_read_status
(paren
id|port
)paren
)paren
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Not IEEE1284 compliant */
)brace
multiline_comment|/* Event 3: Set nStrobe low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
comma
id|PARPORT_CONTROL_STROBE
)paren
suffix:semicolon
multiline_comment|/* Event 4: Set nStrobe and nAutoFd high */
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Event 6: nAck goes high */
r_if
c_cond
(paren
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_ACK
comma
id|PARPORT_STATUS_ACK
)paren
)paren
(brace
multiline_comment|/* This shouldn&squot;t really happen with a compliant device. */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Mode 0x%02x not supported? (0x%02x)&bslash;n&quot;
comma
id|port-&gt;name
comma
id|mode
comma
id|port-&gt;ops-&gt;read_status
(paren
id|port
)paren
)paren
suffix:semicolon
id|parport_ieee1284_terminate
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|xflag
op_assign
id|parport_read_status
(paren
id|port
)paren
op_amp
id|PARPORT_STATUS_SELECT
suffix:semicolon
multiline_comment|/* xflag should be high for all modes other than nibble (0). */
r_if
c_cond
(paren
id|mode
op_logical_and
op_logical_neg
id|xflag
)paren
(brace
multiline_comment|/* Mode not supported. */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Mode 0x%02x rejected by peripheral&bslash;n&quot;
comma
id|port-&gt;name
comma
id|mode
)paren
suffix:semicolon
id|parport_ieee1284_terminate
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* More to do if we&squot;ve requested extensibility link. */
r_if
c_cond
(paren
id|mode
op_amp
id|IEEE1284_EXT_LINK
)paren
(brace
id|m
op_assign
id|mode
op_amp
l_int|0x7f
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|parport_write_data
(paren
id|port
comma
id|m
)paren
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Event 51: Set nStrobe low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
comma
id|PARPORT_CONTROL_STROBE
)paren
suffix:semicolon
multiline_comment|/* Event 52: nAck goes low */
r_if
c_cond
(paren
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_ACK
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* This peripheral is _very_ slow. */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Event 52 didn&squot;t happen&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|parport_ieee1284_terminate
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Event 53: Set nStrobe high */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Event 55: nAck goes high */
r_if
c_cond
(paren
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_ACK
comma
id|PARPORT_STATUS_ACK
)paren
)paren
(brace
multiline_comment|/* This shouldn&squot;t really happen with a compliant&n;&t;&t;&t; * device. */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Mode 0x%02x not supported? (0x%02x)&bslash;n&quot;
comma
id|port-&gt;name
comma
id|mode
comma
id|port-&gt;ops-&gt;read_status
(paren
id|port
)paren
)paren
suffix:semicolon
id|parport_ieee1284_terminate
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Event 54: Peripheral sets XFlag to reflect support */
id|xflag
op_assign
id|parport_read_status
(paren
id|port
)paren
op_amp
id|PARPORT_STATUS_SELECT
suffix:semicolon
multiline_comment|/* xflag should be high. */
r_if
c_cond
(paren
op_logical_neg
id|xflag
)paren
(brace
multiline_comment|/* Extended mode not supported. */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Extended mode 0x%02x not &quot;
l_string|&quot;supported&bslash;n&quot;
comma
id|port-&gt;name
comma
id|mode
)paren
suffix:semicolon
id|parport_ieee1284_terminate
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Any further setup is left to the caller. */
)brace
multiline_comment|/* Mode is supported */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: In mode 0x%02x&bslash;n&quot;
comma
id|port-&gt;name
comma
id|mode
)paren
suffix:semicolon
id|port-&gt;ieee1284.mode
op_assign
id|mode
suffix:semicolon
multiline_comment|/* But ECP is special */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mode
op_amp
id|IEEE1284_EXT_LINK
)paren
op_logical_and
(paren
id|m
op_amp
id|IEEE1284_MODE_ECP
)paren
)paren
(brace
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_ECP_SETUP
suffix:semicolon
multiline_comment|/* Event 30: Set nAutoFd low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_AUTOFD
)paren
suffix:semicolon
multiline_comment|/* Event 31: PError goes high. */
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
id|PARPORT_STATUS_PAPEROUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|DPRINTK
(paren
id|KERN_INFO
l_string|&quot;%s: Timeout at event 31&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: ECP direction: forward&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|IEEE1284_MODE_NIBBLE
suffix:colon
r_case
id|IEEE1284_MODE_BYTE
suffix:colon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_REV_IDLE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* IEEE1284 support */
)brace
multiline_comment|/* Acknowledge that the peripheral has data available.&n; * Events 18-20, in order to get from Reverse Idle phase&n; * to Host Busy Data Available.&n; * This will most likely be called from an interrupt.&n; * Returns zero if data was available.&n; */
macro_line|#ifdef CONFIG_PARPORT_1284
DECL|function|parport_ieee1284_ack_data_avail
r_static
r_int
id|parport_ieee1284_ack_data_avail
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|parport_read_status
(paren
id|port
)paren
op_amp
id|PARPORT_STATUS_ERROR
)paren
multiline_comment|/* Event 18 didn&squot;t happen. */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Event 20: nAutoFd goes high. */
id|port-&gt;ops-&gt;frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_AUTOFD
comma
l_int|0
)paren
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_HBUSY_DAVAIL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* IEEE1284 support */
multiline_comment|/* Handle an interrupt. */
DECL|function|parport_ieee1284_interrupt
r_void
id|parport_ieee1284_interrupt
(paren
r_int
id|which
comma
r_void
op_star
id|handle
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
id|handle
suffix:semicolon
id|parport_ieee1284_wakeup
(paren
id|port
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_1284
r_if
c_cond
(paren
id|port-&gt;ieee1284.phase
op_eq
id|IEEE1284_PH_REV_IDLE
)paren
(brace
multiline_comment|/* An interrupt in this phase means that data&n;&t;&t; * is now available. */
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Data available&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|parport_ieee1284_ack_data_avail
(paren
id|port
)paren
suffix:semicolon
)brace
macro_line|#endif /* IEEE1284 support */
)brace
multiline_comment|/**&n; *&t;parport_write - write a block of data to a parallel port&n; *&t;@port: port to write to&n; *&t;@buffer: data buffer (in kernel space)&n; *&t;@len: number of bytes of data to transfer&n; *&n; *&t;This will write up to @len bytes of @buffer to the port&n; *&t;specified, using the IEEE 1284 transfer mode most recently&n; *&t;negotiated to (using parport_negotiate()), as long as that&n; *&t;mode supports forward transfers (host to peripheral).&n; *&n; *&t;It is the caller&squot;s responsibility to ensure that the first&n; *&t;@len bytes of @buffer are valid.&n; *&n; *&t;This function returns the number of bytes transferred (if zero&n; *&t;or positive), or else an error code.&n; */
DECL|function|parport_write
id|ssize_t
id|parport_write
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
macro_line|#ifndef CONFIG_PARPORT_1284
r_return
id|port-&gt;ops-&gt;compat_write_data
(paren
id|port
comma
id|buffer
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|ssize_t
id|retval
suffix:semicolon
r_int
id|mode
op_assign
id|port-&gt;ieee1284.mode
suffix:semicolon
r_int
id|addr
op_assign
id|mode
op_amp
id|IEEE1284_ADDR
suffix:semicolon
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_const
r_void
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Ignore the device-ID-request bit and the address bit. */
id|mode
op_and_assign
op_complement
(paren
id|IEEE1284_DEVICEID
op_or
id|IEEE1284_ADDR
)paren
suffix:semicolon
multiline_comment|/* Use the mode we&squot;re in. */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|IEEE1284_MODE_NIBBLE
suffix:colon
id|parport_negotiate
(paren
id|port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
r_case
id|IEEE1284_MODE_COMPAT
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using compatibility mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|fn
op_assign
id|port-&gt;ops-&gt;compat_write_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_EPP
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using EPP mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|port-&gt;ops-&gt;epp_write_addr
suffix:semicolon
r_else
id|fn
op_assign
id|port-&gt;ops-&gt;epp_write_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECP
suffix:colon
r_case
id|IEEE1284_MODE_ECPRLE
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using ECP mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|port-&gt;ops-&gt;ecp_write_addr
suffix:semicolon
r_else
id|fn
op_assign
id|port-&gt;ops-&gt;ecp_write_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECPSWE
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using software-emulated ECP mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
multiline_comment|/* The caller has specified that it must be emulated,&n;&t;&t; * even if we have ECP hardware! */
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|parport_ieee1284_ecp_write_addr
suffix:semicolon
r_else
id|fn
op_assign
id|parport_ieee1284_ecp_write_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Unknown mode 0x%02x&bslash;n&quot;
comma
id|port-&gt;name
comma
id|port-&gt;ieee1284.mode
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|retval
op_assign
(paren
op_star
id|fn
)paren
(paren
id|port
comma
id|buffer
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: wrote %d/%d bytes&bslash;n&quot;
comma
id|port-&gt;name
comma
id|retval
comma
id|len
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
macro_line|#endif /* IEEE1284 support */
)brace
multiline_comment|/**&n; *&t;parport_read - read a block of data from a parallel port&n; *&t;@port: port to read from&n; *&t;@buffer: data buffer (in kernel space)&n; *&t;@len: number of bytes of data to transfer&n; *&n; *&t;This will read up to @len bytes of @buffer to the port&n; *&t;specified, using the IEEE 1284 transfer mode most recently&n; *&t;negotiated to (using parport_negotiate()), as long as that&n; *&t;mode supports reverse transfers (peripheral to host).&n; *&n; *&t;It is the caller&squot;s responsibility to ensure that the first&n; *&t;@len bytes of @buffer are available to write to.&n; *&n; *&t;This function returns the number of bytes transferred (if zero&n; *&t;or positive), or else an error code.&n; */
DECL|function|parport_read
id|ssize_t
id|parport_read
(paren
r_struct
id|parport
op_star
id|port
comma
r_void
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
macro_line|#ifndef CONFIG_PARPORT_1284
id|printk
(paren
id|KERN_ERR
l_string|&quot;parport: IEEE1284 not supported in this kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#else
r_int
id|mode
op_assign
id|port-&gt;physport-&gt;ieee1284.mode
suffix:semicolon
r_int
id|addr
op_assign
id|mode
op_amp
id|IEEE1284_ADDR
suffix:semicolon
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Ignore the device-ID-request bit and the address bit. */
id|mode
op_and_assign
op_complement
(paren
id|IEEE1284_DEVICEID
op_or
id|IEEE1284_ADDR
)paren
suffix:semicolon
multiline_comment|/* Use the mode we&squot;re in. */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|IEEE1284_MODE_COMPAT
suffix:colon
r_if
c_cond
(paren
id|parport_negotiate
(paren
id|port
comma
id|IEEE1284_MODE_NIBBLE
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_case
id|IEEE1284_MODE_NIBBLE
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using nibble mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|fn
op_assign
id|port-&gt;ops-&gt;nibble_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_BYTE
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using byte mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|fn
op_assign
id|port-&gt;ops-&gt;byte_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_EPP
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using EPP mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|port-&gt;ops-&gt;epp_read_addr
suffix:semicolon
r_else
id|fn
op_assign
id|port-&gt;ops-&gt;epp_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECP
suffix:colon
r_case
id|IEEE1284_MODE_ECPRLE
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using ECP mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|fn
op_assign
id|port-&gt;ops-&gt;ecp_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECPSWE
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Using software-emulated ECP mode&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|fn
op_assign
id|parport_ieee1284_ecp_read_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;%s: Unknown mode 0x%02x&bslash;n&quot;
comma
id|port-&gt;name
comma
id|port-&gt;physport-&gt;ieee1284.mode
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_return
(paren
op_star
id|fn
)paren
(paren
id|port
comma
id|buffer
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* IEEE1284 support */
)brace
multiline_comment|/**&n; *&t;parport_set_timeout - set the inactivity timeout for a device&n; *&t;@dev: device on a port&n; *&t;@inactivity: inactivity timeout (in jiffies)&n; *&n; *&t;This sets the inactivity timeout for a particular device on a&n; *&t;port.  This affects functions like parport_wait_peripheral().&n; *&t;The special value 0 means not to call schedule() while dealing&n; *&t;with this device.&n; *&n; *&t;The return value is the previous inactivity timeout.&n; *&n; *&t;Any callers of parport_wait_event() for this device are woken&n; *&t;up.&n; */
DECL|function|parport_set_timeout
r_int
id|parport_set_timeout
(paren
r_struct
id|pardevice
op_star
id|dev
comma
r_int
id|inactivity
)paren
(brace
r_int
r_int
id|old
op_assign
id|dev-&gt;timeout
suffix:semicolon
id|dev-&gt;timeout
op_assign
id|inactivity
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;physport-&gt;cad
op_eq
id|dev
)paren
id|parport_ieee1284_wakeup
(paren
id|dev-&gt;port
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
eof
