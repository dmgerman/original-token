multiline_comment|/*&n; *      Low-level parallel-support for PC-style hardware integrated in the &n; *&t;LASI-Controller (on GSC-Bus) for HP-PARISC Workstations&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *&t;by Helge Deller &lt;deller@gmx.de&gt;&n; *&n; * &n; * based on parport_pc.c by &n; * &t;    Grant Guenther &lt;grant@torque.net&gt;&n; * &t;    Phil Blundell &lt;Philip.Blundell@pobox.com&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *          David Campbell &lt;campbell@torque.net&gt;&n; *          Andrea Arcangeli&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;asm/gsc.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/parport_gsc.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG&t;/* undef for production */
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK  printk
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(stuff...)
macro_line|#endif
multiline_comment|/*&n; * Clear TIMEOUT BIT in EPP MODE&n; *&n; * This is also used in SPP detection.&n; */
DECL|function|clear_epp_timeout
r_static
r_int
id|clear_epp_timeout
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|parport_gsc_read_status
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* To clear timeout some chips require double read */
id|parport_gsc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r
op_assign
id|parport_gsc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_writeb
(paren
id|r
op_or
l_int|0x01
comma
id|STATUS
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Some reset by writing 1 */
id|parport_writeb
(paren
id|r
op_amp
l_int|0xfe
comma
id|STATUS
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Others by writing 0 */
id|r
op_assign
id|parport_gsc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|r
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Access functions.&n; *&n; * Most of these aren&squot;t static because they may be used by the&n; * parport_xxx_yyy macros.  extern __inline__ versions of several&n; * of these are in parport_gsc.h.&n; */
DECL|function|parport_gsc_interrupt
r_static
r_void
id|parport_gsc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|DPRINTK
c_func
(paren
id|__FILE__
l_string|&quot;: got IRQ&bslash;n&quot;
)paren
suffix:semicolon
id|parport_generic_irq
c_func
(paren
id|irq
comma
(paren
r_struct
id|parport
op_star
)paren
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_write_data
r_void
id|parport_gsc_write_data
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|DPRINTK
c_func
(paren
id|__FILE__
l_string|&quot;: write (0x%02x) %c &bslash;n&quot;
comma
id|d
comma
id|d
)paren
suffix:semicolon
id|parport_writeb
(paren
id|d
comma
id|DATA
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_read_data
r_int
r_char
id|parport_gsc_read_data
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
macro_line|#ifdef DEBUG
r_int
r_char
id|c
op_assign
id|parport_readb
(paren
id|DATA
(paren
id|p
)paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
id|__FILE__
l_string|&quot;: read (0x%02x) %c&bslash;n&quot;
comma
id|c
comma
id|c
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
macro_line|#else
r_return
id|parport_readb
(paren
id|DATA
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_gsc_write_control
r_void
id|parport_gsc_write_control
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
r_const
r_int
r_char
id|wm
op_assign
(paren
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
multiline_comment|/* Take this out when drivers have adapted to the newer interface. */
r_if
c_cond
(paren
id|d
op_amp
l_int|0x20
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s (%s): use data_reverse for this!&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;cad-&gt;name
)paren
suffix:semicolon
id|parport_gsc_data_reverse
(paren
id|p
)paren
suffix:semicolon
)brace
id|__parport_gsc_frob_control
(paren
id|p
comma
id|wm
comma
id|d
op_amp
id|wm
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_read_control
r_int
r_char
id|parport_gsc_read_control
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_const
r_int
r_char
id|wm
op_assign
(paren
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
r_const
r_struct
id|parport_gsc_private
op_star
id|priv
op_assign
id|p-&gt;physport-&gt;private_data
suffix:semicolon
r_return
id|priv-&gt;ctr
op_amp
id|wm
suffix:semicolon
multiline_comment|/* Use soft copy */
)brace
DECL|function|parport_gsc_frob_control
r_int
r_char
id|parport_gsc_frob_control
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
(brace
r_const
r_int
r_char
id|wm
op_assign
(paren
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
multiline_comment|/* Take this out when drivers have adapted to the newer interface. */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x20
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s (%s): use data_%s for this!&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;cad-&gt;name
comma
(paren
id|val
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;reverse&quot;
suffix:colon
l_string|&quot;forward&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x20
)paren
id|parport_gsc_data_reverse
(paren
id|p
)paren
suffix:semicolon
r_else
id|parport_gsc_data_forward
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Restrict mask and val to control lines. */
id|mask
op_and_assign
id|wm
suffix:semicolon
id|val
op_and_assign
id|wm
suffix:semicolon
r_return
id|__parport_gsc_frob_control
(paren
id|p
comma
id|mask
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_read_status
r_int
r_char
id|parport_gsc_read_status
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|parport_readb
(paren
id|STATUS
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_disable_irq
r_void
id|parport_gsc_disable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_gsc_frob_control
(paren
id|p
comma
l_int|0x10
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_enable_irq
r_void
id|parport_gsc_enable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_gsc_frob_control
(paren
id|p
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_data_forward
r_void
id|parport_gsc_data_forward
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_gsc_frob_control
(paren
id|p
comma
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_data_reverse
r_void
id|parport_gsc_data_reverse
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_gsc_frob_control
(paren
id|p
comma
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_init_state
r_void
id|parport_gsc_init_state
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
l_int|0xc
op_or
(paren
id|dev-&gt;irq_func
ques
c_cond
l_int|0x10
suffix:colon
l_int|0x0
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_save_state
r_void
id|parport_gsc_save_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
id|parport_readb
(paren
id|CONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_restore_state
r_void
id|parport_gsc_restore_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|parport_writeb
(paren
id|s-&gt;u.pc.ctr
comma
id|CONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_gsc_inc_use_count
r_void
id|parport_gsc_inc_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_gsc_dec_use_count
r_void
id|parport_gsc_dec_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|parport_gsc_ops
r_struct
id|parport_operations
id|parport_gsc_ops
op_assign
(brace
id|write_data
suffix:colon
id|parport_gsc_write_data
comma
id|read_data
suffix:colon
id|parport_gsc_read_data
comma
id|write_control
suffix:colon
id|parport_gsc_write_control
comma
id|read_control
suffix:colon
id|parport_gsc_read_control
comma
id|frob_control
suffix:colon
id|parport_gsc_frob_control
comma
id|read_status
suffix:colon
id|parport_gsc_read_status
comma
id|enable_irq
suffix:colon
id|parport_gsc_enable_irq
comma
id|disable_irq
suffix:colon
id|parport_gsc_disable_irq
comma
id|data_forward
suffix:colon
id|parport_gsc_data_forward
comma
id|data_reverse
suffix:colon
id|parport_gsc_data_reverse
comma
id|init_state
suffix:colon
id|parport_gsc_init_state
comma
id|save_state
suffix:colon
id|parport_gsc_save_state
comma
id|restore_state
suffix:colon
id|parport_gsc_restore_state
comma
id|inc_use_count
suffix:colon
id|parport_gsc_inc_use_count
comma
id|dec_use_count
suffix:colon
id|parport_gsc_dec_use_count
comma
id|epp_write_data
suffix:colon
id|parport_ieee1284_epp_write_data
comma
id|epp_read_data
suffix:colon
id|parport_ieee1284_epp_read_data
comma
id|epp_write_addr
suffix:colon
id|parport_ieee1284_epp_write_addr
comma
id|epp_read_addr
suffix:colon
id|parport_ieee1284_epp_read_addr
comma
id|ecp_write_data
suffix:colon
id|parport_ieee1284_ecp_write_data
comma
id|ecp_read_data
suffix:colon
id|parport_ieee1284_ecp_read_data
comma
id|ecp_write_addr
suffix:colon
id|parport_ieee1284_ecp_write_addr
comma
id|compat_write_data
suffix:colon
id|parport_ieee1284_write_compat
comma
id|nibble_read_data
suffix:colon
id|parport_ieee1284_read_nibble
comma
id|byte_read_data
suffix:colon
id|parport_ieee1284_read_byte
comma
)brace
suffix:semicolon
multiline_comment|/* --- Mode detection ------------------------------------- */
multiline_comment|/*&n; * Checks for port existence, all ports support SPP MODE&n; */
DECL|function|parport_SPP_supported
r_static
r_int
id|__devinit
id|parport_SPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
comma
id|w
suffix:semicolon
multiline_comment|/*&n;&t; * first clear an eventually pending EPP timeout &n;&t; * I (sailer@ife.ee.ethz.ch) have an SMSC chipset&n;&t; * that does not even respond to SPP cycles if an EPP&n;&t; * timeout is pending&n;&t; */
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Do a simple read-write test to make sure the port exists. */
id|w
op_assign
l_int|0xc
suffix:semicolon
id|parport_writeb
(paren
id|w
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Is there a control register that we can read from?  Some&n;&t; * ports don&squot;t allow reads, so read_control just returns a&n;&t; * software copy. Some ports _do_ allow reads, so bypass the&n;&t; * software copy here.  In addition, some bits aren&squot;t&n;&t; * writable. */
id|r
op_assign
id|parport_readb
(paren
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xf
)paren
op_eq
id|w
)paren
(brace
id|w
op_assign
l_int|0xe
suffix:semicolon
id|parport_writeb
(paren
id|w
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|r
op_assign
id|parport_readb
(paren
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|parport_writeb
(paren
l_int|0xc
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xf
)paren
op_eq
id|w
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
)brace
multiline_comment|/* Try the data register.  The data lines aren&squot;t tri-stated at&n;&t; * this stage, so we expect back what we wrote. */
id|w
op_assign
l_int|0xaa
suffix:semicolon
id|parport_gsc_write_data
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|parport_gsc_read_data
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|w
)paren
(brace
id|w
op_assign
l_int|0x55
suffix:semicolon
id|parport_gsc_write_data
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|parport_gsc_read_data
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|w
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Detect PS/2 support.&n; *&n; * Bit 5 (0x20) sets the PS/2 data direction; setting this high&n; * allows us to read data from the data lines.  In theory we would get back&n; * 0xff but any peripheral attached to the port may drag some or all of the&n; * lines down to zero.  So if we get back anything that isn&squot;t the contents&n; * of the data register we deem PS/2 support to be present. &n; *&n; * Some SPP ports have &quot;half PS/2&quot; ability - you can&squot;t turn off the line&n; * drivers, but an external peripheral with sufficiently beefy drivers of&n; * its own can overpower them and assert its own levels onto the bus, from&n; * where they can then be read back as normal.  Ports with this property&n; * and the right type of device attached are likely to fail the SPP test,&n; * (as they will appear to have stuck bits) and so the fact that they might&n; * be misdetected here is rather academic. &n; */
DECL|function|parport_PS2_supported
r_static
r_int
id|__devinit
id|parport_PS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* try to tri-state the buffer */
id|parport_gsc_data_reverse
(paren
id|pb
)paren
suffix:semicolon
id|parport_gsc_write_data
c_func
(paren
id|pb
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_gsc_read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0x55
)paren
id|ok
op_increment
suffix:semicolon
id|parport_gsc_write_data
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_gsc_read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0xaa
)paren
id|ok
op_increment
suffix:semicolon
multiline_comment|/* cancel input mode */
id|parport_gsc_data_forward
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
)paren
(brace
id|pb-&gt;modes
op_or_assign
id|PARPORT_MODE_TRISTATE
suffix:semicolon
)brace
r_else
(brace
r_struct
id|parport_gsc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
id|priv-&gt;ctr_writable
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
)brace
r_return
id|ok
suffix:semicolon
)brace
multiline_comment|/* --- Initialisation code -------------------------------- */
DECL|function|parport_gsc_probe_port
r_struct
id|parport
op_star
id|__devinit
id|parport_gsc_probe_port
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|base_hi
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|parport_gsc_private
op_star
id|priv
suffix:semicolon
r_struct
id|parport_operations
op_star
id|ops
suffix:semicolon
r_struct
id|parport
id|tmp
suffix:semicolon
r_struct
id|parport
op_star
id|p
op_assign
op_amp
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|3
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|parport_gsc_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport (0x%lx): no memory!&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ops
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|parport_operations
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ops
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport (0x%lx): no memory for ops!&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|kfree
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
(paren
id|ops
comma
op_amp
id|parport_gsc_ops
comma
r_sizeof
(paren
r_struct
id|parport_operations
)paren
)paren
suffix:semicolon
id|priv-&gt;ctr
op_assign
l_int|0xc
suffix:semicolon
id|priv-&gt;ctr_writable
op_assign
l_int|0xff
suffix:semicolon
id|priv-&gt;dma_buf
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dma_handle
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dev
op_assign
id|dev
suffix:semicolon
id|p-&gt;base
op_assign
id|base
suffix:semicolon
id|p-&gt;base_hi
op_assign
id|base_hi
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;dma
op_assign
id|dma
suffix:semicolon
id|p-&gt;modes
op_assign
id|PARPORT_MODE_PCSPP
op_or
id|PARPORT_MODE_SAFEININT
suffix:semicolon
id|p-&gt;ops
op_assign
id|ops
suffix:semicolon
id|p-&gt;private_data
op_assign
id|priv
suffix:semicolon
id|p-&gt;physport
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parport_SPP_supported
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* No port. */
id|kfree
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|parport_PS2_supported
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|parport_register_port
c_func
(paren
id|base
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
comma
id|ops
)paren
)paren
)paren
(brace
id|kfree
(paren
id|priv
)paren
suffix:semicolon
id|kfree
(paren
id|ops
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|p-&gt;base_hi
op_assign
id|base_hi
suffix:semicolon
id|p-&gt;modes
op_assign
id|tmp.modes
suffix:semicolon
id|p-&gt;size
op_assign
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_EPP
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|3
suffix:semicolon
id|p-&gt;private_data
op_assign
id|priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: PC-style at 0x%lx&quot;
comma
id|p-&gt;name
comma
id|p-&gt;base
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_eq
id|PARPORT_IRQ_AUTO
)paren
(brace
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, irq %d&quot;
comma
id|p-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_AUTO
)paren
(brace
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_AUTO
)paren
multiline_comment|/* To use DMA, giving the irq&n;                                           is mandatory (see above) */
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [&quot;
)paren
suffix:semicolon
DECL|macro|printmode
mdefine_line|#define printmode(x) {if(p-&gt;modes&amp;PARPORT_MODE_##x){printk(&quot;%s%s&quot;,f?&quot;,&quot;:&quot;&quot;,#x);f++;}}
(brace
r_int
id|f
op_assign
l_int|0
suffix:semicolon
id|printmode
c_func
(paren
id|PCSPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|TRISTATE
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|COMPAT
)paren
id|printmode
c_func
(paren
id|EPP
)paren
suffix:semicolon
singleline_comment|//&t;&t;printmode(ECP);
singleline_comment|//&t;&t;printmode(DMA);
)brace
DECL|macro|printmode
macro_line|#undef printmode
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
id|parport_proc_register
c_func
(paren
id|p
)paren
suffix:semicolon
id|request_region
(paren
id|p-&gt;base
comma
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;size
OG
l_int|3
)paren
id|request_region
(paren
id|p-&gt;base
op_plus
l_int|3
comma
id|p-&gt;size
op_minus
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
id|request_region
(paren
id|p-&gt;base_hi
comma
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
r_if
c_cond
(paren
id|request_irq
(paren
id|p-&gt;irq
comma
id|parport_gsc_interrupt
comma
l_int|0
comma
id|p-&gt;name
comma
id|p
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d in use, &quot;
l_string|&quot;resorting to polled operation&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;irq
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/* Done probing.  Now put the port into a sensible start-up state. */
id|parport_gsc_write_data
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
id|parport_gsc_data_forward
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Now that we&squot;ve told the sharing engine about the port, and&n;&t;   found out its characteristics, let the high-level drivers&n;&t;   know about it. */
id|parport_announce_port
(paren
id|p
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|macro|PARPORT_GSC_OFFSET
mdefine_line|#define PARPORT_GSC_OFFSET 0x800
DECL|variable|parport_count
r_static
r_int
id|__initdata
id|parport_count
suffix:semicolon
r_static
r_int
id|__init
DECL|function|parport_init_chip
id|parport_init_chip
c_func
(paren
r_struct
id|hp_device
op_star
id|d
comma
r_struct
id|pa_iodc_driver
op_star
id|dri
)paren
(brace
r_int
r_int
id|port
suffix:semicolon
r_int
id|irq
suffix:semicolon
id|irq
op_assign
id|busdevice_alloc_irq
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ not found for parallel device at 0x%p&bslash;n&quot;
comma
id|d-&gt;hpa
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|port
op_assign
(paren
(paren
r_int
r_int
)paren
id|d-&gt;hpa
)paren
op_plus
id|PARPORT_GSC_OFFSET
suffix:semicolon
multiline_comment|/* &n;&t;    some older machines with ASP-chip don&squot;t support the enhanced parport modes &n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|pdc_add_valid
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|port
op_plus
l_int|4
)paren
)paren
)paren
(brace
multiline_comment|/* Initialize bidirectional-mode (0x10) &amp; data-tranfer-mode #1 (0x20) */
id|printk
c_func
(paren
l_string|&quot;%s: initialize bidirectional-mode.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|parport_writeb
(paren
(paren
l_int|0x10
op_plus
l_int|0x20
)paren
comma
id|port
op_plus
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: enhanced parport-modes not supported.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parport_gsc_probe_port
c_func
(paren
id|port
comma
l_int|0
comma
id|irq
comma
multiline_comment|/* PARPORT_IRQ_NONE */
id|PARPORT_DMA_NONE
comma
l_int|NULL
)paren
)paren
id|parport_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__initdata
r_static
r_struct
id|pa_iodc_driver
id|parport_drivers_for
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|HPHW_FIO
comma
l_int|0x0
comma
l_int|0x0
comma
l_int|0x74
comma
l_int|0x0
comma
l_int|0
comma
multiline_comment|/* 715/64 */
id|DRIVER_CHECK_SVERSION
op_plus
id|DRIVER_CHECK_HWTYPE
comma
l_string|&quot;parallel device&quot;
comma
l_string|&quot;HP 7xx - Series&quot;
comma
(paren
r_void
op_star
)paren
id|parport_init_chip
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
r_int
id|__init
DECL|function|parport_gsc_init
id|parport_gsc_init
(paren
r_void
)paren
(brace
id|parport_count
op_assign
l_int|0
suffix:semicolon
id|register_driver
c_func
(paren
id|parport_drivers_for
)paren
suffix:semicolon
r_return
id|parport_count
suffix:semicolon
)brace
multiline_comment|/* Exported symbols. */
id|EXPORT_NO_SYMBOLS
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Helge Deller &lt;deller@gmx.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;HP-PARISC PC-style parallel port driver&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;integrated PC-style parallel port&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
op_logical_neg
id|parport_gsc_init
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|parport
op_star
id|p
op_assign
id|parport_enumerate
c_func
(paren
)paren
comma
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|tmp
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCSPP
)paren
(brace
r_struct
id|parport_gsc_private
op_star
id|priv
op_assign
id|p-&gt;private_data
suffix:semicolon
r_struct
id|parport_operations
op_star
id|ops
op_assign
id|p-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|free_dma
c_func
(paren
id|p-&gt;dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|free_irq
c_func
(paren
id|p-&gt;irq
comma
id|p
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|p-&gt;base
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;size
OG
l_int|3
)paren
id|release_region
c_func
(paren
id|p-&gt;base
op_plus
l_int|3
comma
id|p-&gt;size
op_minus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
id|release_region
c_func
(paren
id|p-&gt;base_hi
comma
l_int|3
)paren
suffix:semicolon
id|parport_proc_unregister
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;dma_buf
)paren
id|pci_free_consistent
c_func
(paren
id|priv-&gt;dev
comma
id|PAGE_SIZE
comma
id|priv-&gt;dma_buf
comma
id|priv-&gt;dma_handle
)paren
suffix:semicolon
id|kfree
(paren
id|p-&gt;private_data
)paren
suffix:semicolon
id|parport_unregister_port
c_func
(paren
id|p
)paren
suffix:semicolon
id|kfree
(paren
id|ops
)paren
suffix:semicolon
multiline_comment|/* hope no-one cached it */
)brace
id|p
op_assign
id|tmp
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
