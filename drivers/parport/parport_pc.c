multiline_comment|/* Low-level parallel-port routines for 8255-based PC-style hardware.&n; * &n; * Authors: Phil Blundell &lt;Philip.Blundell@pobox.com&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *          David Campbell &lt;campbell@torque.net&gt;&n; *          Andrea Arcangeli&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt; and Phil Blundell.&n; *&n; * Cleaned up include files - Russell King &lt;linux@arm.uk.linux.org&gt;&n; * DMA support - Bert De Jonghe &lt;bert@sophis.be&gt;&n; * Many ECP bugs fixed.  Fred Barnes &amp; Jamie Lokier, 1999&n; */
multiline_comment|/* This driver should work with any hardware that is broadly compatible&n; * with that in the IBM PC.  This applies to the majority of integrated&n; * I/O chipsets that are commonly available.  The expected register&n; * layout is:&n; *&n; *&t;base+0&t;&t;data&n; *&t;base+1&t;&t;status&n; *&t;base+2&t;&t;control&n; *&n; * In addition, there are some optional registers:&n; *&n; *&t;base+3&t;&t;EPP address&n; *&t;base+4&t;&t;EPP data&n; *&t;base+0x400&t;ECP config A&n; *&t;base+0x401&t;ECP config B&n; *&t;base+0x402&t;ECP control&n; *&n; * All registers are 8 bits wide and read/write.  If your hardware differs&n; * only in register addresses (eg because your registers are on 32-bit&n; * word boundaries) then you can alter the constants in parport_pc.h to&n; * accomodate this.&n; *&n; * Note that the ECP registers may not start at offset 0x400 for PCI cards,&n; * but rather will start at port-&gt;base_hi.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/parport_pc.h&gt;
macro_line|#include &lt;asm/parport.h&gt;
DECL|macro|PARPORT_PC_MAX_PORTS
mdefine_line|#define PARPORT_PC_MAX_PORTS PARPORT_MAX
multiline_comment|/* ECR modes */
DECL|macro|ECR_SPP
mdefine_line|#define ECR_SPP 00
DECL|macro|ECR_PS2
mdefine_line|#define ECR_PS2 01
DECL|macro|ECR_PPF
mdefine_line|#define ECR_PPF 02
DECL|macro|ECR_ECP
mdefine_line|#define ECR_ECP 03
DECL|macro|ECR_EPP
mdefine_line|#define ECR_EPP 04
DECL|macro|ECR_VND
mdefine_line|#define ECR_VND 05
DECL|macro|ECR_TST
mdefine_line|#define ECR_TST 06
DECL|macro|ECR_CNF
mdefine_line|#define ECR_CNF 07
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK  printk
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(stuff...)
macro_line|#endif
DECL|macro|NR_SUPERIOS
mdefine_line|#define NR_SUPERIOS 3
DECL|struct|superio_struct
r_static
r_struct
id|superio_struct
(brace
multiline_comment|/* For Super-IO chips autodetection */
DECL|member|io
r_int
id|io
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|variable|__devinitdata
)brace
id|superios
(braket
id|NR_SUPERIOS
)braket
id|__devinitdata
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_int
id|user_specified
id|__devinitdata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* frob_control, but for ECR */
DECL|function|frob_econtrol
r_static
r_void
id|frob_econtrol
(paren
r_struct
id|parport
op_star
id|pb
comma
r_int
r_char
id|m
comma
r_int
r_char
id|v
)paren
(brace
r_int
r_char
id|ectr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|DPRINTK
(paren
id|KERN_DEBUG
l_string|&quot;frob_econtrol(%02x,%02x): %02x -&gt; %02x&bslash;n&quot;
comma
id|m
comma
id|v
comma
id|ectr
comma
(paren
id|ectr
op_amp
op_complement
id|m
)paren
op_xor
id|v
)paren
suffix:semicolon
id|outb
(paren
(paren
id|ectr
op_amp
op_complement
id|m
)paren
op_xor
id|v
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_PC_FIFO
multiline_comment|/* Safely change the mode bits in the ECR &n;   Returns:&n;&t;    0    : Success&n;&t;   -EBUSY: Could not drain FIFO in some finite amount of time,&n;&t;&t;   mode not changed!&n; */
DECL|function|change_mode
r_static
r_int
id|change_mode
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
id|m
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;physport-&gt;private_data
suffix:semicolon
r_int
id|ecr
op_assign
id|ECONTROL
c_func
(paren
id|p
)paren
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_int
id|mode
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;parport change_mode ECP-ISA to mode 0x%02x&bslash;n&quot;
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ecr
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;change_mode: but there&squot;s no ECR!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Bits &lt;7:5&gt; contain the mode. */
id|oecr
op_assign
id|inb
(paren
id|ecr
)paren
suffix:semicolon
id|mode
op_assign
(paren
id|oecr
op_rshift
l_int|5
)paren
op_amp
l_int|0x7
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|m
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_ge
l_int|2
op_logical_and
op_logical_neg
(paren
id|priv-&gt;ctr
op_amp
l_int|0x20
)paren
)paren
(brace
multiline_comment|/* This mode resets the FIFO, so we may&n;&t;&t; * have to wait for it to drain first. */
r_int
id|expire
op_assign
id|jiffies
op_plus
id|p-&gt;physport-&gt;cad-&gt;timeout
suffix:semicolon
r_int
id|counter
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|ECR_PPF
suffix:colon
multiline_comment|/* Parallel Port FIFO mode */
r_case
id|ECR_ECP
suffix:colon
multiline_comment|/* ECP Parallel Port mode */
multiline_comment|/* Busy wait for 200us */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|40
suffix:semicolon
id|counter
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|p
)paren
)paren
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/* Poll slowly. */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
(paren
id|ECONTROL
(paren
id|p
)paren
)paren
op_amp
l_int|0x01
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_after_eq
(paren
id|jiffies
comma
id|expire
)paren
)paren
multiline_comment|/* The FIFO is stuck. */
r_return
op_minus
id|EBUSY
suffix:semicolon
id|__set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|mode
op_ge
l_int|2
op_logical_and
id|m
op_ge
l_int|2
)paren
(brace
multiline_comment|/* We have to go through mode 001 */
id|oecr
op_and_assign
op_complement
(paren
l_int|7
op_lshift
l_int|5
)paren
suffix:semicolon
id|oecr
op_or_assign
id|ECR_PS2
op_lshift
l_int|5
suffix:semicolon
id|outb
(paren
id|oecr
comma
id|ecr
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the mode. */
id|oecr
op_and_assign
op_complement
(paren
l_int|7
op_lshift
l_int|5
)paren
suffix:semicolon
id|oecr
op_or_assign
id|m
op_lshift
l_int|5
suffix:semicolon
id|outb
(paren
id|oecr
comma
id|ecr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* Find FIFO lossage; FIFO is reset */
DECL|function|get_fifo_residue
r_static
r_int
id|get_fifo_residue
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_int
id|residue
suffix:semicolon
r_int
id|cnfga
suffix:semicolon
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;physport-&gt;private_data
suffix:semicolon
multiline_comment|/* Adjust for the contents of the FIFO. */
r_for
c_loop
(paren
id|residue
op_assign
id|priv-&gt;fifo_depth
suffix:semicolon
suffix:semicolon
id|residue
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|p
)paren
)paren
op_amp
l_int|0x2
)paren
multiline_comment|/* Full up. */
r_break
suffix:semicolon
id|outb
(paren
l_int|0
comma
id|FIFO
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: %d PWords were left in FIFO&bslash;n&quot;
comma
id|p-&gt;name
comma
id|residue
)paren
suffix:semicolon
multiline_comment|/* Reset the FIFO. */
id|frob_econtrol
(paren
id|p
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Now change to config mode and clean up. FIXME */
id|frob_econtrol
(paren
id|p
comma
l_int|0xe0
comma
id|ECR_CNF
op_lshift
l_int|5
)paren
suffix:semicolon
id|cnfga
op_assign
id|inb
(paren
id|CONFIGA
(paren
id|p
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: cnfgA contains 0x%02x&bslash;n&quot;
comma
id|p-&gt;name
comma
id|cnfga
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cnfga
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: Accounting for extra byte&bslash;n&quot;
comma
id|p-&gt;name
)paren
suffix:semicolon
id|residue
op_increment
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t care about partial PWords until support is added for&n;&t; * PWord != 1 byte. */
multiline_comment|/* Back to PS2 mode. */
id|frob_econtrol
(paren
id|p
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|residue
suffix:semicolon
)brace
macro_line|#endif /* IEEE 1284 support */
macro_line|#endif /* FIFO support */
multiline_comment|/*&n; * Clear TIMEOUT BIT in EPP MODE&n; *&n; * This is also used in SPP detection.&n; */
DECL|function|clear_epp_timeout
r_static
r_int
id|clear_epp_timeout
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* To clear timeout some chips require double read */
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|outb
(paren
id|r
op_or
l_int|0x01
comma
id|STATUS
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Some reset by writing 1 */
id|outb
(paren
id|r
op_amp
l_int|0xfe
comma
id|STATUS
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Others by writing 0 */
id|r
op_assign
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|r
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Access functions.&n; *&n; * Most of these aren&squot;t static because they may be used by the&n; * parport_xxx_yyy macros.  extern __inline__ versions of several&n; * of these are in parport_pc.h.&n; */
DECL|function|parport_pc_interrupt
r_static
r_void
id|parport_pc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|parport_generic_irq
c_func
(paren
id|irq
comma
(paren
r_struct
id|parport
op_star
)paren
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_data
r_void
id|parport_pc_write_data
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
(paren
id|d
comma
id|DATA
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_data
r_int
r_char
id|parport_pc_read_data
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
(paren
id|DATA
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_control
r_void
id|parport_pc_write_control
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
r_const
r_int
r_char
id|wm
op_assign
(paren
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
multiline_comment|/* Take this out when drivers have adapted to the newer interface. */
r_if
c_cond
(paren
id|d
op_amp
l_int|0x20
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s (%s): use data_reverse for this!&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;cad-&gt;name
)paren
suffix:semicolon
id|parport_pc_data_reverse
(paren
id|p
)paren
suffix:semicolon
)brace
id|__parport_pc_frob_control
(paren
id|p
comma
id|wm
comma
id|d
op_amp
id|wm
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_control
r_int
r_char
id|parport_pc_read_control
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_const
r_int
r_char
id|wm
op_assign
(paren
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;physport-&gt;private_data
suffix:semicolon
r_return
id|priv-&gt;ctr
op_amp
id|wm
suffix:semicolon
multiline_comment|/* Use soft copy */
)brace
DECL|function|parport_pc_frob_control
r_int
r_char
id|parport_pc_frob_control
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
(brace
r_const
r_int
r_char
id|wm
op_assign
(paren
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
op_or
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
multiline_comment|/* Take this out when drivers have adapted to the newer interface. */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x20
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s (%s): use data_%s for this!&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;cad-&gt;name
comma
(paren
id|val
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;reverse&quot;
suffix:colon
l_string|&quot;forward&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x20
)paren
id|parport_pc_data_reverse
(paren
id|p
)paren
suffix:semicolon
r_else
id|parport_pc_data_forward
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Restrict mask and val to control lines. */
id|mask
op_and_assign
id|wm
suffix:semicolon
id|val
op_and_assign
id|wm
suffix:semicolon
r_return
id|__parport_pc_frob_control
(paren
id|p
comma
id|mask
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_status
r_int
r_char
id|parport_pc_read_status
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
(paren
id|STATUS
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_disable_irq
r_void
id|parport_pc_disable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_pc_frob_control
(paren
id|p
comma
l_int|0x10
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_enable_irq
r_void
id|parport_pc_enable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_pc_frob_control
(paren
id|p
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_data_forward
r_void
id|parport_pc_data_forward
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_pc_frob_control
(paren
id|p
comma
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_data_reverse
r_void
id|parport_pc_data_reverse
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|__parport_pc_frob_control
(paren
id|p
comma
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_init_state
r_void
id|parport_pc_init_state
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
l_int|0xc
op_or
(paren
id|dev-&gt;irq_func
ques
c_cond
l_int|0x10
suffix:colon
l_int|0x0
)paren
suffix:semicolon
id|s-&gt;u.pc.ecr
op_assign
l_int|0x24
suffix:semicolon
)brace
DECL|function|parport_pc_save_state
r_void
id|parport_pc_save_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;physport-&gt;private_data
suffix:semicolon
id|s-&gt;u.pc.ctr
op_assign
id|inb
(paren
id|CONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
id|s-&gt;u.pc.ecr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_restore_state
r_void
id|parport_pc_restore_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;physport-&gt;private_data
suffix:semicolon
id|outb
(paren
id|s-&gt;u.pc.ctr
comma
id|CONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
id|outb
(paren
id|s-&gt;u.pc.ecr
comma
id|ECONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_1284
DECL|function|parport_pc_epp_read_data
r_static
r_int
id|parport_pc_epp_read_data
(paren
r_struct
id|parport
op_star
id|port
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|got
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|got
OL
id|length
suffix:semicolon
id|got
op_increment
)paren
(brace
op_star
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_increment
op_assign
id|inb
(paren
id|EPPDATA
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|STATUS
c_func
(paren
id|port
)paren
)paren
op_amp
l_int|0x01
)paren
(brace
id|clear_epp_timeout
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|got
suffix:semicolon
)brace
DECL|function|parport_pc_epp_write_data
r_static
r_int
id|parport_pc_epp_write_data
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|written
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|written
OL
id|length
suffix:semicolon
id|written
op_increment
)paren
(brace
id|outb
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_increment
comma
id|EPPDATA
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|STATUS
c_func
(paren
id|port
)paren
)paren
op_amp
l_int|0x01
)paren
(brace
id|clear_epp_timeout
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|written
suffix:semicolon
)brace
DECL|function|parport_pc_epp_read_addr
r_static
r_int
id|parport_pc_epp_read_addr
(paren
r_struct
id|parport
op_star
id|port
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|got
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|got
OL
id|length
suffix:semicolon
id|got
op_increment
)paren
(brace
op_star
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_increment
op_assign
id|inb
(paren
id|EPPADDR
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|STATUS
(paren
id|port
)paren
)paren
op_amp
l_int|0x01
)paren
(brace
id|clear_epp_timeout
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|got
suffix:semicolon
)brace
DECL|function|parport_pc_epp_write_addr
r_static
r_int
id|parport_pc_epp_write_addr
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|written
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|written
OL
id|length
suffix:semicolon
id|written
op_increment
)paren
(brace
id|outb
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_increment
comma
id|EPPADDR
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|STATUS
(paren
id|port
)paren
)paren
op_amp
l_int|0x01
)paren
(brace
id|clear_epp_timeout
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|written
suffix:semicolon
)brace
DECL|function|parport_pc_ecpepp_read_data
r_static
r_int
id|parport_pc_ecpepp_read_data
(paren
r_struct
id|parport
op_star
id|port
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|got
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_EPP
op_lshift
l_int|5
)paren
suffix:semicolon
id|parport_pc_data_reverse
(paren
id|port
)paren
suffix:semicolon
id|parport_pc_write_control
(paren
id|port
comma
l_int|0x4
)paren
suffix:semicolon
id|got
op_assign
id|parport_pc_epp_read_data
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|got
suffix:semicolon
)brace
DECL|function|parport_pc_ecpepp_write_data
r_static
r_int
id|parport_pc_ecpepp_write_data
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|written
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_EPP
op_lshift
l_int|5
)paren
suffix:semicolon
id|parport_pc_write_control
(paren
id|port
comma
l_int|0x4
)paren
suffix:semicolon
id|parport_pc_data_forward
(paren
id|port
)paren
suffix:semicolon
id|written
op_assign
id|parport_pc_epp_write_data
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
DECL|function|parport_pc_ecpepp_read_addr
r_static
r_int
id|parport_pc_ecpepp_read_addr
(paren
r_struct
id|parport
op_star
id|port
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|got
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_EPP
op_lshift
l_int|5
)paren
suffix:semicolon
id|parport_pc_data_reverse
(paren
id|port
)paren
suffix:semicolon
id|parport_pc_write_control
(paren
id|port
comma
l_int|0x4
)paren
suffix:semicolon
id|got
op_assign
id|parport_pc_epp_read_addr
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|got
suffix:semicolon
)brace
DECL|function|parport_pc_ecpepp_write_addr
r_static
r_int
id|parport_pc_ecpepp_write_addr
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|written
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_EPP
op_lshift
l_int|5
)paren
suffix:semicolon
id|parport_pc_write_control
(paren
id|port
comma
l_int|0x4
)paren
suffix:semicolon
id|parport_pc_data_forward
(paren
id|port
)paren
suffix:semicolon
id|written
op_assign
id|parport_pc_epp_write_addr
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
macro_line|#endif /* IEEE 1284 support */
macro_line|#ifdef CONFIG_PARPORT_PC_FIFO
DECL|function|parport_pc_fifo_write_block_pio
r_static
r_int
id|parport_pc_fifo_write_block_pio
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_const
r_int
r_char
op_star
id|bufp
op_assign
id|buf
suffix:semicolon
r_int
id|left
op_assign
id|length
suffix:semicolon
r_int
id|expire
op_assign
id|jiffies
op_plus
id|port-&gt;physport-&gt;cad-&gt;timeout
suffix:semicolon
r_const
r_int
id|fifo
op_assign
id|FIFO
(paren
id|port
)paren
suffix:semicolon
r_int
id|poll_for
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 80 usecs */
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|port-&gt;physport-&gt;private_data
suffix:semicolon
r_const
r_int
id|fifo_depth
op_assign
id|priv-&gt;fifo_depth
suffix:semicolon
id|port
op_assign
id|port-&gt;physport
suffix:semicolon
multiline_comment|/* We don&squot;t want to be interrupted every character. */
id|parport_pc_disable_irq
(paren
id|port
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* nErrIntrEn */
multiline_comment|/* Forward mode. */
id|parport_pc_data_forward
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
r_while
c_loop
(paren
id|left
)paren
(brace
r_int
r_char
id|byte
suffix:semicolon
r_int
r_char
id|ecrval
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
op_logical_and
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
multiline_comment|/* Can&squot;t yield the port. */
id|schedule
(paren
)paren
suffix:semicolon
multiline_comment|/* Anyone else waiting for the port? */
r_if
c_cond
(paren
id|port-&gt;waithead
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Somebody wants the port&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecrval
op_amp
l_int|0x02
)paren
(brace
multiline_comment|/* FIFO is full. Wait for interrupt. */
multiline_comment|/* Clear serviceIntr */
id|outb
(paren
id|ecrval
op_amp
op_complement
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
id|false_alarm
suffix:colon
id|ret
op_assign
id|parport_wait_event
(paren
id|port
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
(brace
multiline_comment|/* Timed out. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;FIFO write timed out&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ecrval
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ecrval
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;need_resched
op_logical_and
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
id|schedule
(paren
)paren
suffix:semicolon
r_goto
id|false_alarm
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Can&squot;t fail now. */
id|expire
op_assign
id|jiffies
op_plus
id|port-&gt;cad-&gt;timeout
suffix:semicolon
id|poll
suffix:colon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ecrval
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* FIFO is empty. Blast it full. */
r_const
r_int
id|n
op_assign
id|left
OL
id|fifo_depth
ques
c_cond
id|left
suffix:colon
id|fifo_depth
suffix:semicolon
id|outsb
(paren
id|fifo
comma
id|bufp
comma
id|n
)paren
suffix:semicolon
id|bufp
op_add_assign
id|n
suffix:semicolon
id|left
op_sub_assign
id|n
suffix:semicolon
multiline_comment|/* Adjust the poll time. */
r_if
c_cond
(paren
id|i
OL
(paren
id|poll_for
op_minus
l_int|2
)paren
)paren
id|poll_for
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_increment
OL
id|poll_for
)paren
(brace
id|udelay
(paren
l_int|10
)paren
suffix:semicolon
id|ecrval
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
r_goto
id|poll
suffix:semicolon
)brace
multiline_comment|/* Half-full (call me an optimist) */
id|byte
op_assign
op_star
id|bufp
op_increment
suffix:semicolon
id|outb
(paren
id|byte
comma
id|fifo
)paren
suffix:semicolon
id|left
op_decrement
suffix:semicolon
)brace
r_return
id|length
op_minus
id|left
suffix:semicolon
)brace
DECL|function|parport_pc_fifo_write_block_dma
r_static
r_int
id|parport_pc_fifo_write_block_dma
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|dmaflag
suffix:semicolon
r_int
id|left
op_assign
id|length
suffix:semicolon
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|port-&gt;physport-&gt;private_data
suffix:semicolon
id|dma_addr_t
id|dma_addr
comma
id|dma_handle
suffix:semicolon
r_int
id|maxlen
op_assign
l_int|0x10000
suffix:semicolon
multiline_comment|/* max 64k per DMA transfer */
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|buf
suffix:semicolon
r_int
r_int
id|end
op_assign
(paren
r_int
r_int
)paren
id|buf
op_plus
id|length
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|MAX_DMA_ADDRESS
)paren
(brace
multiline_comment|/* If it would cross a 64k boundary, cap it at the end. */
r_if
c_cond
(paren
(paren
id|start
op_xor
id|end
)paren
op_amp
op_complement
l_int|0xffffUL
)paren
id|maxlen
op_assign
l_int|0x10000
op_minus
(paren
id|start
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|dma_addr
op_assign
id|dma_handle
op_assign
id|pci_map_single
c_func
(paren
id|priv-&gt;dev
comma
(paren
r_void
op_star
)paren
id|buf
comma
id|length
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* above 16 MB we use a bounce buffer as ISA-DMA is not possible */
id|maxlen
op_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* sizeof(priv-&gt;dma_buf) */
id|dma_addr
op_assign
id|priv-&gt;dma_handle
suffix:semicolon
id|dma_handle
op_assign
l_int|0
suffix:semicolon
)brace
id|port
op_assign
id|port-&gt;physport
suffix:semicolon
multiline_comment|/* We don&squot;t want to be interrupted every character. */
id|parport_pc_disable_irq
(paren
id|port
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|port
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* nErrIntrEn */
multiline_comment|/* Forward mode. */
id|parport_pc_data_forward
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
r_while
c_loop
(paren
id|left
)paren
(brace
r_int
id|expire
op_assign
id|jiffies
op_plus
id|port-&gt;physport-&gt;cad-&gt;timeout
suffix:semicolon
r_int
id|count
op_assign
id|left
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|maxlen
)paren
id|count
op_assign
id|maxlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_handle
)paren
multiline_comment|/* bounce buffer ! */
id|memcpy
c_func
(paren
id|priv-&gt;dma_buf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|dmaflag
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|port-&gt;dma
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|port-&gt;dma
comma
id|dma_addr
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|port-&gt;dma
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Set DMA mode */
id|frob_econtrol
(paren
id|port
comma
l_int|1
op_lshift
l_int|3
comma
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Clear serviceIntr */
id|frob_econtrol
(paren
id|port
comma
l_int|1
op_lshift
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|dmaflag
)paren
suffix:semicolon
multiline_comment|/* assume DMA will be successful */
id|left
op_sub_assign
id|count
suffix:semicolon
id|buf
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dma_handle
)paren
id|dma_addr
op_add_assign
id|count
suffix:semicolon
multiline_comment|/* Wait for interrupt. */
id|false_alarm
suffix:colon
id|ret
op_assign
id|parport_wait_event
(paren
id|port
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
(brace
multiline_comment|/* Timed out. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;DMA write timed out&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Is serviceIntr set? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
(paren
)paren
suffix:semicolon
r_goto
id|false_alarm
suffix:semicolon
)brace
id|dmaflag
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|count
op_assign
id|get_dma_residue
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|dmaflag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
multiline_comment|/* Can&squot;t yield the port. */
id|schedule
(paren
)paren
suffix:semicolon
multiline_comment|/* Anyone else waiting for the port? */
r_if
c_cond
(paren
id|port-&gt;waithead
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Somebody wants the port&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* update for possible DMA residue ! */
id|buf
op_sub_assign
id|count
suffix:semicolon
id|left
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dma_handle
)paren
id|dma_addr
op_sub_assign
id|count
suffix:semicolon
)brace
multiline_comment|/* Maybe got here through break, so adjust for DMA residue! */
id|dmaflag
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|left
op_add_assign
id|get_dma_residue
c_func
(paren
id|port-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|dmaflag
)paren
suffix:semicolon
multiline_comment|/* Turn off DMA mode */
id|frob_econtrol
(paren
id|port
comma
l_int|1
op_lshift
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_handle
)paren
id|pci_unmap_single
c_func
(paren
id|priv-&gt;dev
comma
id|dma_handle
comma
id|length
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_return
id|length
op_minus
id|left
suffix:semicolon
)brace
multiline_comment|/* Parallel Port FIFO mode (ECP chipsets) */
DECL|function|parport_pc_compat_write_block_pio
r_int
id|parport_pc_compat_write_block_pio
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|written
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/* Special case: a timeout of zero means we cannot call schedule(). */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;physport-&gt;cad-&gt;timeout
)paren
r_return
id|parport_ieee1284_write_compat
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set up parallel port FIFO mode.*/
id|parport_pc_data_forward
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
id|parport_pc_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|change_mode
(paren
id|port
comma
id|ECR_PPF
)paren
suffix:semicolon
multiline_comment|/* Parallel port FIFO */
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: Warning change_mode ECR_PPF failed&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|port-&gt;physport-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_DATA
suffix:semicolon
multiline_comment|/* Write the data to the FIFO. */
r_if
c_cond
(paren
id|port-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|written
op_assign
id|parport_pc_fifo_write_block_dma
(paren
id|port
comma
id|buf
comma
id|length
)paren
suffix:semicolon
r_else
id|written
op_assign
id|parport_pc_fifo_write_block_pio
(paren
id|port
comma
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Finish up. */
r_if
c_cond
(paren
id|change_mode
(paren
id|port
comma
id|ECR_PS2
)paren
op_eq
op_minus
id|EBUSY
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|port-&gt;physport-&gt;private_data
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: FIFO is stuck&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Prevent further data transfer. */
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_TST
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Adjust for the contents of the FIFO. */
r_for
c_loop
(paren
id|written
op_sub_assign
id|priv-&gt;fifo_depth
suffix:semicolon
suffix:semicolon
id|written
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
op_amp
l_int|0x2
)paren
multiline_comment|/* Full up. */
r_break
suffix:semicolon
id|outb
(paren
l_int|0
comma
id|FIFO
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the FIFO and return to PS2 mode. */
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
)brace
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_BUSY
comma
id|PARPORT_STATUS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: BUSY timeout (%d) in compat_write_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
id|port-&gt;physport-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
multiline_comment|/* ECP */
macro_line|#ifdef CONFIG_PARPORT_1284
DECL|function|parport_pc_ecp_write_block_pio
r_int
id|parport_pc_ecp_write_block_pio
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|written
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/* Special case: a timeout of zero means we cannot call schedule(). */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;physport-&gt;cad-&gt;timeout
)paren
r_return
id|parport_ieee1284_ecp_write_data
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Switch to forward mode if necessary. */
r_if
c_cond
(paren
id|port-&gt;physport-&gt;ieee1284.phase
op_ne
id|IEEE1284_PH_FWD_IDLE
)paren
(brace
multiline_comment|/* Event 47: Set nInit high. */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_INIT
op_or
id|PARPORT_CONTROL_AUTOFD
)paren
suffix:semicolon
multiline_comment|/* Event 49: PError goes high. */
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
id|PARPORT_STATUS_PAPEROUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: PError timeout (%d) &quot;
l_string|&quot;in ecp_write_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up ECP parallel port mode.*/
id|parport_pc_data_forward
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
id|parport_pc_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|change_mode
(paren
id|port
comma
id|ECR_ECP
)paren
suffix:semicolon
multiline_comment|/* ECP FIFO */
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: Warning change_mode ECR_ECP failed&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|port-&gt;physport-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_DATA
suffix:semicolon
multiline_comment|/* Write the data to the FIFO. */
r_if
c_cond
(paren
id|port-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|written
op_assign
id|parport_pc_fifo_write_block_dma
(paren
id|port
comma
id|buf
comma
id|length
)paren
suffix:semicolon
r_else
id|written
op_assign
id|parport_pc_fifo_write_block_pio
(paren
id|port
comma
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Finish up. */
r_if
c_cond
(paren
id|change_mode
(paren
id|port
comma
id|ECR_PS2
)paren
op_eq
op_minus
id|EBUSY
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|port-&gt;physport-&gt;private_data
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: FIFO is stuck&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Prevent further data transfer. */
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_TST
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Adjust for the contents of the FIFO. */
r_for
c_loop
(paren
id|written
op_sub_assign
id|priv-&gt;fifo_depth
suffix:semicolon
suffix:semicolon
id|written
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
op_amp
l_int|0x2
)paren
multiline_comment|/* Full up. */
r_break
suffix:semicolon
id|outb
(paren
l_int|0
comma
id|FIFO
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the FIFO and return to PS2 mode. */
id|frob_econtrol
(paren
id|port
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Host transfer recovery. */
id|parport_pc_data_reverse
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: PE,1 timeout (%d) &quot;
l_string|&quot;in ecp_write_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
comma
id|PARPORT_CONTROL_INIT
)paren
suffix:semicolon
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
id|PARPORT_STATUS_PAPEROUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: PE,2 timeout (%d) &quot;
l_string|&quot;in ecp_write_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
)brace
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_BUSY
comma
id|PARPORT_STATUS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: BUSY timeout (%d) in ecp_write_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
)brace
id|port-&gt;physport-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
DECL|function|parport_pc_ecp_read_block_pio
r_int
id|parport_pc_ecp_read_block_pio
(paren
r_struct
id|parport
op_star
id|port
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_int
id|flags
)paren
(brace
r_int
id|left
op_assign
id|length
suffix:semicolon
r_int
id|fifofull
suffix:semicolon
r_int
id|r
suffix:semicolon
r_const
r_int
id|fifo
op_assign
id|FIFO
c_func
(paren
id|port
)paren
suffix:semicolon
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|port-&gt;physport-&gt;private_data
suffix:semicolon
r_const
r_int
id|fifo_depth
op_assign
id|priv-&gt;fifo_depth
suffix:semicolon
r_char
op_star
id|bufp
op_assign
id|buf
suffix:semicolon
id|port
op_assign
id|port-&gt;physport
suffix:semicolon
multiline_comment|/* Special case: a timeout of zero means we cannot call schedule(). */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;cad-&gt;timeout
)paren
r_return
id|parport_ieee1284_ecp_read_data
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
id|fifofull
op_assign
id|fifo_depth
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ieee1284.mode
op_eq
id|IEEE1284_MODE_ECPRLE
)paren
multiline_comment|/* If the peripheral is allowed to send RLE compressed&n;&t;&t; * data, it is possible for a byte to expand to 128&n;&t;&t; * bytes in the FIFO. */
id|fifofull
op_assign
l_int|128
suffix:semicolon
multiline_comment|/* If the caller wants less than a full FIFO&squot;s worth of data,&n;&t; * go through software emulation.  Otherwise we may have to through&n;&t; * away data. */
r_if
c_cond
(paren
id|length
OL
id|fifofull
)paren
r_return
id|parport_ieee1284_ecp_read_data
(paren
id|port
comma
id|buf
comma
id|length
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Switch to reverse mode if necessary. */
r_if
c_cond
(paren
(paren
id|port-&gt;ieee1284.phase
op_ne
id|IEEE1284_PH_REV_IDLE
)paren
op_logical_and
(paren
id|port-&gt;ieee1284.phase
op_ne
id|IEEE1284_PH_REV_DATA
)paren
)paren
(brace
multiline_comment|/* Event 38: Set nAutoFd low */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_AUTOFD
comma
id|PARPORT_CONTROL_AUTOFD
)paren
suffix:semicolon
id|parport_pc_data_reverse
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Event 39: Set nInit low to initiate bus reversal */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Event 40: PError goes low */
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: PE timeout Event 40 (%d) &quot;
l_string|&quot;in ecp_read_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up ECP FIFO mode.*/
id|parport_pc_data_reverse
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
id|parport_pc_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_STROBE
op_or
id|PARPORT_CONTROL_AUTOFD
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|change_mode
(paren
id|port
comma
id|ECR_ECP
)paren
suffix:semicolon
multiline_comment|/* ECP FIFO */
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: Warning change_mode ECR_ECP failed&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_REV_DATA
suffix:semicolon
multiline_comment|/* Do the transfer. */
r_while
c_loop
(paren
id|left
OG
id|fifofull
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|expire
op_assign
id|jiffies
op_plus
id|port-&gt;cad-&gt;timeout
suffix:semicolon
r_int
r_char
id|ecrval
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
op_logical_and
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
multiline_comment|/* Can&squot;t yield the port. */
id|schedule
(paren
)paren
suffix:semicolon
multiline_comment|/* At this point, the FIFO may already be full.&n;&t;&t; * Ideally, we&squot;d be able to tell the port to hold on&n;&t;&t; * for a second while we empty the FIFO, and we&squot;d be&n;&t;&t; * able to ensure that no data is lost.  I&squot;m not sure&n;&t;&t; * that&squot;s the case. :-(  It might be that you can play&n;&t;&t; * games with STB, as in the forward case; someone should&n;&t;&t; * look at a datasheet. */
r_if
c_cond
(paren
id|ecrval
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* FIFO is empty. Wait for interrupt. */
multiline_comment|/* Anyone else waiting for the port? */
r_if
c_cond
(paren
id|port-&gt;waithead
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Somebody wants the port&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Clear serviceIntr */
id|outb
(paren
id|ecrval
op_amp
op_complement
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
id|false_alarm
suffix:colon
id|ret
op_assign
id|parport_wait_event
(paren
id|port
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
(brace
multiline_comment|/* Timed out. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;PIO read timed out&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ecrval
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ecrval
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;need_resched
op_logical_and
id|time_before
(paren
id|jiffies
comma
id|expire
)paren
)paren
id|schedule
(paren
)paren
suffix:semicolon
r_goto
id|false_alarm
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecrval
op_amp
l_int|0x02
)paren
(brace
multiline_comment|/* FIFO is full. */
id|insb
(paren
id|fifo
comma
id|bufp
comma
id|fifo_depth
)paren
suffix:semicolon
id|bufp
op_add_assign
id|fifo_depth
suffix:semicolon
id|left
op_sub_assign
id|fifo_depth
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|bufp
op_increment
op_assign
id|inb
(paren
id|fifo
)paren
suffix:semicolon
id|left
op_decrement
suffix:semicolon
)brace
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_REV_IDLE
suffix:semicolon
multiline_comment|/* Go to forward idle mode to shut the peripheral up. */
id|parport_frob_control
(paren
id|port
comma
id|PARPORT_CONTROL_INIT
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|parport_wait_peripheral
(paren
id|port
comma
id|PARPORT_STATUS_PAPEROUT
comma
id|PARPORT_STATUS_PAPEROUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: PE timeout FWDIDLE (%d) in ecp_read_block_pio&bslash;n&quot;
comma
id|port-&gt;name
comma
id|r
)paren
suffix:semicolon
id|port-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
multiline_comment|/* Finish up. */
(brace
r_int
id|lost
op_assign
id|get_fifo_residue
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lost
)paren
multiline_comment|/* Shouldn&squot;t happen with compliant peripherals. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: DATA LOSS (%d bytes)!&bslash;n&quot;
comma
id|port-&gt;name
comma
id|lost
)paren
suffix:semicolon
)brace
r_return
id|length
op_minus
id|left
suffix:semicolon
)brace
macro_line|#endif /* IEEE 1284 support */
macro_line|#endif /* Allowed to use FIFO/DMA */
DECL|function|parport_pc_inc_use_count
r_void
id|parport_pc_inc_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_pc_dec_use_count
r_void
id|parport_pc_dec_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|parport_pc_ops
r_struct
id|parport_operations
id|parport_pc_ops
op_assign
(brace
id|parport_pc_write_data
comma
id|parport_pc_read_data
comma
id|parport_pc_write_control
comma
id|parport_pc_read_control
comma
id|parport_pc_frob_control
comma
id|parport_pc_read_status
comma
id|parport_pc_enable_irq
comma
id|parport_pc_disable_irq
comma
id|parport_pc_data_forward
comma
id|parport_pc_data_reverse
comma
id|parport_pc_init_state
comma
id|parport_pc_save_state
comma
id|parport_pc_restore_state
comma
id|parport_pc_inc_use_count
comma
id|parport_pc_dec_use_count
comma
id|parport_ieee1284_epp_write_data
comma
id|parport_ieee1284_epp_read_data
comma
id|parport_ieee1284_epp_write_addr
comma
id|parport_ieee1284_epp_read_addr
comma
id|parport_ieee1284_ecp_write_data
comma
id|parport_ieee1284_ecp_read_data
comma
id|parport_ieee1284_ecp_write_addr
comma
id|parport_ieee1284_write_compat
comma
id|parport_ieee1284_read_nibble
comma
id|parport_ieee1284_read_byte
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_PC_SUPERIO
multiline_comment|/* Super-IO chipset detection, Winbond, SMSC */
DECL|function|show_parconfig_smsc37c669
r_static
r_void
id|__devinit
id|show_parconfig_smsc37c669
c_func
(paren
r_int
id|io
comma
r_int
id|key
)paren
(brace
r_int
id|cr1
comma
id|cr4
comma
id|cra
comma
id|cr23
comma
id|cr26
comma
id|cr27
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|modes
(braket
)braket
op_assign
initialization_block
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|io
)paren
suffix:semicolon
id|cr1
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|4
comma
id|io
)paren
suffix:semicolon
id|cr4
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
id|io
)paren
suffix:semicolon
id|cra
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x23
comma
id|io
)paren
suffix:semicolon
id|cr23
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x26
comma
id|io
)paren
suffix:semicolon
id|cr26
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x27
comma
id|io
)paren
suffix:semicolon
id|cr27
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|io
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;SMSC 37c669 LPT Config: cr_1=0x%02x, 4=0x%02x, &quot;
l_string|&quot;A=0x%2x, 23=0x%02x, 26=0x%02x, 27=0x%02x&bslash;n&quot;
comma
id|cr1
comma
id|cr4
comma
id|cra
comma
id|cr23
comma
id|cr26
comma
id|cr27
)paren
suffix:semicolon
multiline_comment|/* The documentation calls DMA and IRQ-Lines by letters, so&n;&t;   the board maker can/will wire them&n;&t;   appropriately/randomly...  G=reserved H=IDE-irq, */
id|printk
(paren
l_string|&quot;SMSC LPT Config: io=0x%04x, irq=%c, dma=%c, &quot;
l_string|&quot;fifo threshold=%d&bslash;n&quot;
comma
id|cr23
op_star
l_int|4
comma
(paren
id|cr27
op_amp
l_int|0x0f
)paren
ques
c_cond
l_char|&squot;A&squot;
op_minus
l_int|1
op_plus
(paren
id|cr27
op_amp
l_int|0x0f
)paren
suffix:colon
l_char|&squot;-&squot;
comma
(paren
id|cr26
op_amp
l_int|0x0f
)paren
ques
c_cond
l_char|&squot;A&squot;
op_minus
l_int|1
op_plus
(paren
id|cr26
op_amp
l_int|0x0f
)paren
suffix:colon
l_char|&squot;-&squot;
comma
id|cra
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMSC LPT Config: enabled=%s power=%s&bslash;n&quot;
comma
(paren
id|cr23
op_star
l_int|4
op_ge
l_int|0x100
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|cr1
op_amp
l_int|4
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMSC LPT Config: Port mode=%s, EPP version =%s&bslash;n&quot;
comma
(paren
id|cr1
op_amp
l_int|0x08
)paren
ques
c_cond
l_string|&quot;Standard mode only (SPP)&quot;
suffix:colon
id|modes
(braket
id|cr4
op_amp
l_int|0x03
)braket
comma
(paren
id|cr4
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;1.7&quot;
suffix:colon
l_string|&quot;1.9&quot;
)paren
suffix:semicolon
multiline_comment|/* Heuristics !  BIOS setup for this mainboard device limits&n;&t;   the choices to standard settings, i.e. io-address and IRQ&n;&t;   are related, however DMA can be 1 or 3, assume DMA_A=DMA1,&n;&t;   DMA_C=DMA3 (this is true e.g. for TYAN 1564D Tomcat IV) */
r_if
c_cond
(paren
id|cr23
op_star
l_int|4
op_ge
l_int|0x100
)paren
(brace
multiline_comment|/* if active */
r_while
c_loop
(paren
(paren
id|superios
(braket
id|i
)braket
dot
id|io
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
OL
id|NR_SUPERIOS
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_SUPERIOS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Super-IO: too many chips!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|d
suffix:semicolon
r_switch
c_cond
(paren
id|cr23
op_star
l_int|4
)paren
(brace
r_case
l_int|0x3bc
suffix:colon
id|superios
(braket
id|i
)braket
dot
id|io
op_assign
l_int|0x3bc
suffix:semicolon
id|superios
(braket
id|i
)braket
dot
id|irq
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x378
suffix:colon
id|superios
(braket
id|i
)braket
dot
id|io
op_assign
l_int|0x378
suffix:semicolon
id|superios
(braket
id|i
)braket
dot
id|irq
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x278
suffix:colon
id|superios
(braket
id|i
)braket
dot
id|io
op_assign
l_int|0x278
suffix:semicolon
id|superios
(braket
id|i
)braket
dot
id|irq
op_assign
l_int|5
suffix:semicolon
)brace
id|d
op_assign
(paren
id|cr26
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_eq
l_int|1
)paren
op_logical_or
(paren
id|d
op_eq
l_int|3
)paren
)paren
(brace
id|superios
(braket
id|i
)braket
dot
id|dma
op_assign
id|d
suffix:semicolon
)brace
r_else
id|superios
(braket
id|i
)braket
dot
id|dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
)brace
)brace
DECL|function|show_parconfig_winbond
r_static
r_void
id|__devinit
id|show_parconfig_winbond
c_func
(paren
r_int
id|io
comma
r_int
id|key
)paren
(brace
r_int
id|cr30
comma
id|cr60
comma
id|cr61
comma
id|cr70
comma
id|cr74
comma
id|crf0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|modes
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_char
op_star
id|irqtypes
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* The registers are called compatible-PnP because the&n;           register layout is modelled after ISA-PnP, the access&n;           method is just another ... */
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x07
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Register 7: Select Logical Device */
id|outb
c_func
(paren
l_int|0x01
comma
id|io
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* LD1 is Parallel Port */
id|outb
c_func
(paren
l_int|0x30
comma
id|io
)paren
suffix:semicolon
id|cr30
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x60
comma
id|io
)paren
suffix:semicolon
id|cr60
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x61
comma
id|io
)paren
suffix:semicolon
id|cr61
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x70
comma
id|io
)paren
suffix:semicolon
id|cr70
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x74
comma
id|io
)paren
suffix:semicolon
id|cr74
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xf0
comma
id|io
)paren
suffix:semicolon
id|crf0
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|io
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Winbond LPT Config: cr_30=%02x 60,61=%02x%02x &quot;
l_string|&quot;70=%02x 74=%02x, f0=%02x&bslash;n&quot;
comma
id|cr30
comma
id|cr60
comma
id|cr61
comma
id|cr70
comma
id|cr74
comma
id|crf0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Winbond LPT Config: active=%s, io=0x%02x%02x irq=%d, &quot;
comma
(paren
id|cr30
op_amp
l_int|0x01
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|cr60
comma
id|cr61
comma
id|cr70
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cr74
op_amp
l_int|0x07
)paren
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;dma=none&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;dma=%d&bslash;n&quot;
comma
id|cr74
op_amp
l_int|0x07
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Winbond LPT Config: irqtype=%s, ECP fifo threshold=%d&bslash;n&quot;
comma
id|irqtypes
(braket
id|crf0
op_rshift
l_int|7
)braket
comma
(paren
id|crf0
op_rshift
l_int|3
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Winbond LPT Config: Port mode=%s&bslash;n&quot;
comma
id|modes
(braket
id|crf0
op_amp
l_int|0x07
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cr30
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* the settings can be interrogated later ... */
r_while
c_loop
(paren
(paren
id|superios
(braket
id|i
)braket
dot
id|io
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
OL
id|NR_SUPERIOS
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_SUPERIOS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Super-IO: too many chips!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|superios
(braket
id|i
)braket
dot
id|io
op_assign
(paren
id|cr60
op_lshift
l_int|8
)paren
op_or
id|cr61
suffix:semicolon
id|superios
(braket
id|i
)braket
dot
id|irq
op_assign
id|cr70
op_amp
l_int|0x0f
suffix:semicolon
id|superios
(braket
id|i
)braket
dot
id|dma
op_assign
(paren
(paren
(paren
id|cr74
op_amp
l_int|0x07
)paren
OG
l_int|3
)paren
ques
c_cond
id|PARPORT_DMA_NONE
suffix:colon
(paren
id|cr74
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|decode_winbond
r_static
r_void
id|__devinit
id|decode_winbond
c_func
(paren
r_int
id|efer
comma
r_int
id|key
comma
r_int
id|devid
comma
r_int
id|devrev
comma
r_int
id|oldid
)paren
(brace
r_char
op_star
id|type
op_assign
l_int|NULL
suffix:semicolon
r_int
id|id
comma
id|progif
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|devid
op_eq
id|devrev
)paren
multiline_comment|/* simple heuristics, we happened to read some&n;                   non-winbond register */
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Winbond chip at EFER=0x%x key=0x%02x devid=%02x devrev=%02x &quot;
l_string|&quot;oldid=%02x&bslash;n&quot;
comma
id|efer
comma
id|key
comma
id|devid
comma
id|devrev
comma
id|oldid
)paren
suffix:semicolon
id|id
op_assign
(paren
id|devid
op_lshift
l_int|8
)paren
op_or
id|devrev
suffix:semicolon
multiline_comment|/* Values are from public data sheets pdf files, I can just&n;           confirm 83977TF is correct :-) */
r_if
c_cond
(paren
id|id
op_eq
l_int|0x9771
)paren
id|type
op_assign
l_string|&quot;83977F/AF&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|0x9773
)paren
id|type
op_assign
l_string|&quot;83977TF / SMSC 97w33x/97w34x&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|0x9774
)paren
id|type
op_assign
l_string|&quot;83977ATF&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|id
op_amp
op_complement
l_int|0x0f
)paren
op_eq
l_int|0x5270
)paren
id|type
op_assign
l_string|&quot;83977CTF / SMSC 97w36x&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|id
op_amp
op_complement
l_int|0x0f
)paren
op_eq
l_int|0x52f0
)paren
id|type
op_assign
l_string|&quot;83977EF / SMSC 97w35x&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|id
op_amp
op_complement
l_int|0x0f
)paren
op_eq
l_int|0x5210
)paren
id|type
op_assign
l_string|&quot;83627&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|id
op_amp
op_complement
l_int|0x0f
)paren
op_eq
l_int|0x6010
)paren
id|type
op_assign
l_string|&quot;83697HF&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|oldid
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x0a
)paren
(brace
id|type
op_assign
l_string|&quot;83877F&quot;
suffix:semicolon
id|progif
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|oldid
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x0b
)paren
(brace
id|type
op_assign
l_string|&quot;83877AF&quot;
suffix:semicolon
id|progif
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|oldid
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x0c
)paren
(brace
id|type
op_assign
l_string|&quot;83877TF&quot;
suffix:semicolon
id|progif
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|oldid
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x0d
)paren
(brace
id|type
op_assign
l_string|&quot;83877ATF&quot;
suffix:semicolon
id|progif
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|progif
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Winbond unknown chip type&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Winbond chip type %s&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progif
op_eq
l_int|2
)paren
(brace
id|show_parconfig_winbond
c_func
(paren
id|efer
comma
id|key
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|decode_smsc
r_static
r_void
id|__devinit
id|decode_smsc
c_func
(paren
r_int
id|efer
comma
r_int
id|key
comma
r_int
id|devid
comma
r_int
id|devrev
)paren
(brace
r_char
op_star
id|type
op_assign
l_int|NULL
suffix:semicolon
r_void
(paren
op_star
id|func
)paren
(paren
r_int
id|io
comma
r_int
id|key
)paren
suffix:semicolon
r_int
id|id
suffix:semicolon
r_if
c_cond
(paren
id|devid
op_eq
id|devrev
)paren
multiline_comment|/* simple heuristics, we happened to read some&n;                   non-smsc register */
r_return
suffix:semicolon
id|func
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMSC chip at EFER=0x%x key=0x%02x devid=%02x devrev=%02x&bslash;n&quot;
comma
id|efer
comma
id|key
comma
id|devid
comma
id|devrev
)paren
suffix:semicolon
id|id
op_assign
(paren
id|devid
op_lshift
l_int|8
)paren
op_or
id|devrev
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0x0302
)paren
(brace
id|type
op_assign
l_string|&quot;37c669&quot;
suffix:semicolon
id|func
op_assign
id|show_parconfig_smsc37c669
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|0x6582
)paren
id|type
op_assign
l_string|&quot;37c665IR&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|devid
op_eq
l_int|0x65
)paren
id|type
op_assign
l_string|&quot;37c665GT&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|devid
op_eq
l_int|0x66
)paren
id|type
op_assign
l_string|&quot;37c666GT&quot;
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMSC unknown chip type&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;SMSC chip type %s&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
(paren
id|func
)paren
(paren
id|efer
comma
id|key
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|winbond_check
r_static
r_void
id|__devinit
id|winbond_check
c_func
(paren
r_int
id|io
comma
r_int
id|key
)paren
(brace
r_int
id|devid
comma
id|devrev
comma
id|oldid
comma
id|x_devid
comma
id|x_devrev
comma
id|x_oldid
suffix:semicolon
multiline_comment|/* First probe without key */
id|outb
c_func
(paren
l_int|0x20
comma
id|io
)paren
suffix:semicolon
id|x_devid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x21
comma
id|io
)paren
suffix:semicolon
id|x_devrev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x09
comma
id|io
)paren
suffix:semicolon
id|x_oldid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Write Magic Sequence to EFER, extended&n;                             funtion enable register */
id|outb
c_func
(paren
l_int|0x20
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Write EFIR, extended function index register */
id|devid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Read EFDR, extended function data register */
id|outb
c_func
(paren
l_int|0x21
comma
id|io
)paren
suffix:semicolon
id|devrev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x09
comma
id|io
)paren
suffix:semicolon
id|oldid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Magic Seal */
r_if
c_cond
(paren
(paren
id|x_devid
op_eq
id|devid
)paren
op_logical_and
(paren
id|x_devrev
op_eq
id|devrev
)paren
op_logical_and
(paren
id|x_oldid
op_eq
id|oldid
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* protection against false positives */
id|decode_winbond
c_func
(paren
id|io
comma
id|key
comma
id|devid
comma
id|devrev
comma
id|oldid
)paren
suffix:semicolon
)brace
DECL|function|winbond_check2
r_static
r_void
id|__devinit
id|winbond_check2
c_func
(paren
r_int
id|io
comma
r_int
id|key
)paren
(brace
r_int
id|devid
comma
id|devrev
comma
id|oldid
comma
id|x_devid
comma
id|x_devrev
comma
id|x_oldid
suffix:semicolon
multiline_comment|/* First probe without the key */
id|outb
c_func
(paren
l_int|0x20
comma
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|x_devid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x21
comma
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|x_devrev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x09
comma
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|x_oldid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Write Magic Byte to EFER, extended&n;                             funtion enable register */
id|outb
c_func
(paren
l_int|0x20
comma
id|io
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Write EFIR, extended function index register */
id|devid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Read EFDR, extended function data register */
id|outb
c_func
(paren
l_int|0x21
comma
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|devrev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x09
comma
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|oldid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Magic Seal */
r_if
c_cond
(paren
(paren
id|x_devid
op_eq
id|devid
)paren
op_logical_and
(paren
id|x_devrev
op_eq
id|devrev
)paren
op_logical_and
(paren
id|x_oldid
op_eq
id|oldid
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* protection against false positives */
id|decode_winbond
c_func
(paren
id|io
comma
id|key
comma
id|devid
comma
id|devrev
comma
id|oldid
)paren
suffix:semicolon
)brace
DECL|function|smsc_check
r_static
r_void
id|__devinit
id|smsc_check
c_func
(paren
r_int
id|io
comma
r_int
id|key
)paren
(brace
r_int
id|id
comma
id|rev
comma
id|oldid
comma
id|oldrev
comma
id|x_id
comma
id|x_rev
comma
id|x_oldid
comma
id|x_oldrev
suffix:semicolon
multiline_comment|/* First probe without the key */
id|outb
c_func
(paren
l_int|0x0d
comma
id|io
)paren
suffix:semicolon
id|x_oldid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0e
comma
id|io
)paren
suffix:semicolon
id|x_oldrev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|io
)paren
suffix:semicolon
id|x_id
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x21
comma
id|io
)paren
suffix:semicolon
id|x_rev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
id|outb
c_func
(paren
id|key
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Write Magic Sequence to EFER, extended&n;                             funtion enable register */
id|outb
c_func
(paren
l_int|0x0d
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Write EFIR, extended function index register */
id|oldid
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Read EFDR, extended function data register */
id|outb
c_func
(paren
l_int|0x0e
comma
id|io
)paren
suffix:semicolon
id|oldrev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|io
)paren
suffix:semicolon
id|id
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x21
comma
id|io
)paren
suffix:semicolon
id|rev
op_assign
id|inb
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|io
)paren
suffix:semicolon
multiline_comment|/* Magic Seal */
r_if
c_cond
(paren
(paren
id|x_id
op_eq
id|id
)paren
op_logical_and
(paren
id|x_oldrev
op_eq
id|oldrev
)paren
op_logical_and
(paren
id|x_oldid
op_eq
id|oldid
)paren
op_logical_and
(paren
id|x_rev
op_eq
id|rev
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* protection against false positives */
id|decode_smsc
c_func
(paren
id|io
comma
id|key
comma
id|oldid
comma
id|oldrev
)paren
suffix:semicolon
)brace
DECL|function|detect_and_report_winbond
r_static
r_void
id|__devinit
id|detect_and_report_winbond
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Winbond Super-IO detection, now testing ports 3F0,370,250,4E,2E ...&bslash;n&quot;
)paren
suffix:semicolon
id|winbond_check
c_func
(paren
l_int|0x3f0
comma
l_int|0x87
)paren
suffix:semicolon
id|winbond_check
c_func
(paren
l_int|0x370
comma
l_int|0x87
)paren
suffix:semicolon
id|winbond_check
c_func
(paren
l_int|0x2e
comma
l_int|0x87
)paren
suffix:semicolon
id|winbond_check
c_func
(paren
l_int|0x4e
comma
l_int|0x87
)paren
suffix:semicolon
id|winbond_check
c_func
(paren
l_int|0x3f0
comma
l_int|0x86
)paren
suffix:semicolon
id|winbond_check2
c_func
(paren
l_int|0x250
comma
l_int|0x88
)paren
suffix:semicolon
id|winbond_check2
c_func
(paren
l_int|0x250
comma
l_int|0x89
)paren
suffix:semicolon
)brace
DECL|function|detect_and_report_smsc
r_static
r_void
id|__devinit
id|detect_and_report_smsc
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMSC Super-IO detection, now testing Ports 2F0, 370 ...&bslash;n&quot;
)paren
suffix:semicolon
id|smsc_check
c_func
(paren
l_int|0x3f0
comma
l_int|0x55
)paren
suffix:semicolon
id|smsc_check
c_func
(paren
l_int|0x370
comma
l_int|0x55
)paren
suffix:semicolon
id|smsc_check
c_func
(paren
l_int|0x3f0
comma
l_int|0x44
)paren
suffix:semicolon
id|smsc_check
c_func
(paren
l_int|0x370
comma
l_int|0x44
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PARPORT_PC_SUPERIO */
DECL|function|get_superio_dma
r_static
r_int
id|__devinit
id|get_superio_dma
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|superios
(braket
id|i
)braket
dot
id|io
op_ne
id|p-&gt;base
)paren
op_logical_and
(paren
id|i
OL
id|NR_SUPERIOS
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|NR_SUPERIOS
)paren
r_return
id|superios
(braket
id|i
)braket
dot
id|dma
suffix:semicolon
r_return
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
DECL|function|get_superio_irq
r_static
r_int
id|__devinit
id|get_superio_irq
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|superios
(braket
id|i
)braket
dot
id|io
op_ne
id|p-&gt;base
)paren
op_logical_and
(paren
id|i
OL
id|NR_SUPERIOS
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|NR_SUPERIOS
)paren
r_return
id|superios
(braket
id|i
)braket
dot
id|irq
suffix:semicolon
r_return
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/* --- Mode detection ------------------------------------- */
multiline_comment|/*&n; * Checks for port existence, all ports support SPP MODE&n; * Returns: &n; *         0           :  No parallel port at this adress&n; *  PARPORT_MODE_PCSPP :  SPP port detected &n; *                        (if the user specified an ioport himself,&n; *                         this shall always be the case!)&n; *&n; */
DECL|function|parport_SPP_supported
r_static
r_int
id|__devinit
id|parport_SPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
comma
id|w
suffix:semicolon
multiline_comment|/*&n;&t; * first clear an eventually pending EPP timeout &n;&t; * I (sailer@ife.ee.ethz.ch) have an SMSC chipset&n;&t; * that does not even respond to SPP cycles if an EPP&n;&t; * timeout is pending&n;&t; */
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Do a simple read-write test to make sure the port exists. */
id|w
op_assign
l_int|0xc
suffix:semicolon
id|outb
(paren
id|w
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Is there a control register that we can read from?  Some&n;&t; * ports don&squot;t allow reads, so read_control just returns a&n;&t; * software copy. Some ports _do_ allow reads, so bypass the&n;&t; * software copy here.  In addition, some bits aren&squot;t&n;&t; * writable. */
id|r
op_assign
id|inb
(paren
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xf
)paren
op_eq
id|w
)paren
(brace
id|w
op_assign
l_int|0xe
suffix:semicolon
id|outb
(paren
id|w
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|r
op_assign
id|inb
(paren
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|outb
(paren
l_int|0xc
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xf
)paren
op_eq
id|w
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_specified
)paren
multiline_comment|/* That didn&squot;t work, but the user thinks there&squot;s a&n;&t;&t; * port here. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport 0x%lx (WARNING): CTR: &quot;
l_string|&quot;wrote 0x%02x, read 0x%02x&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|w
comma
id|r
)paren
suffix:semicolon
multiline_comment|/* Try the data register.  The data lines aren&squot;t tri-stated at&n;&t; * this stage, so we expect back what we wrote. */
id|w
op_assign
l_int|0xaa
suffix:semicolon
id|parport_pc_write_data
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_data
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|w
)paren
(brace
id|w
op_assign
l_int|0x55
suffix:semicolon
id|parport_pc_write_data
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_data
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|w
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_specified
)paren
(brace
multiline_comment|/* Didn&squot;t work, but the user is convinced this is the&n;&t;&t; * place. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport 0x%lx (WARNING): DATA: &quot;
l_string|&quot;wrote 0x%02x, read 0x%02x&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|w
comma
id|r
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport 0x%lx: You gave this address, &quot;
l_string|&quot;but there is probably no parallel port there!&bslash;n&quot;
comma
id|pb-&gt;base
)paren
suffix:semicolon
)brace
multiline_comment|/* It&squot;s possible that we can&squot;t read the control register or&n;&t; * the data register.  In that case just believe the user. */
r_if
c_cond
(paren
id|user_specified
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for ECR&n; *&n; * Old style XT ports alias io ports every 0x400, hence accessing ECR&n; * on these cards actually accesses the CTR.&n; *&n; * Modern cards don&squot;t do this but reading from ECR will return 0xff&n; * regardless of what is written here if the card does NOT support&n; * ECP.&n; *&n; * We first check to see if ECR is the same as CTR.  If not, the low&n; * two bits of ECR aren&squot;t writable, so we check by writing ECR and&n; * reading it back to see if it&squot;s what we expect.&n; */
DECL|function|parport_ECR_present
r_static
r_int
id|__devinit
id|parport_ECR_present
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
r_int
r_char
id|r
op_assign
l_int|0xc
suffix:semicolon
id|outb
(paren
id|r
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
l_int|0x3
)paren
op_eq
(paren
id|r
op_amp
l_int|0x3
)paren
)paren
(brace
id|outb
(paren
id|r
op_xor
l_int|0x2
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Toggle bit 1 */
id|r
op_assign
id|inb
(paren
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
l_int|0x2
)paren
op_eq
(paren
id|r
op_amp
l_int|0x2
)paren
)paren
r_goto
id|no_reg
suffix:semicolon
multiline_comment|/* Sure that no ECR register exists */
)brace
r_if
c_cond
(paren
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
l_int|0x3
)paren
op_ne
l_int|0x1
)paren
r_goto
id|no_reg
suffix:semicolon
id|outb
(paren
l_int|0x34
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_ne
l_int|0x35
)paren
r_goto
id|no_reg
suffix:semicolon
id|priv-&gt;ecr
op_assign
l_int|1
suffix:semicolon
id|outb
(paren
l_int|0xc
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Go to mode 000 */
id|frob_econtrol
(paren
id|pb
comma
l_int|0xe0
comma
id|ECR_SPP
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|no_reg
suffix:colon
id|outb
(paren
l_int|0xc
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* Detect PS/2 support.&n; *&n; * Bit 5 (0x20) sets the PS/2 data direction; setting this high&n; * allows us to read data from the data lines.  In theory we would get back&n; * 0xff but any peripheral attached to the port may drag some or all of the&n; * lines down to zero.  So if we get back anything that isn&squot;t the contents&n; * of the data register we deem PS/2 support to be present. &n; *&n; * Some SPP ports have &quot;half PS/2&quot; ability - you can&squot;t turn off the line&n; * drivers, but an external peripheral with sufficiently beefy drivers of&n; * its own can overpower them and assert its own levels onto the bus, from&n; * where they can then be read back as normal.  Ports with this property&n; * and the right type of device attached are likely to fail the SPP test,&n; * (as they will appear to have stuck bits) and so the fact that they might&n; * be misdetected here is rather academic. &n; */
DECL|function|parport_PS2_supported
r_static
r_int
id|__devinit
id|parport_PS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* try to tri-state the buffer */
id|parport_pc_data_reverse
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_write_data
c_func
(paren
id|pb
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0x55
)paren
id|ok
op_increment
suffix:semicolon
id|parport_pc_write_data
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0xaa
)paren
id|ok
op_increment
suffix:semicolon
multiline_comment|/* cancel input mode */
id|parport_pc_data_forward
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
)paren
(brace
id|pb-&gt;modes
op_or_assign
id|PARPORT_MODE_TRISTATE
suffix:semicolon
)brace
r_else
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
id|priv-&gt;ctr_writable
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
)brace
r_return
id|ok
suffix:semicolon
)brace
DECL|function|parport_ECP_supported
r_static
r_int
id|__devinit
id|parport_ECP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|config
comma
id|configb
suffix:semicolon
r_int
id|pword
suffix:semicolon
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
r_int
id|intrline
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Translate ECP&n;                                                 intrLine to ISA irq&n;                                                 value */
multiline_comment|/* If there is no ECR, we have no hope of supporting ECP. */
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ecr
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Find out FIFO depth */
id|outb
(paren
id|ECR_SPP
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO */
id|outb
(paren
id|ECR_TST
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* TEST FIFO */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
op_logical_neg
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
l_int|0x02
)paren
suffix:semicolon
id|i
op_increment
)paren
id|outb
(paren
l_int|0xaa
comma
id|FIFO
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Using LGS chipset it uses ECR register, but&n;&t; * it doesn&squot;t support ECP or FIFO MODE&n;&t; */
r_if
c_cond
(paren
id|i
op_eq
l_int|1024
)paren
(brace
id|outb
(paren
id|ECR_SPP
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|priv-&gt;fifo_depth
op_assign
id|i
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;0x%lx: FIFO is %d bytes&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Find out writeIntrThreshold */
id|frob_econtrol
(paren
id|pb
comma
l_int|1
op_lshift
l_int|2
comma
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|pb
comma
l_int|1
op_lshift
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|priv-&gt;fifo_depth
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb
(paren
id|FIFO
(paren
id|pb
)paren
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
id|priv-&gt;fifo_depth
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;0x%lx: writeIntrThreshold is %d&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|i
)paren
suffix:semicolon
r_else
multiline_comment|/* Number of bytes we know we can write if we get an&n;                   interrupt. */
id|i
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;writeIntrThreshold
op_assign
id|i
suffix:semicolon
multiline_comment|/* Find out readIntrThreshold */
id|frob_econtrol
(paren
id|pb
comma
l_int|0xe0
comma
id|ECR_PS2
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO and enable PS2 */
id|parport_pc_data_reverse
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Must be in PS2 mode */
id|frob_econtrol
(paren
id|pb
comma
l_int|0xe0
comma
id|ECR_TST
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Test FIFO */
id|frob_econtrol
(paren
id|pb
comma
l_int|1
op_lshift
l_int|2
comma
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
id|frob_econtrol
(paren
id|pb
comma
l_int|1
op_lshift
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|priv-&gt;fifo_depth
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
l_int|0xaa
comma
id|FIFO
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
id|priv-&gt;fifo_depth
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;0x%lx: readIntrThreshold is %d&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|i
)paren
suffix:semicolon
r_else
multiline_comment|/* Number of bytes we can read if we get an interrupt. */
id|i
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;readIntrThreshold
op_assign
id|i
suffix:semicolon
id|outb
(paren
id|ECR_SPP
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO */
id|outb
(paren
l_int|0xf4
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Configuration mode */
id|config
op_assign
id|inb
(paren
id|CONFIGA
(paren
id|pb
)paren
)paren
suffix:semicolon
id|pword
op_assign
(paren
id|config
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
suffix:semicolon
r_switch
c_cond
(paren
id|pword
)paren
(brace
r_case
l_int|0
suffix:colon
id|pword
op_assign
l_int|2
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;0x%lx: Unsupported pword size!&bslash;n&quot;
comma
id|pb-&gt;base
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|pword
op_assign
l_int|4
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;0x%lx: Unsupported pword size!&bslash;n&quot;
comma
id|pb-&gt;base
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;0x%lx: Unknown implementation ID&bslash;n&quot;
comma
id|pb-&gt;base
)paren
suffix:semicolon
multiline_comment|/* Assume 1 */
r_case
l_int|1
suffix:colon
id|pword
op_assign
l_int|1
suffix:semicolon
)brace
id|priv-&gt;pword
op_assign
id|pword
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;0x%lx: PWord is %d bits&bslash;n&quot;
comma
id|pb-&gt;base
comma
l_int|8
op_star
id|pword
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;0x%lx: Interrupts are ISA-%s&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|config
op_amp
l_int|0x80
ques
c_cond
l_string|&quot;Level&quot;
suffix:colon
l_string|&quot;Pulses&quot;
)paren
suffix:semicolon
id|configb
op_assign
id|inb
(paren
id|CONFIGB
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|configb
op_amp
l_int|0x40
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;0x%lx: possible IRQ conflict!&bslash;n&quot;
comma
id|pb-&gt;base
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;0x%lx: ECP port cfgA=0x%02x cfgB=0x%02x&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|config
comma
id|configb
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;0x%lx: ECP settings irq=&quot;
comma
id|pb-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|configb
op_rshift
l_int|3
)paren
op_amp
l_int|0x07
)paren
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|intrline
(braket
(paren
id|configb
op_rshift
l_int|3
)paren
op_amp
l_int|0x07
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&lt;none or set by other means&gt;&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; dma=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|configb
op_amp
l_int|0x03
)paren
op_eq
l_int|0x00
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&lt;none or set by other means&gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|configb
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* Go back to mode 000 */
id|frob_econtrol
(paren
id|pb
comma
l_int|0xe0
comma
id|ECR_SPP
op_lshift
l_int|5
)paren
suffix:semicolon
id|pb-&gt;modes
op_or_assign
id|PARPORT_MODE_ECP
op_or
id|PARPORT_MODE_COMPAT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parport_ECPPS2_supported
r_static
r_int
id|__devinit
id|parport_ECPPS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ecr
)paren
r_return
l_int|0
suffix:semicolon
id|oecr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|outb
(paren
id|ECR_PS2
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|result
op_assign
id|parport_PS2_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|outb
(paren
id|oecr
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* EPP mode detection  */
DECL|function|parport_EPP_supported
r_static
r_int
id|__devinit
id|parport_EPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
multiline_comment|/*&n;&t; * Theory:&n;&t; *&t;Bit 0 of STR is the EPP timeout bit, this bit is 0&n;&t; *&t;when EPP is possible and is set high when an EPP timeout&n;&t; *&t;occurs (EPP uses the HALT line to stop the CPU while it does&n;&t; *&t;the byte transfer, an EPP timeout occurs if the attached&n;&t; *&t;device fails to respond after 10 micro seconds).&n;&t; *&n;&t; *&t;This bit is cleared by either reading it (National Semi)&n;&t; *&t;or writing a 1 to the bit (SMC, UMC, WinBond), others ???&n;&t; *&t;This bit is always high in non EPP modes.&n;&t; */
multiline_comment|/* If EPP timeout bit clear then EPP available */
r_if
c_cond
(paren
op_logical_neg
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* No way to clear timeout */
multiline_comment|/* Check for Intel bug. */
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
(brace
r_int
r_char
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
OL
l_int|0x80
suffix:semicolon
id|i
op_add_assign
l_int|0x20
)paren
(brace
id|outb
(paren
id|i
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_epp_timeout
(paren
id|pb
)paren
)paren
multiline_comment|/* Phony EPP in ECP. */
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|pb-&gt;modes
op_or_assign
id|PARPORT_MODE_EPP
suffix:semicolon
multiline_comment|/* Set up access functions to use EPP hardware. */
id|pb-&gt;ops-&gt;epp_read_data
op_assign
id|parport_pc_epp_read_data
suffix:semicolon
id|pb-&gt;ops-&gt;epp_write_data
op_assign
id|parport_pc_epp_write_data
suffix:semicolon
id|pb-&gt;ops-&gt;epp_read_addr
op_assign
id|parport_pc_epp_read_addr
suffix:semicolon
id|pb-&gt;ops-&gt;epp_write_addr
op_assign
id|parport_pc_epp_write_addr
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parport_ECPEPP_supported
r_static
r_int
id|__devinit
id|parport_ECPEPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ecr
)paren
r_return
l_int|0
suffix:semicolon
id|oecr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Search for SMC style EPP+ECP mode */
id|outb
(paren
l_int|0x80
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|outb
(paren
l_int|0x04
comma
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|result
op_assign
id|parport_EPP_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|outb
(paren
id|oecr
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* Set up access functions to use ECP+EPP hardware. */
id|pb-&gt;ops-&gt;epp_read_data
op_assign
id|parport_pc_ecpepp_read_data
suffix:semicolon
id|pb-&gt;ops-&gt;epp_write_data
op_assign
id|parport_pc_ecpepp_write_data
suffix:semicolon
id|pb-&gt;ops-&gt;epp_read_addr
op_assign
id|parport_pc_ecpepp_read_addr
suffix:semicolon
id|pb-&gt;ops-&gt;epp_write_addr
op_assign
id|parport_pc_ecpepp_write_addr
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#else /* No IEEE 1284 support */
multiline_comment|/* Don&squot;t bother probing for modes we know we won&squot;t use. */
DECL|function|parport_PS2_supported
r_static
r_int
id|__devinit
id|parport_PS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECP_supported
r_static
r_int
id|__devinit
id|parport_ECP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_EPP_supported
r_static
r_int
id|__devinit
id|parport_EPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECPEPP_supported
r_static
r_int
id|__devinit
(def_block
id|parport_ECPEPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
DECL|function|parport_ECPPS2_supported
r_static
r_int
id|__devinit
(def_block
id|parport_ECPPS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
macro_line|#endif /* No IEEE 1284 support */
multiline_comment|/* --- IRQ detection -------------------------------------- */
multiline_comment|/* Only if supports ECP mode */
DECL|function|programmable_irq_support
r_static
r_int
id|__devinit
id|programmable_irq_support
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irq
comma
id|intrLine
suffix:semicolon
r_int
r_char
id|oecr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_static
r_const
r_int
id|lookup
(braket
l_int|8
)braket
op_assign
(brace
id|PARPORT_IRQ_NONE
comma
l_int|7
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|14
comma
l_int|15
comma
l_int|5
)brace
suffix:semicolon
id|outb
(paren
id|ECR_CNF
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Configuration MODE */
id|intrLine
op_assign
(paren
id|inb
(paren
id|CONFIGB
(paren
id|pb
)paren
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x07
suffix:semicolon
id|irq
op_assign
id|lookup
(braket
id|intrLine
)braket
suffix:semicolon
id|outb
(paren
id|oecr
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|irq_probe_ECP
r_static
r_int
id|__devinit
id|irq_probe_ECP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|irqs
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|outb
(paren
id|ECR_SPP
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO */
id|outb
(paren
(paren
id|ECR_TST
op_lshift
l_int|5
)paren
op_or
l_int|0x04
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|outb
(paren
id|ECR_TST
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
multiline_comment|/* If Full FIFO sure that writeIntrThreshold is generated */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
op_logical_neg
(paren
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
op_amp
l_int|0x02
)paren
suffix:semicolon
id|i
op_increment
)paren
id|outb
(paren
l_int|0xaa
comma
id|FIFO
(paren
id|pb
)paren
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|outb
(paren
id|ECR_SPP
op_lshift
l_int|5
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_le
l_int|0
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
multiline_comment|/*&n; * This detection seems that only works in National Semiconductors&n; * This doesn&squot;t work in SMC, LGS, and Winbond &n; */
DECL|function|irq_probe_EPP
r_static
r_int
id|__devinit
id|irq_probe_EPP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
macro_line|#ifndef ADVANCED_DETECT
r_return
id|PARPORT_IRQ_NONE
suffix:semicolon
macro_line|#else
r_int
id|irqs
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|oecr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|frob_econtrol
(paren
id|pb
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Device isn&squot;t expecting an EPP read&n;&t; * and generates an IRQ.&n;&t; */
id|parport_pc_read_epp
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|probe_irq_off
(paren
id|irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|outb
(paren
id|oecr
comma
id|ECONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0xc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_le
l_int|0
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
macro_line|#endif /* Advanced detection */
)brace
DECL|function|irq_probe_SPP
r_static
r_int
id|__devinit
id|irq_probe_SPP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
multiline_comment|/* Don&squot;t even try to do this. */
r_return
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/* We will attempt to share interrupt requests since other devices&n; * such as sound cards and network cards seem to like using the&n; * printer IRQs.&n; *&n; * When ECP is available we can autoprobe for IRQs.&n; * NOTE: If we can autoprobe it, we can register the IRQ.&n; */
DECL|function|parport_irq_probe
r_static
r_int
id|__devinit
id|parport_irq_probe
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|pb-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
(brace
id|pb-&gt;irq
op_assign
id|programmable_irq_support
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_ECP
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
id|priv-&gt;ecr
op_logical_and
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_EPP
)paren
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_EPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_EPP
)paren
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_EPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|clear_epp_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_SPP
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|pb-&gt;irq
op_assign
id|get_superio_irq
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
multiline_comment|/* --- DMA detection -------------------------------------- */
multiline_comment|/* Only if chipset conforms to ECP ISA Interface Standard */
DECL|function|programmable_dma_support
r_static
r_int
id|__devinit
id|programmable_dma_support
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_int
r_char
id|oecr
op_assign
id|inb
(paren
id|ECONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
r_int
id|dma
suffix:semicolon
id|frob_econtrol
(paren
id|p
comma
l_int|0xe0
comma
id|ECR_CNF
op_lshift
l_int|5
)paren
suffix:semicolon
id|dma
op_assign
id|inb
(paren
id|CONFIGB
c_func
(paren
id|p
)paren
)paren
op_amp
l_int|0x07
suffix:semicolon
multiline_comment|/* 000: Indicates jumpered 8-bit DMA if read-only.&n;&t;   100: Indicates jumpered 16-bit DMA if read-only. */
r_if
c_cond
(paren
(paren
id|dma
op_amp
l_int|0x03
)paren
op_eq
l_int|0
)paren
id|dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
id|outb
(paren
id|oecr
comma
id|ECONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
r_return
id|dma
suffix:semicolon
)brace
DECL|function|parport_dma_probe
r_static
r_int
id|__devinit
id|parport_dma_probe
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_const
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
id|p-&gt;dma
op_assign
id|programmable_dma_support
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* ask ECP chipset first */
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_NONE
)paren
multiline_comment|/* ask known Super-IO chips proper, although these&n;&t;&t;   claim ECP compatible, some don&squot;t report their DMA&n;&t;&t;   conforming to ECP standards */
id|p-&gt;dma
op_assign
id|get_superio_dma
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|p-&gt;dma
suffix:semicolon
)brace
multiline_comment|/* --- Initialisation code -------------------------------- */
DECL|function|parport_pc_probe_port
r_struct
id|parport
op_star
id|__devinit
id|parport_pc_probe_port
(paren
r_int
r_int
r_int
id|base
comma
r_int
r_int
r_int
id|base_hi
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
suffix:semicolon
r_struct
id|parport_operations
op_star
id|ops
suffix:semicolon
r_struct
id|parport
id|tmp
suffix:semicolon
r_struct
id|parport
op_star
id|p
op_assign
op_amp
id|tmp
suffix:semicolon
r_int
id|probedirq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|3
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|parport_pc_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport (0x%lx): no memory!&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ops
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|parport_operations
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ops
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport (0x%lx): no memory for ops!&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|kfree
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
(paren
id|ops
comma
op_amp
id|parport_pc_ops
comma
r_sizeof
(paren
r_struct
id|parport_operations
)paren
)paren
suffix:semicolon
id|priv-&gt;ctr
op_assign
l_int|0xc
suffix:semicolon
id|priv-&gt;ctr_writable
op_assign
l_int|0xff
suffix:semicolon
id|priv-&gt;ecr
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;fifo_depth
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dma_buf
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dma_handle
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dev
op_assign
id|dev
suffix:semicolon
id|p-&gt;base
op_assign
id|base
suffix:semicolon
id|p-&gt;base_hi
op_assign
id|base_hi
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;dma
op_assign
id|dma
suffix:semicolon
id|p-&gt;modes
op_assign
id|PARPORT_MODE_PCSPP
op_or
id|PARPORT_MODE_SAFEININT
suffix:semicolon
id|p-&gt;ops
op_assign
id|ops
suffix:semicolon
id|p-&gt;private_data
op_assign
id|priv
suffix:semicolon
id|p-&gt;physport
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|base_hi
op_logical_and
op_logical_neg
id|check_region
c_func
(paren
id|base_hi
comma
l_int|3
)paren
)paren
(brace
id|parport_ECR_present
c_func
(paren
id|p
)paren
suffix:semicolon
id|parport_ECP_supported
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_ne
l_int|0x3bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|base
op_plus
l_int|0x3
comma
l_int|5
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|parport_EPP_supported
c_func
(paren
id|p
)paren
)paren
id|parport_ECPEPP_supported
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|parport_SPP_supported
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* No port. */
id|kfree
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
id|parport_ECPPS2_supported
c_func
(paren
id|p
)paren
suffix:semicolon
r_else
id|parport_PS2_supported
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|parport_register_port
c_func
(paren
id|base
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
comma
id|ops
)paren
)paren
)paren
(brace
id|kfree
(paren
id|priv
)paren
suffix:semicolon
id|kfree
(paren
id|ops
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|p-&gt;base_hi
op_assign
id|base_hi
suffix:semicolon
id|p-&gt;modes
op_assign
id|tmp.modes
suffix:semicolon
id|p-&gt;size
op_assign
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_EPP
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|3
suffix:semicolon
id|p-&gt;private_data
op_assign
id|priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: PC-style at 0x%lx&quot;
comma
id|p-&gt;name
comma
id|p-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;base_hi
op_logical_and
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
)paren
id|printk
c_func
(paren
l_string|&quot; (0x%lx)&quot;
comma
id|p-&gt;base_hi
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;dma
op_assign
id|dma
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_eq
id|PARPORT_IRQ_AUTO
)paren
(brace
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|parport_irq_probe
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;irq
op_eq
id|PARPORT_IRQ_PROBEONLY
)paren
(brace
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|parport_irq_probe
c_func
(paren
id|p
)paren
suffix:semicolon
id|probedirq
op_assign
id|p-&gt;irq
suffix:semicolon
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, irq %d&quot;
comma
id|p-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_AUTO
)paren
(brace
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
id|parport_dma_probe
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_AUTO
)paren
multiline_comment|/* To use DMA, giving the irq&n;                                           is mandatory (see above) */
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_PC_FIFO
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NOFIFO
op_logical_and
id|priv-&gt;fifo_depth
OG
l_int|0
op_logical_and
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|p-&gt;ops-&gt;compat_write_data
op_assign
id|parport_pc_compat_write_block_pio
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_1284
id|p-&gt;ops-&gt;ecp_write_data
op_assign
id|parport_pc_ecp_write_block_pio
suffix:semicolon
macro_line|#endif /* IEEE 1284 support */
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, dma %d&quot;
comma
id|p-&gt;dma
)paren
suffix:semicolon
id|p-&gt;modes
op_or_assign
id|PARPORT_MODE_DMA
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, using FIFO&quot;
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* We can&squot;t use the DMA channel after all. */
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
macro_line|#endif /* Allowed to use FIFO/DMA */
id|printk
c_func
(paren
l_string|&quot; [&quot;
)paren
suffix:semicolon
DECL|macro|printmode
mdefine_line|#define printmode(x) {if(p-&gt;modes&amp;PARPORT_MODE_##x){printk(&quot;%s%s&quot;,f?&quot;,&quot;:&quot;&quot;,#x);f++;}}
(brace
r_int
id|f
op_assign
l_int|0
suffix:semicolon
id|printmode
c_func
(paren
id|PCSPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|TRISTATE
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|COMPAT
)paren
id|printmode
c_func
(paren
id|EPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|DMA
)paren
suffix:semicolon
)brace
DECL|macro|printmode
macro_line|#undef printmode
macro_line|#ifndef CONFIG_PARPORT_1284
id|printk
(paren
l_string|&quot;(,...)&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PARPORT_1284 */
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probedirq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: irq %d detected&bslash;n&quot;
comma
id|p-&gt;name
comma
id|probedirq
)paren
suffix:semicolon
id|parport_proc_register
c_func
(paren
id|p
)paren
suffix:semicolon
id|request_region
(paren
id|p-&gt;base
comma
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;size
OG
l_int|3
)paren
id|request_region
(paren
id|p-&gt;base
op_plus
l_int|3
comma
id|p-&gt;size
op_minus
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
id|request_region
(paren
id|p-&gt;base_hi
comma
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
r_if
c_cond
(paren
id|request_irq
(paren
id|p-&gt;irq
comma
id|parport_pc_interrupt
comma
l_int|0
comma
id|p-&gt;name
comma
id|p
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d in use, &quot;
l_string|&quot;resorting to polled operation&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;irq
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_PC_FIFO
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
(brace
r_if
c_cond
(paren
id|request_dma
(paren
id|p-&gt;dma
comma
id|p-&gt;name
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: dma %d in use, &quot;
l_string|&quot;resorting to PIO operation&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;dma
)paren
suffix:semicolon
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;dma_buf
op_assign
id|pci_alloc_consistent
c_func
(paren
id|priv-&gt;dev
comma
id|PAGE_SIZE
comma
op_amp
id|priv-&gt;dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dma_buf
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: &quot;
l_string|&quot;cannot get buffer for DMA, &quot;
l_string|&quot;resorting to PIO operation&bslash;n&quot;
comma
id|p-&gt;name
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|p-&gt;dma
)paren
suffix:semicolon
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_PARPORT_PC_FIFO */
)brace
multiline_comment|/* Done probing.  Now put the port into a sensible start-up state. */
r_if
c_cond
(paren
id|priv-&gt;ecr
)paren
multiline_comment|/*&n;&t;&t; * Put the ECP detected port in PS2 mode.&n;&t;&t; * Do this also for ports that have ECR but don&squot;t do ECP.&n;&t;&t; */
id|outb
(paren
l_int|0x34
comma
id|ECONTROL
(paren
id|p
)paren
)paren
suffix:semicolon
id|parport_pc_write_data
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
id|parport_pc_data_forward
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Now that we&squot;ve told the sharing engine about the port, and&n;&t;   found out its characteristics, let the high-level drivers&n;&t;   know about it. */
id|parport_announce_port
(paren
id|p
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* Via support maintained by Jeff Garzik &lt;jgarzik@mandrakesoft.com&gt; */
DECL|function|sio_via_686a_probe
r_static
r_int
id|__devinit
id|sio_via_686a_probe
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|u8
id|tmp
suffix:semicolon
r_int
id|dma
comma
id|irq
suffix:semicolon
r_int
id|port1
comma
id|port2
comma
id|have_eppecp
suffix:semicolon
multiline_comment|/*&n;&t; * unlock super i/o configuration, set 0x85_1&n;&t; */
id|pci_read_config_byte
(paren
id|pdev
comma
l_int|0x85
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|pdev
comma
l_int|0x85
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Super I/O configuration, index port == 3f0h, data port == 3f1h&n;&t; */
multiline_comment|/* 0xE2_1-0: Parallel Port Mode / Enable */
id|outb
(paren
l_int|0xE2
comma
l_int|0x3F0
)paren
suffix:semicolon
id|tmp
op_assign
id|inb
(paren
l_int|0x3F1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x03
)paren
op_eq
l_int|0x03
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;parport_pc: Via 686A parallel port disabled in BIOS&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 0xE6: Parallel Port I/O Base Address, bits 9-2 */
id|outb
(paren
l_int|0xE6
comma
l_int|0x3F0
)paren
suffix:semicolon
id|port1
op_assign
id|inb
(paren
l_int|0x3F1
)paren
op_lshift
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|port1
)paren
(brace
r_case
l_int|0x3bc
suffix:colon
id|port2
op_assign
l_int|0x7bc
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x378
suffix:colon
id|port2
op_assign
l_int|0x778
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x278
suffix:colon
id|port2
op_assign
l_int|0x678
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;parport_pc: Via 686A weird parport base 0x%X, ignoring&bslash;n&quot;
comma
id|port1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 0xF0_5: EPP+ECP enable */
id|outb
(paren
l_int|0xF0
comma
l_int|0x3F0
)paren
suffix:semicolon
id|have_eppecp
op_assign
(paren
id|inb
(paren
l_int|0x3F1
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * lock super i/o configuration, clear 0x85_1&n;&t; */
id|pci_read_config_byte
(paren
id|pdev
comma
l_int|0x85
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|pdev
comma
l_int|0x85
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get DMA and IRQ from PCI-&gt;ISA bridge PCI config registers&n;&t; */
multiline_comment|/* 0x50_3-2: PnP Routing for Parallel Port DRQ */
id|pci_read_config_byte
(paren
id|pdev
comma
l_int|0x50
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|dma
op_assign
(paren
(paren
id|tmp
op_rshift
l_int|2
)paren
op_amp
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* 0x51_7-4: PnP Routing for Parallel Port IRQ */
id|pci_read_config_byte
(paren
id|pdev
comma
l_int|0x51
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|irq
op_assign
(paren
(paren
id|tmp
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
multiline_comment|/* filter bogus IRQs */
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|13
suffix:colon
id|irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* do nothing */
r_break
suffix:semicolon
)brace
multiline_comment|/* if ECP not enabled, DMA is not enabled, assumed bogus &squot;dma&squot; value */
r_if
c_cond
(paren
op_logical_neg
id|have_eppecp
)paren
id|dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
multiline_comment|/* finally, do the probe with values obtained */
r_if
c_cond
(paren
id|parport_pc_probe_port
(paren
id|port1
comma
id|port2
comma
id|irq
comma
id|dma
comma
l_int|NULL
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;parport_pc: Via 686A parallel port: io=0x%X&quot;
comma
id|port1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|printk
(paren
l_string|&quot;, irq=%d&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|printk
(paren
l_string|&quot;, dma=%d&quot;
comma
id|dma
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;parport_pc: Strange, can&squot;t probe Via 686A parallel port: io=0x%X, irq=%d, dma=%d&bslash;n&quot;
comma
id|port1
comma
id|irq
comma
id|dma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|enum|parport_pc_sio_types
r_enum
id|parport_pc_sio_types
(brace
DECL|enumerator|sio_via_686a
id|sio_via_686a
op_assign
l_int|0
comma
multiline_comment|/* Via VT82C686A motherboard Super I/O */
DECL|enumerator|last_sio
id|last_sio
)brace
suffix:semicolon
multiline_comment|/* each element directly indexed from enum list, above */
DECL|struct|parport_pc_superio
r_static
r_struct
id|parport_pc_superio
(brace
DECL|member|probe
r_int
(paren
op_star
id|probe
)paren
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
DECL|variable|__devinitdata
)brace
id|parport_pc_superio_info
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|sio_via_686a_probe
comma
)brace
comma
)brace
suffix:semicolon
DECL|enum|parport_pc_pci_cards
r_enum
id|parport_pc_pci_cards
(brace
DECL|enumerator|siig_1s1p_10x_550
id|siig_1s1p_10x_550
op_assign
id|last_sio
comma
DECL|enumerator|siig_1s1p_10x_650
id|siig_1s1p_10x_650
comma
DECL|enumerator|siig_1s1p_10x_850
id|siig_1s1p_10x_850
comma
DECL|enumerator|siig_1p_10x
id|siig_1p_10x
comma
DECL|enumerator|siig_2p_10x
id|siig_2p_10x
comma
DECL|enumerator|siig_2s1p_10x_550
id|siig_2s1p_10x_550
comma
DECL|enumerator|siig_2s1p_10x_650
id|siig_2s1p_10x_650
comma
DECL|enumerator|siig_2s1p_10x_850
id|siig_2s1p_10x_850
comma
DECL|enumerator|siig_1p_20x
id|siig_1p_20x
comma
DECL|enumerator|siig_2p_20x
id|siig_2p_20x
comma
DECL|enumerator|siig_2p1s_20x_550
id|siig_2p1s_20x_550
comma
DECL|enumerator|siig_2p1s_20x_650
id|siig_2p1s_20x_650
comma
DECL|enumerator|siig_2p1s_20x_850
id|siig_2p1s_20x_850
comma
DECL|enumerator|siig_1s1p_20x_550
id|siig_1s1p_20x_550
comma
DECL|enumerator|siig_1s1p_20x_650
id|siig_1s1p_20x_650
comma
DECL|enumerator|siig_1s1p_20x_850
id|siig_1s1p_20x_850
comma
DECL|enumerator|siig_2s1p_20x_550
id|siig_2s1p_20x_550
comma
DECL|enumerator|siig_2s1p_20x_650
id|siig_2s1p_20x_650
comma
DECL|enumerator|siig_2s1p_20x_850
id|siig_2s1p_20x_850
comma
DECL|enumerator|lava_parallel
id|lava_parallel
comma
DECL|enumerator|lava_parallel_dual_a
id|lava_parallel_dual_a
comma
DECL|enumerator|lava_parallel_dual_b
id|lava_parallel_dual_b
comma
DECL|enumerator|boca_ioppar
id|boca_ioppar
comma
DECL|enumerator|plx_9050
id|plx_9050
comma
DECL|enumerator|afavlab_tk9902
id|afavlab_tk9902
comma
DECL|enumerator|timedia_4078a
id|timedia_4078a
comma
DECL|enumerator|timedia_4079h
id|timedia_4079h
comma
DECL|enumerator|timedia_4085h
id|timedia_4085h
comma
DECL|enumerator|timedia_4088a
id|timedia_4088a
comma
DECL|enumerator|timedia_4089a
id|timedia_4089a
comma
DECL|enumerator|timedia_4095a
id|timedia_4095a
comma
DECL|enumerator|timedia_4096a
id|timedia_4096a
comma
DECL|enumerator|timedia_4078u
id|timedia_4078u
comma
DECL|enumerator|timedia_4079a
id|timedia_4079a
comma
DECL|enumerator|timedia_4085u
id|timedia_4085u
comma
DECL|enumerator|timedia_4079r
id|timedia_4079r
comma
DECL|enumerator|timedia_4079s
id|timedia_4079s
comma
DECL|enumerator|timedia_4079d
id|timedia_4079d
comma
DECL|enumerator|timedia_4079e
id|timedia_4079e
comma
DECL|enumerator|timedia_4079f
id|timedia_4079f
comma
DECL|enumerator|timedia_9079a
id|timedia_9079a
comma
DECL|enumerator|timedia_9079b
id|timedia_9079b
comma
DECL|enumerator|timedia_9079c
id|timedia_9079c
comma
DECL|enumerator|timedia_4006a
id|timedia_4006a
comma
DECL|enumerator|timedia_4014
id|timedia_4014
comma
DECL|enumerator|timedia_4008a
id|timedia_4008a
comma
DECL|enumerator|timedia_4018
id|timedia_4018
comma
DECL|enumerator|timedia_9018a
id|timedia_9018a
comma
DECL|enumerator|syba_2p_epp
id|syba_2p_epp
comma
DECL|enumerator|syba_1p_ecp
id|syba_1p_ecp
comma
)brace
suffix:semicolon
multiline_comment|/* each element directly indexed from enum list, above &n; * (but offset by last_sio) */
DECL|struct|parport_pc_pci
r_static
r_struct
id|parport_pc_pci
(brace
DECL|member|numports
r_int
id|numports
suffix:semicolon
r_struct
(brace
multiline_comment|/* BAR (base address registers) numbers in the config&n;                    space header */
DECL|member|lo
r_int
id|lo
suffix:semicolon
DECL|member|hi
r_int
id|hi
suffix:semicolon
multiline_comment|/* -1 if not there, &gt;6 for offset-method (max&n;                           BAR is 6) */
DECL|member|addr
)brace
id|addr
(braket
l_int|4
)braket
suffix:semicolon
DECL|variable|__devinitdata
)brace
id|cards
(braket
)braket
id|__devinitdata
op_assign
(brace
multiline_comment|/* siig_1s1p_10x_550 */
(brace
l_int|1
comma
(brace
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1s1p_10x_650 */
(brace
l_int|1
comma
(brace
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1s1p_10x_850 */
(brace
l_int|1
comma
(brace
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1p_10x */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2p_10x */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2s1p_10x_550 */
(brace
l_int|1
comma
(brace
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2s1p_10x_650 */
(brace
l_int|1
comma
(brace
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2s1p_10x_850 */
(brace
l_int|1
comma
(brace
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1p_20x */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2p_20x */
(brace
l_int|2
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2p1s_20x_550 */
(brace
l_int|2
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2p1s_20x_650 */
(brace
l_int|2
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2p1s_20x_850 */
(brace
l_int|2
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1s1p_20x_550 */
(brace
l_int|1
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1s1p_20x_650 */
(brace
l_int|1
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_1s1p_20x_850 */
(brace
l_int|1
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2s1p_20x_550 */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2s1p_20x_650 */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* siig_2s1p_20x_850 */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* lava_parallel */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* lava_parallel_dual_a */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* lava_parallel_dual_b */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* boca_ioppar */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* plx_9050 */
(brace
l_int|2
comma
(brace
(brace
l_int|4
comma
op_minus
l_int|1
)brace
comma
(brace
l_int|5
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* afavlab_tk9902 */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4078a */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079h */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4085h */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
op_minus
l_int|1
)brace
comma
(brace
l_int|4
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4088a */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4089a */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4095a */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4096a */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4078u */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079a */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4085u */
(brace
l_int|2
comma
(brace
(brace
l_int|2
comma
op_minus
l_int|1
)brace
comma
(brace
l_int|4
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079r */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079s */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079d */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079e */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4079f */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_9079a */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_9079b */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_9079c */
(brace
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4006a */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4014  */
(brace
l_int|2
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
(brace
l_int|2
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4008a */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_4018  */
(brace
l_int|2
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* timedia_9018a */
(brace
l_int|2
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
multiline_comment|/* SYBA uses fixed offsets in&n;                                           a 1K io window */
multiline_comment|/* syba_2p_epp AP138B */
(brace
l_int|2
comma
(brace
(brace
l_int|0
comma
l_int|0x078
)brace
comma
(brace
l_int|0
comma
l_int|0x178
)brace
comma
)brace
)brace
comma
multiline_comment|/* syba_1p_ecp W83787 */
(brace
l_int|1
comma
(brace
(brace
l_int|0
comma
l_int|0x078
)brace
comma
)brace
)brace
comma
)brace
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|parport_pc_pci_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
multiline_comment|/* Super-IO onboard chips */
(brace
l_int|0x1106
comma
l_int|0x0686
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|sio_via_686a
)brace
comma
multiline_comment|/* PCI cards */
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_10x_550
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1s1p_10x_550
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_10x_650
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1s1p_10x_650
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_10x_850
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1s1p_10x_850
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1P_10x
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1p_10x
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P_10x
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2p_10x
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_10x_550
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_10x_550
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_10x_650
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_10x_650
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_10x_850
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_10x_850
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1P_20x
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1p_20x
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P_20x
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2p_20x
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P1S_20x_550
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2p1s_20x_550
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P1S_20x_650
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2p1s_20x_650
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P1S_20x_850
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2p1s_20x_850
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_20x_550
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_20x_550
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_20x_650
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1s1p_20x_650
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_20x_850
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_1s1p_20x_850
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_20x_550
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_20x_550
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_20x_650
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_20x_650
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_20x_850
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|siig_2s1p_20x_850
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_PARALLEL
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|lava_parallel
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_DUAL_PAR_A
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|lava_parallel_dual_a
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_DUAL_PAR_B
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|lava_parallel_dual_b
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_BOCA_IOPPAR
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|boca_ioppar
)brace
comma
(brace
id|PCI_VENDOR_ID_PLX
comma
id|PCI_DEVICE_ID_PLX_9050
comma
id|PCI_SUBVENDOR_ID_EXSYS
comma
id|PCI_SUBDEVICE_ID_EXSYS_4014
comma
l_int|0
comma
l_int|0
comma
id|plx_9050
)brace
comma
(brace
id|PCI_VENDOR_ID_AFAVLAB
comma
id|PCI_DEVICE_ID_AFAVLAB_TK9902
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|afavlab_tk9902
)brace
comma
multiline_comment|/* PCI_VENDOR_ID_TIMEDIA/SUNIX has many differing cards ...*/
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4078
comma
l_int|0
comma
l_int|0
comma
id|timedia_4078a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079h
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4085
comma
l_int|0
comma
l_int|0
comma
id|timedia_4085h
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4088
comma
l_int|0
comma
l_int|0
comma
id|timedia_4088a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4089
comma
l_int|0
comma
l_int|0
comma
id|timedia_4089a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4095
comma
l_int|0
comma
l_int|0
comma
id|timedia_4095a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x4096
comma
l_int|0
comma
l_int|0
comma
id|timedia_4096a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x5078
comma
l_int|0
comma
l_int|0
comma
id|timedia_4078u
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x5079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x5085
comma
l_int|0
comma
l_int|0
comma
id|timedia_4085u
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x6079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079r
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x7079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079s
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x8079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079d
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0x9079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079e
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0xa079
comma
l_int|0
comma
l_int|0
comma
id|timedia_4079f
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0xb079
comma
l_int|0
comma
l_int|0
comma
id|timedia_9079a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0xc079
comma
l_int|0
comma
l_int|0
comma
id|timedia_9079b
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7168
comma
l_int|0x1409
comma
l_int|0xd079
comma
l_int|0
comma
l_int|0
comma
id|timedia_9079c
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7268
comma
l_int|0x1409
comma
l_int|0x0101
comma
l_int|0
comma
l_int|0
comma
id|timedia_4006a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7268
comma
l_int|0x1409
comma
l_int|0x0102
comma
l_int|0
comma
l_int|0
comma
id|timedia_4014
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7268
comma
l_int|0x1409
comma
l_int|0x0103
comma
l_int|0
comma
l_int|0
comma
id|timedia_4008a
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7268
comma
l_int|0x1409
comma
l_int|0x0104
comma
l_int|0
comma
l_int|0
comma
id|timedia_4018
)brace
comma
(brace
l_int|0x1409
comma
l_int|0x7268
comma
l_int|0x1409
comma
l_int|0x9018
comma
l_int|0
comma
l_int|0
comma
id|timedia_9018a
)brace
comma
(brace
id|PCI_VENDOR_ID_SYBA
comma
id|PCI_DEVICE_ID_SYBA_2P_EPP
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|syba_2p_epp
)brace
comma
(brace
id|PCI_VENDOR_ID_SYBA
comma
id|PCI_DEVICE_ID_SYBA_1P_ECP
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|syba_1p_ecp
)brace
comma
(brace
l_int|0
comma
)brace
multiline_comment|/* terminate list */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|parport_pc_pci_tbl
)paren
suffix:semicolon
DECL|function|parport_pc_pci_probe
r_static
r_int
id|__devinit
id|parport_pc_pci_probe
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_int
id|err
comma
id|count
comma
id|n
comma
id|i
op_assign
id|id-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|last_sio
)paren
multiline_comment|/* This is an onboard Super-IO and has already been probed */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* This is a PCI card */
id|i
op_sub_assign
id|last_sio
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|pci_enable_device
(paren
id|dev
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|cards
(braket
id|i
)braket
dot
id|numports
suffix:semicolon
id|n
op_increment
)paren
(brace
r_int
id|lo
op_assign
id|cards
(braket
id|i
)braket
dot
id|addr
(braket
id|n
)braket
dot
id|lo
suffix:semicolon
r_int
id|hi
op_assign
id|cards
(braket
id|i
)braket
dot
id|addr
(braket
id|n
)braket
dot
id|hi
suffix:semicolon
r_int
r_int
id|io_lo
comma
id|io_hi
suffix:semicolon
id|io_lo
op_assign
id|pci_resource_start
(paren
id|dev
comma
id|lo
)paren
suffix:semicolon
id|io_hi
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hi
op_ge
l_int|0
)paren
op_logical_and
(paren
id|hi
op_le
l_int|6
)paren
)paren
id|io_hi
op_assign
id|pci_resource_start
(paren
id|dev
comma
id|hi
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hi
OG
l_int|6
)paren
id|io_lo
op_add_assign
id|hi
suffix:semicolon
multiline_comment|/* Reinterpret the meaning of&n;                                        &quot;hi&quot; as an offset (see SYBA&n;                                        def.) */
multiline_comment|/* TODO: test if sharing interrupts works */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;PCI parallel port detected: %04x:%04x, &quot;
l_string|&quot;I/O at %#lx(%#lx)&bslash;n&quot;
comma
id|parport_pc_pci_tbl
(braket
id|i
op_plus
id|last_sio
)braket
dot
id|vendor
comma
id|parport_pc_pci_tbl
(braket
id|i
op_plus
id|last_sio
)braket
dot
id|device
comma
id|io_lo
comma
id|io_hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_probe_port
(paren
id|io_lo
comma
id|io_hi
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
comma
id|dev
)paren
)paren
id|count
op_increment
suffix:semicolon
)brace
r_return
id|count
op_eq
l_int|0
ques
c_cond
op_minus
id|ENODEV
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|variable|parport_pc_pci_driver
r_static
r_struct
id|pci_driver
id|parport_pc_pci_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;parport_pc&quot;
comma
id|id_table
suffix:colon
id|parport_pc_pci_tbl
comma
id|probe
suffix:colon
id|parport_pc_pci_probe
comma
)brace
suffix:semicolon
DECL|function|parport_pc_init_superio
r_static
r_int
id|__init
id|parport_pc_init_superio
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_const
r_struct
id|pci_device_id
op_star
id|id
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|pci_for_each_dev
c_func
(paren
id|pdev
)paren
(brace
id|id
op_assign
id|pci_match_device
(paren
id|parport_pc_pci_tbl
comma
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|NULL
op_logical_or
id|id-&gt;driver_data
op_ge
id|last_sio
)paren
r_continue
suffix:semicolon
r_return
id|parport_pc_superio_info
(braket
id|id-&gt;driver_data
)braket
dot
id|probe
(paren
id|pdev
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PCI */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* zero devices found */
)brace
multiline_comment|/* This is called by parport_pc_find_nonpci_ports (in asm/parport.h) */
r_static
r_int
id|__init
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
DECL|function|parport_pc_find_isa_ports
id|parport_pc_find_isa_ports
(paren
r_int
id|autoirq
comma
r_int
id|autodma
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_probe_port
c_func
(paren
l_int|0x3bc
comma
l_int|0x7bc
comma
id|autoirq
comma
id|autodma
comma
l_int|NULL
)paren
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_probe_port
c_func
(paren
l_int|0x378
comma
l_int|0x778
comma
id|autoirq
comma
id|autodma
comma
l_int|NULL
)paren
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_probe_port
c_func
(paren
l_int|0x278
comma
l_int|0x678
comma
id|autoirq
comma
id|autodma
comma
l_int|NULL
)paren
)paren
id|count
op_increment
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* This function is called by parport_pc_init if the user didn&squot;t&n; * specify any ports to probe.  Its job is to find some ports.  Order&n; * is important here -- we want ISA ports to be registered first,&n; * followed by PCI cards (for least surprise), but before that we want&n; * to do chipset-specific tests for some onboard ports that we know&n; * about.&n; *&n; * autoirq is PARPORT_IRQ_NONE, PARPORT_IRQ_AUTO, or PARPORT_IRQ_PROBEONLY&n; * autodma is PARPORT_DMA_NONE or PARPORT_DMA_AUTO&n; */
DECL|function|parport_pc_find_ports
r_static
r_int
id|__init
id|parport_pc_find_ports
(paren
r_int
id|autoirq
comma
r_int
id|autodma
)paren
(brace
r_int
id|count
op_assign
l_int|0
comma
id|r
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_PC_SUPERIO
id|detect_and_report_winbond
(paren
)paren
suffix:semicolon
id|detect_and_report_smsc
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Onboard SuperIO chipsets that show themselves on the PCI bus. */
id|count
op_add_assign
id|parport_pc_init_superio
(paren
)paren
suffix:semicolon
multiline_comment|/* ISA ports and whatever (see asm/parport.h). */
id|count
op_add_assign
id|parport_pc_find_nonpci_ports
(paren
id|autoirq
comma
id|autodma
)paren
suffix:semicolon
id|r
op_assign
id|pci_register_driver
(paren
op_amp
id|parport_pc_pci_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
id|count
op_add_assign
id|r
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|parport_pc_init
r_int
id|__init
id|parport_pc_init
(paren
r_int
op_star
id|io
comma
r_int
op_star
id|io_hi
comma
r_int
op_star
id|irq
comma
r_int
op_star
id|dma
)paren
(brace
r_int
id|count
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|io
op_logical_and
op_star
id|io
)paren
(brace
multiline_comment|/* Only probe the ports we were given. */
id|user_specified
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|io_hi
)paren
op_star
id|io_hi
op_assign
l_int|0x400
op_plus
op_star
id|io
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_probe_port
c_func
(paren
op_star
(paren
id|io
op_increment
)paren
comma
op_star
(paren
id|io_hi
op_increment
)paren
comma
op_star
(paren
id|irq
op_increment
)paren
comma
op_star
(paren
id|dma
op_increment
)paren
comma
l_int|NULL
)paren
)paren
id|count
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|io
op_logical_and
(paren
op_increment
id|i
OL
id|PARPORT_PC_MAX_PORTS
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|count
op_add_assign
id|parport_pc_find_ports
(paren
id|irq
(braket
l_int|0
)braket
comma
id|dma
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Exported symbols. */
macro_line|#ifdef CONFIG_PARPORT_PC_PCMCIA
multiline_comment|/* parport_cs needs this in order to dyncamically get us to find ports. */
DECL|variable|parport_pc_probe_port
id|EXPORT_SYMBOL
(paren
id|parport_pc_probe_port
)paren
suffix:semicolon
macro_line|#else
id|EXPORT_NO_SYMBOLS
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
DECL|variable|io
r_static
r_int
id|io
(braket
id|PARPORT_PC_MAX_PORTS
op_plus
l_int|1
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
l_int|0
)brace
suffix:semicolon
DECL|variable|io_hi
r_static
r_int
id|io_hi
(braket
id|PARPORT_PC_MAX_PORTS
op_plus
l_int|1
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
l_int|0
)brace
suffix:semicolon
DECL|variable|dmaval
r_static
r_int
id|dmaval
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
op_minus
l_int|1
)braket
op_assign
id|PARPORT_DMA_AUTO
)brace
suffix:semicolon
DECL|variable|irqval
r_static
r_int
id|irqval
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
op_minus
l_int|1
)braket
op_assign
id|PARPORT_IRQ_PROBEONLY
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_const
r_char
op_star
id|irq
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|dma
r_static
r_const
r_char
op_star
id|dma
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Phil Blundell, Tim Waugh, others&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;PC-style parallel port driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;Base I/O address (SPP regs)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io_hi
comma
l_string|&quot;Base I/O address (ECR)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io_hi
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;IRQ line&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dma
comma
l_string|&quot;DMA channel&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Work out how many ports we have, then get parport_share to parse&n;&t;   the irq values. */
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PARPORT_PC_MAX_PORTS
op_logical_and
id|io
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
id|parport_parse_irqs
c_func
(paren
id|i
comma
id|irq
comma
id|irqval
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|parport_parse_dmas
c_func
(paren
id|i
comma
id|dma
comma
id|dmaval
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The user can make us use any IRQs or DMAs we find. */
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|irq
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|parport_parse_irqs
(paren
l_int|1
comma
id|irq
comma
op_amp
id|val
)paren
)paren
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|PARPORT_IRQ_NONE
suffix:colon
r_case
id|PARPORT_IRQ_AUTO
suffix:colon
id|irqval
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|parport_parse_dmas
(paren
l_int|1
comma
id|dma
comma
op_amp
id|val
)paren
)paren
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|PARPORT_DMA_NONE
suffix:colon
r_case
id|PARPORT_DMA_AUTO
suffix:colon
id|dmaval
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
)brace
)brace
r_return
op_logical_neg
id|parport_pc_init
(paren
id|io
comma
id|io_hi
comma
id|irqval
comma
id|dmaval
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* We ought to keep track of which ports are actually ours. */
r_struct
id|parport
op_star
id|p
op_assign
id|parport_enumerate
c_func
(paren
)paren
comma
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user_specified
)paren
id|pci_unregister_driver
(paren
op_amp
id|parport_pc_pci_driver
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|tmp
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCSPP
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;private_data
suffix:semicolon
r_struct
id|parport_operations
op_star
id|ops
op_assign
id|p-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|free_dma
c_func
(paren
id|p-&gt;dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|free_irq
c_func
(paren
id|p-&gt;irq
comma
id|p
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|p-&gt;base
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;size
OG
l_int|3
)paren
id|release_region
c_func
(paren
id|p-&gt;base
op_plus
l_int|3
comma
id|p-&gt;size
op_minus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
id|release_region
c_func
(paren
id|p-&gt;base_hi
comma
l_int|3
)paren
suffix:semicolon
id|parport_proc_unregister
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;dma_buf
)paren
id|pci_free_consistent
c_func
(paren
id|priv-&gt;dev
comma
id|PAGE_SIZE
comma
id|priv-&gt;dma_buf
comma
id|priv-&gt;dma_handle
)paren
suffix:semicolon
id|kfree
(paren
id|p-&gt;private_data
)paren
suffix:semicolon
id|parport_unregister_port
c_func
(paren
id|p
)paren
suffix:semicolon
id|kfree
(paren
id|ops
)paren
suffix:semicolon
multiline_comment|/* hope no-one cached it */
)brace
id|p
op_assign
id|tmp
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
