multiline_comment|/* $Id: parport_share.c,v 1.15 1998/01/11 12:06:17 philip Exp $&n; * Parallel-port resource manager code.&n; * &n; * Authors: David Campbell &lt;campbell@tirian.che.curtin.edu.au&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *          Jose Renau &lt;renau@acm.org&gt;&n; *          Philip Blundell &lt;philb@gnu.org&gt;&n; *&t;    Andrea Arcangeli&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt;&n; *          and Philip Blundell&n; *&n; * Any part of this program may be used in documents licensed under&n; * the GNU Free Documentation License, Version 1.1 or any later version&n; * published by the Free Software Foundation.&n; */
DECL|macro|PARPORT_DEBUG_SHARING
macro_line|#undef PARPORT_DEBUG_SHARING&t;&t;/* undef for production */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
DECL|macro|PARPORT_PARANOID
macro_line|#undef PARPORT_PARANOID
DECL|macro|PARPORT_DEFAULT_TIMESLICE
mdefine_line|#define PARPORT_DEFAULT_TIMESLICE&t;(HZ/5)
DECL|variable|parport_default_timeslice
r_int
r_int
id|parport_default_timeslice
op_assign
id|PARPORT_DEFAULT_TIMESLICE
suffix:semicolon
DECL|variable|parport_default_spintime
r_int
id|parport_default_spintime
op_assign
id|DEFAULT_SPIN_TIME
suffix:semicolon
DECL|variable|portlist
DECL|variable|portlist_tail
r_static
r_struct
id|parport
op_star
id|portlist
op_assign
l_int|NULL
comma
op_star
id|portlist_tail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|parportlist_lock
id|spinlock_t
id|parportlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|driver_chain
r_static
r_struct
id|parport_driver
op_star
id|driver_chain
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|driverlist_lock
id|spinlock_t
id|driverlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* What you can do to a port that&squot;s gone away.. */
DECL|function|dead_write_lines
r_static
r_void
id|dead_write_lines
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|b
)paren
(brace
)brace
DECL|function|dead_read_lines
r_static
r_int
r_char
id|dead_read_lines
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dead_frob_lines
r_static
r_int
r_char
id|dead_frob_lines
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|b
comma
r_int
r_char
id|c
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dead_onearg
r_static
r_void
id|dead_onearg
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
)brace
DECL|function|dead_initstate
r_static
r_void
id|dead_initstate
(paren
r_struct
id|pardevice
op_star
id|d
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
)brace
DECL|function|dead_state
r_static
r_void
id|dead_state
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
)brace
DECL|function|dead_noargs
r_static
r_void
id|dead_noargs
(paren
r_void
)paren
(brace
)brace
DECL|function|dead_write
r_static
r_int
id|dead_write
(paren
r_struct
id|parport
op_star
id|p
comma
r_const
r_void
op_star
id|b
comma
r_int
id|l
comma
r_int
id|f
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dead_read
r_static
r_int
id|dead_read
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|b
comma
r_int
id|l
comma
r_int
id|f
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dead_ops
r_static
r_struct
id|parport_operations
id|dead_ops
op_assign
(brace
id|dead_write_lines
comma
multiline_comment|/* data */
id|dead_read_lines
comma
id|dead_write_lines
comma
multiline_comment|/* control */
id|dead_read_lines
comma
id|dead_frob_lines
comma
id|dead_read_lines
comma
multiline_comment|/* status */
id|dead_onearg
comma
multiline_comment|/* enable_irq */
id|dead_onearg
comma
multiline_comment|/* disable_irq */
id|dead_onearg
comma
multiline_comment|/* data_forward */
id|dead_onearg
comma
multiline_comment|/* data_reverse */
id|dead_initstate
comma
multiline_comment|/* init_state */
id|dead_state
comma
id|dead_state
comma
id|dead_noargs
comma
multiline_comment|/* xxx_use_count */
id|dead_noargs
comma
id|dead_write
comma
multiline_comment|/* epp */
id|dead_read
comma
id|dead_write
comma
id|dead_read
comma
id|dead_write
comma
multiline_comment|/* ecp */
id|dead_read
comma
id|dead_write
comma
id|dead_write
comma
multiline_comment|/* compat */
id|dead_read
comma
multiline_comment|/* nibble */
id|dead_read
multiline_comment|/* byte */
)brace
suffix:semicolon
multiline_comment|/* Call attach(port) for each registered driver. */
DECL|function|attach_driver_chain
r_static
r_void
id|attach_driver_chain
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_struct
id|parport_driver
op_star
id|drv
suffix:semicolon
r_void
(paren
op_star
op_star
id|attach
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|i
suffix:semicolon
multiline_comment|/* This is complicated because attach() must be able to block,&n;&t; * but we can&squot;t let it do that while we&squot;re holding a&n;&t; * spinlock. */
id|spin_lock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|drv
op_assign
id|driver_chain
suffix:semicolon
id|drv
suffix:semicolon
id|drv
op_assign
id|drv-&gt;next
)paren
id|count
op_increment
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
multiline_comment|/* Drivers can unregister here; that&squot;s okay.  If they register&n;&t; * they&squot;ll be given an attach during parport_register_driver,&n;&t; * so that&squot;s okay too.  The only worry is that someone might&n;&t; * get given an attach twice if they registered just before&n;&t; * this function gets called. */
multiline_comment|/* Hmm, this could be fixed with a generation number..&n;&t; * FIXME */
id|attach
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_void
(paren
op_star
)paren
(paren
r_struct
id|parport
op_star
)paren
)paren
op_star
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attach
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;parport: not enough memory to attach&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|drv
op_assign
id|driver_chain
suffix:semicolon
id|drv
op_logical_and
id|i
OL
id|count
suffix:semicolon
id|drv
op_assign
id|drv-&gt;next
)paren
id|attach
(braket
id|i
op_increment
)braket
op_assign
id|drv-&gt;attach
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|i
suffix:semicolon
id|count
op_increment
)paren
(paren
op_star
id|attach
(braket
id|count
)braket
)paren
(paren
id|port
)paren
suffix:semicolon
id|kfree
(paren
id|attach
)paren
suffix:semicolon
)brace
multiline_comment|/* Call detach(port) for each registered driver. */
DECL|function|detach_driver_chain
r_static
r_void
id|detach_driver_chain
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_struct
id|parport_driver
op_star
id|drv
suffix:semicolon
id|spin_lock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|drv
op_assign
id|driver_chain
suffix:semicolon
id|drv
suffix:semicolon
id|drv
op_assign
id|drv-&gt;next
)paren
id|drv-&gt;detach
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Ask kmod for some lowlevel drivers. */
DECL|function|get_lowlevel_driver
r_static
r_void
id|get_lowlevel_driver
(paren
r_void
)paren
(brace
multiline_comment|/* There is no actual module called this: you should set&n;&t; * up an alias for modutils. */
id|request_module
(paren
l_string|&quot;parport_lowlevel&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_register_driver - register a parallel port device driver&n; *&t;@drv: structure describing the driver&n; *&n; *&t;This can be called by a parallel port device driver in order&n; *&t;to receive notifications about ports being found in the&n; *&t;system, as well as ports no longer available.&n; *&n; *&t;The @drv structure is allocated by the caller and must not be&n; *&t;deallocated until after calling parport_unregister_driver().&n; *&n; *&t;The driver&squot;s attach() function may block.  The port that&n; *&t;attach() is given will be valid for the duration of the&n; *&t;callback, but if the driver wants to take a copy of the&n; *&t;pointer it must call parport_get_port() to do so.  Calling&n; *&t;parport_register_device() on that port will do this for you.&n; *&n; *&t;The driver&squot;s detach() function may not block.  The port that&n; *&t;detach() is given will be valid for the duration of the&n; *&t;callback, but if the driver wants to take a copy of the&n; *&t;pointer it must call parport_get_port() to do so.&n; *&n; *&t;Returns 0 on success.  Currently it always succeeds.&n; **/
DECL|function|parport_register_driver
r_int
id|parport_register_driver
(paren
r_struct
id|parport_driver
op_star
id|drv
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
r_struct
id|parport
op_star
op_star
id|ports
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|portlist
)paren
id|get_lowlevel_driver
(paren
)paren
suffix:semicolon
multiline_comment|/* We have to take the portlist lock for this to be sure&n;&t; * that port is valid for the duration of the callback. */
multiline_comment|/* This is complicated by the fact that attach must be allowed&n;&t; * to block, so we can&squot;t be holding any spinlocks when we call&n;&t; * it.  But we need to hold a spinlock to iterate over the&n;&t; * list of ports.. */
id|spin_lock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|portlist
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
id|count
op_increment
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
id|ports
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|parport
op_star
)paren
op_star
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ports
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;parport: not enough memory to attach&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|spin_lock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|port
op_assign
id|portlist
suffix:semicolon
id|port
op_logical_and
id|i
OL
id|count
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
id|ports
(braket
id|i
op_increment
)braket
op_assign
id|port
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|i
suffix:semicolon
id|count
op_increment
)paren
id|drv-&gt;attach
(paren
id|ports
(braket
id|count
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|ports
)paren
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
id|drv-&gt;next
op_assign
id|driver_chain
suffix:semicolon
id|driver_chain
op_assign
id|drv
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_unregister_driver - deregister a parallel port device driver&n; *&t;@arg: structure describing the driver that was given to&n; *&t;      parport_register_driver()&n; *&n; *&t;This should be called by a parallel port device driver that&n; *&t;has registered itself using parport_register_driver() when it&n; *&t;is about to be unloaded.&n; *&n; *&t;When it returns, the driver&squot;s attach() routine will no longer&n; *&t;be called, and for each port that attach() was called for, the&n; *&t;detach() routine will have been called.&n; *&n; *&t;If the caller&squot;s attach() function can block, it is their&n; *&t;responsibility to make sure to wait for it to exit before&n; *&t;unloading.&n; *&n; *&t;All the driver&squot;s detach() calls are guaranteed to have&n; *&t;finished by the time this function returns.&n; *&n; *&t;The driver&squot;s detach() call is not allowed to block.&n; **/
DECL|function|parport_unregister_driver
r_void
id|parport_unregister_driver
(paren
r_struct
id|parport_driver
op_star
id|arg
)paren
(brace
r_struct
id|parport_driver
op_star
id|drv
op_assign
id|driver_chain
comma
op_star
id|olddrv
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|drv
)paren
(brace
r_if
c_cond
(paren
id|drv
op_eq
id|arg
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
id|spin_lock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|olddrv
)paren
id|olddrv-&gt;next
op_assign
id|drv-&gt;next
suffix:semicolon
r_else
id|driver_chain
op_assign
id|drv-&gt;next
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|driverlist_lock
)paren
suffix:semicolon
multiline_comment|/* Call the driver&squot;s detach routine for each&n;&t;&t;&t; * port to clean up any resources that the&n;&t;&t;&t; * attach routine acquired. */
id|spin_lock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|portlist
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
id|drv-&gt;detach
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|olddrv
op_assign
id|drv
suffix:semicolon
id|drv
op_assign
id|drv-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|free_port
r_static
r_void
id|free_port
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_int
id|d
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
l_int|0
suffix:semicolon
id|d
OL
l_int|5
suffix:semicolon
id|d
op_increment
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|class_name
)paren
id|kfree
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|class_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|mfr
)paren
id|kfree
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|mfr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|model
)paren
id|kfree
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|model
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|cmdset
)paren
id|kfree
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|cmdset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|description
)paren
id|kfree
(paren
id|port-&gt;probe_info
(braket
id|d
)braket
dot
id|description
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|port-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_get_port - increment a port&squot;s reference count&n; *&t;@port: the port&n; *&n; *&t;This ensure&squot;s that a struct parport pointer remains valid&n; *&t;until the matching parport_put_port() call.&n; **/
DECL|function|parport_get_port
r_struct
id|parport
op_star
id|parport_get_port
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
id|atomic_inc
(paren
op_amp
id|port-&gt;ref_count
)paren
suffix:semicolon
r_return
id|port
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_put_port - decrement a port&squot;s reference count&n; *&t;@port: the port&n; *&n; *&t;This should be called once for each call to parport_get_port(),&n; *&t;once the port is no longer needed.&n; **/
DECL|function|parport_put_port
r_void
id|parport_put_port
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
(paren
op_amp
id|port-&gt;ref_count
)paren
)paren
multiline_comment|/* Can destroy it now. */
id|free_port
(paren
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_enumerate - return a list of the system&squot;s parallel ports&n; *&n; *&t;This returns the head of the list of parallel ports in the&n; *&t;system, as a &amp;struct parport.  The structure that is returned&n; *&t;describes the first port in the list, and its &squot;next&squot; member&n; *&t;points to the next port, or %NULL if it&squot;s the last port.&n; *&n; *&t;If there are no parallel ports in the system,&n; *&t;parport_enumerate() will return %NULL.&n; **/
DECL|function|parport_enumerate
r_struct
id|parport
op_star
id|parport_enumerate
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Don&squot;t use this: use parport_register_driver instead. */
r_if
c_cond
(paren
op_logical_neg
id|portlist
)paren
id|get_lowlevel_driver
(paren
)paren
suffix:semicolon
r_return
id|portlist
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_register_port - register a parallel port&n; *&t;@base: base I/O address&n; *&t;@irq: IRQ line&n; *&t;@dma: DMA channel&n; *&t;@ops: pointer to the port driver&squot;s port operations structure&n; *&n; *&t;When a parallel port (lowlevel) driver finds a port that&n; *&t;should be made available to parallel port device drivers, it&n; *&t;should call parport_register_port().  The @base, @irq, and&n; *&t;@dma parameters are for the convenience of port drivers, and&n; *&t;for ports where they aren&squot;t meaningful needn&squot;t be set to&n; *&t;anything special.  They can be altered afterwards by adjusting&n; *&t;the relevant members of the parport structure that is returned&n; *&t;and represents the port.  They should not be tampered with&n; *&t;after calling parport_announce_port, however.&n; *&n; *&t;If there are parallel port device drivers in the system that&n; *&t;have registered themselves using parport_register_driver(),&n; *&t;they are not told about the port at this time; that is done by&n; *&t;parport_announce_port().&n; *&n; *&t;The @ops structure is allocated by the caller, and must not be&n; *&t;deallocated before calling parport_unregister_port().&n; *&n; *&t;If there is no memory to allocate a new parport structure,&n; *&t;this function will return %NULL.&n; **/
DECL|function|parport_register_port
r_struct
id|parport
op_star
id|parport_register_port
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_struct
id|parport_operations
op_star
id|ops
)paren
(brace
r_struct
id|parport
op_star
id|tmp
suffix:semicolon
r_int
id|portnum
suffix:semicolon
r_int
id|device
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
id|tmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|parport
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;parport: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Search for the lowest free parport number. */
id|spin_lock_irq
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|portnum
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|portnum
op_increment
)paren
(brace
r_struct
id|parport
op_star
id|itr
op_assign
id|portlist
suffix:semicolon
r_while
c_loop
(paren
id|itr
)paren
(brace
r_if
c_cond
(paren
id|itr-&gt;number
op_eq
id|portnum
)paren
multiline_comment|/* No good, already used. */
r_break
suffix:semicolon
r_else
id|itr
op_assign
id|itr-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|itr
op_eq
l_int|NULL
)paren
multiline_comment|/* Got to the end of the list. */
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
multiline_comment|/* Init our structure */
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|parport
)paren
)paren
suffix:semicolon
id|tmp-&gt;base
op_assign
id|base
suffix:semicolon
id|tmp-&gt;irq
op_assign
id|irq
suffix:semicolon
id|tmp-&gt;dma
op_assign
id|dma
suffix:semicolon
id|tmp-&gt;muxport
op_assign
id|tmp-&gt;daisy
op_assign
id|tmp-&gt;muxsel
op_assign
op_minus
l_int|1
suffix:semicolon
id|tmp-&gt;modes
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;devices
op_assign
id|tmp-&gt;cad
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;ops
op_assign
id|ops
suffix:semicolon
id|tmp-&gt;portnum
op_assign
id|tmp-&gt;number
op_assign
id|portnum
suffix:semicolon
id|tmp-&gt;physport
op_assign
id|tmp
suffix:semicolon
id|memset
(paren
id|tmp-&gt;probe_info
comma
l_int|0
comma
l_int|5
op_star
r_sizeof
(paren
r_struct
id|parport_device_info
)paren
)paren
suffix:semicolon
id|tmp-&gt;cad_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|tmp-&gt;waitlist_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|tmp-&gt;pardevice_lock
)paren
suffix:semicolon
id|tmp-&gt;ieee1284.mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|tmp-&gt;ieee1284.phase
op_assign
id|IEEE1284_PH_FWD_IDLE
suffix:semicolon
id|init_MUTEX_LOCKED
(paren
op_amp
id|tmp-&gt;ieee1284.irq
)paren
suffix:semicolon
multiline_comment|/* actually a semaphore at 0 */
id|tmp-&gt;spintime
op_assign
id|parport_default_spintime
suffix:semicolon
id|atomic_set
(paren
op_amp
id|tmp-&gt;ref_count
comma
l_int|1
)paren
suffix:semicolon
id|name
op_assign
id|kmalloc
c_func
(paren
l_int|15
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;parport%d&quot;
comma
id|portnum
)paren
suffix:semicolon
id|tmp-&gt;name
op_assign
id|name
suffix:semicolon
multiline_comment|/*&n;&t; * Chain the entry to our list.&n;&t; *&n;&t; * This function must not run from an irq handler so we don&squot; t need&n;&t; * to clear irq on the local CPU. -arca&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
multiline_comment|/* We are locked against anyone else performing alterations, but&n;&t; * because of parport_enumerate people can still _read_ the list&n;&t; * while we are changing it; so be careful..&n;&t; *&n;&t; * It&squot;s okay to have portlist_tail a little bit out of sync&n;&t; * since it&squot;s only used for changing the list, not for reading&n;&t; * from it.&n;&t; */
r_if
c_cond
(paren
id|portlist_tail
)paren
id|portlist_tail-&gt;next
op_assign
id|tmp
suffix:semicolon
id|portlist_tail
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|portlist
)paren
id|portlist
op_assign
id|tmp
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
l_int|0
suffix:semicolon
id|device
OL
l_int|5
suffix:semicolon
id|device
op_increment
)paren
multiline_comment|/* assume the worst */
id|tmp-&gt;probe_info
(braket
id|device
)braket
dot
r_class
op_assign
id|PARPORT_CLASS_LEGACY
suffix:semicolon
id|tmp-&gt;waithead
op_assign
id|tmp-&gt;waittail
op_assign
l_int|NULL
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_announce_port - tell device drivers about a parallel port&n; *&t;@port: parallel port to announce&n; *&n; *&t;After a port driver has registered a parallel port with&n; *&t;parport_register_port, and performed any necessary&n; *&t;initialisation or adjustments, it should call&n; *&t;parport_announce_port() in order to notify all device drivers&n; *&t;that have called parport_register_driver().  Their attach()&n; *&t;functions will be called, with @port as the parameter.&n; **/
DECL|function|parport_announce_port
r_void
id|parport_announce_port
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* Analyse the IEEE1284.3 topology of the port. */
r_if
c_cond
(paren
id|parport_daisy_init
(paren
id|port
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* No devices were detected.  Perhaps they are in some&n;                   funny state; let&squot;s try to reset them and see if&n;                   they wake up. */
id|parport_daisy_fini
(paren
id|port
)paren
suffix:semicolon
id|parport_write_control
(paren
id|port
comma
id|PARPORT_CONTROL_SELECT
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
id|parport_write_control
(paren
id|port
comma
id|PARPORT_CONTROL_SELECT
op_or
id|PARPORT_CONTROL_INIT
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
id|parport_daisy_init
(paren
id|port
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Let drivers know that a new port has arrived. */
id|attach_driver_chain
(paren
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_unregister_port - deregister a parallel port&n; *&t;@port: parallel port to deregister&n; *&n; *&t;When a parallel port driver is forcibly unloaded, or a&n; *&t;parallel port becomes inaccessible, the port driver must call&n; *&t;this function in order to deal with device drivers that still&n; *&t;want to use it.&n; *&n; *&t;The parport structure associated with the port has its&n; *&t;operations structure replaced with one containing &squot;null&squot;&n; *&t;operations that return errors or just don&squot;t do anything.&n; *&n; *&t;Any drivers that have registered themselves using&n; *&t;parport_register_driver() are notified that the port is no&n; *&t;longer accessible by having their detach() routines called&n; *&t;with @port as the parameter.&n; **/
DECL|function|parport_unregister_port
r_void
id|parport_unregister_port
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_struct
id|parport
op_star
id|p
suffix:semicolon
id|port-&gt;ops
op_assign
op_amp
id|dead_ops
suffix:semicolon
multiline_comment|/* Spread the word. */
id|detach_driver_chain
(paren
id|port
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* Forget the IEEE1284.3 topology of the port. */
id|parport_daisy_fini
(paren
id|port
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
multiline_comment|/* We are protected from other people changing the list, but&n;&t; * they can still see it (using parport_enumerate).  So be&n;&t; * careful about the order of writes.. */
r_if
c_cond
(paren
id|portlist
op_eq
id|port
)paren
(brace
r_if
c_cond
(paren
(paren
id|portlist
op_assign
id|port-&gt;next
)paren
op_eq
l_int|NULL
)paren
id|portlist_tail
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|p
op_assign
id|portlist
suffix:semicolon
(paren
id|p
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|p-&gt;next
op_ne
id|port
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;next
op_assign
id|port-&gt;next
)paren
op_eq
l_int|NULL
)paren
id|portlist_tail
op_assign
id|p
suffix:semicolon
)brace
r_else
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s not found in port list!&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
multiline_comment|/* Yes, parport_enumerate _is_ unsafe.  Don&squot;t use it. */
id|parport_put_port
(paren
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_register_device - register a device on a parallel port&n; *&t;@port: port to which the device is attached&n; *&t;@name: a name to refer to the device&n; *&t;@pf: preemption callback&n; *&t;@kf: kick callback (wake-up)&n; *&t;@irq_func: interrupt handler&n; *&t;@flags: registration flags&n; *&t;@handle: data for callback functions&n; *&n; *&t;This function, called by parallel port device drivers,&n; *&t;declares that a device is connected to a port, and tells the&n; *&t;system all it needs to know.&n; *&n; *&t;The @name is allocated by the caller and must not be&n; *&t;deallocated until the caller calls @parport_unregister_device&n; *&t;for that device.&n; *&n; *&t;The preemption callback function, @pf, is called when this&n; *&t;device driver has claimed access to the port but another&n; *&t;device driver wants to use it.  It is given @handle as its&n; *&t;parameter, and should return zero if it is willing for the&n; *&t;system to release the port to another driver on its behalf.&n; *&t;If it wants to keep control of the port it should return&n; *&t;non-zero, and no action will be taken.  It is good manners for&n; *&t;the driver to try to release the port at the earliest&n; *&t;opportunity after its preemption callback rejects a preemption&n; *&t;attempt.  Note that if a preemption callback is happy for&n; *&t;preemption to go ahead, there is no need to release the port;&n; *&t;it is done automatically.  This function may not block, as it&n; *&t;may be called from interrupt context.  If the device driver&n; *&t;does not support preemption, @pf can be %NULL.&n; *&n; *&t;The wake-up (&quot;kick&quot;) callback function, @kf, is called when&n; *&t;the port is available to be claimed for exclusive access; that&n; *&t;is, parport_claim() is guaranteed to succeed when called from&n; *&t;inside the wake-up callback function.  If the driver wants to&n; *&t;claim the port it should do so; otherwise, it need not take&n; *&t;any action.  This function may not block, as it may be called&n; *&t;from interrupt context.  If the device driver does not want to&n; *&t;be explicitly invited to claim the port in this way, @kf can&n; *&t;be %NULL.&n; *&n; *&t;The interrupt handler, @irq_func, is called when an interrupt&n; *&t;arrives from the parallel port.  Note that if a device driver&n; *&t;wants to use interrupts it should use parport_enable_irq(),&n; *&t;and can also check the irq member of the parport structure&n; *&t;representing the port.&n; *&n; *&t;The parallel port (lowlevel) driver is the one that has called&n; *&t;request_irq() and whose interrupt handler is called first.&n; *&t;This handler does whatever needs to be done to the hardware to&n; *&t;acknowledge the interrupt (for PC-style ports there is nothing&n; *&t;special to be done).  It then tells the IEEE 1284 code about&n; *&t;the interrupt, which may involve reacting to an IEEE 1284&n; *&t;event depending on the current IEEE 1284 phase.  After this,&n; *&t;it calls @irq_func.  Needless to say, @irq_func will be called&n; *&t;from interrupt context, and may not block.&n; *&n; *&t;The %PARPORT_DEV_EXCL flag is for preventing port sharing, and&n; *&t;so should only be used when sharing the port with other device&n; *&t;drivers is impossible and would lead to incorrect behaviour.&n; *&t;Use it sparingly!  Normally, @flags will be zero.&n; *&n; *&t;This function returns a pointer to a structure that represents&n; *&t;the device on the port, or %NULL if there is not enough memory&n; *&t;to allocate space for that structure.&n; **/
r_struct
id|pardevice
op_star
DECL|function|parport_register_device
id|parport_register_device
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_char
op_star
id|name
comma
r_int
(paren
op_star
id|pf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|kf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|irq_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
id|flags
comma
r_void
op_star
id|handle
)paren
(brace
r_struct
id|pardevice
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;physport-&gt;flags
op_amp
id|PARPORT_FLAG_EXCL
)paren
(brace
multiline_comment|/* An exclusive device is registered. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: no more devices allowed&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PARPORT_DEV_LURK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pf
op_logical_or
op_logical_neg
id|kf
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: refused to register lurking device (%s) without callbacks&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* We up our own module reference count, and that of the port&n;           on which a device is to be registered, to ensure that&n;           neither of us gets unloaded while we sleep in (e.g.)&n;           kmalloc.  To be absolutely safe, we have to require that&n;           our caller doesn&squot;t sleep in between parport_enumerate and&n;           parport_register_device.. */
id|inc_parport_count
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|inc_use_count
c_func
(paren
)paren
suffix:semicolon
id|parport_get_port
(paren
id|port
)paren
suffix:semicolon
id|tmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pardevice
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: memory squeeze, couldn&squot;t register %s.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tmp-&gt;state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|parport_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;state
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: memory squeeze, couldn&squot;t register %s.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_goto
id|out_free_pardevice
suffix:semicolon
)brace
id|tmp-&gt;name
op_assign
id|name
suffix:semicolon
id|tmp-&gt;port
op_assign
id|port
suffix:semicolon
id|tmp-&gt;daisy
op_assign
op_minus
l_int|1
suffix:semicolon
id|tmp-&gt;preempt
op_assign
id|pf
suffix:semicolon
id|tmp-&gt;wakeup
op_assign
id|kf
suffix:semicolon
id|tmp
op_member_access_from_pointer
r_private
op_assign
id|handle
suffix:semicolon
id|tmp-&gt;flags
op_assign
id|flags
suffix:semicolon
id|tmp-&gt;irq_func
op_assign
id|irq_func
suffix:semicolon
id|tmp-&gt;waiting
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;timeout
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Chain this onto the list */
id|tmp-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * This function must not run from an irq handler so we don&squot; t need&n;&t; * to clear irq on the local CPU. -arca&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|port-&gt;physport-&gt;pardevice_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PARPORT_DEV_EXCL
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;physport-&gt;devices
)paren
(brace
id|spin_unlock
(paren
op_amp
id|port-&gt;physport-&gt;pardevice_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: cannot grant exclusive access for &quot;
l_string|&quot;device %s&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_goto
id|out_free_all
suffix:semicolon
)brace
id|port-&gt;flags
op_or_assign
id|PARPORT_FLAG_EXCL
suffix:semicolon
)brace
id|tmp-&gt;next
op_assign
id|port-&gt;physport-&gt;devices
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Make sure that tmp-&gt;next is written before it&squot;s&n;                  added to the list; see comments marked &squot;no locking&n;                  required&squot; */
r_if
c_cond
(paren
id|port-&gt;physport-&gt;devices
)paren
id|port-&gt;physport-&gt;devices-&gt;prev
op_assign
id|tmp
suffix:semicolon
id|port-&gt;physport-&gt;devices
op_assign
id|tmp
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;physport-&gt;pardevice_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|tmp-&gt;wait_q
)paren
suffix:semicolon
id|tmp-&gt;timeslice
op_assign
id|parport_default_timeslice
suffix:semicolon
id|tmp-&gt;waitnext
op_assign
id|tmp-&gt;waitprev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * This has to be run as last thing since init_state may need other&n;&t; * pardevice fields. -arca&n;&t; */
id|port-&gt;ops
op_member_access_from_pointer
id|init_state
c_func
(paren
id|tmp
comma
id|tmp-&gt;state
)paren
suffix:semicolon
id|parport_device_proc_register
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
id|out_free_all
suffix:colon
id|kfree
(paren
id|tmp-&gt;state
)paren
suffix:semicolon
id|out_free_pardevice
suffix:colon
id|kfree
(paren
id|tmp
)paren
suffix:semicolon
id|out
suffix:colon
id|dec_parport_count
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|dec_use_count
c_func
(paren
)paren
suffix:semicolon
id|parport_put_port
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_unregister_device - deregister a device on a parallel port&n; *&t;@dev: pointer to structure representing device&n; *&n; *&t;This undoes the effect of parport_register_device().&n; **/
DECL|function|parport_unregister_device
r_void
id|parport_unregister_device
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
macro_line|#ifdef PARPORT_PARANOID
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport_unregister_device: passed NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|parport_device_proc_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
id|port
op_assign
id|dev-&gt;port-&gt;physport
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s forgot to release port&bslash;n&quot;
comma
id|port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|parport_release
(paren
id|dev
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|port-&gt;pardevice_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;next
)paren
id|dev-&gt;next-&gt;prev
op_assign
id|dev-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;prev
)paren
id|dev-&gt;prev-&gt;next
op_assign
id|dev-&gt;next
suffix:semicolon
r_else
id|port-&gt;devices
op_assign
id|dev-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|PARPORT_DEV_EXCL
)paren
id|port-&gt;flags
op_and_assign
op_complement
id|PARPORT_FLAG_EXCL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;pardevice_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;state
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dec_parport_count
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|dec_use_count
c_func
(paren
)paren
suffix:semicolon
id|parport_put_port
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Yes, that&squot;s right, someone _could_ still have a pointer to&n;&t; * port, if they used parport_enumerate.  That&squot;s why they&n;&t; * shouldn&squot;t use it (and use parport_register_driver instead)..&n;&t; */
)brace
multiline_comment|/**&n; *&t;parport_find_number - find a parallel port by number&n; *&t;@number: parallel port number&n; *&n; *&t;This returns the parallel port with the specified number, or&n; *&t;%NULL if there is none.&n; *&n; *&t;There is an implicit parport_get_port() done already; to throw&n; *&t;away the reference to the port that parport_find_number()&n; *&t;gives you, use parport_put_port().&n; */
DECL|function|parport_find_number
r_struct
id|parport
op_star
id|parport_find_number
(paren
r_int
id|number
)paren
(brace
r_struct
id|parport
op_star
id|port
comma
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|portlist
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
r_if
c_cond
(paren
id|port-&gt;number
op_eq
id|number
)paren
(brace
id|result
op_assign
id|parport_get_port
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_find_base - find a parallel port by base address&n; *&t;@base: base I/O address&n; *&n; *&t;This returns the parallel port with the specified base&n; *&t;address, or %NULL if there is none.&n; *&n; *&t;There is an implicit parport_get_port() done already; to throw&n; *&t;away the reference to the port that parport_find_base()&n; *&t;gives you, use parport_put_port().&n; */
DECL|function|parport_find_base
r_struct
id|parport
op_star
id|parport_find_base
(paren
r_int
r_int
id|base
)paren
(brace
r_struct
id|parport
op_star
id|port
comma
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|portlist
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
r_if
c_cond
(paren
id|port-&gt;base
op_eq
id|base
)paren
(brace
id|result
op_assign
id|parport_get_port
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|parportlist_lock
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_claim - claim access to a parallel port device&n; *&t;@dev: pointer to structure representing a device on the port&n; *&n; *&t;This function will not block and so can be used from interrupt&n; *&t;context.  If parport_claim() succeeds in claiming access to&n; *&t;the port it returns zero and the port is available to use.  It&n; *&t;may fail (returning non-zero) if the port is in use by another&n; *&t;driver and that driver is not willing to relinquish control of&n; *&t;the port.&n; **/
DECL|function|parport_claim
r_int
id|parport_claim
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_struct
id|pardevice
op_star
id|oldcad
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|dev-&gt;port-&gt;physport
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s already owner&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Preempt any current device */
id|write_lock_irqsave
(paren
op_amp
id|port-&gt;cad_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldcad
op_assign
id|port-&gt;cad
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|oldcad-&gt;preempt
)paren
(brace
r_if
c_cond
(paren
id|oldcad
op_member_access_from_pointer
id|preempt
c_func
(paren
id|oldcad
op_member_access_from_pointer
r_private
)paren
)paren
r_goto
id|blocked
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|save_state
c_func
(paren
id|port
comma
id|dev-&gt;state
)paren
suffix:semicolon
)brace
r_else
r_goto
id|blocked
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad
op_ne
id|oldcad
)paren
(brace
multiline_comment|/* I think we&squot;ll actually deadlock rather than&n;                           get here, but just in case.. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %s released port when preempted!&bslash;n&quot;
comma
id|port-&gt;name
comma
id|oldcad-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad
)paren
r_goto
id|blocked
suffix:semicolon
)brace
)brace
multiline_comment|/* Can&squot;t fail from now on, so mark ourselves as no longer waiting.  */
r_if
c_cond
(paren
id|dev-&gt;waiting
op_amp
l_int|1
)paren
(brace
id|dev-&gt;waiting
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Take ourselves out of the wait list again.  */
id|spin_lock_irq
(paren
op_amp
id|port-&gt;waitlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;waitprev
)paren
id|dev-&gt;waitprev-&gt;waitnext
op_assign
id|dev-&gt;waitnext
suffix:semicolon
r_else
id|port-&gt;waithead
op_assign
id|dev-&gt;waitnext
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;waitnext
)paren
id|dev-&gt;waitnext-&gt;waitprev
op_assign
id|dev-&gt;waitprev
suffix:semicolon
r_else
id|port-&gt;waittail
op_assign
id|dev-&gt;waitprev
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|port-&gt;waitlist_lock
)paren
suffix:semicolon
id|dev-&gt;waitprev
op_assign
id|dev-&gt;waitnext
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Now we do the change of devices */
id|port-&gt;cad
op_assign
id|dev
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* If it&squot;s a mux port, select it. */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;muxport
op_ge
l_int|0
)paren
(brace
multiline_comment|/* FIXME */
id|port-&gt;muxsel
op_assign
id|dev-&gt;port-&gt;muxport
suffix:semicolon
)brace
multiline_comment|/* If it&squot;s a daisy chain device, select it. */
r_if
c_cond
(paren
id|dev-&gt;daisy
op_ge
l_int|0
)paren
(brace
multiline_comment|/* This could be lazier. */
r_if
c_cond
(paren
op_logical_neg
id|parport_daisy_select
(paren
id|port
comma
id|dev-&gt;daisy
comma
id|IEEE1284_MODE_COMPAT
)paren
)paren
id|port-&gt;daisy
op_assign
id|dev-&gt;daisy
suffix:semicolon
)brace
macro_line|#endif /* IEEE1284.3 support */
multiline_comment|/* Restore control registers */
id|port-&gt;ops
op_member_access_from_pointer
id|restore_state
c_func
(paren
id|port
comma
id|dev-&gt;state
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;cad_lock
comma
id|flags
)paren
suffix:semicolon
id|dev-&gt;time
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|blocked
suffix:colon
multiline_comment|/* If this is the first time we tried to claim the port, register an&n;&t;   interest.  This is only allowed for devices sleeping in&n;&t;   parport_claim_or_block(), or those with a wakeup function.  */
multiline_comment|/* The cad_lock is still held for writing here */
r_if
c_cond
(paren
id|dev-&gt;waiting
op_amp
l_int|2
op_logical_or
id|dev-&gt;wakeup
)paren
(brace
id|spin_lock
(paren
op_amp
id|port-&gt;waitlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|dev-&gt;waiting
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* First add ourselves to the end of the wait list. */
id|dev-&gt;waitnext
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;waitprev
op_assign
id|port-&gt;waittail
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;waittail
)paren
(brace
id|port-&gt;waittail-&gt;waitnext
op_assign
id|dev
suffix:semicolon
id|port-&gt;waittail
op_assign
id|dev
suffix:semicolon
)brace
r_else
id|port-&gt;waithead
op_assign
id|port-&gt;waittail
op_assign
id|dev
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|port-&gt;waitlist_lock
)paren
suffix:semicolon
)brace
id|write_unlock_irqrestore
(paren
op_amp
id|port-&gt;cad_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_claim_or_block - claim access to a parallel port device&n; *&t;@dev: pointer to structure representing a device on the port&n; *&n; *&t;This behaves like parport_claim(), but will block if necessary&n; *&t;to wait for the port to be free.  A return value of 1&n; *&t;indicates that it slept; 0 means that it succeeded without&n; *&t;needing to sleep.  A negative error code indicates failure.&n; **/
DECL|function|parport_claim_or_block
r_int
id|parport_claim_or_block
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* Signal to parport_claim() that we can wait even without a&n;&t;   wakeup function.  */
id|dev-&gt;waiting
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Try to claim the port.  If this fails, we need to sleep.  */
id|r
op_assign
id|parport_claim
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef PARPORT_DEBUG_SHARING
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: parport_claim() returned -EAGAIN&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If dev-&gt;waiting is clear now, an interrupt&n;&t;&t;   gave us the port and we would deadlock if we slept.  */
r_if
c_cond
(paren
id|dev-&gt;waiting
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|dev-&gt;wait_q
)paren
suffix:semicolon
id|r
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|r
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef PARPORT_DEBUG_SHARING
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: didn&squot;t sleep in parport_claim_or_block()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef PARPORT_DEBUG_SHARING
r_if
c_cond
(paren
id|dev-&gt;port-&gt;physport-&gt;cad
op_ne
id|dev
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting parport_claim_or_block &quot;
l_string|&quot;but %s owns port!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;port-&gt;physport-&gt;cad
ques
c_cond
id|dev-&gt;port-&gt;physport-&gt;cad-&gt;name
suffix:colon
l_string|&quot;nobody&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|dev-&gt;waiting
op_assign
l_int|0
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;parport_release - give up access to a parallel port device&n; *&t;@dev: pointer to structure representing parallel port device&n; *&n; *&t;This function cannot fail, but it should not be called without&n; *&t;the port claimed.  Similarly, if the port is already claimed&n; *&t;you should not try claiming it again.&n; **/
DECL|function|parport_release
r_void
id|parport_release
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
id|dev-&gt;port-&gt;physport
suffix:semicolon
r_struct
id|pardevice
op_star
id|pd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Make sure that dev is the current device */
id|write_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;cad_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad
op_ne
id|dev
)paren
(brace
id|write_unlock_irqrestore
(paren
op_amp
id|port-&gt;cad_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %s tried to release parport &quot;
l_string|&quot;when not owner&bslash;n&quot;
comma
id|port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* If this is on a mux port, deselect it. */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;muxport
op_ge
l_int|0
)paren
(brace
multiline_comment|/* FIXME */
id|port-&gt;muxsel
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If this is a daisy device, deselect it. */
r_if
c_cond
(paren
id|dev-&gt;daisy
op_ge
l_int|0
)paren
(brace
id|parport_daisy_deselect_all
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;daisy
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
id|port-&gt;cad
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;cad_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Save control registers */
id|port-&gt;ops
op_member_access_from_pointer
id|save_state
c_func
(paren
id|port
comma
id|dev-&gt;state
)paren
suffix:semicolon
multiline_comment|/* If anybody is waiting, find out who&squot;s been there longest and&n;&t;   then wake them up. (Note: no locking required) */
r_for
c_loop
(paren
id|pd
op_assign
id|port-&gt;waithead
suffix:semicolon
id|pd
suffix:semicolon
id|pd
op_assign
id|pd-&gt;waitnext
)paren
(brace
r_if
c_cond
(paren
id|pd-&gt;waiting
op_amp
l_int|2
)paren
(brace
multiline_comment|/* sleeping in claim_or_block */
id|parport_claim
c_func
(paren
id|pd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|pd-&gt;wait_q
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wait_q
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pd-&gt;wakeup
)paren
(brace
id|pd
op_member_access_from_pointer
id|wakeup
c_func
(paren
id|pd
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
)paren
multiline_comment|/* racy but no matter */
r_return
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: don&squot;t know how to wake %s&bslash;n&quot;
comma
id|port-&gt;name
comma
id|pd-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Nobody was waiting, so walk the list to see if anyone is&n;&t;   interested in being woken up. (Note: no locking required) */
r_for
c_loop
(paren
id|pd
op_assign
id|port-&gt;devices
suffix:semicolon
(paren
id|port-&gt;cad
op_eq
l_int|NULL
)paren
op_logical_and
id|pd
suffix:semicolon
id|pd
op_assign
id|pd-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pd-&gt;wakeup
op_logical_and
id|pd
op_ne
id|dev
)paren
id|pd
op_member_access_from_pointer
id|wakeup
c_func
(paren
id|pd
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
)brace
DECL|function|parport_parse_params
r_static
r_int
id|parport_parse_params
(paren
r_int
id|nports
comma
r_const
r_char
op_star
id|str
(braket
)braket
comma
r_int
id|val
(braket
)braket
comma
r_int
id|automatic
comma
r_int
id|none
comma
r_int
id|nofifo
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nports
op_logical_and
id|str
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
(braket
id|i
)braket
comma
l_string|&quot;auto&quot;
comma
l_int|4
)paren
)paren
id|val
(braket
id|i
)braket
op_assign
id|automatic
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
(braket
id|i
)braket
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
)paren
id|val
(braket
id|i
)braket
op_assign
id|none
suffix:semicolon
r_else
r_if
c_cond
(paren
id|nofifo
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|str
(braket
id|i
)braket
comma
l_string|&quot;nofifo&quot;
comma
l_int|4
)paren
)paren
id|val
(braket
id|i
)braket
op_assign
id|nofifo
suffix:semicolon
r_else
(brace
r_char
op_star
id|ep
suffix:semicolon
r_int
r_int
id|r
op_assign
id|simple_strtoul
c_func
(paren
id|str
(braket
id|i
)braket
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_ne
id|str
(braket
id|i
)braket
)paren
id|val
(braket
id|i
)braket
op_assign
id|r
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;parport: bad specifier `%s&squot;&bslash;n&quot;
comma
id|str
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_parse_irqs
r_int
id|parport_parse_irqs
c_func
(paren
r_int
id|nports
comma
r_const
r_char
op_star
id|irqstr
(braket
)braket
comma
r_int
id|irqval
(braket
)braket
)paren
(brace
r_return
id|parport_parse_params
(paren
id|nports
comma
id|irqstr
comma
id|irqval
comma
id|PARPORT_IRQ_AUTO
comma
id|PARPORT_IRQ_NONE
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parport_parse_dmas
r_int
id|parport_parse_dmas
c_func
(paren
r_int
id|nports
comma
r_const
r_char
op_star
id|dmastr
(braket
)braket
comma
r_int
id|dmaval
(braket
)braket
)paren
(brace
r_return
id|parport_parse_params
(paren
id|nports
comma
id|dmastr
comma
id|dmaval
comma
id|PARPORT_DMA_AUTO
comma
id|PARPORT_DMA_NONE
comma
id|PARPORT_DMA_NOFIFO
)paren
suffix:semicolon
)brace
eof
