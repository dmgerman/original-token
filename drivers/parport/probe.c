multiline_comment|/* $Id: parport_probe.c,v 1.1 1999/07/03 08:56:17 davem Exp $&n; * Parallel port device probing code&n; *&n; * Authors:    Carsten Gross, carsten@sol.wohnheim.uni-ulm.de&n; *             Philip Blundell &lt;Philip.Blundell@pobox.com&gt;&n; */
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
r_static
r_struct
(brace
DECL|member|token
r_char
op_star
id|token
suffix:semicolon
DECL|member|descr
r_char
op_star
id|descr
suffix:semicolon
DECL|variable|classes
)brace
id|classes
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;&quot;
comma
l_string|&quot;Legacy device&quot;
)brace
comma
(brace
l_string|&quot;PRINTER&quot;
comma
l_string|&quot;Printer&quot;
)brace
comma
(brace
l_string|&quot;MODEM&quot;
comma
l_string|&quot;Modem&quot;
)brace
comma
(brace
l_string|&quot;NET&quot;
comma
l_string|&quot;Network device&quot;
)brace
comma
(brace
l_string|&quot;HDC&quot;
comma
l_string|&quot;Hard disk&quot;
)brace
comma
(brace
l_string|&quot;PCMCIA&quot;
comma
l_string|&quot;PCMCIA&quot;
)brace
comma
(brace
l_string|&quot;MEDIA&quot;
comma
l_string|&quot;Multimedia device&quot;
)brace
comma
(brace
l_string|&quot;FDC&quot;
comma
l_string|&quot;Floppy disk&quot;
)brace
comma
(brace
l_string|&quot;PORTS&quot;
comma
l_string|&quot;Ports&quot;
)brace
comma
(brace
l_string|&quot;SCANNER&quot;
comma
l_string|&quot;Scanner&quot;
)brace
comma
(brace
l_string|&quot;DIGICAM&quot;
comma
l_string|&quot;Digital camera&quot;
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;Unknown device&quot;
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;Unspecified&quot;
)brace
comma
(brace
l_string|&quot;SCSIADAPTER&quot;
comma
l_string|&quot;SCSI adapter&quot;
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|pretty_print
r_static
r_void
id|pretty_print
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
id|device
)paren
(brace
r_struct
id|parport_device_info
op_star
id|info
op_assign
op_amp
id|port-&gt;probe_info
(braket
id|device
op_plus
l_int|1
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_ge
l_int|0
)paren
id|printk
(paren
l_string|&quot; (addr %d)&quot;
comma
id|device
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;: %s&quot;
comma
id|classes
(braket
id|info
op_member_access_from_pointer
r_class
)braket
dot
id|descr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_member_access_from_pointer
r_class
)paren
id|printk
c_func
(paren
l_string|&quot;, %s %s&quot;
comma
id|info-&gt;mfr
comma
id|info-&gt;model
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|strdup
r_static
r_char
op_star
id|strdup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|n
op_assign
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
suffix:semicolon
r_char
op_star
id|s
op_assign
id|kmalloc
c_func
(paren
id|n
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|strcpy
c_func
(paren
id|s
comma
id|str
)paren
suffix:semicolon
)brace
DECL|function|parse_data
r_static
r_void
id|parse_data
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
id|device
comma
r_char
op_star
id|str
)paren
(brace
r_char
op_star
id|txt
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_char
op_star
id|p
op_assign
id|txt
comma
op_star
id|q
suffix:semicolon
r_int
id|guessed_class
op_assign
id|PARPORT_CLASS_UNSPEC
suffix:semicolon
r_struct
id|parport_device_info
op_star
id|info
op_assign
op_amp
id|port-&gt;probe_info
(braket
id|device
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|txt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s probe: memory squeeze&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|txt
comma
id|str
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_char
op_star
id|sep
suffix:semicolon
id|q
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
op_star
id|q
op_assign
l_int|0
suffix:semicolon
id|sep
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sep
)paren
(brace
r_char
op_star
id|u
suffix:semicolon
op_star
(paren
id|sep
op_increment
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get rid of trailing blanks */
id|u
op_assign
id|strchr
(paren
id|sep
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u
)paren
op_star
id|u
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|u
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|u
)paren
(brace
op_star
id|u
op_assign
id|toupper
c_func
(paren
op_star
id|u
)paren
suffix:semicolon
id|u
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;MFG&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;MANUFACTURER&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;mfr
)paren
id|kfree
(paren
id|info-&gt;mfr
)paren
suffix:semicolon
id|info-&gt;mfr
op_assign
id|strdup
c_func
(paren
id|sep
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;MDL&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;MODEL&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;model
)paren
id|kfree
(paren
id|info-&gt;model
)paren
suffix:semicolon
id|info-&gt;model
op_assign
id|strdup
c_func
(paren
id|sep
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;CLS&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;CLASS&quot;
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;class_name
)paren
id|kfree
(paren
id|info-&gt;class_name
)paren
suffix:semicolon
id|info-&gt;class_name
op_assign
id|strdup
c_func
(paren
id|sep
)paren
suffix:semicolon
r_for
c_loop
(paren
id|u
op_assign
id|sep
suffix:semicolon
op_star
id|u
suffix:semicolon
id|u
op_increment
)paren
op_star
id|u
op_assign
id|toupper
c_func
(paren
op_star
id|u
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|classes
(braket
id|i
)braket
dot
id|token
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|classes
(braket
id|i
)braket
dot
id|token
comma
id|sep
)paren
)paren
(brace
id|info
op_member_access_from_pointer
r_class
op_assign
id|i
suffix:semicolon
r_goto
id|rock_on
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s probe: warning, class &squot;%s&squot; not understood.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|sep
)paren
suffix:semicolon
id|info
op_member_access_from_pointer
r_class
op_assign
id|PARPORT_CLASS_OTHER
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;CMD&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;COMMAND SET&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;cmdset
)paren
id|kfree
(paren
id|info-&gt;cmdset
)paren
suffix:semicolon
id|info-&gt;cmdset
op_assign
id|strdup
c_func
(paren
id|sep
)paren
suffix:semicolon
multiline_comment|/* if it speaks printer language, it&squot;s&n;&t;&t;&t;&t;   probably a printer */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|sep
comma
l_string|&quot;PJL&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
id|sep
comma
l_string|&quot;PCL&quot;
)paren
)paren
id|guessed_class
op_assign
id|PARPORT_CLASS_PRINTER
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;DES&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;DESCRIPTION&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;description
)paren
id|kfree
(paren
id|info-&gt;description
)paren
suffix:semicolon
id|info-&gt;description
op_assign
id|strdup
c_func
(paren
id|sep
)paren
suffix:semicolon
)brace
)brace
id|rock_on
suffix:colon
r_if
c_cond
(paren
id|q
)paren
id|p
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
r_else
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If the device didn&squot;t tell us its class, maybe we have managed to&n;&t;   guess one from the things it did say. */
r_if
c_cond
(paren
id|info
op_member_access_from_pointer
r_class
op_eq
id|PARPORT_CLASS_UNSPEC
)paren
id|info
op_member_access_from_pointer
r_class
op_assign
id|guessed_class
suffix:semicolon
id|pretty_print
(paren
id|port
comma
id|device
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|txt
)paren
suffix:semicolon
)brace
multiline_comment|/* Get Std 1284 Device ID. */
DECL|function|parport_device_id
id|ssize_t
id|parport_device_id
(paren
r_int
id|devnum
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
id|ssize_t
id|retval
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_struct
id|pardevice
op_star
id|dev
op_assign
id|parport_open
(paren
id|devnum
comma
l_string|&quot;Device ID probe&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|parport_claim_or_block
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Negotiate to compatibility mode, and then to device ID mode.&n;&t; * (This is in case we are already in device ID mode.) */
id|parport_negotiate
(paren
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|retval
op_assign
id|parport_negotiate
(paren
id|dev-&gt;port
comma
id|IEEE1284_MODE_NIBBLE
op_or
id|IEEE1284_DEVICEID
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
r_int
id|idlen
suffix:semicolon
r_int
r_char
id|length
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* First two bytes are MSB,LSB of inclusive length. */
id|retval
op_assign
id|parport_read
(paren
id|dev-&gt;port
comma
id|length
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|2
)paren
r_goto
id|end_id
suffix:semicolon
id|idlen
op_assign
(paren
id|length
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|length
(braket
l_int|1
)braket
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|idlen
OL
id|len
)paren
id|len
op_assign
id|idlen
suffix:semicolon
id|retval
op_assign
id|parport_read
(paren
id|dev-&gt;port
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|len
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: only read %Zd of %Zd ID bytes&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
comma
id|retval
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Some printer manufacturers mistakenly believe that&n;                   the length field is supposed to be _exclusive_.&n;&t;&t;   In addition, there are broken devices out there&n;                   that don&squot;t even finish off with a semi-colon. */
r_if
c_cond
(paren
id|buffer
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;;&squot;
)paren
(brace
id|ssize_t
id|diff
suffix:semicolon
id|diff
op_assign
id|parport_read
(paren
id|dev-&gt;port
comma
id|buffer
op_plus
id|len
comma
l_int|2
)paren
suffix:semicolon
id|retval
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|diff
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: device reported incorrect &quot;
l_string|&quot;length field (%d, should be %Zd)&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
comma
id|idlen
comma
id|retval
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* One semi-colon short of a device ID. */
id|buffer
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;;&squot;
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: faking semi-colon&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
)paren
suffix:semicolon
multiline_comment|/* If we get here, I don&squot;t think we&n;                                   need to worry about the possible&n;                                   standard violation of having read&n;                                   more than we were told to.  The&n;                                   device is non-compliant anyhow. */
)brace
)brace
id|end_id
suffix:colon
id|buffer
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|parport_negotiate
(paren
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
)brace
id|parport_release
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|2
)paren
id|parse_data
(paren
id|dev-&gt;port
comma
id|dev-&gt;daisy
comma
id|buffer
)paren
suffix:semicolon
id|parport_close
(paren
id|dev
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
eof
