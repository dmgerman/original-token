multiline_comment|/*****************************************************************************&n; *&n; *      ESS Maestro/Maestro-2/Maestro-2E driver for Linux 2.[23].x&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *&t;(c) Copyright 1999&t; Alan Cox &lt;alan.cox@linux.org&gt;&n; *&n; *&t;Based heavily on SonicVibes.c:&n; *      Copyright (C) 1998-1999  Thomas Sailer (sailer@ife.ee.ethz.ch)&n; *&n; *&t;Heavily modified by Zach Brown &lt;zab@zabbo.net&gt; based on lunch&n; *&t;with ESS engineers.  Many thanks to Howard Kim for providing &n; *&t;contacts and hardware.  Honorable mention goes to Eric &n; *&t;Brombaugh for all sorts of things.  Best regards to the &n; *&t;proprietors of Hack Central for fine lodging.&n; *&n; *  Supported devices:&n; *  /dev/dsp0-3    standard /dev/dsp device, (mostly) OSS compatible&n; *  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible&n; *&n; *  Hardware Description&n; *&n; *&t;A working Maestro setup contains the Maestro chip wired to a &n; *&t;codec or 2.  In the Maestro we have the APUs, the ASSP, and the&n; *&t;Wavecache.  The APUs can be though of as virtual audio routing&n; *&t;channels.  They can take data from a number of sources and perform&n; *&t;basic encodings of the data.  The wavecache is a storehouse for&n; *&t;PCM data.  Typically it deals with PCI and interracts with the&n; *&t;APUs.  The ASSP is a wacky DSP like device that ESS is loth&n; *&t;to release docs on.  Thankfully it isn&squot;t required on the Maestro&n; *&t;until you start doing insane things like FM emulation and surround&n; *&t;encoding.  The codecs are almost always AC-97 compliant codecs, &n; *&t;but it appears that early Maestros may have had PT101 (an ESS&n; *&t;part?) wired to them.  The only real difference in the Maestro&n; *&t;families is external goop like docking capability, memory for&n; *&t;the ASSP, and initialization differences.&n; *&n; *  Driver Operation&n; *&n; *&t;We only drive the APU/Wavecache as typical DACs and drive the&n; *&t;mixers in the codecs.  There are 64 APUs.  We assign 6 to each&n; *&t;/dev/dsp? device.  2 channels for output, and 4 channels for&n; *&t;input.&n; *&n; *&t;Each APU can do a number of things, but we only really use&n; *&t;3 basic functions.  For playback we use them to convert PCM&n; *&t;data fetched over PCI by the wavecahche into analog data that&n; *&t;is handed to the codec.  One APU for mono, and a pair for stereo.&n; *&t;When in stereo, the combination of smarts in the APU and Wavecache&n; *&t;decide which wavecache gets the left or right channel.&n; *&n; *&t;For record we still use the old overly mono system.  For each in&n; *&t;coming channel the data comes in from the codec, through a &squot;input&squot;&n; *&t;APU, through another rate converter APU, and then into memory via&n; *&t;the wavecache and PCI.  If its stereo, we mash it back into LRLR in&n; *&t;software.  The pass between the 2 APUs is supposedly what requires us&n; *&t;to have a 512 byte buffer sitting around in wavecache/memory.&n; *&n; *&t;The wavecache makes our life even more fun.  First off, it can&n; *&t;only address the first 28 bits of PCI address space, making it&n; *&t;useless on quite a few architectures.  Secondly, its insane.&n; *&t;It claims to fetch from 4 regions of PCI space, each 4 meg in length.&n; *&t;But that doesn&squot;t really work.  You can only use 1 region.  So all our&n; *&t;allocations have to be in 4meg of each other.  Booo.  Hiss.&n; *&t;So we have a module parameter, dsps_order, that is the order of&n; *&t;the number of dsps to provide.  All their buffer space is allocated&n; *&t;on open time.  The sonicvibes OSS routines we inherited really want&n; *&t;power of 2 buffers, so we have all those next to each other, then&n; *&t;512 byte regions for the recording wavecaches.  This ends up&n; *&t;wasting quite a bit of memory.  The only fixes I can see would be &n; *&t;getting a kernel allocator that could work in zones, or figuring out&n; *&t;just how to coerce the WP into doing what we want.&n; *&n; *&t;The indirection of the various registers means we have to spinlock&n; *&t;nearly all register accesses.  We have the main register indirection&n; *&t;like the wave cache, maestro registers, etc.  Then we have beasts&n; *&t;like the APU interface that is indirect registers gotten at through&n; *&t;the main maestro indirection.  Ouch.  We spinlock around the actual&n; *&t;ports on a per card basis.  This means spinlock activity at each IO&n; *&t;operation, but the only IO operation clusters are in non critical &n; *&t;paths and it makes the code far easier to follow.  Interrupts are&n; *&t;blocked while holding the locks because the int handler has to&n; *&t;get at some of them :(.  The mixer interface doesn&squot;t, however.&n; *&t;We also have an OSS state lock that is thrown around in a few&n; *&t;places.&n; *&n; *&t;This driver has brute force APM suspend support.  We catch suspend&n; *&t;notifications and stop all work being done on the chip.  Any people&n; *&t;that try between this shutdown and the real suspend operation will&n; *&t;be put to sleep.  When we resume we restore our software state on&n; *&t;the chip and wake up the people that were using it.  The code thats&n; *&t;being used now is quite dirty and assumes we&squot;re on a uni-processor&n; *&t;machine.  Much of it will need to be cleaned up for SMP ACPI or &n; *&t;similar.&n; *&n; *&t;We also pay attention to PCI power management now.  The driver&n; *&t;will power down units of the chip that it knows aren&squot;t needed.&n; *&t;The WaveProcessor and company are only powered on when people&n; *&t;have /dev/dsp*s open.  On removal the driver will&n; *&t;power down the maestro entirely.  There could still be&n; *&t;trouble with BIOSen that magically change power states &n; *&t;themselves, but we&squot;ll see.  &n; *&t;&n; * History&n; *  (still kind of v0.14) Nov 23 - Alan Cox &lt;alan@redhat.com&gt;&n; *&t;Add clocking= for people with seriously warped hardware&n; *  (still v0.14) Nov 10 2000 - Bartlomiej Zolnierkiewicz &lt;bkz@linux-ide.org&gt;&n; *&t;add __init to maestro_ac97_init() and maestro_install()&n; *  (still based on v0.14) Mar 29 2000 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;move to 2.3 power management interface, which&n; *&t;&t;required hacking some suspend/resume/check paths &n; *&t;make static compilation work&n; *  v0.14 - Jan 28 2000 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;add PCI power management through ACPI regs.&n; *&t;we now shut down on machine reboot/halt&n; *&t;leave scary PCI config items alone (isa stuff, mostly)&n; *&t;enable 1921s, it seems only mine was broke.&n; *&t;fix swapped left/right pcm dac.  har har.&n; *&t;up bob freq, increase buffers, fix pointers at underflow&n; *&t;silly compilation problems&n; *  v0.13 - Nov 18 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;fix nec Versas?  man would that be cool.&n; *  v0.12 - Nov 12 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;brown bag volume max fix..&n; *  v0.11 - Nov 11 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;use proper stereo apu decoding, mmap/write should work.&n; *&t;make volume sliders more useful, tweak rate calculation.&n; *&t;fix lame 8bit format reporting bug.  duh. apm apu saving buglet also&n; *&t;fix maestro 1 clock freq &quot;bug&quot;, remove pt101 support&n; *  v0.10 - Oct 28 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;aha, so, sometimes the WP writes a status word to offset 0&n; *&t;  from one of the PCMBARs.  rearrange allocation accordingly..&n; *&t;  cheers again to Eric for being a good hacker in investigating this.&n; *&t;Jeroen Hoogervorst submits 7500 fix out of nowhere.  yay.  :)&n; *  v0.09 - Oct 23 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;added APM support.&n; *&t;re-order something such that some 2Es now work.  Magic!&n; *&t;new codec reset routine.  made some codecs come to life.&n; *&t;fix clear_advance, sync some control with ESS.&n; *&t;now write to all base regs to be paranoid.&n; *  v0.08 - Oct 20 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;Fix initial buflen bug.  I am so smart.  also smp compiling..&n; *&t;I owe Eric yet another beer: fixed recmask, igain, &n; *&t;  muting, and adc sync consistency.  Go Team.&n; *  v0.07 - Oct 4 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;tweak adc/dac, formating, and stuff to allow full duplex&n; *&t;allocate dsps memory at open() so we can fit in the wavecache window&n; *&t;fix wavecache braindamage.  again.  no more scribbling?&n; *&t;fix ess 1921 codec bug on some laptops.&n; *&t;fix dumb pci scanning bug&n; *&t;started 2.3 cleanup, redid spinlocks, little cleanups&n; *  v0.06 - Sep 20 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;fix wavecache thinkos.  limit to 1 /dev/dsp.&n; *&t;eric is wearing his thinking toque this week.&n; *&t;&t;spotted apu mode bugs and gain ramping problem&n; *&t;don&squot;t touch weird mixer regs, make recmask optional&n; *&t;fixed igain inversion, defaults for mixers, clean up rec_start&n; *&t;make mono recording work.&n; *&t;report subsystem stuff, please send reports.&n; *&t;littles: parallel out, amp now&n; *  v0.05 - Sep 17 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;merged and fixed up Eric&squot;s initial recording code&n; *&t;munged format handling to catch misuse, needs rewrite.&n; *&t;revert ring bus init, fixup shared int, add pci busmaster setting&n; *&t;fix mixer oss interface, fix mic mute and recmask&n; *&t;mask off unsupported mixers, reset with all 1s, modularize defaults&n; *&t;make sure bob is running while we need it&n; *&t;got rid of device limit, initial minimal apm hooks&n; *&t;pull out dead code/includes, only allow multimedia/audio maestros&n; *  v0.04 - Sep 01 1999 - Zach Brown &lt;zab@redhat.com&gt;&n; *&t;copied memory leak fix from sonicvibes driver&n; *&t;different ac97 reset, play with 2.0 ac97, simplify ring bus setup&n; *&t;bob freq code, region sanity, jitter sync fix; all from Eric &n; *&n; * TODO&n; *&t;fix bob frequency&n; *&t;endianness&n; *&t;do smart things with ac97 2.0 bits.&n; *&t;docking and dual codecs and 978?&n; *&t;leave 54-&gt;61 open&n; *&n; *&t;it also would be fun to have a mode that would not use pci dma at all&n; *&t;but would copy into the wavecache on board memory and use that &n; *&t;on architectures that don&squot;t like the maestro&squot;s pci dma ickiness.&n; */
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0)
DECL|macro|DECLARE_WAITQUEUE
mdefine_line|#define DECLARE_WAITQUEUE(QUEUE,INIT) struct wait_queue QUEUE = {INIT, NULL}
DECL|macro|wait_queue_head_t
mdefine_line|#define wait_queue_head_t struct wait_queue *
DECL|macro|SILLY_PCI_BASE_ADDRESS
mdefine_line|#define SILLY_PCI_BASE_ADDRESS(PCIDEV) (PCIDEV-&gt;base_address[0] &amp; PCI_BASE_ADDRESS_IO_MASK)
DECL|macro|SILLY_INIT_SEM
mdefine_line|#define SILLY_INIT_SEM(SEM) SEM=MUTEX;
DECL|macro|init_waitqueue_head
mdefine_line|#define init_waitqueue_head init_waitqueue
DECL|macro|SILLY_MAKE_INIT
mdefine_line|#define SILLY_MAKE_INIT(FUNC) __initfunc(FUNC)
DECL|macro|SILLY_OFFSET
mdefine_line|#define SILLY_OFFSET(VMA) ((VMA)-&gt;vm_offset)
macro_line|#else
DECL|macro|SILLY_PCI_BASE_ADDRESS
mdefine_line|#define SILLY_PCI_BASE_ADDRESS(PCIDEV) (PCIDEV-&gt;resource[0].start)
DECL|macro|SILLY_INIT_SEM
mdefine_line|#define SILLY_INIT_SEM(SEM) init_MUTEX(&amp;SEM)
DECL|macro|SILLY_MAKE_INIT
mdefine_line|#define SILLY_MAKE_INIT(FUNC) __init FUNC
DECL|macro|SILLY_OFFSET
mdefine_line|#define SILLY_OFFSET(VMA) ((VMA)-&gt;vm_pgoff)
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
r_static
r_int
id|maestro_pm_callback
c_func
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|d
)paren
suffix:semicolon
macro_line|#include &quot;maestro.h&quot;
multiline_comment|/* --------------------------------------------------------------------- */
DECL|macro|M_DEBUG
mdefine_line|#define M_DEBUG 1
macro_line|#ifdef M_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|macro|M_printk
mdefine_line|#define M_printk(args...) {if (debug) printk(args);}
macro_line|#else
DECL|macro|M_printk
mdefine_line|#define M_printk(x)
macro_line|#endif
multiline_comment|/* we try to setup 2^(dsps_order) /dev/dsp devices */
DECL|variable|dsps_order
r_static
r_int
id|dsps_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wether or not we mess around with power management */
DECL|variable|use_pm
r_static
r_int
id|use_pm
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* set to 1 for force */
multiline_comment|/* clocking for broken hardware - a few laptops seem to use a 50Khz clock&n;&t;ie insmod with clocking=50000 or so */
DECL|variable|clocking
r_static
r_int
id|clocking
op_assign
l_int|48000
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.14&quot;
macro_line|#ifndef PCI_VENDOR_ESS
DECL|macro|PCI_VENDOR_ESS
mdefine_line|#define PCI_VENDOR_ESS&t;&t;&t;0x125D
DECL|macro|PCI_DEVICE_ID_ESS_ESS1968
mdefine_line|#define PCI_DEVICE_ID_ESS_ESS1968&t;0x1968&t;&t;/* Maestro 2&t;*/
DECL|macro|PCI_DEVICE_ID_ESS_ESS1978
mdefine_line|#define PCI_DEVICE_ID_ESS_ESS1978      &t;0x1978&t;&t;/* Maestro 2E&t;*/
DECL|macro|PCI_VENDOR_ESS_OLD
mdefine_line|#define PCI_VENDOR_ESS_OLD&t;&t;0x1285&t;&t;/* Platform Tech, &n;&t;&t;&t;&t;&t;&t;the people the maestro &n;&t;&t;&t;&t;&t;&t;was bought from */
DECL|macro|PCI_DEVICE_ID_ESS_ESS0100
mdefine_line|#define PCI_DEVICE_ID_ESS_ESS0100&t;0x0100&t;&t;/* maestro 1 */
macro_line|#endif /* PCI_VENDOR_ESS */
DECL|macro|ESS_CHAN_HARD
mdefine_line|#define ESS_CHAN_HARD&t;&t;0x100
multiline_comment|/* NEC Versas ? */
DECL|macro|NEC_VERSA_SUBID1
mdefine_line|#define NEC_VERSA_SUBID1&t;0x80581033
DECL|macro|NEC_VERSA_SUBID2
mdefine_line|#define NEC_VERSA_SUBID2&t;0x803c1033
multiline_comment|/* changed so that I could actually find all the&n;&t;references and fix them up.  its a little more readable now. */
DECL|macro|ESS_FMT_STEREO
mdefine_line|#define ESS_FMT_STEREO&t;0x01
DECL|macro|ESS_FMT_16BIT
mdefine_line|#define ESS_FMT_16BIT&t;0x02
DECL|macro|ESS_FMT_MASK
mdefine_line|#define ESS_FMT_MASK&t;0x03
DECL|macro|ESS_DAC_SHIFT
mdefine_line|#define ESS_DAC_SHIFT&t;0   
DECL|macro|ESS_ADC_SHIFT
mdefine_line|#define ESS_ADC_SHIFT&t;4
DECL|macro|ESS_STATE_MAGIC
mdefine_line|#define ESS_STATE_MAGIC&t;&t;0x125D1968
DECL|macro|ESS_CARD_MAGIC
mdefine_line|#define ESS_CARD_MAGIC&t;&t;0x19283746
DECL|macro|DAC_RUNNING
mdefine_line|#define DAC_RUNNING&t;&t;1
DECL|macro|ADC_RUNNING
mdefine_line|#define ADC_RUNNING&t;&t;2
DECL|macro|MAX_DSP_ORDER
mdefine_line|#define MAX_DSP_ORDER&t;2
DECL|macro|MAX_DSPS
mdefine_line|#define MAX_DSPS&t;(1&lt;&lt;MAX_DSP_ORDER)
DECL|macro|NR_DSPS
mdefine_line|#define NR_DSPS&t;&t;(1&lt;&lt;dsps_order)
DECL|macro|NR_IDRS
mdefine_line|#define NR_IDRS&t;&t;32
DECL|macro|NR_APUS
mdefine_line|#define NR_APUS&t;&t;64
DECL|macro|NR_APU_REGS
mdefine_line|#define NR_APU_REGS&t;16
multiline_comment|/* acpi states */
r_enum
(brace
DECL|enumerator|ACPI_D0
id|ACPI_D0
op_assign
l_int|0
comma
DECL|enumerator|ACPI_D1
id|ACPI_D1
comma
DECL|enumerator|ACPI_D2
id|ACPI_D2
comma
DECL|enumerator|ACPI_D3
id|ACPI_D3
)brace
suffix:semicolon
multiline_comment|/* bits in the acpi masks */
DECL|macro|ACPI_12MHZ
mdefine_line|#define ACPI_12MHZ&t;( 1 &lt;&lt; 15)
DECL|macro|ACPI_24MHZ
mdefine_line|#define ACPI_24MHZ&t;( 1 &lt;&lt; 14)
DECL|macro|ACPI_978
mdefine_line|#define ACPI_978&t;( 1 &lt;&lt; 13)
DECL|macro|ACPI_SPDIF
mdefine_line|#define ACPI_SPDIF&t;( 1 &lt;&lt; 12)
DECL|macro|ACPI_GLUE
mdefine_line|#define ACPI_GLUE&t;( 1 &lt;&lt; 11)
DECL|macro|ACPI__10
mdefine_line|#define ACPI__10&t;( 1 &lt;&lt; 10) /* reserved */
DECL|macro|ACPI_PCIINT
mdefine_line|#define ACPI_PCIINT&t;( 1 &lt;&lt; 9)
DECL|macro|ACPI_HV
mdefine_line|#define ACPI_HV&t;&t;( 1 &lt;&lt; 8) /* hardware volume */
DECL|macro|ACPI_GPIO
mdefine_line|#define ACPI_GPIO&t;( 1 &lt;&lt; 7)
DECL|macro|ACPI_ASSP
mdefine_line|#define ACPI_ASSP&t;( 1 &lt;&lt; 6)
DECL|macro|ACPI_SB
mdefine_line|#define ACPI_SB&t;&t;( 1 &lt;&lt; 5) /* sb emul */
DECL|macro|ACPI_FM
mdefine_line|#define ACPI_FM&t;&t;( 1 &lt;&lt; 4) /* fm emul */
DECL|macro|ACPI_RB
mdefine_line|#define ACPI_RB&t;&t;( 1 &lt;&lt; 3) /* ringbus / aclink */
DECL|macro|ACPI_MIDI
mdefine_line|#define ACPI_MIDI&t;( 1 &lt;&lt; 2) 
DECL|macro|ACPI_GP
mdefine_line|#define ACPI_GP&t;&t;( 1 &lt;&lt; 1) /* game port */
DECL|macro|ACPI_WP
mdefine_line|#define ACPI_WP&t;&t;( 1 &lt;&lt; 0) /* wave processor */
DECL|macro|ACPI_ALL
mdefine_line|#define ACPI_ALL&t;(0xffff)
DECL|macro|ACPI_SLEEP
mdefine_line|#define ACPI_SLEEP&t;(~(ACPI_SPDIF|ACPI_ASSP|ACPI_SB|ACPI_FM| &bslash;&n;&t;&t;&t;ACPI_MIDI|ACPI_GP|ACPI_WP))
DECL|macro|ACPI_NONE
mdefine_line|#define ACPI_NONE&t;(ACPI__10)
multiline_comment|/* these masks indicate which units we care about at&n;&t;which states */
DECL|variable|acpi_state_mask
id|u16
id|acpi_state_mask
(braket
)braket
op_assign
(brace
(braket
id|ACPI_D0
)braket
op_assign
id|ACPI_ALL
comma
(braket
id|ACPI_D1
)braket
op_assign
id|ACPI_SLEEP
comma
(braket
id|ACPI_D2
)braket
op_assign
id|ACPI_SLEEP
comma
(braket
id|ACPI_D3
)braket
op_assign
id|ACPI_NONE
)brace
suffix:semicolon
DECL|variable|sample_size
r_static
r_const
r_int
id|sample_size
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|4
)brace
suffix:semicolon
DECL|variable|sample_shift
r_static
r_const
r_int
id|sample_shift
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
)brace
suffix:semicolon
DECL|enum|card_types_t
r_enum
id|card_types_t
(brace
DECL|enumerator|TYPE_MAESTRO
id|TYPE_MAESTRO
comma
DECL|enumerator|TYPE_MAESTRO2
id|TYPE_MAESTRO2
comma
DECL|enumerator|TYPE_MAESTRO2E
id|TYPE_MAESTRO2E
)brace
suffix:semicolon
DECL|variable|card_names
r_static
r_const
r_char
op_star
id|card_names
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|clock_freq
r_static
r_int
id|clock_freq
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_int
id|maestro_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
comma
r_int
r_int
id|event
comma
r_void
op_star
id|buf
)paren
suffix:semicolon
DECL|variable|maestro_nb
r_static
r_struct
id|notifier_block
id|maestro_nb
op_assign
(brace
id|maestro_notifier
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|struct|ess_state
r_struct
id|ess_state
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* FIXME: we probably want submixers in here, but only one record pair */
DECL|member|apu
id|u8
id|apu
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* l/r output, l/r intput converters, l/r input apus */
DECL|member|apu_mode
id|u8
id|apu_mode
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Running mode for this APU */
DECL|member|apu_pan
id|u8
id|apu_pan
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Panning setup for this APU */
DECL|member|apu_base
id|u32
id|apu_base
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* base address for this apu */
DECL|member|card
r_struct
id|ess_card
op_star
id|card
suffix:semicolon
multiline_comment|/* Card info */
multiline_comment|/* wave stuff */
DECL|member|rateadc
DECL|member|ratedac
r_int
r_int
id|rateadc
comma
id|ratedac
suffix:semicolon
DECL|member|fmt
DECL|member|enable
r_int
r_char
id|fmt
comma
id|enable
suffix:semicolon
DECL|member|index
r_int
id|index
suffix:semicolon
multiline_comment|/* this locks around the oss state in the driver */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* only let 1 be opening at a time */
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
multiline_comment|/* soundcore stuff */
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
multiline_comment|/* XXX zab - swptr only in here so that it can be referenced by&n;&t;&t;&t;clear_advance, as far as I can tell :( */
DECL|member|hwptr
DECL|member|swptr
r_int
id|hwptr
comma
id|swptr
suffix:semicolon
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* over/underrun */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* redundant, but makes calculations easier */
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
multiline_comment|/* OSS stuff */
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* our oss buffers are ready to go */
DECL|member|endcleared
r_int
id|endcleared
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ossfragshift
r_int
id|ossfragshift
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|base
id|u16
id|base
suffix:semicolon
multiline_comment|/* Offset for ptr */
DECL|member|dma_dac
DECL|member|dma_adc
)brace
id|dma_dac
comma
id|dma_adc
suffix:semicolon
multiline_comment|/* pointer to each dsp?s piece of the apu-&gt;src buffer page */
DECL|member|mixbuf
r_void
op_star
id|mixbuf
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ess_card
r_struct
id|ess_card
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* We keep maestro cards in a linked list */
DECL|member|next
r_struct
id|ess_card
op_star
id|next
suffix:semicolon
DECL|member|dev_mixer
r_int
id|dev_mixer
suffix:semicolon
DECL|member|card_type
r_int
id|card_type
suffix:semicolon
multiline_comment|/* as most of this is static,&n;&t;&t;perhaps it should be a pointer to a global struct */
DECL|struct|mixer_goo
r_struct
id|mixer_goo
(brace
DECL|member|modcnt
r_int
id|modcnt
suffix:semicolon
DECL|member|supported_mixers
r_int
id|supported_mixers
suffix:semicolon
DECL|member|stereo_mixers
r_int
id|stereo_mixers
suffix:semicolon
DECL|member|record_sources
r_int
id|record_sources
suffix:semicolon
multiline_comment|/* the caller must guarantee arg sanity before calling these */
multiline_comment|/*&t;&t;int (*read_mixer)(struct ess_card *card, int index);*/
DECL|member|write_mixer
r_void
(paren
op_star
id|write_mixer
)paren
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|mixer
comma
r_int
r_int
id|left
comma
r_int
r_int
id|right
)paren
suffix:semicolon
DECL|member|recmask_io
r_int
(paren
op_star
id|recmask_io
)paren
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|rw
comma
r_int
id|mask
)paren
suffix:semicolon
DECL|member|mixer_state
r_int
r_int
id|mixer_state
(braket
id|SOUND_MIXER_NRDEVICES
)braket
suffix:semicolon
DECL|member|mix
)brace
id|mix
suffix:semicolon
DECL|member|power_regs
r_int
id|power_regs
suffix:semicolon
DECL|member|in_suspend
r_int
id|in_suspend
suffix:semicolon
DECL|member|suspend_queue
id|wait_queue_head_t
id|suspend_queue
suffix:semicolon
DECL|member|channels
r_struct
id|ess_state
id|channels
(braket
id|MAX_DSPS
)braket
suffix:semicolon
DECL|member|maestro_map
id|u16
id|maestro_map
(braket
id|NR_IDRS
)braket
suffix:semicolon
multiline_comment|/* Register map */
multiline_comment|/* we have to store this junk so that we can come back from a&n;&t;&t;suspend */
DECL|member|apu_map
id|u16
id|apu_map
(braket
id|NR_APUS
)braket
(braket
id|NR_APU_REGS
)braket
suffix:semicolon
multiline_comment|/* contents of apu regs */
multiline_comment|/* this locks around the physical registers on the card */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* memory for this card.. wavecache limited :(*/
DECL|member|dmapages
r_void
op_star
id|dmapages
suffix:semicolon
DECL|member|dmaorder
r_int
id|dmaorder
suffix:semicolon
multiline_comment|/* hardware resources */
DECL|member|pcidev
r_struct
id|pci_dev
op_star
id|pcidev
suffix:semicolon
DECL|member|iobase
id|u32
id|iobase
suffix:semicolon
DECL|member|irq
id|u32
id|irq
suffix:semicolon
DECL|member|bob_freq
r_int
id|bob_freq
suffix:semicolon
DECL|member|dsps_open
r_char
id|dsps_open
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|ld2
id|ld2
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10000
)paren
(brace
id|x
op_rshift_assign
l_int|16
suffix:semicolon
id|r
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x100
)paren
(brace
id|x
op_rshift_assign
l_int|8
suffix:semicolon
id|r
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10
)paren
(brace
id|x
op_rshift_assign
l_int|4
suffix:semicolon
id|r
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|4
)paren
(brace
id|x
op_rshift_assign
l_int|2
suffix:semicolon
id|r
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|2
)paren
id|r
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
r_static
r_void
id|check_suspend
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|ess_card
op_star
id|devs
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; *&t;ESS Maestro AC97 codec programming interface.&n; */
DECL|function|maestro_ac97_set
r_static
r_void
id|maestro_ac97_set
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
id|u8
id|cmd
comma
id|u16
id|val
)paren
(brace
r_int
id|io
op_assign
id|card-&gt;iobase
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait for the codec bus to be free &n;&t; */
id|check_suspend
c_func
(paren
id|card
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ESS_AC97_INDEX
)paren
op_amp
l_int|1
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Write the bus&n;&t; */
id|outw
c_func
(paren
id|val
comma
id|io
op_plus
id|ESS_AC97_DATA
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmd
comma
id|io
op_plus
id|ESS_AC97_INDEX
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|maestro_ac97_get
r_static
id|u16
id|maestro_ac97_get
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
id|u8
id|cmd
)paren
(brace
r_int
id|io
op_assign
id|card-&gt;iobase
suffix:semicolon
r_int
id|sanity
op_assign
l_int|10000
suffix:semicolon
id|u16
id|data
suffix:semicolon
r_int
id|i
suffix:semicolon
id|check_suspend
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait for the codec bus to be free &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ESS_AC97_INDEX
)paren
op_amp
l_int|1
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
id|cmd
op_or
l_int|0x80
comma
id|io
op_plus
id|ESS_AC97_INDEX
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ESS_AC97_INDEX
)paren
op_amp
l_int|1
)paren
(brace
id|sanity
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sanity
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;maestro: ac97 codec timeout reading 0x%x.&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|data
op_assign
id|inw
c_func
(paren
id|io
op_plus
id|ESS_AC97_DATA
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/* OSS interface to the ac97s.. */
DECL|macro|AC97_STEREO_MASK
mdefine_line|#define AC97_STEREO_MASK (SOUND_MASK_VOLUME|&bslash;&n;&t;SOUND_MASK_PCM|SOUND_MASK_LINE|SOUND_MASK_CD|&bslash;&n;&t;SOUND_MASK_VIDEO|SOUND_MASK_LINE1|SOUND_MASK_IGAIN)
DECL|macro|AC97_SUPPORTED_MASK
mdefine_line|#define AC97_SUPPORTED_MASK (AC97_STEREO_MASK | &bslash;&n;&t;SOUND_MASK_BASS|SOUND_MASK_TREBLE|SOUND_MASK_MIC|&bslash;&n;&t;SOUND_MASK_SPEAKER)
DECL|macro|AC97_RECORD_MASK
mdefine_line|#define AC97_RECORD_MASK (SOUND_MASK_MIC|&bslash;&n;&t;SOUND_MASK_CD| SOUND_MASK_VIDEO| SOUND_MASK_LINE1| SOUND_MASK_LINE|&bslash;&n;&t;SOUND_MASK_PHONEIN)
DECL|macro|supported_mixer
mdefine_line|#define supported_mixer(CARD,FOO) ( CARD-&gt;mix.supported_mixers &amp; (1&lt;&lt;FOO) )
multiline_comment|/* this table has default mixer values for all OSS mixers.&n;&t;be sure to fill it in if you add oss mixers&n;&t;to anyone&squot;s supported mixer defines */
DECL|variable|mixer_defaults
r_int
r_int
id|mixer_defaults
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_BASS
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_TREBLE
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
l_int|0x8000
comma
multiline_comment|/* annoying */
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_CD
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_VIDEO
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
l_int|0x3232
comma
(braket
id|SOUND_MIXER_IGAIN
)braket
op_assign
l_int|0x3232
)brace
suffix:semicolon
DECL|struct|ac97_mixer_hw
r_static
r_struct
id|ac97_mixer_hw
(brace
DECL|member|offset
r_int
r_char
id|offset
suffix:semicolon
DECL|member|scale
r_int
id|scale
suffix:semicolon
DECL|variable|ac97_hw
)brace
id|ac97_hw
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
(brace
l_int|0x02
comma
l_int|63
)brace
comma
(braket
id|SOUND_MIXER_BASS
)braket
op_assign
(brace
l_int|0x08
comma
l_int|15
)brace
comma
(braket
id|SOUND_MIXER_TREBLE
)braket
op_assign
(brace
l_int|0x08
comma
l_int|15
)brace
comma
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
(brace
l_int|0x0a
comma
l_int|15
)brace
comma
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
(brace
l_int|0x0e
comma
l_int|31
)brace
comma
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
(brace
l_int|0x10
comma
l_int|31
)brace
comma
(braket
id|SOUND_MIXER_CD
)braket
op_assign
(brace
l_int|0x12
comma
l_int|31
)brace
comma
(braket
id|SOUND_MIXER_VIDEO
)braket
op_assign
(brace
l_int|0x14
comma
l_int|31
)brace
comma
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
(brace
l_int|0x16
comma
l_int|31
)brace
comma
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
(brace
l_int|0x18
comma
l_int|31
)brace
comma
(braket
id|SOUND_MIXER_IGAIN
)braket
op_assign
(brace
l_int|0x1c
comma
l_int|15
)brace
)brace
suffix:semicolon
macro_line|#if 0 /* *shrug* removed simply because we never used it.&n;&t;&t;feel free to implement again if needed */
multiline_comment|/* reads the given OSS mixer from the ac97&n;&t;the caller must have insured that the ac97 knows&n;&t;about that given mixer, and should be holding a&n;&t;spinlock for the card */
r_static
r_int
id|ac97_read_mixer
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|mixer
)paren
(brace
id|u16
id|val
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_mixer_hw
op_star
id|mh
op_assign
op_amp
id|ac97_hw
(braket
id|mixer
)braket
suffix:semicolon
id|val
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
id|mh-&gt;offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AC97_STEREO_MASK
op_amp
(paren
l_int|1
op_lshift
id|mixer
)paren
)paren
(brace
multiline_comment|/* nice stereo mixers .. */
r_int
id|left
comma
id|right
suffix:semicolon
id|left
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|right
op_assign
id|val
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_IGAIN
)paren
(brace
id|right
op_assign
(paren
id|right
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
suffix:semicolon
id|left
op_assign
(paren
id|left
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
suffix:semicolon
r_else
(brace
id|right
op_assign
l_int|100
op_minus
(paren
(paren
id|right
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
)paren
suffix:semicolon
id|left
op_assign
l_int|100
op_minus
(paren
(paren
id|left
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|left
op_or
(paren
id|right
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_SPEAKER
)paren
(brace
id|ret
op_assign
l_int|100
op_minus
(paren
(paren
(paren
(paren
id|val
op_amp
l_int|0x1e
)paren
op_rshift
l_int|1
)paren
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_MIC
)paren
(brace
id|ret
op_assign
l_int|100
op_minus
(paren
(paren
(paren
id|val
op_amp
l_int|0x1f
)paren
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
)paren
suffix:semicolon
multiline_comment|/*  the low bit is optional in the tone sliders and masking&n;&t;&t;it lets is avoid the 0xf &squot;bypass&squot;.. */
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_BASS
)paren
(brace
id|ret
op_assign
l_int|100
op_minus
(paren
(paren
(paren
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xe
)paren
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_TREBLE
)paren
(brace
id|ret
op_assign
l_int|100
op_minus
(paren
(paren
(paren
id|val
op_amp
l_int|0xe
)paren
op_star
l_int|100
)paren
op_div
id|mh-&gt;scale
)paren
suffix:semicolon
)brace
id|M_printk
c_func
(paren
l_string|&quot;read mixer %d (0x%x) %x -&gt; %x&bslash;n&quot;
comma
id|mixer
comma
id|mh-&gt;offset
comma
id|val
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* write the OSS encoded volume to the given OSS encoded mixer,&n;&t;again caller&squot;s job to make sure all is well in arg land,&n;&t;call with spinlock held */
multiline_comment|/* linear scale -&gt; log */
DECL|variable|lin2log
r_static
r_int
r_char
id|lin2log
(braket
l_int|101
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|15
comma
l_int|23
comma
l_int|30
comma
l_int|34
comma
l_int|38
comma
l_int|42
comma
l_int|45
comma
l_int|47
comma
l_int|50
comma
l_int|52
comma
l_int|53
comma
l_int|55
comma
l_int|57
comma
l_int|58
comma
l_int|60
comma
l_int|61
comma
l_int|62
comma
l_int|63
comma
l_int|65
comma
l_int|66
comma
l_int|67
comma
l_int|68
comma
l_int|69
comma
l_int|69
comma
l_int|70
comma
l_int|71
comma
l_int|72
comma
l_int|73
comma
l_int|73
comma
l_int|74
comma
l_int|75
comma
l_int|75
comma
l_int|76
comma
l_int|77
comma
l_int|77
comma
l_int|78
comma
l_int|78
comma
l_int|79
comma
l_int|80
comma
l_int|80
comma
l_int|81
comma
l_int|81
comma
l_int|82
comma
l_int|82
comma
l_int|83
comma
l_int|83
comma
l_int|84
comma
l_int|84
comma
l_int|84
comma
l_int|85
comma
l_int|85
comma
l_int|86
comma
l_int|86
comma
l_int|87
comma
l_int|87
comma
l_int|87
comma
l_int|88
comma
l_int|88
comma
l_int|88
comma
l_int|89
comma
l_int|89
comma
l_int|89
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|91
comma
l_int|91
comma
l_int|91
comma
l_int|92
comma
l_int|92
comma
l_int|92
comma
l_int|93
comma
l_int|93
comma
l_int|93
comma
l_int|94
comma
l_int|94
comma
l_int|94
comma
l_int|94
comma
l_int|95
comma
l_int|95
comma
l_int|95
comma
l_int|95
comma
l_int|96
comma
l_int|96
comma
l_int|96
comma
l_int|96
comma
l_int|97
comma
l_int|97
comma
l_int|97
comma
l_int|97
comma
l_int|98
comma
l_int|98
comma
l_int|98
comma
l_int|98
comma
l_int|99
comma
l_int|99
comma
l_int|99
comma
l_int|99
comma
l_int|99
)brace
suffix:semicolon
DECL|function|ac97_write_mixer
r_static
r_void
id|ac97_write_mixer
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|mixer
comma
r_int
r_int
id|left
comma
r_int
r_int
id|right
)paren
(brace
id|u16
id|val
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_mixer_hw
op_star
id|mh
op_assign
op_amp
id|ac97_hw
(braket
id|mixer
)braket
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;wrote mixer %d (0x%x) %d,%d&quot;
comma
id|mixer
comma
id|mh-&gt;offset
comma
id|left
comma
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AC97_STEREO_MASK
op_amp
(paren
l_int|1
op_lshift
id|mixer
)paren
)paren
(brace
multiline_comment|/* stereo mixers, mute them if we can */
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_IGAIN
)paren
(brace
multiline_comment|/* igain&squot;s slider is reversed.. */
id|right
op_assign
(paren
id|right
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
suffix:semicolon
id|left
op_assign
(paren
id|left
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
(paren
id|left
op_eq
l_int|0
)paren
op_logical_and
(paren
id|right
op_eq
l_int|0
)paren
)paren
id|val
op_or_assign
l_int|0x8000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* log conversion for the stereo controls */
r_if
c_cond
(paren
(paren
id|left
op_eq
l_int|0
)paren
op_logical_and
(paren
id|right
op_eq
l_int|0
)paren
)paren
(brace
id|val
op_assign
l_int|0x8000
suffix:semicolon
)brace
id|right
op_assign
(paren
(paren
l_int|100
op_minus
id|lin2log
(braket
id|right
)braket
)paren
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
suffix:semicolon
id|left
op_assign
(paren
(paren
l_int|100
op_minus
id|lin2log
(braket
id|left
)braket
)paren
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
suffix:semicolon
)brace
id|val
op_or_assign
(paren
id|left
op_lshift
l_int|8
)paren
op_or
id|right
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_SPEAKER
)paren
(brace
id|val
op_assign
(paren
(paren
(paren
l_int|100
op_minus
id|left
)paren
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
)paren
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_MIC
)paren
(brace
id|val
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
id|mh-&gt;offset
)paren
op_amp
op_complement
l_int|0x801f
suffix:semicolon
id|val
op_or_assign
(paren
(paren
(paren
l_int|100
op_minus
id|left
)paren
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/*  the low bit is optional in the tone sliders and masking&n;&t;&t;it lets is avoid the 0xf &squot;bypass&squot;.. */
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_BASS
)paren
(brace
id|val
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
id|mh-&gt;offset
)paren
op_amp
op_complement
l_int|0x0f00
suffix:semicolon
id|val
op_or_assign
(paren
(paren
(paren
(paren
l_int|100
op_minus
id|left
)paren
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
)paren
op_lshift
l_int|8
)paren
op_amp
l_int|0x0e00
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mixer
op_eq
id|SOUND_MIXER_TREBLE
)paren
(brace
id|val
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
id|mh-&gt;offset
)paren
op_amp
op_complement
l_int|0x000f
suffix:semicolon
id|val
op_or_assign
(paren
(paren
(paren
l_int|100
op_minus
id|left
)paren
op_star
id|mh-&gt;scale
)paren
op_div
l_int|100
)paren
op_amp
l_int|0x000e
suffix:semicolon
)brace
id|maestro_ac97_set
c_func
(paren
id|card
comma
id|mh-&gt;offset
comma
id|val
)paren
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot; -&gt; %x&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/* the following tables allow us to go from &n;&t;OSS &lt;-&gt; ac97 quickly. */
DECL|enum|ac97_recsettings
r_enum
id|ac97_recsettings
(brace
DECL|enumerator|AC97_REC_MIC
id|AC97_REC_MIC
op_assign
l_int|0
comma
DECL|enumerator|AC97_REC_CD
id|AC97_REC_CD
comma
DECL|enumerator|AC97_REC_VIDEO
id|AC97_REC_VIDEO
comma
DECL|enumerator|AC97_REC_AUX
id|AC97_REC_AUX
comma
DECL|enumerator|AC97_REC_LINE
id|AC97_REC_LINE
comma
DECL|enumerator|AC97_REC_STEREO
id|AC97_REC_STEREO
comma
multiline_comment|/* combination of all enabled outputs..  */
DECL|enumerator|AC97_REC_MONO
id|AC97_REC_MONO
comma
multiline_comment|/*.. or the mono equivalent */
DECL|enumerator|AC97_REC_PHONE
id|AC97_REC_PHONE
)brace
suffix:semicolon
DECL|variable|ac97_oss_mask
r_static
r_int
r_int
id|ac97_oss_mask
(braket
)braket
op_assign
(brace
(braket
id|AC97_REC_MIC
)braket
op_assign
id|SOUND_MASK_MIC
comma
(braket
id|AC97_REC_CD
)braket
op_assign
id|SOUND_MASK_CD
comma
(braket
id|AC97_REC_VIDEO
)braket
op_assign
id|SOUND_MASK_VIDEO
comma
(braket
id|AC97_REC_AUX
)braket
op_assign
id|SOUND_MASK_LINE1
comma
(braket
id|AC97_REC_LINE
)braket
op_assign
id|SOUND_MASK_LINE
comma
(braket
id|AC97_REC_PHONE
)braket
op_assign
id|SOUND_MASK_PHONEIN
)brace
suffix:semicolon
multiline_comment|/* indexed by bit position */
DECL|variable|ac97_oss_rm
r_static
r_int
r_int
id|ac97_oss_rm
(braket
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
id|AC97_REC_MIC
comma
(braket
id|SOUND_MIXER_CD
)braket
op_assign
id|AC97_REC_CD
comma
(braket
id|SOUND_MIXER_VIDEO
)braket
op_assign
id|AC97_REC_VIDEO
comma
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
id|AC97_REC_AUX
comma
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
id|AC97_REC_LINE
comma
(braket
id|SOUND_MIXER_PHONEIN
)braket
op_assign
id|AC97_REC_PHONE
)brace
suffix:semicolon
multiline_comment|/* read or write the recmask &n;&t;the ac97 can really have left and right recording&n;&t;inputs independantly set, but OSS doesn&squot;t seem to &n;&t;want us to express that to the user. &n;&t;the caller guarantees that we have a supported bit set,&n;&t;and they must be holding the card&squot;s spinlock */
r_static
r_int
DECL|function|ac97_recmask_io
id|ac97_recmask_io
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|read
comma
r_int
id|mask
)paren
(brace
r_int
r_int
id|val
op_assign
id|ac97_oss_mask
(braket
id|maestro_ac97_get
c_func
(paren
id|card
comma
l_int|0x1a
)paren
op_amp
l_int|0x7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|read
)paren
r_return
id|val
suffix:semicolon
multiline_comment|/* oss can have many inputs, maestro cant.  try&n;&t;&t;to pick the &squot;new&squot; one */
r_if
c_cond
(paren
id|mask
op_ne
id|val
)paren
id|mask
op_and_assign
op_complement
id|val
suffix:semicolon
id|val
op_assign
id|ffs
c_func
(paren
id|mask
)paren
op_minus
l_int|1
suffix:semicolon
id|val
op_assign
id|ac97_oss_rm
(braket
id|val
)braket
suffix:semicolon
id|val
op_or_assign
id|val
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* set both channels */
id|M_printk
c_func
(paren
l_string|&quot;maestro: setting ac97 recmask to 0x%x&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x1a
comma
id|val
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;The Maestro can be wired to a standard AC97 compliant codec&n; *&t;(see www.intel.com for the pdf&squot;s on this), or to a PT101 codec&n; *&t;which appears to be the ES1918 (data sheet on the esstech.com.tw site)&n; *&n; *&t;The PT101 setup is untested.&n; */
DECL|function|maestro_ac97_init
r_static
id|u16
id|__init
id|maestro_ac97_init
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
(brace
id|u16
id|vend1
comma
id|vend2
comma
id|caps
suffix:semicolon
id|card-&gt;mix.supported_mixers
op_assign
id|AC97_SUPPORTED_MASK
suffix:semicolon
id|card-&gt;mix.stereo_mixers
op_assign
id|AC97_STEREO_MASK
suffix:semicolon
id|card-&gt;mix.record_sources
op_assign
id|AC97_RECORD_MASK
suffix:semicolon
multiline_comment|/*&t;card-&gt;mix.read_mixer = ac97_read_mixer;*/
id|card-&gt;mix.write_mixer
op_assign
id|ac97_write_mixer
suffix:semicolon
id|card-&gt;mix.recmask_io
op_assign
id|ac97_recmask_io
suffix:semicolon
id|vend1
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
l_int|0x7c
)paren
suffix:semicolon
id|vend2
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
l_int|0x7e
)paren
suffix:semicolon
id|caps
op_assign
id|maestro_ac97_get
c_func
(paren
id|card
comma
l_int|0x00
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: AC97 Codec detected: v: 0x%2x%2x caps: 0x%x pwr: 0x%x&bslash;n&quot;
comma
id|vend1
comma
id|vend2
comma
id|caps
comma
id|maestro_ac97_get
c_func
(paren
id|card
comma
l_int|0x26
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|caps
op_amp
l_int|0x4
)paren
)paren
(brace
multiline_comment|/* no bass/treble nobs */
id|card-&gt;mix.supported_mixers
op_and_assign
op_complement
(paren
id|SOUND_MASK_BASS
op_or
id|SOUND_MASK_TREBLE
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX endianness, dork head. */
multiline_comment|/* vendor specifc bits.. */
r_switch
c_cond
(paren
(paren
r_int
)paren
(paren
id|vend1
op_lshift
l_int|16
)paren
op_or
id|vend2
)paren
(brace
r_case
l_int|0x545200ff
suffix:colon
multiline_comment|/* TriTech */
multiline_comment|/* no idea what this does */
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x2a
comma
l_int|0x0001
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x2c
comma
l_int|0x0000
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x2c
comma
l_int|0xffff
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0&t;/* i thought the problems I was seeing were with&n;&t;the 1921, but apparently they were with the pci board&n;&t;it was on, so this code is commented out.&n;&t; lets see if this holds true. */
r_case
l_int|0x83847609
suffix:colon
multiline_comment|/* ESS 1921 */
multiline_comment|/* writing to 0xe (mic) or 0x1a (recmask) seems&n;&t;&t;&t;to hang this codec */
id|card-&gt;mix.supported_mixers
op_and_assign
op_complement
(paren
id|SOUND_MASK_MIC
)paren
suffix:semicolon
id|card-&gt;mix.record_sources
op_assign
l_int|0
suffix:semicolon
id|card-&gt;mix.recmask_io
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if 0&t;/* don&squot;t ask.  I have yet to see what these actually do. */
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x76
comma
l_int|0xABBA
)paren
suffix:semicolon
multiline_comment|/* o/~ Take a chance on me o/~ */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x78
comma
l_int|0x3002
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x78
comma
l_int|0x3802
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x1E
comma
l_int|0x0404
)paren
suffix:semicolon
multiline_comment|/* null misc stuff */
id|maestro_ac97_set
c_func
(paren
id|card
comma
l_int|0x20
comma
l_int|0x0000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0  /* there has been 1 person on the planet with a pt101 that we&n;&t;know of.  If they care, they can put this back in :) */
r_static
id|u16
id|maestro_pt101_init
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|iobase
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: PT101 Codec detected, initializing but _not_ installing mixer device.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* who knows.. */
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x2A
comma
l_int|0x0001
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x2C
comma
l_int|0x0000
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x2C
comma
l_int|0xFFFF
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x10
comma
l_int|0x9F1F
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x12
comma
l_int|0x0808
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x14
comma
l_int|0x9F1F
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x16
comma
l_int|0x9F1F
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x18
comma
l_int|0x0404
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x1A
comma
l_int|0x0000
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x1C
comma
l_int|0x0000
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x02
comma
l_int|0x0404
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x04
comma
l_int|0x0808
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x0C
comma
l_int|0x801F
)paren
suffix:semicolon
id|maestro_ac97_set
c_func
(paren
id|iobase
comma
l_int|0x0E
comma
l_int|0x801F
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* this is very magic, and very slow.. */
r_static
r_void
DECL|function|maestro_ac97_reset
id|maestro_ac97_reset
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
id|u16
id|save_68
suffix:semicolon
id|u16
id|w
suffix:semicolon
id|u32
id|vend
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x38
)paren
op_amp
l_int|0xfffc
comma
id|ioaddr
op_plus
l_int|0x38
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x3a
)paren
op_amp
l_int|0xfffc
comma
id|ioaddr
op_plus
l_int|0x3a
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x3c
)paren
op_amp
l_int|0xfffc
comma
id|ioaddr
op_plus
l_int|0x3c
)paren
suffix:semicolon
multiline_comment|/* reset the first codec */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
l_int|0x36
)paren
suffix:semicolon
id|save_68
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x68
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pcidev
comma
l_int|0x58
comma
op_amp
id|w
)paren
suffix:semicolon
multiline_comment|/* something magical with gpio and bus arb. */
id|pci_read_config_dword
c_func
(paren
id|pcidev
comma
id|PCI_SUBSYSTEM_VENDOR_ID
comma
op_amp
id|vend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|w
op_amp
l_int|0x1
)paren
(brace
id|save_68
op_or_assign
l_int|0x10
suffix:semicolon
)brace
id|outw
c_func
(paren
l_int|0xfffe
comma
id|ioaddr
op_plus
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* tickly gpio 0.. */
id|outw
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
l_int|0x68
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
l_int|0x60
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
l_int|0x60
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|outw
c_func
(paren
id|save_68
op_or
l_int|0x1
comma
id|ioaddr
op_plus
l_int|0x68
)paren
suffix:semicolon
multiline_comment|/* now restore .. */
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x38
)paren
op_amp
l_int|0xfffc
)paren
op_or
l_int|0x1
comma
id|ioaddr
op_plus
l_int|0x38
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x3a
)paren
op_amp
l_int|0xfffc
)paren
op_or
l_int|0x1
comma
id|ioaddr
op_plus
l_int|0x3a
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x3c
)paren
op_amp
l_int|0xfffc
)paren
op_or
l_int|0x1
comma
id|ioaddr
op_plus
l_int|0x3c
)paren
suffix:semicolon
multiline_comment|/* now the second codec */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
l_int|0x36
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xfff7
comma
id|ioaddr
op_plus
l_int|0x64
)paren
suffix:semicolon
id|save_68
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x68
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0009
comma
id|ioaddr
op_plus
l_int|0x68
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
l_int|0x60
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0009
comma
id|ioaddr
op_plus
l_int|0x60
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
multiline_comment|/* .. ouch.. */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x38
)paren
op_amp
l_int|0xfffc
comma
id|ioaddr
op_plus
l_int|0x38
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x3a
)paren
op_amp
l_int|0xfffc
comma
id|ioaddr
op_plus
l_int|0x3a
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x3c
)paren
op_amp
l_int|0xfffc
comma
id|ioaddr
op_plus
l_int|0x3c
)paren
suffix:semicolon
macro_line|#if 0 /* the loop here needs to be much better if we want it.. */
id|M_printk
c_func
(paren
l_string|&quot;trying software reset&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* try and do a software reset */
id|outb
c_func
(paren
l_int|0x80
op_or
l_int|0x7c
comma
id|ioaddr
op_plus
l_int|0x30
)paren
suffix:semicolon
r_for
c_loop
(paren
id|w
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|w
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x30
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0x32
)paren
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x80
op_or
l_int|0x7d
comma
id|ioaddr
op_plus
l_int|0x30
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x30
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0x32
)paren
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
op_or
l_int|0x7f
comma
id|ioaddr
op_plus
l_int|0x30
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x30
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0x32
)paren
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|w
OG
l_int|10000
)paren
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0x37
)paren
op_or
l_int|0x08
comma
id|ioaddr
op_plus
l_int|0x37
)paren
suffix:semicolon
multiline_comment|/* do a software reset */
id|mdelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
multiline_comment|/* oh my.. */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0x37
)paren
op_amp
op_complement
l_int|0x08
comma
id|ioaddr
op_plus
l_int|0x37
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x80
comma
id|ioaddr
op_plus
l_int|0x30
)paren
suffix:semicolon
r_for
c_loop
(paren
id|w
op_assign
l_int|0
suffix:semicolon
id|w
OL
l_int|10000
suffix:semicolon
id|w
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x30
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|vend
op_eq
id|NEC_VERSA_SUBID1
op_logical_or
id|vend
op_eq
id|NEC_VERSA_SUBID2
)paren
(brace
multiline_comment|/* turn on external amp? */
id|outw
c_func
(paren
l_int|0xf9ff
comma
id|ioaddr
op_plus
l_int|0x64
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x68
)paren
op_or
l_int|0x600
comma
id|ioaddr
op_plus
l_int|0x68
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0209
comma
id|ioaddr
op_plus
l_int|0x60
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Indirect register access. Not all registers are readable so we&n; *&t;need to keep register state ourselves&n; */
DECL|macro|WRITEABLE_MAP
mdefine_line|#define WRITEABLE_MAP&t;0xEFFFFF
DECL|macro|READABLE_MAP
mdefine_line|#define READABLE_MAP&t;0x64003F
multiline_comment|/*&n; *&t;The Maestro engineers were a little indirection happy. These indirected&n; *&t;registers themselves include indirect registers at another layer&n; */
DECL|function|__maestro_write
r_static
r_void
id|__maestro_write
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
id|u16
id|reg
comma
id|u16
id|data
)paren
(brace
r_int
id|ioaddr
op_assign
id|card-&gt;iobase
suffix:semicolon
id|outw
c_func
(paren
id|reg
comma
id|ioaddr
op_plus
l_int|0x02
)paren
suffix:semicolon
id|outw
c_func
(paren
id|data
comma
id|ioaddr
op_plus
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ge
id|NR_IDRS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;maestro: IDR %d out of bounds!&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
)brace
r_else
id|card-&gt;maestro_map
(braket
id|reg
)braket
op_assign
id|data
suffix:semicolon
)brace
DECL|function|maestro_write
r_static
r_void
id|maestro_write
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u16
id|reg
comma
id|u16
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|check_suspend
c_func
(paren
id|s-&gt;card
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__maestro_write
c_func
(paren
id|s-&gt;card
comma
id|reg
comma
id|data
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__maestro_read
r_static
id|u16
id|__maestro_read
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
id|u16
id|reg
)paren
(brace
r_int
id|ioaddr
op_assign
id|card-&gt;iobase
suffix:semicolon
id|outw
c_func
(paren
id|reg
comma
id|ioaddr
op_plus
l_int|0x02
)paren
suffix:semicolon
r_return
id|card-&gt;maestro_map
(braket
id|reg
)braket
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x00
)paren
suffix:semicolon
)brace
DECL|function|maestro_read
r_static
id|u16
id|maestro_read
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u16
id|reg
)paren
(brace
r_if
c_cond
(paren
id|READABLE_MAP
op_amp
(paren
l_int|1
op_lshift
id|reg
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|check_suspend
c_func
(paren
id|s-&gt;card
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__maestro_read
c_func
(paren
id|s-&gt;card
comma
id|reg
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|s-&gt;card-&gt;maestro_map
(braket
id|reg
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;These routines handle accessing the second level indirections to the&n; *&t;wave ram.&n; */
multiline_comment|/*&n; *&t;The register names are the ones ESS uses (see 104T31.ZIP)&n; */
DECL|macro|IDR0_DATA_PORT
mdefine_line|#define IDR0_DATA_PORT&t;&t;0x00
DECL|macro|IDR1_CRAM_POINTER
mdefine_line|#define IDR1_CRAM_POINTER&t;0x01
DECL|macro|IDR2_CRAM_DATA
mdefine_line|#define IDR2_CRAM_DATA&t;&t;0x02
DECL|macro|IDR3_WAVE_DATA
mdefine_line|#define IDR3_WAVE_DATA&t;&t;0x03
DECL|macro|IDR4_WAVE_PTR_LOW
mdefine_line|#define IDR4_WAVE_PTR_LOW&t;0x04
DECL|macro|IDR5_WAVE_PTR_HI
mdefine_line|#define IDR5_WAVE_PTR_HI&t;0x05
DECL|macro|IDR6_TIMER_CTRL
mdefine_line|#define IDR6_TIMER_CTRL&t;&t;0x06
DECL|macro|IDR7_WAVE_ROMRAM
mdefine_line|#define IDR7_WAVE_ROMRAM&t;0x07
DECL|function|apu_index_set
r_static
r_void
id|apu_index_set
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
id|u16
id|index
)paren
(brace
r_int
id|i
suffix:semicolon
id|__maestro_write
c_func
(paren
id|card
comma
id|IDR1_CRAM_POINTER
comma
id|index
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|__maestro_read
c_func
(paren
id|card
comma
id|IDR1_CRAM_POINTER
)paren
op_eq
id|index
)paren
(brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: APU register select failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|apu_data_set
r_static
r_void
id|apu_data_set
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
id|u16
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|__maestro_read
c_func
(paren
id|card
comma
id|IDR0_DATA_PORT
)paren
op_eq
id|data
)paren
(brace
r_return
suffix:semicolon
)brace
id|__maestro_write
c_func
(paren
id|card
comma
id|IDR0_DATA_PORT
comma
id|data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This is the public interface for APU manipulation. It handles the&n; *&t;interlock to avoid two APU writes in parallel etc. Don&squot;t diddle&n; *&t;directly with the stuff above.&n; */
DECL|function|apu_set_register
r_static
r_void
id|apu_set_register
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u16
id|channel
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|check_suspend
c_func
(paren
id|s-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_amp
id|ESS_CHAN_HARD
)paren
(brace
id|channel
op_and_assign
op_complement
id|ESS_CHAN_HARD
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|channel
OG
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BAD CHANNEL %d.&bslash;n&quot;
comma
id|channel
)paren
suffix:semicolon
)brace
r_else
id|channel
op_assign
id|s-&gt;apu
(braket
id|channel
)braket
suffix:semicolon
multiline_comment|/* store based on real hardware apu/reg */
id|s-&gt;card-&gt;apu_map
(braket
id|channel
)braket
(braket
id|reg
)braket
op_assign
id|data
suffix:semicolon
)brace
id|reg
op_or_assign
(paren
id|channel
op_lshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* hooray for double indirection!! */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|apu_index_set
c_func
(paren
id|s-&gt;card
comma
id|reg
)paren
suffix:semicolon
id|apu_data_set
c_func
(paren
id|s-&gt;card
comma
id|data
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|apu_get_register
r_static
id|u16
id|apu_get_register
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u16
id|channel
comma
id|u8
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u16
id|v
suffix:semicolon
id|check_suspend
c_func
(paren
id|s-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_amp
id|ESS_CHAN_HARD
)paren
(brace
id|channel
op_and_assign
op_complement
id|ESS_CHAN_HARD
suffix:semicolon
)brace
r_else
id|channel
op_assign
id|s-&gt;apu
(braket
id|channel
)braket
suffix:semicolon
id|reg
op_or_assign
(paren
id|channel
op_lshift
l_int|4
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|apu_index_set
c_func
(paren
id|s-&gt;card
comma
id|reg
)paren
suffix:semicolon
id|v
op_assign
id|__maestro_read
c_func
(paren
id|s-&gt;card
comma
id|IDR0_DATA_PORT
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The wavecache buffers between the APUs and&n; *&t;pci bus mastering&n; */
DECL|function|wave_set_register
r_static
r_void
id|wave_set_register
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u16
id|reg
comma
id|u16
id|value
)paren
(brace
r_int
id|ioaddr
op_assign
id|s-&gt;card-&gt;iobase
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|check_suspend
c_func
(paren
id|s-&gt;card
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outw
c_func
(paren
id|reg
comma
id|ioaddr
op_plus
l_int|0x10
)paren
suffix:semicolon
id|outw
c_func
(paren
id|value
comma
id|ioaddr
op_plus
l_int|0x12
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|wave_get_register
r_static
id|u16
id|wave_get_register
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u16
id|reg
)paren
(brace
r_int
id|ioaddr
op_assign
id|s-&gt;card-&gt;iobase
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u16
id|value
suffix:semicolon
id|check_suspend
c_func
(paren
id|s-&gt;card
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outw
c_func
(paren
id|reg
comma
id|ioaddr
op_plus
l_int|0x10
)paren
suffix:semicolon
id|value
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0x12
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
DECL|function|sound_reset
r_static
r_void
id|sound_reset
c_func
(paren
r_int
id|ioaddr
)paren
(brace
id|outw
c_func
(paren
l_int|0x2000
comma
l_int|0x18
op_plus
id|ioaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
l_int|0x18
op_plus
id|ioaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* sets the play formats of these apus, should be passed the already shifted format */
DECL|function|set_apu_fmt
r_static
r_void
id|set_apu_fmt
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
id|apu
comma
r_int
id|mode
)paren
(brace
r_int
id|apu_fmt
op_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mode
op_amp
id|ESS_FMT_16BIT
)paren
)paren
(brace
id|apu_fmt
op_add_assign
l_int|0x20
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|ESS_FMT_STEREO
)paren
)paren
(brace
id|apu_fmt
op_add_assign
l_int|0x10
suffix:semicolon
)brace
id|s-&gt;apu_mode
(braket
id|apu
)braket
op_assign
id|apu_fmt
suffix:semicolon
id|s-&gt;apu_mode
(braket
id|apu
op_plus
l_int|1
)braket
op_assign
id|apu_fmt
suffix:semicolon
)brace
multiline_comment|/* this only fixes the output apu mode to be later set by start_dac and&n;&t;company.  output apu modes are set in ess_rec_setup */
DECL|function|set_fmt
r_static
r_void
id|set_fmt
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|data
)paren
(brace
id|s-&gt;fmt
op_assign
(paren
id|s-&gt;fmt
op_amp
id|mask
)paren
op_or
id|data
suffix:semicolon
id|set_apu_fmt
c_func
(paren
id|s
comma
l_int|0
comma
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_MASK
)paren
suffix:semicolon
)brace
multiline_comment|/* this is off by a little bit.. */
DECL|function|compute_rate
r_static
id|u32
id|compute_rate
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
id|u32
id|freq
)paren
(brace
id|u32
id|clock
op_assign
id|clock_freq
(braket
id|s-&gt;card-&gt;card_type
)braket
suffix:semicolon
id|freq
op_assign
(paren
id|freq
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|freq
op_eq
l_int|48000
)paren
r_return
l_int|0x10000
suffix:semicolon
r_return
(paren
(paren
id|freq
op_div
id|clock
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
(paren
id|freq
op_mod
id|clock
)paren
op_lshift
l_int|16
)paren
op_div
id|clock
)paren
suffix:semicolon
)brace
DECL|function|set_dac_rate
r_static
r_void
id|set_dac_rate
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
r_int
id|rate
)paren
(brace
id|u32
id|freq
suffix:semicolon
r_int
id|fmt
op_assign
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_MASK
suffix:semicolon
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|4000
)paren
id|rate
op_assign
l_int|4000
suffix:semicolon
id|s-&gt;ratedac
op_assign
id|rate
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fmt
op_amp
id|ESS_FMT_16BIT
)paren
op_logical_and
op_logical_neg
(paren
id|fmt
op_amp
id|ESS_FMT_STEREO
)paren
)paren
(brace
id|rate
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&t;M_printk(&quot;computing dac rate %d with mode %d&bslash;n&quot;,rate,s-&gt;fmt);*/
id|freq
op_assign
id|compute_rate
c_func
(paren
id|s
comma
id|rate
)paren
suffix:semicolon
multiline_comment|/* Load the frequency, turn on 6dB */
id|apu_set_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|2
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|2
)paren
op_amp
l_int|0x00FF
)paren
op_or
(paren
(paren
(paren
id|freq
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|3
comma
id|freq
op_rshift
l_int|8
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|2
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|2
)paren
op_amp
l_int|0x00FF
)paren
op_or
(paren
(paren
(paren
id|freq
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|3
comma
id|freq
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|set_adc_rate
r_static
r_void
id|set_adc_rate
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
id|rate
)paren
(brace
id|u32
id|freq
suffix:semicolon
multiline_comment|/* Sample Rate conversion APUs don&squot;t like 0x10000 for their rate */
r_if
c_cond
(paren
id|rate
OG
l_int|47999
)paren
id|rate
op_assign
l_int|47999
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|4000
)paren
id|rate
op_assign
l_int|4000
suffix:semicolon
id|s-&gt;rateadc
op_assign
id|rate
suffix:semicolon
id|freq
op_assign
id|compute_rate
c_func
(paren
id|s
comma
id|rate
)paren
suffix:semicolon
multiline_comment|/* Load the frequency, turn on 6dB */
id|apu_set_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|2
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|2
)paren
op_amp
l_int|0x00FF
)paren
op_or
(paren
(paren
(paren
id|freq
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|3
comma
id|freq
op_rshift
l_int|8
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|2
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|2
)paren
op_amp
l_int|0x00FF
)paren
op_or
(paren
(paren
(paren
id|freq
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|3
comma
id|freq
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* fix mixer rate at 48khz.  and its _must_ be 0x10000. */
id|freq
op_assign
l_int|0x10000
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|4
comma
l_int|2
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|4
comma
l_int|2
)paren
op_amp
l_int|0x00FF
)paren
op_or
(paren
(paren
(paren
id|freq
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|4
comma
l_int|3
comma
id|freq
op_rshift
l_int|8
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|5
comma
l_int|2
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|5
comma
l_int|2
)paren
op_amp
l_int|0x00FF
)paren
op_or
(paren
(paren
(paren
id|freq
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|5
comma
l_int|3
comma
id|freq
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop our host of recording apus */
DECL|function|stop_adc
r_extern
r_inline
r_void
id|stop_adc
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
multiline_comment|/* XXX lets hope we don&squot;t have to lock around this */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;enable
op_amp
id|ADC_RUNNING
)paren
)paren
r_return
suffix:semicolon
id|s-&gt;enable
op_and_assign
op_complement
id|ADC_RUNNING
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|0
comma
id|apu_get_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|0
comma
id|apu_get_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|4
comma
l_int|0
comma
id|apu_get_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|5
comma
l_int|0
comma
id|apu_get_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
)brace
multiline_comment|/* stop output apus */
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
multiline_comment|/* XXX have to lock around this? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
r_return
suffix:semicolon
id|s-&gt;enable
op_and_assign
op_complement
id|DAC_RUNNING
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|0
comma
id|apu_get_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|0
comma
id|apu_get_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
multiline_comment|/* XXX locks? */
r_if
c_cond
(paren
(paren
id|s-&gt;dma_dac.mapped
op_logical_or
id|s-&gt;dma_dac.count
OG
l_int|0
)paren
op_logical_and
id|s-&gt;dma_dac.ready
op_logical_and
(paren
op_logical_neg
(paren
id|s-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
)paren
(brace
id|s-&gt;enable
op_or_assign
id|DAC_RUNNING
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|0
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
op_or
id|s-&gt;apu_mode
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_STEREO
)paren
(brace
id|apu_set_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|0
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|1
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
op_or
id|s-&gt;apu_mode
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
multiline_comment|/* XXX locks? */
r_if
c_cond
(paren
(paren
id|s-&gt;dma_adc.mapped
op_logical_or
id|s-&gt;dma_adc.count
OL
(paren
r_int
)paren
(paren
id|s-&gt;dma_adc.dmasize
op_minus
l_int|2
op_star
id|s-&gt;dma_adc.fragsize
)paren
)paren
op_logical_and
id|s-&gt;dma_adc.ready
op_logical_and
(paren
op_logical_neg
(paren
id|s-&gt;enable
op_amp
id|ADC_RUNNING
)paren
)paren
)paren
(brace
id|s-&gt;enable
op_or_assign
id|ADC_RUNNING
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|0
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
op_or
id|s-&gt;apu_mode
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|4
comma
l_int|0
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|4
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
op_or
id|s-&gt;apu_mode
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;fmt
op_amp
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
)paren
(brace
id|apu_set_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|0
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|3
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
op_or
id|s-&gt;apu_mode
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|s
comma
l_int|5
comma
l_int|0
comma
(paren
id|apu_get_register
c_func
(paren
id|s
comma
l_int|5
comma
l_int|0
)paren
op_amp
l_int|0xFF0F
)paren
op_or
id|s-&gt;apu_mode
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;Native play back driver &n; */
multiline_comment|/* the mode passed should be already shifted and masked */
r_static
r_void
DECL|function|ess_play_setup
id|ess_play_setup
c_func
(paren
r_struct
id|ess_state
op_star
id|ess
comma
r_int
id|mode
comma
id|u32
id|rate
comma
r_void
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
id|u32
id|pa
suffix:semicolon
id|u32
id|tmpval
suffix:semicolon
r_int
id|high_apu
op_assign
l_int|0
suffix:semicolon
r_int
id|channel
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;mode=%d rate=%d buf=%p len=%d.&bslash;n&quot;
comma
id|mode
comma
id|rate
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* all maestro sizes are in 16bit words */
id|size
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|ESS_FMT_STEREO
)paren
(brace
id|high_apu
op_increment
suffix:semicolon
multiline_comment|/* only 16/stereo gets size divided */
r_if
c_cond
(paren
id|mode
op_amp
id|ESS_FMT_16BIT
)paren
(brace
id|size
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|high_apu
suffix:semicolon
id|channel
op_increment
)paren
(brace
id|pa
op_assign
id|virt_to_bus
c_func
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/* set the wavecache control reg */
id|tmpval
op_assign
(paren
id|pa
op_minus
l_int|0x10
)paren
op_amp
l_int|0xFFF8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mode
op_amp
id|ESS_FMT_16BIT
)paren
)paren
(brace
id|tmpval
op_or_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|ESS_FMT_STEREO
)paren
(brace
id|tmpval
op_or_assign
l_int|2
suffix:semicolon
)brace
id|ess-&gt;apu_base
(braket
id|channel
)braket
op_assign
id|tmpval
suffix:semicolon
id|wave_set_register
c_func
(paren
id|ess
comma
id|ess-&gt;apu
(braket
id|channel
)braket
op_lshift
l_int|3
comma
id|tmpval
)paren
suffix:semicolon
id|pa
op_sub_assign
id|virt_to_bus
c_func
(paren
id|ess-&gt;card-&gt;dmapages
)paren
suffix:semicolon
id|pa
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* words */
multiline_comment|/* base offset of dma calcs when reading the pointer&n;&t;&t;&t;on the left one */
r_if
c_cond
(paren
op_logical_neg
id|channel
)paren
(brace
id|ess-&gt;dma_dac.base
op_assign
id|pa
op_amp
l_int|0xFFFF
suffix:semicolon
)brace
id|pa
op_or_assign
l_int|0x00400000
suffix:semicolon
multiline_comment|/* System RAM */
multiline_comment|/* XXX the 16bit here might not be needed.. */
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|ESS_FMT_STEREO
)paren
op_logical_and
(paren
id|mode
op_amp
id|ESS_FMT_16BIT
)paren
)paren
(brace
r_if
c_cond
(paren
id|channel
)paren
(brace
id|pa
op_or_assign
l_int|0x00800000
suffix:semicolon
)brace
multiline_comment|/* Stereo */
id|pa
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* XXX think about endianess when writing these registers */
id|M_printk
c_func
(paren
l_string|&quot;maestro: ess_play_setup: APU[%d] pa = 0x%x&bslash;n&quot;
comma
id|ess-&gt;apu
(braket
id|channel
)braket
comma
id|pa
)paren
suffix:semicolon
multiline_comment|/* start of sample */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|4
comma
(paren
(paren
id|pa
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|5
comma
id|pa
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
multiline_comment|/* sample end */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|6
comma
(paren
id|pa
op_plus
id|size
)paren
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
multiline_comment|/* setting loop len == sample len */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|7
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* clear effects/env.. */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|8
comma
l_int|0x0000
)paren
suffix:semicolon
multiline_comment|/* set amp now to 0xd0 (?), low byte is &squot;amplitude dest&squot;? */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|9
comma
l_int|0xD000
)paren
suffix:semicolon
multiline_comment|/* clear routing stuff */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|11
comma
l_int|0x0000
)paren
suffix:semicolon
multiline_comment|/* dma on, no envelopes, filter to all 1s) */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|0
comma
l_int|0x400F
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|ESS_FMT_16BIT
)paren
(brace
id|ess-&gt;apu_mode
(braket
id|channel
)braket
op_assign
l_int|0x10
suffix:semicolon
)brace
r_else
id|ess-&gt;apu_mode
(braket
id|channel
)braket
op_assign
l_int|0x30
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|ESS_FMT_STEREO
)paren
(brace
multiline_comment|/* set panning: left or right */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|10
comma
l_int|0x8F00
op_or
(paren
id|channel
ques
c_cond
l_int|0
suffix:colon
l_int|0x10
)paren
)paren
suffix:semicolon
id|ess-&gt;apu_mode
(braket
id|channel
)braket
op_add_assign
l_int|0x10
suffix:semicolon
)brace
r_else
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|10
comma
l_int|0x8F08
)paren
suffix:semicolon
)brace
multiline_comment|/* clear WP interupts */
id|outw
c_func
(paren
l_int|1
comma
id|ess-&gt;card-&gt;iobase
op_plus
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* enable WP ints */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ess-&gt;card-&gt;iobase
op_plus
l_int|0x18
)paren
op_or
l_int|4
comma
id|ess-&gt;card-&gt;iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* go team! */
id|set_dac_rate
c_func
(paren
id|ess
comma
id|rate
)paren
suffix:semicolon
id|start_dac
c_func
(paren
id|ess
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Native record driver &n; */
multiline_comment|/* again, passed mode is alrady shifted/masked */
r_static
r_void
DECL|function|ess_rec_setup
id|ess_rec_setup
c_func
(paren
r_struct
id|ess_state
op_star
id|ess
comma
r_int
id|mode
comma
id|u32
id|rate
comma
r_void
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_int
id|apu_step
op_assign
l_int|2
suffix:semicolon
r_int
id|channel
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: ess_rec_setup: mode=%d rate=%d buf=0x%p len=%d.&bslash;n&quot;
comma
id|mode
comma
id|rate
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* all maestro sizes are in 16bit words */
id|size
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* we&squot;re given the full size of the buffer, but&n;&t;in stereo each channel will only use its half */
r_if
c_cond
(paren
id|mode
op_amp
id|ESS_FMT_STEREO
)paren
(brace
id|size
op_rshift_assign
l_int|1
suffix:semicolon
id|apu_step
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* APU assignments: 2 = mono/left SRC&n;&t;                    3 = right SRC&n;&t;                    4 = mono/left Input Mixer&n;&t;                    5 = right Input Mixer */
r_for
c_loop
(paren
id|channel
op_assign
l_int|2
suffix:semicolon
id|channel
OL
l_int|6
suffix:semicolon
id|channel
op_add_assign
id|apu_step
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|bsize
comma
id|route
suffix:semicolon
id|u32
id|pa
suffix:semicolon
id|u32
id|tmpval
suffix:semicolon
multiline_comment|/* data seems to flow from the codec, through an apu into&n;&t;&t;&t;the &squot;mixbuf&squot; bit of page, then through the SRC apu&n;&t;&t;&t;and out to the real &squot;buffer&squot;.  ok.  sure.  */
r_if
c_cond
(paren
id|channel
op_amp
l_int|0x04
)paren
(brace
multiline_comment|/* ok, we&squot;re an input mixer going from adc&n;&t;&t;&t;&t;through the mixbuf to the other apus */
r_if
c_cond
(paren
op_logical_neg
(paren
id|channel
op_amp
l_int|0x01
)paren
)paren
(brace
id|pa
op_assign
id|virt_to_bus
c_func
(paren
id|ess-&gt;mixbuf
)paren
suffix:semicolon
)brace
r_else
(brace
id|pa
op_assign
id|virt_to_bus
c_func
(paren
id|ess-&gt;mixbuf
op_plus
(paren
id|PAGE_SIZE
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* we source from a &squot;magic&squot; apu */
id|bsize
op_assign
id|PAGE_SIZE
op_rshift
l_int|5
suffix:semicolon
multiline_comment|/* half of this channels alloc, in words */
id|route
op_assign
l_int|0x14
op_plus
(paren
id|channel
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* parallel in crap, see maestro reg 0xC [8-11] */
id|ess-&gt;apu_mode
(braket
id|channel
)braket
op_assign
l_int|0x90
suffix:semicolon
multiline_comment|/* Input Mixer */
)brace
r_else
(brace
multiline_comment|/* we&squot;re a rate converter taking&n;&t;&t;&t;&t;input from the input apus and outputing it to&n;&t;&t;&t;&t;system memory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|channel
op_amp
l_int|0x01
)paren
)paren
(brace
id|pa
op_assign
id|virt_to_bus
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* right channel records its split half.&n;&t;&t;&t;&t;*2 accomodates for rampant shifting earlier */
id|pa
op_assign
id|virt_to_bus
c_func
(paren
id|buffer
op_plus
id|size
op_star
l_int|2
)paren
suffix:semicolon
)brace
id|ess-&gt;apu_mode
(braket
id|channel
)braket
op_assign
l_int|0xB0
suffix:semicolon
multiline_comment|/* Sample Rate Converter */
id|bsize
op_assign
id|size
suffix:semicolon
multiline_comment|/* get input from inputing apu */
id|route
op_assign
id|channel
op_plus
l_int|2
suffix:semicolon
)brace
id|M_printk
c_func
(paren
l_string|&quot;maestro: ess_rec_setup: getting pa 0x%x from %d&bslash;n&quot;
comma
id|pa
comma
id|channel
)paren
suffix:semicolon
multiline_comment|/* set the wavecache control reg */
id|tmpval
op_assign
(paren
id|pa
op_minus
l_int|0x10
)paren
op_amp
l_int|0xFFF8
suffix:semicolon
id|ess-&gt;apu_base
(braket
id|channel
)braket
op_assign
id|tmpval
suffix:semicolon
id|wave_set_register
c_func
(paren
id|ess
comma
id|ess-&gt;apu
(braket
id|channel
)braket
op_lshift
l_int|3
comma
id|tmpval
)paren
suffix:semicolon
id|pa
op_sub_assign
id|virt_to_bus
c_func
(paren
id|ess-&gt;card-&gt;dmapages
)paren
suffix:semicolon
id|pa
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* words */
multiline_comment|/* base offset of dma calcs when reading the pointer&n;&t;&t;&t;on this left one */
r_if
c_cond
(paren
id|channel
op_eq
l_int|2
)paren
(brace
id|ess-&gt;dma_adc.base
op_assign
id|pa
op_amp
l_int|0xFFFF
suffix:semicolon
)brace
id|pa
op_or_assign
l_int|0x00400000
suffix:semicolon
multiline_comment|/* bit 22 -&gt; System RAM */
id|M_printk
c_func
(paren
l_string|&quot;maestro: ess_rec_setup: APU[%d] pa = 0x%x size = 0x%x route = 0x%x&bslash;n&quot;
comma
id|ess-&gt;apu
(braket
id|channel
)braket
comma
id|pa
comma
id|bsize
comma
id|route
)paren
suffix:semicolon
multiline_comment|/* Begin loading the APU */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* clear all PBRs */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
id|i
comma
l_int|0x0000
)paren
suffix:semicolon
)brace
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|0
comma
l_int|0x400F
)paren
suffix:semicolon
multiline_comment|/* need to enable subgroups.. and we should probably&n;&t;&t;&t;have different groups for different /dev/dsps..  */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|2
comma
l_int|0x8
)paren
suffix:semicolon
multiline_comment|/* Load the buffer into the wave engine */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|4
comma
(paren
(paren
id|pa
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* XXX reg is little endian.. */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|5
comma
id|pa
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|6
comma
(paren
id|pa
op_plus
id|bsize
)paren
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|7
comma
id|bsize
)paren
suffix:semicolon
multiline_comment|/* clear effects/env.. */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|8
comma
l_int|0x00F0
)paren
suffix:semicolon
multiline_comment|/* amplitude now?  sure.  why not.  */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|9
comma
l_int|0x0000
)paren
suffix:semicolon
multiline_comment|/* set filter tune, radius, polar pan */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|10
comma
l_int|0x8F08
)paren
suffix:semicolon
multiline_comment|/* route input */
id|apu_set_register
c_func
(paren
id|ess
comma
id|channel
comma
l_int|11
comma
id|route
)paren
suffix:semicolon
)brace
multiline_comment|/* clear WP interupts */
id|outw
c_func
(paren
l_int|1
comma
id|ess-&gt;card-&gt;iobase
op_plus
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* enable WP ints */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ess-&gt;card-&gt;iobase
op_plus
l_int|0x18
)paren
op_or
l_int|4
comma
id|ess-&gt;card-&gt;iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* let &squot;er rip */
id|set_adc_rate
c_func
(paren
id|ess
comma
id|rate
)paren
suffix:semicolon
id|start_adc
c_func
(paren
id|ess
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|set_dmaa
r_static
r_void
id|set_dmaa
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|count
)paren
(brace
id|M_printk
c_func
(paren
l_string|&quot;set_dmaa??&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|set_dmac
r_static
r_void
id|set_dmac
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|count
)paren
(brace
id|M_printk
c_func
(paren
l_string|&quot;set_dmac??&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Playback pointer */
DECL|function|get_dmaa
r_extern
id|__inline__
r_int
id|get_dmaa
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_int
id|offset
suffix:semicolon
id|offset
op_assign
id|apu_get_register
c_func
(paren
id|s
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&t;M_printk(&quot;dmaa: offset: %d, base: %d&bslash;n&quot;,offset,s-&gt;dma_dac.base); */
id|offset
op_sub_assign
id|s-&gt;dma_dac.base
suffix:semicolon
r_return
(paren
id|offset
op_amp
l_int|0xFFFE
)paren
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* hardware is in words */
)brace
multiline_comment|/* Record pointer */
DECL|function|get_dmac
r_extern
id|__inline__
r_int
id|get_dmac
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_int
id|offset
suffix:semicolon
id|offset
op_assign
id|apu_get_register
c_func
(paren
id|s
comma
l_int|2
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&t;M_printk(&quot;dmac: offset: %d, base: %d&bslash;n&quot;,offset,s-&gt;dma_adc.base); */
multiline_comment|/* The offset is an address not a position relative to base */
id|offset
op_sub_assign
id|s-&gt;dma_adc.base
suffix:semicolon
r_return
(paren
id|offset
op_amp
l_int|0xFFFE
)paren
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* hardware is in words */
)brace
multiline_comment|/*&n; *&t;Meet Bob, the timer...&n; */
r_static
r_void
id|ess_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|stop_bob
r_static
r_void
id|stop_bob
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
multiline_comment|/* Mask IDR 11,17 */
id|maestro_write
c_func
(paren
id|s
comma
l_int|0x11
comma
id|maestro_read
c_func
(paren
id|s
comma
l_int|0x11
)paren
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|s
comma
l_int|0x17
comma
id|maestro_read
c_func
(paren
id|s
comma
l_int|0x17
)paren
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* eventually we could be clever and limit bob ints&n;&t;to the frequency at which our smallest duration&n;&t;chunks may expire */
DECL|macro|ESS_SYSCLK
mdefine_line|#define ESS_SYSCLK&t;50000000
DECL|function|start_bob
r_static
r_void
id|start_bob
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_int
id|prescale
suffix:semicolon
r_int
id|divide
suffix:semicolon
multiline_comment|/* XXX make freq selector much smarter, see calc_bob_rate */
r_int
id|freq
op_assign
l_int|200
suffix:semicolon
multiline_comment|/* compute ideal interrupt frequency for buffer size &amp; play rate */
multiline_comment|/* first, find best prescaler value to match freq */
r_for
c_loop
(paren
id|prescale
op_assign
l_int|5
suffix:semicolon
id|prescale
OL
l_int|12
suffix:semicolon
id|prescale
op_increment
)paren
r_if
c_cond
(paren
id|freq
OG
(paren
id|ESS_SYSCLK
op_rshift
(paren
id|prescale
op_plus
l_int|9
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* next, back off prescaler whilst getting divider into optimum range */
id|divide
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|prescale
OG
l_int|5
)paren
op_logical_and
(paren
id|divide
OL
l_int|32
)paren
)paren
(brace
id|prescale
op_decrement
suffix:semicolon
id|divide
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|divide
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* now fine-tune the divider for best match */
r_for
c_loop
(paren
suffix:semicolon
id|divide
OL
l_int|31
suffix:semicolon
id|divide
op_increment
)paren
r_if
c_cond
(paren
id|freq
op_ge
(paren
(paren
id|ESS_SYSCLK
op_rshift
(paren
id|prescale
op_plus
l_int|9
)paren
)paren
op_div
(paren
id|divide
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* divide = 0 is illegal, but don&squot;t let prescale = 4! */
r_if
c_cond
(paren
id|divide
op_eq
l_int|0
)paren
(brace
id|divide
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|prescale
OG
l_int|5
)paren
(brace
id|prescale
op_decrement
suffix:semicolon
)brace
)brace
id|maestro_write
c_func
(paren
id|s
comma
l_int|6
comma
l_int|0x9000
op_or
(paren
id|prescale
op_lshift
l_int|5
)paren
op_or
id|divide
)paren
suffix:semicolon
multiline_comment|/* set reg */
multiline_comment|/* Now set IDR 11/17 */
id|maestro_write
c_func
(paren
id|s
comma
l_int|0x11
comma
id|maestro_read
c_func
(paren
id|s
comma
l_int|0x11
)paren
op_or
l_int|1
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|s
comma
l_int|0x17
comma
id|maestro_read
c_func
(paren
id|s
comma
l_int|0x17
)paren
op_or
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* this quickly calculates the frequency needed for bob&n;&t;and sets it if its different than what bob is&n;&t;currently running at.  its called often so &n;&t;needs to be fairly quick. */
DECL|macro|BOB_MIN
mdefine_line|#define BOB_MIN 50
DECL|macro|BOB_MAX
mdefine_line|#define BOB_MAX 400
DECL|function|calc_bob_rate
r_static
r_void
id|calc_bob_rate
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
macro_line|#if 0 /* this thing tries to set the frequency of bob such that&n;&t;there are 2 interrupts / buffer walked by the dac/adc.  That&n;&t;is probably very wrong for people who actually care about &n;&t;mid buffer positioning.  it should be calculated as bytes/interrupt&n;&t;and that needs to be decided :)  so for now just use the static 150&n;&t;in start_bob.*/
r_int
r_int
id|dac_rate
op_assign
l_int|2
comma
id|adc_rate
op_assign
l_int|1
comma
id|newrate
suffix:semicolon
r_static
r_int
id|israte
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.fragsize
op_eq
l_int|0
)paren
id|dac_rate
op_assign
id|BOB_MIN
suffix:semicolon
r_else
(brace
id|dac_rate
op_assign
(paren
l_int|2
op_star
id|s-&gt;ratedac
op_star
id|sample_size
(braket
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_MASK
)braket
)paren
op_div
(paren
id|s-&gt;dma_dac.fragsize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.fragsize
op_eq
l_int|0
)paren
id|adc_rate
op_assign
id|BOB_MIN
suffix:semicolon
r_else
(brace
id|adc_rate
op_assign
(paren
l_int|2
op_star
id|s-&gt;rateadc
op_star
id|sample_size
(braket
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_MASK
)braket
)paren
op_div
(paren
id|s-&gt;dma_adc.fragsize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dac_rate
OG
id|adc_rate
)paren
(brace
id|newrate
op_assign
id|adc_rate
suffix:semicolon
)brace
r_else
id|newrate
op_assign
id|dac_rate
suffix:semicolon
r_if
c_cond
(paren
id|newrate
OG
id|BOB_MAX
)paren
(brace
id|newrate
op_assign
id|BOB_MAX
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|newrate
OL
id|BOB_MIN
)paren
(brace
id|newrate
op_assign
id|BOB_MIN
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|israte
op_ne
id|newrate
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dac: %d  adc: %d rate: %d&bslash;n&quot;
comma
id|dac_rate
comma
id|adc_rate
comma
id|israte
)paren
suffix:semicolon
id|israte
op_assign
id|newrate
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_int
DECL|function|prog_dmabuf
id|prog_dmabuf
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|db
op_assign
id|rec
ques
c_cond
op_amp
id|s-&gt;dma_adc
suffix:colon
op_amp
id|s-&gt;dma_dac
suffix:semicolon
r_int
id|rate
op_assign
id|rec
ques
c_cond
id|s-&gt;rateadc
suffix:colon
id|s-&gt;ratedac
suffix:semicolon
r_int
id|bytepersec
suffix:semicolon
r_int
id|bufs
suffix:semicolon
r_int
r_char
id|fmt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|fmt
op_assign
id|s-&gt;fmt
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|fmt
op_rshift_assign
id|ESS_ADC_SHIFT
suffix:semicolon
)brace
r_else
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|fmt
op_rshift_assign
id|ESS_DAC_SHIFT
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|fmt
op_and_assign
id|ESS_FMT_MASK
suffix:semicolon
id|db-&gt;hwptr
op_assign
id|db-&gt;swptr
op_assign
id|db-&gt;total_bytes
op_assign
id|db-&gt;count
op_assign
id|db-&gt;error
op_assign
id|db-&gt;endcleared
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this algorithm is a little nuts.. where did /1000 come from? */
id|bytepersec
op_assign
id|rate
op_lshift
id|sample_shift
(braket
id|fmt
)braket
suffix:semicolon
id|bufs
op_assign
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;ossfragshift
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1000
op_lshift
id|db-&gt;ossfragshift
)paren
OL
id|bytepersec
)paren
id|db-&gt;fragshift
op_assign
id|ld2
c_func
(paren
id|bytepersec
op_div
l_int|1000
)paren
suffix:semicolon
r_else
id|db-&gt;fragshift
op_assign
id|db-&gt;ossfragshift
suffix:semicolon
)brace
r_else
(brace
id|db-&gt;fragshift
op_assign
id|ld2
c_func
(paren
id|bytepersec
op_div
l_int|100
op_div
(paren
id|db-&gt;subdivision
ques
c_cond
id|db-&gt;subdivision
suffix:colon
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;fragshift
OL
l_int|3
)paren
id|db-&gt;fragshift
op_assign
l_int|3
suffix:semicolon
)brace
id|db-&gt;numfrag
op_assign
id|bufs
op_rshift
id|db-&gt;fragshift
suffix:semicolon
r_while
c_loop
(paren
id|db-&gt;numfrag
template_param
l_int|3
)paren
(brace
id|db-&gt;fragshift
op_decrement
suffix:semicolon
id|db-&gt;numfrag
op_assign
id|bufs
op_rshift
id|db-&gt;fragshift
suffix:semicolon
)brace
id|db-&gt;fragsize
op_assign
l_int|1
op_lshift
id|db-&gt;fragshift
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;ossmaxfrags
op_ge
l_int|4
op_logical_and
id|db-&gt;ossmaxfrags
OL
id|db-&gt;numfrag
)paren
id|db-&gt;numfrag
op_assign
id|db-&gt;ossmaxfrags
suffix:semicolon
id|db-&gt;fragsamples
op_assign
id|db-&gt;fragsize
op_rshift
id|sample_shift
(braket
id|fmt
)braket
suffix:semicolon
id|db-&gt;dmasize
op_assign
id|db-&gt;numfrag
op_lshift
id|db-&gt;fragshift
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: setup oss: numfrag: %d fragsize: %d dmasize: %d&bslash;n&quot;
comma
id|db-&gt;numfrag
comma
id|db-&gt;fragsize
comma
id|db-&gt;dmasize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|db-&gt;rawbuf
comma
(paren
id|fmt
op_amp
id|ESS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|db-&gt;dmasize
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
id|ess_rec_setup
c_func
(paren
id|s
comma
id|fmt
comma
id|s-&gt;rateadc
comma
id|db-&gt;rawbuf
comma
id|db-&gt;dmasize
)paren
suffix:semicolon
r_else
id|ess_play_setup
c_func
(paren
id|s
comma
id|fmt
comma
id|s-&gt;ratedac
comma
id|db-&gt;rawbuf
comma
id|db-&gt;dmasize
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|db-&gt;ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|clear_advance
id|clear_advance
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_int
r_char
id|c
op_assign
(paren
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|s-&gt;dma_dac.rawbuf
suffix:semicolon
r_int
id|bsize
op_assign
id|s-&gt;dma_dac.dmasize
suffix:semicolon
r_int
id|bptr
op_assign
id|s-&gt;dma_dac.swptr
suffix:semicolon
r_int
id|len
op_assign
id|s-&gt;dma_dac.fragsize
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_plus
id|len
OG
id|bsize
)paren
(brace
r_int
id|x
op_assign
id|bsize
op_minus
id|bptr
suffix:semicolon
id|memset
c_func
(paren
id|buf
op_plus
id|bptr
comma
id|c
comma
id|x
)paren
suffix:semicolon
multiline_comment|/* account for wrapping? */
id|bptr
op_assign
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|x
suffix:semicolon
)brace
id|memset
c_func
(paren
id|buf
op_plus
id|bptr
comma
id|c
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* call with spinlock held! */
r_static
r_void
DECL|function|ess_update_ptr
id|ess_update_ptr
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_int
id|hwptr
suffix:semicolon
r_int
id|diff
suffix:semicolon
multiline_comment|/* update ADC pointer */
r_if
c_cond
(paren
id|s-&gt;dma_adc.ready
)paren
(brace
multiline_comment|/* oh boy should this all be re-written.  everything in the current code paths think&n;&t;&t;that the various counters/pointers are expressed in bytes to the user but we have&n;&t;&t;two apus doing stereo stuff so we fix it up here.. it propogates to all the various&n;&t;&t;counters from here.  */
r_if
c_cond
(paren
id|s-&gt;fmt
op_amp
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
)paren
(brace
id|hwptr
op_assign
(paren
id|get_dmac
c_func
(paren
id|s
)paren
op_star
l_int|2
)paren
op_mod
id|s-&gt;dma_adc.dmasize
suffix:semicolon
)brace
r_else
(brace
id|hwptr
op_assign
id|get_dmac
c_func
(paren
id|s
)paren
op_mod
id|s-&gt;dma_adc.dmasize
suffix:semicolon
)brace
id|diff
op_assign
(paren
id|s-&gt;dma_adc.dmasize
op_plus
id|hwptr
op_minus
id|s-&gt;dma_adc.hwptr
)paren
op_mod
id|s-&gt;dma_adc.dmasize
suffix:semicolon
id|s-&gt;dma_adc.hwptr
op_assign
id|hwptr
suffix:semicolon
id|s-&gt;dma_adc.total_bytes
op_add_assign
id|diff
suffix:semicolon
id|s-&gt;dma_adc.count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_adc.fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OG
(paren
r_int
)paren
(paren
id|s-&gt;dma_adc.dmasize
op_minus
(paren
(paren
l_int|3
op_star
id|s-&gt;dma_adc.fragsize
)paren
op_rshift
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* FILL ME &n;&t;&t;&t;&t;wrindir(s, SV_CIENABLE, s-&gt;enable); */
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* brute force everyone back in sync, sigh */
id|s-&gt;dma_adc.count
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_adc.swptr
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_adc.hwptr
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_adc.error
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* update DAC pointer */
r_if
c_cond
(paren
id|s-&gt;dma_dac.ready
)paren
(brace
id|hwptr
op_assign
id|get_dmaa
c_func
(paren
id|s
)paren
op_mod
id|s-&gt;dma_dac.dmasize
suffix:semicolon
multiline_comment|/* the apu only reports the length it has seen, not the&n;&t;&t;&t;length of the memory that has been used (the WP&n;&t;&t;&t;knows that) */
r_if
c_cond
(paren
(paren
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_MASK
)paren
op_eq
(paren
id|ESS_FMT_STEREO
op_or
id|ESS_FMT_16BIT
)paren
)paren
id|hwptr
op_lshift_assign
l_int|1
suffix:semicolon
id|diff
op_assign
(paren
id|s-&gt;dma_dac.dmasize
op_plus
id|hwptr
op_minus
id|s-&gt;dma_dac.hwptr
)paren
op_mod
id|s-&gt;dma_dac.dmasize
suffix:semicolon
multiline_comment|/*&t;&t;M_printk(&quot;updating dac: hwptr: %d diff: %d&bslash;n&quot;,hwptr,diff);*/
id|s-&gt;dma_dac.hwptr
op_assign
id|hwptr
suffix:semicolon
id|s-&gt;dma_dac.total_bytes
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
id|s-&gt;dma_dac.count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|s-&gt;dma_dac.count
op_sub_assign
id|diff
suffix:semicolon
multiline_comment|/*&t;&t;&t;M_printk(&quot;maestro: ess_update_ptr: diff: %d, count: %d&bslash;n&quot;, diff, s-&gt;dma_dac.count); */
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_le
l_int|0
)paren
(brace
id|M_printk
c_func
(paren
l_string|&quot;underflow! diff: %d count: %d hw: %d sw: %d&bslash;n&quot;
comma
id|diff
comma
id|s-&gt;dma_dac.count
comma
id|hwptr
comma
id|s-&gt;dma_dac.swptr
)paren
suffix:semicolon
multiline_comment|/* FILL ME &n;&t;&t;&t;&t;wrindir(s, SV_CIENABLE, s-&gt;enable); */
multiline_comment|/* XXX how on earth can calling this with the lock held work.. */
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* brute force everyone back in sync, sigh */
id|s-&gt;dma_dac.count
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|hwptr
suffix:semicolon
id|s-&gt;dma_dac.error
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_le
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
op_logical_and
op_logical_neg
id|s-&gt;dma_dac.endcleared
)paren
(brace
id|clear_advance
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.endcleared
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_plus
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
op_le
(paren
r_int
)paren
id|s-&gt;dma_dac.dmasize
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;&t;printk(&quot;waking up DAC count: %d sw: %d hw: %d&bslash;n&quot;,s-&gt;dma_dac.count, s-&gt;dma_dac.swptr, &n;&t;&t;&t;&t;&t;hwptr);*/
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|ess_interrupt
id|ess_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ess_state
op_star
id|s
suffix:semicolon
r_struct
id|ess_card
op_star
id|c
op_assign
(paren
r_struct
id|ess_card
op_star
)paren
id|dev_id
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|event
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|event
op_assign
id|inb
c_func
(paren
id|c-&gt;iobase
op_plus
l_int|0x1A
)paren
)paren
)paren
r_return
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|c-&gt;iobase
op_plus
l_int|4
)paren
op_amp
l_int|1
comma
id|c-&gt;iobase
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&t;M_printk(&quot;maestro int: %x&bslash;n&quot;,event);*/
r_if
c_cond
(paren
id|event
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
(brace
multiline_comment|/* XXX if we have a hw volume control int enable&n;&t;&t;&t;all the ints?  doesn&squot;t make sense.. */
id|event
op_assign
id|inw
c_func
(paren
id|c-&gt;iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xFF
comma
id|c-&gt;iobase
op_plus
l_int|0x1A
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* else ack &squot;em all, i imagine */
id|outb
c_func
(paren
l_int|0xFF
comma
id|c-&gt;iobase
op_plus
l_int|0x1A
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Update the pointers for all APU&squot;s we are running.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s
op_assign
op_amp
id|c-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dev_audio
op_eq
op_minus
l_int|1
)paren
(brace
r_break
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|variable|invalid_magic
r_static
r_const
r_char
id|invalid_magic
(braket
)braket
op_assign
id|KERN_CRIT
l_string|&quot;maestro: invalid magic value in %s&bslash;n&quot;
suffix:semicolon
DECL|macro|VALIDATE_MAGIC
mdefine_line|#define VALIDATE_MAGIC(FOO,MAG)                         &bslash;&n;({                                                &bslash;&n;&t;if (!(FOO) || (FOO)-&gt;magic != MAG) { &bslash;&n;&t;&t;printk(invalid_magic,__FUNCTION__);            &bslash;&n;&t;&t;return -ENXIO;                    &bslash;&n;&t;}                                         &bslash;&n;})
DECL|macro|VALIDATE_STATE
mdefine_line|#define VALIDATE_STATE(a) VALIDATE_MAGIC(a,ESS_STATE_MAGIC)
DECL|macro|VALIDATE_CARD
mdefine_line|#define VALIDATE_CARD(a) VALIDATE_MAGIC(a,ESS_CARD_MAGIC)
DECL|function|set_mixer
r_static
r_void
id|set_mixer
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
r_int
id|mixer
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|left
comma
id|right
suffix:semicolon
multiline_comment|/* cleanse input a little */
id|right
op_assign
(paren
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|left
op_assign
(paren
id|val
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|right
OG
l_int|100
)paren
(brace
id|right
op_assign
l_int|100
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
OG
l_int|100
)paren
(brace
id|left
op_assign
l_int|100
suffix:semicolon
)brace
id|card-&gt;mix.mixer_state
(braket
id|mixer
)braket
op_assign
(paren
id|right
op_lshift
l_int|8
)paren
op_or
id|left
suffix:semicolon
id|card-&gt;mix
dot
id|write_mixer
c_func
(paren
id|card
comma
id|mixer
comma
id|left
comma
id|right
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|mixer_push_state
id|mixer_push_state
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOUND_MIXER_NRDEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|supported_mixer
c_func
(paren
id|card
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|set_mixer
c_func
(paren
id|card
comma
id|i
comma
id|card-&gt;mix.mixer_state
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|mixer_ioctl
r_static
r_int
id|mixer_ioctl
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
comma
id|val
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|VALIDATE_CARD
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_INFO
)paren
(brace
id|mixer_info
id|info
suffix:semicolon
id|strncpy
c_func
(paren
id|info.id
comma
id|card_names
(braket
id|card-&gt;card_type
)braket
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.name
comma
id|card_names
(braket
id|card-&gt;card_type
)braket
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
id|info.modify_counter
op_assign
id|card-&gt;mix.modcnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_OLD_MIXER_INFO
)paren
(brace
id|_old_mixer_info
id|info
suffix:semicolon
id|strncpy
c_func
(paren
id|info.id
comma
id|card_names
(braket
id|card-&gt;card_type
)braket
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.name
comma
id|card_names
(braket
id|card-&gt;card_type
)braket
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|OSS_GETVERSION
)paren
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
l_char|&squot;M&squot;
op_logical_or
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_eq
id|_IOC_READ
)paren
(brace
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
multiline_comment|/* give them the current record source */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;mix.recmask_io
)paren
(brace
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|card-&gt;mix
dot
id|recmask_io
c_func
(paren
id|card
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
multiline_comment|/* give them the supported mixers */
id|val
op_assign
id|card-&gt;mix.supported_mixers
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
multiline_comment|/* Arg contains a bit for each supported recording source */
id|val
op_assign
id|card-&gt;mix.record_sources
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
multiline_comment|/* Mixer channels supporting stereo */
id|val
op_assign
id|card-&gt;mix.stereo_mixers
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
id|val
op_assign
id|SOUND_CAP_EXCL_INPUT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* read a specific mixer */
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|supported_mixer
c_func
(paren
id|card
comma
id|i
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* do we ever want to touch the hardware? */
multiline_comment|/*                     spin_lock_irqsave(&amp;card-&gt;lock, flags);&n;&t;&t;&t;val = card-&gt;mix.read_mixer(card,i);&n;                       spin_unlock_irqrestore(&amp;card-&gt;lock, flags);*/
id|val
op_assign
id|card-&gt;mix.mixer_state
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&t;&t;&t;M_printk(&quot;returned 0x%x for mixer %d&bslash;n&quot;,val,i);*/
r_break
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
(paren
id|_IOC_WRITE
op_or
id|_IOC_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|card-&gt;mix.modcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
multiline_comment|/* Arg contains a bit for each recording source */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;mix.recmask_io
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_and_assign
id|card-&gt;mix.record_sources
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|card-&gt;mix
dot
id|recmask_io
c_func
(paren
id|card
comma
l_int|0
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|supported_mixer
c_func
(paren
id|card
comma
id|i
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_mixer
c_func
(paren
id|card
comma
id|i
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|ess_llseek
r_static
id|loff_t
id|ess_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|ess_open_mixdev
r_static
r_int
id|ess_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|ess_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_while
c_loop
(paren
id|card
op_logical_and
id|card-&gt;dev_mixer
op_ne
id|minor
)paren
id|card
op_assign
id|card-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|file-&gt;private_data
op_assign
id|card
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ess_release_mixdev
r_static
r_int
id|ess_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|ess_card
op_star
id|card
op_assign
(paren
r_struct
id|ess_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|VALIDATE_CARD
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ess_ioctl_mixdev
r_static
r_int
id|ess_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ess_card
op_star
id|card
op_assign
(paren
r_struct
id|ess_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|VALIDATE_CARD
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
id|mixer_ioctl
c_func
(paren
id|card
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|ess_mixer_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|ess_mixer_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|ess_llseek
comma
id|ioctl
suffix:colon
id|ess_ioctl_mixdev
comma
id|open
suffix:colon
id|ess_open_mixdev
comma
id|release
suffix:colon
id|ess_release_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
op_logical_or
op_logical_neg
id|s-&gt;dma_dac.ready
)paren
r_return
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* XXX uhm.. questionable locking*/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|count
op_star
id|HZ
)paren
op_div
id|s-&gt;ratedac
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
(paren
id|s-&gt;fmt
op_rshift
id|ESS_DAC_SHIFT
)paren
op_amp
id|ESS_FMT_MASK
)braket
suffix:semicolon
multiline_comment|/* XXX this is just broken.  someone is waking us up alot, or schedule_timeout is broken.&n;&t;&t;&t;or something.  who cares. - zach */
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
id|tmo
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
id|M_printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;maestro: dma timed out?? %ld&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* Zach sez: &quot;god this is gross..&quot; */
r_static
r_int
DECL|function|comb_stereo
id|comb_stereo
c_func
(paren
r_int
r_char
op_star
id|real_buffer
comma
r_int
r_char
op_star
id|tmp_buffer
comma
r_int
id|offset
comma
r_int
id|count
comma
r_int
id|bufsize
)paren
(brace
multiline_comment|/* No such thing as stereo recording, so we&n;&t;use dual input mixers.  which means we have to &n;&t;combine mono to stereo buffer.  yuck. &n;&n;&t;but we don&squot;t have to be able to work a byte at a time..*/
r_int
r_char
op_star
id|so
comma
op_star
id|left
comma
op_star
id|right
suffix:semicolon
r_int
id|i
suffix:semicolon
id|so
op_assign
id|tmp_buffer
suffix:semicolon
id|left
op_assign
id|real_buffer
op_plus
id|offset
suffix:semicolon
id|right
op_assign
id|real_buffer
op_plus
id|bufsize
op_div
l_int|2
op_plus
id|offset
suffix:semicolon
multiline_comment|/*&t;M_printk(&quot;comb_stereo writing %d to %p from %p and %p, offset: %d size: %d&bslash;n&quot;,count/2, tmp_buffer,left,right,offset,bufsize);*/
r_for
c_loop
(paren
id|i
op_assign
id|count
op_div
l_int|4
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
(paren
op_star
(paren
id|so
op_plus
l_int|2
)paren
)paren
op_assign
op_star
(paren
id|right
op_increment
)paren
suffix:semicolon
(paren
op_star
(paren
id|so
op_plus
l_int|3
)paren
)paren
op_assign
op_star
(paren
id|right
op_increment
)paren
suffix:semicolon
(paren
op_star
id|so
)paren
op_assign
op_star
(paren
id|left
op_increment
)paren
suffix:semicolon
(paren
op_star
(paren
id|so
op_plus
l_int|1
)paren
)paren
op_assign
op_star
(paren
id|left
op_increment
)paren
suffix:semicolon
id|so
op_add_assign
l_int|4
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* in this loop, dma_adc.count signifies the amount of data thats waiting&n;&t;to be copied to the user&squot;s buffer.  it is filled by the interrupt&n;&t;handler and drained by this loop. */
r_static
id|ssize_t
DECL|function|ess_read
id|ess_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
(paren
r_struct
id|ess_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
r_char
op_star
id|combbuf
op_assign
l_int|NULL
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|combbuf
op_assign
id|kmalloc
c_func
(paren
id|count
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|calc_bob_rate
c_func
(paren
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* remember, all these things are expressed in bytes to be&n;&t;&t;&t;sent to the user.. hence the evil / 2 down below */
id|swptr
op_assign
id|s-&gt;dma_adc.swptr
suffix:semicolon
id|cnt
op_assign
id|s-&gt;dma_adc.dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OL
id|cnt
)paren
id|cnt
op_assign
id|s-&gt;dma_adc.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|cnt
op_and_assign
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|rec_return_free
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
comma
id|HZ
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;card-&gt;in_suspend
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;maestro: read: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|s-&gt;dma_adc.dmasize
comma
id|s-&gt;dma_adc.fragsize
comma
id|s-&gt;dma_adc.count
comma
id|s-&gt;dma_adc.hwptr
comma
id|s-&gt;dma_adc.swptr
)paren
suffix:semicolon
)brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_dmac
c_func
(paren
id|s
comma
id|virt_to_bus
c_func
(paren
id|s-&gt;dma_adc.rawbuf
)paren
comma
id|s-&gt;dma_adc.numfrag
op_lshift
id|s-&gt;dma_adc.fragshift
)paren
suffix:semicolon
multiline_comment|/* program enhanced mode registers */
multiline_comment|/* FILL ME */
multiline_comment|/*&t;&t;&t;&t;wrindir(s, SV_CIDMACBASECOUNT1, (s-&gt;dma_adc.fragsamples-1) &gt;&gt; 8);&n;&t;&t;&t;&t;wrindir(s, SV_CIDMACBASECOUNT0, s-&gt;dma_adc.fragsamples-1); */
id|s-&gt;dma_adc.count
op_assign
id|s-&gt;dma_adc.hwptr
op_assign
id|s-&gt;dma_adc.swptr
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|rec_return_free
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;fmt
op_amp
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
)paren
(brace
multiline_comment|/* swptr/2 so that we know the real offset in each apu&squot;s buffer */
id|comb_stereo
c_func
(paren
id|s-&gt;dma_adc.rawbuf
comma
id|combbuf
comma
id|swptr
op_div
l_int|2
comma
id|cnt
comma
id|s-&gt;dma_adc.dmasize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|combbuf
comma
id|cnt
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|rec_return_free
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|s-&gt;dma_adc.rawbuf
op_plus
id|swptr
comma
id|cnt
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|rec_return_free
suffix:semicolon
)brace
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|s-&gt;dma_adc.dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;dma_adc.swptr
op_assign
id|swptr
suffix:semicolon
id|s-&gt;dma_adc.count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|rec_return_free
suffix:colon
r_if
c_cond
(paren
id|combbuf
)paren
(brace
id|kfree
c_func
(paren
id|combbuf
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ess_write
id|ess_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
(paren
r_struct
id|ess_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|calc_bob_rate
c_func
(paren
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
OL
l_int|0
)paren
(brace
id|s-&gt;dma_dac.count
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|s-&gt;dma_dac.hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|s-&gt;dma_dac.swptr
suffix:semicolon
id|cnt
op_assign
id|s-&gt;dma_dac.dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_plus
id|cnt
OG
id|s-&gt;dma_dac.dmasize
)paren
id|cnt
op_assign
id|s-&gt;dma_dac.dmasize
op_minus
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_goto
id|return_free
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
id|HZ
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;card-&gt;in_suspend
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;maestro: write: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|s-&gt;dma_dac.dmasize
comma
id|s-&gt;dma_dac.fragsize
comma
id|s-&gt;dma_dac.count
comma
id|s-&gt;dma_dac.hwptr
comma
id|s-&gt;dma_dac.swptr
)paren
suffix:semicolon
)brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_dmaa
c_func
(paren
id|s
comma
id|virt_to_bus
c_func
(paren
id|s-&gt;dma_dac.rawbuf
)paren
comma
id|s-&gt;dma_dac.numfrag
op_lshift
id|s-&gt;dma_dac.fragshift
)paren
suffix:semicolon
multiline_comment|/* program enhanced mode registers */
multiline_comment|/*&t;&t;&t;&t;wrindir(s, SV_CIDMAABASECOUNT1, (s-&gt;dma_dac.fragsamples-1) &gt;&gt; 8);&n;&t;&t;&t;&t;wrindir(s, SV_CIDMAABASECOUNT0, s-&gt;dma_dac.fragsamples-1); */
multiline_comment|/* FILL ME */
id|s-&gt;dma_dac.count
op_assign
id|s-&gt;dma_dac.hwptr
op_assign
id|s-&gt;dma_dac.swptr
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|return_free
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|s-&gt;dma_dac.rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|return_free
suffix:semicolon
)brace
multiline_comment|/*&t;&t;printk(&quot;wrote %d bytes at sw: %d cnt: %d while hw: %d&bslash;n&quot;,cnt, swptr, s-&gt;dma_dac.count, s-&gt;dma_dac.hwptr);*/
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|s-&gt;dma_dac.dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|swptr
suffix:semicolon
id|s-&gt;dma_dac.count
op_add_assign
id|cnt
suffix:semicolon
id|s-&gt;dma_dac.endcleared
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|return_free
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - we have our own spinlock */
DECL|function|ess_poll
r_static
r_int
r_int
id|ess_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
(paren
r_struct
id|ess_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* In 0.14 prog_dmabuf always returns success anyway ... */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;dma_dac.wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;dma_adc.wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_adc.fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|s-&gt;dma_dac.dmasize
op_ge
id|s-&gt;dma_dac.count
op_plus
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|ess_mmap
r_static
r_int
id|ess_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
(paren
r_struct
id|ess_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|db
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|db
op_assign
op_amp
id|s-&gt;dma_dac
suffix:semicolon
)brace
r_else
macro_line|#if 0
multiline_comment|/* if we can have the wp/wc do the combining&n;&t;&t;we can turn this back on.  */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|db
op_assign
op_amp
id|s-&gt;dma_adc
suffix:semicolon
)brace
r_else
macro_line|#endif
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|SILLY_OFFSET
c_func
(paren
id|vma
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|db-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_goto
id|out
suffix:semicolon
id|db-&gt;mapped
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ess_ioctl
r_static
r_int
id|ess_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
(paren
r_struct
id|ess_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
comma
id|mapped
comma
id|ret
suffix:semicolon
r_int
r_char
id|fmtm
comma
id|fmtd
suffix:semicolon
multiline_comment|/*&t;printk(&quot;maestro: ess_ioctl: cmd %d&bslash;n&quot;, cmd);*/
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|mapped
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|s-&gt;dma_dac.mapped
)paren
op_logical_or
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|s-&gt;dma_adc.mapped
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|drain_dac
c_func
(paren
id|s
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
multiline_comment|/* XXX fix */
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|DSP_CAP_DUPLEX
op_or
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|s-&gt;dma_dac.hwptr
op_assign
id|s-&gt;dma_dac.count
op_assign
id|s-&gt;dma_dac.total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|s-&gt;dma_adc.swptr
op_assign
id|s-&gt;dma_adc.hwptr
op_assign
id|s-&gt;dma_adc.count
op_assign
id|s-&gt;dma_adc.total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
id|set_adc_rate
c_func
(paren
id|s
comma
id|val
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
id|set_dac_rate
c_func
(paren
id|s
comma
id|val
)paren
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
id|s-&gt;rateadc
suffix:colon
id|s-&gt;ratedac
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|fmtd
op_assign
l_int|0
suffix:semicolon
id|fmtm
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|fmtd
op_or_assign
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
suffix:semicolon
r_else
id|fmtm
op_and_assign
op_complement
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|fmtd
op_or_assign
id|ESS_FMT_STEREO
op_lshift
id|ESS_DAC_SHIFT
suffix:semicolon
r_else
id|fmtm
op_and_assign
op_complement
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_DAC_SHIFT
)paren
suffix:semicolon
)brace
id|set_fmt
c_func
(paren
id|s
comma
id|fmtm
comma
id|fmtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
id|fmtd
op_assign
l_int|0
suffix:semicolon
id|fmtm
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|2
)paren
id|fmtd
op_or_assign
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
suffix:semicolon
r_else
id|fmtm
op_and_assign
op_complement
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|2
)paren
id|fmtd
op_or_assign
id|ESS_FMT_STEREO
op_lshift
id|ESS_DAC_SHIFT
suffix:semicolon
r_else
id|fmtm
op_and_assign
op_complement
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_DAC_SHIFT
)paren
suffix:semicolon
)brace
id|set_fmt
c_func
(paren
id|s
comma
id|fmtm
comma
id|fmtd
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;fmt
op_amp
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:colon
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_DAC_SHIFT
)paren
)paren
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask */
r_return
id|put_user
c_func
(paren
id|AFMT_U8
op_or
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Selects ONE fmt*/
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_QUERY
)paren
(brace
id|fmtd
op_assign
l_int|0
suffix:semicolon
id|fmtm
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fixed at 16bit for now */
id|fmtd
op_or_assign
id|ESS_FMT_16BIT
op_lshift
id|ESS_ADC_SHIFT
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
)paren
id|fmtd
op_or_assign
id|ESS_FMT_16BIT
op_lshift
id|ESS_ADC_SHIFT
suffix:semicolon
r_else
id|fmtm
op_and_assign
op_complement
(paren
id|ESS_FMT_16BIT
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
)paren
id|fmtd
op_or_assign
id|ESS_FMT_16BIT
op_lshift
id|ESS_DAC_SHIFT
suffix:semicolon
r_else
id|fmtm
op_and_assign
op_complement
(paren
id|ESS_FMT_16BIT
op_lshift
id|ESS_DAC_SHIFT
)paren
suffix:semicolon
)brace
id|set_fmt
c_func
(paren
id|s
comma
id|fmtm
comma
id|fmtd
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;fmt
op_amp
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
(paren
id|ESS_FMT_16BIT
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:colon
(paren
id|ESS_FMT_16BIT
op_lshift
id|ESS_DAC_SHIFT
)paren
)paren
)paren
ques
c_cond
id|AFMT_S16_LE
suffix:colon
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
(paren
id|s-&gt;enable
op_amp
id|ADC_RUNNING
)paren
)paren
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
(paren
id|s-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|s-&gt;dma_dac.fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|s-&gt;dma_dac.dmasize
op_minus
id|s-&gt;dma_dac.count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_dac.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|s-&gt;dma_adc.fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|s-&gt;dma_adc.count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_adc.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|val
op_assign
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|s-&gt;dma_adc.total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|s-&gt;dma_adc.count
op_rshift
id|s-&gt;dma_adc.fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|s-&gt;dma_adc.hwptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
id|s-&gt;dma_adc.count
op_and_assign
id|s-&gt;dma_adc.fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ess_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|s-&gt;dma_dac.total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|s-&gt;dma_dac.count
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|s-&gt;dma_dac.hwptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
id|s-&gt;dma_dac.count
op_and_assign
id|s-&gt;dma_dac.fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|0
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_dac.fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_adc.fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: SETFRAGMENT: %0x&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|s-&gt;dma_adc.ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|s-&gt;dma_adc.ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.ossfragshift
OL
l_int|4
)paren
id|s-&gt;dma_adc.ossfragshift
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.ossfragshift
OG
l_int|15
)paren
id|s-&gt;dma_adc.ossfragshift
op_assign
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.ossmaxfrags
OL
l_int|4
)paren
id|s-&gt;dma_adc.ossmaxfrags
op_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|s-&gt;dma_dac.ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|s-&gt;dma_dac.ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.ossfragshift
OL
l_int|4
)paren
id|s-&gt;dma_dac.ossfragshift
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.ossfragshift
OG
l_int|15
)paren
id|s-&gt;dma_dac.ossfragshift
op_assign
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.ossmaxfrags
OL
l_int|4
)paren
id|s-&gt;dma_dac.ossmaxfrags
op_assign
l_int|4
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|s-&gt;dma_adc.subdivision
)paren
op_logical_or
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|s-&gt;dma_dac.subdivision
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
op_logical_and
id|val
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|s-&gt;dma_adc.subdivision
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|s-&gt;dma_dac.subdivision
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
id|s-&gt;rateadc
suffix:colon
id|s-&gt;ratedac
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;fmt
op_amp
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:colon
(paren
id|ESS_FMT_STEREO
op_lshift
id|ESS_DAC_SHIFT
)paren
)paren
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;fmt
op_amp
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
(paren
id|ESS_FMT_16BIT
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:colon
(paren
id|ESS_FMT_16BIT
op_lshift
id|ESS_DAC_SHIFT
)paren
)paren
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_void
DECL|function|set_base_registers
id|set_base_registers
c_func
(paren
r_struct
id|ess_state
op_star
id|s
comma
r_void
op_star
id|vaddr
)paren
(brace
r_int
r_int
id|packed_phys
op_assign
id|virt_to_bus
c_func
(paren
id|vaddr
)paren
op_rshift
l_int|12
suffix:semicolon
id|wave_set_register
c_func
(paren
id|s
comma
l_int|0x01FC
comma
id|packed_phys
)paren
suffix:semicolon
id|wave_set_register
c_func
(paren
id|s
comma
l_int|0x01FD
comma
id|packed_phys
)paren
suffix:semicolon
id|wave_set_register
c_func
(paren
id|s
comma
l_int|0x01FE
comma
id|packed_phys
)paren
suffix:semicolon
id|wave_set_register
c_func
(paren
id|s
comma
l_int|0x01FF
comma
id|packed_phys
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * this guy makes sure we&squot;re in the right power&n; * state for what we want to be doing &n; */
DECL|function|maestro_power
r_static
r_void
id|maestro_power
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_int
id|tostate
)paren
(brace
id|u16
id|active_mask
op_assign
id|acpi_state_mask
(braket
id|tostate
)braket
suffix:semicolon
id|u8
id|state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_pm
)paren
(brace
r_return
suffix:semicolon
)brace
id|pci_read_config_byte
c_func
(paren
id|card-&gt;pcidev
comma
id|card-&gt;power_regs
op_plus
l_int|0x4
comma
op_amp
id|state
)paren
suffix:semicolon
id|state
op_and_assign
l_int|3
suffix:semicolon
multiline_comment|/* make sure we&squot;re in the right state */
r_if
c_cond
(paren
id|state
op_ne
id|tostate
)paren
(brace
id|M_printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: dev %02x:%02x.%x switching from D%d to D%d&bslash;n&quot;
comma
id|card-&gt;pcidev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|card-&gt;pcidev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|card-&gt;pcidev-&gt;devfn
)paren
comma
id|state
comma
id|tostate
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|card-&gt;pcidev
comma
id|card-&gt;power_regs
op_plus
l_int|0x4
comma
id|tostate
)paren
suffix:semicolon
)brace
multiline_comment|/* and make sure the units we care about are on &n;&t;&t;XXX we might want to do this before state flipping? */
id|pci_write_config_word
c_func
(paren
id|card-&gt;pcidev
comma
l_int|0x54
comma
op_complement
id|active_mask
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|card-&gt;pcidev
comma
l_int|0x56
comma
op_complement
id|active_mask
)paren
suffix:semicolon
)brace
multiline_comment|/* we allocate a large power of two for all our memory.&n;&t;this is cut up into (not to scale :):&n;&t;|silly fifo word&t;| 512byte mixbuf per adc&t;| dac/adc * channels |&n;*/
r_static
r_int
DECL|function|allocate_buffers
id|allocate_buffers
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_void
op_star
id|rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
comma
id|i
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
multiline_comment|/* alloc as big a chunk as we can */
r_for
c_loop
(paren
id|order
op_assign
(paren
id|dsps_order
op_plus
(paren
l_int|16
op_minus
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|order
op_ge
(paren
id|dsps_order
op_plus
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
comma
id|order
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
l_int|1
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: allocated %ld (%d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|rawbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|virt_to_bus
c_func
(paren
id|rawbuf
)paren
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
(paren
l_int|1
op_lshift
l_int|28
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;maestro: DMA buffer beyond 256MB! busaddr 0x%lx  size %ld&bslash;n&quot;
comma
id|virt_to_bus
c_func
(paren
id|rawbuf
)paren
comma
id|PAGE_SIZE
op_lshift
id|order
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|s-&gt;card-&gt;dmapages
op_assign
id|rawbuf
suffix:semicolon
id|s-&gt;card-&gt;dmaorder
op_assign
id|order
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|ess
op_assign
op_amp
id|s-&gt;card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ess-&gt;dev_audio
op_eq
op_minus
l_int|1
)paren
(brace
r_continue
suffix:semicolon
)brace
id|ess-&gt;dma_dac.ready
op_assign
id|s-&gt;dma_dac.mapped
op_assign
l_int|0
suffix:semicolon
id|ess-&gt;dma_adc.ready
op_assign
id|s-&gt;dma_adc.mapped
op_assign
l_int|0
suffix:semicolon
id|ess-&gt;dma_adc.buforder
op_assign
id|ess-&gt;dma_dac.buforder
op_assign
id|order
op_minus
l_int|1
op_minus
id|dsps_order
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* offset dac and adc buffers starting half way through and then at each [da][ad]c&squot;s&n;&t;&t;&t;order&squot;s intervals.. */
id|ess-&gt;dma_dac.rawbuf
op_assign
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
(paren
id|order
op_minus
l_int|1
)paren
)paren
op_plus
(paren
id|i
op_star
(paren
id|PAGE_SIZE
op_lshift
(paren
id|ess-&gt;dma_dac.buforder
op_plus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|ess-&gt;dma_adc.rawbuf
op_assign
id|ess-&gt;dma_dac.rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|ess-&gt;dma_dac.buforder
)paren
suffix:semicolon
multiline_comment|/* offset mixbuf by a mixbuf so that the lame status fifo can&n;&t;&t;&t;happily scribble away.. */
id|ess-&gt;mixbuf
op_assign
id|rawbuf
op_plus
(paren
l_int|512
op_star
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: setup apu %d: dac: %p adc: %p mix: %p&bslash;n&quot;
comma
id|i
comma
id|ess-&gt;dma_dac.rawbuf
comma
id|ess-&gt;dma_adc.rawbuf
comma
id|ess-&gt;mixbuf
)paren
suffix:semicolon
)brace
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|free_buffers
id|free_buffers
c_func
(paren
r_struct
id|ess_state
op_star
id|s
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
id|s-&gt;dma_dac.rawbuf
op_assign
id|s-&gt;dma_adc.rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|s-&gt;dma_dac.mapped
op_assign
id|s-&gt;dma_adc.mapped
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: freeing %p&bslash;n&quot;
comma
id|s-&gt;card-&gt;dmapages
)paren
suffix:semicolon
multiline_comment|/* undo marking the pages as reserved */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|s-&gt;card-&gt;dmapages
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|s-&gt;card-&gt;dmaorder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|s-&gt;card-&gt;dmapages
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|s-&gt;card-&gt;dmapages
comma
id|s-&gt;card-&gt;dmaorder
)paren
suffix:semicolon
id|s-&gt;card-&gt;dmapages
op_assign
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|ess_open
id|ess_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|ess_card
op_star
id|c
op_assign
id|devs
suffix:semicolon
r_struct
id|ess_state
op_star
id|s
op_assign
l_int|NULL
comma
op_star
id|sp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|fmtm
op_assign
op_complement
l_int|0
comma
id|fmts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Scan the cards and find the channel. We only&n;&t; *&t;do this at open time so it is ok&n;&t; */
r_while
c_loop
(paren
id|c
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sp
op_assign
op_amp
id|c-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;dev_audio
OL
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sp-&gt;dev_audio
op_xor
id|minor
)paren
op_amp
op_complement
l_int|0xf
)paren
(brace
r_continue
suffix:semicolon
)brace
id|s
op_assign
id|sp
suffix:semicolon
)brace
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|s
suffix:semicolon
multiline_comment|/* wait for device to become free */
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;open_mode
op_amp
id|file-&gt;f_mode
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* under semaphore.. */
r_if
c_cond
(paren
(paren
id|s-&gt;card-&gt;dmapages
op_eq
l_int|NULL
)paren
op_logical_and
id|allocate_buffers
c_func
(paren
id|s
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* we&squot;re covered by the open_sem */
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;card-&gt;dsps_open
)paren
(brace
id|maestro_power
c_func
(paren
id|s-&gt;card
comma
id|ACPI_D0
)paren
suffix:semicolon
id|start_bob
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|s-&gt;card-&gt;dsps_open
op_increment
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: open, %d bobs now&bslash;n&quot;
comma
id|s-&gt;card-&gt;dsps_open
)paren
suffix:semicolon
multiline_comment|/* ok, lets write WC base regs now that we&squot;ve &n;&t;&t;powered up the chip */
id|M_printk
c_func
(paren
l_string|&quot;maestro: writing 0x%lx (bus 0x%lx) to the wp&bslash;n&quot;
comma
id|virt_to_bus
c_func
(paren
id|s-&gt;card-&gt;dmapages
)paren
comma
(paren
(paren
id|virt_to_bus
c_func
(paren
id|s-&gt;card-&gt;dmapages
)paren
)paren
op_amp
l_int|0xFFE00000
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|set_base_registers
c_func
(paren
id|s
comma
id|s-&gt;card-&gt;dmapages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
multiline_comment|/*&n;&t;&t;fmtm &amp;= ~((ESS_FMT_STEREO | ESS_FMT_16BIT) &lt;&lt; ESS_ADC_SHIFT);&n;&t;&t;if ((minor &amp; 0xf) == SND_DEV_DSP16)&n;&t;&t;&t;fmts |= ESS_FMT_16BIT &lt;&lt; ESS_ADC_SHIFT; */
id|fmtm
op_and_assign
op_complement
(paren
(paren
id|ESS_FMT_STEREO
op_or
id|ESS_FMT_16BIT
)paren
op_lshift
id|ESS_ADC_SHIFT
)paren
suffix:semicolon
id|fmts
op_assign
(paren
id|ESS_FMT_STEREO
op_or
id|ESS_FMT_16BIT
)paren
op_lshift
id|ESS_ADC_SHIFT
suffix:semicolon
id|s-&gt;dma_adc.ossfragshift
op_assign
id|s-&gt;dma_adc.ossmaxfrags
op_assign
id|s-&gt;dma_adc.subdivision
op_assign
l_int|0
suffix:semicolon
id|set_adc_rate
c_func
(paren
id|s
comma
l_int|8000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|fmtm
op_and_assign
op_complement
(paren
(paren
id|ESS_FMT_STEREO
op_or
id|ESS_FMT_16BIT
)paren
op_lshift
id|ESS_DAC_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0xf
)paren
op_eq
id|SND_DEV_DSP16
)paren
id|fmts
op_or_assign
id|ESS_FMT_16BIT
op_lshift
id|ESS_DAC_SHIFT
suffix:semicolon
id|s-&gt;dma_dac.ossfragshift
op_assign
id|s-&gt;dma_dac.ossmaxfrags
op_assign
id|s-&gt;dma_dac.subdivision
op_assign
l_int|0
suffix:semicolon
id|set_dac_rate
c_func
(paren
id|s
comma
l_int|8000
)paren
suffix:semicolon
)brace
id|set_fmt
c_func
(paren
id|s
comma
id|fmtm
comma
id|fmts
)paren
suffix:semicolon
id|s-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ess_release
id|ess_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
(paren
r_struct
id|ess_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|drain_dac
c_func
(paren
id|s
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|s-&gt;open_mode
op_and_assign
(paren
op_complement
id|file-&gt;f_mode
)paren
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
multiline_comment|/* we&squot;re covered by the open_sem */
id|M_printk
c_func
(paren
l_string|&quot;maestro: %d dsps now alive&bslash;n&quot;
comma
id|s-&gt;card-&gt;dsps_open
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|s-&gt;card-&gt;dsps_open
op_le
l_int|0
)paren
(brace
id|s-&gt;card-&gt;dsps_open
op_assign
l_int|0
suffix:semicolon
id|stop_bob
c_func
(paren
id|s
)paren
suffix:semicolon
id|free_buffers
c_func
(paren
id|s
)paren
suffix:semicolon
id|maestro_power
c_func
(paren
id|s-&gt;card
comma
id|ACPI_D2
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ess_audio_fops
r_static
r_struct
id|file_operations
id|ess_audio_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|ess_llseek
comma
id|read
suffix:colon
id|ess_read
comma
id|write
suffix:colon
id|ess_write
comma
id|poll
suffix:colon
id|ess_poll
comma
id|ioctl
suffix:colon
id|ess_ioctl
comma
id|mmap
suffix:colon
id|ess_mmap
comma
id|open
suffix:colon
id|ess_open
comma
id|release
suffix:colon
id|ess_release
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|maestro_config
id|maestro_config
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
op_assign
id|card-&gt;pcidev
suffix:semicolon
r_struct
id|ess_state
op_star
id|ess
op_assign
op_amp
id|card-&gt;channels
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|apu
comma
id|iobase
op_assign
id|card-&gt;iobase
suffix:semicolon
id|u16
id|w
suffix:semicolon
id|u32
id|n
suffix:semicolon
multiline_comment|/* We used to muck around with pci config space that&n;&t; * we had no business messing with.  We don&squot;t know enough&n;&t; * about the machine to know which DMA mode is appropriate, &n;&t; * etc.  We were guessing wrong on some machines and making&n;&t; * them unhappy.  We now trust in the BIOS to do things right,&n;&t; * which almost certainly means a new host of problems will&n;&t; * arise with broken BIOS implementations.  screw &squot;em. &n;&t; * We&squot;re already intolerant of machines that don&squot;t assign&n;&t; * IRQs.&n;&t; */
multiline_comment|/* do config work at full power */
id|maestro_power
c_func
(paren
id|card
comma
id|ACPI_D0
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pcidev
comma
l_int|0x50
comma
op_amp
id|w
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t swap left/right (undoc)*/
id|pci_write_config_word
c_func
(paren
id|pcidev
comma
l_int|0x50
comma
id|w
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pcidev
comma
l_int|0x52
comma
op_amp
id|w
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|15
)paren
suffix:semicolon
multiline_comment|/* Turn off internal clock multiplier */
multiline_comment|/* XXX how do we know which to use? */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|14
)paren
suffix:semicolon
multiline_comment|/* External clock */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
multiline_comment|/* HWV off */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Debounce off */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* GPIO 4:5 */
id|w
op_or_assign
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Disconnect from the CHI.  Enabling this made a dell 7500 work. */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* MIDI fix off (undoc) */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* reserved, always write 0 */
id|pci_write_config_word
c_func
(paren
id|pcidev
comma
l_int|0x52
comma
id|w
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Legacy mode&n;&t; */
id|pci_read_config_word
c_func
(paren
id|pcidev
comma
l_int|0x40
comma
op_amp
id|w
)paren
suffix:semicolon
id|w
op_or_assign
(paren
l_int|1
op_lshift
l_int|15
)paren
suffix:semicolon
multiline_comment|/* legacy decode off */
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|14
)paren
suffix:semicolon
multiline_comment|/* Disable SIRQ */
id|w
op_and_assign
op_complement
(paren
l_int|0x1f
)paren
suffix:semicolon
multiline_comment|/* disable mpu irq/io, game port, fm, SB */
id|pci_write_config_word
c_func
(paren
id|pcidev
comma
l_int|0x40
comma
id|w
)paren
suffix:semicolon
id|sound_reset
c_func
(paren
id|iobase
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ring Bus Setup&n;&t; */
multiline_comment|/* setup usual 0x34 stuff.. 0x36 may be chip specific */
id|outw
c_func
(paren
l_int|0xC090
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
multiline_comment|/* direct sound, stereo */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x3000
comma
id|iobase
op_plus
l_int|0x36
)paren
suffix:semicolon
multiline_comment|/* direct sound, stereo */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Reset the CODEC&n;&t; */
id|maestro_ac97_reset
c_func
(paren
id|iobase
comma
id|pcidev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ring Bus Setup&n;&t; */
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_and_assign
op_complement
l_int|0xF000
suffix:semicolon
id|n
op_or_assign
l_int|12
op_lshift
l_int|12
suffix:semicolon
multiline_comment|/* Direct Sound, Stereo */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
multiline_comment|/* Modem off */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_and_assign
op_complement
l_int|0x00F0
suffix:semicolon
id|n
op_or_assign
l_int|9
op_lshift
l_int|4
suffix:semicolon
multiline_comment|/* DAC, Stereo */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_and_assign
op_complement
l_int|0x000F
suffix:semicolon
multiline_comment|/* ASSP off */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_or_assign
(paren
l_int|1
op_lshift
l_int|29
)paren
suffix:semicolon
multiline_comment|/* Enable ring bus */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_or_assign
(paren
l_int|1
op_lshift
l_int|28
)paren
suffix:semicolon
multiline_comment|/* Enable serial bus */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_and_assign
op_complement
l_int|0x00F00000
suffix:semicolon
multiline_comment|/* MIC off */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_assign
id|inl
c_func
(paren
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|n
op_and_assign
op_complement
l_int|0x000F0000
suffix:semicolon
multiline_comment|/* I2S off */
id|outl
c_func
(paren
id|n
comma
id|iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
multiline_comment|/* ClkRun off */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Harpo off */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* ASSP irq off */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* ISDN irq off */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_or_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Direct Sound IRQ on */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* MPU401 IRQ off */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_assign
id|inw
c_func
(paren
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
id|w
op_or_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
multiline_comment|/* SB IRQ on */
id|outw
c_func
(paren
id|w
comma
id|iobase
op_plus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* it appears some maestros (dell 7500) only work if these are set,&n;&t;&t;regardless of wether we use the assp or not. */
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
l_int|0xA4
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|iobase
op_plus
l_int|0xA2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
l_int|0xA6
)paren
suffix:semicolon
r_for
c_loop
(paren
id|apu
op_assign
l_int|0
suffix:semicolon
id|apu
OL
l_int|16
suffix:semicolon
id|apu
op_increment
)paren
(brace
multiline_comment|/* Write 0 into the buffer area 0x1E0-&gt;1EF */
id|outw
c_func
(paren
l_int|0x01E0
op_plus
id|apu
comma
l_int|0x10
op_plus
id|iobase
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
l_int|0x12
op_plus
id|iobase
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The 1.10 test program seem to write 0 into the buffer area&n;&t;&t; * 0x1D0-0x1DF too.&n;&t;&t; */
id|outw
c_func
(paren
l_int|0x01D0
op_plus
id|apu
comma
l_int|0x10
op_plus
id|iobase
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
l_int|0x12
op_plus
id|iobase
)paren
suffix:semicolon
)brace
macro_line|#if 1
id|wave_set_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
(paren
id|wave_get_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_amp
l_int|0xFF00
)paren
)paren
suffix:semicolon
id|wave_set_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
id|wave_get_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_or
l_int|0x100
)paren
suffix:semicolon
id|wave_set_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
id|wave_get_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_amp
op_complement
l_int|0x200
)paren
suffix:semicolon
id|wave_set_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
id|wave_get_register
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_or
op_complement
l_int|0x400
)paren
suffix:semicolon
macro_line|#else&t;&t;
id|maestro_write
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
(paren
id|maestro_read
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_amp
l_int|0xFF00
)paren
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
id|maestro_read
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_or
l_int|0x100
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
id|maestro_read
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_amp
op_complement
l_int|0x200
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
comma
id|maestro_read
c_func
(paren
id|ess
comma
id|IDR7_WAVE_ROMRAM
)paren
op_or
l_int|0x400
)paren
suffix:semicolon
macro_line|#endif
id|maestro_write
c_func
(paren
id|ess
comma
id|IDR2_CRAM_DATA
comma
l_int|0x0000
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x08
comma
l_int|0xB004
)paren
suffix:semicolon
multiline_comment|/* Now back to the DirectSound stuff */
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x09
comma
l_int|0x001B
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x0A
comma
l_int|0x8000
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x0B
comma
l_int|0x3F37
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x0C
comma
l_int|0x0098
)paren
suffix:semicolon
multiline_comment|/* parallel out ?? */
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x0C
comma
(paren
id|maestro_read
c_func
(paren
id|ess
comma
l_int|0x0C
)paren
op_amp
op_complement
l_int|0xF000
)paren
op_or
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/* parallel in, has something to do with recording :) */
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x0C
comma
(paren
id|maestro_read
c_func
(paren
id|ess
comma
l_int|0x0C
)paren
op_amp
op_complement
l_int|0x0F00
)paren
op_or
l_int|0x0500
)paren
suffix:semicolon
id|maestro_write
c_func
(paren
id|ess
comma
l_int|0x0D
comma
l_int|0x7632
)paren
suffix:semicolon
multiline_comment|/* Wave cache control on - test off, sg off, &n;&t;&t;enable, enable extra chans 1Mb */
id|outw
c_func
(paren
id|inw
c_func
(paren
l_int|0x14
op_plus
id|iobase
)paren
op_or
(paren
l_int|1
op_lshift
l_int|8
)paren
comma
l_int|0x14
op_plus
id|iobase
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
l_int|0x14
op_plus
id|iobase
)paren
op_amp
l_int|0xFE03
comma
l_int|0x14
op_plus
id|iobase
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
l_int|0x14
op_plus
id|iobase
)paren
op_amp
l_int|0xFFFC
)paren
comma
l_int|0x14
op_plus
id|iobase
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
l_int|0x14
op_plus
id|iobase
)paren
op_or
(paren
l_int|1
op_lshift
l_int|7
)paren
comma
l_int|0x14
op_plus
id|iobase
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xA1A0
comma
l_int|0x14
op_plus
id|iobase
)paren
suffix:semicolon
multiline_comment|/* 0300 ? */
multiline_comment|/* Now clear the APU control ram */
r_for
c_loop
(paren
id|apu
op_assign
l_int|0
suffix:semicolon
id|apu
OL
id|NR_APUS
suffix:semicolon
id|apu
op_increment
)paren
(brace
r_for
c_loop
(paren
id|w
op_assign
l_int|0
suffix:semicolon
id|w
OL
id|NR_APU_REGS
suffix:semicolon
id|w
op_increment
)paren
(brace
id|apu_set_register
c_func
(paren
id|ess
comma
id|apu
op_or
id|ESS_CHAN_HARD
comma
id|w
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this guy tries to find the pci power management&n; * register bank.  this should really be in core&n; * code somewhere.  1 on success. */
r_int
DECL|function|parse_power
id|parse_power
c_func
(paren
r_struct
id|ess_card
op_star
id|card
comma
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
id|u32
id|n
suffix:semicolon
id|u16
id|w
suffix:semicolon
id|u8
id|next
suffix:semicolon
r_int
id|max
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* an a 8bit guy pointing to 32bit guys&n;&t;&t;&t;&t;can only express so much. */
id|card-&gt;power_regs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check to see if we have a capabilities list in&n;&t;&t;the config register */
id|pci_read_config_word
c_func
(paren
id|pcidev
comma
id|PCI_STATUS
comma
op_amp
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|w
op_amp
id|PCI_STATUS_CAP_LIST
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* walk the list, starting at the head. */
id|pci_read_config_byte
c_func
(paren
id|pcidev
comma
id|PCI_CAPABILITY_LIST
comma
op_amp
id|next
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next
op_logical_and
id|max
op_decrement
)paren
(brace
id|pci_read_config_dword
c_func
(paren
id|pcidev
comma
id|next
op_amp
op_complement
l_int|3
comma
op_amp
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_amp
l_int|0xff
)paren
op_eq
id|PCI_CAP_ID_PM
)paren
(brace
id|card-&gt;power_regs
op_assign
id|next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|next
op_assign
(paren
(paren
id|n
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_return
id|card-&gt;power_regs
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|maestro_install
id|maestro_install
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcidev
comma
r_int
id|card_type
)paren
(brace
id|u32
id|n
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|ess_card
op_star
id|card
suffix:semicolon
r_struct
id|ess_state
op_star
id|ess
suffix:semicolon
r_struct
id|pm_dev
op_star
id|pmdev
suffix:semicolon
r_int
id|num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t pick up weird modem maestros */
r_if
c_cond
(paren
(paren
(paren
id|pcidev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_amp
l_int|0xffff
)paren
op_ne
id|PCI_CLASS_MULTIMEDIA_AUDIO
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|iobase
op_assign
id|SILLY_PCI_BASE_ADDRESS
c_func
(paren
id|pcidev
)paren
suffix:semicolon
multiline_comment|/* stake our claim on the iospace */
r_if
c_cond
(paren
id|request_region
c_func
(paren
id|iobase
comma
l_int|256
comma
id|card_names
(braket
id|card_type
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: can&squot;t allocate 256 bytes I/O at 0x%4.4x&bslash;n&quot;
comma
id|iobase
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this was tripping up some machines */
r_if
c_cond
(paren
id|pcidev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: pci subsystem reports irq 0, this might not be correct.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* just to be sure */
id|pci_set_master
c_func
(paren
id|pcidev
)paren
suffix:semicolon
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ess_card
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|card
)paren
)paren
suffix:semicolon
id|card-&gt;pcidev
op_assign
id|pcidev
suffix:semicolon
id|pmdev
op_assign
id|pm_register
c_func
(paren
id|PM_PCI_DEV
comma
id|PM_PCI_ID
c_func
(paren
id|pcidev
)paren
comma
id|maestro_pm_callback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmdev
)paren
id|pmdev-&gt;data
op_assign
id|card
suffix:semicolon
r_if
c_cond
(paren
id|register_reboot_notifier
c_func
(paren
op_amp
id|maestro_nb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: reboot notifier registration failed; may not reboot properly.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|card-&gt;iobase
op_assign
id|iobase
suffix:semicolon
id|card-&gt;card_type
op_assign
id|card_type
suffix:semicolon
id|card-&gt;irq
op_assign
id|pcidev-&gt;irq
suffix:semicolon
id|card-&gt;next
op_assign
id|devs
suffix:semicolon
id|card-&gt;magic
op_assign
id|ESS_CARD_MAGIC
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|card-&gt;suspend_queue
)paren
suffix:semicolon
id|devs
op_assign
id|card
suffix:semicolon
multiline_comment|/* init our groups of 6 apus */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
id|s-&gt;index
op_assign
id|i
suffix:semicolon
id|s-&gt;card
op_assign
id|card
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|SILLY_INIT_SEM
c_func
(paren
id|s-&gt;open_sem
)paren
suffix:semicolon
id|s-&gt;magic
op_assign
id|ESS_STATE_MAGIC
suffix:semicolon
id|s-&gt;apu
(braket
l_int|0
)braket
op_assign
l_int|6
op_star
id|i
suffix:semicolon
id|s-&gt;apu
(braket
l_int|1
)braket
op_assign
(paren
l_int|6
op_star
id|i
)paren
op_plus
l_int|1
suffix:semicolon
id|s-&gt;apu
(braket
l_int|2
)braket
op_assign
(paren
l_int|6
op_star
id|i
)paren
op_plus
l_int|2
suffix:semicolon
id|s-&gt;apu
(braket
l_int|3
)braket
op_assign
(paren
l_int|6
op_star
id|i
)paren
op_plus
l_int|3
suffix:semicolon
id|s-&gt;apu
(braket
l_int|4
)braket
op_assign
(paren
l_int|6
op_star
id|i
)paren
op_plus
l_int|4
suffix:semicolon
id|s-&gt;apu
(braket
l_int|5
)braket
op_assign
(paren
l_int|6
op_star
id|i
)paren
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.ready
op_logical_or
id|s-&gt;dma_dac.ready
op_logical_or
id|s-&gt;dma_adc.rawbuf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;maestro: BOTCH!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* register devices */
r_if
c_cond
(paren
(paren
id|s-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|ess_audio_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|num
op_assign
id|i
suffix:semicolon
multiline_comment|/* clear the rest if we ran out of slots to register */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
id|s-&gt;dev_audio
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|ess
op_assign
op_amp
id|card-&gt;channels
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pcidev
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;maestro: pci_enable_device() failed&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dev_audio
op_ne
op_minus
l_int|1
)paren
id|unregister_sound_dsp
c_func
(paren
id|s-&gt;dev_audio
)paren
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|maestro_nb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Ok card ready. Begin setup proper&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: Configuring %s found at IO 0x%04X IRQ %d&bslash;n&quot;
comma
id|card_names
(braket
id|card_type
)braket
comma
id|iobase
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pcidev
comma
id|PCI_SUBSYSTEM_VENDOR_ID
comma
op_amp
id|n
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro:  subvendor id: 0x%08x&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* turn off power management unless:&n;&t; *&t;- the user explicitly asks for it&n;&t; * &t;&t;or&n;&t; *&t;&t;- we&squot;re not a 2e, lesser chipps seem to have problems.&n;&t; *&t;&t;- we&squot;re not on our _very_ small whitelist.  some implemenetations&n;&t; *&t;&t;&t;really dont&squot; like the pm code, others require it.&n;&t; *&t;&t;&t;feel free to expand this as required.&n;&t; */
DECL|macro|SUBSYSTEM_VENDOR
mdefine_line|#define SUBSYSTEM_VENDOR(x) (x&amp;0xffff)
r_if
c_cond
(paren
(paren
id|use_pm
op_ne
l_int|1
)paren
op_logical_and
(paren
(paren
id|card_type
op_ne
id|TYPE_MAESTRO2E
)paren
op_logical_or
(paren
id|SUBSYSTEM_VENDOR
c_func
(paren
id|n
)paren
op_ne
l_int|0x1028
)paren
)paren
)paren
(brace
id|use_pm
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|use_pm
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: not attempting power management.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|parse_power
c_func
(paren
id|card
comma
id|pcidev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: no PCI power managment interface found.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_read_config_dword
c_func
(paren
id|pcidev
comma
id|card-&gt;power_regs
comma
op_amp
id|n
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: PCI power managment capability: 0x%x&bslash;n&quot;
comma
id|n
op_rshift
l_int|16
)paren
suffix:semicolon
)brace
)brace
id|maestro_config
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maestro_ac97_get
c_func
(paren
id|card
comma
l_int|0x00
)paren
op_eq
l_int|0x0080
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;maestro: my goodness!  you seem to have a pt101 codec, which is quite rare.&bslash;n&quot;
l_string|&quot;&bslash;tyou should tell someone about this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|maestro_ac97_init
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|ess_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;maestro: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|card-&gt;mix.mixer_state
comma
id|mixer_defaults
comma
r_sizeof
(paren
id|card-&gt;mix.mixer_state
)paren
)paren
suffix:semicolon
id|mixer_push_state
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|card-&gt;irq
comma
id|ess_interrupt
comma
id|SA_SHIRQ
comma
id|card_names
(braket
id|card_type
)braket
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;maestro: unable to allocate irq %d,&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;dev_mixer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dev_audio
op_ne
op_minus
l_int|1
)paren
(brace
id|unregister_sound_dsp
c_func
(paren
id|s-&gt;dev_audio
)paren
suffix:semicolon
)brace
)brace
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|maestro_nb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* now go to sleep &squot;till something interesting happens */
id|maestro_power
c_func
(paren
id|card
comma
id|ACPI_D2
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: %d channels configured.&bslash;n&quot;
comma
id|num
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|init_maestro
r_int
id|__init
id|init_maestro
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|foundone
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
multiline_comment|/* No PCI bus in this machine! */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;maestro: version &quot;
id|DRIVER_VERSION
l_string|&quot; time &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dsps_order
OL
l_int|0
)paren
(brace
id|dsps_order
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: clipping dsps_order to %d&bslash;n&quot;
comma
id|dsps_order
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsps_order
OG
id|MAX_DSP_ORDER
)paren
(brace
id|dsps_order
op_assign
id|MAX_DSP_ORDER
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;maestro: clipping dsps_order to %d&bslash;n&quot;
comma
id|dsps_order
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Find the ESS Maestro 2.&n;&t; */
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ESS
comma
id|PCI_DEVICE_ID_ESS_ESS1968
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|maestro_install
c_func
(paren
id|pcidev
comma
id|TYPE_MAESTRO2
)paren
)paren
id|foundone
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Find the ESS Maestro 2E&n;&t; */
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ESS
comma
id|PCI_DEVICE_ID_ESS_ESS1978
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|maestro_install
c_func
(paren
id|pcidev
comma
id|TYPE_MAESTRO2E
)paren
)paren
id|foundone
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;ESS Maestro 1&n;&t; */
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ESS_OLD
comma
id|PCI_DEVICE_ID_ESS_ESS0100
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|maestro_install
c_func
(paren
id|pcidev
comma
id|TYPE_MAESTRO
)paren
)paren
id|foundone
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|foundone
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;maestro: no devices found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nuke_maestros
r_static
r_void
id|nuke_maestros
c_func
(paren
r_void
)paren
(brace
r_struct
id|ess_card
op_star
id|card
suffix:semicolon
multiline_comment|/* we do these unconditionally, which is probably wrong */
id|pm_unregister_all
c_func
(paren
id|maestro_pm_callback
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|maestro_nb
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|card
op_assign
id|devs
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|devs
op_assign
id|devs-&gt;next
suffix:semicolon
multiline_comment|/* XXX maybe should force stop bob, but should be all &n;&t;&t;&t;stopped by _release by now */
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;dev_mixer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|ess
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ess-&gt;dev_audio
op_ne
op_minus
l_int|1
)paren
(brace
id|unregister_sound_dsp
c_func
(paren
id|ess-&gt;dev_audio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Goodbye, Mr. Bond. */
id|maestro_power
c_func
(paren
id|card
comma
id|ACPI_D3
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|devs
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|maestro_notifier
r_static
r_int
id|maestro_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
comma
r_int
r_int
id|event
comma
r_void
op_star
id|buf
)paren
(brace
multiline_comment|/* this notifier is called when the kernel is really shut down. */
id|M_printk
c_func
(paren
l_string|&quot;maestro: shutting down&bslash;n&quot;
)paren
suffix:semicolon
id|nuke_maestros
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Zach Brown &lt;zab@zabbo.net&gt;, Alan Cox &lt;alan@redhat.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ESS Maestro Driver&quot;
)paren
suffix:semicolon
macro_line|#ifdef M_DEBUG
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_PARM
c_func
(paren
id|dsps_order
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|use_pm
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|clocking
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|M_printk
c_func
(paren
l_string|&quot;maestro: unloading&bslash;n&quot;
)paren
suffix:semicolon
id|nuke_maestros
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* --------------------------------------------------------------------- */
r_void
DECL|function|check_suspend
id|check_suspend
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;in_suspend
)paren
(brace
r_return
suffix:semicolon
)brace
id|card-&gt;in_suspend
op_increment
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
(paren
id|card-&gt;suspend_queue
)paren
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
(paren
id|card-&gt;suspend_queue
)paren
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
r_static
r_int
DECL|function|maestro_suspend
id|maestro_suspend
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* over-kill */
id|M_printk
c_func
(paren
l_string|&quot;maestro: apm in dev %p&bslash;n&quot;
comma
id|card
)paren
suffix:semicolon
multiline_comment|/* we have to read from the apu regs, need&n;&t;&t;to power it up */
id|maestro_power
c_func
(paren
id|card
comma
id|ACPI_D0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dev_audio
op_eq
op_minus
l_int|1
)paren
(brace
r_continue
suffix:semicolon
)brace
id|M_printk
c_func
(paren
l_string|&quot;maestro: stopping apus for device %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
(brace
id|card-&gt;apu_map
(braket
id|s-&gt;apu
(braket
id|j
)braket
)braket
(braket
l_int|5
)braket
op_assign
id|apu_get_register
c_func
(paren
id|s
comma
id|j
comma
l_int|5
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* get rid of interrupts? */
r_if
c_cond
(paren
id|card-&gt;dsps_open
OG
l_int|0
)paren
(brace
id|stop_bob
c_func
(paren
op_amp
id|card-&gt;channels
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|card-&gt;in_suspend
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* we trust in the bios to power down the chip on suspend.&n;&t; * XXX I&squot;m also not sure that in_suspend will protect&n;&t; * against all reg accesses from here on out. &n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|maestro_resume
id|maestro_resume
c_func
(paren
r_struct
id|ess_card
op_star
id|card
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* over-kill */
id|card-&gt;in_suspend
op_assign
l_int|0
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: resuming card at %p&bslash;n&quot;
comma
id|card
)paren
suffix:semicolon
multiline_comment|/* restore all our config */
id|maestro_config
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* need to restore the base pointers.. */
r_if
c_cond
(paren
id|card-&gt;dmapages
)paren
(brace
id|set_base_registers
c_func
(paren
op_amp
id|card-&gt;channels
(braket
l_int|0
)braket
comma
id|card-&gt;dmapages
)paren
suffix:semicolon
)brace
id|mixer_push_state
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* set each channels&squot; apu control registers before&n;&t; * restoring audio &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
r_int
id|chan
comma
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dev_audio
op_eq
op_minus
l_int|1
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
l_int|6
suffix:semicolon
id|chan
op_increment
)paren
(brace
id|wave_set_register
c_func
(paren
id|s
comma
id|s-&gt;apu
(braket
id|chan
)braket
op_lshift
l_int|3
comma
id|s-&gt;apu_base
(braket
id|chan
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
l_int|1
suffix:semicolon
id|reg
OL
id|NR_APU_REGS
suffix:semicolon
id|reg
op_increment
)paren
(brace
id|apu_set_register
c_func
(paren
id|s
comma
id|chan
comma
id|reg
comma
id|s-&gt;card-&gt;apu_map
(braket
id|s-&gt;apu
(braket
id|chan
)braket
)braket
(braket
id|reg
)braket
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
l_int|6
suffix:semicolon
id|chan
op_increment
)paren
(brace
id|apu_set_register
c_func
(paren
id|s
comma
id|chan
comma
l_int|0
comma
id|s-&gt;card-&gt;apu_map
(braket
id|s-&gt;apu
(braket
id|chan
)braket
)braket
(braket
l_int|0
)braket
op_amp
l_int|0xFF0F
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* now we flip on the music */
r_if
c_cond
(paren
id|card-&gt;dsps_open
op_le
l_int|0
)paren
(brace
multiline_comment|/* this card&squot;s idle */
id|maestro_power
c_func
(paren
id|card
comma
id|ACPI_D2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ok, we&squot;re actually playing things on&n;&t;&t;&t;this card */
id|maestro_power
c_func
(paren
id|card
comma
id|ACPI_D0
)paren
suffix:semicolon
id|start_bob
c_func
(paren
op_amp
id|card-&gt;channels
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ess_state
op_star
id|s
op_assign
op_amp
id|card-&gt;channels
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* these use the apu_mode, and can handle&n;&t;&t;&t;&t;spurious calls */
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all right, we think things are ready, &n;&t;&t;wake up people who were using the device&n;&t;&t;when we suspended */
id|wake_up
c_func
(paren
op_amp
(paren
id|card-&gt;suspend_queue
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|maestro_pm_callback
id|maestro_pm_callback
c_func
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ess_card
op_star
id|card
op_assign
(paren
r_struct
id|ess_card
op_star
)paren
id|dev-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_goto
id|out
suffix:semicolon
id|M_printk
c_func
(paren
l_string|&quot;maestro: pm event 0x%x received for card %p&bslash;n&quot;
comma
id|rqst
comma
id|card
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rqst
)paren
(brace
r_case
id|PM_SUSPEND
suffix:colon
id|maestro_suspend
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_RESUME
suffix:colon
id|maestro_resume
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we&squot;d also like to find out about&n;&t;&t; * power level changes because some biosen&n;&t;&t; * do mean things to the maestro when they&n;&t;&t; * change their power state.&n;&t;&t; */
)brace
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_maestro
id|module_init
c_func
(paren
id|init_maestro
)paren
suffix:semicolon
eof
