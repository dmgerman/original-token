multiline_comment|/*&n; * sound/ad1848.c&n; *&n; * The low level driver for the AD1848/CS4248 codec chip which&n; * is used for example in the MS Sound System.&n; *&n; * The CS4231 which is used in the GUS MAX and some other cards is&n; * upwards compatible with AD1848 and this driver is able to drive it.&n; *&n; * Copyright by Hannu Savolainen 1994&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions are&n; * met: 1. Redistributions of source code must retain the above copyright&n; * notice, this list of conditions and the following disclaimer. 2.&n; * Redistributions in binary form must reproduce the above copyright notice,&n; * this list of conditions and the following disclaimer in the documentation&n; * and/or other materials provided with the distribution.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND ANY&n; * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED&n; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER&n; * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; *&n; */
DECL|macro|DEB
mdefine_line|#define DEB(x)
DECL|macro|DEB1
mdefine_line|#define DEB1(x)
macro_line|#include &quot;sound_config.h&quot;
macro_line|#if defined(CONFIGURE_SOUNDCARD) &amp;&amp; !defined(EXCLUDE_AD1848)
DECL|macro|IMODE_NONE
mdefine_line|#define IMODE_NONE&t;&t;0
DECL|macro|IMODE_OUTPUT
mdefine_line|#define IMODE_OUTPUT&t;&t;1
DECL|macro|IMODE_INPUT
mdefine_line|#define IMODE_INPUT&t;&t;2
DECL|macro|IMODE_INIT
mdefine_line|#define IMODE_INIT&t;&t;3
DECL|macro|IMODE_MIDI
mdefine_line|#define IMODE_MIDI&t;&t;4
r_typedef
r_struct
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|dma_capture
DECL|member|dma_playback
r_int
id|dma_capture
comma
id|dma_playback
suffix:semicolon
DECL|member|MCE_bit
r_int
r_char
id|MCE_bit
suffix:semicolon
DECL|member|speed
r_int
id|speed
suffix:semicolon
DECL|member|speed_bits
r_int
r_char
id|speed_bits
suffix:semicolon
DECL|member|channels
r_int
id|channels
suffix:semicolon
DECL|member|audio_format
r_int
id|audio_format
suffix:semicolon
DECL|member|format_bits
r_int
r_char
id|format_bits
suffix:semicolon
DECL|member|xfer_count
r_int
id|xfer_count
suffix:semicolon
DECL|member|irq_mode
r_int
id|irq_mode
suffix:semicolon
DECL|member|intr_active
r_int
id|intr_active
suffix:semicolon
DECL|member|opened
r_int
id|opened
suffix:semicolon
DECL|member|chip_name
r_char
op_star
id|chip_name
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
)brace
DECL|typedef|ad1848_info
id|ad1848_info
suffix:semicolon
DECL|variable|nr_ad1848_devs
r_static
r_int
id|nr_ad1848_devs
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq2dev
r_static
r_char
id|irq2dev
(braket
l_int|16
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|ad_format_mask
r_static
r_int
id|ad_format_mask
(braket
l_int|3
multiline_comment|/*devc-&gt;mode*/
)braket
op_assign
(brace
l_int|0
comma
id|AFMT_U8
op_or
id|AFMT_S16_LE
op_or
id|AFMT_MU_LAW
op_or
id|AFMT_A_LAW
comma
id|AFMT_U8
op_or
id|AFMT_S16_LE
op_or
id|AFMT_MU_LAW
op_or
id|AFMT_A_LAW
op_or
id|AFMT_U16_LE
op_or
id|AFMT_IMA_ADPCM
)brace
suffix:semicolon
DECL|variable|dev_info
r_static
id|ad1848_info
id|dev_info
(braket
id|MAX_AUDIO_DEV
)braket
suffix:semicolon
DECL|macro|io_Index_Addr
mdefine_line|#define io_Index_Addr(d)&t;((d)-&gt;base)
DECL|macro|io_Indexed_Data
mdefine_line|#define io_Indexed_Data(d)&t;((d)-&gt;base+1)
DECL|macro|io_Status
mdefine_line|#define io_Status(d)&t;&t;((d)-&gt;base+2)
DECL|macro|io_Polled_IO
mdefine_line|#define io_Polled_IO(d)&t;&t;((d)-&gt;base+3)
r_static
r_int
id|ad1848_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_void
id|ad1848_close
(paren
r_int
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ad1848_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
comma
r_int
id|local
)paren
suffix:semicolon
r_static
r_void
id|ad1848_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
comma
r_int
id|dma_restart
)paren
suffix:semicolon
r_static
r_void
id|ad1848_start_input
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
comma
r_int
id|dma_restart
)paren
suffix:semicolon
r_static
r_int
id|ad1848_prepare_for_IO
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
suffix:semicolon
r_static
r_void
id|ad1848_reset
(paren
r_int
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ad1848_halt
(paren
r_int
id|dev
)paren
suffix:semicolon
r_void
id|ad1848_interrupt
(paren
r_int
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
DECL|function|ad_read
id|ad_read
(paren
id|ad1848_info
op_star
id|devc
comma
r_int
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|x
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
(paren
r_int
r_char
)paren
(paren
id|reg
op_amp
l_int|0xff
)paren
op_or
id|devc-&gt;MCE_bit
comma
id|io_Index_Addr
(paren
id|devc
)paren
)paren
suffix:semicolon
id|x
op_assign
id|INB
(paren
id|io_Indexed_Data
(paren
id|devc
)paren
)paren
suffix:semicolon
multiline_comment|/*  printk(&quot;(%02x&lt;-%02x) &quot;, reg|devc-&gt;MCE_bit, x); */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad_write
id|ad_write
(paren
id|ad1848_info
op_star
id|devc
comma
r_int
id|reg
comma
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
(paren
r_int
r_char
)paren
(paren
id|reg
op_amp
l_int|0xff
)paren
op_or
id|devc-&gt;MCE_bit
comma
id|io_Index_Addr
(paren
id|devc
)paren
)paren
suffix:semicolon
id|OUTB
(paren
(paren
r_int
r_char
)paren
(paren
id|data
op_amp
l_int|0xff
)paren
comma
id|io_Indexed_Data
(paren
id|devc
)paren
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;(%02x-&gt;%02x) &quot;, reg|devc-&gt;MCE_bit, data); */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad_set_MCE
id|ad_set_MCE
(paren
id|ad1848_info
op_star
id|devc
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
id|devc-&gt;MCE_bit
op_assign
l_int|0x40
suffix:semicolon
r_else
id|devc-&gt;MCE_bit
op_assign
l_int|0x00
suffix:semicolon
id|OUTB
(paren
id|devc-&gt;MCE_bit
comma
id|io_Index_Addr
(paren
id|devc
)paren
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|wait_for_calibration
id|wait_for_calibration
(paren
id|ad1848_info
op_star
id|devc
)paren
(brace
r_int
id|timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Wait until the auto calibration process has finished.&n; *&n; * 1)&t;Wait until the chip becomes ready (reads don&squot;t return 0x80).&n; * 2)&t;Wait until the ACI bit of I11 gets on and then off.&n; */
id|timeout
op_assign
l_int|100000
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
l_int|0
op_logical_and
id|INB
(paren
id|devc-&gt;base
)paren
op_eq
l_int|0x80
)paren
id|timeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|INB
(paren
id|devc-&gt;base
)paren
op_eq
l_int|0x80
)paren
id|printk
(paren
l_string|&quot;ad1848: Auto calibration timed out(1).&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|100000
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
l_int|0
op_logical_and
op_logical_neg
(paren
id|ad_read
(paren
id|devc
comma
l_int|11
)paren
op_amp
l_int|0x20
)paren
)paren
id|timeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ad_read
(paren
id|devc
comma
l_int|11
)paren
op_amp
l_int|0x20
)paren
)paren
id|printk
(paren
l_string|&quot;ad1848: Auto calibration timed out(2).&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|100000
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
l_int|0
op_logical_and
id|ad_read
(paren
id|devc
comma
l_int|11
)paren
op_amp
l_int|0x20
)paren
id|timeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ad_read
(paren
id|devc
comma
l_int|11
)paren
op_amp
l_int|0x20
)paren
id|printk
(paren
l_string|&quot;ad1848: Auto calibration timed out(3).&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ad1848_pcm_operations
r_static
r_struct
id|audio_operations
id|ad1848_pcm_operations
(braket
id|MAX_AUDIO_DEV
)braket
op_assign
(brace
(brace
l_string|&quot;Generic AD1848 codec&quot;
comma
id|DMA_AUTOMODE
comma
id|AFMT_U8
comma
multiline_comment|/* Will be set later */
l_int|NULL
comma
id|ad1848_open
comma
id|ad1848_close
comma
id|ad1848_output_block
comma
id|ad1848_start_input
comma
id|ad1848_ioctl
comma
id|ad1848_prepare_for_IO
comma
id|ad1848_prepare_for_IO
comma
id|ad1848_reset
comma
id|ad1848_halt
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
r_static
r_int
DECL|function|ad1848_open
id|ad1848_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_int
id|err
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;ad1848_open(int mode = %X)&bslash;n&quot;
comma
id|mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
l_int|0
op_logical_or
id|dev
op_ge
id|num_audiodevs
)paren
r_return
id|RET_ERROR
(paren
id|ENXIO
)paren
suffix:semicolon
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;opened
)paren
(brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ad1848: Already opened&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EBUSY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devc-&gt;irq
)paren
multiline_comment|/* Not managed by another driver */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_set_irq_handler
(paren
id|devc-&gt;irq
comma
id|ad1848_interrupt
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ad1848: IRQ in use&bslash;n&quot;
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DMAbuf_open_dma
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ad1848: DMA in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EBUSY
)paren
suffix:semicolon
)brace
id|devc-&gt;intr_active
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;opened
op_assign
l_int|1
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad1848_close
id|ad1848_close
(paren
r_int
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;ad1848_close(void)&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|devc-&gt;intr_active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;irq
)paren
multiline_comment|/* Not managed by another driver */
id|snd_release_irq
(paren
id|devc-&gt;irq
)paren
suffix:semicolon
id|ad1848_reset
(paren
id|dev
)paren
suffix:semicolon
id|DMAbuf_close_dma
(paren
id|dev
)paren
suffix:semicolon
id|devc-&gt;opened
op_assign
l_int|0
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_speed
id|set_speed
(paren
id|ad1848_info
op_star
id|devc
comma
r_int
id|arg
)paren
(brace
multiline_comment|/*&n; * The sampling speed is encoded in the least significant nibble of I8. The&n; * LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz) and other&n; * three bits select the divisor (indirectly):&n; *&n; * The available speeds are in the following table. Keep the speeds in&n; * the increasing order.&n; */
r_typedef
r_struct
(brace
r_int
id|speed
suffix:semicolon
r_int
r_char
id|bits
suffix:semicolon
)brace
id|speed_struct
suffix:semicolon
r_static
id|speed_struct
id|speed_table
(braket
)braket
op_assign
(brace
(brace
l_int|5510
comma
(paren
l_int|0
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|5510
comma
(paren
l_int|0
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|6620
comma
(paren
l_int|7
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|8000
comma
(paren
l_int|0
op_lshift
l_int|1
)paren
op_or
l_int|0
)brace
comma
(brace
l_int|9600
comma
(paren
l_int|7
op_lshift
l_int|1
)paren
op_or
l_int|0
)brace
comma
(brace
l_int|11025
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|16000
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
l_int|0
)brace
comma
(brace
l_int|18900
comma
(paren
l_int|2
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|22050
comma
(paren
l_int|3
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|27420
comma
(paren
l_int|2
op_lshift
l_int|1
)paren
op_or
l_int|0
)brace
comma
(brace
l_int|32000
comma
(paren
l_int|3
op_lshift
l_int|1
)paren
op_or
l_int|0
)brace
comma
(brace
l_int|33075
comma
(paren
l_int|6
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|37800
comma
(paren
l_int|4
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|44100
comma
(paren
l_int|5
op_lshift
l_int|1
)paren
op_or
l_int|1
)brace
comma
(brace
l_int|48000
comma
(paren
l_int|6
op_lshift
l_int|1
)paren
op_or
l_int|0
)brace
)brace
suffix:semicolon
r_int
id|i
comma
id|n
comma
id|selected
op_assign
op_minus
l_int|1
suffix:semicolon
id|n
op_assign
r_sizeof
(paren
id|speed_table
)paren
op_div
r_sizeof
(paren
id|speed_struct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
OL
id|speed_table
(braket
l_int|0
)braket
dot
id|speed
)paren
id|selected
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg
OG
id|speed_table
(braket
id|n
op_minus
l_int|1
)braket
dot
id|speed
)paren
id|selected
op_assign
id|n
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
multiline_comment|/*really*/
suffix:semicolon
id|selected
op_eq
op_minus
l_int|1
op_logical_and
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|speed_table
(braket
id|i
)braket
dot
id|speed
op_eq
id|arg
)paren
id|selected
op_assign
id|i
suffix:semicolon
r_else
r_if
c_cond
(paren
id|speed_table
(braket
id|i
)braket
dot
id|speed
OG
id|arg
)paren
(brace
r_int
id|diff1
comma
id|diff2
suffix:semicolon
id|diff1
op_assign
id|arg
op_minus
id|speed_table
(braket
id|i
op_minus
l_int|1
)braket
dot
id|speed
suffix:semicolon
id|diff2
op_assign
id|speed_table
(braket
id|i
)braket
dot
id|speed
op_minus
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|diff1
OL
id|diff2
)paren
id|selected
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_else
id|selected
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|selected
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;ad1848: Can&squot;t find speed???&bslash;n&quot;
)paren
suffix:semicolon
id|selected
op_assign
l_int|3
suffix:semicolon
)brace
id|devc-&gt;speed
op_assign
id|speed_table
(braket
id|selected
)braket
dot
id|speed
suffix:semicolon
id|devc-&gt;speed_bits
op_assign
id|speed_table
(braket
id|selected
)braket
dot
id|bits
suffix:semicolon
r_return
id|devc-&gt;speed
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_channels
id|set_channels
(paren
id|ad1848_info
op_star
id|devc
comma
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_ne
l_int|1
op_logical_and
id|arg
op_ne
l_int|2
)paren
r_return
id|devc-&gt;channels
suffix:semicolon
id|devc-&gt;channels
op_assign
id|arg
suffix:semicolon
r_return
id|arg
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_format
id|set_format
(paren
id|ad1848_info
op_star
id|devc
comma
r_int
id|arg
)paren
(brace
r_static
r_struct
id|format_tbl
(brace
r_int
id|format
suffix:semicolon
r_int
r_char
id|bits
suffix:semicolon
)brace
id|format2bits
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
id|AFMT_MU_LAW
comma
l_int|1
)brace
comma
(brace
id|AFMT_A_LAW
comma
l_int|3
)brace
comma
(brace
id|AFMT_IMA_ADPCM
comma
l_int|5
)brace
comma
(brace
id|AFMT_U8
comma
l_int|0
)brace
comma
(brace
id|AFMT_S16_LE
comma
l_int|2
)brace
comma
(brace
id|AFMT_S16_BE
comma
l_int|6
)brace
comma
(brace
id|AFMT_S8
comma
l_int|0
)brace
comma
(brace
id|AFMT_U16_LE
comma
l_int|0
)brace
comma
(brace
id|AFMT_U16_BE
comma
l_int|0
)brace
)brace
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
r_sizeof
(paren
id|format2bits
)paren
op_div
r_sizeof
(paren
r_struct
id|format_tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|arg
op_amp
id|ad_format_mask
(braket
id|devc-&gt;mode
)braket
)paren
)paren
id|arg
op_assign
id|AFMT_U8
suffix:semicolon
id|devc-&gt;audio_format
op_assign
id|arg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|format2bits
(braket
id|i
)braket
dot
id|format
op_eq
id|arg
)paren
(brace
r_if
c_cond
(paren
(paren
id|devc-&gt;format_bits
op_assign
id|format2bits
(braket
id|i
)braket
dot
id|bits
)paren
op_eq
l_int|0
)paren
r_return
id|devc-&gt;audio_format
op_assign
id|AFMT_U8
suffix:semicolon
multiline_comment|/* Was not supported */
r_return
id|arg
suffix:semicolon
)brace
multiline_comment|/* Still hanging here. Something must be terribly wrong */
id|devc-&gt;format_bits
op_assign
l_int|0
suffix:semicolon
r_return
id|devc-&gt;audio_format
op_assign
id|AFMT_U8
suffix:semicolon
)brace
r_static
r_int
DECL|function|ad1848_ioctl
id|ad1848_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
comma
r_int
id|local
)paren
(brace
id|ad1848_info
op_star
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_PCM_WRITE_RATE
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|set_speed
(paren
id|devc
comma
id|arg
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|set_speed
(paren
id|devc
comma
id|IOCTL_IN
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|devc-&gt;speed
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|devc-&gt;speed
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|set_channels
(paren
id|devc
comma
id|arg
op_plus
l_int|1
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|set_channels
(paren
id|devc
comma
id|IOCTL_IN
(paren
id|arg
)paren
op_plus
l_int|1
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|set_channels
(paren
id|devc
comma
id|arg
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|set_channels
(paren
id|devc
comma
id|IOCTL_IN
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|devc-&gt;channels
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|devc-&gt;channels
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SAMPLESIZE
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|set_format
(paren
id|devc
comma
id|arg
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|set_format
(paren
id|devc
comma
id|IOCTL_IN
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|devc-&gt;audio_format
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|devc-&gt;audio_format
)paren
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad1848_output_block
id|ad1848_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
comma
r_int
id|dma_restart
)paren
(brace
r_int
r_int
id|flags
comma
id|cnt
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;audio_format
op_eq
id|AFMT_IMA_ADPCM
)paren
(brace
id|cnt
op_div_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|devc-&gt;audio_format
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_S16_BE
)paren
)paren
multiline_comment|/* 16 bit data */
id|cnt
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devc-&gt;channels
OG
l_int|1
)paren
id|cnt
op_rshift_assign
l_int|1
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|flags
op_amp
id|DMA_AUTOMODE
op_logical_and
id|intrflag
op_logical_and
id|cnt
op_eq
id|devc-&gt;xfer_count
)paren
(brace
id|devc-&gt;irq_mode
op_assign
id|IMODE_OUTPUT
suffix:semicolon
id|devc-&gt;intr_active
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Auto DMA mode on. No need to react&n;&t;&t;&t;&t; */
)brace
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_restart
)paren
(brace
id|ad1848_halt
(paren
id|dev
)paren
suffix:semicolon
id|DMAbuf_start_dma
(paren
id|dev
comma
id|buf
comma
id|count
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
)brace
id|ad_set_MCE
(paren
id|devc
comma
l_int|1
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|15
comma
(paren
r_int
r_char
)paren
(paren
id|cnt
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|14
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|cnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|9
comma
l_int|0x0d
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Playback enable, single DMA channel mode,&n;&t;&t;&t;&t; * auto calibration on.&n;&t;&t;&t;&t; */
id|ad_set_MCE
(paren
id|devc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Starts the calibration process and&n;&t;&t;&t;&t; * enters playback mode after it.&n;&t;&t;&t;&t; */
id|wait_for_calibration
(paren
id|devc
)paren
suffix:semicolon
id|devc-&gt;xfer_count
op_assign
id|cnt
suffix:semicolon
id|devc-&gt;irq_mode
op_assign
id|IMODE_OUTPUT
suffix:semicolon
id|devc-&gt;intr_active
op_assign
l_int|1
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad1848_start_input
id|ad1848_start_input
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
comma
r_int
id|dma_restart
)paren
(brace
r_int
r_int
id|flags
comma
id|cnt
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
multiline_comment|/* int             count_reg = (devc-&gt;mode == 1) ? 14 : 30; */
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;audio_format
op_eq
id|AFMT_IMA_ADPCM
)paren
(brace
id|cnt
op_div_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|devc-&gt;audio_format
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_S16_BE
)paren
)paren
multiline_comment|/* 16 bit data */
id|cnt
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devc-&gt;channels
OG
l_int|1
)paren
id|cnt
op_rshift_assign
l_int|1
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|flags
op_amp
id|DMA_AUTOMODE
op_logical_and
id|intrflag
op_logical_and
id|cnt
op_eq
id|devc-&gt;xfer_count
)paren
(brace
id|devc-&gt;irq_mode
op_assign
id|IMODE_INPUT
suffix:semicolon
id|devc-&gt;intr_active
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Auto DMA mode on. No need to react&n;&t;&t;&t;&t; */
)brace
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_restart
)paren
(brace
id|ad1848_halt
(paren
id|dev
)paren
suffix:semicolon
id|DMAbuf_start_dma
(paren
id|dev
comma
id|buf
comma
id|count
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
)brace
id|ad_set_MCE
(paren
id|devc
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
id|ad_write
(paren
id|devc
comma
id|count_reg
op_plus
l_int|1
comma
(paren
r_int
r_char
)paren
(paren
id|cnt
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
id|count_reg
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|cnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
macro_line|#else
id|ad_write
(paren
id|devc
comma
l_int|15
comma
(paren
r_int
r_char
)paren
(paren
id|cnt
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|14
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|cnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;mode
op_eq
l_int|2
)paren
(brace
id|ad_write
(paren
id|devc
comma
l_int|31
comma
(paren
r_int
r_char
)paren
(paren
id|cnt
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|32
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|cnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ad_write
(paren
id|devc
comma
l_int|9
comma
l_int|0x0e
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Capture enable, single DMA channel mode,&n;&t;&t;&t;&t; * auto calibration on.&n;&t;&t;&t;&t; */
id|ad_set_MCE
(paren
id|devc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Starts the calibration process and&n;&t;&t;&t;&t; * enters playback mode after it.&n;&t;&t;&t;&t; */
id|wait_for_calibration
(paren
id|devc
)paren
suffix:semicolon
id|devc-&gt;xfer_count
op_assign
id|cnt
suffix:semicolon
id|devc-&gt;irq_mode
op_assign
id|IMODE_INPUT
suffix:semicolon
id|devc-&gt;intr_active
op_assign
l_int|1
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ad1848_prepare_for_IO
id|ad1848_prepare_for_IO
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_int
id|timeout
suffix:semicolon
r_int
r_char
id|fs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|ad_set_MCE
(paren
id|devc
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Enables changes to the format select reg */
id|fs
op_assign
id|devc-&gt;speed_bits
op_or
(paren
id|devc-&gt;format_bits
op_lshift
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;channels
OG
l_int|1
)paren
id|fs
op_or_assign
l_int|0x10
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|8
comma
id|fs
)paren
suffix:semicolon
multiline_comment|/*&n;   * Write to I8 starts resynchronization. Wait until it completes.&n;   */
id|timeout
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
l_int|0
op_logical_and
id|INB
(paren
id|devc-&gt;base
)paren
op_eq
l_int|0x80
)paren
id|timeout
op_decrement
suffix:semicolon
id|ad_set_MCE
(paren
id|devc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Starts the calibration process and&n;&t;&t;&t;&t; * enters playback mode after it.&n;&t;&t;&t;&t; */
id|wait_for_calibration
(paren
id|devc
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * If mode == 2 (CS4231), set I28 also. It&squot;s the capture format register.&n; */
r_if
c_cond
(paren
id|devc-&gt;mode
op_eq
l_int|2
)paren
(brace
id|ad_set_MCE
(paren
id|devc
comma
l_int|1
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|28
comma
id|fs
)paren
suffix:semicolon
multiline_comment|/*&n;   * Write to I28 starts resynchronization. Wait until it completes.&n;   */
id|timeout
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
id|timeout
OG
l_int|0
op_logical_and
id|INB
(paren
id|devc-&gt;base
)paren
op_eq
l_int|0x80
)paren
id|timeout
op_decrement
suffix:semicolon
id|ad_set_MCE
(paren
id|devc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Starts the calibration process and&n;&t;&t;&t;&t; * enters playback mode after it.&n;&t;&t;&t;&t; */
id|wait_for_calibration
(paren
id|devc
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
id|devc-&gt;xfer_count
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad1848_reset
id|ad1848_reset
(paren
r_int
id|dev
)paren
(brace
id|ad1848_halt
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ad1848_halt
id|ad1848_halt
(paren
r_int
id|dev
)paren
(brace
id|ad1848_info
op_star
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|9
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear the PEN and CEN bits (among others) */
id|OUTB
(paren
l_int|0
comma
id|io_Status
(paren
id|devc
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt status */
)brace
r_int
DECL|function|ad1848_detect
id|ad1848_detect
(paren
r_int
id|io_base
)paren
(brace
DECL|macro|DDB
mdefine_line|#define DDB(x)&t;x
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
op_amp
id|dev_info
(braket
id|nr_ad1848_devs
)braket
suffix:semicolon
r_int
r_char
id|tmp1
op_assign
l_int|0xff
comma
id|tmp2
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|nr_ad1848_devs
op_ge
id|MAX_AUDIO_DEV
)paren
r_return
l_int|0
suffix:semicolon
id|devc-&gt;base
op_assign
id|io_base
suffix:semicolon
id|devc-&gt;MCE_bit
op_assign
l_int|0x40
suffix:semicolon
id|devc-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;dma_capture
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;dma_playback
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;opened
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;chip_name
op_assign
l_string|&quot;AD1848&quot;
suffix:semicolon
id|devc-&gt;mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* MODE1 = original AD1848 */
multiline_comment|/*&n; * Check that the I/O address is in use.&n; *&n; * The bit 0x80 of the base I/O port is known to be 0 after the&n; * chip has performed it&squot;s power on initialization. Just assume&n; * this has happened before the OS is starting.&n; *&n; * If the I/O address is unused, it typically returns 0xff.&n; */
r_if
c_cond
(paren
(paren
id|INB
(paren
id|devc-&gt;base
)paren
op_amp
l_int|0x80
)paren
op_ne
l_int|0x00
)paren
multiline_comment|/* Not a AD1884 */
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;ad_detect_A&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Test if it&squot;s possible to change contents of the indirect registers.&n; * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only&n; * so try to avoid using it.&n;*/
id|ad_write
(paren
id|devc
comma
l_int|0
comma
l_int|0xaa
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|1
comma
l_int|0x45
)paren
suffix:semicolon
multiline_comment|/* 0x55 with bit 0x10 clear */
r_if
c_cond
(paren
(paren
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
l_int|0
)paren
)paren
op_ne
l_int|0xaa
op_logical_or
(paren
id|tmp2
op_assign
id|ad_read
(paren
id|devc
comma
l_int|1
)paren
)paren
op_ne
l_int|0x45
)paren
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;ad_detect_B (%x/%x)&bslash;n&quot;
comma
id|tmp1
comma
id|tmp2
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ad_write
(paren
id|devc
comma
l_int|0
comma
l_int|0x45
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|1
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
l_int|0
)paren
)paren
op_ne
l_int|0x45
op_logical_or
(paren
id|tmp2
op_assign
id|ad_read
(paren
id|devc
comma
l_int|1
)paren
)paren
op_ne
l_int|0xaa
)paren
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;ad_detect_C (%x/%x)&bslash;n&quot;
comma
id|tmp1
comma
id|tmp2
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The indirect register I12 has some read only bits. Lets&n; * try to change them.&n; */
id|tmp
op_assign
id|ad_read
(paren
id|devc
comma
l_int|12
)paren
suffix:semicolon
id|ad_write
(paren
id|devc
comma
l_int|12
comma
(paren
op_complement
id|tmp
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x0f
)paren
op_ne
(paren
(paren
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
l_int|12
)paren
)paren
op_amp
l_int|0x0f
)paren
)paren
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;ad_detect_D (%x)&bslash;n&quot;
comma
id|tmp1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE! Last 4 bits of the reg I12 tell the chip revision.&n; *&t; 0x01=RevB and 0x0A=RevC.&n; */
multiline_comment|/*&n; * The original AD1848/CS4248 has just 15 indirect registers. This means&n; * that I0 and I16 should return the same value (etc.).&n; * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails&n; * with CS4231.&n; */
id|ad_write
(paren
id|devc
comma
l_int|12
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Mode2=disabled */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
id|i
)paren
)paren
op_ne
(paren
id|tmp2
op_assign
id|ad_read
(paren
id|devc
comma
id|i
op_plus
l_int|16
)paren
)paren
)paren
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;ad_detect_F(%d/%x/%x)&bslash;n&quot;
comma
id|i
comma
id|tmp1
comma
id|tmp2
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit (0x40).&n; * The bit 0x80 is always 1 in CS4248 and CS4231.&n; */
id|ad_write
(paren
id|devc
comma
l_int|12
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Set mode2, clear 0x80 */
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_amp
l_int|0x80
)paren
id|devc-&gt;chip_name
op_assign
l_string|&quot;CS4248&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_amp
l_int|0xc0
)paren
op_eq
(paren
l_int|0x80
op_or
l_int|0x40
)paren
)paren
(brace
multiline_comment|/*&n;&t; *&t;CS4231 detected - is it?&n;&t; *&n;&t; *&t;Verify that setting I0 doesn&squot;t change I16.&n;&t; */
id|ad_write
(paren
id|devc
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set I16 to known value */
id|ad_write
(paren
id|devc
comma
l_int|0
comma
l_int|0x45
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
l_int|16
)paren
)paren
op_ne
l_int|0x45
)paren
multiline_comment|/* No change -&gt; CS4231? */
(brace
id|ad_write
(paren
id|devc
comma
l_int|0
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_assign
id|ad_read
(paren
id|devc
comma
l_int|16
)paren
)paren
op_eq
l_int|0xaa
)paren
multiline_comment|/* Rotten bits? */
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;ad_detect_H(%x)&bslash;n&quot;
comma
id|tmp1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;It&squot;s a CS4231 - So what!&n;&t; *&t;(Mode2 will be supported later)&n;&t; */
id|devc-&gt;chip_name
op_assign
l_string|&quot;CS4231&quot;
suffix:semicolon
id|devc-&gt;mode
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|ad1848_init
id|ad1848_init
(paren
r_char
op_star
id|name
comma
r_int
id|io_base
comma
r_int
id|irq
comma
r_int
id|dma_playback
comma
r_int
id|dma_capture
)paren
(brace
multiline_comment|/*&n; * NOTE! If irq &lt; 0, there is another driver which has allocated the IRQ&n; *&t; so that this driver doesn&squot;t need to allocate/deallocate it.&n; *&t; The actually used IRQ is ABS(irq).&n; */
multiline_comment|/*&n; * Initial values for the indirect registers of CS4248/AD1848.&n; */
r_static
r_int
id|init_values
(braket
)braket
op_assign
(brace
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x08
comma
l_int|0x02
comma
l_int|0x00
comma
l_int|0xca
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|i
comma
id|my_dev
suffix:semicolon
id|ad1848_info
op_star
id|devc
op_assign
op_amp
id|dev_info
(braket
id|nr_ad1848_devs
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ad1848_detect
(paren
id|io_base
)paren
)paren
r_return
suffix:semicolon
id|devc-&gt;irq
op_assign
(paren
id|irq
OG
l_int|0
)paren
ques
c_cond
id|irq
suffix:colon
l_int|0
suffix:semicolon
id|devc-&gt;dma_capture
op_assign
id|dma_playback
suffix:semicolon
id|devc-&gt;dma_playback
op_assign
id|dma_capture
suffix:semicolon
id|devc-&gt;opened
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_ad1848_devs
op_ne
l_int|0
)paren
(brace
id|memcpy
(paren
(paren
r_char
op_star
)paren
op_amp
id|ad1848_pcm_operations
(braket
id|nr_ad1848_devs
)braket
comma
(paren
r_char
op_star
)paren
op_amp
id|ad1848_pcm_operations
(braket
l_int|0
)braket
comma
r_sizeof
(paren
r_struct
id|audio_operations
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|ad_write
(paren
id|devc
comma
id|i
comma
id|init_values
(braket
id|i
)braket
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0
comma
id|io_Status
(paren
id|devc
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear pending interrupts */
macro_line|#ifndef SCO
id|sprintf
(paren
id|ad1848_pcm_operations
(braket
id|nr_ad1848_devs
)braket
dot
id|name
comma
l_string|&quot;%s (%s)&quot;
comma
id|name
comma
id|devc-&gt;chip_name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|irq
OG
l_int|0
)paren
id|printk
(paren
l_string|&quot; &lt;%s&gt;&quot;
comma
id|ad1848_pcm_operations
(braket
id|nr_ad1848_devs
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_audiodevs
OL
id|MAX_AUDIO_DEV
)paren
(brace
id|audio_devs
(braket
id|my_dev
op_assign
id|num_audiodevs
op_increment
)braket
op_assign
op_amp
id|ad1848_pcm_operations
(braket
id|nr_ad1848_devs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
l_int|0
)paren
id|irq2dev
(braket
id|irq
)braket
op_assign
id|my_dev
suffix:semicolon
r_else
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
id|irq2dev
(braket
op_minus
id|irq
)braket
op_assign
id|my_dev
suffix:semicolon
id|audio_devs
(braket
id|my_dev
)braket
op_member_access_from_pointer
id|dmachan
op_assign
id|dma_playback
suffix:semicolon
id|audio_devs
(braket
id|my_dev
)braket
op_member_access_from_pointer
id|buffcount
op_assign
l_int|1
suffix:semicolon
id|audio_devs
(braket
id|my_dev
)braket
op_member_access_from_pointer
id|buffsize
op_assign
id|DSP_BUFFSIZE
op_star
l_int|2
suffix:semicolon
id|audio_devs
(braket
id|my_dev
)braket
op_member_access_from_pointer
id|devc
op_assign
id|devc
suffix:semicolon
id|audio_devs
(braket
id|my_dev
)braket
op_member_access_from_pointer
id|format_mask
op_assign
id|ad_format_mask
(braket
id|devc-&gt;mode
)braket
suffix:semicolon
id|nr_ad1848_devs
op_increment
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;AD1848: Too many PCM devices available&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|ad1848_interrupt
id|ad1848_interrupt
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|ad1848_info
op_star
id|devc
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|irq
template_param
l_int|15
)paren
r_return
suffix:semicolon
multiline_comment|/* Bogus irq */
id|dev
op_assign
id|irq2dev
(braket
id|irq
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
l_int|0
op_logical_or
id|dev
op_ge
id|num_audiodevs
)paren
r_return
suffix:semicolon
multiline_comment|/* Bogus dev */
id|devc
op_assign
(paren
id|ad1848_info
op_star
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|status
op_assign
id|INB
(paren
id|io_Status
(paren
id|devc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|devc-&gt;opened
op_logical_and
id|devc-&gt;irq_mode
op_eq
id|IMODE_OUTPUT
)paren
(brace
id|DMAbuf_outputintr
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devc-&gt;opened
op_logical_and
id|devc-&gt;irq_mode
op_eq
id|IMODE_INPUT
)paren
id|DMAbuf_inputintr
(paren
id|dev
)paren
suffix:semicolon
)brace
id|OUTB
(paren
l_int|0
comma
id|io_Status
(paren
id|devc
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt status */
)brace
macro_line|#endif
multiline_comment|/*&n; * Some extra code for the MS Sound System&n; */
macro_line|#if defined(CONFIGURE_SOUNDCARD) &amp;&amp; !defined(EXCLUDE_MSS)
r_int
DECL|function|probe_ms_sound
id|probe_ms_sound
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_if
c_cond
(paren
(paren
id|INB
(paren
id|hw_config-&gt;io_base
op_plus
l_int|3
)paren
op_amp
l_int|0x04
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* WSS ID test failed */
r_if
c_cond
(paren
id|hw_config-&gt;irq
OG
l_int|11
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hw_config-&gt;dma
op_ne
l_int|0
op_logical_and
id|hw_config-&gt;dma
op_ne
l_int|1
op_logical_and
id|hw_config-&gt;dma
op_ne
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ad1848_detect
(paren
id|hw_config-&gt;io_base
op_plus
l_int|4
)paren
suffix:semicolon
)brace
r_int
DECL|function|attach_ms_sound
id|attach_ms_sound
(paren
r_int
id|mem_start
comma
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_static
r_int
r_char
id|interrupt_bits
(braket
l_int|12
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0x08
comma
op_minus
l_int|1
comma
l_int|0x10
comma
l_int|0x18
comma
l_int|0x20
)brace
suffix:semicolon
r_char
id|bits
suffix:semicolon
r_static
r_int
r_char
id|dma_bits
(braket
l_int|4
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|3
)brace
suffix:semicolon
r_int
id|config_port
op_assign
id|hw_config-&gt;io_base
op_plus
l_int|0
comma
id|version_port
op_assign
id|hw_config-&gt;io_base
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ad1848_detect
(paren
id|hw_config-&gt;io_base
op_plus
l_int|4
)paren
)paren
r_return
id|mem_start
suffix:semicolon
multiline_comment|/*&n; * Set the IRQ and DMA addresses.&n; */
id|bits
op_assign
id|interrupt_bits
(braket
id|hw_config-&gt;irq
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_eq
op_minus
l_int|1
)paren
r_return
id|mem_start
suffix:semicolon
id|OUTB
(paren
id|bits
op_or
l_int|0x40
comma
id|config_port
)paren
suffix:semicolon
multiline_comment|/* Verify IRQ (I guess) */
r_if
c_cond
(paren
(paren
id|INB
(paren
id|version_port
)paren
op_amp
l_int|0x40
)paren
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;[IRQ?]&quot;
)paren
suffix:semicolon
id|OUTB
(paren
id|bits
op_or
id|dma_bits
(braket
id|hw_config-&gt;dma
)braket
comma
id|config_port
)paren
suffix:semicolon
multiline_comment|/* Write IRQ+DMA setup */
id|ad1848_init
(paren
l_string|&quot;MS Sound System&quot;
comma
id|hw_config-&gt;io_base
op_plus
l_int|4
comma
id|hw_config-&gt;irq
comma
id|hw_config-&gt;dma
comma
id|hw_config-&gt;dma
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
macro_line|#endif
eof
