multiline_comment|/*  -*- linux-c -*-&n; *&n; * sound/wavfront.c&n; *&n; * A Linux driver for Turtle Beach WaveFront Series (Maui, Tropez, Tropez Plus)&n; *&n; * This driver supports the onboard wavetable synthesizer (an ICS2115),&n; * including patch, sample and program loading and unloading, conversion&n; * of GUS patches during loading, and full user-level access to all&n; * WaveFront commands. It tries to provide semi-intelligent patch and&n; * sample management as well.&n; *&n; * It also provides support for the ICS emulation of an MPU-401.  Full&n; * support for the ICS emulation&squot;s &quot;virtual MIDI mode&quot; is provided in&n; * wf_midi.c.&n; *&n; * Support is also provided for the Tropez Plus&squot; onboard FX processor,&n; * a Yamaha YSS225. Currently, code exists to configure the YSS225,&n; * and there is an interface allowing tweaking of any of its memory&n; * addresses. However, I have been unable to decipher the logical&n; * positioning of the configuration info for various effects, so for&n; * now, you just get the YSS225 in the same state as Turtle Beach&squot;s&n; * &quot;SETUPSND.EXE&quot; utility leaves it.&n; *&n; * The boards&squot; CODEC (a Crystal CS4232) is supported by cs4232.[co],&n; * This chip also controls the configuration of the card: the wavefront&n; * synth is logical unit 4.&n; *&n; **********************************************************************&n; *&n; * Copyright (C) by Paul Barton-Davis 1998&n; *&n; * Some portions of this file are taken from work that is&n; * copyright (C) by Hannu Savolainen 1993-1996&n; *&n; * Although the relevant code here is all new, the handling of&n; * sample/alias/multi- samples is entirely based on a driver by Matt&n; * Martin and Rutger Nijlunsing which demonstrated how to get things&n; * to most aspects of this to work correctly. The GUS patch loading&n; * code has been almost unaltered by me, except to fit formatting and&n; * function names in the rest of the file. Many thanks to them.&n; *&n; * Appreciation and thanks to Hannu Savolainen for his early work on the Maui&n; * driver, and answering a few questions while this one was developed.&n; *&n; * Absolutely NO thanks to Turtle Beach/Voyetra and Yamaha for their&n; * complete lack of help in developing this driver, and in particular&n; * for their utter silence in response to questions about undocumented&n; * aspects of configuring a WaveFront soundcard, particularly the&n; * effects processor.&n; *&n; * $Id: wavfront.c,v 0.4 1998/07/22 02:12:11 pbd Exp $&n; *&n; * This program is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)&n; * Version 2 (June 1991). See the &quot;COPYING&quot; file distributed with this software&n; * for more info.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/init.h&gt;
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &quot;soundmodule.h&quot;
macro_line|#include &lt;linux/wavefront.h&gt;
DECL|macro|MIDI_SYNTH_NAME
mdefine_line|#define MIDI_SYNTH_NAME&t;&quot;WaveFront MIDI&quot;
DECL|macro|MIDI_SYNTH_CAPS
mdefine_line|#define MIDI_SYNTH_CAPS&t;SYNTH_CAP_INPUT
macro_line|#include &quot;midi_synth.h&quot;
multiline_comment|/* This thing is meant to work as a module */
macro_line|#if defined(CONFIG_SOUND_WAVEFRONT_MODULE) &amp;&amp; defined(MODULE)
multiline_comment|/* if WF_DEBUG not defined, no run-time debugging messages will&n;   be available via the debug flag setting. Given the current&n;   beta state of the driver, this will remain set until a future &n;   version.&n;*/
DECL|macro|WF_DEBUG
mdefine_line|#define WF_DEBUG 1
multiline_comment|/* bitmasks for WaveFront status port value */
DECL|macro|STAT_INTR_WRITE
mdefine_line|#define STAT_INTR_WRITE&t;&t;0x40
DECL|macro|STAT_CAN_WRITE
mdefine_line|#define STAT_CAN_WRITE&t;&t;0x20
DECL|macro|STAT_WINTR_ENABLED
mdefine_line|#define STAT_WINTR_ENABLED&t;0x10
DECL|macro|STAT_INTR_READ
mdefine_line|#define STAT_INTR_READ&t;&t;0x04
DECL|macro|STAT_CAN_READ
mdefine_line|#define STAT_CAN_READ&t;&t;0x02
DECL|macro|STAT_RINTR_ENABLED
mdefine_line|#define STAT_RINTR_ENABLED&t;0x01
multiline_comment|/*** Module-accessible parameters ***************************************/
DECL|variable|wf_raw
r_int
id|wf_raw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we normally check for &quot;raw state&quot; to firmware&n;&t;&t;   loading. if set, then during driver loading, the&n;&t;&t;   state of the board is ignored, and we reset the&n;&t;&t;   board and load the firmware anyway.&n;&t;&t;*/
DECL|variable|fx_raw
r_int
id|fx_raw
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if this is zero, we&squot;ll leave the FX processor in&n;&t;&t;   whatever state it is when the driver is loaded.&n;&t;&t;   The default is to download the microprogram and&n;&t;&t;   associated coefficients to set it up for &quot;default&quot;&n;&t;&t;   operation, whatever that means.&n;&t;&t;*/
DECL|variable|debug_default
r_int
id|debug_default
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* you can set this to control debugging&n;&t;&t;&t;      during driver loading. it takes any combination&n;&t;&t;&t;      of the WF_DEBUG_* flags defined in&n;&t;&t;&t;      wavefront.h&n;&t;&t;&t;   */
multiline_comment|/* XXX this needs to be made firmware and hardware version dependent */
DECL|variable|ospath
r_char
op_star
id|ospath
op_assign
l_string|&quot;/etc/sound/wavefront.os&quot;
suffix:semicolon
multiline_comment|/* where to find a processed&n;&t;&t;&t;&t;&t;     version of the WaveFront OS&n;&t;&t;&t;&t;&t;  */
DECL|variable|sleep_interval
r_int
id|sleep_interval
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* HZ/sleep_interval seconds per sleep */
DECL|variable|sleep_tries
r_int
id|sleep_tries
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* number of times we&squot;ll try to sleep */
DECL|variable|wait_usecs
r_int
id|wait_usecs
op_assign
l_int|150
suffix:semicolon
multiline_comment|/* This magic number seems to give pretty optimal&n;&t;&t;&t; throughput based on my limited experimentation.&n;&t;&t;&t; If you want to play around with it and find a better&n;&t;&t;&t; value, be my guest. Remember, the idea is to&n;&t;&t;&t; get a number that causes us to just busy wait&n;&t;&t;&t; for as many WaveFront commands as possible, without&n;&t;&t;&t; coming up with a number so large that we hog the&n;&t;&t;&t; whole CPU.&n;&n;&t;&t;&t; Specifically, with this number, out of about 134,000&n;&t;&t;&t; status waits, only about 250 result in a sleep.&n;&t;&t;      */
id|MODULE_PARM
c_func
(paren
id|wf_raw
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|fx_raw
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug_default
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sleep_interval
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sleep_tries
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|wait_usecs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ospath
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
multiline_comment|/***************************************************************************/
DECL|variable|wavefront_info
r_static
r_struct
id|synth_info
id|wavefront_info
op_assign
(brace
l_string|&quot;Turtle Beach WaveFront&quot;
comma
l_int|0
comma
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_WAVEFRONT
comma
l_int|0
comma
l_int|32
comma
l_int|0
comma
l_int|0
comma
id|SYNTH_CAP_INPUT
)brace
suffix:semicolon
DECL|variable|midi_load_patch
r_static
r_int
(paren
op_star
id|midi_load_patch
)paren
(paren
r_int
id|dev
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|struct|wf_config
r_typedef
r_struct
id|wf_config
(brace
DECL|member|devno
r_int
id|devno
suffix:semicolon
multiline_comment|/* device number from kernel */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* &quot;you were one, one of the few ...&quot; */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* low i/o port address */
DECL|macro|mpu_data_port
mdefine_line|#define mpu_data_port    base 
DECL|macro|mpu_command_port
mdefine_line|#define mpu_command_port base + 1 /* write semantics */
DECL|macro|mpu_status_port
mdefine_line|#define mpu_status_port  base + 1 /* read semantics */
DECL|macro|data_port
mdefine_line|#define data_port        base + 2 
DECL|macro|status_port
mdefine_line|#define status_port      base + 3 /* read semantics */
DECL|macro|control_port
mdefine_line|#define control_port     base + 3 /* write semantics  */
DECL|macro|block_port
mdefine_line|#define block_port       base + 4 /* 16 bit, writeonly */
DECL|macro|last_block_port
mdefine_line|#define last_block_port  base + 6 /* 16 bit, writeonly */
multiline_comment|/* FX ports. These are mapped through the ICS2115 to the YS225.&n;&t;   The ICS2115 takes care of flipping the relevant pins on the&n;&t;   YS225 so that access to each of these ports does the right&n;&t;   thing. Note: these are NOT documented by Turtle Beach.&n;&t;*/
DECL|macro|fx_status
mdefine_line|#define fx_status       base + 8 
DECL|macro|fx_op
mdefine_line|#define fx_op           base + 8 
DECL|macro|fx_lcr
mdefine_line|#define fx_lcr          base + 9 
DECL|macro|fx_dsp_addr
mdefine_line|#define fx_dsp_addr     base + 0xa
DECL|macro|fx_dsp_page
mdefine_line|#define fx_dsp_page     base + 0xb 
DECL|macro|fx_dsp_lsb
mdefine_line|#define fx_dsp_lsb      base + 0xc 
DECL|macro|fx_dsp_msb
mdefine_line|#define fx_dsp_msb      base + 0xd 
DECL|macro|fx_mod_addr
mdefine_line|#define fx_mod_addr     base + 0xe
DECL|macro|fx_mod_data
mdefine_line|#define fx_mod_data     base + 0xf 
DECL|member|irq_ok
r_volatile
r_int
id|irq_ok
suffix:semicolon
multiline_comment|/* set by interrupt handler */
DECL|member|opened
r_int
id|opened
suffix:semicolon
multiline_comment|/* flag, holds open(1) mode */
DECL|member|debug
r_char
id|debug
suffix:semicolon
multiline_comment|/* debugging flags */
DECL|member|freemem
r_int
id|freemem
suffix:semicolon
multiline_comment|/* installed RAM, in bytes */
DECL|member|synthdev
r_int
id|synthdev
suffix:semicolon
multiline_comment|/* OSS minor devnum for synth */
DECL|member|mididev
r_int
id|mididev
suffix:semicolon
multiline_comment|/* OSS minor devno for internal MIDI */
DECL|member|ext_mididev
r_int
id|ext_mididev
suffix:semicolon
multiline_comment|/* OSS minor devno for external MIDI */
DECL|member|fw_version
r_char
id|fw_version
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* major = [0], minor = [1] */
DECL|member|hw_version
r_char
id|hw_version
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* major = [0], minor = [1] */
DECL|member|israw
r_char
id|israw
suffix:semicolon
multiline_comment|/* needs Motorola microcode */
DECL|member|prog_status
r_char
id|prog_status
(braket
id|WF_MAX_PROGRAM
)braket
suffix:semicolon
multiline_comment|/* WF_SLOT_* */
DECL|member|patch_status
r_char
id|patch_status
(braket
id|WF_MAX_PATCH
)braket
suffix:semicolon
multiline_comment|/* WF_SLOT_* */
DECL|member|sample_status
r_char
id|sample_status
(braket
id|WF_MAX_SAMPLE
)braket
suffix:semicolon
multiline_comment|/* WF_ST_* | WF_SLOT_* */
DECL|member|samples_used
r_int
id|samples_used
suffix:semicolon
multiline_comment|/* how many */
DECL|member|interrupts_on
r_char
id|interrupts_on
suffix:semicolon
multiline_comment|/* h/w MPU interrupts enabled ? */
DECL|member|rom_samples_rdonly
r_char
id|rom_samples_rdonly
suffix:semicolon
multiline_comment|/* can we write on ROM samples */
DECL|member|interrupt_sleeper
r_struct
id|wait_queue
op_star
id|interrupt_sleeper
suffix:semicolon
macro_line|#ifdef  WF_STATS
DECL|member|status_found_during_loop
r_int
r_int
id|status_found_during_loop
suffix:semicolon
DECL|member|status_found_during_sleep
r_int
r_int
id|status_found_during_sleep
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif  WF_STATS
DECL|typedef|wf_config
)brace
id|wf_config
suffix:semicolon
multiline_comment|/* Note: because this module doesn&squot;t export any symbols, this really isn&squot;t&n;   a global variable, even if it looks like one. I was quite confused by&n;   this when I started writing this as a (newer) module -- pbd.&n;*/
DECL|variable|wavefront_configuration
r_static
id|wf_config
id|wavefront_configuration
suffix:semicolon
DECL|macro|wavefront_status
mdefine_line|#define wavefront_status(hw) (inb (hw-&gt;status_port))
multiline_comment|/* forward references */
r_static
r_int
id|wffx_ioctl
(paren
r_struct
id|wf_config
op_star
comma
id|wavefront_fx_info
op_star
)paren
suffix:semicolon
r_static
r_int
id|wffx_init
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|wavefront_delete_sample
(paren
r_struct
id|wf_config
op_star
id|hw
comma
r_int
id|sampnum
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|cmd
r_int
id|cmd
suffix:semicolon
DECL|member|action
r_char
op_star
id|action
suffix:semicolon
DECL|member|read_cnt
r_int
r_int
id|read_cnt
suffix:semicolon
DECL|member|write_cnt
r_int
r_int
id|write_cnt
suffix:semicolon
DECL|member|need_ack
r_int
id|need_ack
suffix:semicolon
DECL|typedef|wavefront_command
)brace
id|wavefront_command
suffix:semicolon
r_static
r_struct
(brace
DECL|member|errno
r_int
id|errno
suffix:semicolon
DECL|member|errstr
r_const
r_char
op_star
id|errstr
suffix:semicolon
DECL|variable|wavefront_errors
)brace
id|wavefront_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x01
comma
l_string|&quot;Bad sample number&quot;
)brace
comma
(brace
l_int|0x02
comma
l_string|&quot;Out of sample memory&quot;
)brace
comma
(brace
l_int|0x03
comma
l_string|&quot;Bad patch number&quot;
)brace
comma
(brace
l_int|0x04
comma
l_string|&quot;Error in number of voices&quot;
)brace
comma
(brace
l_int|0x06
comma
l_string|&quot;Sample load already in progress&quot;
)brace
comma
(brace
l_int|0x0B
comma
l_string|&quot;No sample load request pending&quot;
)brace
comma
(brace
l_int|0x0E
comma
l_string|&quot;Bad MIDI channel number&quot;
)brace
comma
(brace
l_int|0x10
comma
l_string|&quot;Download Record Error&quot;
)brace
comma
(brace
l_int|0x80
comma
l_string|&quot;Success&quot;
)brace
comma
(brace
l_int|0x0
comma
l_int|0x0
)brace
)brace
suffix:semicolon
DECL|macro|NEEDS_ACK
mdefine_line|#define NEEDS_ACK 1
DECL|variable|wavefront_commands
r_static
id|wavefront_command
id|wavefront_commands
(braket
)braket
op_assign
(brace
(brace
id|WFC_SET_SYNTHVOL
comma
l_string|&quot;set synthesizer volume&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_SYNTHVOL
comma
l_string|&quot;get synthesizer volume&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_NVOICES
comma
l_string|&quot;set number of voices&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_NVOICES
comma
l_string|&quot;get number of voices&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_TUNING
comma
l_string|&quot;set synthesizer tuning&quot;
comma
l_int|0
comma
l_int|2
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_TUNING
comma
l_string|&quot;get synthesizer tuning&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DISABLE_CHANNEL
comma
l_string|&quot;disable synth channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_ENABLE_CHANNEL
comma
l_string|&quot;enable synth channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_CHANNEL_STATUS
comma
l_string|&quot;get synth channel status&quot;
comma
l_int|3
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_MISYNTH_OFF
comma
l_string|&quot;disable midi-in to synth&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_MISYNTH_ON
comma
l_string|&quot;enable midi-in to synth&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_VMIDI_ON
comma
l_string|&quot;enable virtual midi mode&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_VMIDI_OFF
comma
l_string|&quot;disable virtual midi mode&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_MIDI_STATUS
comma
l_string|&quot;report midi status&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_FIRMWARE_VERSION
comma
l_string|&quot;report firmware version&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_HARDWARE_VERSION
comma
l_string|&quot;report hardware version&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_GET_NSAMPLES
comma
l_string|&quot;report number of samples&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_INSTOUT_LEVELS
comma
l_string|&quot;report instantaneous output levels&quot;
comma
l_int|7
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_PEAKOUT_LEVELS
comma
l_string|&quot;report peak output levels&quot;
comma
l_int|7
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE
comma
l_string|&quot;download sample&quot;
comma
l_int|0
comma
id|WF_SAMPLE_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DOWNLOAD_BLOCK
comma
l_string|&quot;download block&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE_HEADER
comma
l_string|&quot;download sample header&quot;
comma
l_int|0
comma
id|WF_SAMPLE_HDR_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_HEADER
comma
l_string|&quot;upload sample header&quot;
comma
l_int|13
comma
l_int|2
comma
l_int|0
)brace
comma
multiline_comment|/* This command requires a variable number of bytes to be written.&n;&t;   There is a hack in wavefront_cmd() to support this. The actual&n;&t;   count is passed in as the read buffer ptr, cast appropriately.&n;&t;   Ugh.&n;&t;*/
(brace
id|WFC_DOWNLOAD_MULTISAMPLE
comma
l_string|&quot;download multisample&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
multiline_comment|/* This one is a hack as well. We just read the first byte of the&n;&t;   response, don&squot;t fetch an ACK, and leave the rest to the &n;&t;   calling function. Ugly, ugly, ugly.&n;&t;*/
(brace
id|WFC_UPLOAD_MULTISAMPLE
comma
l_string|&quot;upload multisample&quot;
comma
l_int|2
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE_ALIAS
comma
l_string|&quot;download sample alias&quot;
comma
l_int|0
comma
id|WF_ALIAS_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_ALIAS
comma
l_string|&quot;upload sample alias&quot;
comma
id|WF_ALIAS_BYTES
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_DELETE_SAMPLE
comma
l_string|&quot;delete sample&quot;
comma
l_int|0
comma
l_int|2
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_IDENTIFY_SAMPLE_TYPE
comma
l_string|&quot;identify sample type&quot;
comma
l_int|5
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_PARAMS
comma
l_string|&quot;upload sample parameters&quot;
)brace
comma
(brace
id|WFC_REPORT_FREE_MEMORY
comma
l_string|&quot;report free memory&quot;
comma
l_int|4
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_PATCH
comma
l_string|&quot;download patch&quot;
comma
l_int|0
comma
l_int|134
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_PATCH
comma
l_string|&quot;upload patch&quot;
comma
l_int|132
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_PROGRAM
comma
l_string|&quot;download program&quot;
comma
l_int|0
comma
l_int|33
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_PROGRAM
comma
l_string|&quot;upload program&quot;
comma
l_int|32
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_EDRUM_PROGRAM
comma
l_string|&quot;download enhanced drum program&quot;
comma
l_int|0
comma
l_int|9
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_EDRUM_PROGRAM
comma
l_string|&quot;upload enhanced drum program&quot;
comma
l_int|8
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_EDRUM_CHANNEL
comma
l_string|&quot;set enhanced drum program channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DISABLE_DRUM_PROGRAM
comma
l_string|&quot;disable drum program&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_REPORT_CHANNEL_PROGRAMS
comma
l_string|&quot;report channel program numbers&quot;
comma
l_int|32
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_NOOP
comma
l_string|&quot;the no-op command&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
l_int|0x00
)brace
)brace
suffix:semicolon
r_static
r_const
r_char
op_star
DECL|function|wavefront_errorstr
id|wavefront_errorstr
(paren
r_int
id|errnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|wavefront_errors
(braket
id|i
)braket
dot
id|errstr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_errors
(braket
id|i
)braket
dot
id|errno
op_eq
id|errnum
)paren
(brace
r_return
id|wavefront_errors
(braket
id|i
)braket
dot
id|errstr
suffix:semicolon
)brace
)brace
r_return
l_string|&quot;Unknown WaveFront error&quot;
suffix:semicolon
)brace
r_static
id|wavefront_command
op_star
DECL|function|wavefront_get_command
id|wavefront_get_command
(paren
r_int
id|cmd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|wavefront_commands
(braket
id|i
)braket
dot
id|cmd
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|wavefront_commands
(braket
id|i
)braket
dot
id|cmd
)paren
(brace
r_return
op_amp
id|wavefront_commands
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_return
(paren
id|wavefront_command
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_sleep
id|wavefront_sleep
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|limit
)paren
(brace
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|limit
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
r_return
id|signal_pending
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_wait
id|wavefront_wait
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_int
id|short_loop_cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|short_loop_cnt
op_eq
l_int|0
)paren
(brace
id|short_loop_cnt
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
r_float
)paren
id|wait_usecs
op_div
l_float|1000000.0
)paren
op_star
(paren
r_float
)paren
id|current_cpu_data.loops_per_sec
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|short_loop_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_status
c_func
(paren
id|hw
)paren
op_amp
id|mask
)paren
(brace
macro_line|#ifdef WF_STATS
id|hw-&gt;status_found_during_loop
op_increment
suffix:semicolon
macro_line|#endif WF_STATS
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sleep_tries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_status
c_func
(paren
id|hw
)paren
op_amp
id|mask
)paren
(brace
macro_line|#ifdef WF_STATS
r_if
c_cond
(paren
id|i
OL
l_int|4
)paren
(brace
id|hw-&gt;status_found_during_sleep
(braket
id|i
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif WF_STATS
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_sleep
(paren
id|hw
comma
id|HZ
op_div
id|sleep_interval
)paren
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_read
id|wavefront_read
(paren
id|wf_config
op_star
id|hw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|hw
comma
id|STAT_CAN_READ
)paren
)paren
r_return
id|inb
(paren
id|hw-&gt;data_port
)paren
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: read timeout.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_write
id|wavefront_write
(paren
id|wf_config
op_star
id|hw
comma
r_int
r_char
id|data
)paren
(brace
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|hw
comma
id|STAT_CAN_WRITE
)paren
)paren
(brace
id|outb
(paren
id|data
comma
id|hw-&gt;data_port
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: write timeout.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_cmd
id|wavefront_cmd
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|cmd
comma
r_int
r_char
op_star
id|rbuf
comma
r_int
r_char
op_star
id|wbuf
)paren
(brace
r_int
id|ack
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|c
suffix:semicolon
id|wavefront_command
op_star
id|wfcmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wfcmd
op_assign
id|wavefront_get_command
(paren
id|cmd
)paren
)paren
op_eq
(paren
id|wavefront_command
op_star
)paren
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: command 0x%x not supported.&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Hack to handle the one variable-size write command. See&n;&t;   wavefront_send_multisample() for the other half of this&n;&t;   gross and ugly strategy.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_eq
id|WFC_DOWNLOAD_MULTISAMPLE
)paren
(brace
id|wfcmd-&gt;write_cnt
op_assign
(paren
r_int
r_int
)paren
id|rbuf
suffix:semicolon
id|rbuf
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_CMD
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Wavefront: 0x%x [%s] (%d,%d,%d)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|wfcmd-&gt;read_cnt
comma
id|wfcmd-&gt;write_cnt
comma
id|wfcmd-&gt;need_ack
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_if
c_cond
(paren
op_logical_neg
id|wavefront_write
(paren
id|hw
comma
id|cmd
)paren
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
(paren
id|WF_DEBUG_IO
op_or
id|WF_DEBUG_CMD
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: cannot request &quot;
l_string|&quot;0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wfcmd-&gt;write_cnt
OG
l_int|0
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: writing %d bytes &quot;
l_string|&quot;for 0x%x&bslash;n&quot;
comma
id|wfcmd-&gt;write_cnt
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wfcmd-&gt;write_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wavefront_write
(paren
id|hw
comma
id|wbuf
(braket
id|i
)braket
)paren
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: bad write for byte %d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: write[%d] = 0x%x&bslash;n&quot;
comma
id|i
comma
id|wbuf
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif WF_DEBUG
)brace
)brace
)brace
r_if
c_cond
(paren
id|wfcmd-&gt;read_cnt
OG
l_int|0
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: reading %d ints &quot;
l_string|&quot;for 0x%x&bslash;n&quot;
comma
id|wfcmd-&gt;read_cnt
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wfcmd-&gt;read_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|wavefront_read
c_func
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: bad read for byte %d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now handle errors. Lots of special cases here */
r_if
c_cond
(paren
id|c
op_eq
l_int|0xff
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: bad read for error byte at &quot;
l_string|&quot;read byte %d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Can you believe this madness ? */
r_if
c_cond
(paren
id|c
op_eq
l_int|1
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_IDENTIFY_SAMPLE_TYPE
)paren
(brace
id|rbuf
(braket
l_int|0
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|3
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_UPLOAD_PATCH
)paren
(brace
r_return
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|1
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_UPLOAD_PROGRAM
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: error %d (%s) during &quot;
l_string|&quot;read for byte &quot;
l_string|&quot;%d of 0x%x [%s].&bslash;n&quot;
comma
id|c
comma
id|wavefront_errorstr
(paren
id|c
)paren
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|rbuf
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: read[%d] = 0x%x&bslash;n&quot;
comma
id|i
comma
id|rbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
)brace
)brace
r_if
c_cond
(paren
(paren
id|wfcmd-&gt;read_cnt
op_eq
l_int|0
op_logical_and
id|wfcmd-&gt;write_cnt
op_eq
l_int|0
)paren
op_logical_or
id|wfcmd-&gt;need_ack
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_CMD
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: reading ACK for 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
multiline_comment|/* Some commands need an ACK, but return zero instead&n;&t;&t;   of the standard value.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|ack
op_assign
id|wavefront_read
c_func
(paren
id|hw
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ack
op_assign
id|WF_ACK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ack
op_ne
id|WF_ACK
)paren
(brace
r_if
c_cond
(paren
id|ack
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: cannot read ack for 0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* something unknown */
r_if
c_cond
(paren
id|ack
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* explicit error */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: cannot read err for 0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
)brace
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: 0x%x [%s] &quot;
l_string|&quot;failed (0x%x, 0x%x, %s)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|ack
comma
id|err
comma
id|wavefront_errorstr
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
op_minus
id|err
suffix:semicolon
)brace
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: ack received &quot;
l_string|&quot;for 0x%x [%s]&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
)brace
r_else
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_CMD
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Wavefront: 0x%x [%s] does not need &quot;
l_string|&quot;ACK (%d,%d,%d)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|wfcmd-&gt;read_cnt
comma
id|wfcmd-&gt;write_cnt
comma
id|wfcmd-&gt;need_ack
)paren
suffix:semicolon
macro_line|#endif WF_DEBUG
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: data munging   &n;&n;Things here are weird.  All data written to the board cannot &n;have its most significant bit set.  Any data item with values &n;potentially &gt; 0x7F (127) must be split across multiple bytes.&n;&n;Sometimes, we need to munge numeric values that are represented on&n;the x86 side as 8- to 32-bit values.  Sometimes, we need to munge data&n;that is represented on the x86 side as an array of bytes.  The most&n;efficient approach to handling both cases seems to be to use 2&n;different functions for munging and 2 for de-munging.  This avoids&n;weird casting and worrying about bit-level offsets.&n;&n;**********************************************************************/
r_static
r_int
r_char
op_star
DECL|function|munge_int32
id|munge_int32
(paren
r_int
r_int
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|dst_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dst_size
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dst
op_assign
id|src
op_amp
l_int|0x7F
suffix:semicolon
multiline_comment|/* Mask high bit of LSB */
id|src
op_assign
id|src
op_rshift
l_int|7
suffix:semicolon
multiline_comment|/* Rotate Right 7 bits  */
multiline_comment|/* Note: we leave the upper bits in place */
id|dst
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|demunge_int32
id|demunge_int32
(paren
r_int
r_char
op_star
id|src
comma
r_int
id|src_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|outval
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|src_size
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outval
op_assign
(paren
id|outval
op_lshift
l_int|7
)paren
op_plus
id|src
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|outval
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
r_char
op_star
DECL|function|munge_buf
id|munge_buf
(paren
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|dst_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|last
op_assign
id|dst_size
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|last
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|src
(braket
id|i
)braket
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|src
(braket
id|i
)braket
op_rshift
l_int|7
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_int
r_char
op_star
DECL|function|demunge_buf
id|demunge_buf
(paren
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|src_bytes
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|end
op_assign
id|src
op_plus
id|src_bytes
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|src_bytes
suffix:semicolon
multiline_comment|/* NOTE: src and dst *CAN* point to the same address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|src
op_ne
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dst
(braket
id|i
)braket
op_assign
op_star
id|src
op_increment
suffix:semicolon
id|dst
(braket
id|i
)braket
op_or_assign
(paren
op_star
id|src
op_increment
)paren
op_lshift
l_int|7
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: sample, patch and program management.&n;***********************************************************************/
r_static
r_int
DECL|function|wavefront_delete_sample
id|wavefront_delete_sample
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|sample_num
)paren
(brace
r_int
r_char
id|wbuf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|x
suffix:semicolon
id|wbuf
(braket
l_int|0
)braket
op_assign
id|sample_num
op_amp
l_int|0x7f
suffix:semicolon
id|wbuf
(braket
l_int|1
)braket
op_assign
id|sample_num
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DELETE_SAMPLE
comma
l_int|0
comma
id|wbuf
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;sample_status
(braket
id|sample_num
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_sample_status
id|wavefront_get_sample_status
(paren
r_struct
id|wf_config
op_star
id|hw
comma
r_int
id|assume_rom
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|rbuf
(braket
l_int|32
)braket
comma
id|wbuf
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|sc_real
comma
id|sc_alias
comma
id|sc_multi
suffix:semicolon
multiline_comment|/* check sample status */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_GET_NSAMPLES
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;WaveFront: cannot request sample count.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sc_real
op_assign
id|sc_alias
op_assign
id|sc_multi
op_assign
id|hw-&gt;samples_used
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wbuf
(braket
l_int|0
)braket
op_assign
id|i
op_amp
l_int|0x7f
suffix:semicolon
id|wbuf
(braket
l_int|1
)braket
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_IDENTIFY_SAMPLE_TYPE
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: cannot identify sample &quot;
l_string|&quot;type of slot %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|hw-&gt;sample_status
(braket
id|i
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hw-&gt;sample_status
(braket
id|i
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|rbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assume_rom
)paren
(brace
id|hw-&gt;sample_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_ROM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rbuf
(braket
l_int|0
)braket
op_amp
id|WF_ST_MASK
)paren
(brace
r_case
id|WF_ST_SAMPLE
suffix:colon
id|sc_real
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_MULTISAMPLE
suffix:colon
id|sc_multi
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_ALIAS
suffix:colon
id|sc_alias
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_EMPTY
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: unknown sample type for &quot;
l_string|&quot;slot %d (0x%x)&bslash;n&quot;
comma
id|i
comma
id|rbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbuf
(braket
l_int|0
)braket
op_ne
id|WF_ST_EMPTY
)paren
(brace
id|hw-&gt;samples_used
op_increment
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: %d samples used (%d real, %d aliases, %d multi), &quot;
l_string|&quot;%d empty&bslash;n&quot;
comma
id|hw-&gt;samples_used
comma
id|sc_real
comma
id|sc_alias
comma
id|sc_multi
comma
id|WF_MAX_SAMPLE
op_minus
id|hw-&gt;samples_used
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_patch_status
id|wavefront_get_patch_status
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
(brace
r_int
r_char
id|patchbuf
(braket
id|WF_PATCH_BYTES
)braket
suffix:semicolon
r_int
r_char
id|patchnum
(braket
l_int|2
)braket
suffix:semicolon
id|wavefront_patch
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|cnt
comma
id|cnt2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|patchnum
(braket
l_int|0
)braket
op_assign
id|i
op_amp
l_int|0x7f
suffix:semicolon
id|patchnum
(braket
l_int|1
)braket
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_UPLOAD_PATCH
comma
id|patchbuf
comma
id|patchnum
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;patch_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_FILLED
suffix:semicolon
id|p
op_assign
(paren
id|wavefront_patch
op_star
)paren
id|patchbuf
suffix:semicolon
id|hw-&gt;sample_status
(braket
id|p-&gt;sample_number
op_or
(paren
id|p-&gt;sample_msb
op_lshift
l_int|7
)paren
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x
op_eq
l_int|3
)paren
(brace
multiline_comment|/* Bad patch number */
id|hw-&gt;patch_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload patch &quot;
l_string|&quot;error 0x%x&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|hw-&gt;patch_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* program status has already filled in slot_used bits */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnt
op_assign
l_int|0
comma
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_USED
)paren
(brace
id|cnt2
op_increment
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: %d patch slots filled, %d in use&bslash;n&quot;
comma
id|cnt
comma
id|cnt2
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_program_status
id|wavefront_get_program_status
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
(brace
r_int
r_char
id|progbuf
(braket
id|WF_PROGRAM_BYTES
)braket
suffix:semicolon
id|wavefront_program
id|prog
suffix:semicolon
r_int
r_char
id|prognum
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|l
comma
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PROGRAM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prognum
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_UPLOAD_PROGRAM
comma
id|progbuf
comma
op_amp
id|prognum
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;prog_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
id|demunge_buf
(paren
id|progbuf
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|prog
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|WF_NUM_LAYERS
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|prog.layer
(braket
id|l
)braket
dot
id|mute
)paren
(brace
id|hw-&gt;patch_status
(braket
id|prog.layer
(braket
id|l
)braket
dot
id|patch_number
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|x
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Bad program number */
id|hw-&gt;prog_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload program &quot;
l_string|&quot;error 0x%x&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|hw-&gt;prog_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PROGRAM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;prog_status
(braket
id|i
)braket
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: %d programs slots in use&bslash;n&quot;
comma
id|cnt
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_patch
id|wavefront_send_patch
(paren
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|buf
(braket
id|WF_PATCH_BYTES
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
op_star
id|bptr
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: downloading patch %d&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
id|hw-&gt;patch_status
(braket
id|header-&gt;number
)braket
op_or_assign
id|WF_SLOT_FILLED
suffix:semicolon
id|bptr
op_assign
id|buf
suffix:semicolon
id|bptr
op_assign
id|munge_int32
(paren
id|header-&gt;number
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
id|munge_buf
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header-&gt;hdr.p
comma
id|bptr
comma
id|WF_PATCH_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DOWNLOAD_PATCH
comma
l_int|0
comma
id|buf
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: download patch failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_program
id|wavefront_send_program
(paren
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|buf
(braket
id|WF_PROGRAM_BYTES
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: downloading program %d&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
id|hw-&gt;prog_status
(braket
id|header-&gt;number
)braket
op_assign
id|WF_SLOT_USED
suffix:semicolon
multiline_comment|/* XXX need to zero existing SLOT_USED bit for program_status[i]&n;&t;   where `i&squot; is the program that&squot;s being (potentially) overwritten.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_NUM_LAYERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|header-&gt;hdr.pr.layer
(braket
id|i
)braket
dot
id|mute
)paren
(brace
id|hw-&gt;patch_status
(braket
id|header-&gt;hdr.pr.layer
(braket
id|i
)braket
dot
id|patch_number
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
multiline_comment|/* XXX need to mark SLOT_USED for sample used by&n;&t;&t;&t;   patch_number, but this means we have to load it. Ick.&n;&t;&t;&t;*/
)brace
)brace
id|buf
(braket
l_int|0
)braket
op_assign
id|header-&gt;number
suffix:semicolon
id|munge_buf
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header-&gt;hdr.pr
comma
op_amp
id|buf
(braket
l_int|1
)braket
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DOWNLOAD_PROGRAM
comma
l_int|0
comma
id|buf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: download patch failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_freemem
id|wavefront_freemem
(paren
id|wf_config
op_star
id|hw
)paren
(brace
r_char
id|rbuf
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_REPORT_FREE_MEMORY
comma
id|rbuf
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: can&squot;t get memory stats.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
id|demunge_int32
(paren
id|rbuf
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|wavefront_send_sample
id|wavefront_send_sample
(paren
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
comma
id|UINT16
op_star
id|dataptr
comma
r_int
id|data_is_unsigned
)paren
(brace
multiline_comment|/* samples are downloaded via a 16-bit wide i/o port&n;&t;   (you could think of it as 2 adjacent 8-bit wide ports&n;&t;   but its less efficient that way). therefore, all&n;&t;   the blocksizes and so forth listed in the documentation,&n;&t;   and used conventionally to refer to sample sizes,&n;&t;   which are given in 8-bit units (bytes), need to be&n;&t;   divided by 2.&n;        */
id|UINT16
id|sample_short
suffix:semicolon
id|UINT32
id|length
suffix:semicolon
id|UINT16
op_star
id|data_end
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_const
r_int
id|max_blksize
op_assign
l_int|4096
op_div
l_int|2
suffix:semicolon
r_int
r_int
id|written
suffix:semicolon
r_int
r_int
id|blocksize
suffix:semicolon
r_int
id|dma_ack
suffix:semicolon
r_int
id|blocknum
suffix:semicolon
r_int
r_char
id|sample_hdr
(braket
id|WF_SAMPLE_HDR_BYTES
)braket
suffix:semicolon
r_int
r_char
op_star
id|shptr
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_int
id|initial_skip
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: sample %sdownload for slot %d, &quot;
l_string|&quot;type %d, %d bytes from 0x%x&bslash;n&quot;
comma
id|header-&gt;size
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;header &quot;
comma
id|header-&gt;number
comma
id|header-&gt;subkey
comma
id|header-&gt;size
comma
(paren
r_int
)paren
id|header-&gt;dataptr
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
multiline_comment|/* XXX its a debatable point whether or not RDONLY semantics&n;&t;&t;   on the ROM samples should cover just the sample data or&n;&t;&t;   the sample header. For now, it only covers the sample data,&n;&t;&t;   so anyone is free at all times to rewrite sample headers.&n;&n;&t;&t;   My reason for this is that we have the sample headers&n;&t;&t;   available in the WFB file for General MIDI, and so these&n;&t;&t;   can always be reset if needed. The sample data, however,&n;&t;&t;   cannot be recovered without a complete reset and firmware&n;&t;&t;   reload of the ICS2115, which is a very expensive operation.&n;&n;&t;&t;   So, doing things this way allows us to honor the notion of&n;&t;&t;   &quot;RESETSAMPLES&quot; reasonably cheaply. Note however, that this&n;&t;&t;   is done purely at user level: there is no WFB parser in&n;&t;&t;   this driver, and so a complete reset (back to General MIDI,&n;&t;&t;   or theoretically some other configuration) is the&n;&t;&t;   responsibility of the user level library. &n;&n;&t;&t;   To try to do this in the kernel would be a little&n;&t;&t;   crazy: we&squot;d need 158K of kernel space just to hold&n;&t;&t;   a copy of the patch/program/sample header data.&n;&t;&t;*/
r_if
c_cond
(paren
id|hw-&gt;rom_samples_rdonly
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_amp
id|WF_SLOT_ROM
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: sample slot %d &quot;
l_string|&quot;write protected&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
)brace
id|wavefront_delete_sample
(paren
id|hw
comma
id|header-&gt;number
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
id|hw-&gt;freemem
op_assign
id|wavefront_freemem
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;freemem
OL
id|header-&gt;size
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: insufficient memory to &quot;
l_string|&quot;load %d byte sample.&bslash;n&quot;
comma
id|header-&gt;size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|skip
op_assign
id|WF_GET_CHANNEL
c_func
(paren
op_amp
id|header-&gt;hdr.s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|header-&gt;hdr.s.SampleResolution
)paren
(brace
r_case
id|LINEAR_16BIT
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: channel selection only possible &quot;
l_string|&quot;on 16-bit samples&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|skip
)paren
(brace
r_case
l_int|0
suffix:colon
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|skip
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|initial_skip
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|initial_skip
op_assign
l_int|2
suffix:semicolon
id|skip
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|initial_skip
op_assign
l_int|3
suffix:semicolon
id|skip
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|initial_skip
op_assign
l_int|4
suffix:semicolon
id|skip
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|initial_skip
op_assign
l_int|5
suffix:semicolon
id|skip
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: channel selection: %d =&gt; &quot;
l_string|&quot;initial skip = %d, skip = %d&bslash;n&quot;
comma
id|WF_GET_CHANNEL
(paren
op_amp
id|header-&gt;hdr.s
)paren
comma
id|initial_skip
comma
id|skip
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
multiline_comment|/* Be safe, and zero the &quot;Unused&quot; bits ... */
id|WF_SET_CHANNEL
c_func
(paren
op_amp
id|header-&gt;hdr.s
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* adjust size for 16 bit samples by dividing by two.  We always&n;&t;   send 16 bits per write, even for 8 bit samples, so the length&n;&t;   is always half the size of the sample data in bytes.&n;&t;*/
id|length
op_assign
id|header-&gt;size
op_div
l_int|2
suffix:semicolon
multiline_comment|/* the data we&squot;re sent has not been munged, and in fact, the&n;&t;   header we have to send isn&squot;t just a munged copy either.&n;&t;   so, build the sample header right here.&n;&t;*/
id|shptr
op_assign
op_amp
id|sample_hdr
(braket
l_int|0
)braket
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
id|header-&gt;number
comma
id|shptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
id|shptr
op_assign
id|munge_int32
(paren
id|length
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Yes, a 4 byte result doesn&squot;t contain all of the offset bits,&n;&t;   but the offset only uses 24 bits.&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.sampleStartOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.loopStartOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.loopEndOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.sampleEndOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* This one is truly weird.  What kind of weirdo decided that in&n;&t;   a system dominated by 16- and 32-bit integers, they would use&n;&t;   just 12 bits ?&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
id|header-&gt;hdr.s.FrequencyBias
comma
id|shptr
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Why is this nybblified, when the MSB is *always* zero? &n;&t;   Anyway, we can&squot;t take address of bitfield, so make a&n;&t;   good-faith guess at where it starts.&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
op_amp
id|header-&gt;hdr.s.FrequencyBias
op_plus
l_int|1
)paren
comma
id|shptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|header-&gt;size
ques
c_cond
id|WFC_DOWNLOAD_SAMPLE
suffix:colon
id|WFC_DOWNLOAD_SAMPLE_HEADER
comma
l_int|0
comma
id|sample_hdr
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: sample %sdownload refused.&bslash;n&quot;
comma
id|header-&gt;size
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;header &quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
op_eq
l_int|0
)paren
(brace
r_goto
id|sent
suffix:semicolon
multiline_comment|/* Sorry. Just had to have one somewhere */
)brace
id|data_end
op_assign
id|dataptr
op_plus
id|length
suffix:semicolon
multiline_comment|/* Do any initial skip over an unused channel&squot;s data */
id|dataptr
op_add_assign
id|initial_skip
suffix:semicolon
r_for
c_loop
(paren
id|written
op_assign
l_int|0
comma
id|blocknum
op_assign
l_int|0
suffix:semicolon
id|written
OL
id|length
suffix:semicolon
id|written
op_add_assign
id|max_blksize
comma
id|blocknum
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|length
op_minus
id|written
)paren
OG
id|max_blksize
)paren
(brace
id|blocksize
op_assign
id|max_blksize
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* round to nearest 16-byte value */
id|blocksize
op_assign
(paren
(paren
id|length
op_minus
id|written
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|0x7
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DOWNLOAD_BLOCK
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: download block &quot;
l_string|&quot;request refused.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blocksize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dataptr
OL
id|data_end
)paren
(brace
id|get_user
(paren
id|sample_short
comma
id|dataptr
)paren
suffix:semicolon
id|dataptr
op_add_assign
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|data_is_unsigned
)paren
(brace
multiline_comment|/* GUS ? */
r_if
c_cond
(paren
id|WF_SAMPLE_IS_8BIT
c_func
(paren
op_amp
id|header-&gt;hdr.s
)paren
)paren
(brace
multiline_comment|/* 8 bit sample&n;&t;&t;&t;&t;&t;&t; resolution, sign&n;&t;&t;&t;&t;&t;&t; extend both bytes.&n;&t;&t;&t;&t;&t;&t;*/
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sample_short
)paren
(braket
l_int|0
)braket
op_add_assign
l_int|0x7f
suffix:semicolon
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sample_short
)paren
(braket
l_int|1
)braket
op_add_assign
l_int|0x7f
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 16 bit sample&n;&t;&t;&t;&t;&t;&t; resolution, sign&n;&t;&t;&t;&t;&t;&t; extend the MSB.&n;&t;&t;&t;&t;&t;&t;*/
id|sample_short
op_add_assign
l_int|0x7fff
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* In padding section of final block:&n;&n;&t;&t;&t;&t;   Don&squot;t fetch unsupplied data from&n;&t;&t;&t;&t;   user space, just continue with&n;&t;&t;&t;&t;   whatever the final value was.&n;&t;&t;&t;&t;*/
)brace
r_if
c_cond
(paren
id|i
OL
id|blocksize
op_minus
l_int|1
)paren
(brace
id|outw
(paren
id|sample_short
comma
id|hw-&gt;block_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outw
(paren
id|sample_short
comma
id|hw-&gt;last_block_port
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Get &quot;DMA page acknowledge&quot; */
r_if
c_cond
(paren
(paren
id|dma_ack
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_ne
id|WF_DMA_ACK
)paren
(brace
r_if
c_cond
(paren
id|dma_ack
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload sample &quot;
l_string|&quot;DMA ack timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload sample &quot;
l_string|&quot;DMA ack error 0x%x&bslash;n&quot;
comma
id|dma_ack
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
)brace
id|hw-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_SAMPLE
)paren
suffix:semicolon
multiline_comment|/* Note, label is here because sending the sample header shouldn&squot;t&n;&t;   alter the sample_status info at all.&n;&t;*/
id|sent
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_alias
id|wavefront_send_alias
(paren
r_struct
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|alias_hdr
(braket
id|WF_ALIAS_BYTES
)braket
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: download alias, %d is &quot;
l_string|&quot;alias for %d&bslash;n&quot;
comma
id|header-&gt;number
comma
id|header-&gt;hdr.a.OriginalSample
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
id|munge_int32
(paren
id|header-&gt;number
comma
op_amp
id|alias_hdr
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.a.OriginalSample
comma
op_amp
id|alias_hdr
(braket
l_int|2
)braket
comma
l_int|2
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.sampleStartOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|4
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.loopStartOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|8
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.loopEndOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|12
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.sampleEndOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|16
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.a.FrequencyBias
comma
op_amp
id|alias_hdr
(braket
l_int|20
)braket
comma
l_int|3
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
op_amp
id|header-&gt;hdr.a.FrequencyBias
op_plus
l_int|1
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|23
)braket
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DOWNLOAD_SAMPLE_ALIAS
comma
l_int|0
comma
id|alias_hdr
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: download alias failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|hw-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_ALIAS
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_multisample
id|wavefront_send_multisample
(paren
r_struct
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|num_samples
suffix:semicolon
r_int
r_char
id|msample_hdr
(braket
id|WF_MSAMPLE_BYTES
)braket
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
op_amp
id|msample_hdr
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* You&squot;ll recall at this point that the &quot;number of samples&quot; value&n;&t;   in a wavefront_multisample struct is actually the log2 of the&n;&t;   real number of samples.&n;&t;*/
id|num_samples
op_assign
(paren
l_int|1
op_lshift
(paren
id|header-&gt;hdr.ms.NumberOfSamples
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|msample_hdr
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
id|header-&gt;hdr.ms.NumberOfSamples
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: multi %d with %d=%d samples&bslash;n&quot;
comma
id|header-&gt;number
comma
id|header-&gt;hdr.ms.NumberOfSamples
comma
id|num_samples
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_samples
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
(paren
id|hw-&gt;debug
op_amp
(paren
id|WF_DEBUG_LOAD_PATCH
op_or
id|WF_DEBUG_DATA
)paren
)paren
op_eq
(paren
id|WF_DEBUG_LOAD_PATCH
op_or
id|WF_DEBUG_DATA
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: sample[%d] = %d&bslash;n&quot;
comma
id|i
comma
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
id|munge_int32
(paren
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
comma
op_amp
id|msample_hdr
(braket
l_int|3
op_plus
(paren
id|i
op_star
l_int|2
)paren
)braket
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Need a hack here to pass in the number of bytes&n;&t;   to be written to the synth. This is ugly, and perhaps&n;&t;   one day, I&squot;ll fix it.&n;&t;*/
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DOWNLOAD_MULTISAMPLE
comma
(paren
r_int
r_char
op_star
)paren
(paren
(paren
id|num_samples
op_star
l_int|2
)paren
op_plus
l_int|3
)paren
comma
id|msample_hdr
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: download of multisample failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|hw-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_MULTISAMPLE
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_fetch_multisample
id|wavefront_fetch_multisample
(paren
r_struct
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|log_ns
(braket
l_int|1
)braket
suffix:semicolon
r_int
r_char
id|number
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|num_samples
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
id|number
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_UPLOAD_MULTISAMPLE
comma
id|log_ns
comma
id|number
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload multisample failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: msample %d has %d samples&bslash;n&quot;
comma
id|header-&gt;number
comma
id|log_ns
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
id|header-&gt;hdr.ms.NumberOfSamples
op_assign
id|log_ns
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* get the number of samples ... */
id|num_samples
op_assign
(paren
l_int|1
op_lshift
id|log_ns
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_samples
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|d
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload multisample failed &quot;
l_string|&quot;during sample loop.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|d
(braket
l_int|1
)braket
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: upload multisample failed &quot;
l_string|&quot;during sample loop.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
op_assign
id|demunge_int32
(paren
(paren
r_int
r_char
op_star
)paren
id|d
comma
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_DATA
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: msample &quot;
l_string|&quot;sample[%d] = %d&bslash;n&quot;
comma
id|i
comma
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_drum
id|wavefront_send_drum
(paren
r_struct
id|wf_config
op_star
id|hw
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|drumbuf
(braket
id|WF_DRUM_BYTES
)braket
suffix:semicolon
id|wavefront_drum
op_star
id|drum
op_assign
op_amp
id|header-&gt;hdr.d
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: downloading edrum for MIDI &quot;
l_string|&quot;note %d, patch = %d&bslash;n&quot;
comma
id|header-&gt;number
comma
id|drum-&gt;PatchNumber
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
id|drumbuf
(braket
l_int|0
)braket
op_assign
id|header-&gt;number
op_amp
l_int|0x7f
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|munge_int32
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|drum
)paren
(braket
id|i
)braket
comma
op_amp
id|drumbuf
(braket
l_int|1
op_plus
(paren
id|i
op_star
l_int|2
)paren
)braket
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_DOWNLOAD_EDRUM_PROGRAM
comma
l_int|0
comma
id|drumbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: download drum failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_find_free_sample
id|wavefront_find_free_sample
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hw-&gt;sample_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: no free sample slots!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_find_free_patch
id|wavefront_find_free_patch
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hw-&gt;patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: no free patch slots!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|log2_2048
id|log2_2048
c_func
(paren
r_int
id|n
)paren
(brace
r_int
id|tbl
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Returns 2048*log2(n) */
multiline_comment|/* FIXME: this is like doing integer math&n;&t;   on quantum particles (RuN) */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
op_ge
l_int|32
op_star
l_int|256
)paren
(brace
id|n
op_rshift_assign
l_int|8
suffix:semicolon
id|i
op_add_assign
l_int|2048
op_star
l_int|8
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
op_ge
l_int|32
)paren
(brace
id|n
op_rshift_assign
l_int|1
suffix:semicolon
id|i
op_add_assign
l_int|2048
suffix:semicolon
)brace
id|i
op_add_assign
id|tbl
(braket
id|n
)braket
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_load_gus_patch
id|wavefront_load_gus_patch
(paren
r_struct
id|wf_config
op_star
id|hw
comma
r_int
id|dev
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
(brace
r_struct
id|patch_info
id|guspatch
suffix:semicolon
id|wavefront_patch_info
id|samp
comma
id|pat
comma
id|prog
suffix:semicolon
id|wavefront_patch
op_star
id|patp
suffix:semicolon
id|wavefront_sample
op_star
id|sampp
suffix:semicolon
id|wavefront_program
op_star
id|progp
suffix:semicolon
r_int
id|i
comma
id|base_note
suffix:semicolon
r_int
id|sizeof_patch
suffix:semicolon
multiline_comment|/* Copy in the header of the GUS patch */
id|sizeof_patch
op_assign
(paren
r_int
)paren
op_amp
id|guspatch.data
(braket
l_int|0
)braket
op_minus
(paren
r_int
)paren
op_amp
id|guspatch
suffix:semicolon
id|copy_from_user
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
op_amp
id|guspatch
)paren
(braket
id|offs
)braket
comma
op_amp
(paren
id|addr
)paren
(braket
id|offs
)braket
comma
id|sizeof_patch
op_minus
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|wavefront_find_free_patch
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|pat.number
op_assign
id|i
suffix:semicolon
id|pat.subkey
op_assign
id|WF_ST_PATCH
suffix:semicolon
id|patp
op_assign
op_amp
id|pat.hdr.p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|wavefront_find_free_sample
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|samp.number
op_assign
id|i
suffix:semicolon
id|samp.subkey
op_assign
id|WF_ST_SAMPLE
suffix:semicolon
id|samp.size
op_assign
id|guspatch.len
suffix:semicolon
id|sampp
op_assign
op_amp
id|samp.hdr.s
suffix:semicolon
id|prog.number
op_assign
id|guspatch.instr_no
suffix:semicolon
id|progp
op_assign
op_amp
id|prog.hdr.pr
suffix:semicolon
multiline_comment|/* Setup the patch structure */
id|patp-&gt;amplitude_bias
op_assign
id|guspatch.volume
suffix:semicolon
id|patp-&gt;portamento
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;sample_number
op_assign
id|samp.number
op_amp
l_int|0xff
suffix:semicolon
id|patp-&gt;sample_msb
op_assign
id|samp.number
op_rshift
l_int|8
suffix:semicolon
id|patp-&gt;pitch_bend
op_assign
multiline_comment|/*12*/
l_int|0
suffix:semicolon
id|patp-&gt;mono
op_assign
l_int|1
suffix:semicolon
id|patp-&gt;retrigger
op_assign
l_int|1
suffix:semicolon
id|patp-&gt;nohold
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_SUSTAIN_ON
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|patp-&gt;frequency_bias
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;restart
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;reuse
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;reset_lfo
op_assign
l_int|1
suffix:semicolon
id|patp-&gt;fm_src2
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fm_src1
op_assign
id|WF_MOD_MOD_WHEEL
suffix:semicolon
id|patp-&gt;am_src
op_assign
id|WF_MOD_PRESSURE
suffix:semicolon
id|patp-&gt;am_amount
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;fc1_mod_amount
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fc2_mod_amount
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fm_amount1
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fm_amount2
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;envelope1.attack_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.decay1_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.decay2_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.sustain_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.release_level
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;envelope2.attack_velocity
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.attack_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.decay1_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.decay2_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.sustain_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.release_level
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;envelope2.attack_velocity
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;randomizer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Program for this patch */
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|patch_number
op_assign
id|pat.number
suffix:semicolon
multiline_comment|/* XXX is this right ? */
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|mute
op_assign
l_int|1
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|pan_or_mod
op_assign
l_int|1
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|pan
op_assign
l_int|7
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|mix_level
op_assign
l_int|127
multiline_comment|/* guspatch.volume */
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|split_type
op_assign
l_int|0
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|split_point
op_assign
l_int|0
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|updown
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|progp-&gt;layer
(braket
id|i
)braket
dot
id|mute
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Sample data */
id|sampp-&gt;SampleResolution
op_assign
(paren
(paren
op_complement
id|guspatch.mode
op_amp
id|WAVE_16_BITS
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|base_note
op_assign
l_int|0
suffix:semicolon
id|note_to_freq
(paren
id|base_note
)paren
OL
id|guspatch.base_note
suffix:semicolon
id|base_note
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|guspatch.base_note
op_minus
id|note_to_freq
c_func
(paren
id|base_note
)paren
)paren
OG
(paren
id|note_to_freq
c_func
(paren
id|base_note
)paren
op_minus
id|guspatch.base_note
)paren
)paren
id|base_note
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ref freq=%d,base note=%d&bslash;n&quot;
comma
id|guspatch.base_freq
comma
id|base_note
)paren
suffix:semicolon
id|sampp-&gt;FrequencyBias
op_assign
(paren
l_int|29550
op_minus
id|log2_2048
c_func
(paren
id|guspatch.base_freq
)paren
op_plus
id|base_note
op_star
l_int|171
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Freq Bias is %d&bslash;n&quot;
comma
id|sampp-&gt;FrequencyBias
)paren
suffix:semicolon
id|sampp-&gt;Loop
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_LOOPING
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|sampp-&gt;sampleStartOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;sampleStartOffset.Integer
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;loopStartOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;loopStartOffset.Integer
op_assign
id|guspatch.loop_start
op_rshift
(paren
(paren
id|guspatch.mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sampp-&gt;loopEndOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;loopEndOffset.Integer
op_assign
id|guspatch.loop_end
op_rshift
(paren
(paren
id|guspatch.mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sampp-&gt;sampleEndOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;sampleEndOffset.Integer
op_assign
id|guspatch.len
op_rshift
(paren
id|guspatch.mode
op_amp
l_int|1
)paren
suffix:semicolon
id|sampp-&gt;Bidirectional
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_BIDIR_LOOP
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|sampp-&gt;Reverse
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_LOOP_BACK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Now ship it down */
id|wavefront_send_sample
(paren
id|hw
comma
op_amp
id|samp
comma
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|addr
)paren
(braket
id|sizeof_patch
)braket
comma
(paren
id|guspatch.mode
op_amp
id|WAVE_UNSIGNED
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|wavefront_send_patch
(paren
id|hw
comma
op_amp
id|pat
)paren
suffix:semicolon
id|wavefront_send_program
(paren
id|hw
comma
op_amp
id|prog
)paren
suffix:semicolon
multiline_comment|/* Now pan as best we can ... use the slave/internal MIDI device&n;&t;   number if it exists (since it talks to the WaveFront), or the&n;&t;   master otherwise.&n;&t;*/
macro_line|#ifdef CONFIG_MIDI
r_if
c_cond
(paren
id|hw-&gt;mididev
OG
l_int|0
)paren
(brace
id|midi_synth_controller
(paren
id|hw-&gt;mididev
comma
id|guspatch.instr_no
comma
l_int|10
comma
(paren
(paren
id|guspatch.panning
op_lshift
l_int|4
)paren
OG
l_int|127
)paren
ques
c_cond
l_int|127
suffix:colon
(paren
id|guspatch.panning
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif CONFIG_MIDI
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|wavefront_load_patch
id|wavefront_load_patch
(paren
r_int
id|dev
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
(brace
r_struct
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
id|wavefront_patch_info
id|header
suffix:semicolon
r_if
c_cond
(paren
id|format
op_eq
id|SYSEX_PATCH
)paren
(brace
multiline_comment|/* Handled by midi_synth.c */
r_if
c_cond
(paren
id|midi_load_patch
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: SYSEX not loadable: &quot;
l_string|&quot;no midi patch loader!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
id|midi_load_patch
(paren
id|dev
comma
id|format
comma
id|addr
comma
id|offs
comma
id|count
comma
id|pmgr_flag
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|format
op_eq
id|GUS_PATCH
)paren
(brace
r_return
id|wavefront_load_gus_patch
(paren
id|hw
comma
id|dev
comma
id|format
comma
id|addr
comma
id|offs
comma
id|count
comma
id|pmgr_flag
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|format
op_ne
id|WAVEFRONT_PATCH
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: unknown patch format %d&bslash;n&quot;
comma
id|format
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
r_sizeof
(paren
id|wavefront_patch_info
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: sample header too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* copied in so far: `offs&squot; bytes from `addr&squot;. We shouldn&squot;t copy&n;&t;   them in again, and they correspond to header-&gt;key and header-&gt;devno.&n;&t;   So now, copy the rest of the wavefront_patch_info struct, except&n;&t;   for the &squot;hdr&squot; field, since this is handled via indirection&n;&t;   through the &squot;hdrptr&squot; field.&n;&t;*/
id|copy_from_user
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
op_amp
id|header
)paren
(braket
id|offs
)braket
comma
op_amp
(paren
id|addr
)paren
(braket
id|offs
)braket
comma
r_sizeof
(paren
id|wavefront_patch_info
)paren
op_minus
r_sizeof
(paren
id|wavefront_any
)paren
op_minus
id|offs
)paren
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_LOAD_PATCH
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: download &quot;
l_string|&quot;Sample type: %d &quot;
l_string|&quot;Sample number: %d &quot;
l_string|&quot;Sample size: %d&bslash;n&quot;
comma
id|header.subkey
comma
id|header.number
comma
id|header.size
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_switch
c_cond
(paren
id|header.subkey
)paren
(brace
r_case
id|WF_ST_SAMPLE
suffix:colon
multiline_comment|/* sample or sample_header, based on patch-&gt;size */
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.s
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_sample
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_sample
(paren
id|hw
comma
op_amp
id|header
comma
id|header.dataptr
comma
l_int|0
)paren
suffix:semicolon
r_case
id|WF_ST_MULTISAMPLE
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.s
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_multisample
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_multisample
(paren
id|hw
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_ALIAS
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.a
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_alias
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_alias
(paren
id|hw
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_DRUM
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.d
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_drum
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_drum
(paren
id|hw
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_PATCH
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.p
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_patch
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_patch
(paren
id|hw
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_PROGRAM
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.pr
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_program
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_program
(paren
id|hw
comma
op_amp
id|header
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: unknown patch type %d.&bslash;n&quot;
comma
id|header.subkey
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: /dev/sequencer{,2} and other hardware-dependent interfaces&n;***********************************************************************/
r_static
r_void
DECL|function|process_sample_hdr
id|process_sample_hdr
(paren
id|UCHAR8
op_star
id|buf
)paren
(brace
id|wavefront_sample
id|s
suffix:semicolon
id|UCHAR8
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|buf
suffix:semicolon
multiline_comment|/* The board doesn&squot;t send us an exact copy of a &quot;wavefront_sample&quot;&n;&t;   in response to an Upload Sample Header command. Instead, we &n;&t;   have to convert the data format back into our data structure,&n;&t;   just as in the Download Sample command, where we have to do&n;&t;   something very similar in the reverse direction.&n;&t;*/
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.sampleStartOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.loopStartOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.loopEndOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.sampleEndOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.FrequencyBias
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|3
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|3
suffix:semicolon
id|s.SampleResolution
op_assign
op_star
id|ptr
op_amp
l_int|0x3
suffix:semicolon
id|s.Loop
op_assign
op_star
id|ptr
op_amp
l_int|0x8
suffix:semicolon
id|s.Bidirectional
op_assign
op_star
id|ptr
op_amp
l_int|0x10
suffix:semicolon
id|s.Reverse
op_assign
op_star
id|ptr
op_amp
l_int|0x40
suffix:semicolon
multiline_comment|/* Now copy it back to where it came from */
id|memcpy
(paren
id|buf
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|s
comma
r_sizeof
(paren
id|wavefront_sample
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_synth_control
id|wavefront_synth_control
(paren
r_int
id|dev
comma
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
r_struct
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
id|wavefront_control
id|wc
suffix:semicolon
r_int
r_char
id|patchnumbuf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|wc
comma
id|arg
comma
r_sizeof
(paren
id|wc
)paren
)paren
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_CMD
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;WaveFront: synth control with &quot;
l_string|&quot;cmd 0x%x&bslash;n&quot;
comma
id|wc.cmd
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
multiline_comment|/* special case handling of or for various commands */
r_switch
c_cond
(paren
id|wc.cmd
)paren
(brace
r_case
id|WFC_DISABLE_INTERRUPTS
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: interrupts disabled.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x20
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
id|hw-&gt;interrupts_on
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_ENABLE_INTERRUPTS
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: interrupts enabled.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x20
op_or
l_int|0x40
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
id|hw-&gt;interrupts_on
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_INTERRUPT_STATUS
suffix:colon
id|wc.rbuf
(braket
l_int|0
)braket
op_assign
id|hw-&gt;interrupts_on
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_ROMSAMPLES_RDONLY
suffix:colon
id|hw-&gt;rom_samples_rdonly
op_assign
id|wc.wbuf
(braket
l_int|0
)braket
suffix:semicolon
id|wc.status
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_IDENTIFY_SLOT_TYPE
suffix:colon
id|i
op_assign
id|wc.wbuf
(braket
l_int|0
)braket
op_or
(paren
id|wc.wbuf
(braket
l_int|1
)braket
op_lshift
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|WF_MAX_SAMPLE
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: invalid slot ID %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|wc.status
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|wc.rbuf
(braket
l_int|0
)braket
op_assign
id|hw-&gt;sample_status
(braket
id|i
)braket
suffix:semicolon
id|wc.status
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_DEBUG_DRIVER
suffix:colon
id|hw-&gt;debug
op_assign
id|wc.wbuf
(braket
l_int|0
)braket
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: debug = 0x%x&bslash;n&quot;
comma
id|hw-&gt;debug
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_FX_IOCTL
suffix:colon
id|wffx_ioctl
(paren
id|hw
comma
(paren
id|wavefront_fx_info
op_star
)paren
op_amp
id|wc.wbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_UPLOAD_PATCH
suffix:colon
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
id|wc.wbuf
)paren
comma
id|patchnumbuf
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
(paren
id|wc.wbuf
comma
id|patchnumbuf
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_MULTISAMPLE
suffix:colon
r_case
id|WFC_UPLOAD_SAMPLE_ALIAS
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: support for various uploads &quot;
l_string|&quot;being considered.&bslash;n&quot;
)paren
suffix:semicolon
id|wc.status
op_assign
id|EINVAL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|wc.status
op_assign
id|wavefront_cmd
(paren
id|hw
comma
id|wc.cmd
comma
id|wc.rbuf
comma
id|wc.wbuf
)paren
suffix:semicolon
multiline_comment|/* Special case handling of certain commands.&n;&n;&t;   In particular, if the command was an upload, demunge the data&n;&t;   so that the user-level doesn&squot;t have to think about it.&n;&t;*/
r_if
c_cond
(paren
id|wc.status
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|wc.cmd
)paren
(brace
multiline_comment|/* intercept any freemem requests so that we know&n;&t;&t;&t;   we are always current with the user-level view&n;&t;&t;&t;   of things.&n;&t;&t;&t;*/
r_case
id|WFC_REPORT_FREE_MEMORY
suffix:colon
id|hw-&gt;freemem
op_assign
id|demunge_int32
(paren
id|wc.rbuf
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_PATCH
suffix:colon
id|demunge_buf
(paren
id|wc.rbuf
comma
id|wc.rbuf
comma
id|WF_PATCH_BYTES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_PROGRAM
suffix:colon
id|demunge_buf
(paren
id|wc.rbuf
comma
id|wc.rbuf
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_EDRUM_PROGRAM
suffix:colon
id|demunge_buf
(paren
id|wc.rbuf
comma
id|wc.rbuf
comma
id|WF_DRUM_BYTES
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_HEADER
suffix:colon
id|process_sample_hdr
(paren
id|wc.rbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_MULTISAMPLE
suffix:colon
r_case
id|WFC_UPLOAD_SAMPLE_ALIAS
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: support for &quot;
l_string|&quot;various uploads &quot;
l_string|&quot;being considered.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_VMIDI_OFF
suffix:colon
id|virtual_midi_disable
(paren
id|hw-&gt;mididev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_VMIDI_ON
suffix:colon
id|virtual_midi_enable
(paren
id|hw-&gt;mididev
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* XXX It would be nice to avoid a complete copy of the whole&n;&t;   struct sometimes. But I think its fast enough that this&n;&t;   is a low priority fix.&n;&t;*/
id|copy_to_user
(paren
id|arg
comma
op_amp
id|wc
comma
r_sizeof
(paren
id|wc
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: MIDI synth interface&n;***********************************************************************/
r_static
r_int
DECL|function|wavefront_ioctl
id|wavefront_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
r_int
r_char
id|rbuf
(braket
l_int|4
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDCTL_SYNTH_INFO
suffix:colon
id|memcpy
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
(braket
l_int|0
)braket
comma
op_amp
id|wavefront_info
comma
r_sizeof
(paren
id|wavefront_info
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_RESETSAMPLES
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: cannot reset sample status in kernel.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t force an error */
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_PERCMODE
suffix:colon
multiline_comment|/* XXX does this correspond to anything obvious ?*/
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t force an error */
r_break
suffix:semicolon
r_case
id|SNDCTL_SYNTH_MEMAVL
suffix:colon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_REPORT_FREE_MEMORY
comma
id|rbuf
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: cannot get free memory size&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;freemem
op_assign
id|demunge_int32
(paren
id|rbuf
comma
l_int|4
)paren
suffix:semicolon
r_return
id|hw-&gt;freemem
suffix:semicolon
)brace
r_case
id|SNDCTL_SYNTH_CONTROL
suffix:colon
r_return
id|wavefront_synth_control
(paren
id|dev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|wavefront_open
id|wavefront_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_struct
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;opened
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: warning: device in use&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|hw-&gt;opened
op_assign
id|mode
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|wavefront_close
id|wavefront_close
(paren
r_int
id|dev
)paren
(brace
r_struct
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef WF_STATS
id|printk
(paren
l_string|&quot;Status during loop: %ld&bslash;n&quot;
comma
id|hw-&gt;status_found_during_loop
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;Status during sleep[%d]: %ld&bslash;n&quot;
comma
id|i
comma
id|hw-&gt;status_found_during_sleep
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif WF_STATS
id|hw-&gt;opened
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;debug
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|wavefront_aftertouch
id|wavefront_aftertouch
(paren
r_int
id|dev
comma
r_int
id|channel
comma
r_int
id|pressure
)paren
(brace
id|midi_synth_aftertouch
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|pressure
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
DECL|function|wavefront_bender
id|wavefront_bender
(paren
r_int
id|dev
comma
r_int
id|chn
comma
r_int
id|value
)paren
(brace
id|midi_synth_bender
(paren
id|wavefront_configuration.mididev
comma
id|chn
comma
id|value
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
DECL|function|wavefront_controller
id|wavefront_controller
(paren
r_int
id|dev
comma
r_int
id|channel
comma
r_int
id|ctrl_num
comma
r_int
id|value
)paren
(brace
r_if
c_cond
(paren
id|ctrl_num
op_eq
id|CTRL_PITCH_BENDER
)paren
(brace
id|wavefront_bender
c_func
(paren
l_int|0
comma
id|channel
comma
id|value
)paren
suffix:semicolon
)brace
id|midi_synth_controller
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|ctrl_num
comma
id|value
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
DECL|function|wavefront_panning
id|wavefront_panning
c_func
(paren
r_int
id|dev
comma
r_int
id|channel
comma
r_int
id|pressure
)paren
(brace
id|midi_synth_controller
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|CTL_PAN
comma
id|pressure
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|wavefront_set_instr
id|wavefront_set_instr
(paren
r_int
id|dev
comma
r_int
id|channel
comma
r_int
id|instr_no
)paren
(brace
r_return
id|midi_synth_set_instr
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|instr_no
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|wavefront_kill_note
id|wavefront_kill_note
(paren
r_int
id|dev
comma
r_int
id|channel
comma
r_int
id|note
comma
r_int
id|volume
)paren
(brace
r_if
c_cond
(paren
id|note
op_eq
l_int|255
)paren
r_return
(paren
id|midi_synth_start_note
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|midi_synth_kill_note
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|note
comma
id|volume
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|wavefront_start_note
id|wavefront_start_note
(paren
r_int
id|dev
comma
r_int
id|channel
comma
r_int
id|note
comma
r_int
id|volume
)paren
(brace
r_if
c_cond
(paren
id|note
op_eq
l_int|255
)paren
(brace
id|midi_synth_aftertouch
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|volume
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|volume
op_eq
l_int|0
)paren
(brace
id|volume
op_assign
l_int|127
suffix:semicolon
id|midi_synth_aftertouch
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
l_int|0
)paren
suffix:semicolon
)brace
suffix:semicolon
id|midi_synth_start_note
(paren
id|wavefront_configuration.mididev
comma
id|channel
comma
id|note
comma
id|volume
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
DECL|function|wavefront_setup_voice
id|wavefront_setup_voice
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|chn
)paren
(brace
)brace
suffix:semicolon
DECL|function|wavefront_reset
r_static
r_void
id|wavefront_reset
(paren
r_int
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|midi_synth_kill_note
(paren
id|dev
comma
id|i
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|wavefront_operations
r_static
r_struct
id|synth_operations
id|wavefront_operations
op_assign
(brace
l_string|&quot;WaveFront&quot;
comma
op_amp
id|wavefront_info
comma
l_int|0
comma
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_WAVEFRONT
comma
id|wavefront_open
comma
id|wavefront_close
comma
id|wavefront_ioctl
comma
id|wavefront_kill_note
comma
id|wavefront_start_note
comma
id|wavefront_set_instr
comma
id|wavefront_reset
comma
l_int|NULL
comma
id|wavefront_load_patch
comma
id|wavefront_aftertouch
comma
id|wavefront_controller
comma
id|wavefront_panning
comma
l_int|NULL
comma
id|wavefront_bender
comma
l_int|NULL
comma
id|wavefront_setup_voice
)brace
suffix:semicolon
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: OSS/Free and/or Linux kernel installation interface&n;***********************************************************************/
r_void
DECL|function|wavefrontintr
id|wavefrontintr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|dummy
)paren
(brace
multiline_comment|/* We don&squot;t use this handler except during device&n;&t;   configuration. While the module is installed, the &n;&t;   interrupt is used to signal MIDI interrupts, and is &n;&t;   handled by the interrupt routine in wf_midi.c&n;&t; */
id|wf_config
op_star
id|hw
op_assign
(paren
id|wf_config
op_star
)paren
id|dev_id
suffix:semicolon
id|hw-&gt;irq_ok
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wavefront_status
c_func
(paren
id|hw
)paren
op_amp
id|STAT_INTR_WRITE
)paren
op_logical_or
(paren
id|wavefront_status
c_func
(paren
id|hw
)paren
op_amp
id|STAT_INTR_READ
)paren
)paren
(brace
id|wake_up
(paren
op_amp
id|hw-&gt;interrupt_sleeper
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* STATUS REGISTER &n;&n;0 Host Rx Interrupt Enable (1=Enabled)&n;1 Host Rx Register Full (1=Full)&n;2 Host Rx Interrupt Pending (1=Interrupt)&n;3 Unused&n;4 Host Tx Interrupt (1=Enabled)&n;5 Host Tx Register empty (1=Empty)&n;6 Host Tx Interrupt Pending (1=Interrupt)&n;7 Unused&n;&n;11111001 &n;  Rx Intr enable&n;  nothing to read from board&n;  no rx interrupt pending&n;  unused&n;  tx interrupt enabled&n;  space to transmit&n;  tx interrupt pending&n;&n;*/
r_int
DECL|function|wavefront_interrupt_bits
id|wavefront_interrupt_bits
(paren
r_int
id|irq
)paren
(brace
r_int
id|bits
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|9
suffix:colon
id|bits
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|bits
op_assign
l_int|0x08
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|bits
op_assign
l_int|0x10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|bits
op_assign
l_int|0x18
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: invalid IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|bits
suffix:semicolon
)brace
r_void
DECL|function|wavefront_should_cause_interrupt
id|wavefront_should_cause_interrupt
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|val
comma
r_int
id|port
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hw-&gt;irq_ok
op_assign
l_int|0
suffix:semicolon
id|outb
(paren
id|val
comma
id|port
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|interruptible_sleep_on
(paren
op_amp
id|hw-&gt;interrupt_sleeper
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_hw_reset
id|wavefront_hw_reset
(paren
id|wf_config
op_star
id|hw
)paren
(brace
r_int
id|bits
suffix:semicolon
r_int
id|hwv
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|hw-&gt;irq
comma
id|wavefrontintr
comma
l_int|0
comma
l_string|&quot;WaveFront&quot;
comma
(paren
r_void
op_star
)paren
id|hw
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: IRQ %d not available!&bslash;n&quot;
comma
id|hw-&gt;irq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* try reset of port */
id|outb
(paren
l_int|0x0
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
multiline_comment|/* At this point, the board is in reset, and the H/W initialization&n;&t;   register is accessed at the same address as the data port.&n;     &n;&t;   Bit 7 - Enable IRQ Driver&t;&n;&t;   0 - Tri-state the Wave-Board drivers for the PC Bus IRQs&n;&t;   1 - Enable IRQ selected by bits 5:3 to be driven onto the PC Bus.&n;     &n;&t;   Bit 6 - MIDI Interface Select&n;&n;&t;   0 - Use the MIDI Input from the 26-pin WaveBlaster&n;&t;   compatible header as the serial MIDI source&n;&t;   1 - Use the MIDI Input from the 9-pin D connector as the serial MIDI &n;&t;   source.&n;     &n;&t;   Bits 5:3 - IRQ Selection&n;&t;   0 0 0 - IRQ 2/9&n;&t;   0 0 1 - IRQ 5&n;&t;   0 1 0 - IRQ 12&n;&t;   0 1 1 - IRQ 15&n;&t;   1 0 0 - Reserved&n;&t;   1 0 1 - Reserved&n;&t;   1 1 0 - Reserved&n;&t;   1 1 1 - Reserved&n;     &n;&t;   Bits 2:1 - Reserved&n;&t;   Bit 0 - Disable Boot ROM&n;&t;   0 - memory accesses to 03FC30-03FFFFH utilize the internal Boot ROM&n;&t;   1 - memory accesses to 03FC30-03FFFFH are directed to external &n;&t;   storage.&n;     &n;&t;*/
multiline_comment|/* configure hardware: IRQ, enable interrupts, &n;&t;   plus external 9-pin MIDI interface selected&n;&t;*/
r_if
c_cond
(paren
(paren
id|bits
op_assign
id|wavefront_interrupt_bits
(paren
id|hw-&gt;irq
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
id|bits
comma
id|hw-&gt;data_port
)paren
suffix:semicolon
multiline_comment|/* CONTROL REGISTER&n;&n;&t;   0 Host Rx Interrupt Enable (1=Enabled)      0x1&n;&t;   1 Unused                                    0x2&n;&t;   2 Unused                                    0x4&n;&t;   3 Unused                                    0x8&n;&t;   4 Host Tx Interrupt Enable                 0x10&n;&t;   5 Mute (0=Mute; 1=Play)                    0x20&n;&t;   6 Master Interrupt Enable (1=Enabled)      0x40&n;&t;   7 Master Reset (0=Reset; 1=Run)            0x80&n;&n;&t;   Take us out of reset, unmute, master + TX + RX interrupts on.&n;&t;   &n;&t;   We&squot;ll get an interrupt presumably to tell us that the TX&n;&t;   register is clear. However, this doesn&squot;t mean that the&n;&t;   board is ready. We actually have to send it a command, and&n;&t;   wait till it gets back to use. After a cold boot, this can&n;&t;   take some time.&n;&t;   &n;&t;   &n;&t;   I think this is because its only after a cold boot that the&n;&t;   onboard ROM does its memory check, which can take &quot;up to 4&n;&t;   seconds&quot; according to the WaveFront SDK. So, since sleeping&n;&t;   doesn&squot;t cost us much, we&squot;ll give it *plenty* of time. It&n;&t;   turns out that with 12MB of RAM, it can take up to 16&n;&t;   seconds or so!! See the code after &quot;ABOUT INTERRUPTS&quot;&n;&t;*/
id|wavefront_should_cause_interrupt
c_func
(paren
id|hw
comma
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x10
op_or
l_int|0x1
comma
id|hw-&gt;control_port
comma
(paren
l_int|2
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Note: data port is now the data port, not the h/w initialization&n;&t;   port.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: intr not received after h/w un-reset.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|hw-&gt;interrupts_on
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ABOUT INTERRUPTS:&n;&t;   -----------------&n;&t;   &n;&t;   When we talk about interrupts, there are two kinds&n;&t;   generated by the ICS2115. The first is to signal MPU data&n;&t;   ready to read, and the second is to signal RX or TX status&n;&t;   changes. We *always* want interrupts for MPU stuff but we &n;&t;   generally avoid using RX/TX interrupts.&n;&n;&t;   In theory, we could use the TX and RX interrupts for all&n;&t;   communication with the card. However, there are 2 good&n;&t;   reasons not to do this.&n;&n;&t;   First of all, the MIDI interface is going to use the same&n;&t;   interrupt. This presents no practical problem since Linux&n;&t;   allows us to share IRQ&squot;s. However, there are times when it&n;&t;   makes sense for a user to ask the driver to disable&n;&t;   interrupts, to avoid bothering Linux with a stream of MIDI&n;&t;   interrupts that aren&squot;t going to be used because nothing&n;&t;   cares about them. If we rely on them for communication with&n;&t;   the WaveFront synth as well, this disabling would be&n;&t;   crippling. Since being able to disable them can save quite&n;&t;   a bit of overhead (consider the interrupt frequency of a&n;&t;   physical MIDI controller like a modwheel being shunted back&n;&t;   and forth - its higher than the mouse, and much of&n;&t;   the time is of absolutely no interest to the kernel or any&n;&t;   user space processes whatsoever), we don&squot;t want to do this.&n;&n;&t;   Secondly, much of the time, there&squot;s no reason to go to&n;&t;   sleep on a TX or RX status: the WaveFront gets back to us&n;&t;   quickly enough that its a lot more efficient to just busy&n;&t;   wait on the relevant status. Once we go to sleep, all is&n;&t;   lost anyway, and so interrupts don&squot;t really help us much anyway.&n;&n;&t;   Therefore, we don&squot;t use interrupts for communication with&n;&t;   the WaveFront synth. We just poll the relevant RX/TX status.&n;&n;&t;   However, there is one broad exception to this. During module&n;&t;   loading, to deal with several situations where timing would&n;&t;   be an issue, we use TX/RX interrupts to help us avoid busy&n;&t;   waiting for indeterminate and hard to manage periods of&n;&t;   time. So, TX/RX interrupts are enabled until the end of &n;&t;   wavefront_init(), and not used again after that.&n;&n;&t; */
multiline_comment|/* Note: data port is now the data port, not the h/w initialization&n;&t;   port.&n;&n;&t;   At this point, only &quot;HW VERSION&quot; or &quot;DOWNLOAD OS&quot; commands&n;&t;   will work. So, issue one of them, and wait for TX&n;&t;   interrupt. This can take a *long* time after a cold boot,&n;&t;   while the ISC ROM does its RAM test. The SDK says up to 4&n;&t;   seconds - with 12MB of RAM on a Tropez+, it takes a lot&n;&t;   longer than that (~16secs). Note that the card understands&n;&t;   the difference between a warm and a cold boot, so&n;&t;   subsequent ISC2115 reboots (say, caused by module&n;&t;   reloading) will get through this much faster.&n;&n;&t;   Interesting question: why is no RX interrupt received first ?&n;&t;*/
id|wavefront_should_cause_interrupt
c_func
(paren
id|hw
comma
id|WFC_HARDWARE_VERSION
comma
id|hw-&gt;data_port
comma
l_int|20
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: post-RAM-check interrupt not received.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|wavefront_status
c_func
(paren
id|hw
)paren
op_amp
id|STAT_CAN_READ
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: no response to HW version cmd.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: board not responding correctly.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwv
(braket
l_int|0
)braket
op_eq
l_int|0xFF
)paren
(brace
multiline_comment|/* NAK */
multiline_comment|/* Board&squot;s RAM test failed. Try to read error code,&n;&t;&t;   and tell us about it either way.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: on-board RAM test failed &quot;
l_string|&quot;(bad error code).&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: on-board RAM test failed &quot;
l_string|&quot;(error code: 0x%x).&bslash;n&quot;
comma
id|hwv
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* We&squot;re OK, just get the next byte of the HW version response */
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|1
)braket
op_assign
id|wavefront_read
(paren
id|hw
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: board not responding correctly(2).&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: hardware version %d.%d&bslash;n&quot;
comma
id|hwv
(braket
l_int|0
)braket
comma
id|hwv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|gone_bad
suffix:colon
id|free_irq
(paren
id|hw-&gt;irq
comma
id|hw
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_int
DECL|function|probe_wavefront
id|probe_wavefront
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
r_char
id|rbuf
(braket
l_int|4
)braket
comma
id|wbuf
(braket
l_int|4
)braket
suffix:semicolon
id|wf_config
op_star
id|hw
suffix:semicolon
r_if
c_cond
(paren
id|hw_config-&gt;irq
template_param
l_int|16
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: impossible IRQ suggested(%d)&bslash;n&quot;
comma
id|hw_config-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Yeah yeah, TB docs say 8, but the FX device on the Tropez Plus&n;&t;   takes up another 8 ...&n;&t;*/
r_if
c_cond
(paren
id|check_region
(paren
id|hw_config-&gt;io_base
comma
l_int|16
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: IO address range 0x%x - 0x%x &quot;
l_string|&quot;already in use - ignored&bslash;n&quot;
comma
id|hw_config-&gt;io_base
comma
id|hw_config-&gt;io_base
op_plus
l_int|15
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
id|hw-&gt;irq
op_assign
id|hw_config-&gt;irq
suffix:semicolon
id|hw-&gt;base
op_assign
id|hw_config-&gt;io_base
suffix:semicolon
id|hw-&gt;israw
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;debug
op_assign
id|debug_default
suffix:semicolon
id|hw-&gt;interrupts_on
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;rom_samples_rdonly
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX default lock on ROM sample slots */
macro_line|#ifdef WF_STATS
id|hw-&gt;status_found_during_sleep
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;status_found_during_sleep
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;status_found_during_sleep
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;status_found_during_sleep
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;status_found_during_loop
op_assign
l_int|0
suffix:semicolon
macro_line|#endif WF_STATS
id|hw_config-&gt;slots
(braket
id|WF_SYNTH_SLOT
)braket
op_assign
id|hw-&gt;synthdev
op_assign
op_minus
l_int|1
suffix:semicolon
id|hw_config-&gt;slots
(braket
id|WF_INTERNAL_MIDI_SLOT
)braket
op_assign
id|hw-&gt;mididev
op_assign
op_minus
l_int|1
suffix:semicolon
id|hw_config-&gt;slots
(braket
id|WF_EXTERNAL_MIDI_SLOT
)braket
op_assign
id|hw-&gt;ext_mididev
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_FIRMWARE_VERSION
comma
id|rbuf
comma
id|wbuf
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;fw_version
(braket
l_int|0
)braket
op_assign
id|rbuf
(braket
l_int|0
)braket
suffix:semicolon
id|hw-&gt;fw_version
(braket
l_int|1
)braket
op_assign
id|rbuf
(braket
l_int|1
)braket
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: firmware %d.%d already loaded.&bslash;n&quot;
comma
id|rbuf
(braket
l_int|0
)braket
comma
id|rbuf
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* check that a command actually works */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_HARDWARE_VERSION
comma
id|rbuf
comma
id|wbuf
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;hw_version
(braket
l_int|0
)braket
op_assign
id|rbuf
(braket
l_int|0
)braket
suffix:semicolon
id|hw-&gt;hw_version
(braket
l_int|1
)braket
op_assign
id|rbuf
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: not raw, but no &quot;
l_string|&quot;hardware version!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wf_raw
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: reloading firmware anyway.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|hw-&gt;israw
op_assign
l_int|1
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: no response to firmware probe, &quot;
l_string|&quot;assume raw.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|init_waitqueue
(paren
op_amp
id|hw-&gt;interrupt_sleeper
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_hw_reset
(paren
id|hw
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: hardware reset failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#include &quot;os.h&quot;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|errno
r_static
r_int
id|errno
suffix:semicolon
r_static
r_int
DECL|function|wavefront_download_firmware
id|wavefront_download_firmware
(paren
id|wf_config
op_star
id|hw
comma
r_char
op_star
id|path
)paren
(brace
r_int
r_char
id|section
(braket
id|WF_SECTION_MAX
)braket
suffix:semicolon
r_char
id|section_length
suffix:semicolon
multiline_comment|/* yes, just a char; max value is WF_SECTION_MAX */
r_int
id|section_cnt_downloaded
op_assign
l_int|0
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
multiline_comment|/* This tries to be a bit cleverer than the stuff Alan Cox did for&n;&t;   the generic sound firmware, in that it actually knows&n;&t;   something about the structure of the Motorola firmware. In&n;&t;   particular, it uses a version that has been stripped of the&n;&t;   20K of useless header information, and had section lengths&n;&t;   added, making it possible to load the entire OS without any&n;&t;   [kv]malloc() activity, since the longest entity we ever read is&n;&t;   42 bytes (well, WF_SECTION_MAX) long.&n;&t;*/
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_assign
id|open
(paren
id|path
comma
l_int|0
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: Unable to load &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|read
(paren
id|fd
comma
op_amp
id|section_length
comma
r_sizeof
(paren
id|section_length
)paren
)paren
)paren
op_ne
r_sizeof
(paren
id|section_length
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: firmware read error.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|section_length
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|fd
comma
id|section
comma
id|section_length
)paren
op_ne
id|section_length
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: firmware section &quot;
l_string|&quot;read error.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* Send command */
r_if
c_cond
(paren
op_logical_neg
id|wavefront_write
(paren
id|hw
comma
id|WFC_DOWNLOAD_OS
)paren
)paren
(brace
r_goto
id|failure
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|section_length
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wavefront_write
(paren
id|hw
comma
id|section
(braket
id|i
)braket
)paren
)paren
(brace
r_goto
id|failure
suffix:semicolon
)brace
)brace
multiline_comment|/* get ACK */
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|hw
comma
id|STAT_CAN_READ
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|inb
(paren
id|hw-&gt;data_port
)paren
)paren
op_ne
id|WF_ACK
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: download &quot;
l_string|&quot;of section #%d not &quot;
l_string|&quot;acknowledged, ack = 0x%x&bslash;n&quot;
comma
id|section_cnt_downloaded
op_plus
l_int|1
comma
id|c
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
op_logical_and
op_logical_neg
(paren
op_increment
id|section_cnt_downloaded
op_mod
l_int|10
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;.&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
)brace
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: timed out &quot;
l_string|&quot;for download ACK.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|close
(paren
id|fd
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
macro_line|#ifdef WF_DEBUG
r_if
c_cond
(paren
id|hw-&gt;debug
op_amp
id|WF_DEBUG_IO
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif WF_DEBUG
r_return
l_int|0
suffix:semicolon
id|failure
suffix:colon
id|close
(paren
id|fd
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;&bslash;nWaveFront: firmware download failed!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_config_midi
id|wavefront_config_midi
(paren
id|wf_config
op_star
id|hw
comma
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
r_char
id|rbuf
(braket
l_int|4
)braket
comma
id|wbuf
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_wf_mpu
(paren
id|hw_config
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: could not install &quot;
l_string|&quot;MPU-401 device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Attach an modified MPU-401 driver to the master MIDI interface */
id|hw_config-&gt;name
op_assign
l_string|&quot;WaveFront Internal MIDI&quot;
suffix:semicolon
id|attach_wf_mpu
(paren
id|hw_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw_config-&gt;slots
(braket
id|WF_INTERNAL_MIDI_SLOT
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: MPU-401 not configured.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hw-&gt;mididev
op_assign
id|hw_config-&gt;slots
(braket
id|WF_INTERNAL_MIDI_SLOT
)braket
suffix:semicolon
multiline_comment|/* Route external MIDI to WaveFront synth (by default) */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_MISYNTH_ON
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: cannot enable MIDI-IN to synth routing.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX error ? */
)brace
multiline_comment|/* Get the regular MIDI patch loading function, so we can&n;&t;   use it if we ever get handed a SYSEX patch. This is&n;&t;   unlikely, because its so damn slow, but we may as well&n;&t;   leave this functionality from maui.c behind, since it&n;&t;   could be useful for sequencer applications that can&n;&t;   only use MIDI to do patch loading.&n;&t;*/
r_if
c_cond
(paren
id|midi_devs
(braket
id|hw-&gt;mididev
)braket
op_member_access_from_pointer
id|converter
op_ne
l_int|NULL
)paren
(brace
id|midi_load_patch
op_assign
id|midi_devs
(braket
id|hw-&gt;mididev
)braket
op_member_access_from_pointer
id|converter-&gt;load_patch
suffix:semicolon
id|midi_devs
(braket
id|hw-&gt;mididev
)braket
op_member_access_from_pointer
id|converter-&gt;load_patch
op_assign
op_amp
id|wavefront_load_patch
suffix:semicolon
)brace
multiline_comment|/* Turn on Virtual MIDI, but first *always* turn it off,&n;&t;   since otherwise consectutive reloads of the driver will&n;&t;   never cause the hardware to generate the initial &quot;internal&quot; or &n;&t;   &quot;external&quot; source bytes in the MIDI data stream. This&n;&t;   is pretty important, since the internal hardware generally will&n;&t;   be used to generate none or very little MIDI output, and&n;&t;   thus the only source of MIDI data is actually external. Without&n;&t;   the switch bytes, the driver will think it all comes from&n;&t;   the internal interface. Duh.&n;&t;*/
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_VMIDI_OFF
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: cannot disable &quot;
l_string|&quot;virtual MIDI mode&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX go ahead and try anyway ? */
)brace
id|hw_config-&gt;name
op_assign
l_string|&quot;WaveFront External MIDI&quot;
suffix:semicolon
r_if
c_cond
(paren
id|virtual_midi_enable
(paren
id|hw-&gt;mididev
comma
id|hw_config
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: no virtual MIDI access.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;ext_mididev
op_assign
id|hw_config-&gt;slots
(braket
id|WF_EXTERNAL_MIDI_SLOT
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_VMIDI_ON
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: cannot enable virtual MIDI mode.&bslash;n&quot;
)paren
suffix:semicolon
id|virtual_midi_disable
(paren
id|hw-&gt;mididev
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_do_reset
id|wavefront_do_reset
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|atboot
)paren
(brace
r_char
id|voices
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atboot
op_logical_and
id|wavefront_hw_reset
(paren
id|hw
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: hw reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;israw
op_logical_or
id|wf_raw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_download_firmware
(paren
id|hw
comma
id|ospath
)paren
)paren
(brace
r_goto
id|gone_bad
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fx_raw
)paren
(brace
id|wffx_init
(paren
id|hw
)paren
suffix:semicolon
)brace
multiline_comment|/* If we loaded the OS, we now have to wait for it to be ready&n;&t;   to roll. We can&squot;t guarantee that interrupts are enabled,&n;&t;   because we might be reloading the module without forcing a&n;&t;   reset/reload of the firmware.&n;&t;   &n;&t;   Rather than busy-wait, lets just turn interrupts on.&n;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x10
op_or
l_int|0x1
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
id|wavefront_should_cause_interrupt
(paren
id|hw
comma
id|WFC_NOOP
comma
id|hw-&gt;data_port
comma
(paren
l_int|10
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: no post-OS interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* Now, do it again ! */
id|wavefront_should_cause_interrupt
(paren
id|hw
comma
id|WFC_NOOP
comma
id|hw-&gt;data_port
comma
(paren
l_int|10
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: no post-OS interrupt(2).&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* OK, no (RX/TX) interrupts any more, but leave mute&n;&t;   on. Master interrupts get enabled when we&squot;re done here.&n;&t;*/
id|outb
(paren
l_int|0x80
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
multiline_comment|/* No need for the IRQ anymore */
id|free_irq
(paren
id|hw-&gt;irq
comma
id|hw
)paren
suffix:semicolon
multiline_comment|/* SETUPSND.EXE asks for sample memory config here, but since i&n;&t;   have no idea how to interpret the result, we&squot;ll forget&n;&t;   about it.&n;&t;*/
r_if
c_cond
(paren
(paren
id|hw-&gt;freemem
op_assign
id|wavefront_freemem
(paren
id|hw
)paren
)paren
OL
l_int|0
)paren
(brace
r_goto
id|gone_bad
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: available DRAM %dk&bslash;n&quot;
comma
id|hw-&gt;freemem
op_div
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wavefront_write
(paren
id|hw
comma
l_int|0xf0
)paren
op_logical_or
op_logical_neg
id|wavefront_write
(paren
id|hw
comma
l_int|1
)paren
op_logical_or
(paren
id|wavefront_read
(paren
id|hw
)paren
OL
l_int|0
)paren
)paren
(brace
id|hw-&gt;debug
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: MPU emulation mode not set.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|voices
(braket
l_int|0
)braket
op_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|hw
comma
id|WFC_SET_NVOICES
comma
l_int|0
comma
id|voices
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: cannot set number of voices to 32.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|gone_bad
suffix:colon
multiline_comment|/* reset that sucker so that it doesn&squot;t bother us. */
id|outb
(paren
l_int|0x0
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
id|free_irq
(paren
id|hw-&gt;irq
comma
id|hw
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_init
id|wavefront_init
(paren
id|wf_config
op_star
id|hw
comma
r_int
id|atboot
)paren
(brace
r_int
id|samples_are_from_rom
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;israw
op_logical_or
id|wf_raw
)paren
(brace
id|samples_are_from_rom
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|samples_are_from_rom
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;israw
op_logical_or
id|wf_raw
op_logical_or
id|fx_raw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_do_reset
(paren
id|hw
comma
id|atboot
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|wavefront_get_sample_status
(paren
id|hw
comma
id|samples_are_from_rom
)paren
suffix:semicolon
id|wavefront_get_program_status
(paren
id|hw
)paren
suffix:semicolon
id|wavefront_get_patch_status
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Start normal operation: unreset, master interrupt enable&n;&t;   (for MPU interrupts) no mute&n;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x20
comma
id|hw-&gt;control_port
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|attach_wavefront
id|attach_wavefront
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|sound_alloc_synthdev
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: Too many synthesizers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|hw_config-&gt;slots
(braket
id|WF_SYNTH_SLOT
)braket
op_assign
id|i
suffix:semicolon
id|hw-&gt;synthdev
op_assign
id|i
suffix:semicolon
id|synth_devs
(braket
id|hw-&gt;synthdev
)braket
op_assign
op_amp
id|wavefront_operations
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_init
(paren
id|hw
comma
l_int|1
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: board could not &quot;
l_string|&quot;be initialized.&bslash;n&quot;
)paren
suffix:semicolon
id|sound_unload_synthdev
(paren
id|i
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|request_region
(paren
id|hw_config-&gt;io_base
op_plus
l_int|2
comma
l_int|6
comma
l_string|&quot;WaveFront synth&quot;
)paren
suffix:semicolon
id|request_region
(paren
id|hw_config-&gt;io_base
op_plus
l_int|8
comma
l_int|8
comma
l_string|&quot;WaveFront FX&quot;
)paren
suffix:semicolon
id|conf_printf2
(paren
l_string|&quot;WaveFront Synth&quot;
comma
id|hw_config-&gt;io_base
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MIDI)    
r_if
c_cond
(paren
id|wavefront_config_midi
(paren
id|hw
comma
id|hw_config
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: could not initialize MIDI.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: MIDI not configured at kernel-config time.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif CONFIG_MIDI
r_return
suffix:semicolon
)brace
r_void
DECL|function|unload_wavefront
id|unload_wavefront
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_struct
id|wf_config
op_star
id|hw
op_assign
op_amp
id|wavefront_configuration
suffix:semicolon
multiline_comment|/* the first two are freed by the wf_mpu code */
id|release_region
(paren
id|hw-&gt;base
op_plus
l_int|2
comma
l_int|6
)paren
suffix:semicolon
id|release_region
(paren
id|hw-&gt;base
op_plus
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|sound_unload_synthdev
(paren
id|hw-&gt;synthdev
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MIDI)
id|unload_wf_mpu
(paren
id|hw_config
)paren
suffix:semicolon
macro_line|#endif
)brace
"&f;"
multiline_comment|/***********************************************************************/
multiline_comment|/*   WaveFront FX control                                              */
multiline_comment|/***********************************************************************/
macro_line|#include &quot;yss225.h&quot;
multiline_comment|/* Control bits for the Load Control Register&n; */
DECL|macro|FX_LSB_TRANSFER
mdefine_line|#define FX_LSB_TRANSFER 0x01    /* transfer after DSP LSB byte written */
DECL|macro|FX_MSB_TRANSFER
mdefine_line|#define FX_MSB_TRANSFER 0x02    /* transfer after DSP MSB byte written */
DECL|macro|FX_AUTO_INCR
mdefine_line|#define FX_AUTO_INCR    0x04    /* auto-increment DSP address after transfer */
r_static
r_int
DECL|function|wffx_idle
id|wffx_idle
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|x
op_assign
l_int|0x80
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|x
op_assign
id|inb
(paren
id|hw-&gt;fx_status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|x
op_amp
l_int|0x80
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: FX device never idle.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|wffx_mute
id|wffx_mute
(paren
r_struct
id|wf_config
op_star
id|hw
comma
r_int
id|onoff
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|outb
(paren
id|onoff
ques
c_cond
l_int|0x02
suffix:colon
l_int|0x00
comma
id|hw-&gt;fx_op
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wffx_memset
id|wffx_memset
(paren
r_struct
id|wf_config
op_star
id|hw
comma
r_int
id|page
comma
r_int
id|addr
comma
r_int
id|cnt
comma
r_int
r_int
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|page
template_param
l_int|7
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: FX memset: &quot;
l_string|&quot;page must be &gt;= 0 and &lt;= 7&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
template_param
l_int|0x7f
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: FX memset: &quot;
l_string|&quot;addr must be &gt;= 0 and &lt;= 7f&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_eq
l_int|1
)paren
(brace
id|outb
(paren
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
id|page
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|addr
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
(braket
l_int|0
)braket
op_amp
l_int|0xff
)paren
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: FX: addr %d:%x set to 0x%x&bslash;n&quot;
comma
id|page
comma
id|addr
comma
id|data
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
id|page
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|addr
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
(paren
id|data
(braket
id|i
)braket
op_rshift
l_int|8
)paren
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
(paren
id|hw
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ne
id|cnt
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: FX memset &quot;
l_string|&quot;(0x%x, 0x%x, 0x%x, %d) incomplete&bslash;n&quot;
comma
id|page
comma
id|addr
comma
(paren
r_int
)paren
id|data
comma
id|cnt
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wffx_ioctl
id|wffx_ioctl
(paren
r_struct
id|wf_config
op_star
id|hw
comma
id|wavefront_fx_info
op_star
id|r
)paren
(brace
r_int
r_int
id|page_data
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_int
op_star
id|pd
suffix:semicolon
r_switch
c_cond
(paren
id|r-&gt;request
)paren
(brace
r_case
id|WFFX_MUTE
suffix:colon
id|wffx_mute
(paren
id|hw
comma
id|r-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFFX_MEMSET
suffix:colon
r_if
c_cond
(paren
id|r-&gt;data
(braket
l_int|2
)braket
op_le
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: cannot write &quot;
l_string|&quot;&lt;= 0 bytes to FX&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r-&gt;data
(braket
l_int|2
)braket
op_eq
l_int|1
)paren
(brace
id|pd
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|r-&gt;data
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|r-&gt;data
(braket
l_int|2
)braket
OG
r_sizeof
(paren
id|page_data
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;WaveFront: cannot write &quot;
l_string|&quot;&gt; 255 bytes to FX&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|copy_from_user
(paren
id|page_data
comma
(paren
r_int
r_char
op_star
)paren
id|r-&gt;data
(braket
l_int|3
)braket
comma
id|r-&gt;data
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pd
op_assign
id|page_data
suffix:semicolon
)brace
r_return
id|wffx_memset
(paren
id|hw
comma
id|r-&gt;data
(braket
l_int|0
)braket
comma
multiline_comment|/* page */
id|r-&gt;data
(braket
l_int|1
)braket
comma
multiline_comment|/* addr */
id|r-&gt;data
(braket
l_int|2
)braket
comma
multiline_comment|/* cnt */
id|pd
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;WaveFront: FX: ioctl %d not yet supported&bslash;n&quot;
comma
id|r-&gt;request
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* YSS225 initialization.&n;&n;   This code was developed using DOSEmu.  The Turtle Beach SETUPSND&n;   utility was run with I/O tracing in DOSEmu enabled, and a reconstruction&n;   of the port I/O done, using the Yamaha faxback document as a guide&n;   to add more logic to the code.  It&squot;s really pretty weird.&n;&n;   There was an alternative approach of just dumping the whole I/O&n;   sequence as a series of port/value pairs and a simple loop&n;   that output it.  However, I hope that eventually I&squot;ll get more&n;   control over what this code does, and so I tried to stick with&n;   a somewhat &quot;algorithmic&quot; approach.&n;*/
r_static
r_int
DECL|function|wffx_init
id|wffx_init
(paren
r_struct
id|wf_config
op_star
id|hw
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* Set all bits for all channels on the MOD unit to zero */
multiline_comment|/* XXX But why do this twice ? */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|2
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0xff
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
(paren
id|hw
)paren
)paren
(brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_op
)paren
suffix:semicolon
multiline_comment|/* mute on */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x44
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x42
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x43
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x7c
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x7e
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x46
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x49
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x47
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x4a
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
multiline_comment|/* either because of stupidity by TB&squot;s programmers, or because it&n;&t;   actually does something, rezero the MOD page.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0xff
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
(paren
id|hw
)paren
)paren
(brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
)brace
multiline_comment|/* load page zero */
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_zero
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_zero
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_zero
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Now load page one */
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x01
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_one
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_one
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_one
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_two
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_two
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_three
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_three
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x04
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_four
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_four
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Load memory area (page six) */
id|outb
(paren
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x06
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_six
)paren
suffix:semicolon
id|i
op_add_assign
l_int|3
)paren
(brace
id|outb
(paren
id|page_six
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|page_six
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_six
(braket
id|i
op_plus
l_int|2
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_seven
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_seven
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_seven
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Now setup the MOD area. We do this algorithmically in order to&n;&t;   save a little data space. It could be done in the same fashion&n;&t;   as the &quot;pages&quot;.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
op_le
l_int|0x0f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
l_int|0x01
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0xb0
suffix:semicolon
id|i
op_le
l_int|0xbf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0xf0
suffix:semicolon
id|i
op_le
l_int|0xff
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0x1d
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x1e
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x1f
suffix:semicolon
id|i
op_le
l_int|0x2d
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x2e
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x2f
suffix:semicolon
id|i
op_le
l_int|0x3e
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x3f
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x40
suffix:semicolon
id|i
op_le
l_int|0x4d
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x4e
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0e
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x4f
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0e
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x50
suffix:semicolon
id|i
op_le
l_int|0x6b
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x6c
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x6d
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x6e
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x6f
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x70
suffix:semicolon
id|i
op_le
l_int|0x7f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0xc0
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x80
suffix:semicolon
id|i
op_le
l_int|0xaf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0xc0
suffix:semicolon
id|i
op_le
l_int|0xdd
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0xde
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0xdf
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0xe0
suffix:semicolon
id|i
op_le
l_int|0xef
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
op_le
l_int|0x0f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
l_int|0x01
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
id|i
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x01
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_op
)paren
suffix:semicolon
multiline_comment|/* mute on */
multiline_comment|/* Now set the coefficients and so forth for the programs above */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|coefficients
)paren
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
id|outb
(paren
id|coefficients
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|coefficients
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|coefficients
(braket
id|i
op_plus
l_int|2
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|coefficients
(braket
id|i
op_plus
l_int|3
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Some settings (?) that are too small to bundle into loops */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x1e
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x14
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0xde
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0xdf
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
multiline_comment|/* some more coefficients */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x06
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x78
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0f
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0b
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0f
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0a
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x46
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x49
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
multiline_comment|/* Now, for some strange reason, lets reload every page&n;&t;   and all the coefficients over again. I have *NO* idea&n;&t;   why this is done. I do know that no sound is produced&n;&t;   is this phase is omitted.&n;&t;*/
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_zero_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_zero_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_zero_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x01
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_one_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_one_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_one_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_two_v2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_two_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_three_v2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_three_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x04
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_four_v2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_four_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x06
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
multiline_comment|/* Page six v.2 is algorithmic */
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0x3e
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|i
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|hw-&gt;fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_seven_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_seven_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_seven_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|mod_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|mod_v2
(braket
id|i
)braket
comma
id|hw-&gt;fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
id|mod_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|coefficients2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
id|outb
(paren
id|coefficients2
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|coefficients2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|coefficients2
(braket
id|i
op_plus
l_int|2
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|coefficients2
(braket
id|i
op_plus
l_int|3
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_op
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
id|hw
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|coefficients3
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_int
id|x
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|hw-&gt;fx_dsp_page
)paren
suffix:semicolon
id|x
op_assign
(paren
id|i
op_mod
l_int|4
)paren
ques
c_cond
l_int|0x4e
suffix:colon
l_int|0x4c
suffix:semicolon
id|outb
(paren
id|x
comma
id|hw-&gt;fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|coefficients3
(braket
id|i
)braket
comma
id|hw-&gt;fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|coefficients3
(braket
id|i
op_plus
l_int|1
)braket
comma
id|hw-&gt;fx_dsp_lsb
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x00
comma
id|hw-&gt;fx_op
)paren
suffix:semicolon
multiline_comment|/* mute off */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|variable|cfg
r_struct
id|address_info
id|cfg
suffix:semicolon
DECL|variable|io
r_int
id|io
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|irq
r_int
id|irq
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
id|printk
(paren
l_string|&quot;Turtle Beach WaveFront Driver&bslash;n&quot;
l_string|&quot;Copyright (C) by Hannu Savolainen, &quot;
l_string|&quot;Paul Barton-Davis 1993-1998.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
op_minus
l_int|1
op_logical_or
id|irq
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;WaveFront: irq and io &quot;
l_string|&quot;options must be set.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|cfg.io_base
op_assign
id|io
suffix:semicolon
id|cfg.irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|probe_wavefront
(paren
op_amp
id|cfg
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|attach_wavefront
(paren
op_amp
id|cfg
)paren
suffix:semicolon
id|SOUND_LOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|unload_wavefront
(paren
op_amp
id|cfg
)paren
suffix:semicolon
id|SOUND_LOCK_END
suffix:semicolon
)brace
macro_line|#endif CONFIG_SOUND_WAVEFRONT_MODULE_AND_MODULE
eof
