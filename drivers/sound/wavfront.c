multiline_comment|/*  -*- linux-c -*-&n; *&n; * sound/wavfront.c&n; *&n; * A Linux driver for Turtle Beach WaveFront Series (Maui, Tropez, Tropez Plus)&n; *&n; * This driver supports the onboard wavetable synthesizer (an ICS2115),&n; * including patch, sample and program loading and unloading, conversion&n; * of GUS patches during loading, and full user-level access to all&n; * WaveFront commands. It tries to provide semi-intelligent patch and&n; * sample management as well.&n; *&n; * It also provides support for the ICS emulation of an MPU-401.  Full&n; * support for the ICS emulation&squot;s &quot;virtual MIDI mode&quot; is provided in&n; * wf_midi.c.&n; *&n; * Support is also provided for the Tropez Plus&squot; onboard FX processor,&n; * a Yamaha YSS225. Currently, code exists to configure the YSS225,&n; * and there is an interface allowing tweaking of any of its memory&n; * addresses. However, I have been unable to decipher the logical&n; * positioning of the configuration info for various effects, so for&n; * now, you just get the YSS225 in the same state as Turtle Beach&squot;s&n; * &quot;SETUPSND.EXE&quot; utility leaves it.&n; *&n; * The boards&squot; DAC/ADC (a Crystal CS4232) is supported by cs4232.[co],&n; * This chip also controls the configuration of the card: the wavefront&n; * synth is logical unit 4.&n; *&n; *&n; * Supported devices:&n; *&n; *   /dev/dsp                      - using cs4232+ad1848 modules, OSS compatible&n; *   /dev/midiNN and /dev/midiNN+1 - using wf_midi code, OSS compatible&n; *   /dev/synth00                  - raw synth interface&n; * &n; **********************************************************************&n; *&n; * Copyright (C) by Paul Barton-Davis 1998&n; *&n; * Some portions of this file are taken from work that is&n; * copyright (C) by Hannu Savolainen 1993-1996&n; *&n; * Although the relevant code here is all new, the handling of&n; * sample/alias/multi- samples is entirely based on a driver by Matt&n; * Martin and Rutger Nijlunsing which demonstrated how to get things&n; * to work correctly. The GUS patch loading code has been almost&n; * unaltered by me, except to fit formatting and function names in the&n; * rest of the file. Many thanks to them.&n; *&n; * Appreciation and thanks to Hannu Savolainen for his early work on the Maui&n; * driver, and answering a few questions while this one was developed.&n; *&n; * Absolutely NO thanks to Turtle Beach/Voyetra and Yamaha for their&n; * complete lack of help in developing this driver, and in particular&n; * for their utter silence in response to questions about undocumented&n; * aspects of configuring a WaveFront soundcard, particularly the&n; * effects processor.&n; *&n; * $Id: wavfront.c,v 0.7 1998/09/09 15:47:36 pbd Exp $&n; *&n; * This program is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)&n; * Version 2 (June 1991). See the &quot;COPYING&quot; file distributed with this software&n; * for more info.&n; *&n; * Changes:&n; * 11-10-2000&t;Bartlomiej Zolnierkiewicz &lt;bkz@linux-ide.org&gt;&n; *&t;&t;Added some __init and __initdata to entries in yss225.c&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;    
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &lt;linux/wavefront.h&gt;
multiline_comment|/*&n; *&t;This sucks, hopefully it&squot;ll get standardised&n; */
macro_line|#if defined(__alpha__)
macro_line|#ifdef CONFIG_SMP
DECL|macro|LOOPS_PER_TICK
mdefine_line|#define LOOPS_PER_TICK cpu_data[smp_processor_id()].loops_per_jiffy
macro_line|#else
DECL|macro|LOOPS_PER_TICK
mdefine_line|#define LOOPS_PER_TICK&t;loops_per_sec
macro_line|#endif
macro_line|#endif
macro_line|#if defined(__i386__)
DECL|macro|LOOPS_PER_TICK
mdefine_line|#define LOOPS_PER_TICK current_cpu_data.loops_per_jiffy
macro_line|#endif
DECL|macro|_MIDI_SYNTH_C_
mdefine_line|#define _MIDI_SYNTH_C_
DECL|macro|MIDI_SYNTH_NAME
mdefine_line|#define MIDI_SYNTH_NAME&t;&quot;WaveFront MIDI&quot;
DECL|macro|MIDI_SYNTH_CAPS
mdefine_line|#define MIDI_SYNTH_CAPS&t;SYNTH_CAP_INPUT
macro_line|#include &quot;midi_synth.h&quot;
multiline_comment|/* Compile-time control of the extent to which OSS is supported.&n;&n;   I consider /dev/sequencer to be an anachronism, but given its&n;   widespread usage by various Linux MIDI software, it seems worth&n;   offering support to it if its not too painful. Instead of using&n;   /dev/sequencer, I recommend:&n;&n;     for synth programming and patch loading: /dev/synthNN&n;     for kernel-synchronized MIDI sequencing: the ALSA sequencer&n;     for direct MIDI control: /dev/midiNN&n;&n;   I have never tried static compilation into the kernel. The #if&squot;s&n;   for this are really just notes to myself about what the code is&n;   for.&n;*/
DECL|macro|OSS_SUPPORT_SEQ
mdefine_line|#define OSS_SUPPORT_SEQ            0x1  /* use of /dev/sequencer */
DECL|macro|OSS_SUPPORT_STATIC_INSTALL
mdefine_line|#define OSS_SUPPORT_STATIC_INSTALL 0x2  /* static compilation into kernel */
DECL|macro|OSS_SUPPORT_LEVEL
mdefine_line|#define OSS_SUPPORT_LEVEL          0x1  /* just /dev/sequencer for now */
macro_line|#if    OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
DECL|variable|midi_load_patch
r_static
r_int
(paren
op_star
id|midi_load_patch
)paren
(paren
r_int
id|devno
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif OSS_SUPPORT_SEQ
multiline_comment|/* if WF_DEBUG not defined, no run-time debugging messages will&n;   be available via the debug flag setting. Given the current&n;   beta state of the driver, this will remain set until a future &n;   version.&n;*/
DECL|macro|WF_DEBUG
mdefine_line|#define WF_DEBUG 1
macro_line|#ifdef WF_DEBUG
multiline_comment|/* Thank goodness for gcc&squot;s preprocessor ... */
DECL|macro|DPRINT
mdefine_line|#define DPRINT(cond, format, args...) &bslash;&n;       if ((dev.debug &amp; (cond)) == (cond)) { &bslash;&n;&t;     printk (KERN_DEBUG LOGNAME format, ## args); &bslash;&n;       }
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(cond, format, args...)
macro_line|#endif
DECL|macro|LOGNAME
mdefine_line|#define LOGNAME &quot;WaveFront: &quot;
multiline_comment|/* bitmasks for WaveFront status port value */
DECL|macro|STAT_RINTR_ENABLED
mdefine_line|#define STAT_RINTR_ENABLED&t;0x01
DECL|macro|STAT_CAN_READ
mdefine_line|#define STAT_CAN_READ&t;&t;0x02
DECL|macro|STAT_INTR_READ
mdefine_line|#define STAT_INTR_READ&t;&t;0x04
DECL|macro|STAT_WINTR_ENABLED
mdefine_line|#define STAT_WINTR_ENABLED&t;0x10
DECL|macro|STAT_CAN_WRITE
mdefine_line|#define STAT_CAN_WRITE&t;&t;0x20
DECL|macro|STAT_INTR_WRITE
mdefine_line|#define STAT_INTR_WRITE&t;&t;0x40
multiline_comment|/*** Module-accessible parameters ***************************************/
DECL|variable|wf_raw
r_int
id|wf_raw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we normally check for &quot;raw state&quot; to firmware&n;&t;&t;   loading. if set, then during driver loading, the&n;&t;&t;   state of the board is ignored, and we reset the&n;&t;&t;   board and load the firmware anyway.&n;&t;&t;*/
DECL|variable|fx_raw
r_int
id|fx_raw
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if this is zero, we&squot;ll leave the FX processor in&n;&t;&t;   whatever state it is when the driver is loaded.&n;&t;&t;   The default is to download the microprogram and&n;&t;&t;   associated coefficients to set it up for &quot;default&quot;&n;&t;&t;   operation, whatever that means.&n;&t;&t;*/
DECL|variable|debug_default
r_int
id|debug_default
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* you can set this to control debugging&n;&t;&t;&t;      during driver loading. it takes any combination&n;&t;&t;&t;      of the WF_DEBUG_* flags defined in&n;&t;&t;&t;      wavefront.h&n;&t;&t;&t;   */
multiline_comment|/* XXX this needs to be made firmware and hardware version dependent */
DECL|variable|ospath
r_char
op_star
id|ospath
op_assign
l_string|&quot;/etc/sound/wavefront.os&quot;
suffix:semicolon
multiline_comment|/* where to find a processed&n;&t;&t;&t;&t;&t;     version of the WaveFront OS&n;&t;&t;&t;&t;&t;  */
DECL|variable|wait_usecs
r_int
id|wait_usecs
op_assign
l_int|150
suffix:semicolon
multiline_comment|/* This magic number seems to give pretty optimal&n;&t;&t;&t; throughput based on my limited experimentation.&n;&t;&t;&t; If you want to play around with it and find a better&n;&t;&t;&t; value, be my guest. Remember, the idea is to&n;&t;&t;&t; get a number that causes us to just busy wait&n;&t;&t;&t; for as many WaveFront commands as possible, without&n;&t;&t;&t; coming up with a number so large that we hog the&n;&t;&t;&t; whole CPU.&n;&n;&t;&t;&t; Specifically, with this number, out of about 134,000&n;&t;&t;&t; status waits, only about 250 result in a sleep.&n;&t;&t;      */
DECL|variable|sleep_interval
r_int
id|sleep_interval
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* HZ/sleep_interval seconds per sleep */
DECL|variable|sleep_tries
r_int
id|sleep_tries
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* number of times we&squot;ll try to sleep */
DECL|variable|reset_time
r_int
id|reset_time
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* hundreths of a second we wait after a HW reset for&n;&t;&t;&t;      the expected interrupt.&n;&t;&t;&t;   */
DECL|variable|ramcheck_time
r_int
id|ramcheck_time
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* time in seconds to wait while ROM code&n;&t;&t;&t;      checks on-board RAM.&n;&t;&t;&t;   */
DECL|variable|osrun_time
r_int
id|osrun_time
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* time in seconds we wait for the OS to&n;&t;&t;&t;      start running.&n;&t;&t;&t;   */
id|MODULE_PARM
c_func
(paren
id|wf_raw
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|fx_raw
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug_default
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|wait_usecs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sleep_interval
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sleep_tries
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ospath
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|reset_time
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ramcheck_time
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|osrun_time
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/***************************************************************************/
multiline_comment|/* Note: because this module doesn&squot;t export any symbols, this really isn&squot;t&n;   a global variable, even if it looks like one. I was quite confused by&n;   this when I started writing this as a (newer) module -- pbd.&n;*/
DECL|struct|wf_config
r_struct
id|wf_config
(brace
DECL|member|devno
r_int
id|devno
suffix:semicolon
multiline_comment|/* device number from kernel */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* &quot;you were one, one of the few ...&quot; */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* low i/o port address */
DECL|macro|mpu_data_port
mdefine_line|#define mpu_data_port    base 
DECL|macro|mpu_command_port
mdefine_line|#define mpu_command_port base + 1 /* write semantics */
DECL|macro|mpu_status_port
mdefine_line|#define mpu_status_port  base + 1 /* read semantics */
DECL|macro|data_port
mdefine_line|#define data_port        base + 2 
DECL|macro|status_port
mdefine_line|#define status_port      base + 3 /* read semantics */
DECL|macro|control_port
mdefine_line|#define control_port     base + 3 /* write semantics  */
DECL|macro|block_port
mdefine_line|#define block_port       base + 4 /* 16 bit, writeonly */
DECL|macro|last_block_port
mdefine_line|#define last_block_port  base + 6 /* 16 bit, writeonly */
multiline_comment|/* FX ports. These are mapped through the ICS2115 to the YS225.&n;&t;   The ICS2115 takes care of flipping the relevant pins on the&n;&t;   YS225 so that access to each of these ports does the right&n;&t;   thing. Note: these are NOT documented by Turtle Beach.&n;&t;*/
DECL|macro|fx_status
mdefine_line|#define fx_status       base + 8 
DECL|macro|fx_op
mdefine_line|#define fx_op           base + 8 
DECL|macro|fx_lcr
mdefine_line|#define fx_lcr          base + 9 
DECL|macro|fx_dsp_addr
mdefine_line|#define fx_dsp_addr     base + 0xa
DECL|macro|fx_dsp_page
mdefine_line|#define fx_dsp_page     base + 0xb 
DECL|macro|fx_dsp_lsb
mdefine_line|#define fx_dsp_lsb      base + 0xc 
DECL|macro|fx_dsp_msb
mdefine_line|#define fx_dsp_msb      base + 0xd 
DECL|macro|fx_mod_addr
mdefine_line|#define fx_mod_addr     base + 0xe
DECL|macro|fx_mod_data
mdefine_line|#define fx_mod_data     base + 0xf 
DECL|member|irq_ok
r_volatile
r_int
id|irq_ok
suffix:semicolon
multiline_comment|/* set by interrupt handler */
DECL|member|irq_cnt
r_volatile
r_int
id|irq_cnt
suffix:semicolon
multiline_comment|/* ditto */
DECL|member|opened
r_int
id|opened
suffix:semicolon
multiline_comment|/* flag, holds open(2) mode */
DECL|member|debug
r_char
id|debug
suffix:semicolon
multiline_comment|/* debugging flags */
DECL|member|freemem
r_int
id|freemem
suffix:semicolon
multiline_comment|/* installed RAM, in bytes */
DECL|member|synth_dev
r_int
id|synth_dev
suffix:semicolon
multiline_comment|/* devno for &quot;raw&quot; synth */
DECL|member|mididev
r_int
id|mididev
suffix:semicolon
multiline_comment|/* devno for internal MIDI */
DECL|member|ext_mididev
r_int
id|ext_mididev
suffix:semicolon
multiline_comment|/* devno for external MIDI */
DECL|member|fx_mididev
r_int
id|fx_mididev
suffix:semicolon
multiline_comment|/* devno for FX MIDI interface */
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
DECL|member|oss_dev
r_int
id|oss_dev
suffix:semicolon
multiline_comment|/* devno for OSS sequencer synth */
macro_line|#endif OSS_SUPPORT_SEQ
DECL|member|fw_version
r_char
id|fw_version
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* major = [0], minor = [1] */
DECL|member|hw_version
r_char
id|hw_version
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* major = [0], minor = [1] */
DECL|member|israw
r_char
id|israw
suffix:semicolon
multiline_comment|/* needs Motorola microcode */
DECL|member|has_fx
r_char
id|has_fx
suffix:semicolon
multiline_comment|/* has FX processor (Tropez+) */
DECL|member|prog_status
r_char
id|prog_status
(braket
id|WF_MAX_PROGRAM
)braket
suffix:semicolon
multiline_comment|/* WF_SLOT_* */
DECL|member|patch_status
r_char
id|patch_status
(braket
id|WF_MAX_PATCH
)braket
suffix:semicolon
multiline_comment|/* WF_SLOT_* */
DECL|member|sample_status
r_char
id|sample_status
(braket
id|WF_MAX_SAMPLE
)braket
suffix:semicolon
multiline_comment|/* WF_ST_* | WF_SLOT_* */
DECL|member|samples_used
r_int
id|samples_used
suffix:semicolon
multiline_comment|/* how many */
DECL|member|interrupts_on
r_char
id|interrupts_on
suffix:semicolon
multiline_comment|/* h/w MPU interrupts enabled ? */
DECL|member|rom_samples_rdonly
r_char
id|rom_samples_rdonly
suffix:semicolon
multiline_comment|/* can we write on ROM samples */
DECL|member|interrupt_sleeper
id|wait_queue_head_t
id|interrupt_sleeper
suffix:semicolon
DECL|variable|dev
)brace
id|dev
suffix:semicolon
r_static
r_int
id|detect_wffx
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|wffx_ioctl
(paren
id|wavefront_fx_info
op_star
)paren
suffix:semicolon
r_static
r_int
id|wffx_init
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|wavefront_delete_sample
(paren
r_int
id|sampnum
)paren
suffix:semicolon
r_static
r_int
id|wavefront_find_free_sample
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* From wf_midi.c */
r_extern
r_int
id|virtual_midi_enable
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|virtual_midi_disable
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|detect_wf_mpu
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|install_wf_mpu
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|uninstall_wf_mpu
(paren
r_void
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|cmd
r_int
id|cmd
suffix:semicolon
DECL|member|action
r_char
op_star
id|action
suffix:semicolon
DECL|member|read_cnt
r_int
r_int
id|read_cnt
suffix:semicolon
DECL|member|write_cnt
r_int
r_int
id|write_cnt
suffix:semicolon
DECL|member|need_ack
r_int
id|need_ack
suffix:semicolon
DECL|typedef|wavefront_command
)brace
id|wavefront_command
suffix:semicolon
r_static
r_struct
(brace
DECL|member|errno
r_int
id|errno
suffix:semicolon
DECL|member|errstr
r_const
r_char
op_star
id|errstr
suffix:semicolon
DECL|variable|wavefront_errors
)brace
id|wavefront_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x01
comma
l_string|&quot;Bad sample number&quot;
)brace
comma
(brace
l_int|0x02
comma
l_string|&quot;Out of sample memory&quot;
)brace
comma
(brace
l_int|0x03
comma
l_string|&quot;Bad patch number&quot;
)brace
comma
(brace
l_int|0x04
comma
l_string|&quot;Error in number of voices&quot;
)brace
comma
(brace
l_int|0x06
comma
l_string|&quot;Sample load already in progress&quot;
)brace
comma
(brace
l_int|0x0B
comma
l_string|&quot;No sample load request pending&quot;
)brace
comma
(brace
l_int|0x0E
comma
l_string|&quot;Bad MIDI channel number&quot;
)brace
comma
(brace
l_int|0x10
comma
l_string|&quot;Download Record Error&quot;
)brace
comma
(brace
l_int|0x80
comma
l_string|&quot;Success&quot;
)brace
comma
(brace
l_int|0x0
comma
l_int|0x0
)brace
)brace
suffix:semicolon
DECL|macro|NEEDS_ACK
mdefine_line|#define NEEDS_ACK 1
DECL|variable|wavefront_commands
r_static
id|wavefront_command
id|wavefront_commands
(braket
)braket
op_assign
(brace
(brace
id|WFC_SET_SYNTHVOL
comma
l_string|&quot;set synthesizer volume&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_SYNTHVOL
comma
l_string|&quot;get synthesizer volume&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_NVOICES
comma
l_string|&quot;set number of voices&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_NVOICES
comma
l_string|&quot;get number of voices&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_TUNING
comma
l_string|&quot;set synthesizer tuning&quot;
comma
l_int|0
comma
l_int|2
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_TUNING
comma
l_string|&quot;get synthesizer tuning&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DISABLE_CHANNEL
comma
l_string|&quot;disable synth channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_ENABLE_CHANNEL
comma
l_string|&quot;enable synth channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_CHANNEL_STATUS
comma
l_string|&quot;get synth channel status&quot;
comma
l_int|3
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_MISYNTH_OFF
comma
l_string|&quot;disable midi-in to synth&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_MISYNTH_ON
comma
l_string|&quot;enable midi-in to synth&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_VMIDI_ON
comma
l_string|&quot;enable virtual midi mode&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_VMIDI_OFF
comma
l_string|&quot;disable virtual midi mode&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_MIDI_STATUS
comma
l_string|&quot;report midi status&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_FIRMWARE_VERSION
comma
l_string|&quot;report firmware version&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_HARDWARE_VERSION
comma
l_string|&quot;report hardware version&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_GET_NSAMPLES
comma
l_string|&quot;report number of samples&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_INSTOUT_LEVELS
comma
l_string|&quot;report instantaneous output levels&quot;
comma
l_int|7
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_PEAKOUT_LEVELS
comma
l_string|&quot;report peak output levels&quot;
comma
l_int|7
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE
comma
l_string|&quot;download sample&quot;
comma
l_int|0
comma
id|WF_SAMPLE_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DOWNLOAD_BLOCK
comma
l_string|&quot;download block&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE_HEADER
comma
l_string|&quot;download sample header&quot;
comma
l_int|0
comma
id|WF_SAMPLE_HDR_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_HEADER
comma
l_string|&quot;upload sample header&quot;
comma
l_int|13
comma
l_int|2
comma
l_int|0
)brace
comma
multiline_comment|/* This command requires a variable number of bytes to be written.&n;&t;   There is a hack in wavefront_cmd() to support this. The actual&n;&t;   count is passed in as the read buffer ptr, cast appropriately.&n;&t;   Ugh.&n;&t;*/
(brace
id|WFC_DOWNLOAD_MULTISAMPLE
comma
l_string|&quot;download multisample&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
multiline_comment|/* This one is a hack as well. We just read the first byte of the&n;&t;   response, don&squot;t fetch an ACK, and leave the rest to the &n;&t;   calling function. Ugly, ugly, ugly.&n;&t;*/
(brace
id|WFC_UPLOAD_MULTISAMPLE
comma
l_string|&quot;upload multisample&quot;
comma
l_int|2
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE_ALIAS
comma
l_string|&quot;download sample alias&quot;
comma
l_int|0
comma
id|WF_ALIAS_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_ALIAS
comma
l_string|&quot;upload sample alias&quot;
comma
id|WF_ALIAS_BYTES
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_DELETE_SAMPLE
comma
l_string|&quot;delete sample&quot;
comma
l_int|0
comma
l_int|2
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_IDENTIFY_SAMPLE_TYPE
comma
l_string|&quot;identify sample type&quot;
comma
l_int|5
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_PARAMS
comma
l_string|&quot;upload sample parameters&quot;
)brace
comma
(brace
id|WFC_REPORT_FREE_MEMORY
comma
l_string|&quot;report free memory&quot;
comma
l_int|4
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_PATCH
comma
l_string|&quot;download patch&quot;
comma
l_int|0
comma
l_int|134
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_PATCH
comma
l_string|&quot;upload patch&quot;
comma
l_int|132
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_PROGRAM
comma
l_string|&quot;download program&quot;
comma
l_int|0
comma
l_int|33
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_PROGRAM
comma
l_string|&quot;upload program&quot;
comma
l_int|32
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_EDRUM_PROGRAM
comma
l_string|&quot;download enhanced drum program&quot;
comma
l_int|0
comma
l_int|9
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_EDRUM_PROGRAM
comma
l_string|&quot;upload enhanced drum program&quot;
comma
l_int|8
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_EDRUM_CHANNEL
comma
l_string|&quot;set enhanced drum program channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DISABLE_DRUM_PROGRAM
comma
l_string|&quot;disable drum program&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_REPORT_CHANNEL_PROGRAMS
comma
l_string|&quot;report channel program numbers&quot;
comma
l_int|32
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_NOOP
comma
l_string|&quot;the no-op command&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
l_int|0x00
)brace
)brace
suffix:semicolon
r_static
r_const
r_char
op_star
DECL|function|wavefront_errorstr
id|wavefront_errorstr
(paren
r_int
id|errnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|wavefront_errors
(braket
id|i
)braket
dot
id|errstr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_errors
(braket
id|i
)braket
dot
id|errno
op_eq
id|errnum
)paren
(brace
r_return
id|wavefront_errors
(braket
id|i
)braket
dot
id|errstr
suffix:semicolon
)brace
)brace
r_return
l_string|&quot;Unknown WaveFront error&quot;
suffix:semicolon
)brace
r_static
id|wavefront_command
op_star
DECL|function|wavefront_get_command
id|wavefront_get_command
(paren
r_int
id|cmd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|wavefront_commands
(braket
id|i
)braket
dot
id|cmd
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|wavefront_commands
(braket
id|i
)braket
dot
id|cmd
)paren
(brace
r_return
op_amp
id|wavefront_commands
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_return
(paren
id|wavefront_command
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|wavefront_status
id|wavefront_status
(paren
r_void
)paren
(brace
r_return
id|inb
(paren
id|dev.status_port
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_sleep
id|wavefront_sleep
(paren
r_int
id|limit
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|limit
)paren
suffix:semicolon
r_return
id|signal_pending
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_wait
id|wavefront_wait
(paren
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_int
id|short_loop_cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute the loop count that lets us sleep for about the&n;&t;   right amount of time, cache issues, bus speeds and all&n;&t;   other issues being unequal but largely irrelevant.&n;&t;*/
r_if
c_cond
(paren
id|short_loop_cnt
op_eq
l_int|0
)paren
(brace
id|short_loop_cnt
op_assign
id|wait_usecs
op_star
(paren
id|LOOPS_PER_TICK
op_div
(paren
l_int|1000000
op_div
id|HZ
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Spin for a short period of time, because &gt;99% of all&n;&t;   requests to the WaveFront can be serviced inline like this.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|short_loop_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_status
c_func
(paren
)paren
op_amp
id|mask
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sleep_tries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_status
c_func
(paren
)paren
op_amp
id|mask
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_sleep
(paren
id|HZ
op_div
id|sleep_interval
)paren
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_read
id|wavefront_read
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|STAT_CAN_READ
)paren
)paren
r_return
id|inb
(paren
id|dev.data_port
)paren
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;read timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_write
id|wavefront_write
(paren
r_int
r_char
id|data
)paren
(brace
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|STAT_CAN_WRITE
)paren
)paren
(brace
id|outb
(paren
id|data
comma
id|dev.data_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;write timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_cmd
id|wavefront_cmd
(paren
r_int
id|cmd
comma
r_int
r_char
op_star
id|rbuf
comma
r_int
r_char
op_star
id|wbuf
)paren
(brace
r_int
id|ack
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|c
suffix:semicolon
id|wavefront_command
op_star
id|wfcmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wfcmd
op_assign
id|wavefront_get_command
(paren
id|cmd
)paren
)paren
op_eq
(paren
id|wavefront_command
op_star
)paren
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;command 0x%x not supported.&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Hack to handle the one variable-size write command. See&n;&t;   wavefront_send_multisample() for the other half of this&n;&t;   gross and ugly strategy.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_eq
id|WFC_DOWNLOAD_MULTISAMPLE
)paren
(brace
id|wfcmd-&gt;write_cnt
op_assign
(paren
r_int
r_int
)paren
id|rbuf
suffix:semicolon
id|rbuf
op_assign
l_int|0
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;0x%x [%s] (%d,%d,%d)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|wfcmd-&gt;read_cnt
comma
id|wfcmd-&gt;write_cnt
comma
id|wfcmd-&gt;need_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_write
(paren
id|cmd
)paren
)paren
(brace
id|DPRINT
(paren
(paren
id|WF_DEBUG_IO
op_or
id|WF_DEBUG_CMD
)paren
comma
l_string|&quot;cannot request &quot;
l_string|&quot;0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wfcmd-&gt;write_cnt
OG
l_int|0
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;writing %d bytes &quot;
l_string|&quot;for 0x%x&bslash;n&quot;
comma
id|wfcmd-&gt;write_cnt
comma
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wfcmd-&gt;write_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_write
(paren
id|wbuf
(braket
id|i
)braket
)paren
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;bad write for byte &quot;
l_string|&quot;%d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;write[%d] = 0x%x&bslash;n&quot;
comma
id|i
comma
id|wbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wfcmd-&gt;read_cnt
OG
l_int|0
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;reading %d ints &quot;
l_string|&quot;for 0x%x&bslash;n&quot;
comma
id|wfcmd-&gt;read_cnt
comma
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wfcmd-&gt;read_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|wavefront_read
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;bad read for byte &quot;
l_string|&quot;%d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now handle errors. Lots of special cases here */
r_if
c_cond
(paren
id|c
op_eq
l_int|0xff
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;bad read for &quot;
l_string|&quot;error byte at &quot;
l_string|&quot;read byte %d &quot;
l_string|&quot;of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Can you believe this madness ? */
r_if
c_cond
(paren
id|c
op_eq
l_int|1
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_IDENTIFY_SAMPLE_TYPE
)paren
(brace
id|rbuf
(braket
l_int|0
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|3
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_UPLOAD_PATCH
)paren
(brace
r_return
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|1
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_UPLOAD_PROGRAM
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;error %d (%s) &quot;
l_string|&quot;during &quot;
l_string|&quot;read for byte &quot;
l_string|&quot;%d of 0x%x &quot;
l_string|&quot;[%s].&bslash;n&quot;
comma
id|c
comma
id|wavefront_errorstr
(paren
id|c
)paren
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|rbuf
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;read[%d] = 0x%x&bslash;n&quot;
comma
id|i
comma
id|rbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|wfcmd-&gt;read_cnt
op_eq
l_int|0
op_logical_and
id|wfcmd-&gt;write_cnt
op_eq
l_int|0
)paren
op_logical_or
id|wfcmd-&gt;need_ack
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;reading ACK for 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Some commands need an ACK, but return zero instead&n;&t;&t;   of the standard value.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|ack
op_assign
id|wavefront_read
c_func
(paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ack
op_assign
id|WF_ACK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ack
op_ne
id|WF_ACK
)paren
(brace
r_if
c_cond
(paren
id|ack
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;cannot read ack for &quot;
l_string|&quot;0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* something unknown */
r_if
c_cond
(paren
id|ack
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* explicit error */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;cannot read err &quot;
l_string|&quot;for 0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
)brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;0x%x [%s] &quot;
l_string|&quot;failed (0x%x, 0x%x, %s)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|ack
comma
id|err
comma
id|wavefront_errorstr
(paren
id|err
)paren
)paren
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;ack received &quot;
l_string|&quot;for 0x%x [%s]&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;0x%x [%s] does not need &quot;
l_string|&quot;ACK (%d,%d,%d)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|wfcmd-&gt;read_cnt
comma
id|wfcmd-&gt;write_cnt
comma
id|wfcmd-&gt;need_ack
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: data munging   &n;&n;Things here are wierd. All data written to the board cannot &n;have its most significant bit set. Any data item with values &n;potentially &gt; 0x7F (127) must be split across multiple bytes.&n;&n;Sometimes, we need to munge numeric values that are represented on&n;the x86 side as 8-32 bit values. Sometimes, we need to munge data&n;that is represented on the x86 side as an array of bytes. The most&n;efficient approach to handling both cases seems to be to use 2&n;different functions for munging and 2 for de-munging. This avoids&n;wierd casting and worrying about bit-level offsets.&n;&n;**********************************************************************/
r_static
r_int
r_char
op_star
DECL|function|munge_int32
id|munge_int32
(paren
r_int
r_int
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|dst_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dst_size
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dst
op_assign
id|src
op_amp
l_int|0x7F
suffix:semicolon
multiline_comment|/* Mask high bit of LSB */
id|src
op_assign
id|src
op_rshift
l_int|7
suffix:semicolon
multiline_comment|/* Rotate Right 7 bits  */
multiline_comment|/* Note: we leave the upper bits in place */
id|dst
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|demunge_int32
id|demunge_int32
(paren
r_int
r_char
op_star
id|src
comma
r_int
id|src_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|outval
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|src_size
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outval
op_assign
(paren
id|outval
op_lshift
l_int|7
)paren
op_plus
id|src
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|outval
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
r_char
op_star
DECL|function|munge_buf
id|munge_buf
(paren
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|dst_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|last
op_assign
id|dst_size
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|last
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|src
(braket
id|i
)braket
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|src
(braket
id|i
)braket
op_rshift
l_int|7
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_int
r_char
op_star
DECL|function|demunge_buf
id|demunge_buf
(paren
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|src_bytes
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|end
op_assign
id|src
op_plus
id|src_bytes
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|src_bytes
suffix:semicolon
multiline_comment|/* NOTE: src and dst *CAN* point to the same address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|src
op_ne
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dst
(braket
id|i
)braket
op_assign
op_star
id|src
op_increment
suffix:semicolon
id|dst
(braket
id|i
)braket
op_or_assign
(paren
op_star
id|src
op_increment
)paren
op_lshift
l_int|7
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: sample, patch and program management.&n;***********************************************************************/
r_static
r_int
DECL|function|wavefront_delete_sample
id|wavefront_delete_sample
(paren
r_int
id|sample_num
)paren
(brace
r_int
r_char
id|wbuf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|x
suffix:semicolon
id|wbuf
(braket
l_int|0
)braket
op_assign
id|sample_num
op_amp
l_int|0x7f
suffix:semicolon
id|wbuf
(braket
l_int|1
)braket
op_assign
id|sample_num
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_cmd
(paren
id|WFC_DELETE_SAMPLE
comma
l_int|0
comma
id|wbuf
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev.sample_status
(braket
id|sample_num
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_sample_status
id|wavefront_get_sample_status
(paren
r_int
id|assume_rom
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|rbuf
(braket
l_int|32
)braket
comma
id|wbuf
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|sc_real
comma
id|sc_alias
comma
id|sc_multi
suffix:semicolon
multiline_comment|/* check sample status */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_GET_NSAMPLES
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;cannot request sample count.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sc_real
op_assign
id|sc_alias
op_assign
id|sc_multi
op_assign
id|dev.samples_used
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wbuf
(braket
l_int|0
)braket
op_assign
id|i
op_amp
l_int|0x7f
suffix:semicolon
id|wbuf
(braket
l_int|1
)braket
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_IDENTIFY_SAMPLE_TYPE
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;cannot identify sample &quot;
l_string|&quot;type of slot %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|dev.sample_status
(braket
id|i
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dev.sample_status
(braket
id|i
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|rbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assume_rom
)paren
(brace
id|dev.sample_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_ROM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rbuf
(braket
l_int|0
)braket
op_amp
id|WF_ST_MASK
)paren
(brace
r_case
id|WF_ST_SAMPLE
suffix:colon
id|sc_real
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_MULTISAMPLE
suffix:colon
id|sc_multi
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_ALIAS
suffix:colon
id|sc_alias
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_EMPTY
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;unknown sample type for &quot;
l_string|&quot;slot %d (0x%x)&bslash;n&quot;
comma
id|i
comma
id|rbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbuf
(braket
l_int|0
)braket
op_ne
id|WF_ST_EMPTY
)paren
(brace
id|dev.samples_used
op_increment
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;%d samples used (%d real, %d aliases, %d multi), &quot;
l_string|&quot;%d empty&bslash;n&quot;
comma
id|dev.samples_used
comma
id|sc_real
comma
id|sc_alias
comma
id|sc_multi
comma
id|WF_MAX_SAMPLE
op_minus
id|dev.samples_used
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_patch_status
id|wavefront_get_patch_status
(paren
r_void
)paren
(brace
r_int
r_char
id|patchbuf
(braket
id|WF_PATCH_BYTES
)braket
suffix:semicolon
r_int
r_char
id|patchnum
(braket
l_int|2
)braket
suffix:semicolon
id|wavefront_patch
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|cnt
comma
id|cnt2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|patchnum
(braket
l_int|0
)braket
op_assign
id|i
op_amp
l_int|0x7f
suffix:semicolon
id|patchnum
(braket
l_int|1
)braket
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_cmd
(paren
id|WFC_UPLOAD_PATCH
comma
id|patchbuf
comma
id|patchnum
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev.patch_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_FILLED
suffix:semicolon
id|p
op_assign
(paren
id|wavefront_patch
op_star
)paren
id|patchbuf
suffix:semicolon
id|dev.sample_status
(braket
id|p-&gt;sample_number
op_or
(paren
id|p-&gt;sample_msb
op_lshift
l_int|7
)paren
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x
op_eq
l_int|3
)paren
(brace
multiline_comment|/* Bad patch number */
id|dev.patch_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload patch &quot;
l_string|&quot;error 0x%x&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|dev.patch_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* program status has already filled in slot_used bits */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnt
op_assign
l_int|0
comma
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev.patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev.patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_USED
)paren
(brace
id|cnt2
op_increment
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;%d patch slots filled, %d in use&bslash;n&quot;
comma
id|cnt
comma
id|cnt2
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_program_status
id|wavefront_get_program_status
(paren
r_void
)paren
(brace
r_int
r_char
id|progbuf
(braket
id|WF_PROGRAM_BYTES
)braket
suffix:semicolon
id|wavefront_program
id|prog
suffix:semicolon
r_int
r_char
id|prognum
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|l
comma
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PROGRAM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prognum
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_cmd
(paren
id|WFC_UPLOAD_PROGRAM
comma
id|progbuf
comma
op_amp
id|prognum
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev.prog_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
id|demunge_buf
(paren
id|progbuf
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|prog
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|WF_NUM_LAYERS
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|prog.layer
(braket
id|l
)braket
dot
id|mute
)paren
(brace
id|dev.patch_status
(braket
id|prog.layer
(braket
id|l
)braket
dot
id|patch_number
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|x
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Bad program number */
id|dev.prog_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload program &quot;
l_string|&quot;error 0x%x&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|dev.prog_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PROGRAM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev.prog_status
(braket
id|i
)braket
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;%d programs slots in use&bslash;n&quot;
comma
id|cnt
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_patch
id|wavefront_send_patch
(paren
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|buf
(braket
id|WF_PATCH_BYTES
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
op_star
id|bptr
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;downloading patch %d&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
id|dev.patch_status
(braket
id|header-&gt;number
)braket
op_or_assign
id|WF_SLOT_FILLED
suffix:semicolon
id|bptr
op_assign
id|buf
suffix:semicolon
id|bptr
op_assign
id|munge_int32
(paren
id|header-&gt;number
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
id|munge_buf
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header-&gt;hdr.p
comma
id|bptr
comma
id|WF_PATCH_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_DOWNLOAD_PATCH
comma
l_int|0
comma
id|buf
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;download patch failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_program
id|wavefront_send_program
(paren
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|buf
(braket
id|WF_PROGRAM_BYTES
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;downloading program %d&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
id|dev.prog_status
(braket
id|header-&gt;number
)braket
op_assign
id|WF_SLOT_USED
suffix:semicolon
multiline_comment|/* XXX need to zero existing SLOT_USED bit for program_status[i]&n;&t;   where `i&squot; is the program that&squot;s being (potentially) overwritten.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_NUM_LAYERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|header-&gt;hdr.pr.layer
(braket
id|i
)braket
dot
id|mute
)paren
(brace
id|dev.patch_status
(braket
id|header-&gt;hdr.pr.layer
(braket
id|i
)braket
dot
id|patch_number
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
multiline_comment|/* XXX need to mark SLOT_USED for sample used by&n;&t;&t;&t;   patch_number, but this means we have to load it. Ick.&n;&t;&t;&t;*/
)brace
)brace
id|buf
(braket
l_int|0
)braket
op_assign
id|header-&gt;number
suffix:semicolon
id|munge_buf
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header-&gt;hdr.pr
comma
op_amp
id|buf
(braket
l_int|1
)braket
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_DOWNLOAD_PROGRAM
comma
l_int|0
comma
id|buf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;download patch failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_freemem
id|wavefront_freemem
(paren
r_void
)paren
(brace
r_char
id|rbuf
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_REPORT_FREE_MEMORY
comma
id|rbuf
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;can&squot;t get memory stats.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
id|demunge_int32
(paren
id|rbuf
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|wavefront_send_sample
id|wavefront_send_sample
(paren
id|wavefront_patch_info
op_star
id|header
comma
id|UINT16
op_star
id|dataptr
comma
r_int
id|data_is_unsigned
)paren
(brace
multiline_comment|/* samples are downloaded via a 16-bit wide i/o port&n;&t;   (you could think of it as 2 adjacent 8-bit wide ports&n;&t;   but its less efficient that way). therefore, all&n;&t;   the blocksizes and so forth listed in the documentation,&n;&t;   and used conventionally to refer to sample sizes,&n;&t;   which are given in 8-bit units (bytes), need to be&n;&t;   divided by 2.&n;        */
id|UINT16
id|sample_short
suffix:semicolon
id|UINT32
id|length
suffix:semicolon
id|UINT16
op_star
id|data_end
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_const
r_int
id|max_blksize
op_assign
l_int|4096
op_div
l_int|2
suffix:semicolon
r_int
r_int
id|written
suffix:semicolon
r_int
r_int
id|blocksize
suffix:semicolon
r_int
id|dma_ack
suffix:semicolon
r_int
id|blocknum
suffix:semicolon
r_int
r_char
id|sample_hdr
(braket
id|WF_SAMPLE_HDR_BYTES
)braket
suffix:semicolon
r_int
r_char
op_star
id|shptr
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_int
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;sample %sdownload for slot %d, &quot;
l_string|&quot;type %d, %d bytes from 0x%x&bslash;n&quot;
comma
id|header-&gt;size
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;header &quot;
comma
id|header-&gt;number
comma
id|header-&gt;subkey
comma
id|header-&gt;size
comma
(paren
r_int
)paren
id|header-&gt;dataptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;number
op_eq
id|WAVEFRONT_FIND_FREE_SAMPLE_SLOT
)paren
(brace
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_find_free_sample
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|printk
(paren
id|KERN_DEBUG
id|LOGNAME
l_string|&quot;unspecified sample =&gt; %d&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|header-&gt;number
op_assign
id|x
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
multiline_comment|/* XXX its a debatable point whether or not RDONLY semantics&n;&t;&t;   on the ROM samples should cover just the sample data or&n;&t;&t;   the sample header. For now, it only covers the sample data,&n;&t;&t;   so anyone is free at all times to rewrite sample headers.&n;&n;&t;&t;   My reason for this is that we have the sample headers&n;&t;&t;   available in the WFB file for General MIDI, and so these&n;&t;&t;   can always be reset if needed. The sample data, however,&n;&t;&t;   cannot be recovered without a complete reset and firmware&n;&t;&t;   reload of the ICS2115, which is a very expensive operation.&n;&n;&t;&t;   So, doing things this way allows us to honor the notion of&n;&t;&t;   &quot;RESETSAMPLES&quot; reasonably cheaply. Note however, that this&n;&t;&t;   is done purely at user level: there is no WFB parser in&n;&t;&t;   this driver, and so a complete reset (back to General MIDI,&n;&t;&t;   or theoretically some other configuration) is the&n;&t;&t;   responsibility of the user level library. &n;&n;&t;&t;   To try to do this in the kernel would be a little&n;&t;&t;   crazy: we&squot;d need 158K of kernel space just to hold&n;&t;&t;   a copy of the patch/program/sample header data.&n;&t;&t;*/
r_if
c_cond
(paren
id|dev.rom_samples_rdonly
)paren
(brace
r_if
c_cond
(paren
id|dev.sample_status
(braket
id|header-&gt;number
)braket
op_amp
id|WF_SLOT_ROM
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;sample slot %d &quot;
l_string|&quot;write protected&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
)brace
id|wavefront_delete_sample
(paren
id|header-&gt;number
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
id|dev.freemem
op_assign
id|wavefront_freemem
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.freemem
OL
id|header-&gt;size
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;insufficient memory to &quot;
l_string|&quot;load %d byte sample.&bslash;n&quot;
comma
id|header-&gt;size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|skip
op_assign
id|WF_GET_CHANNEL
c_func
(paren
op_amp
id|header-&gt;hdr.s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip
OG
l_int|0
op_logical_and
id|header-&gt;hdr.s.SampleResolution
op_ne
id|LINEAR_16BIT
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;channel selection only &quot;
l_string|&quot;possible on 16-bit samples&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|skip
)paren
(brace
r_case
l_int|0
suffix:colon
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|skip
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|initial_skip
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|initial_skip
op_assign
l_int|2
suffix:semicolon
id|skip
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|initial_skip
op_assign
l_int|3
suffix:semicolon
id|skip
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|initial_skip
op_assign
l_int|4
suffix:semicolon
id|skip
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|initial_skip
op_assign
l_int|5
suffix:semicolon
id|skip
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;channel selection: %d =&gt; &quot;
l_string|&quot;initial skip = %d, skip = %d&bslash;n&quot;
comma
id|WF_GET_CHANNEL
(paren
op_amp
id|header-&gt;hdr.s
)paren
comma
id|initial_skip
comma
id|skip
)paren
suffix:semicolon
multiline_comment|/* Be safe, and zero the &quot;Unused&quot; bits ... */
id|WF_SET_CHANNEL
c_func
(paren
op_amp
id|header-&gt;hdr.s
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* adjust size for 16 bit samples by dividing by two.  We always&n;&t;   send 16 bits per write, even for 8 bit samples, so the length&n;&t;   is always half the size of the sample data in bytes.&n;&t;*/
id|length
op_assign
id|header-&gt;size
op_div
l_int|2
suffix:semicolon
multiline_comment|/* the data we&squot;re sent has not been munged, and in fact, the&n;&t;   header we have to send isn&squot;t just a munged copy either.&n;&t;   so, build the sample header right here.&n;&t;*/
id|shptr
op_assign
op_amp
id|sample_hdr
(braket
l_int|0
)braket
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
id|header-&gt;number
comma
id|shptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
id|shptr
op_assign
id|munge_int32
(paren
id|length
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Yes, a 4 byte result doesn&squot;t contain all of the offset bits,&n;&t;   but the offset only uses 24 bits.&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.sampleStartOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.loopStartOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.loopEndOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|header-&gt;hdr.s.sampleEndOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* This one is truly wierd. What kind of wierdo decided that in&n;&t;   a system dominated by 16 and 32 bit integers, they would use&n;&t;   a just 12 bits ?&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
id|header-&gt;hdr.s.FrequencyBias
comma
id|shptr
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Why is this nybblified, when the MSB is *always* zero ? &n;&t;   Anyway, we can&squot;t take address of bitfield, so make a&n;&t;   good-faith guess at where it starts.&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
op_amp
id|header-&gt;hdr.s.FrequencyBias
op_plus
l_int|1
)paren
comma
id|shptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|header-&gt;size
ques
c_cond
id|WFC_DOWNLOAD_SAMPLE
suffix:colon
id|WFC_DOWNLOAD_SAMPLE_HEADER
comma
l_int|0
comma
id|sample_hdr
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;sample %sdownload refused.&bslash;n&quot;
comma
id|header-&gt;size
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;header &quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
op_eq
l_int|0
)paren
(brace
r_goto
id|sent
suffix:semicolon
multiline_comment|/* Sorry. Just had to have one somewhere */
)brace
id|data_end
op_assign
id|dataptr
op_plus
id|length
suffix:semicolon
multiline_comment|/* Do any initial skip over an unused channel&squot;s data */
id|dataptr
op_add_assign
id|initial_skip
suffix:semicolon
r_for
c_loop
(paren
id|written
op_assign
l_int|0
comma
id|blocknum
op_assign
l_int|0
suffix:semicolon
id|written
OL
id|length
suffix:semicolon
id|written
op_add_assign
id|max_blksize
comma
id|blocknum
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|length
op_minus
id|written
)paren
OG
id|max_blksize
)paren
(brace
id|blocksize
op_assign
id|max_blksize
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* round to nearest 16-byte value */
id|blocksize
op_assign
(paren
(paren
id|length
op_minus
id|written
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|0x7
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_DOWNLOAD_BLOCK
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;download block &quot;
l_string|&quot;request refused.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blocksize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dataptr
OL
id|data_end
)paren
(brace
id|__get_user
(paren
id|sample_short
comma
id|dataptr
)paren
suffix:semicolon
id|dataptr
op_add_assign
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|data_is_unsigned
)paren
(brace
multiline_comment|/* GUS ? */
r_if
c_cond
(paren
id|WF_SAMPLE_IS_8BIT
c_func
(paren
op_amp
id|header-&gt;hdr.s
)paren
)paren
(brace
multiline_comment|/* 8 bit sample&n;&t;&t;&t;&t;&t;&t; resolution, sign&n;&t;&t;&t;&t;&t;&t; extend both bytes.&n;&t;&t;&t;&t;&t;&t;*/
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sample_short
)paren
(braket
l_int|0
)braket
op_add_assign
l_int|0x7f
suffix:semicolon
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sample_short
)paren
(braket
l_int|1
)braket
op_add_assign
l_int|0x7f
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 16 bit sample&n;&t;&t;&t;&t;&t;&t; resolution, sign&n;&t;&t;&t;&t;&t;&t; extend the MSB.&n;&t;&t;&t;&t;&t;&t;*/
id|sample_short
op_add_assign
l_int|0x7fff
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* In padding section of final block:&n;&n;&t;&t;&t;&t;   Don&squot;t fetch unsupplied data from&n;&t;&t;&t;&t;   user space, just continue with&n;&t;&t;&t;&t;   whatever the final value was.&n;&t;&t;&t;&t;*/
)brace
r_if
c_cond
(paren
id|i
OL
id|blocksize
op_minus
l_int|1
)paren
(brace
id|outw
(paren
id|sample_short
comma
id|dev.block_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outw
(paren
id|sample_short
comma
id|dev.last_block_port
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Get &quot;DMA page acknowledge&quot;, even though its really&n;&t;&t;   nothing to do with DMA at all.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|dma_ack
op_assign
id|wavefront_read
(paren
)paren
)paren
op_ne
id|WF_DMA_ACK
)paren
(brace
r_if
c_cond
(paren
id|dma_ack
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload sample &quot;
l_string|&quot;DMA ack timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload sample &quot;
l_string|&quot;DMA ack error 0x%x&bslash;n&quot;
comma
id|dma_ack
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
)brace
id|dev.sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_SAMPLE
)paren
suffix:semicolon
multiline_comment|/* Note, label is here because sending the sample header shouldn&squot;t&n;&t;   alter the sample_status info at all.&n;&t;*/
id|sent
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_alias
id|wavefront_send_alias
(paren
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|alias_hdr
(braket
id|WF_ALIAS_BYTES
)braket
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;download alias, %d is &quot;
l_string|&quot;alias for %d&bslash;n&quot;
comma
id|header-&gt;number
comma
id|header-&gt;hdr.a.OriginalSample
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
op_amp
id|alias_hdr
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.a.OriginalSample
comma
op_amp
id|alias_hdr
(braket
l_int|2
)braket
comma
l_int|2
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.sampleStartOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|4
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.loopStartOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|8
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.loopEndOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|12
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.sampleEndOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|16
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.a.FrequencyBias
comma
op_amp
id|alias_hdr
(braket
l_int|20
)braket
comma
l_int|3
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
op_amp
id|header-&gt;hdr.a.FrequencyBias
op_plus
l_int|1
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|23
)braket
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_DOWNLOAD_SAMPLE_ALIAS
comma
l_int|0
comma
id|alias_hdr
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;download alias failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dev.sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_ALIAS
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_multisample
id|wavefront_send_multisample
(paren
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|num_samples
suffix:semicolon
r_int
r_char
id|msample_hdr
(braket
id|WF_MSAMPLE_BYTES
)braket
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
op_amp
id|msample_hdr
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* You&squot;ll recall at this point that the &quot;number of samples&quot; value&n;&t;   in a wavefront_multisample struct is actually the log2 of the&n;&t;   real number of samples.&n;&t;*/
id|num_samples
op_assign
(paren
l_int|1
op_lshift
(paren
id|header-&gt;hdr.ms.NumberOfSamples
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|msample_hdr
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
id|header-&gt;hdr.ms.NumberOfSamples
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;multi %d with %d=%d samples&bslash;n&quot;
comma
id|header-&gt;number
comma
id|header-&gt;hdr.ms.NumberOfSamples
comma
id|num_samples
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_samples
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DPRINT
c_func
(paren
id|WF_DEBUG_LOAD_PATCH
op_or
id|WF_DEBUG_DATA
comma
l_string|&quot;sample[%d] = %d&bslash;n&quot;
comma
id|i
comma
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
comma
op_amp
id|msample_hdr
(braket
l_int|3
op_plus
(paren
id|i
op_star
l_int|2
)paren
)braket
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Need a hack here to pass in the number of bytes&n;&t;   to be written to the synth. This is ugly, and perhaps&n;&t;   one day, I&squot;ll fix it.&n;&t;*/
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_DOWNLOAD_MULTISAMPLE
comma
(paren
r_int
r_char
op_star
)paren
(paren
(paren
id|num_samples
op_star
l_int|2
)paren
op_plus
l_int|3
)paren
comma
id|msample_hdr
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;download of multisample failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dev.sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_MULTISAMPLE
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_fetch_multisample
id|wavefront_fetch_multisample
(paren
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|log_ns
(braket
l_int|1
)braket
suffix:semicolon
r_int
r_char
id|number
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|num_samples
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
id|number
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_UPLOAD_MULTISAMPLE
comma
id|log_ns
comma
id|number
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload multisample failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;msample %d has %d samples&bslash;n&quot;
comma
id|header-&gt;number
comma
id|log_ns
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|header-&gt;hdr.ms.NumberOfSamples
op_assign
id|log_ns
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* get the number of samples ... */
id|num_samples
op_assign
(paren
l_int|1
op_lshift
id|log_ns
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_samples
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|d
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload multisample failed &quot;
l_string|&quot;during sample loop.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|d
(braket
l_int|1
)braket
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;upload multisample failed &quot;
l_string|&quot;during sample loop.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
op_assign
id|demunge_int32
(paren
(paren
r_int
r_char
op_star
)paren
id|d
comma
l_int|2
)paren
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;msample sample[%d] = %d&bslash;n&quot;
comma
id|i
comma
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_drum
id|wavefront_send_drum
(paren
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|drumbuf
(braket
id|WF_DRUM_BYTES
)braket
suffix:semicolon
id|wavefront_drum
op_star
id|drum
op_assign
op_amp
id|header-&gt;hdr.d
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;downloading edrum for MIDI &quot;
l_string|&quot;note %d, patch = %d&bslash;n&quot;
comma
id|header-&gt;number
comma
id|drum-&gt;PatchNumber
)paren
suffix:semicolon
id|drumbuf
(braket
l_int|0
)braket
op_assign
id|header-&gt;number
op_amp
l_int|0x7f
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|munge_int32
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|drum
)paren
(braket
id|i
)braket
comma
op_amp
id|drumbuf
(braket
l_int|1
op_plus
(paren
id|i
op_star
l_int|2
)paren
)braket
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_DOWNLOAD_EDRUM_PROGRAM
comma
l_int|0
comma
id|drumbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;download drum failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_find_free_sample
id|wavefront_find_free_sample
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev.sample_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;no free sample slots!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_find_free_patch
id|wavefront_find_free_patch
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev.patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;no free patch slots!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|log2_2048
id|log2_2048
c_func
(paren
r_int
id|n
)paren
(brace
r_int
id|tbl
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Returns 2048*log2(n) */
multiline_comment|/* FIXME: this is like doing integer math&n;&t;   on quantum particles (RuN) */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
op_ge
l_int|32
op_star
l_int|256
)paren
(brace
id|n
op_rshift_assign
l_int|8
suffix:semicolon
id|i
op_add_assign
l_int|2048
op_star
l_int|8
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
op_ge
l_int|32
)paren
(brace
id|n
op_rshift_assign
l_int|1
suffix:semicolon
id|i
op_add_assign
l_int|2048
suffix:semicolon
)brace
id|i
op_add_assign
id|tbl
(braket
id|n
)braket
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_load_gus_patch
id|wavefront_load_gus_patch
(paren
r_int
id|devno
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
(brace
r_struct
id|patch_info
id|guspatch
suffix:semicolon
id|wavefront_patch_info
id|samp
comma
id|pat
comma
id|prog
suffix:semicolon
id|wavefront_patch
op_star
id|patp
suffix:semicolon
id|wavefront_sample
op_star
id|sampp
suffix:semicolon
id|wavefront_program
op_star
id|progp
suffix:semicolon
r_int
id|i
comma
id|base_note
suffix:semicolon
r_int
id|sizeof_patch
suffix:semicolon
multiline_comment|/* Copy in the header of the GUS patch */
id|sizeof_patch
op_assign
(paren
r_int
)paren
op_amp
id|guspatch.data
(braket
l_int|0
)braket
op_minus
(paren
r_int
)paren
op_amp
id|guspatch
suffix:semicolon
id|copy_from_user
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
op_amp
id|guspatch
)paren
(braket
id|offs
)braket
comma
op_amp
(paren
id|addr
)paren
(braket
id|offs
)braket
comma
id|sizeof_patch
op_minus
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|wavefront_find_free_patch
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|pat.number
op_assign
id|i
suffix:semicolon
id|pat.subkey
op_assign
id|WF_ST_PATCH
suffix:semicolon
id|patp
op_assign
op_amp
id|pat.hdr.p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|wavefront_find_free_sample
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|samp.number
op_assign
id|i
suffix:semicolon
id|samp.subkey
op_assign
id|WF_ST_SAMPLE
suffix:semicolon
id|samp.size
op_assign
id|guspatch.len
suffix:semicolon
id|sampp
op_assign
op_amp
id|samp.hdr.s
suffix:semicolon
id|prog.number
op_assign
id|guspatch.instr_no
suffix:semicolon
id|progp
op_assign
op_amp
id|prog.hdr.pr
suffix:semicolon
multiline_comment|/* Setup the patch structure */
id|patp-&gt;amplitude_bias
op_assign
id|guspatch.volume
suffix:semicolon
id|patp-&gt;portamento
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;sample_number
op_assign
id|samp.number
op_amp
l_int|0xff
suffix:semicolon
id|patp-&gt;sample_msb
op_assign
id|samp.number
op_rshift
l_int|8
suffix:semicolon
id|patp-&gt;pitch_bend
op_assign
multiline_comment|/*12*/
l_int|0
suffix:semicolon
id|patp-&gt;mono
op_assign
l_int|1
suffix:semicolon
id|patp-&gt;retrigger
op_assign
l_int|1
suffix:semicolon
id|patp-&gt;nohold
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_SUSTAIN_ON
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|patp-&gt;frequency_bias
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;restart
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;reuse
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;reset_lfo
op_assign
l_int|1
suffix:semicolon
id|patp-&gt;fm_src2
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fm_src1
op_assign
id|WF_MOD_MOD_WHEEL
suffix:semicolon
id|patp-&gt;am_src
op_assign
id|WF_MOD_PRESSURE
suffix:semicolon
id|patp-&gt;am_amount
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;fc1_mod_amount
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fc2_mod_amount
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fm_amount1
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;fm_amount2
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;envelope1.attack_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.decay1_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.decay2_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.sustain_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope1.release_level
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;envelope2.attack_velocity
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.attack_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.decay1_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.decay2_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.sustain_level
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;envelope2.release_level
op_assign
l_int|0
suffix:semicolon
id|patp-&gt;envelope2.attack_velocity
op_assign
l_int|127
suffix:semicolon
id|patp-&gt;randomizer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Program for this patch */
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|patch_number
op_assign
id|pat.number
suffix:semicolon
multiline_comment|/* XXX is this right ? */
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|mute
op_assign
l_int|1
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|pan_or_mod
op_assign
l_int|1
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|pan
op_assign
l_int|7
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|mix_level
op_assign
l_int|127
multiline_comment|/* guspatch.volume */
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|split_type
op_assign
l_int|0
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|split_point
op_assign
l_int|0
suffix:semicolon
id|progp-&gt;layer
(braket
l_int|0
)braket
dot
id|play_below
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|progp-&gt;layer
(braket
id|i
)braket
dot
id|mute
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Sample data */
id|sampp-&gt;SampleResolution
op_assign
(paren
(paren
op_complement
id|guspatch.mode
op_amp
id|WAVE_16_BITS
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|base_note
op_assign
l_int|0
suffix:semicolon
id|note_to_freq
(paren
id|base_note
)paren
OL
id|guspatch.base_note
suffix:semicolon
id|base_note
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|guspatch.base_note
op_minus
id|note_to_freq
c_func
(paren
id|base_note
)paren
)paren
OG
(paren
id|note_to_freq
c_func
(paren
id|base_note
)paren
op_minus
id|guspatch.base_note
)paren
)paren
id|base_note
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ref freq=%d,base note=%d&bslash;n&quot;
comma
id|guspatch.base_freq
comma
id|base_note
)paren
suffix:semicolon
id|sampp-&gt;FrequencyBias
op_assign
(paren
l_int|29550
op_minus
id|log2_2048
c_func
(paren
id|guspatch.base_freq
)paren
op_plus
id|base_note
op_star
l_int|171
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Freq Bias is %d&bslash;n&quot;
comma
id|sampp-&gt;FrequencyBias
)paren
suffix:semicolon
id|sampp-&gt;Loop
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_LOOPING
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|sampp-&gt;sampleStartOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;sampleStartOffset.Integer
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;loopStartOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;loopStartOffset.Integer
op_assign
id|guspatch.loop_start
op_rshift
(paren
(paren
id|guspatch.mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sampp-&gt;loopEndOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;loopEndOffset.Integer
op_assign
id|guspatch.loop_end
op_rshift
(paren
(paren
id|guspatch.mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sampp-&gt;sampleEndOffset.Fraction
op_assign
l_int|0
suffix:semicolon
id|sampp-&gt;sampleEndOffset.Integer
op_assign
id|guspatch.len
op_rshift
(paren
id|guspatch.mode
op_amp
l_int|1
)paren
suffix:semicolon
id|sampp-&gt;Bidirectional
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_BIDIR_LOOP
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|sampp-&gt;Reverse
op_assign
(paren
id|guspatch.mode
op_amp
id|WAVE_LOOP_BACK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Now ship it down */
id|wavefront_send_sample
(paren
op_amp
id|samp
comma
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|addr
)paren
(braket
id|sizeof_patch
)braket
comma
(paren
id|guspatch.mode
op_amp
id|WAVE_UNSIGNED
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|wavefront_send_patch
(paren
op_amp
id|pat
)paren
suffix:semicolon
id|wavefront_send_program
(paren
op_amp
id|prog
)paren
suffix:semicolon
multiline_comment|/* Now pan as best we can ... use the slave/internal MIDI device&n;&t;   number if it exists (since it talks to the WaveFront), or the&n;&t;   master otherwise.&n;&t;*/
r_if
c_cond
(paren
id|dev.mididev
OG
l_int|0
)paren
(brace
id|midi_synth_controller
(paren
id|dev.mididev
comma
id|guspatch.instr_no
comma
l_int|10
comma
(paren
(paren
id|guspatch.panning
op_lshift
l_int|4
)paren
OG
l_int|127
)paren
ques
c_cond
l_int|127
suffix:colon
(paren
id|guspatch.panning
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_load_patch
id|wavefront_load_patch
(paren
r_const
r_char
op_star
id|addr
)paren
(brace
id|wavefront_patch_info
id|header
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header
comma
id|addr
comma
r_sizeof
(paren
id|wavefront_patch_info
)paren
op_minus
r_sizeof
(paren
id|wavefront_any
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;bad address for load patch.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;download &quot;
l_string|&quot;Sample type: %d &quot;
l_string|&quot;Sample number: %d &quot;
l_string|&quot;Sample size: %d&bslash;n&quot;
comma
id|header.subkey
comma
id|header.number
comma
id|header.size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|header.subkey
)paren
(brace
r_case
id|WF_ST_SAMPLE
suffix:colon
multiline_comment|/* sample or sample_header, based on patch-&gt;size */
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.s
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_sample
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_sample
(paren
op_amp
id|header
comma
id|header.dataptr
comma
l_int|0
)paren
suffix:semicolon
r_case
id|WF_ST_MULTISAMPLE
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.s
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_multisample
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_multisample
(paren
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_ALIAS
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.a
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_alias
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_alias
(paren
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_DRUM
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.d
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_drum
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_drum
(paren
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_PATCH
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.p
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_patch
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_patch
(paren
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_PROGRAM
suffix:colon
id|copy_from_user
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header.hdr.pr
comma
(paren
r_int
r_char
op_star
)paren
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_program
)paren
)paren
suffix:semicolon
r_return
id|wavefront_send_program
(paren
op_amp
id|header
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;unknown patch type %d.&bslash;n&quot;
comma
id|header.subkey
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: /dev/sequencer{,2} and other hardware-dependent interfaces&n;***********************************************************************/
r_static
r_void
DECL|function|process_sample_hdr
id|process_sample_hdr
(paren
id|UCHAR8
op_star
id|buf
)paren
(brace
id|wavefront_sample
id|s
suffix:semicolon
id|UCHAR8
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|buf
suffix:semicolon
multiline_comment|/* The board doesn&squot;t send us an exact copy of a &quot;wavefront_sample&quot;&n;&t;   in response to an Upload Sample Header command. Instead, we &n;&t;   have to convert the data format back into our data structure,&n;&t;   just as in the Download Sample command, where we have to do&n;&t;   something very similar in the reverse direction.&n;&t;*/
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.sampleStartOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.loopStartOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.loopEndOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.sampleEndOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|UINT32
op_star
)paren
op_amp
id|s.FrequencyBias
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|3
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|3
suffix:semicolon
id|s.SampleResolution
op_assign
op_star
id|ptr
op_amp
l_int|0x3
suffix:semicolon
id|s.Loop
op_assign
op_star
id|ptr
op_amp
l_int|0x8
suffix:semicolon
id|s.Bidirectional
op_assign
op_star
id|ptr
op_amp
l_int|0x10
suffix:semicolon
id|s.Reverse
op_assign
op_star
id|ptr
op_amp
l_int|0x40
suffix:semicolon
multiline_comment|/* Now copy it back to where it came from */
id|memcpy
(paren
id|buf
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|s
comma
r_sizeof
(paren
id|wavefront_sample
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_synth_control
id|wavefront_synth_control
(paren
r_int
id|cmd
comma
id|wavefront_control
op_star
id|wc
)paren
(brace
r_int
r_char
id|patchnumbuf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;synth control with &quot;
l_string|&quot;cmd 0x%x&bslash;n&quot;
comma
id|wc-&gt;cmd
)paren
suffix:semicolon
multiline_comment|/* Pre-handling of or for various commands */
r_switch
c_cond
(paren
id|wc-&gt;cmd
)paren
(brace
r_case
id|WFC_DISABLE_INTERRUPTS
suffix:colon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;interrupts disabled.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x20
comma
id|dev.control_port
)paren
suffix:semicolon
id|dev.interrupts_on
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_ENABLE_INTERRUPTS
suffix:colon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;interrupts enabled.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x20
comma
id|dev.control_port
)paren
suffix:semicolon
id|dev.interrupts_on
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_INTERRUPT_STATUS
suffix:colon
id|wc-&gt;rbuf
(braket
l_int|0
)braket
op_assign
id|dev.interrupts_on
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_ROMSAMPLES_RDONLY
suffix:colon
id|dev.rom_samples_rdonly
op_assign
id|wc-&gt;wbuf
(braket
l_int|0
)braket
suffix:semicolon
id|wc-&gt;status
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_IDENTIFY_SLOT_TYPE
suffix:colon
id|i
op_assign
id|wc-&gt;wbuf
(braket
l_int|0
)braket
op_or
(paren
id|wc-&gt;wbuf
(braket
l_int|1
)braket
op_lshift
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|WF_MAX_SAMPLE
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;invalid slot ID %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|wc-&gt;status
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|wc-&gt;rbuf
(braket
l_int|0
)braket
op_assign
id|dev.sample_status
(braket
id|i
)braket
suffix:semicolon
id|wc-&gt;status
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_DEBUG_DRIVER
suffix:colon
id|dev.debug
op_assign
id|wc-&gt;wbuf
(braket
l_int|0
)braket
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;debug = 0x%x&bslash;n&quot;
comma
id|dev.debug
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_FX_IOCTL
suffix:colon
id|wffx_ioctl
(paren
(paren
id|wavefront_fx_info
op_star
)paren
op_amp
id|wc-&gt;wbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_UPLOAD_PATCH
suffix:colon
id|munge_int32
(paren
op_star
(paren
(paren
id|UINT32
op_star
)paren
id|wc-&gt;wbuf
)paren
comma
id|patchnumbuf
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
(paren
id|wc-&gt;wbuf
comma
id|patchnumbuf
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_MULTISAMPLE
suffix:colon
multiline_comment|/* multisamples have to be handled differently, and&n;&t;&t;   cannot be dealt with properly by wavefront_cmd() alone.&n;&t;&t;*/
id|wc-&gt;status
op_assign
id|wavefront_fetch_multisample
(paren
(paren
id|wavefront_patch_info
op_star
)paren
id|wc-&gt;rbuf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_ALIAS
suffix:colon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;support for sample alias upload &quot;
l_string|&quot;being considered.&bslash;n&quot;
)paren
suffix:semicolon
id|wc-&gt;status
op_assign
id|EINVAL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|wc-&gt;status
op_assign
id|wavefront_cmd
(paren
id|wc-&gt;cmd
comma
id|wc-&gt;rbuf
comma
id|wc-&gt;wbuf
)paren
suffix:semicolon
multiline_comment|/* Post-handling of certain commands.&n;&n;&t;   In particular, if the command was an upload, demunge the data&n;&t;   so that the user-level doesn&squot;t have to think about it.&n;&t;*/
r_if
c_cond
(paren
id|wc-&gt;status
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|wc-&gt;cmd
)paren
(brace
multiline_comment|/* intercept any freemem requests so that we know&n;&t;&t;&t;   we are always current with the user-level view&n;&t;&t;&t;   of things.&n;&t;&t;&t;*/
r_case
id|WFC_REPORT_FREE_MEMORY
suffix:colon
id|dev.freemem
op_assign
id|demunge_int32
(paren
id|wc-&gt;rbuf
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_PATCH
suffix:colon
id|demunge_buf
(paren
id|wc-&gt;rbuf
comma
id|wc-&gt;rbuf
comma
id|WF_PATCH_BYTES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_PROGRAM
suffix:colon
id|demunge_buf
(paren
id|wc-&gt;rbuf
comma
id|wc-&gt;rbuf
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_EDRUM_PROGRAM
suffix:colon
id|demunge_buf
(paren
id|wc-&gt;rbuf
comma
id|wc-&gt;rbuf
comma
id|WF_DRUM_BYTES
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_HEADER
suffix:colon
id|process_sample_hdr
(paren
id|wc-&gt;rbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_ALIAS
suffix:colon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;support for &quot;
l_string|&quot;sample aliases still &quot;
l_string|&quot;being considered.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_VMIDI_OFF
suffix:colon
r_if
c_cond
(paren
id|virtual_midi_disable
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WFC_VMIDI_ON
suffix:colon
r_if
c_cond
(paren
id|virtual_midi_enable
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************/
multiline_comment|/* WaveFront: Linux file system interface (for access via raw synth)    */
multiline_comment|/***********************************************************************/
r_static
id|loff_t
DECL|function|wavefront_llseek
id|wavefront_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_open
id|wavefront_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/* XXX fix me */
id|dev.opened
op_assign
id|file-&gt;f_flags
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_release
id|wavefront_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|dev.opened
op_assign
l_int|0
suffix:semicolon
id|dev.debug
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_ioctl
id|wavefront_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|wavefront_control
id|wc
suffix:semicolon
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|WFCTL_WFCMD
suffix:colon
id|copy_from_user
(paren
op_amp
id|wc
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|wc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wavefront_synth_control
(paren
id|cmd
comma
op_amp
id|wc
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|wc
comma
r_sizeof
(paren
id|wc
)paren
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
r_case
id|WFCTL_LOAD_SPP
suffix:colon
r_return
id|wavefront_load_patch
(paren
(paren
r_const
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;invalid ioctl %#x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|wavefront_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|wavefront_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|wavefront_llseek
comma
id|ioctl
suffix:colon
id|wavefront_ioctl
comma
id|open
suffix:colon
id|wavefront_open
comma
id|release
suffix:colon
id|wavefront_release
comma
)brace
suffix:semicolon
"&f;"
multiline_comment|/***********************************************************************/
multiline_comment|/* WaveFront: OSS installation and support interface                   */
multiline_comment|/***********************************************************************/
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
DECL|variable|wavefront_info
r_static
r_struct
id|synth_info
id|wavefront_info
op_assign
(brace
l_string|&quot;Turtle Beach WaveFront&quot;
comma
l_int|0
comma
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_WAVEFRONT
comma
l_int|0
comma
l_int|32
comma
l_int|0
comma
l_int|0
comma
id|SYNTH_CAP_INPUT
)brace
suffix:semicolon
r_static
r_int
DECL|function|wavefront_oss_open
id|wavefront_oss_open
(paren
r_int
id|devno
comma
r_int
id|mode
)paren
(brace
id|dev.opened
op_assign
id|mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|wavefront_oss_close
id|wavefront_oss_close
(paren
r_int
id|devno
)paren
(brace
id|dev.opened
op_assign
l_int|0
suffix:semicolon
id|dev.debug
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_oss_ioctl
id|wavefront_oss_ioctl
(paren
r_int
id|devno
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
id|wavefront_control
id|wc
suffix:semicolon
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDCTL_SYNTH_INFO
suffix:colon
id|memcpy
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
(braket
l_int|0
)braket
comma
op_amp
id|wavefront_info
comma
r_sizeof
(paren
id|wavefront_info
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_RESETSAMPLES
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;driver cannot reset samples.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t force an error */
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_PERCMODE
suffix:colon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t force an error */
r_break
suffix:semicolon
r_case
id|SNDCTL_SYNTH_MEMAVL
suffix:colon
r_if
c_cond
(paren
(paren
id|dev.freemem
op_assign
id|wavefront_freemem
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;cannot get memory size&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
r_return
id|dev.freemem
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDCTL_SYNTH_CONTROL
suffix:colon
id|copy_from_user
(paren
op_amp
id|wc
comma
id|arg
comma
r_sizeof
(paren
id|wc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wavefront_synth_control
(paren
id|cmd
comma
op_amp
id|wc
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|copy_to_user
(paren
id|arg
comma
op_amp
id|wc
comma
r_sizeof
(paren
id|wc
)paren
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|wavefront_oss_load_patch
id|wavefront_oss_load_patch
(paren
r_int
id|devno
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
(brace
r_if
c_cond
(paren
id|format
op_eq
id|SYSEX_PATCH
)paren
(brace
multiline_comment|/* Handled by midi_synth.c */
r_if
c_cond
(paren
id|midi_load_patch
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;SYSEX not loadable: &quot;
l_string|&quot;no midi patch loader!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
id|midi_load_patch
(paren
id|devno
comma
id|format
comma
id|addr
comma
id|offs
comma
id|count
comma
id|pmgr_flag
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|format
op_eq
id|GUS_PATCH
)paren
(brace
r_return
id|wavefront_load_gus_patch
(paren
id|devno
comma
id|format
comma
id|addr
comma
id|offs
comma
id|count
comma
id|pmgr_flag
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|format
op_ne
id|WAVEFRONT_PATCH
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;unknown patch format %d&bslash;n&quot;
comma
id|format
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
r_sizeof
(paren
id|wavefront_patch_info
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;sample header too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* &quot;addr&quot; points to a user-space wavefront_patch_info */
r_return
id|wavefront_load_patch
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|variable|wavefront_operations
r_static
r_struct
id|synth_operations
id|wavefront_operations
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|id
suffix:colon
l_string|&quot;WaveFront&quot;
comma
id|info
suffix:colon
op_amp
id|wavefront_info
comma
id|midi_dev
suffix:colon
l_int|0
comma
id|synth_type
suffix:colon
id|SYNTH_TYPE_SAMPLE
comma
id|synth_subtype
suffix:colon
id|SAMPLE_TYPE_WAVEFRONT
comma
id|open
suffix:colon
id|wavefront_oss_open
comma
id|close
suffix:colon
id|wavefront_oss_close
comma
id|ioctl
suffix:colon
id|wavefront_oss_ioctl
comma
id|kill_note
suffix:colon
id|midi_synth_kill_note
comma
id|start_note
suffix:colon
id|midi_synth_start_note
comma
id|set_instr
suffix:colon
id|midi_synth_set_instr
comma
id|reset
suffix:colon
id|midi_synth_reset
comma
id|load_patch
suffix:colon
id|midi_synth_load_patch
comma
id|aftertouch
suffix:colon
id|midi_synth_aftertouch
comma
id|controller
suffix:colon
id|midi_synth_controller
comma
id|panning
suffix:colon
id|midi_synth_panning
comma
id|bender
suffix:colon
id|midi_synth_bender
comma
id|setup_voice
suffix:colon
id|midi_synth_setup_voice
)brace
suffix:semicolon
macro_line|#endif OSS_SUPPORT_SEQ
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_STATIC_INSTALL
DECL|function|attach_wavefront
r_static
r_void
id|__init
id|attach_wavefront
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
(paren
r_void
)paren
id|install_wavefront
(paren
)paren
suffix:semicolon
)brace
DECL|function|probe_wavefront
r_static
r_int
id|__init
id|probe_wavefront
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_return
op_logical_neg
id|detect_wavefront
(paren
id|hw_config-&gt;irq
comma
id|hw_config-&gt;io_base
)paren
suffix:semicolon
)brace
DECL|function|unload_wavefront
r_static
r_void
id|__exit
id|unload_wavefront
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
(paren
r_void
)paren
id|uninstall_wavefront
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif OSS_SUPPORT_STATIC_INSTALL
multiline_comment|/***********************************************************************/
multiline_comment|/* WaveFront: Linux modular sound kernel installation interface        */
multiline_comment|/***********************************************************************/
r_void
DECL|function|wavefrontintr
id|wavefrontintr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|dummy
)paren
(brace
r_struct
id|wf_config
op_star
id|hw
op_assign
id|dev_id
suffix:semicolon
multiline_comment|/*&n;&t;   Some comments on interrupts. I attempted a version of this&n;&t;   driver that used interrupts throughout the code instead of&n;&t;   doing busy and/or sleep-waiting. Alas, it appears that once&n;&t;   the Motorola firmware is downloaded, the card *never*&n;&t;   generates an RX interrupt. These are successfully generated&n;&t;   during firmware loading, and after that wavefront_status()&n;&t;   reports that an interrupt is pending on the card from time&n;&t;   to time, but it never seems to be delivered to this&n;&t;   driver. Note also that wavefront_status() continues to&n;&t;   report that RX interrupts are enabled, suggesting that I&n;&t;   didn&squot;t goof up and disable them by mistake.&n;&n;&t;   Thus, I stepped back to a prior version of&n;&t;   wavefront_wait(), the only place where this really&n;&t;   matters. Its sad, but I&squot;ve looked through the code to check&n;&t;   on things, and I really feel certain that the Motorola&n;&t;   firmware prevents RX-ready interrupts.&n;&t;*/
r_if
c_cond
(paren
(paren
id|wavefront_status
c_func
(paren
)paren
op_amp
(paren
id|STAT_INTR_READ
op_or
id|STAT_INTR_WRITE
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|hw-&gt;irq_ok
op_assign
l_int|1
suffix:semicolon
id|hw-&gt;irq_cnt
op_increment
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|hw-&gt;interrupt_sleeper
)paren
suffix:semicolon
)brace
multiline_comment|/* STATUS REGISTER &n;&n;0 Host Rx Interrupt Enable (1=Enabled)&n;1 Host Rx Register Full (1=Full)&n;2 Host Rx Interrupt Pending (1=Interrupt)&n;3 Unused&n;4 Host Tx Interrupt (1=Enabled)&n;5 Host Tx Register empty (1=Empty)&n;6 Host Tx Interrupt Pending (1=Interrupt)&n;7 Unused&n;*/
r_int
DECL|function|wavefront_interrupt_bits
id|wavefront_interrupt_bits
(paren
r_int
id|irq
)paren
(brace
r_int
id|bits
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|9
suffix:colon
id|bits
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|bits
op_assign
l_int|0x08
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|bits
op_assign
l_int|0x10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|bits
op_assign
l_int|0x18
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;invalid IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|bits
suffix:semicolon
)brace
r_void
DECL|function|wavefront_should_cause_interrupt
id|wavefront_should_cause_interrupt
(paren
r_int
id|val
comma
r_int
id|port
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev.irq_ok
op_assign
l_int|0
suffix:semicolon
id|outb
(paren
id|val
comma
id|port
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
(paren
op_amp
id|dev.interrupt_sleeper
comma
id|timeout
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|wavefront_hw_reset
r_static
r_int
id|__init
id|wavefront_hw_reset
(paren
r_void
)paren
(brace
r_int
id|bits
suffix:semicolon
r_int
id|hwv
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|irq_mask
suffix:semicolon
r_int
id|reported_irq
suffix:semicolon
multiline_comment|/* IRQ already checked in init_module() */
id|bits
op_assign
id|wavefront_interrupt_bits
(paren
id|dev.irq
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
id|LOGNAME
l_string|&quot;autodetecting WaveFront IRQ&bslash;n&quot;
)paren
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
id|irq_mask
op_assign
id|probe_irq_on
(paren
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0
comma
id|dev.control_port
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
id|bits
comma
id|dev.data_port
)paren
suffix:semicolon
id|wavefront_should_cause_interrupt
c_func
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x10
op_or
l_int|0x1
comma
id|dev.control_port
comma
(paren
id|reset_time
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
id|reported_irq
op_assign
id|probe_irq_off
(paren
id|irq_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reported_irq
op_ne
id|dev.irq
)paren
(brace
r_if
c_cond
(paren
id|reported_irq
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;No unassigned interrupts detected &quot;
l_string|&quot;after h/w reset&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reported_irq
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;Multiple unassigned interrupts detected &quot;
l_string|&quot;after h/w reset&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;autodetected IRQ %d not the &quot;
l_string|&quot;value provided (%d)&bslash;n&quot;
comma
id|reported_irq
comma
id|dev.irq
)paren
suffix:semicolon
)brace
id|dev.irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;autodetected IRQ at %d&bslash;n&quot;
comma
id|reported_irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
(paren
id|dev.irq
comma
id|wavefrontintr
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
l_string|&quot;wavefront synth&quot;
comma
op_amp
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;IRQ %d not available!&bslash;n&quot;
comma
id|dev.irq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* try reset of port */
id|outb
(paren
l_int|0x0
comma
id|dev.control_port
)paren
suffix:semicolon
multiline_comment|/* At this point, the board is in reset, and the H/W initialization&n;&t;   register is accessed at the same address as the data port.&n;     &n;&t;   Bit 7 - Enable IRQ Driver&t;&n;&t;   0 - Tri-state the Wave-Board drivers for the PC Bus IRQs&n;&t;   1 - Enable IRQ selected by bits 5:3 to be driven onto the PC Bus.&n;     &n;&t;   Bit 6 - MIDI Interface Select&n;&n;&t;   0 - Use the MIDI Input from the 26-pin WaveBlaster&n;&t;   compatible header as the serial MIDI source&n;&t;   1 - Use the MIDI Input from the 9-pin D connector as the&n;&t;   serial MIDI source.&n;     &n;&t;   Bits 5:3 - IRQ Selection&n;&t;   0 0 0 - IRQ 2/9&n;&t;   0 0 1 - IRQ 5&n;&t;   0 1 0 - IRQ 12&n;&t;   0 1 1 - IRQ 15&n;&t;   1 0 0 - Reserved&n;&t;   1 0 1 - Reserved&n;&t;   1 1 0 - Reserved&n;&t;   1 1 1 - Reserved&n;     &n;&t;   Bits 2:1 - Reserved&n;&t;   Bit 0 - Disable Boot ROM&n;&t;   0 - memory accesses to 03FC30-03FFFFH utilize the internal Boot ROM&n;&t;   1 - memory accesses to 03FC30-03FFFFH are directed to external &n;&t;   storage.&n;     &n;&t;*/
multiline_comment|/* configure hardware: IRQ, enable interrupts, &n;&t;   plus external 9-pin MIDI interface selected&n;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
id|bits
comma
id|dev.data_port
)paren
suffix:semicolon
multiline_comment|/* CONTROL REGISTER&n;&n;&t;   0 Host Rx Interrupt Enable (1=Enabled)      0x1&n;&t;   1 Unused                                    0x2&n;&t;   2 Unused                                    0x4&n;&t;   3 Unused                                    0x8&n;&t;   4 Host Tx Interrupt Enable                 0x10&n;&t;   5 Mute (0=Mute; 1=Play)                    0x20&n;&t;   6 Master Interrupt Enable (1=Enabled)      0x40&n;&t;   7 Master Reset (0=Reset; 1=Run)            0x80&n;&n;&t;   Take us out of reset, mute output, master + TX + RX interrupts on.&n;&t;   &n;&t;   We&squot;ll get an interrupt presumably to tell us that the TX&n;&t;   register is clear.&n;&t;*/
id|wavefront_should_cause_interrupt
c_func
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x10
op_or
l_int|0x1
comma
id|dev.control_port
comma
(paren
id|reset_time
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Note: data port is now the data port, not the h/w initialization&n;&t;   port.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev.irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;intr not received after h/w un-reset.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|dev.interrupts_on
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Note: data port is now the data port, not the h/w initialization&n;&t;   port.&n;&n;&t;   At this point, only &quot;HW VERSION&quot; or &quot;DOWNLOAD OS&quot; commands&n;&t;   will work. So, issue one of them, and wait for TX&n;&t;   interrupt. This can take a *long* time after a cold boot,&n;&t;   while the ISC ROM does its RAM test. The SDK says up to 4&n;&t;   seconds - with 12MB of RAM on a Tropez+, it takes a lot&n;&t;   longer than that (~16secs). Note that the card understands&n;&t;   the difference between a warm and a cold boot, so&n;&t;   subsequent ISC2115 reboots (say, caused by module&n;&t;   reloading) will get through this much faster.&n;&n;&t;   XXX Interesting question: why is no RX interrupt received first ?&n;&t;*/
id|wavefront_should_cause_interrupt
c_func
(paren
id|WFC_HARDWARE_VERSION
comma
id|dev.data_port
comma
id|ramcheck_time
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev.irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;post-RAM-check interrupt not received.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wavefront_wait
(paren
id|STAT_CAN_READ
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;no response to HW version cmd.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;board not responding correctly.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwv
(braket
l_int|0
)braket
op_eq
l_int|0xFF
)paren
(brace
multiline_comment|/* NAK */
multiline_comment|/* Board&squot;s RAM test failed. Try to read error code,&n;&t;&t;   and tell us about it either way.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;on-board RAM test failed &quot;
l_string|&quot;(bad error code).&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;on-board RAM test failed &quot;
l_string|&quot;(error code: 0x%x).&bslash;n&quot;
comma
id|hwv
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* We&squot;re OK, just get the next byte of the HW version response */
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|1
)braket
op_assign
id|wavefront_read
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;incorrect h/w response.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;hardware version %d.%d&bslash;n&quot;
comma
id|hwv
(braket
l_int|0
)braket
comma
id|hwv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|gone_bad
suffix:colon
r_if
c_cond
(paren
id|dev.irq
op_ge
l_int|0
)paren
(brace
id|free_irq
(paren
id|dev.irq
comma
op_amp
id|dev
)paren
suffix:semicolon
id|dev.irq
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|detect_wavefront
r_static
r_int
id|__init
id|detect_wavefront
(paren
r_int
id|irq
comma
r_int
id|io_base
)paren
(brace
r_int
r_char
id|rbuf
(braket
l_int|4
)braket
comma
id|wbuf
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* TB docs say the device takes up 8 ports, but we know that&n;&t;   if there is an FX device present (i.e. a Tropez+) it really&n;&t;   consumes 16.&n;&t;*/
r_if
c_cond
(paren
id|check_region
(paren
id|io_base
comma
l_int|16
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;IO address range 0x%x - 0x%x &quot;
l_string|&quot;already in use - ignored&bslash;n&quot;
comma
id|dev.base
comma
id|dev.base
op_plus
l_int|15
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dev.irq
op_assign
id|irq
suffix:semicolon
id|dev.base
op_assign
id|io_base
suffix:semicolon
id|dev.israw
op_assign
l_int|0
suffix:semicolon
id|dev.debug
op_assign
id|debug_default
suffix:semicolon
id|dev.interrupts_on
op_assign
l_int|0
suffix:semicolon
id|dev.irq_cnt
op_assign
l_int|0
suffix:semicolon
id|dev.rom_samples_rdonly
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX default lock on ROM sample slots */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_FIRMWARE_VERSION
comma
id|rbuf
comma
id|wbuf
)paren
op_eq
l_int|0
)paren
(brace
id|dev.fw_version
(braket
l_int|0
)braket
op_assign
id|rbuf
(braket
l_int|0
)braket
suffix:semicolon
id|dev.fw_version
(braket
l_int|1
)braket
op_assign
id|rbuf
(braket
l_int|1
)braket
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;firmware %d.%d already loaded.&bslash;n&quot;
comma
id|rbuf
(braket
l_int|0
)braket
comma
id|rbuf
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* check that a command actually works */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_HARDWARE_VERSION
comma
id|rbuf
comma
id|wbuf
)paren
op_eq
l_int|0
)paren
(brace
id|dev.hw_version
(braket
l_int|0
)braket
op_assign
id|rbuf
(braket
l_int|0
)braket
suffix:semicolon
id|dev.hw_version
(braket
l_int|1
)braket
op_assign
id|rbuf
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;not raw, but no &quot;
l_string|&quot;hardware version!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wf_raw
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;reloading firmware anyway.&bslash;n&quot;
)paren
suffix:semicolon
id|dev.israw
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev.israw
op_assign
l_int|1
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;no response to firmware probe, assume raw.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|init_waitqueue_head
(paren
op_amp
id|dev.interrupt_sleeper
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_hw_reset
(paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;hardware reset failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for FX device, present only on Tropez+ */
id|dev.has_fx
op_assign
(paren
id|detect_wffx
(paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#include &quot;os.h&quot;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|errno
r_static
r_int
id|errno
suffix:semicolon
r_static
r_int
DECL|function|wavefront_download_firmware
id|wavefront_download_firmware
(paren
r_char
op_star
id|path
)paren
(brace
r_int
r_char
id|section
(braket
id|WF_SECTION_MAX
)braket
suffix:semicolon
r_char
id|section_length
suffix:semicolon
multiline_comment|/* yes, just a char; max value is WF_SECTION_MAX */
r_int
id|section_cnt_downloaded
op_assign
l_int|0
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
multiline_comment|/* This tries to be a bit cleverer than the stuff Alan Cox did for&n;&t;   the generic sound firmware, in that it actually knows&n;&t;   something about the structure of the Motorola firmware. In&n;&t;   particular, it uses a version that has been stripped of the&n;&t;   20K of useless header information, and had section lengths&n;&t;   added, making it possible to load the entire OS without any&n;&t;   [kv]malloc() activity, since the longest entity we ever read is&n;&t;   42 bytes (well, WF_SECTION_MAX) long.&n;&t;*/
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_assign
id|open
(paren
id|path
comma
l_int|0
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;Unable to load &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|read
(paren
id|fd
comma
op_amp
id|section_length
comma
r_sizeof
(paren
id|section_length
)paren
)paren
)paren
op_ne
r_sizeof
(paren
id|section_length
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;firmware read error.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|section_length
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|fd
comma
id|section
comma
id|section_length
)paren
op_ne
id|section_length
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;firmware section &quot;
l_string|&quot;read error.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* Send command */
r_if
c_cond
(paren
id|wavefront_write
(paren
id|WFC_DOWNLOAD_OS
)paren
)paren
(brace
r_goto
id|failure
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|section_length
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_write
(paren
id|section
(braket
id|i
)braket
)paren
)paren
(brace
r_goto
id|failure
suffix:semicolon
)brace
)brace
multiline_comment|/* get ACK */
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|STAT_CAN_READ
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|inb
(paren
id|dev.data_port
)paren
)paren
op_ne
id|WF_ACK
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;download &quot;
l_string|&quot;of section #%d not &quot;
l_string|&quot;acknowledged, ack = 0x%x&bslash;n&quot;
comma
id|section_cnt_downloaded
op_plus
l_int|1
comma
id|c
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;time out for firmware ACK.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
)brace
id|close
(paren
id|fd
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failure
suffix:colon
id|close
(paren
id|fd
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;&bslash;nWaveFront: firmware download failed!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|wavefront_config_midi
r_static
r_int
id|__init
id|wavefront_config_midi
(paren
r_void
)paren
(brace
r_int
r_char
id|rbuf
(braket
l_int|4
)braket
comma
id|wbuf
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|detect_wf_mpu
(paren
id|dev.irq
comma
id|dev.base
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;could not find working MIDI device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev.mididev
op_assign
id|install_wf_mpu
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;MIDI interfaces not configured&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Route external MIDI to WaveFront synth (by default) */
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_MISYNTH_ON
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;cannot enable MIDI-IN to synth routing.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX error ? */
)brace
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
multiline_comment|/* Get the regular MIDI patch loading function, so we can&n;&t;   use it if we ever get handed a SYSEX patch. This is&n;&t;   unlikely, because its so damn slow, but we may as well&n;&t;   leave this functionality from maui.c behind, since it&n;&t;   could be useful for sequencer applications that can&n;&t;   only use MIDI to do patch loading.&n;&t;*/
r_if
c_cond
(paren
id|midi_devs
(braket
id|dev.mididev
)braket
op_member_access_from_pointer
id|converter
op_ne
l_int|NULL
)paren
(brace
id|midi_load_patch
op_assign
id|midi_devs
(braket
id|dev.mididev
)braket
op_member_access_from_pointer
id|converter-&gt;load_patch
suffix:semicolon
id|midi_devs
(braket
id|dev.mididev
)braket
op_member_access_from_pointer
id|converter-&gt;load_patch
op_assign
op_amp
id|wavefront_oss_load_patch
suffix:semicolon
)brace
macro_line|#endif OSS_SUPPORT_SEQ
multiline_comment|/* Turn on Virtual MIDI, but first *always* turn it off,&n;&t;   since otherwise consectutive reloads of the driver will&n;&t;   never cause the hardware to generate the initial &quot;internal&quot; or &n;&t;   &quot;external&quot; source bytes in the MIDI data stream. This&n;&t;   is pretty important, since the internal hardware generally will&n;&t;   be used to generate none or very little MIDI output, and&n;&t;   thus the only source of MIDI data is actually external. Without&n;&t;   the switch bytes, the driver will think it all comes from&n;&t;   the internal interface. Duh.&n;&t;*/
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_VMIDI_OFF
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;virtual MIDI mode not disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We&squot;re OK, but missing the external MIDI dev */
)brace
r_if
c_cond
(paren
(paren
id|dev.ext_mididev
op_assign
id|virtual_midi_enable
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;no virtual MIDI access.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_VMIDI_ON
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;cannot enable virtual MIDI mode.&bslash;n&quot;
)paren
suffix:semicolon
id|virtual_midi_disable
(paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wavefront_do_reset
r_static
r_int
id|__init
id|wavefront_do_reset
(paren
r_int
id|atboot
)paren
(brace
r_char
id|voices
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atboot
op_logical_and
id|wavefront_hw_reset
(paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;hw reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev.israw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_download_firmware
(paren
id|ospath
)paren
)paren
(brace
r_goto
id|gone_bad
suffix:semicolon
)brace
id|dev.israw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for the OS to get running. The protocol for&n;&t;&t;   this is non-obvious, and was determined by&n;&t;&t;   using port-IO tracing in DOSemu and some&n;&t;&t;   experimentation here.&n;&t;&t;   &n;&t;&t;   Rather than using timed waits, use interrupts creatively.&n;&t;&t;*/
id|wavefront_should_cause_interrupt
(paren
id|WFC_NOOP
comma
id|dev.data_port
comma
(paren
id|osrun_time
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev.irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;no post-OS interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* Now, do it again ! */
id|wavefront_should_cause_interrupt
(paren
id|WFC_NOOP
comma
id|dev.data_port
comma
(paren
l_int|10
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev.irq_ok
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;no post-OS interrupt(2).&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* OK, no (RX/TX) interrupts any more, but leave mute&n;&t;&t;   in effect. &n;&t;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
comma
id|dev.control_port
)paren
suffix:semicolon
multiline_comment|/* No need for the IRQ anymore */
id|free_irq
(paren
id|dev.irq
comma
op_amp
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev.has_fx
op_logical_and
id|fx_raw
)paren
(brace
id|wffx_init
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* SETUPSND.EXE asks for sample memory config here, but since i&n;&t;   have no idea how to interpret the result, we&squot;ll forget&n;&t;   about it.&n;&t;*/
r_if
c_cond
(paren
(paren
id|dev.freemem
op_assign
id|wavefront_freemem
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
r_goto
id|gone_bad
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;available DRAM %dk&bslash;n&quot;
comma
id|dev.freemem
op_div
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_write
(paren
l_int|0xf0
)paren
op_logical_or
id|wavefront_write
(paren
l_int|1
)paren
op_logical_or
(paren
id|wavefront_read
(paren
)paren
OL
l_int|0
)paren
)paren
(brace
id|dev.debug
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;MPU emulation mode not set.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|voices
(braket
l_int|0
)braket
op_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_cmd
(paren
id|WFC_SET_NVOICES
comma
l_int|0
comma
id|voices
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;cannot set number of voices to 32.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|gone_bad
suffix:colon
multiline_comment|/* reset that sucker so that it doesn&squot;t bother us. */
id|outb
(paren
l_int|0x0
comma
id|dev.control_port
)paren
suffix:semicolon
id|dev.interrupts_on
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev.irq
op_ge
l_int|0
)paren
(brace
id|free_irq
(paren
id|dev.irq
comma
op_amp
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|wavefront_init
r_static
r_int
id|__init
id|wavefront_init
(paren
r_int
id|atboot
)paren
(brace
r_int
id|samples_are_from_rom
suffix:semicolon
r_if
c_cond
(paren
id|dev.israw
)paren
(brace
id|samples_are_from_rom
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* XXX is this always true ? */
id|samples_are_from_rom
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev.israw
op_logical_or
id|fx_raw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_do_reset
(paren
id|atboot
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|wavefront_get_sample_status
(paren
id|samples_are_from_rom
)paren
suffix:semicolon
id|wavefront_get_program_status
(paren
)paren
suffix:semicolon
id|wavefront_get_patch_status
(paren
)paren
suffix:semicolon
multiline_comment|/* Start normal operation: unreset, master interrupt enabled, no mute&n;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x20
comma
id|dev.control_port
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|install_wavefront
r_static
r_int
id|__init
id|install_wavefront
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev.synth_dev
op_assign
id|register_sound_synth
(paren
op_amp
id|wavefront_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;cannot register raw synth&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
r_if
c_cond
(paren
(paren
id|dev.oss_dev
op_assign
id|sound_alloc_synthdev
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;Too many sequencers&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|synth_devs
(braket
id|dev.oss_dev
)braket
op_assign
op_amp
id|wavefront_operations
suffix:semicolon
)brace
macro_line|#endif OSS_SUPPORT_SEQ
r_if
c_cond
(paren
id|wavefront_init
(paren
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;initialization failed.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
id|sound_unload_synthdev
(paren
id|dev.oss_dev
)paren
suffix:semicolon
macro_line|#endif OSS_SUPPORT_SEQ
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|request_region
(paren
id|dev.base
op_plus
l_int|2
comma
l_int|6
comma
l_string|&quot;wavefront synth&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.has_fx
)paren
(brace
id|request_region
(paren
id|dev.base
op_plus
l_int|8
comma
l_int|8
comma
l_string|&quot;wavefront fx&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_config_midi
(paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;could not initialize MIDI.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|dev.oss_dev
suffix:semicolon
)brace
DECL|function|uninstall_wavefront
r_static
r_void
id|__exit
id|uninstall_wavefront
(paren
r_void
)paren
(brace
multiline_comment|/* the first two i/o addresses are freed by the wf_mpu code */
id|release_region
(paren
id|dev.base
op_plus
l_int|2
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.has_fx
)paren
(brace
id|release_region
(paren
id|dev.base
op_plus
l_int|8
comma
l_int|8
)paren
suffix:semicolon
)brace
id|unregister_sound_synth
(paren
id|dev.synth_dev
)paren
suffix:semicolon
macro_line|#if OSS_SUPPORT_LEVEL &amp; OSS_SUPPORT_SEQ
id|sound_unload_synthdev
(paren
id|dev.oss_dev
)paren
suffix:semicolon
macro_line|#endif OSS_SUPPORT_SEQ
id|uninstall_wf_mpu
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************/
multiline_comment|/*   WaveFront FX control                                              */
multiline_comment|/***********************************************************************/
macro_line|#include &quot;yss225.h&quot;
multiline_comment|/* Control bits for the Load Control Register&n; */
DECL|macro|FX_LSB_TRANSFER
mdefine_line|#define FX_LSB_TRANSFER 0x01    /* transfer after DSP LSB byte written */
DECL|macro|FX_MSB_TRANSFER
mdefine_line|#define FX_MSB_TRANSFER 0x02    /* transfer after DSP MSB byte written */
DECL|macro|FX_AUTO_INCR
mdefine_line|#define FX_AUTO_INCR    0x04    /* auto-increment DSP address after transfer */
r_static
r_int
DECL|function|wffx_idle
id|wffx_idle
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|x
op_assign
l_int|0x80
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|x
op_assign
id|inb
(paren
id|dev.fx_status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|x
op_amp
l_int|0x80
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;FX device never idle.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|detect_wffx
r_int
id|__init
id|detect_wffx
(paren
r_void
)paren
(brace
multiline_comment|/* This is a crude check, but its the best one I have for now.&n;&t;   Certainly on the Maui and the Tropez, wffx_idle() will&n;&t;   report &quot;never idle&quot;, which suggests that this test should&n;&t;   work OK.&n;&t;*/
r_if
c_cond
(paren
id|inb
(paren
id|dev.fx_status
)paren
op_amp
l_int|0x80
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;Hmm, probably a Maui or Tropez.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|attach_wffx
r_int
id|__init
id|attach_wffx
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev.fx_mididev
op_assign
id|sound_alloc_mididev
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;cannot install FX Midi driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|wffx_mute
id|wffx_mute
(paren
r_int
id|onoff
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|outb
(paren
id|onoff
ques
c_cond
l_int|0x02
suffix:colon
l_int|0x00
comma
id|dev.fx_op
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wffx_memset
id|wffx_memset
(paren
r_int
id|page
comma
r_int
id|addr
comma
r_int
id|cnt
comma
r_int
r_int
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|page
template_param
l_int|7
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;FX memset: &quot;
l_string|&quot;page must be &gt;= 0 and &lt;= 7&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
template_param
l_int|0x7f
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;FX memset: &quot;
l_string|&quot;addr must be &gt;= 0 and &lt;= 7f&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_eq
l_int|1
)paren
(brace
id|outb
(paren
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
id|page
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|addr
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
(braket
l_int|0
)braket
op_amp
l_int|0xff
)paren
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;FX: addr %d:%x set to 0x%x&bslash;n&quot;
comma
id|page
comma
id|addr
comma
id|data
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
id|page
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|addr
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
(paren
id|data
(braket
id|i
)braket
op_rshift
l_int|8
)paren
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
(paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ne
id|cnt
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;FX memset &quot;
l_string|&quot;(0x%x, 0x%x, 0x%x, %d) incomplete&bslash;n&quot;
comma
id|page
comma
id|addr
comma
(paren
r_int
)paren
id|data
comma
id|cnt
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wffx_ioctl
id|wffx_ioctl
(paren
id|wavefront_fx_info
op_star
id|r
)paren
(brace
r_int
r_int
id|page_data
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_int
op_star
id|pd
suffix:semicolon
r_switch
c_cond
(paren
id|r-&gt;request
)paren
(brace
r_case
id|WFFX_MUTE
suffix:colon
id|wffx_mute
(paren
id|r-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFFX_MEMSET
suffix:colon
r_if
c_cond
(paren
id|r-&gt;data
(braket
l_int|2
)braket
op_le
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;cannot write &quot;
l_string|&quot;&lt;= 0 bytes to FX&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r-&gt;data
(braket
l_int|2
)braket
op_eq
l_int|1
)paren
(brace
id|pd
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|r-&gt;data
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|r-&gt;data
(braket
l_int|2
)braket
OG
r_sizeof
(paren
id|page_data
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|LOGNAME
l_string|&quot;cannot write &quot;
l_string|&quot;&gt; 255 bytes to FX&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|copy_from_user
(paren
id|page_data
comma
(paren
r_int
r_char
op_star
)paren
id|r-&gt;data
(braket
l_int|3
)braket
comma
id|r-&gt;data
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pd
op_assign
id|page_data
suffix:semicolon
)brace
r_return
id|wffx_memset
(paren
id|r-&gt;data
(braket
l_int|0
)braket
comma
multiline_comment|/* page */
id|r-&gt;data
(braket
l_int|1
)braket
comma
multiline_comment|/* addr */
id|r-&gt;data
(braket
l_int|2
)braket
comma
multiline_comment|/* cnt */
id|pd
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|LOGNAME
l_string|&quot;FX: ioctl %d not yet supported&bslash;n&quot;
comma
id|r-&gt;request
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* YSS225 initialization.&n;&n;   This code was developed using DOSEMU. The Turtle Beach SETUPSND&n;   utility was run with I/O tracing in DOSEMU enabled, and a reconstruction&n;   of the port I/O done, using the Yamaha faxback document as a guide&n;   to add more logic to the code. Its really pretty wierd.&n;&n;   There was an alternative approach of just dumping the whole I/O&n;   sequence as a series of port/value pairs and a simple loop&n;   that output it. However, I hope that eventually I&squot;ll get more&n;   control over what this code does, and so I tried to stick with&n;   a somewhat &quot;algorithmic&quot; approach.&n;*/
DECL|function|wffx_init
r_static
r_int
id|__init
id|wffx_init
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* Set all bits for all channels on the MOD unit to zero */
multiline_comment|/* XXX But why do this twice ? */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|2
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0xff
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
(paren
)paren
)paren
(brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|dev.fx_op
)paren
suffix:semicolon
multiline_comment|/* mute on */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x44
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x42
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x43
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x7c
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x7e
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x46
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x49
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x47
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x4a
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
multiline_comment|/* either because of stupidity by TB&squot;s programmers, or because it&n;&t;   actually does something, rezero the MOD page.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0xff
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
(paren
)paren
)paren
(brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
)brace
multiline_comment|/* load page zero */
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_zero
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_zero
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_zero
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Now load page one */
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x01
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_one
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_one
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_one
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_two
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_two
(braket
id|i
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_three
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_three
(braket
id|i
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x04
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_four
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_four
(braket
id|i
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Load memory area (page six) */
id|outb
(paren
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x06
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_six
)paren
suffix:semicolon
id|i
op_add_assign
l_int|3
)paren
(brace
id|outb
(paren
id|page_six
(braket
id|i
)braket
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|page_six
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_six
(braket
id|i
op_plus
l_int|2
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_seven
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_seven
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_seven
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Now setup the MOD area. We do this algorithmically in order to&n;&t;   save a little data space. It could be done in the same fashion&n;&t;   as the &quot;pages&quot;.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
op_le
l_int|0x0f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
l_int|0x01
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
id|i
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0xb0
suffix:semicolon
id|i
op_le
l_int|0xbf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0xf0
suffix:semicolon
id|i
op_le
l_int|0xff
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0x1d
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x1e
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x1f
suffix:semicolon
id|i
op_le
l_int|0x2d
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x2e
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x2f
suffix:semicolon
id|i
op_le
l_int|0x3e
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x3f
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x40
suffix:semicolon
id|i
op_le
l_int|0x4d
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x4e
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0e
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x4f
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0e
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x50
suffix:semicolon
id|i
op_le
l_int|0x6b
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x6c
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x6d
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x6e
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x6f
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x70
suffix:semicolon
id|i
op_le
l_int|0x7f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0xc0
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x80
suffix:semicolon
id|i
op_le
l_int|0xaf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0xc0
suffix:semicolon
id|i
op_le
l_int|0xdd
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0xde
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0xdf
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0xe0
suffix:semicolon
id|i
op_le
l_int|0xef
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
op_le
l_int|0x0f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
l_int|0x01
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
id|i
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x01
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x02
comma
id|dev.fx_op
)paren
suffix:semicolon
multiline_comment|/* mute on */
multiline_comment|/* Now set the coefficients and so forth for the programs above */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|coefficients
)paren
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
id|outb
(paren
id|coefficients
(braket
id|i
)braket
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|coefficients
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|coefficients
(braket
id|i
op_plus
l_int|2
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|coefficients
(braket
id|i
op_plus
l_int|3
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Some settings (?) that are too small to bundle into loops */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x1e
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x14
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0xde
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0xdf
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x20
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
multiline_comment|/* some more coefficients */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x06
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x78
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x40
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0f
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0b
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0f
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0xff
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x0a
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x46
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x49
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
multiline_comment|/* Now, for some strange reason, lets reload every page&n;&t;   and all the coefficients over again. I have *NO* idea&n;&t;   why this is done. I do know that no sound is produced&n;&t;   is this phase is omitted.&n;&t;*/
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_zero_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_zero_v2
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_zero_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x01
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_one_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_one_v2
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_one_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x02
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_two_v2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_two_v2
(braket
id|i
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_three_v2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_three_v2
(braket
id|i
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x04
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_four_v2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
id|page_four_v2
(braket
id|i
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x06
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
multiline_comment|/* Page six v.2 is algorithmic */
r_for
c_loop
(paren
id|i
op_assign
l_int|0x10
suffix:semicolon
id|i
op_le
l_int|0x3e
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|i
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|outb
(paren
id|FX_AUTO_INCR
op_or
id|FX_LSB_TRANSFER
comma
id|dev.fx_lcr
)paren
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
l_int|0x10
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|page_seven_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|page_seven_v2
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|page_seven_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|mod_v2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|outb
(paren
id|mod_v2
(braket
id|i
)braket
comma
id|dev.fx_mod_addr
)paren
suffix:semicolon
id|outb
(paren
id|mod_v2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_mod_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|coefficients2
)paren
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
id|outb
(paren
id|coefficients2
(braket
id|i
)braket
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|outb
(paren
id|coefficients2
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|coefficients2
(braket
id|i
op_plus
l_int|2
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|coefficients2
(braket
id|i
op_plus
l_int|3
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|coefficients3
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_int
id|x
suffix:semicolon
id|outb
(paren
l_int|0x07
comma
id|dev.fx_dsp_page
)paren
suffix:semicolon
id|x
op_assign
(paren
id|i
op_mod
l_int|4
)paren
ques
c_cond
l_int|0x4e
suffix:colon
l_int|0x4c
suffix:semicolon
id|outb
(paren
id|x
comma
id|dev.fx_dsp_addr
)paren
suffix:semicolon
id|outb
(paren
id|coefficients3
(braket
id|i
)braket
comma
id|dev.fx_dsp_msb
)paren
suffix:semicolon
id|outb
(paren
id|coefficients3
(braket
id|i
op_plus
l_int|1
)braket
comma
id|dev.fx_dsp_lsb
)paren
suffix:semicolon
)brace
id|outb
(paren
l_int|0x00
comma
id|dev.fx_op
)paren
suffix:semicolon
multiline_comment|/* mute off */
r_if
c_cond
(paren
op_logical_neg
id|wffx_idle
c_func
(paren
)paren
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|io
r_static
r_int
id|io
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Paul Barton-Davis &lt;pbd@op.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Turtle Beach WaveFront Linux Driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_wavfront
r_static
r_int
id|__init
id|init_wavfront
(paren
r_void
)paren
(brace
id|printk
(paren
l_string|&quot;Turtle Beach WaveFront Driver&bslash;n&quot;
l_string|&quot;Copyright (C) by Hannu Solvainen, &quot;
l_string|&quot;Paul Barton-Davis 1993-1998.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX t&squot;would be lovely to ask the CS4232 for these values, eh ? */
r_if
c_cond
(paren
id|io
op_eq
op_minus
l_int|1
op_logical_or
id|irq
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;irq and io options must be set.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_interrupt_bits
(paren
id|irq
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|LOGNAME
l_string|&quot;IRQ must be 9, 5, 12 or 15 (not %d)&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|detect_wavefront
(paren
id|irq
comma
id|io
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|install_wavefront
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_wavfront
r_static
r_void
id|__exit
id|cleanup_wavfront
(paren
r_void
)paren
(brace
id|uninstall_wavefront
(paren
)paren
suffix:semicolon
)brace
DECL|variable|init_wavfront
id|module_init
c_func
(paren
id|init_wavfront
)paren
suffix:semicolon
DECL|variable|cleanup_wavfront
id|module_exit
c_func
(paren
id|cleanup_wavfront
)paren
suffix:semicolon
eof
