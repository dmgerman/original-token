multiline_comment|/*&n; * Sound driver for Silicon Graphics 320 and 540 Visual Workstations&squot;&n; * onboard audio.  See notes in ../../Documentation/sound/vwsnd .&n; *&n; * Copyright 1999 Silicon Graphics, Inc.  All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
DECL|macro|VWSND_DEBUG
macro_line|#undef VWSND_DEBUG&t;&t;&t;/* define for debugging */
multiline_comment|/*&n; * XXX to do -&n; *&n; *&t;External sync.&n; *&t;Rename swbuf, hwbuf, u&amp;i, hwptr&amp;swptr to something rational.&n; *&t;Bug - if select() called before read(), pcm_setup() not called.&n; *&t;Bug - output doesn&squot;t stop soon enough if process killed.&n; */
multiline_comment|/*&n; * Things to test -&n; *&n; *&t;Will readv/writev work?  Write a test.&n; *&n; *&t;insmod/rmmod 100 million times.&n; *&n; *&t;Run I/O until int ptrs wrap around (roughly 6.2 hours @ DAT&n; *&t;rate).&n; *&n; *&t;Concurrent threads banging on mixer simultaneously, both UP&n; *&t;and SMP kernels.  Especially, watch for thread A changing&n; *&t;OUTSRC while thread B changes gain -- both write to the same&n; *&t;ad1843 register.&n; *&n; *&t;What happens if a client opens /dev/audio then forks?&n; *&t;Do two procs have /dev/audio open?  Test.&n; *&n; *&t;Pump audio through the CD, MIC and line inputs and verify that&n; *&t;they mix/mute into the output.&n; *&n; *&t;Apps:&n; *&t;&t;amp&n; *&t;&t;mpg123&n; *&t;&t;x11amp&n; *&t;&t;mxv&n; *&t;&t;kmedia&n; *&t;&t;esound&n; *&t;&t;need more input apps&n; *&n; *&t;Run tests while bombarding with signals.  setitimer(2) will do it...  */
multiline_comment|/*&n; * This driver is organized in nine sections.&n; * The nine sections are:&n; *&n; *&t;debug stuff&n; * &t;low level lithium access&n; *&t;high level lithium access&n; *&t;AD1843 access&n; *&t;PCM I/O&n; *&t;audio driver&n; *&t;mixer driver&n; *&t;probe/attach/unload&n; *&t;initialization and loadable kernel module interface&n; *&n; * That is roughly the order of increasing abstraction, so forward&n; * dependencies are minimal.&n; */
multiline_comment|/*&n; * Locking Notes&n; *&n; *&t;INC_USE_COUNT and DEC_USE_COUNT keep track of the number of&n; *&t;open descriptors to this driver. They store it in vwsnd_use_count.&n; * &t;The global device list, vwsnd_dev_list,&t;is immutable when the IN_USE&n; *&t;is true.&n; *&n; *&t;devc-&gt;open_lock is a semaphore that is used to enforce the&n; *&t;single reader/single writer rule for /dev/audio.  The rule is&n; *&t;that each device may have at most one reader and one writer.&n; *&t;Open will block until the previous client has closed the&n; *&t;device, unless O_NONBLOCK is specified.&n; *&n; *&t;The semaphore devc-&gt;io_sema serializes PCM I/O syscalls.  This&n; *&t;is unnecessary in Linux 2.2, because the kernel lock&n; *&t;serializes read, write, and ioctl globally, but it&squot;s there,&n; *&t;ready for the brave, new post-kernel-lock world.&n; *&n; *&t;Locking between interrupt and baselevel is handled by the&n; *&t;&quot;lock&quot; spinlock in vwsnd_port (one lock each for read and&n; *&t;write).  Each half holds the lock just long enough to see what&n; *&t;area it owns and update its pointers.  See pcm_output() and&n; *&t;pcm_input() for most of the gory stuff.&n; *&n; *&t;devc-&gt;mix_sema serializes all mixer ioctls.  This is also&n; *&t;redundant because of the kernel lock.&n; *&n; *&t;The lowest level lock is lith-&gt;lithium_lock.  It is a&n; *&t;spinlock which is held during the two-register tango of&n; *&t;reading/writing an AD1843 register.  See&n; *&t;li_{read,write}_ad1843_reg().&n; */
multiline_comment|/*&n; * Sample Format Notes&n; *&n; *&t;Lithium&squot;s DMA engine has two formats: 16-bit 2&squot;s complement&n; *&t;and 8-bit unsigned .  16-bit transfers the data unmodified, 2&n; *&t;bytes per sample.  8-bit unsigned transfers 1 byte per sample&n; *&t;and XORs each byte with 0x80.  Lithium can input or output&n; *&t;either mono or stereo in either format.&n; *&n; *&t;The AD1843 has four formats: 16-bit 2&squot;s complement, 8-bit&n; *&t;unsigned, 8-bit mu-Law and 8-bit A-Law.&n; *&n; *&t;This driver supports five formats: AFMT_S8, AFMT_U8,&n; *&t;AFMT_MU_LAW, AFMT_A_LAW, and AFMT_S16_LE.&n; *&n; *&t;For AFMT_U8 output, we keep the AD1843 in 16-bit mode, and&n; *&t;rely on Lithium&squot;s XOR to translate between U8 and S8.&n; *&n; *&t;For AFMT_S8, AFMT_MU_LAW and AFMT_A_LAW output, we have to XOR&n; *&t;the 0x80 bit in software to compensate for Lithium&squot;s XOR.&n; *&t;This happens in pcm_copy_{in,out}().&n; *&n; * Changes:&n; * 11-10-2000&t;Bartlomiej Zolnierkiewicz &lt;bkz@linux-ide.org&gt;&n; *&t;&t;Added some __init/__exit&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/semaphore.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/fixmap.h&gt;
macro_line|#include &lt;asm/cobalt.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;sound_config.h&quot;
multiline_comment|/*****************************************************************************/
multiline_comment|/* debug stuff */
macro_line|#ifdef VWSND_DEBUG
macro_line|#include &lt;linux/interrupt.h&gt;&t;&t;/* for in_interrupt() */
DECL|variable|shut_up
r_static
r_int
id|shut_up
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * dbgassert - called when an assertion fails.&n; */
DECL|function|dbgassert
r_static
r_void
id|dbgassert
c_func
(paren
r_const
r_char
op_star
id|fcn
comma
r_int
id|line
comma
r_const
r_char
op_star
id|expr
)paren
(brace
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;ASSERTION FAILED IN INTERRUPT, %s:%s:%d %s&bslash;n&quot;
comma
id|__FILE__
comma
id|fcn
comma
id|line
comma
id|expr
)paren
suffix:semicolon
r_else
(brace
r_int
id|x
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ASSERTION FAILED, %s:%s:%d %s&bslash;n&quot;
comma
id|__FILE__
comma
id|fcn
comma
id|line
comma
id|expr
)paren
suffix:semicolon
id|x
op_assign
op_star
(paren
r_volatile
r_int
op_star
)paren
l_int|0
suffix:semicolon
multiline_comment|/* force proc to exit */
)brace
)brace
multiline_comment|/*&n; * Bunch of useful debug macros:&n; *&n; *&t;ASSERT&t;- print unless e nonzero (panic if in interrupt)&n; *&t;DBGDO&t;- include arbitrary code if debugging&n; *&t;DBGX&t;- debug print raw (w/o function name)&n; *&t;DBGP&t;- debug print w/ function name&n; *&t;DBGE&t;- debug print function entry&n; *&t;DBGC&t;- debug print function call&n; *&t;DBGR&t;- debug print function return&n; *&t;DBGXV&t;- debug print raw when verbose&n; *&t;DBGPV&t;- debug print when verbose&n; *&t;DBGEV&t;- debug print function entry when verbose&n; *&t;DBGRV&t;- debug print function return when verbose&n; */
DECL|macro|ASSERT
mdefine_line|#define ASSERT(e)      ((e) ? (void) 0 : dbgassert(__FUNCTION__, __LINE__, #e))
DECL|macro|DBGDO
mdefine_line|#define DBGDO(x)            x
DECL|macro|DBGX
mdefine_line|#define DBGX(fmt, args...)  (in_interrupt() ? 0 : printk(KERN_ERR fmt, ##args))
DECL|macro|DBGP
mdefine_line|#define DBGP(fmt, args...)  (DBGX(__FUNCTION__ &quot;: &quot; fmt, ##args))
DECL|macro|DBGE
mdefine_line|#define DBGE(fmt, args...)  (DBGX(__FUNCTION__ fmt, ##args))
DECL|macro|DBGC
mdefine_line|#define DBGC(rtn)           (DBGP(&quot;calling %s&bslash;n&quot;, rtn))
DECL|macro|DBGR
mdefine_line|#define DBGR()              (DBGP(&quot;returning&bslash;n&quot;))
DECL|macro|DBGXV
mdefine_line|#define DBGXV(fmt, args...) (shut_up ? 0 : DBGX(fmt, ##args))
DECL|macro|DBGPV
mdefine_line|#define DBGPV(fmt, args...) (shut_up ? 0 : DBGP(fmt, ##args))
DECL|macro|DBGEV
mdefine_line|#define DBGEV(fmt, args...) (shut_up ? 0 : DBGE(fmt, ##args))
DECL|macro|DBGCV
mdefine_line|#define DBGCV(rtn)          (shut_up ? 0 : DBGC(rtn))
DECL|macro|DBGRV
mdefine_line|#define DBGRV()             (shut_up ? 0 : DBGR())
macro_line|#else /* !VWSND_DEBUG */
DECL|macro|ASSERT
mdefine_line|#define ASSERT(e)           ((void) 0)
DECL|macro|DBGDO
mdefine_line|#define DBGDO(x)            /* don&squot;t */
DECL|macro|DBGX
mdefine_line|#define DBGX(fmt, args...)  ((void) 0)
DECL|macro|DBGP
mdefine_line|#define DBGP(fmt, args...)  ((void) 0)
DECL|macro|DBGE
mdefine_line|#define DBGE(fmt, args...)  ((void) 0)
DECL|macro|DBGC
mdefine_line|#define DBGC(rtn)           ((void) 0)
DECL|macro|DBGR
mdefine_line|#define DBGR()              ((void) 0)
DECL|macro|DBGPV
mdefine_line|#define DBGPV(fmt, args...) ((void) 0)
DECL|macro|DBGXV
mdefine_line|#define DBGXV(fmt, args...) ((void) 0)
DECL|macro|DBGEV
mdefine_line|#define DBGEV(fmt, args...) ((void) 0)
DECL|macro|DBGCV
mdefine_line|#define DBGCV(rtn)          ((void) 0)
DECL|macro|DBGRV
mdefine_line|#define DBGRV()             ((void) 0)
macro_line|#endif /* !VWSND_DEBUG */
multiline_comment|/*****************************************************************************/
multiline_comment|/* low level lithium access */
multiline_comment|/*&n; * We need to talk to Lithium registers on three pages.  Here are&n; * the pages&squot; offsets from the base address (0xFF001000).&n; */
r_enum
(brace
DECL|enumerator|LI_PAGE0_OFFSET
id|LI_PAGE0_OFFSET
op_assign
l_int|0x01000
op_minus
l_int|0x1000
comma
multiline_comment|/* FF001000 */
DECL|enumerator|LI_PAGE1_OFFSET
id|LI_PAGE1_OFFSET
op_assign
l_int|0x0F000
op_minus
l_int|0x1000
comma
multiline_comment|/* FF00F000 */
DECL|enumerator|LI_PAGE2_OFFSET
id|LI_PAGE2_OFFSET
op_assign
l_int|0x10000
op_minus
l_int|0x1000
comma
multiline_comment|/* FF010000 */
)brace
suffix:semicolon
multiline_comment|/* low-level lithium data */
DECL|struct|lithium
r_typedef
r_struct
id|lithium
(brace
DECL|member|page0
id|caddr_t
id|page0
suffix:semicolon
multiline_comment|/* virtual addresses */
DECL|member|page1
id|caddr_t
id|page1
suffix:semicolon
DECL|member|page2
id|caddr_t
id|page2
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* protects codec and UST/MSC access */
DECL|typedef|lithium_t
)brace
id|lithium_t
suffix:semicolon
multiline_comment|/*&n; * li_create initializes the lithium_t structure and sets up vm mappings&n; * to access the registers.&n; * Returns 0 on success, -errno on failure.&n; */
DECL|function|li_create
r_static
r_int
id|li_create
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
r_int
id|baseaddr
)paren
(brace
r_static
r_void
id|li_destroy
c_func
(paren
id|lithium_t
op_star
)paren
suffix:semicolon
id|lith-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|lith-&gt;page0
op_assign
id|ioremap_nocache
c_func
(paren
id|baseaddr
op_plus
id|LI_PAGE0_OFFSET
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|lith-&gt;page1
op_assign
id|ioremap_nocache
c_func
(paren
id|baseaddr
op_plus
id|LI_PAGE1_OFFSET
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|lith-&gt;page2
op_assign
id|ioremap_nocache
c_func
(paren
id|baseaddr
op_plus
id|LI_PAGE2_OFFSET
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lith-&gt;page0
op_logical_or
op_logical_neg
id|lith-&gt;page1
op_logical_or
op_logical_neg
id|lith-&gt;page2
)paren
(brace
id|li_destroy
c_func
(paren
id|lith
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * li_destroy destroys the lithium_t structure and vm mappings.&n; */
DECL|function|li_destroy
r_static
r_void
id|li_destroy
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
r_if
c_cond
(paren
id|lith-&gt;page0
)paren
(brace
id|iounmap
c_func
(paren
id|lith-&gt;page0
)paren
suffix:semicolon
id|lith-&gt;page0
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lith-&gt;page1
)paren
(brace
id|iounmap
c_func
(paren
id|lith-&gt;page1
)paren
suffix:semicolon
id|lith-&gt;page1
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lith-&gt;page2
)paren
(brace
id|iounmap
c_func
(paren
id|lith-&gt;page2
)paren
suffix:semicolon
id|lith-&gt;page2
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * basic register accessors - read/write long/byte&n; */
DECL|function|li_readl
r_static
id|__inline__
r_int
r_int
id|li_readl
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|off
)paren
(brace
r_return
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|lith-&gt;page0
op_plus
id|off
)paren
suffix:semicolon
)brace
DECL|function|li_readb
r_static
id|__inline__
r_int
r_char
id|li_readb
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|off
)paren
(brace
r_return
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|lith-&gt;page0
op_plus
id|off
)paren
suffix:semicolon
)brace
DECL|function|li_writel
r_static
id|__inline__
r_void
id|li_writel
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|off
comma
r_int
r_int
id|val
)paren
(brace
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|lith-&gt;page0
op_plus
id|off
)paren
op_assign
id|val
suffix:semicolon
)brace
DECL|function|li_writeb
r_static
id|__inline__
r_void
id|li_writeb
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|off
comma
r_int
r_char
id|val
)paren
(brace
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|lith-&gt;page0
op_plus
id|off
)paren
op_assign
id|val
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/* High Level Lithium Access */
multiline_comment|/*&n; * Lithium DMA Notes&n; *&n; * Lithium has two dedicated DMA channels for audio.  They are known&n; * as comm1 and comm2 (communication areas 1 and 2).  Comm1 is for&n; * input, and comm2 is for output.  Each is controlled by three&n; * registers: BASE (base address), CFG (config) and CCTL&n; * (config/control).&n; *&n; * Each DMA channel points to a physically contiguous ring buffer in&n; * main memory of up to 8 Kbytes.  (This driver always uses 8 Kb.)&n; * There are three pointers into the ring buffer: read, write, and&n; * trigger.  The pointers are 8 bits each.  Each pointer points to&n; * 32-byte &quot;chunks&quot; of data.  The DMA engine moves 32 bytes at a time,&n; * so there is no finer-granularity control.&n; *&n; * In comm1, the hardware updates the write ptr, and software updates&n; * the read ptr.  In comm2, it&squot;s the opposite: hardware updates the&n; * read ptr, and software updates the write ptr.  I designate the&n; * hardware-updated ptr as the hwptr, and the software-updated ptr as&n; * the swptr.&n; *&n; * The trigger ptr and trigger mask are used to trigger interrupts.&n; * From the Lithium spec, section 5.6.8, revision of 12/15/1998:&n; *&n; *&t;Trigger Mask Value&n; *&n; *&t;A three bit wide field that represents a power of two mask&n; *&t;that is used whenever the trigger pointer is compared to its&n; *&t;respective read or write pointer.  A value of zero here&n; *&t;implies a mask of 0xFF and a value of seven implies a mask&n; *&t;0x01.  This value can be used to sub-divide the ring buffer&n; *&t;into pie sections so that interrupts monitor the progress of&n; *&t;hardware from section to section.&n; *&n; * My interpretation of that is, whenever the hw ptr is updated, it is&n; * compared with the trigger ptr, and the result is masked by the&n; * trigger mask.  (Actually, by the complement of the trigger mask.)&n; * If the result is zero, an interrupt is triggered.  I.e., interrupt&n; * if ((hwptr &amp; ~mask) == (trptr &amp; ~mask)).  The mask is formed from&n; * the trigger register value as mask = (1 &lt;&lt; (8 - tmreg)) - 1.&n; *&n; * In yet different words, setting tmreg to 0 causes an interrupt after&n; * every 256 DMA chunks (8192 bytes) or once per traversal of the&n; * ring buffer.  Setting it to 7 caues an interrupt every 2 DMA chunks&n; * (64 bytes) or 128 times per traversal of the ring buffer.&n; */
multiline_comment|/* Lithium register offsets and bit definitions */
DECL|macro|LI_HOST_CONTROLLER
mdefine_line|#define LI_HOST_CONTROLLER&t;0x000
DECL|macro|LI_HC_RESET
macro_line|# define LI_HC_RESET&t;&t; 0x00008000
DECL|macro|LI_HC_LINK_ENABLE
macro_line|# define LI_HC_LINK_ENABLE&t; 0x00004000
DECL|macro|LI_HC_LINK_FAILURE
macro_line|# define LI_HC_LINK_FAILURE&t; 0x00000004
DECL|macro|LI_HC_LINK_CODEC
macro_line|# define LI_HC_LINK_CODEC&t; 0x00000002
DECL|macro|LI_HC_LINK_READY
macro_line|# define LI_HC_LINK_READY&t; 0x00000001
DECL|macro|LI_INTR_STATUS
mdefine_line|#define LI_INTR_STATUS&t;&t;0x010
DECL|macro|LI_INTR_MASK
mdefine_line|#define LI_INTR_MASK&t;&t;0x014
DECL|macro|LI_INTR_LINK_ERR
macro_line|# define LI_INTR_LINK_ERR&t; 0x00008000
DECL|macro|LI_INTR_COMM2_TRIG
macro_line|# define LI_INTR_COMM2_TRIG&t; 0x00000008
DECL|macro|LI_INTR_COMM2_UNDERFLOW
macro_line|# define LI_INTR_COMM2_UNDERFLOW 0x00000004
DECL|macro|LI_INTR_COMM1_TRIG
macro_line|# define LI_INTR_COMM1_TRIG&t; 0x00000002
DECL|macro|LI_INTR_COMM1_OVERFLOW
macro_line|# define LI_INTR_COMM1_OVERFLOW  0x00000001
DECL|macro|LI_CODEC_COMMAND
mdefine_line|#define LI_CODEC_COMMAND&t;0x018
DECL|macro|LI_CC_BUSY
macro_line|# define LI_CC_BUSY&t;&t; 0x00008000
DECL|macro|LI_CC_DIR
macro_line|# define LI_CC_DIR&t;&t; 0x00000080
DECL|macro|LI_CC_DIR_RD
macro_line|#  define LI_CC_DIR_RD&t;&t;  LI_CC_DIR
DECL|macro|LI_CC_DIR_WR
macro_line|#  define LI_CC_DIR_WR&t;&t;(!LI_CC_DIR)
DECL|macro|LI_CC_ADDR_MASK
macro_line|# define LI_CC_ADDR_MASK&t; 0x0000007F
DECL|macro|LI_CODEC_DATA
mdefine_line|#define LI_CODEC_DATA&t;&t;0x01C
DECL|macro|LI_COMM1_BASE
mdefine_line|#define LI_COMM1_BASE&t;&t;0x100
DECL|macro|LI_COMM1_CTL
mdefine_line|#define LI_COMM1_CTL&t;&t;0x104
DECL|macro|LI_CCTL_RESET
macro_line|# define LI_CCTL_RESET&t;&t; 0x80000000
DECL|macro|LI_CCTL_SIZE
macro_line|# define LI_CCTL_SIZE&t;&t; 0x70000000
DECL|macro|LI_CCTL_DMA_ENABLE
macro_line|# define LI_CCTL_DMA_ENABLE&t; 0x08000000
DECL|macro|LI_CCTL_TMASK
macro_line|# define LI_CCTL_TMASK&t;&t; 0x07000000 /* trigger mask */
DECL|macro|LI_CCTL_TPTR
macro_line|# define LI_CCTL_TPTR&t;&t; 0x00FF0000 /* trigger pointer */
DECL|macro|LI_CCTL_RPTR
macro_line|# define LI_CCTL_RPTR&t;&t; 0x0000FF00
DECL|macro|LI_CCTL_WPTR
macro_line|# define LI_CCTL_WPTR&t;&t; 0x000000FF
DECL|macro|LI_COMM1_CFG
mdefine_line|#define LI_COMM1_CFG&t;&t;0x108
DECL|macro|LI_CCFG_LOCK
macro_line|# define LI_CCFG_LOCK&t;&t; 0x00008000
DECL|macro|LI_CCFG_SLOT
macro_line|# define LI_CCFG_SLOT&t;&t; 0x00000070
DECL|macro|LI_CCFG_DIRECTION
macro_line|# define LI_CCFG_DIRECTION&t; 0x00000008
DECL|macro|LI_CCFG_DIR_IN
macro_line|#  define LI_CCFG_DIR_IN&t;(!LI_CCFG_DIRECTION)
DECL|macro|LI_CCFG_DIR_OUT
macro_line|#  define LI_CCFG_DIR_OUT&t;  LI_CCFG_DIRECTION
DECL|macro|LI_CCFG_MODE
macro_line|# define LI_CCFG_MODE&t;&t; 0x00000004
DECL|macro|LI_CCFG_MODE_MONO
macro_line|#  define LI_CCFG_MODE_MONO&t;(!LI_CCFG_MODE)
DECL|macro|LI_CCFG_MODE_STEREO
macro_line|#  define LI_CCFG_MODE_STEREO&t;  LI_CCFG_MODE
DECL|macro|LI_CCFG_FORMAT
macro_line|# define LI_CCFG_FORMAT&t;&t; 0x00000003
DECL|macro|LI_CCFG_FMT_8BIT
macro_line|#  define LI_CCFG_FMT_8BIT&t;  0x00000000
DECL|macro|LI_CCFG_FMT_16BIT
macro_line|#  define LI_CCFG_FMT_16BIT&t;  0x00000001
DECL|macro|LI_COMM2_BASE
mdefine_line|#define LI_COMM2_BASE&t;&t;0x10C
DECL|macro|LI_COMM2_CTL
mdefine_line|#define LI_COMM2_CTL&t;&t;0x110
multiline_comment|/* bit definitions are the same as LI_COMM1_CTL */
DECL|macro|LI_COMM2_CFG
mdefine_line|#define LI_COMM2_CFG&t;&t;0x114
multiline_comment|/* bit definitions are the same as LI_COMM1_CFG */
DECL|macro|LI_UST_LOW
mdefine_line|#define LI_UST_LOW&t;&t;0x200&t;/* 64-bit Unadjusted System Time is */
DECL|macro|LI_UST_HIGH
mdefine_line|#define LI_UST_HIGH&t;&t;0x204&t;/* microseconds since boot */
DECL|macro|LI_AUDIO1_UST
mdefine_line|#define LI_AUDIO1_UST&t;&t;0x300&t;/* UST-MSC pairs */
DECL|macro|LI_AUDIO1_MSC
mdefine_line|#define LI_AUDIO1_MSC&t;&t;0x304&t;/* MSC (Media Stream Counter) */
DECL|macro|LI_AUDIO2_UST
mdefine_line|#define LI_AUDIO2_UST&t;&t;0x308&t;/* counts samples actually */
DECL|macro|LI_AUDIO2_MSC
mdefine_line|#define LI_AUDIO2_MSC&t;&t;0x30C&t;/* processed as of time UST */
multiline_comment|/* &n; * Lithium&squot;s DMA engine operates on chunks of 32 bytes.  We call that&n; * a DMACHUNK.&n; */
DECL|macro|DMACHUNK_SHIFT
mdefine_line|#define DMACHUNK_SHIFT 5
DECL|macro|DMACHUNK_SIZE
mdefine_line|#define DMACHUNK_SIZE (1 &lt;&lt; DMACHUNK_SHIFT)
DECL|macro|BYTES_TO_CHUNKS
mdefine_line|#define BYTES_TO_CHUNKS(bytes) ((bytes) &gt;&gt; DMACHUNK_SHIFT)
DECL|macro|CHUNKS_TO_BYTES
mdefine_line|#define CHUNKS_TO_BYTES(chunks) ((chunks) &lt;&lt; DMACHUNK_SHIFT)
multiline_comment|/*&n; * Two convenient macros to shift bitfields into/out of position.&n; *&n; * Observe that (mask &amp; -mask) is (1 &lt;&lt; low_set_bit_of(mask)).&n; * As long as mask is constant, we trust the compiler will change the&n; * multipy and divide into shifts.&n; */
DECL|macro|SHIFT_FIELD
mdefine_line|#define SHIFT_FIELD(val, mask) (((val) * ((mask) &amp; -(mask))) &amp; (mask))
DECL|macro|UNSHIFT_FIELD
mdefine_line|#define UNSHIFT_FIELD(val, mask) (((val) &amp; (mask)) / ((mask) &amp; -(mask)))
multiline_comment|/*&n; * dma_chan_desc is invariant information about a Lithium&n; * DMA channel.  There are two instances, li_comm1 and li_comm2.&n; *&n; * Note that the CCTL register fields are write ptr and read ptr, but what&n; * we care about are which pointer is updated by software and which by&n; * hardware.&n; */
DECL|struct|dma_chan_desc
r_typedef
r_struct
id|dma_chan_desc
(brace
DECL|member|basereg
r_int
id|basereg
suffix:semicolon
DECL|member|cfgreg
r_int
id|cfgreg
suffix:semicolon
DECL|member|ctlreg
r_int
id|ctlreg
suffix:semicolon
DECL|member|hwptrreg
r_int
id|hwptrreg
suffix:semicolon
DECL|member|swptrreg
r_int
id|swptrreg
suffix:semicolon
DECL|member|ustreg
r_int
id|ustreg
suffix:semicolon
DECL|member|mscreg
r_int
id|mscreg
suffix:semicolon
DECL|member|swptrmask
r_int
r_int
id|swptrmask
suffix:semicolon
DECL|member|ad1843_slot
r_int
id|ad1843_slot
suffix:semicolon
DECL|member|direction
r_int
id|direction
suffix:semicolon
multiline_comment|/* LI_CCTL_DIR_IN/OUT */
DECL|typedef|dma_chan_desc_t
)brace
id|dma_chan_desc_t
suffix:semicolon
DECL|variable|li_comm1
r_static
r_const
id|dma_chan_desc_t
id|li_comm1
op_assign
(brace
id|LI_COMM1_BASE
comma
multiline_comment|/* base register offset */
id|LI_COMM1_CFG
comma
multiline_comment|/* config register offset */
id|LI_COMM1_CTL
comma
multiline_comment|/* control register offset */
id|LI_COMM1_CTL
op_plus
l_int|0
comma
multiline_comment|/* hw ptr reg offset (write ptr) */
id|LI_COMM1_CTL
op_plus
l_int|1
comma
multiline_comment|/* sw ptr reg offset (read ptr) */
id|LI_AUDIO1_UST
comma
multiline_comment|/* ust reg offset */
id|LI_AUDIO1_MSC
comma
multiline_comment|/* msc reg offset */
id|LI_CCTL_RPTR
comma
multiline_comment|/* sw ptr bitmask in ctlval */
l_int|2
comma
multiline_comment|/* ad1843 serial slot */
id|LI_CCFG_DIR_IN
multiline_comment|/* direction */
)brace
suffix:semicolon
DECL|variable|li_comm2
r_static
r_const
id|dma_chan_desc_t
id|li_comm2
op_assign
(brace
id|LI_COMM2_BASE
comma
multiline_comment|/* base register offset */
id|LI_COMM2_CFG
comma
multiline_comment|/* config register offset */
id|LI_COMM2_CTL
comma
multiline_comment|/* control register offset */
id|LI_COMM2_CTL
op_plus
l_int|1
comma
multiline_comment|/* hw ptr reg offset (read ptr) */
id|LI_COMM2_CTL
op_plus
l_int|0
comma
multiline_comment|/* sw ptr reg offset (writr ptr) */
id|LI_AUDIO2_UST
comma
multiline_comment|/* ust reg offset */
id|LI_AUDIO2_MSC
comma
multiline_comment|/* msc reg offset */
id|LI_CCTL_WPTR
comma
multiline_comment|/* sw ptr bitmask in ctlval */
l_int|2
comma
multiline_comment|/* ad1843 serial slot */
id|LI_CCFG_DIR_OUT
multiline_comment|/* direction */
)brace
suffix:semicolon
multiline_comment|/*&n; * dma_chan is variable information about a Lithium DMA channel.&n; *&n; * The desc field points to invariant information.&n; * The lith field points to a lithium_t which is passed&n; * to li_read* and li_write* to access the registers.&n; * The *val fields shadow the lithium registers&squot; contents.&n; */
DECL|struct|dma_chan
r_typedef
r_struct
id|dma_chan
(brace
DECL|member|desc
r_const
id|dma_chan_desc_t
op_star
id|desc
suffix:semicolon
DECL|member|lith
id|lithium_t
op_star
id|lith
suffix:semicolon
DECL|member|baseval
r_int
r_int
id|baseval
suffix:semicolon
DECL|member|cfgval
r_int
r_int
id|cfgval
suffix:semicolon
DECL|member|ctlval
r_int
r_int
id|ctlval
suffix:semicolon
DECL|typedef|dma_chan_t
)brace
id|dma_chan_t
suffix:semicolon
multiline_comment|/*&n; * ustmsc is a UST/MSC pair (Unadjusted System Time/Media Stream Counter).&n; * UST is time in microseconds since the system booted, and MSC is a&n; * counter that increments with every audio sample.&n; */
DECL|struct|ustmsc
r_typedef
r_struct
id|ustmsc
(brace
DECL|member|ust
r_int
r_int
r_int
id|ust
suffix:semicolon
DECL|member|msc
r_int
r_int
id|msc
suffix:semicolon
DECL|typedef|ustmsc_t
)brace
id|ustmsc_t
suffix:semicolon
multiline_comment|/*&n; * li_ad1843_wait waits until lithium says the AD1843 register&n; * exchange is not busy.  Returns 0 on success, -EBUSY on timeout.&n; *&n; * Locking: must be called with lithium_lock held.&n; */
DECL|function|li_ad1843_wait
r_static
r_int
id|li_ad1843_wait
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
r_int
r_int
id|later
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|li_readl
c_func
(paren
id|lith
comma
id|LI_CODEC_COMMAND
)paren
op_amp
id|LI_CC_BUSY
)paren
r_if
c_cond
(paren
id|jiffies
op_ge
id|later
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * li_read_ad1843_reg returns the current contents of a 16 bit AD1843 register.&n; *&n; * Returns unsigned register value on success, -errno on failure.&n; */
DECL|function|li_read_ad1843_reg
r_static
r_int
id|li_read_ad1843_reg
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|reg
)paren
(brace
r_int
id|val
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lith-&gt;lock
)paren
suffix:semicolon
(brace
id|val
op_assign
id|li_ad1843_wait
c_func
(paren
id|lith
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
(brace
id|li_writel
c_func
(paren
id|lith
comma
id|LI_CODEC_COMMAND
comma
id|LI_CC_DIR_RD
op_or
id|reg
)paren
suffix:semicolon
id|val
op_assign
id|li_ad1843_wait
c_func
(paren
id|lith
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
id|val
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_CODEC_DATA
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lith-&gt;lock
)paren
suffix:semicolon
id|DBGXV
c_func
(paren
l_string|&quot;li_read_ad1843_reg(lith=0x%p, reg=%d) returns 0x%04x&bslash;n&quot;
comma
id|lith
comma
id|reg
comma
id|val
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * li_write_ad1843_reg writes the specified value to a 16 bit AD1843 register.&n; */
DECL|function|li_write_ad1843_reg
r_static
r_void
id|li_write_ad1843_reg
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|reg
comma
r_int
id|newval
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|lith-&gt;lock
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
id|li_ad1843_wait
c_func
(paren
id|lith
)paren
op_eq
l_int|0
)paren
(brace
id|li_writel
c_func
(paren
id|lith
comma
id|LI_CODEC_DATA
comma
id|newval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|LI_CODEC_COMMAND
comma
id|LI_CC_DIR_WR
op_or
id|reg
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lith-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * li_setup_dma calculates all the register settings for DMA in a particular&n; * mode.  It takes too many arguments.&n; */
DECL|function|li_setup_dma
r_static
r_void
id|li_setup_dma
c_func
(paren
id|dma_chan_t
op_star
id|chan
comma
r_const
id|dma_chan_desc_t
op_star
id|desc
comma
id|lithium_t
op_star
id|lith
comma
r_int
r_int
id|buffer_paddr
comma
r_int
id|bufshift
comma
r_int
id|fragshift
comma
r_int
id|channels
comma
r_int
id|sampsize
)paren
(brace
r_int
r_int
id|mode
comma
id|format
suffix:semicolon
r_int
r_int
id|size
comma
id|tmask
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(chan=0x%p, desc=0x%p, lith=0x%p, buffer_paddr=0x%lx, &quot;
l_string|&quot;bufshift=%d, fragshift=%d, channels=%d, sampsize=%d)&bslash;n&quot;
comma
id|chan
comma
id|desc
comma
id|lith
comma
id|buffer_paddr
comma
id|bufshift
comma
id|fragshift
comma
id|channels
comma
id|sampsize
)paren
suffix:semicolon
multiline_comment|/* Reset the channel first. */
id|li_writel
c_func
(paren
id|lith
comma
id|desc-&gt;ctlreg
comma
id|LI_CCTL_RESET
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|channels
op_eq
l_int|1
op_logical_or
id|channels
op_eq
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channels
op_eq
l_int|2
)paren
id|mode
op_assign
id|LI_CCFG_MODE_STEREO
suffix:semicolon
r_else
id|mode
op_assign
id|LI_CCFG_MODE_MONO
suffix:semicolon
id|ASSERT
c_func
(paren
id|sampsize
op_eq
l_int|1
op_logical_or
id|sampsize
op_eq
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sampsize
op_eq
l_int|2
)paren
id|format
op_assign
id|LI_CCFG_FMT_16BIT
suffix:semicolon
r_else
id|format
op_assign
id|LI_CCFG_FMT_8BIT
suffix:semicolon
id|chan-&gt;desc
op_assign
id|desc
suffix:semicolon
id|chan-&gt;lith
op_assign
id|lith
suffix:semicolon
multiline_comment|/*&n;&t; * Lithium DMA address register takes a 40-bit physical&n;&t; * address, right-shifted by 8 so it fits in 32 bits.  Bit 37&n;&t; * must be set -- it enables cache coherence.&n;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|buffer_paddr
op_amp
l_int|0xFF
)paren
)paren
suffix:semicolon
id|chan-&gt;baseval
op_assign
(paren
id|buffer_paddr
op_rshift
l_int|8
)paren
op_or
l_int|1
op_lshift
(paren
l_int|37
op_minus
l_int|8
)paren
suffix:semicolon
id|chan-&gt;cfgval
op_assign
(paren
op_logical_neg
id|LI_CCFG_LOCK
op_or
id|SHIFT_FIELD
c_func
(paren
id|desc-&gt;ad1843_slot
comma
id|LI_CCFG_SLOT
)paren
op_or
id|desc-&gt;direction
op_or
id|mode
op_or
id|format
)paren
suffix:semicolon
id|size
op_assign
id|bufshift
op_minus
l_int|6
suffix:semicolon
id|tmask
op_assign
l_int|13
op_minus
id|fragshift
suffix:semicolon
multiline_comment|/* See Lithium DMA Notes above. */
id|ASSERT
c_func
(paren
id|size
op_ge
l_int|2
op_logical_and
id|size
op_le
l_int|7
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmask
op_ge
l_int|1
op_logical_and
id|tmask
op_le
l_int|7
)paren
suffix:semicolon
id|chan-&gt;ctlval
op_assign
(paren
op_logical_neg
id|LI_CCTL_RESET
op_or
id|SHIFT_FIELD
c_func
(paren
id|size
comma
id|LI_CCTL_SIZE
)paren
op_or
op_logical_neg
id|LI_CCTL_DMA_ENABLE
op_or
id|SHIFT_FIELD
c_func
(paren
id|tmask
comma
id|LI_CCTL_TMASK
)paren
op_or
id|SHIFT_FIELD
c_func
(paren
l_int|0
comma
id|LI_CCTL_TPTR
)paren
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;basereg 0x%x = 0x%lx&bslash;n&quot;
comma
id|desc-&gt;basereg
comma
id|chan-&gt;baseval
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;cfgreg 0x%x = 0x%lx&bslash;n&quot;
comma
id|desc-&gt;cfgreg
comma
id|chan-&gt;cfgval
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;ctlreg 0x%x = 0x%lx&bslash;n&quot;
comma
id|desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|desc-&gt;basereg
comma
id|chan-&gt;baseval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|desc-&gt;cfgreg
comma
id|chan-&gt;cfgval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|li_shutdown_dma
r_static
r_void
id|li_shutdown_dma
c_func
(paren
id|dma_chan_t
op_star
id|chan
)paren
(brace
id|lithium_t
op_star
id|lith
op_assign
id|chan-&gt;lith
suffix:semicolon
id|caddr_t
id|lith1
op_assign
id|lith-&gt;page1
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(chan=0x%p)&bslash;n&quot;
comma
id|chan
)paren
suffix:semicolon
id|chan-&gt;ctlval
op_and_assign
op_complement
id|LI_CCTL_DMA_ENABLE
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;ctlreg 0x%x = 0x%lx&bslash;n&quot;
comma
id|chan-&gt;desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|chan-&gt;desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Offset 0x500 on Lithium page 1 is an undocumented,&n;&t; * unsupported register that holds the zero sample value.&n;&t; * Lithium is supposed to output zero samples when DMA is&n;&t; * inactive, and repeat the last sample when DMA underflows.&n;&t; * But it has a bug, where, after underflow occurs, the zero&n;&t; * sample is not reset.&n;&t; *&n;&t; * I expect this to break in a future rev of Lithium.&n;&t; */
r_if
c_cond
(paren
id|lith1
op_logical_and
id|chan-&gt;desc-&gt;direction
op_eq
id|LI_CCFG_DIR_OUT
)paren
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|lith1
op_plus
l_int|0x500
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * li_activate_dma always starts dma at the beginning of the buffer.&n; *&n; * N.B., these may be called from interrupt.&n; */
DECL|function|li_activate_dma
r_static
id|__inline__
r_void
id|li_activate_dma
c_func
(paren
id|dma_chan_t
op_star
id|chan
)paren
(brace
id|chan-&gt;ctlval
op_or_assign
id|LI_CCTL_DMA_ENABLE
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;ctlval = 0x%lx&bslash;n&quot;
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|chan-&gt;lith
comma
id|chan-&gt;desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
)brace
DECL|function|li_deactivate_dma
r_static
r_void
id|li_deactivate_dma
c_func
(paren
id|dma_chan_t
op_star
id|chan
)paren
(brace
id|lithium_t
op_star
id|lith
op_assign
id|chan-&gt;lith
suffix:semicolon
id|caddr_t
id|lith2
op_assign
id|lith-&gt;page2
suffix:semicolon
id|chan-&gt;ctlval
op_and_assign
op_complement
(paren
id|LI_CCTL_DMA_ENABLE
op_or
id|LI_CCTL_RPTR
op_or
id|LI_CCTL_WPTR
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;ctlval = 0x%lx&bslash;n&quot;
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;ctlreg 0x%x = 0x%lx&bslash;n&quot;
comma
id|chan-&gt;desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|chan-&gt;desc-&gt;ctlreg
comma
id|chan-&gt;ctlval
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Offsets 0x98 and 0x9C on Lithium page 2 are undocumented,&n;&t; * unsupported registers that are internal copies of the DMA&n;&t; * read and write pointers.  Because of a Lithium bug, these&n;&t; * registers aren&squot;t zeroed correctly when DMA is shut off.  So&n;&t; * we whack them directly.&n;&t; *&n;&t; * I expect this to break in a future rev of Lithium.&n;&t; */
r_if
c_cond
(paren
id|lith2
op_logical_and
id|chan-&gt;desc-&gt;direction
op_eq
id|LI_CCFG_DIR_OUT
)paren
(brace
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|lith2
op_plus
l_int|0x98
)paren
op_assign
l_int|0
suffix:semicolon
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|lith2
op_plus
l_int|0x9C
)paren
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * read/write the ring buffer pointers.  These routines&squot; arguments and results&n; * are byte offsets from the beginning of the ring buffer.&n; */
DECL|function|li_read_swptr
r_static
id|__inline__
r_int
id|li_read_swptr
c_func
(paren
id|dma_chan_t
op_star
id|chan
)paren
(brace
r_const
r_int
r_int
id|mask
op_assign
id|chan-&gt;desc-&gt;swptrmask
suffix:semicolon
r_return
id|CHUNKS_TO_BYTES
c_func
(paren
id|UNSHIFT_FIELD
c_func
(paren
id|chan-&gt;ctlval
comma
id|mask
)paren
)paren
suffix:semicolon
)brace
DECL|function|li_read_hwptr
r_static
id|__inline__
r_int
id|li_read_hwptr
c_func
(paren
id|dma_chan_t
op_star
id|chan
)paren
(brace
r_return
id|CHUNKS_TO_BYTES
c_func
(paren
id|li_readb
c_func
(paren
id|chan-&gt;lith
comma
id|chan-&gt;desc-&gt;hwptrreg
)paren
)paren
suffix:semicolon
)brace
DECL|function|li_write_swptr
r_static
id|__inline__
r_void
id|li_write_swptr
c_func
(paren
id|dma_chan_t
op_star
id|chan
comma
r_int
id|val
)paren
(brace
r_const
r_int
r_int
id|mask
op_assign
id|chan-&gt;desc-&gt;swptrmask
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|val
op_amp
op_complement
id|CHUNKS_TO_BYTES
c_func
(paren
l_int|0xFF
)paren
)paren
)paren
suffix:semicolon
id|val
op_assign
id|BYTES_TO_CHUNKS
c_func
(paren
id|val
)paren
suffix:semicolon
id|chan-&gt;ctlval
op_assign
(paren
id|chan-&gt;ctlval
op_amp
op_complement
id|mask
)paren
op_or
id|SHIFT_FIELD
c_func
(paren
id|val
comma
id|mask
)paren
suffix:semicolon
id|li_writeb
c_func
(paren
id|chan-&gt;lith
comma
id|chan-&gt;desc-&gt;swptrreg
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/* li_read_USTMSC() returns a UST/MSC pair for the given channel. */
DECL|function|li_read_USTMSC
r_static
r_void
id|li_read_USTMSC
c_func
(paren
id|dma_chan_t
op_star
id|chan
comma
id|ustmsc_t
op_star
id|ustmsc
)paren
(brace
id|lithium_t
op_star
id|lith
op_assign
id|chan-&gt;lith
suffix:semicolon
r_const
id|dma_chan_desc_t
op_star
id|desc
op_assign
id|chan-&gt;desc
suffix:semicolon
r_int
r_int
id|now_low
comma
id|now_high0
comma
id|now_high1
comma
id|chan_ust
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lith-&gt;lock
)paren
suffix:semicolon
(brace
multiline_comment|/*&n;&t;&t; * retry until we do all five reads without the&n;&t;&t; * high word changing.  (High word increments&n;&t;&t; * every 2^32 microseconds, i.e., not often)&n;&t;&t; */
r_do
(brace
id|now_high0
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_UST_HIGH
)paren
suffix:semicolon
id|now_low
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_UST_LOW
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Lithium guarantees these two reads will be&n;&t;&t;&t; * atomic -- ust will not increment after msc&n;&t;&t;&t; * is read.&n;&t;&t;&t; */
id|ustmsc-&gt;msc
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|desc-&gt;mscreg
)paren
suffix:semicolon
id|chan_ust
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|desc-&gt;ustreg
)paren
suffix:semicolon
id|now_high1
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_UST_HIGH
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|now_high0
op_ne
id|now_high1
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lith-&gt;lock
)paren
suffix:semicolon
id|ustmsc-&gt;ust
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
id|now_high0
op_lshift
l_int|32
op_or
id|chan_ust
)paren
suffix:semicolon
)brace
DECL|function|li_enable_interrupts
r_static
r_void
id|li_enable_interrupts
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
r_int
id|mask
)paren
(brace
id|DBGEV
c_func
(paren
l_string|&quot;(lith=0x%p, mask=0x%x)&bslash;n&quot;
comma
id|lith
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* clear any already-pending interrupts. */
id|li_writel
c_func
(paren
id|lith
comma
id|LI_INTR_STATUS
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* enable the interrupts. */
id|mask
op_or_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_INTR_MASK
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|LI_INTR_MASK
comma
id|mask
)paren
suffix:semicolon
)brace
DECL|function|li_disable_interrupts
r_static
r_void
id|li_disable_interrupts
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
r_int
id|mask
)paren
(brace
r_int
r_int
id|keepmask
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(lith=0x%p, mask=0x%x)&bslash;n&quot;
comma
id|lith
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* disable the interrupts */
id|keepmask
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_INTR_MASK
)paren
op_amp
op_complement
id|mask
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|LI_INTR_MASK
comma
id|keepmask
)paren
suffix:semicolon
multiline_comment|/* clear any pending interrupts. */
id|li_writel
c_func
(paren
id|lith
comma
id|LI_INTR_STATUS
comma
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the interrupt status and clear all pending interrupts. */
DECL|function|li_get_clear_intr_status
r_static
r_int
r_int
id|li_get_clear_intr_status
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
r_int
r_int
id|status
suffix:semicolon
id|status
op_assign
id|li_readl
c_func
(paren
id|lith
comma
id|LI_INTR_STATUS
)paren
suffix:semicolon
id|li_writel
c_func
(paren
id|lith
comma
id|LI_INTR_STATUS
comma
op_complement
l_int|0
)paren
suffix:semicolon
r_return
id|status
op_amp
id|li_readl
c_func
(paren
id|lith
comma
id|LI_INTR_MASK
)paren
suffix:semicolon
)brace
DECL|function|li_init
r_static
r_int
id|li_init
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
multiline_comment|/* 1. System power supplies stabilize. */
multiline_comment|/* 2. Assert the ~RESET signal. */
id|li_writel
c_func
(paren
id|lith
comma
id|LI_HOST_CONTROLLER
comma
id|LI_HC_RESET
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 3. Deassert the ~RESET signal and enter a wait period to allow&n;&t;   the AD1843 internal clocks and the external crystal oscillator&n;&t;   to stabilize. */
id|li_writel
c_func
(paren
id|lith
comma
id|LI_HOST_CONTROLLER
comma
id|LI_HC_LINK_ENABLE
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/* AD1843 access */
multiline_comment|/*&n; * AD1843 bitfield definitions.  All are named as in the AD1843 data&n; * sheet, with ad1843_ prepended and individual bit numbers removed.&n; *&n; * E.g., bits LSS0 through LSS2 become ad1843_LSS.&n; *&n; * Only the bitfields we need are defined.&n; */
DECL|struct|ad1843_bitfield
r_typedef
r_struct
id|ad1843_bitfield
(brace
DECL|member|reg
r_char
id|reg
suffix:semicolon
DECL|member|lo_bit
r_char
id|lo_bit
suffix:semicolon
DECL|member|nbits
r_char
id|nbits
suffix:semicolon
DECL|typedef|ad1843_bitfield_t
)brace
id|ad1843_bitfield_t
suffix:semicolon
r_static
r_const
id|ad1843_bitfield_t
DECL|variable|ad1843_PDNO
id|ad1843_PDNO
op_assign
(brace
l_int|0
comma
l_int|14
comma
l_int|1
)brace
comma
multiline_comment|/* Converter Power-Down Flag */
DECL|variable|ad1843_INIT
id|ad1843_INIT
op_assign
(brace
l_int|0
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Clock Initialization Flag */
DECL|variable|ad1843_RIG
id|ad1843_RIG
op_assign
(brace
l_int|2
comma
l_int|0
comma
l_int|4
)brace
comma
multiline_comment|/* Right ADC Input Gain */
DECL|variable|ad1843_RMGE
id|ad1843_RMGE
op_assign
(brace
l_int|2
comma
l_int|4
comma
l_int|1
)brace
comma
multiline_comment|/* Right ADC Mic Gain Enable */
DECL|variable|ad1843_RSS
id|ad1843_RSS
op_assign
(brace
l_int|2
comma
l_int|5
comma
l_int|3
)brace
comma
multiline_comment|/* Right ADC Source Select */
DECL|variable|ad1843_LIG
id|ad1843_LIG
op_assign
(brace
l_int|2
comma
l_int|8
comma
l_int|4
)brace
comma
multiline_comment|/* Left ADC Input Gain */
DECL|variable|ad1843_LMGE
id|ad1843_LMGE
op_assign
(brace
l_int|2
comma
l_int|12
comma
l_int|1
)brace
comma
multiline_comment|/* Left ADC Mic Gain Enable */
DECL|variable|ad1843_LSS
id|ad1843_LSS
op_assign
(brace
l_int|2
comma
l_int|13
comma
l_int|3
)brace
comma
multiline_comment|/* Left ADC Source Select */
DECL|variable|ad1843_RX1M
id|ad1843_RX1M
op_assign
(brace
l_int|4
comma
l_int|0
comma
l_int|5
)brace
comma
multiline_comment|/* Right Aux 1 Mix Gain/Atten */
DECL|variable|ad1843_RX1MM
id|ad1843_RX1MM
op_assign
(brace
l_int|4
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* Right Aux 1 Mix Mute */
DECL|variable|ad1843_LX1M
id|ad1843_LX1M
op_assign
(brace
l_int|4
comma
l_int|8
comma
l_int|5
)brace
comma
multiline_comment|/* Left Aux 1 Mix Gain/Atten */
DECL|variable|ad1843_LX1MM
id|ad1843_LX1MM
op_assign
(brace
l_int|4
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Left Aux 1 Mix Mute */
DECL|variable|ad1843_RX2M
id|ad1843_RX2M
op_assign
(brace
l_int|5
comma
l_int|0
comma
l_int|5
)brace
comma
multiline_comment|/* Right Aux 2 Mix Gain/Atten */
DECL|variable|ad1843_RX2MM
id|ad1843_RX2MM
op_assign
(brace
l_int|5
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* Right Aux 2 Mix Mute */
DECL|variable|ad1843_LX2M
id|ad1843_LX2M
op_assign
(brace
l_int|5
comma
l_int|8
comma
l_int|5
)brace
comma
multiline_comment|/* Left Aux 2 Mix Gain/Atten */
DECL|variable|ad1843_LX2MM
id|ad1843_LX2MM
op_assign
(brace
l_int|5
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Left Aux 2 Mix Mute */
DECL|variable|ad1843_RMCM
id|ad1843_RMCM
op_assign
(brace
l_int|7
comma
l_int|0
comma
l_int|5
)brace
comma
multiline_comment|/* Right Mic Mix Gain/Atten */
DECL|variable|ad1843_RMCMM
id|ad1843_RMCMM
op_assign
(brace
l_int|7
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* Right Mic Mix Mute */
DECL|variable|ad1843_LMCM
id|ad1843_LMCM
op_assign
(brace
l_int|7
comma
l_int|8
comma
l_int|5
)brace
comma
multiline_comment|/* Left Mic Mix Gain/Atten */
DECL|variable|ad1843_LMCMM
id|ad1843_LMCMM
op_assign
(brace
l_int|7
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Left Mic Mix Mute */
DECL|variable|ad1843_HPOS
id|ad1843_HPOS
op_assign
(brace
l_int|8
comma
l_int|4
comma
l_int|1
)brace
comma
multiline_comment|/* Headphone Output Voltage Swing */
DECL|variable|ad1843_HPOM
id|ad1843_HPOM
op_assign
(brace
l_int|8
comma
l_int|5
comma
l_int|1
)brace
comma
multiline_comment|/* Headphone Output Mute */
DECL|variable|ad1843_RDA1G
id|ad1843_RDA1G
op_assign
(brace
l_int|9
comma
l_int|0
comma
l_int|6
)brace
comma
multiline_comment|/* Right DAC1 Analog/Digital Gain */
DECL|variable|ad1843_RDA1GM
id|ad1843_RDA1GM
op_assign
(brace
l_int|9
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* Right DAC1 Analog Mute */
DECL|variable|ad1843_LDA1G
id|ad1843_LDA1G
op_assign
(brace
l_int|9
comma
l_int|8
comma
l_int|6
)brace
comma
multiline_comment|/* Left DAC1 Analog/Digital Gain */
DECL|variable|ad1843_LDA1GM
id|ad1843_LDA1GM
op_assign
(brace
l_int|9
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Left DAC1 Analog Mute */
DECL|variable|ad1843_RDA1AM
id|ad1843_RDA1AM
op_assign
(brace
l_int|11
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* Right DAC1 Digital Mute */
DECL|variable|ad1843_LDA1AM
id|ad1843_LDA1AM
op_assign
(brace
l_int|11
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Left DAC1 Digital Mute */
DECL|variable|ad1843_ADLC
id|ad1843_ADLC
op_assign
(brace
l_int|15
comma
l_int|0
comma
l_int|2
)brace
comma
multiline_comment|/* ADC Left Sample Rate Source */
DECL|variable|ad1843_ADRC
id|ad1843_ADRC
op_assign
(brace
l_int|15
comma
l_int|2
comma
l_int|2
)brace
comma
multiline_comment|/* ADC Right Sample Rate Source */
DECL|variable|ad1843_DA1C
id|ad1843_DA1C
op_assign
(brace
l_int|15
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* DAC1 Sample Rate Source */
DECL|variable|ad1843_C1C
id|ad1843_C1C
op_assign
(brace
l_int|17
comma
l_int|0
comma
l_int|16
)brace
comma
multiline_comment|/* Clock 1 Sample Rate Select */
DECL|variable|ad1843_C2C
id|ad1843_C2C
op_assign
(brace
l_int|20
comma
l_int|0
comma
l_int|16
)brace
comma
multiline_comment|/* Clock 1 Sample Rate Select */
DECL|variable|ad1843_DAADL
id|ad1843_DAADL
op_assign
(brace
l_int|25
comma
l_int|4
comma
l_int|2
)brace
comma
multiline_comment|/* Digital ADC Left Source Select */
DECL|variable|ad1843_DAADR
id|ad1843_DAADR
op_assign
(brace
l_int|25
comma
l_int|6
comma
l_int|2
)brace
comma
multiline_comment|/* Digital ADC Right Source Select */
DECL|variable|ad1843_DRSFLT
id|ad1843_DRSFLT
op_assign
(brace
l_int|25
comma
l_int|15
comma
l_int|1
)brace
comma
multiline_comment|/* Digital Reampler Filter Mode */
DECL|variable|ad1843_ADLF
id|ad1843_ADLF
op_assign
(brace
l_int|26
comma
l_int|0
comma
l_int|2
)brace
comma
multiline_comment|/* ADC Left Channel Data Format */
DECL|variable|ad1843_ADRF
id|ad1843_ADRF
op_assign
(brace
l_int|26
comma
l_int|2
comma
l_int|2
)brace
comma
multiline_comment|/* ADC Right Channel Data Format */
DECL|variable|ad1843_ADTLK
id|ad1843_ADTLK
op_assign
(brace
l_int|26
comma
l_int|4
comma
l_int|1
)brace
comma
multiline_comment|/* ADC Transmit Lock Mode Select */
DECL|variable|ad1843_SCF
id|ad1843_SCF
op_assign
(brace
l_int|26
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* SCLK Frequency Select */
DECL|variable|ad1843_DA1F
id|ad1843_DA1F
op_assign
(brace
l_int|26
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* DAC1 Data Format Select */
DECL|variable|ad1843_DA1SM
id|ad1843_DA1SM
op_assign
(brace
l_int|26
comma
l_int|14
comma
l_int|1
)brace
comma
multiline_comment|/* DAC1 Stereo/Mono Mode Select */
DECL|variable|ad1843_ADLEN
id|ad1843_ADLEN
op_assign
(brace
l_int|27
comma
l_int|0
comma
l_int|1
)brace
comma
multiline_comment|/* ADC Left Channel Enable */
DECL|variable|ad1843_ADREN
id|ad1843_ADREN
op_assign
(brace
l_int|27
comma
l_int|1
comma
l_int|1
)brace
comma
multiline_comment|/* ADC Right Channel Enable */
DECL|variable|ad1843_AAMEN
id|ad1843_AAMEN
op_assign
(brace
l_int|27
comma
l_int|4
comma
l_int|1
)brace
comma
multiline_comment|/* Analog to Analog Mix Enable */
DECL|variable|ad1843_ANAEN
id|ad1843_ANAEN
op_assign
(brace
l_int|27
comma
l_int|7
comma
l_int|1
)brace
comma
multiline_comment|/* Analog Channel Enable */
DECL|variable|ad1843_DA1EN
id|ad1843_DA1EN
op_assign
(brace
l_int|27
comma
l_int|8
comma
l_int|1
)brace
comma
multiline_comment|/* DAC1 Enable */
DECL|variable|ad1843_DA2EN
id|ad1843_DA2EN
op_assign
(brace
l_int|27
comma
l_int|9
comma
l_int|1
)brace
comma
multiline_comment|/* DAC2 Enable */
DECL|variable|ad1843_C1EN
id|ad1843_C1EN
op_assign
(brace
l_int|28
comma
l_int|11
comma
l_int|1
)brace
comma
multiline_comment|/* Clock Generator 1 Enable */
DECL|variable|ad1843_C2EN
id|ad1843_C2EN
op_assign
(brace
l_int|28
comma
l_int|12
comma
l_int|1
)brace
comma
multiline_comment|/* Clock Generator 2 Enable */
DECL|variable|ad1843_PDNI
id|ad1843_PDNI
op_assign
(brace
l_int|28
comma
l_int|15
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Converter Power Down */
multiline_comment|/*&n; * The various registers of the AD1843 use three different formats for&n; * specifying gain.  The ad1843_gain structure parameterizes the&n; * formats.&n; */
DECL|struct|ad1843_gain
r_typedef
r_struct
id|ad1843_gain
(brace
DECL|member|negative
r_int
id|negative
suffix:semicolon
multiline_comment|/* nonzero if gain is negative. */
DECL|member|lfield
r_const
id|ad1843_bitfield_t
op_star
id|lfield
suffix:semicolon
DECL|member|rfield
r_const
id|ad1843_bitfield_t
op_star
id|rfield
suffix:semicolon
DECL|typedef|ad1843_gain_t
)brace
id|ad1843_gain_t
suffix:semicolon
DECL|variable|ad1843_gain_RECLEV
r_static
r_const
id|ad1843_gain_t
id|ad1843_gain_RECLEV
op_assign
(brace
l_int|0
comma
op_amp
id|ad1843_LIG
comma
op_amp
id|ad1843_RIG
)brace
suffix:semicolon
DECL|variable|ad1843_gain_LINE
r_static
r_const
id|ad1843_gain_t
id|ad1843_gain_LINE
op_assign
(brace
l_int|1
comma
op_amp
id|ad1843_LX1M
comma
op_amp
id|ad1843_RX1M
)brace
suffix:semicolon
DECL|variable|ad1843_gain_CD
r_static
r_const
id|ad1843_gain_t
id|ad1843_gain_CD
op_assign
(brace
l_int|1
comma
op_amp
id|ad1843_LX2M
comma
op_amp
id|ad1843_RX2M
)brace
suffix:semicolon
DECL|variable|ad1843_gain_MIC
r_static
r_const
id|ad1843_gain_t
id|ad1843_gain_MIC
op_assign
(brace
l_int|1
comma
op_amp
id|ad1843_LMCM
comma
op_amp
id|ad1843_RMCM
)brace
suffix:semicolon
DECL|variable|ad1843_gain_PCM
r_static
r_const
id|ad1843_gain_t
id|ad1843_gain_PCM
op_assign
(brace
l_int|1
comma
op_amp
id|ad1843_LDA1G
comma
op_amp
id|ad1843_RDA1G
)brace
suffix:semicolon
multiline_comment|/* read the current value of an AD1843 bitfield. */
DECL|function|ad1843_read_bits
r_static
r_int
id|ad1843_read_bits
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_const
id|ad1843_bitfield_t
op_star
id|field
)paren
(brace
r_int
id|w
op_assign
id|li_read_ad1843_reg
c_func
(paren
id|lith
comma
id|field-&gt;reg
)paren
suffix:semicolon
r_int
id|val
op_assign
id|w
op_rshift
id|field-&gt;lo_bit
op_amp
(paren
(paren
l_int|1
op_lshift
id|field-&gt;nbits
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|DBGXV
c_func
(paren
l_string|&quot;ad1843_read_bits(lith=0x%p, field-&gt;{%d %d %d}) returns 0x%x&bslash;n&quot;
comma
id|lith
comma
id|field-&gt;reg
comma
id|field-&gt;lo_bit
comma
id|field-&gt;nbits
comma
id|val
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * write a new value to an AD1843 bitfield and return the old value.&n; */
DECL|function|ad1843_write_bits
r_static
r_int
id|ad1843_write_bits
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_const
id|ad1843_bitfield_t
op_star
id|field
comma
r_int
id|newval
)paren
(brace
r_int
id|w
op_assign
id|li_read_ad1843_reg
c_func
(paren
id|lith
comma
id|field-&gt;reg
)paren
suffix:semicolon
r_int
id|mask
op_assign
(paren
(paren
l_int|1
op_lshift
id|field-&gt;nbits
)paren
op_minus
l_int|1
)paren
op_lshift
id|field-&gt;lo_bit
suffix:semicolon
r_int
id|oldval
op_assign
(paren
id|w
op_amp
id|mask
)paren
op_rshift
id|field-&gt;lo_bit
suffix:semicolon
r_int
id|newbits
op_assign
(paren
id|newval
op_lshift
id|field-&gt;lo_bit
)paren
op_amp
id|mask
suffix:semicolon
id|w
op_assign
(paren
id|w
op_amp
op_complement
id|mask
)paren
op_or
id|newbits
suffix:semicolon
(paren
r_void
)paren
id|li_write_ad1843_reg
c_func
(paren
id|lith
comma
id|field-&gt;reg
comma
id|w
)paren
suffix:semicolon
id|DBGXV
c_func
(paren
l_string|&quot;ad1843_write_bits(lith=0x%p, field-&gt;{%d %d %d}, val=0x%x) &quot;
l_string|&quot;returns 0x%x&bslash;n&quot;
comma
id|lith
comma
id|field-&gt;reg
comma
id|field-&gt;lo_bit
comma
id|field-&gt;nbits
comma
id|newval
comma
id|oldval
)paren
suffix:semicolon
r_return
id|oldval
suffix:semicolon
)brace
multiline_comment|/*&n; * ad1843_read_multi reads multiple bitfields from the same AD1843&n; * register.  It uses a single read cycle to do it.  (Reading the&n; * ad1843 requires 256 bit times at 12.288 MHz, or nearly 20&n; * microseconds.)&n; *&n; * Called ike this.&n; *&n; *  ad1843_read_multi(lith, nfields,&n; *&t;&t;      &amp;ad1843_FIELD1, &amp;val1,&n; *&t;&t;      &amp;ad1843_FIELD2, &amp;val2, ...);&n; */
DECL|function|ad1843_read_multi
r_static
r_void
id|ad1843_read_multi
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|argcount
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_const
id|ad1843_bitfield_t
op_star
id|fp
suffix:semicolon
r_int
id|w
op_assign
l_int|0
comma
id|mask
comma
op_star
id|value
comma
id|reg
op_assign
op_minus
l_int|1
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|argcount
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|argcount
op_ge
l_int|0
)paren
(brace
id|fp
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_const
id|ad1843_bitfield_t
op_star
)paren
suffix:semicolon
id|value
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_int
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
op_minus
l_int|1
)paren
(brace
id|reg
op_assign
id|fp-&gt;reg
suffix:semicolon
id|w
op_assign
id|li_read_ad1843_reg
c_func
(paren
id|lith
comma
id|reg
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|reg
op_eq
id|fp-&gt;reg
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|fp-&gt;nbits
)paren
op_minus
l_int|1
suffix:semicolon
op_star
id|value
op_assign
id|w
op_rshift
id|fp-&gt;lo_bit
op_amp
id|mask
suffix:semicolon
)brace
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ad1843_write_multi stores multiple bitfields into the same AD1843&n; * register.  It uses one read and one write cycle to do it.&n; *&n; * Called like this.&n; *&n; *  ad1843_write_multi(lith, nfields,&n; *&t;&t;       &amp;ad1843_FIELD1, val1,&n; *&t;&t;       &amp;ad1843_FIELF2, val2, ...);&n; */
DECL|function|ad1843_write_multi
r_static
r_void
id|ad1843_write_multi
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|argcount
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_int
id|reg
suffix:semicolon
r_const
id|ad1843_bitfield_t
op_star
id|fp
suffix:semicolon
r_int
id|value
suffix:semicolon
r_int
id|w
comma
id|m
comma
id|mask
comma
id|bits
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
id|reg
op_assign
op_minus
l_int|1
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|argcount
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|argcount
op_ge
l_int|0
)paren
(brace
id|fp
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_const
id|ad1843_bitfield_t
op_star
)paren
suffix:semicolon
id|value
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
op_minus
l_int|1
)paren
id|reg
op_assign
id|fp-&gt;reg
suffix:semicolon
id|ASSERT
c_func
(paren
id|fp-&gt;reg
op_eq
id|reg
)paren
suffix:semicolon
id|m
op_assign
(paren
(paren
l_int|1
op_lshift
id|fp-&gt;nbits
)paren
op_minus
l_int|1
)paren
op_lshift
id|fp-&gt;lo_bit
suffix:semicolon
id|mask
op_or_assign
id|m
suffix:semicolon
id|bits
op_or_assign
(paren
id|value
op_lshift
id|fp-&gt;lo_bit
)paren
op_amp
id|m
suffix:semicolon
)brace
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bits
op_amp
op_complement
id|mask
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|mask
op_amp
l_int|0xFFFF
)paren
id|w
op_assign
id|li_read_ad1843_reg
c_func
(paren
id|lith
comma
id|reg
)paren
suffix:semicolon
r_else
id|w
op_assign
l_int|0
suffix:semicolon
id|w
op_assign
(paren
id|w
op_amp
op_complement
id|mask
)paren
op_or
id|bits
suffix:semicolon
(paren
r_void
)paren
id|li_write_ad1843_reg
c_func
(paren
id|lith
comma
id|reg
comma
id|w
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ad1843_get_gain reads the specified register and extracts the gain value&n; * using the supplied gain type.  It returns the gain in OSS format.&n; */
DECL|function|ad1843_get_gain
r_static
r_int
id|ad1843_get_gain
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_const
id|ad1843_gain_t
op_star
id|gp
)paren
(brace
r_int
id|lg
comma
id|rg
suffix:semicolon
r_int
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|gp-&gt;lfield-&gt;nbits
)paren
op_minus
l_int|1
suffix:semicolon
id|ad1843_read_multi
c_func
(paren
id|lith
comma
l_int|2
comma
id|gp-&gt;lfield
comma
op_amp
id|lg
comma
id|gp-&gt;rfield
comma
op_amp
id|rg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gp-&gt;negative
)paren
(brace
id|lg
op_assign
id|mask
op_minus
id|lg
suffix:semicolon
id|rg
op_assign
id|mask
op_minus
id|rg
suffix:semicolon
)brace
id|lg
op_assign
(paren
id|lg
op_star
l_int|100
op_plus
(paren
id|mask
op_rshift
l_int|1
)paren
)paren
op_div
id|mask
suffix:semicolon
id|rg
op_assign
(paren
id|rg
op_star
l_int|100
op_plus
(paren
id|mask
op_rshift
l_int|1
)paren
)paren
op_div
id|mask
suffix:semicolon
r_return
id|lg
op_lshift
l_int|0
op_or
id|rg
op_lshift
l_int|8
suffix:semicolon
)brace
multiline_comment|/*&n; * Set an audio channel&squot;s gain. Converts from OSS format to AD1843&squot;s&n; * format.&n; *&n; * Returns the new gain, which may be lower than the old gain.&n; */
DECL|function|ad1843_set_gain
r_static
r_int
id|ad1843_set_gain
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_const
id|ad1843_gain_t
op_star
id|gp
comma
r_int
id|newval
)paren
(brace
r_int
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|gp-&gt;lfield-&gt;nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|lg
op_assign
id|newval
op_rshift
l_int|0
op_amp
l_int|0xFF
suffix:semicolon
r_int
id|rg
op_assign
id|newval
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|lg
template_param
l_int|100
op_logical_or
id|rg
template_param
l_int|100
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lg
op_assign
(paren
id|lg
op_star
id|mask
op_plus
(paren
id|mask
op_rshift
l_int|1
)paren
)paren
op_div
l_int|100
suffix:semicolon
id|rg
op_assign
(paren
id|rg
op_star
id|mask
op_plus
(paren
id|mask
op_rshift
l_int|1
)paren
)paren
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|gp-&gt;negative
)paren
(brace
id|lg
op_assign
id|mask
op_minus
id|lg
suffix:semicolon
id|rg
op_assign
id|mask
op_minus
id|rg
suffix:semicolon
)brace
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
id|gp-&gt;lfield
comma
id|lg
comma
id|gp-&gt;rfield
comma
id|rg
)paren
suffix:semicolon
r_return
id|ad1843_get_gain
c_func
(paren
id|lith
comma
id|gp
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns the current recording source, in OSS format. */
DECL|function|ad1843_get_recsrc
r_static
r_int
id|ad1843_get_recsrc
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
r_int
id|ls
op_assign
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_LSS
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ls
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
id|SOUND_MASK_MIC
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|SOUND_MASK_LINE
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
id|SOUND_MASK_CD
suffix:semicolon
r_case
l_int|6
suffix:colon
r_return
id|SOUND_MASK_PCM
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Enable/disable digital resample mode in the AD1843.&n; *&n; * The AD1843 requires that ADL, ADR, DA1 and DA2 be powered down&n; * while switching modes.  So we save DA1&squot;s state (DA2&squot;s state is not&n; * interesting), power them down, switch into/out of resample mode,&n; * power them up, and restore state.&n; *&n; * This will cause audible glitches if D/A or A/D is going on, so the&n; * driver disallows that (in mixer_write_ioctl()).&n; *&n; * The open question is, is this worth doing?  I&squot;m leaving it in,&n; * because it&squot;s written, but...&n; */
DECL|function|ad1843_set_resample_mode
r_static
r_void
id|ad1843_set_resample_mode
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|onoff
)paren
(brace
multiline_comment|/* Save DA1 mute and gain (addr 9 is DA1 analog gain/attenuation) */
r_int
id|save_da1
op_assign
id|li_read_ad1843_reg
c_func
(paren
id|lith
comma
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Power down A/D and D/A. */
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|4
comma
op_amp
id|ad1843_DA1EN
comma
l_int|0
comma
op_amp
id|ad1843_DA2EN
comma
l_int|0
comma
op_amp
id|ad1843_ADLEN
comma
l_int|0
comma
op_amp
id|ad1843_ADREN
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Switch mode */
id|ASSERT
c_func
(paren
id|onoff
op_eq
l_int|0
op_logical_or
id|onoff
op_eq
l_int|1
)paren
suffix:semicolon
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_DRSFLT
comma
id|onoff
)paren
suffix:semicolon
multiline_comment|/* Power up A/D and D/A. */
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|3
comma
op_amp
id|ad1843_DA1EN
comma
l_int|1
comma
op_amp
id|ad1843_ADLEN
comma
l_int|1
comma
op_amp
id|ad1843_ADREN
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Restore DA1 mute and gain. */
id|li_write_ad1843_reg
c_func
(paren
id|lith
comma
l_int|9
comma
id|save_da1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set recording source.  Arg newsrc specifies an OSS channel mask.&n; *&n; * The complication is that when we switch into/out of loopback mode&n; * (i.e., src = SOUND_MASK_PCM), we change the AD1843 into/out of&n; * digital resampling mode.&n; *&n; * Returns newsrc on success, -errno on failure.&n; */
DECL|function|ad1843_set_recsrc
r_static
r_int
id|ad1843_set_recsrc
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|newsrc
)paren
(brace
r_int
id|bits
suffix:semicolon
r_int
id|oldbits
suffix:semicolon
r_switch
c_cond
(paren
id|newsrc
)paren
(brace
r_case
id|SOUND_MASK_PCM
suffix:colon
id|bits
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MASK_MIC
suffix:colon
id|bits
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MASK_LINE
suffix:colon
id|bits
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MASK_CD
suffix:colon
id|bits
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|oldbits
op_assign
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_LSS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsrc
op_eq
id|SOUND_MASK_PCM
op_logical_and
id|oldbits
op_ne
l_int|6
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;enabling digital resample mode&bslash;n&quot;
)paren
suffix:semicolon
id|ad1843_set_resample_mode
c_func
(paren
id|lith
comma
l_int|1
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_DAADL
comma
l_int|2
comma
op_amp
id|ad1843_DAADR
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newsrc
op_ne
id|SOUND_MASK_PCM
op_logical_and
id|oldbits
op_eq
l_int|6
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;disabling digital resample mode&bslash;n&quot;
)paren
suffix:semicolon
id|ad1843_set_resample_mode
c_func
(paren
id|lith
comma
l_int|0
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_DAADL
comma
l_int|0
comma
op_amp
id|ad1843_DAADR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LSS
comma
id|bits
comma
op_amp
id|ad1843_RSS
comma
id|bits
)paren
suffix:semicolon
r_return
id|newsrc
suffix:semicolon
)brace
multiline_comment|/*&n; * Return current output sources, in OSS format.&n; */
DECL|function|ad1843_get_outsrc
r_static
r_int
id|ad1843_get_outsrc
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
r_int
id|pcm
comma
id|line
comma
id|mic
comma
id|cd
suffix:semicolon
id|pcm
op_assign
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_LDA1GM
)paren
ques
c_cond
l_int|0
suffix:colon
id|SOUND_MASK_PCM
suffix:semicolon
id|line
op_assign
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_LX1MM
)paren
ques
c_cond
l_int|0
suffix:colon
id|SOUND_MASK_LINE
suffix:semicolon
id|cd
op_assign
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_LX2MM
)paren
ques
c_cond
l_int|0
suffix:colon
id|SOUND_MASK_CD
suffix:semicolon
id|mic
op_assign
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_LMCMM
)paren
ques
c_cond
l_int|0
suffix:colon
id|SOUND_MASK_MIC
suffix:semicolon
r_return
id|pcm
op_or
id|line
op_or
id|cd
op_or
id|mic
suffix:semicolon
)brace
multiline_comment|/*&n; * Set output sources.  Arg is a mask of active sources in OSS format.&n; *&n; * Returns source mask on success, -errno on failure.&n; */
DECL|function|ad1843_set_outsrc
r_static
r_int
id|ad1843_set_outsrc
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|mask
)paren
(brace
r_int
id|pcm
comma
id|line
comma
id|mic
comma
id|cd
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
op_complement
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_MIC
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pcm
op_assign
(paren
id|mask
op_amp
id|SOUND_MASK_PCM
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|line
op_assign
(paren
id|mask
op_amp
id|SOUND_MASK_LINE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|mic
op_assign
(paren
id|mask
op_amp
id|SOUND_MASK_MIC
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|cd
op_assign
(paren
id|mask
op_amp
id|SOUND_MASK_CD
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LDA1GM
comma
id|pcm
comma
op_amp
id|ad1843_RDA1GM
comma
id|pcm
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LX1MM
comma
id|line
comma
op_amp
id|ad1843_RX1MM
comma
id|line
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LX2MM
comma
id|cd
comma
op_amp
id|ad1843_RX2MM
comma
id|cd
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LMCMM
comma
id|mic
comma
op_amp
id|ad1843_RMCMM
comma
id|mic
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* Setup ad1843 for D/A conversion. */
DECL|function|ad1843_setup_dac
r_static
r_void
id|ad1843_setup_dac
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|framerate
comma
r_int
id|fmt
comma
r_int
id|channels
)paren
(brace
r_int
id|ad_fmt
op_assign
l_int|0
comma
id|ad_mode
op_assign
l_int|0
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(lith=0x%p, framerate=%d, fmt=%d, channels=%d)&bslash;n&quot;
comma
id|lith
comma
id|framerate
comma
id|fmt
comma
id|channels
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fmt
)paren
(brace
r_case
id|AFMT_S8
suffix:colon
id|ad_fmt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
id|ad_fmt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_LE
suffix:colon
id|ad_fmt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_MU_LAW
suffix:colon
id|ad_fmt
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_A_LAW
suffix:colon
id|ad_fmt
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|channels
)paren
(brace
r_case
l_int|2
suffix:colon
id|ad_mode
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ad_mode
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|DBGPV
c_func
(paren
l_string|&quot;ad_mode = %d, ad_fmt = %d&bslash;n&quot;
comma
id|ad_mode
comma
id|ad_fmt
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|framerate
op_ge
l_int|4000
op_logical_and
id|framerate
op_le
l_int|49000
)paren
suffix:semicolon
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_C1C
comma
id|framerate
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_DA1SM
comma
id|ad_mode
comma
op_amp
id|ad1843_DA1F
comma
id|ad_fmt
)paren
suffix:semicolon
)brace
DECL|function|ad1843_shutdown_dac
r_static
r_void
id|ad1843_shutdown_dac
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_DA1F
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ad1843_setup_adc
r_static
r_void
id|ad1843_setup_adc
c_func
(paren
id|lithium_t
op_star
id|lith
comma
r_int
id|framerate
comma
r_int
id|fmt
comma
r_int
id|channels
)paren
(brace
r_int
id|da_fmt
op_assign
l_int|0
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(lith=0x%p, framerate=%d, fmt=%d, channels=%d)&bslash;n&quot;
comma
id|lith
comma
id|framerate
comma
id|fmt
comma
id|channels
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fmt
)paren
(brace
r_case
id|AFMT_S8
suffix:colon
id|da_fmt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
id|da_fmt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_LE
suffix:colon
id|da_fmt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_MU_LAW
suffix:colon
id|da_fmt
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_A_LAW
suffix:colon
id|da_fmt
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|DBGPV
c_func
(paren
l_string|&quot;da_fmt = %d&bslash;n&quot;
comma
id|da_fmt
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|framerate
op_ge
l_int|4000
op_logical_and
id|framerate
op_le
l_int|49000
)paren
suffix:semicolon
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_C2C
comma
id|framerate
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_ADLF
comma
id|da_fmt
comma
op_amp
id|ad1843_ADRF
comma
id|da_fmt
)paren
suffix:semicolon
)brace
DECL|function|ad1843_shutdown_adc
r_static
r_void
id|ad1843_shutdown_adc
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
multiline_comment|/* nothing to do */
)brace
multiline_comment|/*&n; * Fully initialize the ad1843.  As described in the AD1843 data&n; * sheet, section &quot;START-UP SEQUENCE&quot;.  The numbered comments are&n; * subsection headings from the data sheet.  See the data sheet, pages&n; * 52-54, for more info.&n; *&n; * return 0 on success, -errno on failure.  */
DECL|function|ad1843_init
r_static
r_int
id|__init
id|ad1843_init
c_func
(paren
id|lithium_t
op_star
id|lith
)paren
(brace
r_int
r_int
id|later
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|li_init
c_func
(paren
id|lith
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_INIT
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vwsnd sound: AD1843 won&squot;t initialize&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_SCF
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 4. Put the conversion resources into standby. */
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_PDNI
comma
l_int|0
)paren
suffix:semicolon
id|later
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
multiline_comment|/* roughly half a second */
id|DBGDO
c_func
(paren
id|shut_up
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ad1843_read_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_PDNO
)paren
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|later
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vwsnd audio: AD1843 won&squot;t power up&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|DBGDO
c_func
(paren
id|shut_up
op_decrement
)paren
suffix:semicolon
multiline_comment|/* 5. Power up the clock generators and enable clock output pins. */
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_C1EN
comma
l_int|1
comma
op_amp
id|ad1843_C2EN
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 6. Configure conversion resources while they are in standby. */
multiline_comment|/* DAC1 uses clock 1 as source, ADC uses clock 2.  Always. */
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|3
comma
op_amp
id|ad1843_DA1C
comma
l_int|1
comma
op_amp
id|ad1843_ADLC
comma
l_int|2
comma
op_amp
id|ad1843_ADRC
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 7. Enable conversion resources. */
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_ADTLK
comma
l_int|1
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|5
comma
op_amp
id|ad1843_ANAEN
comma
l_int|1
comma
op_amp
id|ad1843_AAMEN
comma
l_int|1
comma
op_amp
id|ad1843_DA1EN
comma
l_int|1
comma
op_amp
id|ad1843_ADLEN
comma
l_int|1
comma
op_amp
id|ad1843_ADREN
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 8. Configure conversion resources while they are enabled. */
id|ad1843_write_bits
c_func
(paren
id|lith
comma
op_amp
id|ad1843_DA1C
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Unmute all channels. */
id|ad1843_set_outsrc
c_func
(paren
id|lith
comma
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
)paren
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LDA1AM
comma
l_int|0
comma
op_amp
id|ad1843_RDA1AM
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set default recording source to Line In and set&n;&t; * mic gain to +20 dB.&n;&t; */
id|ad1843_set_recsrc
c_func
(paren
id|lith
comma
id|SOUND_MASK_LINE
)paren
suffix:semicolon
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_LMGE
comma
l_int|1
comma
op_amp
id|ad1843_RMGE
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set Speaker Out level to +/- 4V and unmute it. */
id|ad1843_write_multi
c_func
(paren
id|lith
comma
l_int|2
comma
op_amp
id|ad1843_HPOS
comma
l_int|1
comma
op_amp
id|ad1843_HPOM
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/* PCM I/O */
DECL|macro|READ_INTR_MASK
mdefine_line|#define READ_INTR_MASK  (LI_INTR_COMM1_TRIG | LI_INTR_COMM1_OVERFLOW)
DECL|macro|WRITE_INTR_MASK
mdefine_line|#define WRITE_INTR_MASK (LI_INTR_COMM2_TRIG | LI_INTR_COMM2_UNDERFLOW)
DECL|enum|vwsnd_port_swstate
r_typedef
r_enum
id|vwsnd_port_swstate
(brace
multiline_comment|/* software state */
DECL|enumerator|SW_OFF
id|SW_OFF
comma
DECL|enumerator|SW_INITIAL
id|SW_INITIAL
comma
DECL|enumerator|SW_RUN
id|SW_RUN
comma
DECL|enumerator|SW_DRAIN
id|SW_DRAIN
comma
DECL|typedef|vwsnd_port_swstate_t
)brace
id|vwsnd_port_swstate_t
suffix:semicolon
DECL|enum|vwsnd_port_hwstate
r_typedef
r_enum
id|vwsnd_port_hwstate
(brace
multiline_comment|/* hardware state */
DECL|enumerator|HW_STOPPED
id|HW_STOPPED
comma
DECL|enumerator|HW_RUNNING
id|HW_RUNNING
comma
DECL|typedef|vwsnd_port_hwstate_t
)brace
id|vwsnd_port_hwstate_t
suffix:semicolon
multiline_comment|/*&n; * These flags are read by ISR, but only written at baseline.&n; */
DECL|enum|vwsnd_port_flags
r_typedef
r_enum
id|vwsnd_port_flags
(brace
DECL|enumerator|DISABLED
id|DISABLED
op_assign
l_int|1
op_lshift
l_int|0
comma
DECL|enumerator|ERFLOWN
id|ERFLOWN
op_assign
l_int|1
op_lshift
l_int|1
comma
multiline_comment|/* overflown or underflown */
DECL|enumerator|HW_BUSY
id|HW_BUSY
op_assign
l_int|1
op_lshift
l_int|2
comma
DECL|typedef|vwsnd_port_flags_t
)brace
id|vwsnd_port_flags_t
suffix:semicolon
multiline_comment|/*&n; * vwsnd_port is the per-port data structure.  Each device has two&n; * ports, one for input and one for output.&n; *&n; * Locking:&n; *&n; *&t;port-&gt;lock protects: hwstate, flags, swb_[iu]_avail.&n; *&n; *&t;devc-&gt;io_sema protects: swstate, sw_*, swb_[iu]_idx.&n; *&n; *&t;everything else is only written by open/release or&n; *&t;pcm_{setup,shutdown}(), which are serialized by a&n; *&t;combination of devc-&gt;open_sema and devc-&gt;io_sema.&n; */
DECL|struct|vwsnd_port
r_typedef
r_struct
id|vwsnd_port
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|queue
id|wait_queue_head_t
id|queue
suffix:semicolon
DECL|member|swstate
id|vwsnd_port_swstate_t
id|swstate
suffix:semicolon
DECL|member|hwstate
id|vwsnd_port_hwstate_t
id|hwstate
suffix:semicolon
DECL|member|flags
id|vwsnd_port_flags_t
id|flags
suffix:semicolon
DECL|member|sw_channels
r_int
id|sw_channels
suffix:semicolon
DECL|member|sw_samplefmt
r_int
id|sw_samplefmt
suffix:semicolon
DECL|member|sw_framerate
r_int
id|sw_framerate
suffix:semicolon
DECL|member|sample_size
r_int
id|sample_size
suffix:semicolon
DECL|member|frame_size
r_int
id|frame_size
suffix:semicolon
DECL|member|zero_word
r_int
r_int
id|zero_word
suffix:semicolon
multiline_comment|/* zero for the sample format */
DECL|member|sw_fragshift
r_int
id|sw_fragshift
suffix:semicolon
DECL|member|sw_fragcount
r_int
id|sw_fragcount
suffix:semicolon
DECL|member|sw_subdivshift
r_int
id|sw_subdivshift
suffix:semicolon
DECL|member|hw_fragshift
r_int
r_int
id|hw_fragshift
suffix:semicolon
DECL|member|hw_fragsize
r_int
r_int
id|hw_fragsize
suffix:semicolon
DECL|member|hw_fragcount
r_int
r_int
id|hw_fragcount
suffix:semicolon
DECL|member|hwbuf_size
r_int
id|hwbuf_size
suffix:semicolon
DECL|member|hwbuf_paddr
r_int
r_int
id|hwbuf_paddr
suffix:semicolon
DECL|member|hwbuf_vaddr
r_int
r_int
id|hwbuf_vaddr
suffix:semicolon
DECL|member|hwbuf
id|caddr_t
id|hwbuf
suffix:semicolon
multiline_comment|/* hwbuf == hwbuf_vaddr */
DECL|member|hwbuf_max
r_int
id|hwbuf_max
suffix:semicolon
multiline_comment|/* max bytes to preload */
DECL|member|swbuf
id|caddr_t
id|swbuf
suffix:semicolon
DECL|member|swbuf_size
r_int
r_int
id|swbuf_size
suffix:semicolon
multiline_comment|/* size in bytes */
DECL|member|swb_u_idx
r_int
r_int
id|swb_u_idx
suffix:semicolon
multiline_comment|/* index of next user byte */
DECL|member|swb_i_idx
r_int
r_int
id|swb_i_idx
suffix:semicolon
multiline_comment|/* index of next intr byte */
DECL|member|swb_u_avail
r_int
r_int
id|swb_u_avail
suffix:semicolon
multiline_comment|/* # bytes avail to user */
DECL|member|swb_i_avail
r_int
r_int
id|swb_i_avail
suffix:semicolon
multiline_comment|/* # bytes avail to intr */
DECL|member|chan
id|dma_chan_t
id|chan
suffix:semicolon
multiline_comment|/* Accounting */
DECL|member|byte_count
r_int
id|byte_count
suffix:semicolon
DECL|member|frag_count
r_int
id|frag_count
suffix:semicolon
DECL|member|MSC_offset
r_int
id|MSC_offset
suffix:semicolon
DECL|typedef|vwsnd_port_t
)brace
id|vwsnd_port_t
suffix:semicolon
multiline_comment|/* vwsnd_dev is the per-device data structure. */
DECL|struct|vwsnd_dev
r_typedef
r_struct
id|vwsnd_dev
(brace
DECL|member|next_dev
r_struct
id|vwsnd_dev
op_star
id|next_dev
suffix:semicolon
DECL|member|audio_minor
r_int
id|audio_minor
suffix:semicolon
multiline_comment|/* minor number of audio device */
DECL|member|mixer_minor
r_int
id|mixer_minor
suffix:semicolon
multiline_comment|/* minor number of mixer device */
DECL|member|open_sema
r_struct
id|semaphore
id|open_sema
suffix:semicolon
DECL|member|io_sema
r_struct
id|semaphore
id|io_sema
suffix:semicolon
DECL|member|mix_sema
r_struct
id|semaphore
id|mix_sema
suffix:semicolon
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|lith
id|lithium_t
id|lith
suffix:semicolon
DECL|member|rport
id|vwsnd_port_t
id|rport
suffix:semicolon
DECL|member|wport
id|vwsnd_port_t
id|wport
suffix:semicolon
DECL|typedef|vwsnd_dev_t
)brace
id|vwsnd_dev_t
suffix:semicolon
DECL|variable|vwsnd_dev_list
r_static
id|vwsnd_dev_t
op_star
id|vwsnd_dev_list
suffix:semicolon
multiline_comment|/* linked list of all devices */
DECL|variable|vwsnd_use_count
r_static
id|atomic_t
id|vwsnd_use_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|macro|INC_USE_COUNT
macro_line|# define INC_USE_COUNT (atomic_inc(&amp;vwsnd_use_count))
DECL|macro|DEC_USE_COUNT
macro_line|# define DEC_USE_COUNT (atomic_dec(&amp;vwsnd_use_count))
DECL|macro|IN_USE
macro_line|# define IN_USE        (atomic_read(&amp;vwsnd_use_count) != 0)
multiline_comment|/*&n; * Lithium can only DMA multiples of 32 bytes.  Its DMA buffer may&n; * be up to 8 Kb.  This driver always uses 8 Kb.&n; *&n; * Memory bug workaround -- I&squot;m not sure what&squot;s going on here, but&n; * somehow pcm_copy_out() was triggering segv&squot;s going on to the next&n; * page of the hw buffer.  So, I make the hw buffer one size bigger&n; * than we actually use.  That way, the following page is allocated&n; * and mapped, and no error.  I suspect that something is broken&n; * in Cobalt, but haven&squot;t really investigated.  HBO is the actual&n; * size of the buffer, and HWBUF_ORDER is what we allocate.&n; */
DECL|macro|HWBUF_SHIFT
mdefine_line|#define HWBUF_SHIFT 13
DECL|macro|HWBUF_SIZE
mdefine_line|#define HWBUF_SIZE (1 &lt;&lt; HWBUF_SHIFT)
DECL|macro|HBO
macro_line|# define HBO         (HWBUF_SHIFT &gt; PAGE_SHIFT ? HWBUF_SHIFT - PAGE_SHIFT : 0)
DECL|macro|HWBUF_ORDER
macro_line|# define HWBUF_ORDER (HBO + 1)&t;&t;/* next size bigger */
DECL|macro|MIN_SPEED
mdefine_line|#define MIN_SPEED 4000
DECL|macro|MAX_SPEED
mdefine_line|#define MAX_SPEED 49000
DECL|macro|MIN_FRAGSHIFT
mdefine_line|#define MIN_FRAGSHIFT&t;&t;&t;(DMACHUNK_SHIFT + 1)
DECL|macro|MAX_FRAGSHIFT
mdefine_line|#define MAX_FRAGSHIFT&t;&t;&t;(PAGE_SHIFT)
DECL|macro|MIN_FRAGSIZE
mdefine_line|#define MIN_FRAGSIZE&t;&t;&t;(1 &lt;&lt; MIN_FRAGSHIFT)
DECL|macro|MAX_FRAGSIZE
mdefine_line|#define MAX_FRAGSIZE&t;&t;&t;(1 &lt;&lt; MAX_FRAGSHIFT)
DECL|macro|MIN_FRAGCOUNT
mdefine_line|#define MIN_FRAGCOUNT(fragsize)&t;&t;3
DECL|macro|MAX_FRAGCOUNT
mdefine_line|#define MAX_FRAGCOUNT(fragsize)&t;&t;(32 * PAGE_SIZE / (fragsize))
DECL|macro|DEFAULT_FRAGSHIFT
mdefine_line|#define DEFAULT_FRAGSHIFT&t;&t;12
DECL|macro|DEFAULT_FRAGCOUNT
mdefine_line|#define DEFAULT_FRAGCOUNT&t;&t;16
DECL|macro|DEFAULT_SUBDIVSHIFT
mdefine_line|#define DEFAULT_SUBDIVSHIFT&t;&t;0
multiline_comment|/*&n; * The software buffer (swbuf) is a ring buffer shared between user&n; * level and interrupt level.  Each level owns some of the bytes in&n; * the buffer, and may give bytes away by calling swb_inc_{u,i}().&n; * User level calls _u for user, and interrupt level calls _i for&n; * interrupt.&n; *&n; * port-&gt;swb_{u,i}_avail is the number of bytes available to that level.&n; *&n; * port-&gt;swb_{u,i}_idx is the index of the first available byte in the&n; * buffer.&n; *&n; * Each level calls swb_inc_{u,i}() to atomically increment its index,&n; * recalculate the number of bytes available for both sides, and&n; * return the number of bytes available.  Since each side can only&n; * give away bytes, the other side can only increase the number of&n; * bytes available to this side.  Each side updates its own index&n; * variable, swb_{u,i}_idx, so no lock is needed to read it.&n; *&n; * To query the number of bytes available, call swb_inc_{u,i} with an&n; * increment of zero.&n; */
DECL|function|__swb_inc_u
r_static
id|__inline__
r_int
r_int
id|__swb_inc_u
c_func
(paren
id|vwsnd_port_t
op_star
id|port
comma
r_int
id|inc
)paren
(brace
r_if
c_cond
(paren
id|inc
)paren
(brace
id|port-&gt;swb_u_idx
op_add_assign
id|inc
suffix:semicolon
id|port-&gt;swb_u_idx
op_mod_assign
id|port-&gt;swbuf_size
suffix:semicolon
id|port-&gt;swb_u_avail
op_sub_assign
id|inc
suffix:semicolon
id|port-&gt;swb_i_avail
op_add_assign
id|inc
suffix:semicolon
)brace
r_return
id|port-&gt;swb_u_avail
suffix:semicolon
)brace
DECL|function|swb_inc_u
r_static
id|__inline__
r_int
r_int
id|swb_inc_u
c_func
(paren
id|vwsnd_port_t
op_star
id|port
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|ret
op_assign
id|__swb_inc_u
c_func
(paren
id|port
comma
id|inc
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__swb_inc_i
r_static
id|__inline__
r_int
r_int
id|__swb_inc_i
c_func
(paren
id|vwsnd_port_t
op_star
id|port
comma
r_int
id|inc
)paren
(brace
r_if
c_cond
(paren
id|inc
)paren
(brace
id|port-&gt;swb_i_idx
op_add_assign
id|inc
suffix:semicolon
id|port-&gt;swb_i_idx
op_mod_assign
id|port-&gt;swbuf_size
suffix:semicolon
id|port-&gt;swb_i_avail
op_sub_assign
id|inc
suffix:semicolon
id|port-&gt;swb_u_avail
op_add_assign
id|inc
suffix:semicolon
)brace
r_return
id|port-&gt;swb_i_avail
suffix:semicolon
)brace
DECL|function|swb_inc_i
r_static
id|__inline__
r_int
r_int
id|swb_inc_i
c_func
(paren
id|vwsnd_port_t
op_star
id|port
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|ret
op_assign
id|__swb_inc_i
c_func
(paren
id|port
comma
id|inc
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * pcm_setup - this routine initializes all port state after&n; * mode-setting ioctls have been done, but before the first I/O is&n; * done.&n; *&n; * Locking: called with devc-&gt;io_sema held.&n; *&n; * Returns 0 on success, -errno on failure.&n; */
DECL|function|pcm_setup
r_static
r_int
id|pcm_setup
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
id|vwsnd_port_t
op_star
id|rport
comma
id|vwsnd_port_t
op_star
id|wport
)paren
(brace
id|vwsnd_port_t
op_star
id|aport
op_assign
id|rport
ques
c_cond
id|rport
suffix:colon
id|wport
suffix:semicolon
r_int
id|sample_size
suffix:semicolon
r_int
r_int
id|zero_word
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, rport=0x%p, wport=0x%p)&bslash;n&quot;
comma
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|aport
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aport-&gt;swbuf
op_ne
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|aport-&gt;sw_samplefmt
)paren
(brace
r_case
id|AFMT_MU_LAW
suffix:colon
id|sample_size
op_assign
l_int|1
suffix:semicolon
id|zero_word
op_assign
l_int|0xFFFFFFFF
op_xor
l_int|0x80808080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_A_LAW
suffix:colon
id|sample_size
op_assign
l_int|1
suffix:semicolon
id|zero_word
op_assign
l_int|0xD5D5D5D5
op_xor
l_int|0x80808080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
id|sample_size
op_assign
l_int|1
suffix:semicolon
id|zero_word
op_assign
l_int|0x80808080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S8
suffix:colon
id|sample_size
op_assign
l_int|1
suffix:semicolon
id|zero_word
op_assign
l_int|0x00000000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_LE
suffix:colon
id|sample_size
op_assign
l_int|2
suffix:semicolon
id|zero_word
op_assign
l_int|0x00000000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sample_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* prevent compiler warning */
id|zero_word
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|aport-&gt;sample_size
op_assign
id|sample_size
suffix:semicolon
id|aport-&gt;zero_word
op_assign
id|zero_word
suffix:semicolon
id|aport-&gt;frame_size
op_assign
id|aport-&gt;sw_channels
op_star
id|aport-&gt;sample_size
suffix:semicolon
id|aport-&gt;hw_fragshift
op_assign
id|aport-&gt;sw_fragshift
op_minus
id|aport-&gt;sw_subdivshift
suffix:semicolon
id|aport-&gt;hw_fragsize
op_assign
l_int|1
op_lshift
id|aport-&gt;hw_fragshift
suffix:semicolon
id|aport-&gt;hw_fragcount
op_assign
id|aport-&gt;sw_fragcount
op_lshift
id|aport-&gt;sw_subdivshift
suffix:semicolon
id|ASSERT
c_func
(paren
id|aport-&gt;hw_fragsize
op_ge
id|MIN_FRAGSIZE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|aport-&gt;hw_fragsize
op_le
id|MAX_FRAGSIZE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|aport-&gt;hw_fragcount
op_ge
id|MIN_FRAGCOUNT
c_func
(paren
id|aport-&gt;hw_fragsize
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|aport-&gt;hw_fragcount
op_le
id|MAX_FRAGCOUNT
c_func
(paren
id|aport-&gt;hw_fragsize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
(brace
r_int
id|hwfrags
comma
id|swfrags
suffix:semicolon
id|rport-&gt;hwbuf_max
op_assign
id|aport-&gt;hwbuf_size
op_minus
id|DMACHUNK_SIZE
suffix:semicolon
id|hwfrags
op_assign
id|rport-&gt;hwbuf_max
op_rshift
id|aport-&gt;hw_fragshift
suffix:semicolon
id|swfrags
op_assign
id|aport-&gt;hw_fragcount
op_minus
id|hwfrags
suffix:semicolon
r_if
c_cond
(paren
id|swfrags
OL
l_int|2
)paren
id|swfrags
op_assign
l_int|2
suffix:semicolon
id|rport-&gt;swbuf_size
op_assign
id|swfrags
op_star
id|aport-&gt;hw_fragsize
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;hwfrags = %d, swfrags = %d&bslash;n&quot;
comma
id|hwfrags
comma
id|swfrags
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;read hwbuf_max = %d, swbuf_size = %d&bslash;n&quot;
comma
id|rport-&gt;hwbuf_max
comma
id|rport-&gt;swbuf_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wport
)paren
(brace
r_int
id|hwfrags
comma
id|swfrags
suffix:semicolon
r_int
id|total_bytes
op_assign
id|aport-&gt;hw_fragcount
op_star
id|aport-&gt;hw_fragsize
suffix:semicolon
id|wport-&gt;hwbuf_max
op_assign
id|aport-&gt;hwbuf_size
op_minus
id|DMACHUNK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;hwbuf_max
OG
id|total_bytes
)paren
id|wport-&gt;hwbuf_max
op_assign
id|total_bytes
suffix:semicolon
id|hwfrags
op_assign
id|wport-&gt;hwbuf_max
op_rshift
id|aport-&gt;hw_fragshift
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;hwfrags = %d&bslash;n&quot;
comma
id|hwfrags
)paren
suffix:semicolon
id|swfrags
op_assign
id|aport-&gt;hw_fragcount
op_minus
id|hwfrags
suffix:semicolon
r_if
c_cond
(paren
id|swfrags
OL
l_int|2
)paren
id|swfrags
op_assign
l_int|2
suffix:semicolon
id|wport-&gt;swbuf_size
op_assign
id|swfrags
op_star
id|aport-&gt;hw_fragsize
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;hwfrags = %d, swfrags = %d&bslash;n&quot;
comma
id|hwfrags
comma
id|swfrags
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;write hwbuf_max = %d, swbuf_size = %d&bslash;n&quot;
comma
id|wport-&gt;hwbuf_max
comma
id|wport-&gt;swbuf_size
)paren
suffix:semicolon
)brace
id|aport-&gt;swb_u_idx
op_assign
l_int|0
suffix:semicolon
id|aport-&gt;swb_i_idx
op_assign
l_int|0
suffix:semicolon
id|aport-&gt;byte_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Is this a Cobalt bug?  We need to make this buffer extend&n;&t; * one page further than we actually use -- somehow memcpy&n;&t; * causes an exceptoin otherwise.  I suspect there&squot;s a bug in&n;&t; * Cobalt (or somewhere) where it&squot;s generating a fault on a&n;&t; * speculative load or something.  Obviously, I haven&squot;t taken&n;&t; * the time to track it down.&n;&t; */
id|aport-&gt;swbuf
op_assign
id|vmalloc
c_func
(paren
id|aport-&gt;swbuf_size
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aport-&gt;swbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|rport
op_logical_and
id|wport
)paren
(brace
id|ASSERT
c_func
(paren
id|aport
op_eq
id|rport
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|wport-&gt;swbuf
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* One extra page - see comment above. */
id|wport-&gt;swbuf
op_assign
id|vmalloc
c_func
(paren
id|aport-&gt;swbuf_size
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wport-&gt;swbuf
)paren
(brace
id|vfree
c_func
(paren
id|aport-&gt;swbuf
)paren
suffix:semicolon
id|aport-&gt;swbuf
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|wport-&gt;sample_size
op_assign
id|rport-&gt;sample_size
suffix:semicolon
id|wport-&gt;zero_word
op_assign
id|rport-&gt;zero_word
suffix:semicolon
id|wport-&gt;frame_size
op_assign
id|rport-&gt;frame_size
suffix:semicolon
id|wport-&gt;hw_fragshift
op_assign
id|rport-&gt;hw_fragshift
suffix:semicolon
id|wport-&gt;hw_fragsize
op_assign
id|rport-&gt;hw_fragsize
suffix:semicolon
id|wport-&gt;hw_fragcount
op_assign
id|rport-&gt;hw_fragcount
suffix:semicolon
id|wport-&gt;swbuf_size
op_assign
id|rport-&gt;swbuf_size
suffix:semicolon
id|wport-&gt;hwbuf_max
op_assign
id|rport-&gt;hwbuf_max
suffix:semicolon
id|wport-&gt;swb_u_idx
op_assign
id|rport-&gt;swb_u_idx
suffix:semicolon
id|wport-&gt;swb_i_idx
op_assign
id|rport-&gt;swb_i_idx
suffix:semicolon
id|wport-&gt;byte_count
op_assign
id|rport-&gt;byte_count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rport
)paren
(brace
id|rport-&gt;swb_u_avail
op_assign
l_int|0
suffix:semicolon
id|rport-&gt;swb_i_avail
op_assign
id|rport-&gt;swbuf_size
suffix:semicolon
id|rport-&gt;swstate
op_assign
id|SW_RUN
suffix:semicolon
id|li_setup_dma
c_func
(paren
op_amp
id|rport-&gt;chan
comma
op_amp
id|li_comm1
comma
op_amp
id|devc-&gt;lith
comma
id|rport-&gt;hwbuf_paddr
comma
id|HWBUF_SHIFT
comma
id|rport-&gt;hw_fragshift
comma
id|rport-&gt;sw_channels
comma
id|rport-&gt;sample_size
)paren
suffix:semicolon
id|ad1843_setup_adc
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|rport-&gt;sw_framerate
comma
id|rport-&gt;sw_samplefmt
comma
id|rport-&gt;sw_channels
)paren
suffix:semicolon
id|li_enable_interrupts
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|READ_INTR_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rport-&gt;flags
op_amp
id|DISABLED
)paren
)paren
(brace
id|ustmsc_t
id|ustmsc
suffix:semicolon
id|rport-&gt;hwstate
op_assign
id|HW_RUNNING
suffix:semicolon
id|li_activate_dma
c_func
(paren
op_amp
id|rport-&gt;chan
)paren
suffix:semicolon
id|li_read_USTMSC
c_func
(paren
op_amp
id|rport-&gt;chan
comma
op_amp
id|ustmsc
)paren
suffix:semicolon
id|rport-&gt;MSC_offset
op_assign
id|ustmsc.msc
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wport
)paren
(brace
r_if
c_cond
(paren
id|wport-&gt;hwbuf_max
OG
id|wport-&gt;swbuf_size
)paren
id|wport-&gt;hwbuf_max
op_assign
id|wport-&gt;swbuf_size
suffix:semicolon
id|wport-&gt;flags
op_and_assign
op_complement
id|ERFLOWN
suffix:semicolon
id|wport-&gt;swb_u_avail
op_assign
id|wport-&gt;swbuf_size
suffix:semicolon
id|wport-&gt;swb_i_avail
op_assign
l_int|0
suffix:semicolon
id|wport-&gt;swstate
op_assign
id|SW_RUN
suffix:semicolon
id|li_setup_dma
c_func
(paren
op_amp
id|wport-&gt;chan
comma
op_amp
id|li_comm2
comma
op_amp
id|devc-&gt;lith
comma
id|wport-&gt;hwbuf_paddr
comma
id|HWBUF_SHIFT
comma
id|wport-&gt;hw_fragshift
comma
id|wport-&gt;sw_channels
comma
id|wport-&gt;sample_size
)paren
suffix:semicolon
id|ad1843_setup_dac
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|wport-&gt;sw_framerate
comma
id|wport-&gt;sw_samplefmt
comma
id|wport-&gt;sw_channels
)paren
suffix:semicolon
id|li_enable_interrupts
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|WRITE_INTR_MASK
)paren
suffix:semicolon
)brace
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcm_shutdown_port - shut down one port (direction) for PCM I/O.&n; * Only called from pcm_shutdown.&n; */
DECL|function|pcm_shutdown_port
r_static
r_void
id|pcm_shutdown_port
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
id|vwsnd_port_t
op_star
id|aport
comma
r_int
r_int
id|mask
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|vwsnd_port_hwstate_t
id|hwstate
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|aport-&gt;swstate
op_assign
id|SW_INITIAL
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|aport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|aport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|hwstate
op_assign
id|aport-&gt;hwstate
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|aport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwstate
op_eq
id|HW_STOPPED
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|aport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|li_disable_interrupts
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aport
op_eq
op_amp
id|devc-&gt;rport
)paren
id|ad1843_shutdown_adc
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
r_else
multiline_comment|/* aport == &amp;devc-&gt;wport) */
id|ad1843_shutdown_dac
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
id|li_shutdown_dma
c_func
(paren
op_amp
id|aport-&gt;chan
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|aport-&gt;swbuf
)paren
suffix:semicolon
id|aport-&gt;swbuf
op_assign
l_int|NULL
suffix:semicolon
id|aport-&gt;byte_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pcm_shutdown undoes what pcm_setup did.&n; * Also sets the ports&squot; swstate to newstate.&n; */
DECL|function|pcm_shutdown
r_static
r_void
id|pcm_shutdown
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
id|vwsnd_port_t
op_star
id|rport
comma
id|vwsnd_port_t
op_star
id|wport
)paren
(brace
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, rport=0x%p, wport=0x%p)&bslash;n&quot;
comma
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport
op_logical_and
id|rport-&gt;swbuf
)paren
(brace
id|DBGPV
c_func
(paren
l_string|&quot;shutting down rport&bslash;n&quot;
)paren
suffix:semicolon
id|pcm_shutdown_port
c_func
(paren
id|devc
comma
id|rport
comma
id|READ_INTR_MASK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wport
op_logical_and
id|wport-&gt;swbuf
)paren
(brace
id|DBGPV
c_func
(paren
l_string|&quot;shutting down wport&bslash;n&quot;
)paren
suffix:semicolon
id|pcm_shutdown_port
c_func
(paren
id|devc
comma
id|wport
comma
id|WRITE_INTR_MASK
)paren
suffix:semicolon
)brace
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|pcm_copy_in
r_static
r_void
id|pcm_copy_in
c_func
(paren
id|vwsnd_port_t
op_star
id|rport
comma
r_int
id|swidx
comma
r_int
id|hwidx
comma
r_int
id|nb
)paren
(brace
r_char
op_star
id|src
op_assign
id|rport-&gt;hwbuf
op_plus
id|hwidx
suffix:semicolon
r_char
op_star
id|dst
op_assign
id|rport-&gt;swbuf
op_plus
id|swidx
suffix:semicolon
r_int
id|fmt
op_assign
id|rport-&gt;sw_samplefmt
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;swidx = %d, hwidx = %d&bslash;n&quot;
comma
id|swidx
comma
id|hwidx
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rport-&gt;hwbuf
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rport-&gt;swbuf
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nb
OG
l_int|0
op_logical_and
(paren
id|nb
op_mod
l_int|32
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|swidx
op_mod
l_int|32
op_eq
l_int|0
op_logical_and
id|hwidx
op_mod
l_int|32
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|swidx
op_ge
l_int|0
op_logical_and
id|swidx
op_plus
id|nb
op_le
id|rport-&gt;swbuf_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hwidx
op_ge
l_int|0
op_logical_and
id|hwidx
op_plus
id|nb
op_le
id|rport-&gt;hwbuf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|AFMT_MU_LAW
op_logical_or
id|fmt
op_eq
id|AFMT_A_LAW
op_logical_or
id|fmt
op_eq
id|AFMT_S8
)paren
(brace
multiline_comment|/* See Sample Format Notes above. */
r_char
op_star
id|end
op_assign
id|src
op_plus
id|nb
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
op_xor
l_int|0x80
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|pcm_copy_out
r_static
r_void
id|pcm_copy_out
c_func
(paren
id|vwsnd_port_t
op_star
id|wport
comma
r_int
id|swidx
comma
r_int
id|hwidx
comma
r_int
id|nb
)paren
(brace
r_char
op_star
id|src
op_assign
id|wport-&gt;swbuf
op_plus
id|swidx
suffix:semicolon
r_char
op_star
id|dst
op_assign
id|wport-&gt;hwbuf
op_plus
id|hwidx
suffix:semicolon
r_int
id|fmt
op_assign
id|wport-&gt;sw_samplefmt
suffix:semicolon
id|ASSERT
c_func
(paren
id|nb
OG
l_int|0
op_logical_and
(paren
id|nb
op_mod
l_int|32
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|wport-&gt;hwbuf
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|wport-&gt;swbuf
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|swidx
op_mod
l_int|32
op_eq
l_int|0
op_logical_and
id|hwidx
op_mod
l_int|32
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|swidx
op_ge
l_int|0
op_logical_and
id|swidx
op_plus
id|nb
op_le
id|wport-&gt;swbuf_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|hwidx
op_ge
l_int|0
op_logical_and
id|hwidx
op_plus
id|nb
op_le
id|wport-&gt;hwbuf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|AFMT_MU_LAW
op_logical_or
id|fmt
op_eq
id|AFMT_A_LAW
op_logical_or
id|fmt
op_eq
id|AFMT_S8
)paren
(brace
multiline_comment|/* See Sample Format Notes above. */
r_char
op_star
id|end
op_assign
id|src
op_plus
id|nb
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
op_xor
l_int|0x80
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcm_output() is called both from baselevel and from interrupt level.&n; * This is where audio frames are copied into the hardware-accessible&n; * ring buffer.&n; *&n; * Locking note: The part of this routine that figures out what to do&n; * holds wport-&gt;lock.  The longer part releases wport-&gt;lock, but sets&n; * wport-&gt;flags &amp; HW_BUSY.  Afterward, it reacquires wport-&gt;lock, and&n; * checks for more work to do.&n; *&n; * If another thread calls pcm_output() while HW_BUSY is set, it&n; * returns immediately, knowing that the thread that set HW_BUSY will&n; * look for more work to do before returning.&n; *&n; * This has the advantage that port-&gt;lock is held for several short&n; * periods instead of one long period.  Also, when pcm_output is&n; * called from base level, it reenables interrupts.&n; */
DECL|function|pcm_output
r_static
r_void
id|pcm_output
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
r_int
id|erflown
comma
r_int
id|nb
)paren
(brace
id|vwsnd_port_t
op_star
id|wport
op_assign
op_amp
id|devc-&gt;wport
suffix:semicolon
r_const
r_int
id|hwmax
op_assign
id|wport-&gt;hwbuf_max
suffix:semicolon
r_const
r_int
id|hwsize
op_assign
id|wport-&gt;hwbuf_size
suffix:semicolon
r_const
r_int
id|swsize
op_assign
id|wport-&gt;swbuf_size
suffix:semicolon
r_const
r_int
id|fragsize
op_assign
id|wport-&gt;hw_fragsize
suffix:semicolon
r_int
r_int
id|iflags
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, erflown=%d, nb=%d)&bslash;n&quot;
comma
id|devc
comma
id|erflown
comma
id|nb
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erflown
)paren
id|wport-&gt;flags
op_or_assign
id|ERFLOWN
suffix:semicolon
(paren
r_void
)paren
id|__swb_inc_u
c_func
(paren
id|wport
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;flags
op_amp
id|HW_BUSY
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;returning: HW BUSY&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wport-&gt;flags
op_amp
id|DISABLED
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;returning: DISABLED&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|wport-&gt;flags
op_or_assign
id|HW_BUSY
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|swptr
comma
id|hwptr
comma
id|hw_avail
comma
id|sw_avail
comma
id|swidx
suffix:semicolon
id|vwsnd_port_hwstate_t
id|hwstate
op_assign
id|wport-&gt;hwstate
suffix:semicolon
id|vwsnd_port_swstate_t
id|swstate
op_assign
id|wport-&gt;swstate
suffix:semicolon
r_int
id|hw_unavail
suffix:semicolon
id|ustmsc_t
id|ustmsc
suffix:semicolon
id|hwptr
op_assign
id|li_read_hwptr
c_func
(paren
op_amp
id|wport-&gt;chan
)paren
suffix:semicolon
id|swptr
op_assign
id|li_read_swptr
c_func
(paren
op_amp
id|wport-&gt;chan
)paren
suffix:semicolon
id|hw_unavail
op_assign
(paren
id|swptr
op_minus
id|hwptr
op_plus
id|hwsize
)paren
op_mod
id|hwsize
suffix:semicolon
id|hw_avail
op_assign
(paren
id|hwmax
op_minus
id|hw_unavail
)paren
op_amp
op_minus
id|fragsize
suffix:semicolon
id|sw_avail
op_assign
id|wport-&gt;swb_i_avail
op_amp
op_minus
id|fragsize
suffix:semicolon
r_if
c_cond
(paren
id|sw_avail
op_logical_and
id|swstate
op_eq
id|SW_RUN
)paren
(brace
r_if
c_cond
(paren
id|wport-&gt;flags
op_amp
id|ERFLOWN
)paren
(brace
id|wport-&gt;flags
op_and_assign
op_complement
id|ERFLOWN
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|swstate
op_eq
id|SW_INITIAL
op_logical_or
id|swstate
op_eq
id|SW_OFF
op_logical_or
(paren
id|swstate
op_eq
id|SW_DRAIN
op_logical_and
op_logical_neg
id|sw_avail
op_logical_and
(paren
id|wport-&gt;flags
op_amp
id|ERFLOWN
)paren
)paren
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;stopping.  hwstate = %d&bslash;n&quot;
comma
id|hwstate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwstate
op_ne
id|HW_STOPPED
)paren
(brace
id|li_deactivate_dma
c_func
(paren
op_amp
id|wport-&gt;chan
)paren
suffix:semicolon
id|wport-&gt;hwstate
op_assign
id|HW_STOPPED
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|wport-&gt;queue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sw_avail
op_logical_or
op_logical_neg
id|hw_avail
)paren
r_break
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We gave up the port lock, but we have the HW_BUSY flag.&n;&t;&t; * Proceed without accessing any nonlocal state.&n;&t;&t; * Do not exit the loop -- must check for more work.&n;&t;&t; */
id|swidx
op_assign
id|wport-&gt;swb_i_idx
suffix:semicolon
id|nb
op_assign
id|hw_avail
suffix:semicolon
r_if
c_cond
(paren
id|nb
OG
id|sw_avail
)paren
id|nb
op_assign
id|sw_avail
suffix:semicolon
r_if
c_cond
(paren
id|nb
OG
id|hwsize
op_minus
id|swptr
)paren
id|nb
op_assign
id|hwsize
op_minus
id|swptr
suffix:semicolon
multiline_comment|/* don&squot;t overflow hwbuf */
r_if
c_cond
(paren
id|nb
OG
id|swsize
op_minus
id|swidx
)paren
id|nb
op_assign
id|swsize
op_minus
id|swidx
suffix:semicolon
multiline_comment|/* don&squot;t overflow swbuf */
id|ASSERT
c_func
(paren
id|nb
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
op_mod
id|fragsize
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;nb = %d, fragsize = %d&bslash;n&quot;
comma
id|nb
comma
id|fragsize
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;hw_avail = %d&bslash;n&quot;
comma
id|hw_avail
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;sw_avail = %d&bslash;n&quot;
comma
id|sw_avail
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;hwsize = %d, swptr = %d&bslash;n&quot;
comma
id|hwsize
comma
id|swptr
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;swsize = %d, swidx = %d&bslash;n&quot;
comma
id|swsize
comma
id|swidx
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|nb
op_mod
id|fragsize
)paren
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;copying swb[%d..%d] to hwb[%d..%d]&bslash;n&quot;
comma
id|swidx
comma
id|swidx
op_plus
id|nb
comma
id|swptr
comma
id|swptr
op_plus
id|nb
)paren
suffix:semicolon
id|pcm_copy_out
c_func
(paren
id|wport
comma
id|swidx
comma
id|swptr
comma
id|nb
)paren
suffix:semicolon
id|li_write_swptr
c_func
(paren
op_amp
id|wport-&gt;chan
comma
(paren
id|swptr
op_plus
id|nb
)paren
op_mod
id|hwsize
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwstate
op_eq
id|HW_STOPPED
)paren
(brace
id|DBGPV
c_func
(paren
l_string|&quot;starting&bslash;n&quot;
)paren
suffix:semicolon
id|li_activate_dma
c_func
(paren
op_amp
id|wport-&gt;chan
)paren
suffix:semicolon
id|wport-&gt;hwstate
op_assign
id|HW_RUNNING
suffix:semicolon
id|li_read_USTMSC
c_func
(paren
op_amp
id|wport-&gt;chan
comma
op_amp
id|ustmsc
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|wport-&gt;byte_count
op_mod
id|wport-&gt;frame_size
op_eq
l_int|0
)paren
suffix:semicolon
id|wport-&gt;MSC_offset
op_assign
id|ustmsc.msc
op_minus
id|wport-&gt;byte_count
op_div
id|wport-&gt;frame_size
suffix:semicolon
)brace
id|__swb_inc_i
c_func
(paren
id|wport
comma
id|nb
)paren
suffix:semicolon
id|wport-&gt;byte_count
op_add_assign
id|nb
suffix:semicolon
id|wport-&gt;frag_count
op_add_assign
id|nb
op_div
id|fragsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|nb
op_mod
id|fragsize
op_eq
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wport-&gt;queue
)paren
suffix:semicolon
)brace
id|wport-&gt;flags
op_and_assign
op_complement
id|HW_BUSY
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcm_input() is called both from baselevel and from interrupt level.&n; * This is where audio frames are copied out of the hardware-accessible&n; * ring buffer.&n; *&n; * Locking note: The part of this routine that figures out what to do&n; * holds rport-&gt;lock.  The longer part releases rport-&gt;lock, but sets&n; * rport-&gt;flags &amp; HW_BUSY.  Afterward, it reacquires rport-&gt;lock, and&n; * checks for more work to do.&n; *&n; * If another thread calls pcm_input() while HW_BUSY is set, it&n; * returns immediately, knowing that the thread that set HW_BUSY will&n; * look for more work to do before returning.&n; *&n; * This has the advantage that port-&gt;lock is held for several short&n; * periods instead of one long period.  Also, when pcm_input is&n; * called from base level, it reenables interrupts.&n; */
DECL|function|pcm_input
r_static
r_void
id|pcm_input
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
r_int
id|erflown
comma
r_int
id|nb
)paren
(brace
id|vwsnd_port_t
op_star
id|rport
op_assign
op_amp
id|devc-&gt;rport
suffix:semicolon
r_const
r_int
id|hwmax
op_assign
id|rport-&gt;hwbuf_max
suffix:semicolon
r_const
r_int
id|hwsize
op_assign
id|rport-&gt;hwbuf_size
suffix:semicolon
r_const
r_int
id|swsize
op_assign
id|rport-&gt;swbuf_size
suffix:semicolon
r_const
r_int
id|fragsize
op_assign
id|rport-&gt;hw_fragsize
suffix:semicolon
r_int
r_int
id|iflags
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, erflown=%d, nb=%d)&bslash;n&quot;
comma
id|devc
comma
id|erflown
comma
id|nb
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erflown
)paren
id|rport-&gt;flags
op_or_assign
id|ERFLOWN
suffix:semicolon
(paren
r_void
)paren
id|__swb_inc_u
c_func
(paren
id|rport
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport-&gt;flags
op_amp
id|HW_BUSY
op_logical_or
op_logical_neg
id|rport-&gt;swbuf
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;returning: HW BUSY or !swbuf&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rport-&gt;flags
op_amp
id|DISABLED
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;returning: DISABLED&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rport-&gt;flags
op_or_assign
id|HW_BUSY
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|swptr
comma
id|hwptr
comma
id|hw_avail
comma
id|sw_avail
comma
id|swidx
suffix:semicolon
id|vwsnd_port_hwstate_t
id|hwstate
op_assign
id|rport-&gt;hwstate
suffix:semicolon
id|vwsnd_port_swstate_t
id|swstate
op_assign
id|rport-&gt;swstate
suffix:semicolon
id|hwptr
op_assign
id|li_read_hwptr
c_func
(paren
op_amp
id|rport-&gt;chan
)paren
suffix:semicolon
id|swptr
op_assign
id|li_read_swptr
c_func
(paren
op_amp
id|rport-&gt;chan
)paren
suffix:semicolon
id|hw_avail
op_assign
(paren
id|hwptr
op_minus
id|swptr
op_plus
id|hwsize
)paren
op_mod
id|hwsize
op_amp
op_minus
id|fragsize
suffix:semicolon
r_if
c_cond
(paren
id|hw_avail
OG
id|hwmax
)paren
id|hw_avail
op_assign
id|hwmax
suffix:semicolon
id|sw_avail
op_assign
id|rport-&gt;swb_i_avail
op_amp
op_minus
id|fragsize
suffix:semicolon
r_if
c_cond
(paren
id|swstate
op_ne
id|SW_RUN
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;stopping.  hwstate = %d&bslash;n&quot;
comma
id|hwstate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwstate
op_ne
id|HW_STOPPED
)paren
(brace
id|li_deactivate_dma
c_func
(paren
op_amp
id|rport-&gt;chan
)paren
suffix:semicolon
id|rport-&gt;hwstate
op_assign
id|HW_STOPPED
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|rport-&gt;queue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sw_avail
op_logical_or
op_logical_neg
id|hw_avail
)paren
r_break
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We gave up the port lock, but we have the HW_BUSY flag.&n;&t;&t; * Proceed without accessing any nonlocal state.&n;&t;&t; * Do not exit the loop -- must check for more work.&n;&t;&t; */
id|swidx
op_assign
id|rport-&gt;swb_i_idx
suffix:semicolon
id|nb
op_assign
id|hw_avail
suffix:semicolon
r_if
c_cond
(paren
id|nb
OG
id|sw_avail
)paren
id|nb
op_assign
id|sw_avail
suffix:semicolon
r_if
c_cond
(paren
id|nb
OG
id|hwsize
op_minus
id|swptr
)paren
id|nb
op_assign
id|hwsize
op_minus
id|swptr
suffix:semicolon
multiline_comment|/* don&squot;t overflow hwbuf */
r_if
c_cond
(paren
id|nb
OG
id|swsize
op_minus
id|swidx
)paren
id|nb
op_assign
id|swsize
op_minus
id|swidx
suffix:semicolon
multiline_comment|/* don&squot;t overflow swbuf */
id|ASSERT
c_func
(paren
id|nb
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
op_mod
id|fragsize
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;nb = %d, fragsize = %d&bslash;n&quot;
comma
id|nb
comma
id|fragsize
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;hw_avail = %d&bslash;n&quot;
comma
id|hw_avail
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;sw_avail = %d&bslash;n&quot;
comma
id|sw_avail
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;hwsize = %d, swptr = %d&bslash;n&quot;
comma
id|hwsize
comma
id|swptr
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;swsize = %d, swidx = %d&bslash;n&quot;
comma
id|swsize
comma
id|swidx
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|nb
op_mod
id|fragsize
)paren
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;copying hwb[%d..%d] to swb[%d..%d]&bslash;n&quot;
comma
id|swptr
comma
id|swptr
op_plus
id|nb
comma
id|swidx
comma
id|swidx
op_plus
id|nb
)paren
suffix:semicolon
id|pcm_copy_in
c_func
(paren
id|rport
comma
id|swidx
comma
id|swptr
comma
id|nb
)paren
suffix:semicolon
id|li_write_swptr
c_func
(paren
op_amp
id|rport-&gt;chan
comma
(paren
id|swptr
op_plus
id|nb
)paren
op_mod
id|hwsize
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|__swb_inc_i
c_func
(paren
id|rport
comma
id|nb
)paren
suffix:semicolon
id|rport-&gt;byte_count
op_add_assign
id|nb
suffix:semicolon
id|rport-&gt;frag_count
op_add_assign
id|nb
op_div
id|fragsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|nb
op_mod
id|fragsize
op_eq
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rport-&gt;queue
)paren
suffix:semicolon
)brace
id|rport-&gt;flags
op_and_assign
op_complement
id|HW_BUSY
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|iflags
)paren
suffix:semicolon
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pcm_flush_frag() writes zero samples to fill the current fragment,&n; * then flushes it to the hardware.&n; *&n; * It is only meaningful to flush output, not input.&n; */
DECL|function|pcm_flush_frag
r_static
r_void
id|pcm_flush_frag
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
)paren
(brace
id|vwsnd_port_t
op_star
id|wport
op_assign
op_amp
id|devc-&gt;wport
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;swstate = %d&bslash;n&quot;
comma
id|wport-&gt;swstate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;swstate
op_eq
id|SW_RUN
)paren
(brace
r_int
id|idx
op_assign
id|wport-&gt;swb_u_idx
suffix:semicolon
r_int
id|end
op_assign
(paren
id|idx
op_plus
id|wport-&gt;hw_fragsize
op_minus
l_int|1
)paren
op_rshift
id|wport-&gt;hw_fragshift
op_lshift
id|wport-&gt;hw_fragshift
suffix:semicolon
r_int
id|nb
op_assign
id|end
op_minus
id|idx
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;clearing %d bytes&bslash;n&quot;
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
)paren
id|memset
c_func
(paren
id|wport-&gt;swbuf
op_plus
id|idx
comma
(paren
r_char
)paren
id|wport-&gt;zero_word
comma
id|nb
)paren
suffix:semicolon
id|wport-&gt;swstate
op_assign
id|SW_DRAIN
suffix:semicolon
id|pcm_output
c_func
(paren
id|devc
comma
l_int|0
comma
id|nb
)paren
suffix:semicolon
)brace
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for output to drain.  This sleeps uninterruptibly because&n; * there is nothing intelligent we can do if interrupted.  This&n; * means the process will be delayed in responding to the signal.&n; */
DECL|function|pcm_write_sync
r_static
r_void
id|pcm_write_sync
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
)paren
(brace
id|vwsnd_port_t
op_star
id|wport
op_assign
op_amp
id|devc-&gt;wport
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|vwsnd_port_hwstate_t
id|hwstate
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p)&bslash;n&quot;
comma
id|devc
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|hwstate
op_assign
id|wport-&gt;hwstate
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwstate
op_eq
id|HW_STOPPED
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;swstate = %d, hwstate = %d&bslash;n&quot;
comma
id|wport-&gt;swstate
comma
id|wport-&gt;hwstate
)paren
suffix:semicolon
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/* audio driver */
multiline_comment|/*&n; * seek on an audio device always fails.&n; */
DECL|function|vwsnd_audio_read_intr
r_static
r_void
id|vwsnd_audio_read_intr
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
r_int
r_int
id|status
)paren
(brace
r_int
id|overflown
op_assign
id|status
op_amp
id|LI_INTR_COMM1_OVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|READ_INTR_MASK
)paren
id|pcm_input
c_func
(paren
id|devc
comma
id|overflown
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|vwsnd_audio_write_intr
r_static
r_void
id|vwsnd_audio_write_intr
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
r_int
r_int
id|status
)paren
(brace
r_int
id|underflown
op_assign
id|status
op_amp
id|LI_INTR_COMM2_UNDERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|WRITE_INTR_MASK
)paren
id|pcm_output
c_func
(paren
id|devc
comma
id|underflown
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|vwsnd_audio_intr
r_static
r_void
id|vwsnd_audio_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
(paren
id|vwsnd_dev_t
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(irq=%d, dev_id=0x%p, regs=0x%p)&bslash;n&quot;
comma
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|status
op_assign
id|li_get_clear_intr_status
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
id|vwsnd_audio_read_intr
c_func
(paren
id|devc
comma
id|status
)paren
suffix:semicolon
id|vwsnd_audio_write_intr
c_func
(paren
id|devc
comma
id|status
)paren
suffix:semicolon
)brace
DECL|function|vwsnd_audio_llseek
r_static
id|loff_t
id|vwsnd_audio_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|whence
)paren
(brace
id|DBGEV
c_func
(paren
l_string|&quot;(file=0x%p, offset=%Ld, whence=%d)&bslash;n&quot;
comma
id|file
comma
id|offset
comma
id|whence
)paren
suffix:semicolon
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|function|vwsnd_audio_do_read
r_static
id|ssize_t
id|vwsnd_audio_do_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
id|file-&gt;private_data
suffix:semicolon
id|vwsnd_port_t
op_star
id|rport
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
op_amp
id|devc-&gt;rport
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|ret
comma
id|nb
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(file=0x%p, buffer=0x%p, count=%d, ppos=0x%p)&bslash;n&quot;
comma
id|file
comma
id|buffer
comma
id|count
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|rport-&gt;swbuf
op_eq
l_int|NULL
)paren
(brace
id|vwsnd_port_t
op_star
id|wport
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
ques
c_cond
op_amp
id|devc-&gt;wport
suffix:colon
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|pcm_setup
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|rport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nb
op_assign
id|swb_inc_u
c_func
(paren
id|rport
comma
l_int|0
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|DBGPV
c_func
(paren
l_string|&quot;blocking&bslash;n&quot;
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport-&gt;flags
op_amp
id|DISABLED
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|pcm_input
c_func
(paren
id|devc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* nb bytes are available in userbuf. */
r_if
c_cond
(paren
id|nb
OG
id|count
)paren
id|nb
op_assign
id|count
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;nb = %d&bslash;n&quot;
comma
id|nb
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buffer
comma
id|rport-&gt;swbuf
op_plus
id|rport-&gt;swb_u_idx
comma
id|nb
)paren
suffix:semicolon
(paren
r_void
)paren
id|swb_inc_u
c_func
(paren
id|rport
comma
id|nb
)paren
suffix:semicolon
id|buffer
op_add_assign
id|nb
suffix:semicolon
id|count
op_sub_assign
id|nb
suffix:semicolon
id|ret
op_add_assign
id|nb
suffix:semicolon
)brace
id|DBGPV
c_func
(paren
l_string|&quot;returning %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|vwsnd_audio_read
r_static
id|ssize_t
id|vwsnd_audio_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
id|ret
op_assign
id|vwsnd_audio_do_read
c_func
(paren
id|file
comma
id|buffer
comma
id|count
comma
id|ppos
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|vwsnd_audio_do_write
r_static
id|ssize_t
id|vwsnd_audio_do_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
id|file-&gt;private_data
suffix:semicolon
id|vwsnd_port_t
op_star
id|wport
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
ques
c_cond
op_amp
id|devc-&gt;wport
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|ret
comma
id|nb
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(file=0x%p, buffer=0x%p, count=%d, ppos=0x%p)&bslash;n&quot;
comma
id|file
comma
id|buffer
comma
id|count
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;swbuf
op_eq
l_int|NULL
)paren
(brace
id|vwsnd_port_t
op_star
id|rport
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
op_amp
id|devc-&gt;rport
suffix:colon
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|pcm_setup
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nb
op_assign
id|swb_inc_u
c_func
(paren
id|wport
comma
l_int|0
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;flags
op_amp
id|DISABLED
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wport-&gt;queue
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* nb bytes are available in userbuf. */
r_if
c_cond
(paren
id|nb
OG
id|count
)paren
id|nb
op_assign
id|count
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;nb = %d&bslash;n&quot;
comma
id|nb
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|wport-&gt;swbuf
op_plus
id|wport-&gt;swb_u_idx
comma
id|buffer
comma
id|nb
)paren
suffix:semicolon
id|pcm_output
c_func
(paren
id|devc
comma
l_int|0
comma
id|nb
)paren
suffix:semicolon
id|buffer
op_add_assign
id|nb
suffix:semicolon
id|count
op_sub_assign
id|nb
suffix:semicolon
id|ret
op_add_assign
id|nb
suffix:semicolon
)brace
id|DBGPV
c_func
(paren
l_string|&quot;returning %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|vwsnd_audio_write
r_static
id|ssize_t
id|vwsnd_audio_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
id|ret
op_assign
id|vwsnd_audio_do_write
c_func
(paren
id|file
comma
id|buffer
comma
id|count
comma
id|ppos
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - fine */
DECL|function|vwsnd_audio_poll
r_static
r_int
r_int
id|vwsnd_audio_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
(paren
id|vwsnd_dev_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|vwsnd_port_t
op_star
id|rport
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
op_amp
id|devc-&gt;rport
suffix:colon
l_int|NULL
suffix:semicolon
id|vwsnd_port_t
op_star
id|wport
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
ques
c_cond
op_amp
id|devc-&gt;wport
suffix:colon
l_int|NULL
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(file=0x%p, wait=0x%p)&bslash;n&quot;
comma
id|file
comma
id|wait
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rport
op_logical_or
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|rport-&gt;queue
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swb_inc_u
c_func
(paren
id|rport
comma
l_int|0
)paren
)paren
id|mask
op_or_assign
(paren
id|POLLIN
op_or
id|POLLRDNORM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wport
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|wport-&gt;queue
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;swbuf
op_eq
l_int|NULL
op_logical_or
id|swb_inc_u
c_func
(paren
id|wport
comma
l_int|0
)paren
)paren
id|mask
op_or_assign
(paren
id|POLLOUT
op_or
id|POLLWRNORM
)paren
suffix:semicolon
)brace
id|DBGPV
c_func
(paren
l_string|&quot;returning 0x%x&bslash;n&quot;
comma
id|mask
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|vwsnd_audio_do_ioctl
r_static
r_int
id|vwsnd_audio_do_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
(paren
id|vwsnd_dev_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|vwsnd_port_t
op_star
id|rport
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
ques
c_cond
op_amp
id|devc-&gt;rport
suffix:colon
l_int|NULL
suffix:semicolon
id|vwsnd_port_t
op_star
id|wport
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
ques
c_cond
op_amp
id|devc-&gt;wport
suffix:colon
l_int|NULL
suffix:semicolon
id|vwsnd_port_t
op_star
id|aport
op_assign
id|rport
ques
c_cond
id|rport
suffix:colon
id|wport
suffix:semicolon
r_struct
id|audio_buf_info
id|buf_info
suffix:semicolon
r_struct
id|count_info
id|info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ival
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(inode=0x%p, file=0x%p, cmd=0x%x, arg=0x%lx)&bslash;n&quot;
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
multiline_comment|/* _SIOR (&squot;M&squot;, 118, int) */
id|DBGX
c_func
(paren
l_string|&quot;OSS_GETVERSION&bslash;n&quot;
)paren
suffix:semicolon
id|ival
op_assign
id|SOUND_VERSION
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;,15, int) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCAPS&bslash;n&quot;
)paren
suffix:semicolon
id|ival
op_assign
id|DSP_CAP_DUPLEX
op_or
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;,11, int) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETFMTS&bslash;n&quot;
)paren
suffix:semicolon
id|ival
op_assign
(paren
id|AFMT_S16_LE
op_or
id|AFMT_MU_LAW
op_or
id|AFMT_A_LAW
op_or
id|AFMT_U8
op_or
id|AFMT_S8
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;, 2, int) */
id|DBGX
c_func
(paren
l_string|&quot;SOUND_PCM_READ_RATE&bslash;n&quot;
)paren
suffix:semicolon
id|ival
op_assign
id|aport-&gt;sw_framerate
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;, 6, int) */
id|DBGX
c_func
(paren
l_string|&quot;SOUND_PCM_READ_CHANNELS&bslash;n&quot;
)paren
suffix:semicolon
id|ival
op_assign
id|aport-&gt;sw_channels
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;, 2, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
)paren
(brace
r_if
c_cond
(paren
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
(brace
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED failed: swstate = %d&bslash;n&quot;
comma
id|aport-&gt;swstate
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ival
OL
id|MIN_SPEED
)paren
id|ival
op_assign
id|MIN_SPEED
suffix:semicolon
r_if
c_cond
(paren
id|ival
OG
id|MAX_SPEED
)paren
id|ival
op_assign
id|MAX_SPEED
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
id|rport-&gt;sw_framerate
op_assign
id|ival
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
id|wport-&gt;sw_framerate
op_assign
id|ival
suffix:semicolon
)brace
r_else
id|ival
op_assign
id|aport-&gt;sw_framerate
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;, 3, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_STEREO %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
op_ne
l_int|0
op_logical_and
id|ival
op_ne
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
id|rport-&gt;sw_channels
op_assign
id|ival
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
id|wport-&gt;sw_channels
op_assign
id|ival
op_plus
l_int|1
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;, 6, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_CHANNELS %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
op_ne
l_int|1
op_logical_and
id|ival
op_ne
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
id|rport-&gt;sw_channels
op_assign
id|ival
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
id|wport-&gt;sw_channels
op_assign
id|ival
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;, 4, int) */
id|ival
op_assign
id|pcm_setup
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
OL
l_int|0
)paren
(brace
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE failed, errno %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_return
id|ival
suffix:semicolon
)brace
id|ival
op_assign
l_int|1
op_lshift
id|aport-&gt;sw_fragshift
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE returning %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;,10, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT %d:%d&bslash;n&quot;
comma
id|ival
op_rshift
l_int|16
comma
id|ival
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(brace
r_int
id|sw_fragshift
op_assign
id|ival
op_amp
l_int|0xFFFF
suffix:semicolon
r_int
id|sw_subdivshift
op_assign
id|aport-&gt;sw_subdivshift
suffix:semicolon
r_int
id|hw_fragshift
op_assign
id|sw_fragshift
op_minus
id|sw_subdivshift
suffix:semicolon
r_int
id|sw_fragcount
op_assign
(paren
id|ival
op_rshift
l_int|16
)paren
op_amp
l_int|0xFFFF
suffix:semicolon
r_int
id|hw_fragsize
suffix:semicolon
r_if
c_cond
(paren
id|hw_fragshift
OL
id|MIN_FRAGSHIFT
)paren
id|hw_fragshift
op_assign
id|MIN_FRAGSHIFT
suffix:semicolon
r_if
c_cond
(paren
id|hw_fragshift
OG
id|MAX_FRAGSHIFT
)paren
id|hw_fragshift
op_assign
id|MAX_FRAGSHIFT
suffix:semicolon
id|sw_fragshift
op_assign
id|hw_fragshift
op_plus
id|aport-&gt;sw_subdivshift
suffix:semicolon
id|hw_fragsize
op_assign
l_int|1
op_lshift
id|hw_fragshift
suffix:semicolon
r_if
c_cond
(paren
id|sw_fragcount
OL
id|MIN_FRAGCOUNT
c_func
(paren
id|hw_fragsize
)paren
)paren
id|sw_fragcount
op_assign
id|MIN_FRAGCOUNT
c_func
(paren
id|hw_fragsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sw_fragcount
OG
id|MAX_FRAGCOUNT
c_func
(paren
id|hw_fragsize
)paren
)paren
id|sw_fragcount
op_assign
id|MAX_FRAGCOUNT
c_func
(paren
id|hw_fragsize
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;sw_fragshift = %d&bslash;n&quot;
comma
id|sw_fragshift
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;rport = 0x%p, wport = 0x%p&bslash;n&quot;
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
(brace
id|rport-&gt;sw_fragshift
op_assign
id|sw_fragshift
suffix:semicolon
id|rport-&gt;sw_fragcount
op_assign
id|sw_fragcount
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wport
)paren
(brace
id|wport-&gt;sw_fragshift
op_assign
id|sw_fragshift
suffix:semicolon
id|wport-&gt;sw_fragcount
op_assign
id|sw_fragcount
suffix:semicolon
)brace
id|ival
op_assign
id|sw_fragcount
op_lshift
l_int|16
op_or
id|sw_fragshift
suffix:semicolon
)brace
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT returns %d:%d&bslash;n&quot;
comma
id|ival
op_rshift
l_int|16
comma
id|ival
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;, 9, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SUBDIVIDE %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(brace
r_int
id|subdivshift
suffix:semicolon
r_int
id|hw_fragshift
comma
id|hw_fragsize
comma
id|hw_fragcount
suffix:semicolon
r_switch
c_cond
(paren
id|ival
)paren
(brace
r_case
l_int|1
suffix:colon
id|subdivshift
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|subdivshift
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|subdivshift
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|hw_fragshift
op_assign
id|aport-&gt;sw_fragshift
op_minus
id|subdivshift
suffix:semicolon
r_if
c_cond
(paren
id|hw_fragshift
template_param
id|MAX_FRAGSHIFT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|hw_fragsize
op_assign
l_int|1
op_lshift
id|hw_fragshift
suffix:semicolon
id|hw_fragcount
op_assign
id|aport-&gt;sw_fragcount
op_rshift
id|subdivshift
suffix:semicolon
r_if
c_cond
(paren
id|hw_fragcount
template_param
id|MAX_FRAGCOUNT
c_func
(paren
id|hw_fragsize
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
id|rport-&gt;sw_subdivshift
op_assign
id|subdivshift
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
id|wport-&gt;sw_subdivshift
op_assign
id|subdivshift
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* _SIOWR(&squot;P&squot;,5, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFMT %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
op_ne
id|AFMT_QUERY
)paren
(brace
r_if
c_cond
(paren
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
(brace
id|DBGP
c_func
(paren
l_string|&quot;SETFMT failed, swstate = %d&bslash;n&quot;
comma
id|aport-&gt;swstate
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ival
)paren
(brace
r_case
id|AFMT_MU_LAW
suffix:colon
r_case
id|AFMT_A_LAW
suffix:colon
r_case
id|AFMT_U8
suffix:colon
r_case
id|AFMT_S8
suffix:colon
r_case
id|AFMT_S16_LE
suffix:colon
r_if
c_cond
(paren
id|rport
)paren
id|rport-&gt;sw_samplefmt
op_assign
id|ival
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
id|wport-&gt;sw_samplefmt
op_assign
id|ival
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|ival
op_assign
id|aport-&gt;sw_samplefmt
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;,12, audio_buf_info) */
id|DBGXV
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ival
op_assign
id|pcm_setup
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
OL
l_int|0
)paren
r_return
id|ival
suffix:semicolon
id|ival
op_assign
id|swb_inc_u
c_func
(paren
id|wport
comma
l_int|0
)paren
suffix:semicolon
id|buf_info.fragments
op_assign
id|ival
op_rshift
id|wport-&gt;sw_fragshift
suffix:semicolon
id|buf_info.fragstotal
op_assign
id|wport-&gt;sw_fragcount
suffix:semicolon
id|buf_info.fragsize
op_assign
l_int|1
op_lshift
id|wport-&gt;sw_fragshift
suffix:semicolon
id|buf_info.bytes
op_assign
id|ival
suffix:semicolon
id|DBGXV
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE returns { %d %d %d %d }&bslash;n&quot;
comma
id|buf_info.fragments
comma
id|buf_info.fragstotal
comma
id|buf_info.fragsize
comma
id|buf_info.bytes
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf_info
comma
r_sizeof
id|buf_info
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;,13, audio_buf_info) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ival
op_assign
id|pcm_setup
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
OL
l_int|0
)paren
r_return
id|ival
suffix:semicolon
id|ival
op_assign
id|swb_inc_u
c_func
(paren
id|rport
comma
l_int|0
)paren
suffix:semicolon
id|buf_info.fragments
op_assign
id|ival
op_rshift
id|rport-&gt;sw_fragshift
suffix:semicolon
id|buf_info.fragstotal
op_assign
id|rport-&gt;sw_fragcount
suffix:semicolon
id|buf_info.fragsize
op_assign
l_int|1
op_lshift
id|rport-&gt;sw_fragshift
suffix:semicolon
id|buf_info.bytes
op_assign
id|ival
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE returns { %d %d %d %d }&bslash;n&quot;
comma
id|buf_info.fragments
comma
id|buf_info.fragstotal
comma
id|buf_info.fragsize
comma
id|buf_info.bytes
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf_info
comma
r_sizeof
id|buf_info
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
multiline_comment|/* _SIO  (&squot;P&squot;,14) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_NONBLOCK&bslash;n&quot;
)paren
suffix:semicolon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
multiline_comment|/* _SIO  (&squot;P&squot;, 0) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_RESET&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Nothing special needs to be done for input.  Input&n;&t;&t; * samples sit in swbuf, but it will be reinitialized&n;&t;&t; * to empty when pcm_setup() is called.&n;&t;&t; */
r_if
c_cond
(paren
id|wport
op_logical_and
id|wport-&gt;swbuf
)paren
(brace
id|wport-&gt;swstate
op_assign
id|SW_INITIAL
suffix:semicolon
id|pcm_output
c_func
(paren
id|devc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|pcm_write_sync
c_func
(paren
id|devc
)paren
suffix:semicolon
)brace
id|pcm_shutdown
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
multiline_comment|/* _SIO  (&squot;P&squot;, 1) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SYNC&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
(brace
id|pcm_flush_frag
c_func
(paren
id|devc
)paren
suffix:semicolon
id|pcm_write_sync
c_func
(paren
id|devc
)paren
suffix:semicolon
)brace
id|pcm_shutdown
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/* _SIO  (&squot;P&squot;, 8) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_POST&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pcm_flush_frag
c_func
(paren
id|devc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;, 17, count_info) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETIPTR&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|ustmsc_t
id|ustmsc
suffix:semicolon
r_if
c_cond
(paren
id|rport-&gt;hwstate
op_eq
id|HW_RUNNING
)paren
(brace
id|ASSERT
c_func
(paren
id|rport-&gt;swstate
op_eq
id|SW_RUN
)paren
suffix:semicolon
id|li_read_USTMSC
c_func
(paren
op_amp
id|rport-&gt;chan
comma
op_amp
id|ustmsc
)paren
suffix:semicolon
id|info.bytes
op_assign
id|ustmsc.msc
op_minus
id|rport-&gt;MSC_offset
suffix:semicolon
id|info.bytes
op_mul_assign
id|rport-&gt;frame_size
suffix:semicolon
)brace
r_else
(brace
id|info.bytes
op_assign
id|rport-&gt;byte_count
suffix:semicolon
)brace
id|info.blocks
op_assign
id|rport-&gt;frag_count
suffix:semicolon
id|info.ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not implemented */
id|rport-&gt;frag_count
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
id|info
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;,18, count_info) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOPTR&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|ustmsc_t
id|ustmsc
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;hwstate
op_eq
id|HW_RUNNING
)paren
(brace
id|ASSERT
c_func
(paren
id|wport-&gt;swstate
op_eq
id|SW_RUN
)paren
suffix:semicolon
id|li_read_USTMSC
c_func
(paren
op_amp
id|wport-&gt;chan
comma
op_amp
id|ustmsc
)paren
suffix:semicolon
id|info.bytes
op_assign
id|ustmsc.msc
op_minus
id|wport-&gt;MSC_offset
suffix:semicolon
id|info.bytes
op_mul_assign
id|wport-&gt;frame_size
suffix:semicolon
)brace
r_else
(brace
id|info.bytes
op_assign
id|wport-&gt;byte_count
suffix:semicolon
)brace
id|info.blocks
op_assign
id|wport-&gt;frag_count
suffix:semicolon
id|info.ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not implemented */
id|wport-&gt;frag_count
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
id|info
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;, 23, int) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETODELAY&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wport
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
r_int
id|fsize
op_assign
id|wport-&gt;frame_size
suffix:semicolon
id|ival
op_assign
id|wport-&gt;swb_i_avail
op_div
id|fsize
suffix:semicolon
r_if
c_cond
(paren
id|wport-&gt;hwstate
op_eq
id|HW_RUNNING
)paren
(brace
r_int
id|swptr
comma
id|hwptr
comma
id|hwframes
comma
id|hwbytes
comma
id|hwsize
suffix:semicolon
r_int
id|totalhwbytes
suffix:semicolon
id|ustmsc_t
id|ustmsc
suffix:semicolon
id|hwsize
op_assign
id|wport-&gt;hwbuf_size
suffix:semicolon
id|swptr
op_assign
id|li_read_swptr
c_func
(paren
op_amp
id|wport-&gt;chan
)paren
suffix:semicolon
id|li_read_USTMSC
c_func
(paren
op_amp
id|wport-&gt;chan
comma
op_amp
id|ustmsc
)paren
suffix:semicolon
id|hwframes
op_assign
id|ustmsc.msc
op_minus
id|wport-&gt;MSC_offset
suffix:semicolon
id|totalhwbytes
op_assign
id|hwframes
op_star
id|fsize
suffix:semicolon
id|hwptr
op_assign
id|totalhwbytes
op_mod
id|hwsize
suffix:semicolon
id|hwbytes
op_assign
(paren
id|swptr
op_minus
id|hwptr
op_plus
id|hwsize
)paren
op_mod
id|hwsize
suffix:semicolon
id|ival
op_add_assign
id|hwbytes
op_div
id|fsize
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_PROFILE
suffix:colon
multiline_comment|/* _SIOW (&squot;P&squot;, 23, int) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_PROFILE&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Thomas Sailer explains SNDCTL_DSP_PROFILE&n;&t;&t; * (private email, March 24, 1999):&n;&t;&t; *&n;&t;&t; *     This gives the sound driver a hint on what it&n;&t;&t; *     should do with partial fragments&n;&t;&t; *     (i.e. fragments partially filled with write).&n;&t;&t; *     This can direct the driver to zero them or&n;&t;&t; *     leave them alone.  But don&squot;t ask me what this&n;&t;&t; *     is good for, my driver just zeroes the last&n;&t;&t; *     fragment before the receiver stops, no idea&n;&t;&t; *     what good for any other behaviour could&n;&t;&t; *     be. Implementing it as NOP seems safe.&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
multiline_comment|/* _SIOR (&squot;P&squot;,16, int) */
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETTRIGGER&bslash;n&quot;
)paren
suffix:semicolon
id|ival
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rport-&gt;flags
op_amp
id|DISABLED
)paren
)paren
id|ival
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wport
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|wport-&gt;flags
op_amp
id|DISABLED
)paren
)paren
id|ival
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
multiline_comment|/* _SIOW (&squot;P&squot;,16, int) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DBGX
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETTRIGGER %d&bslash;n&quot;
comma
id|ival
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If user is disabling I/O and port is not in initial&n;&t;&t; * state, fail with EINVAL.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rport
op_logical_and
op_logical_neg
(paren
id|ival
op_amp
id|PCM_ENABLE_INPUT
)paren
)paren
op_logical_or
(paren
id|wport
op_logical_and
op_logical_neg
(paren
id|ival
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
)paren
op_logical_and
id|aport-&gt;swstate
op_ne
id|SW_INITIAL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
(brace
id|vwsnd_port_hwstate_t
id|hwstate
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|hwstate
op_assign
id|rport-&gt;hwstate
suffix:semicolon
r_if
c_cond
(paren
id|ival
op_amp
id|PCM_ENABLE_INPUT
)paren
id|rport-&gt;flags
op_and_assign
op_complement
id|DISABLED
suffix:semicolon
r_else
id|rport-&gt;flags
op_or_assign
id|DISABLED
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwstate
op_ne
id|HW_RUNNING
op_logical_and
id|ival
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
id|rport-&gt;swstate
op_eq
id|SW_INITIAL
)paren
id|pcm_setup
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_else
id|li_activate_dma
c_func
(paren
op_amp
id|rport-&gt;chan
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wport
)paren
(brace
id|vwsnd_port_flags_t
id|pflags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|pflags
op_assign
id|wport-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|ival
op_amp
id|PCM_ENABLE_OUTPUT
)paren
id|wport-&gt;flags
op_and_assign
op_complement
id|DISABLED
suffix:semicolon
r_else
id|wport-&gt;flags
op_or_assign
id|DISABLED
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|wport-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pflags
op_amp
id|DISABLED
op_logical_and
id|ival
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
id|wport-&gt;swstate
op_eq
id|SW_RUN
)paren
id|pcm_output
c_func
(paren
id|devc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|DBGP
c_func
(paren
l_string|&quot;unknown ioctl 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DBGP
c_func
(paren
l_string|&quot;unimplemented ioctl 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|vwsnd_audio_ioctl
r_static
r_int
id|vwsnd_audio_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
(paren
id|vwsnd_dev_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
id|ret
op_assign
id|vwsnd_audio_do_ioctl
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No mmap. */
DECL|function|vwsnd_audio_mmap
r_static
r_int
id|vwsnd_audio_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|DBGE
c_func
(paren
l_string|&quot;(file=0x%p, vma=0x%p)&bslash;n&quot;
comma
id|file
comma
id|vma
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the audio device for read and/or write.&n; *&n; * Returns 0 on success, -errno on failure.&n; */
DECL|function|vwsnd_audio_open
r_static
r_int
id|vwsnd_audio_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
suffix:semicolon
id|dev_t
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|sw_samplefmt
suffix:semicolon
id|DBGE
c_func
(paren
l_string|&quot;(inode=0x%p, file=0x%p)&bslash;n&quot;
comma
id|inode
comma
id|file
)paren
suffix:semicolon
id|INC_USE_COUNT
suffix:semicolon
r_for
c_loop
(paren
id|devc
op_assign
id|vwsnd_dev_list
suffix:semicolon
id|devc
suffix:semicolon
id|devc
op_assign
id|devc-&gt;next_dev
)paren
r_if
c_cond
(paren
(paren
id|devc-&gt;audio_minor
op_amp
op_complement
l_int|0x0F
)paren
op_eq
(paren
id|minor
op_amp
op_complement
l_int|0x0F
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|devc
op_eq
l_int|NULL
)paren
(brace
id|DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|devc-&gt;open_sema
)paren
suffix:semicolon
r_while
c_loop
(paren
id|devc-&gt;open_mode
op_amp
id|file-&gt;f_mode
)paren
(brace
id|up
c_func
(paren
op_amp
id|devc-&gt;open_sema
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|devc-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|devc-&gt;open_sema
)paren
suffix:semicolon
)brace
id|devc-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|devc-&gt;open_sema
)paren
suffix:semicolon
multiline_comment|/* get default sample format from minor number. */
id|sw_samplefmt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0xF
)paren
op_eq
id|SND_DEV_DSP
)paren
id|sw_samplefmt
op_assign
id|AFMT_U8
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0xF
)paren
op_eq
id|SND_DEV_AUDIO
)paren
id|sw_samplefmt
op_assign
id|AFMT_MU_LAW
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0xF
)paren
op_eq
id|SND_DEV_DSP16
)paren
id|sw_samplefmt
op_assign
id|AFMT_S16_LE
suffix:semicolon
r_else
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Initialize vwsnd_ports. */
id|down
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|devc-&gt;rport.swstate
op_assign
id|SW_INITIAL
suffix:semicolon
id|devc-&gt;rport.flags
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;rport.sw_channels
op_assign
l_int|1
suffix:semicolon
id|devc-&gt;rport.sw_samplefmt
op_assign
id|sw_samplefmt
suffix:semicolon
id|devc-&gt;rport.sw_framerate
op_assign
l_int|8000
suffix:semicolon
id|devc-&gt;rport.sw_fragshift
op_assign
id|DEFAULT_FRAGSHIFT
suffix:semicolon
id|devc-&gt;rport.sw_fragcount
op_assign
id|DEFAULT_FRAGCOUNT
suffix:semicolon
id|devc-&gt;rport.sw_subdivshift
op_assign
id|DEFAULT_SUBDIVSHIFT
suffix:semicolon
id|devc-&gt;rport.byte_count
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;rport.frag_count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|devc-&gt;wport.swstate
op_assign
id|SW_INITIAL
suffix:semicolon
id|devc-&gt;wport.flags
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;wport.sw_channels
op_assign
l_int|1
suffix:semicolon
id|devc-&gt;wport.sw_samplefmt
op_assign
id|sw_samplefmt
suffix:semicolon
id|devc-&gt;wport.sw_framerate
op_assign
l_int|8000
suffix:semicolon
id|devc-&gt;wport.sw_fragshift
op_assign
id|DEFAULT_FRAGSHIFT
suffix:semicolon
id|devc-&gt;wport.sw_fragcount
op_assign
id|DEFAULT_FRAGCOUNT
suffix:semicolon
id|devc-&gt;wport.sw_subdivshift
op_assign
id|DEFAULT_SUBDIVSHIFT
suffix:semicolon
id|devc-&gt;wport.byte_count
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;wport.frag_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|devc
suffix:semicolon
id|DBGRV
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release (close) the audio device.&n; */
DECL|function|vwsnd_audio_release
r_static
r_int
id|vwsnd_audio_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
(paren
id|vwsnd_dev_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|vwsnd_port_t
op_star
id|wport
op_assign
l_int|NULL
comma
op_star
id|rport
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
(brace
id|DBGEV
c_func
(paren
l_string|&quot;(inode=0x%p, file=0x%p)&bslash;n&quot;
comma
id|inode
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|rport
op_assign
op_amp
id|devc-&gt;rport
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|wport
op_assign
op_amp
id|devc-&gt;wport
suffix:semicolon
id|pcm_flush_frag
c_func
(paren
id|devc
)paren
suffix:semicolon
id|pcm_write_sync
c_func
(paren
id|devc
)paren
suffix:semicolon
)brace
id|pcm_shutdown
c_func
(paren
id|devc
comma
id|rport
comma
id|wport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rport
)paren
id|rport-&gt;swstate
op_assign
id|SW_OFF
suffix:semicolon
r_if
c_cond
(paren
id|wport
)paren
id|wport-&gt;swstate
op_assign
id|SW_OFF
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|devc-&gt;io_sema
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|devc-&gt;open_sema
)paren
suffix:semicolon
(brace
id|devc-&gt;open_mode
op_and_assign
op_complement
id|file-&gt;f_mode
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|devc-&gt;open_sema
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|devc-&gt;open_wait
)paren
suffix:semicolon
id|DEC_USE_COUNT
suffix:semicolon
id|DBGR
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|vwsnd_audio_fops
r_static
r_struct
id|file_operations
id|vwsnd_audio_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|vwsnd_audio_llseek
comma
id|read
suffix:colon
id|vwsnd_audio_read
comma
id|write
suffix:colon
id|vwsnd_audio_write
comma
id|poll
suffix:colon
id|vwsnd_audio_poll
comma
id|ioctl
suffix:colon
id|vwsnd_audio_ioctl
comma
id|mmap
suffix:colon
id|vwsnd_audio_mmap
comma
id|open
suffix:colon
id|vwsnd_audio_open
comma
id|release
suffix:colon
id|vwsnd_audio_release
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/* mixer driver */
multiline_comment|/* open the mixer device. */
DECL|function|vwsnd_mixer_open
r_static
r_int
id|vwsnd_mixer_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(inode=0x%p, file=0x%p)&bslash;n&quot;
comma
id|inode
comma
id|file
)paren
suffix:semicolon
id|INC_USE_COUNT
suffix:semicolon
r_for
c_loop
(paren
id|devc
op_assign
id|vwsnd_dev_list
suffix:semicolon
id|devc
suffix:semicolon
id|devc
op_assign
id|devc-&gt;next_dev
)paren
r_if
c_cond
(paren
id|devc-&gt;mixer_minor
op_eq
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|devc
op_eq
l_int|NULL
)paren
(brace
id|DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|file-&gt;private_data
op_assign
id|devc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* release (close) the mixer device. */
DECL|function|vwsnd_mixer_release
r_static
r_int
id|vwsnd_mixer_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|DBGEV
c_func
(paren
l_string|&quot;(inode=0x%p, file=0x%p)&bslash;n&quot;
comma
id|inode
comma
id|file
)paren
suffix:semicolon
id|DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* seek is illegal on mixer. */
DECL|function|vwsnd_mixer_llseek
r_static
id|loff_t
id|vwsnd_mixer_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|whence
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* mixer_read_ioctl handles all read ioctls on the mixer device. */
DECL|function|mixer_read_ioctl
r_static
r_int
id|mixer_read_ioctl
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
r_int
r_int
id|nr
comma
id|caddr_t
id|arg
)paren
(brace
r_int
id|val
op_assign
op_minus
l_int|1
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, nr=0x%x, arg=0x%p)&bslash;n&quot;
comma
id|devc
comma
id|nr
comma
id|arg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
id|SOUND_MIXER_CAPS
suffix:colon
id|val
op_assign
id|SOUND_CAP_EXCL_INPUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
id|val
op_assign
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_RECLEV
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
id|val
op_assign
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_RECLEV
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_OUTMASK
suffix:colon
id|val
op_assign
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
id|val
op_assign
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PCM
suffix:colon
id|val
op_assign
id|ad1843_get_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_PCM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_LINE
suffix:colon
id|val
op_assign
id|ad1843_get_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_LINE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
id|val
op_assign
id|ad1843_get_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_MIC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CD
suffix:colon
id|val
op_assign
id|ad1843_get_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_CD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
id|val
op_assign
id|ad1843_get_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_RECLEV
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|val
op_assign
id|ad1843_get_recsrc
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_OUTSRC
suffix:colon
id|val
op_assign
id|ad1843_get_outsrc
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* mixer_write_ioctl handles all write ioctls on the mixer device. */
DECL|function|mixer_write_ioctl
r_static
r_int
id|mixer_write_ioctl
c_func
(paren
id|vwsnd_dev_t
op_star
id|devc
comma
r_int
r_int
id|nr
comma
id|caddr_t
id|arg
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|err
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, nr=0x%x, arg=0x%p)&bslash;n&quot;
comma
id|devc
comma
id|nr
comma
id|arg
)paren
suffix:semicolon
id|err
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
id|SOUND_MIXER_PCM
suffix:colon
id|val
op_assign
id|ad1843_set_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_PCM
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_LINE
suffix:colon
id|val
op_assign
id|ad1843_set_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_LINE
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
id|val
op_assign
id|ad1843_set_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_MIC
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CD
suffix:colon
id|val
op_assign
id|ad1843_set_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_CD
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
id|val
op_assign
id|ad1843_set_gain
c_func
(paren
op_amp
id|devc-&gt;lith
comma
op_amp
id|ad1843_gain_RECLEV
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
r_if
c_cond
(paren
id|devc-&gt;rport.swbuf
op_logical_or
id|devc-&gt;wport.swbuf
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* can&squot;t change recsrc while running */
id|val
op_assign
id|ad1843_set_recsrc
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_OUTSRC
suffix:colon
id|val
op_assign
id|ad1843_set_outsrc
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OL
l_int|0
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* This is the ioctl entry to the mixer driver. */
DECL|function|vwsnd_mixer_ioctl
r_static
r_int
id|vwsnd_mixer_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ioctl
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
(paren
id|vwsnd_dev_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_const
r_int
r_int
id|nrmask
op_assign
id|_IOC_NRMASK
op_lshift
id|_IOC_NRSHIFT
suffix:semicolon
r_const
r_int
r_int
id|nr
op_assign
(paren
id|cmd
op_amp
id|nrmask
)paren
op_rshift
id|_IOC_NRSHIFT
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(devc=0x%p, cmd=0x%x, arg=0x%lx)&bslash;n&quot;
comma
id|devc
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|devc-&gt;mix_sema
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
(paren
id|cmd
op_amp
op_complement
id|nrmask
)paren
op_eq
id|MIXER_READ
c_func
(paren
l_int|0
)paren
)paren
id|retval
op_assign
id|mixer_read_ioctl
c_func
(paren
id|devc
comma
id|nr
comma
(paren
id|caddr_t
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cmd
op_amp
op_complement
id|nrmask
)paren
op_eq
id|MIXER_WRITE
c_func
(paren
l_int|0
)paren
)paren
id|retval
op_assign
id|mixer_write_ioctl
c_func
(paren
id|devc
comma
id|nr
comma
(paren
id|caddr_t
)paren
id|arg
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|devc-&gt;mix_sema
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|vwsnd_mixer_fops
r_static
r_struct
id|file_operations
id|vwsnd_mixer_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|vwsnd_mixer_llseek
comma
id|ioctl
suffix:colon
id|vwsnd_mixer_ioctl
comma
id|open
suffix:colon
id|vwsnd_mixer_open
comma
id|release
suffix:colon
id|vwsnd_mixer_release
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/* probe/attach/unload */
multiline_comment|/* driver probe routine.  Return nonzero if hardware is found. */
DECL|function|probe_vwsnd
r_static
r_int
id|__init
id|probe_vwsnd
c_func
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
id|lithium_t
id|lith
suffix:semicolon
r_int
id|w
suffix:semicolon
r_int
r_int
id|later
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(hw_config=0x%p)&bslash;n&quot;
comma
id|hw_config
)paren
suffix:semicolon
multiline_comment|/* XXX verify lithium present (to prevent crash on non-vw) */
r_if
c_cond
(paren
id|li_create
c_func
(paren
op_amp
id|lith
comma
id|hw_config-&gt;io_base
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;probe_vwsnd: can&squot;t map lithium&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|later
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
id|li_writel
c_func
(paren
op_amp
id|lith
comma
id|LI_HOST_CONTROLLER
comma
id|LI_HC_LINK_ENABLE
)paren
suffix:semicolon
r_do
(brace
id|w
op_assign
id|li_readl
c_func
(paren
op_amp
id|lith
comma
id|LI_HOST_CONTROLLER
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|w
op_eq
id|LI_HC_LINK_ENABLE
op_logical_and
id|jiffies
OL
id|later
)paren
suffix:semicolon
id|li_destroy
c_func
(paren
op_amp
id|lith
)paren
suffix:semicolon
id|DBGPV
c_func
(paren
l_string|&quot;HC = 0x%04x&bslash;n&quot;
comma
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|w
op_eq
id|LI_HC_LINK_ENABLE
)paren
op_logical_or
(paren
id|w
op_amp
id|LI_HC_LINK_CODEC
)paren
)paren
(brace
multiline_comment|/* This may indicate a beta machine with no audio,&n;&t;&t; * or a future machine with different audio.&n;&t;&t; * On beta-release 320 w/ no audio, HC == 0x4000 */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;probe_vwsnd: audio codec not found&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|w
op_amp
id|LI_HC_LINK_FAILURE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;probe_vwsnd: can&squot;t init audio codec&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;probe_vwsnd: lithium audio found&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * driver attach routine.  Initialize driver data structures and&n; * initialize hardware.  A new vwsnd_dev_t is allocated and put&n; * onto the global list, vwsnd_dev_list.&n; *&n; * Return +minor_dev on success, -errno on failure.&n; */
DECL|function|attach_vwsnd
r_static
r_int
id|__init
id|attach_vwsnd
c_func
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|DBGEV
c_func
(paren
l_string|&quot;(hw_config=0x%p)&bslash;n&quot;
comma
id|hw_config
)paren
suffix:semicolon
id|devc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|vwsnd_dev_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devc
op_eq
l_int|NULL
)paren
r_goto
id|fail0
suffix:semicolon
id|err
op_assign
id|li_create
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|hw_config-&gt;io_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fail1
suffix:semicolon
id|init_waitqueue
c_func
(paren
op_amp
id|devc-&gt;open_wait
)paren
suffix:semicolon
id|devc-&gt;rport.hwbuf_size
op_assign
id|HWBUF_SIZE
suffix:semicolon
id|devc-&gt;rport.hwbuf_vaddr
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|HWBUF_ORDER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devc-&gt;rport.hwbuf_vaddr
)paren
r_goto
id|fail2
suffix:semicolon
id|devc-&gt;rport.hwbuf
op_assign
(paren
id|caddr_t
)paren
id|devc-&gt;rport.hwbuf_vaddr
suffix:semicolon
id|devc-&gt;rport.hwbuf_paddr
op_assign
id|virt_to_phys
c_func
(paren
id|devc-&gt;rport.hwbuf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Quote from the NT driver:&n;&t; *&n;&t; * // WARNING!!! HACK to setup output dma!!!&n;&t; * // This is required because even on output there is some data&n;&t; * // trickling into the input DMA channel.  This is a bug in the&n;&t; * // Lithium microcode.&n;&t; * // --sde&n;&t; *&n;&t; * We set the input side&squot;s DMA base address here.  It will remain&n;&t; * valid until the driver is unloaded.&n;&t; */
id|li_writel
c_func
(paren
op_amp
id|devc-&gt;lith
comma
id|LI_COMM1_BASE
comma
id|devc-&gt;rport.hwbuf_paddr
op_rshift
l_int|8
op_or
l_int|1
op_lshift
(paren
l_int|37
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|devc-&gt;wport.hwbuf_size
op_assign
id|HWBUF_SIZE
suffix:semicolon
id|devc-&gt;wport.hwbuf_vaddr
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|HWBUF_ORDER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devc-&gt;wport.hwbuf_vaddr
)paren
r_goto
id|fail3
suffix:semicolon
id|devc-&gt;wport.hwbuf
op_assign
(paren
id|caddr_t
)paren
id|devc-&gt;wport.hwbuf_vaddr
suffix:semicolon
id|devc-&gt;wport.hwbuf_paddr
op_assign
id|virt_to_phys
c_func
(paren
id|devc-&gt;wport.hwbuf
)paren
suffix:semicolon
id|DBGP
c_func
(paren
l_string|&quot;wport hwbuf = 0x%p&bslash;n&quot;
comma
id|devc-&gt;wport.hwbuf
)paren
suffix:semicolon
id|DBGDO
c_func
(paren
id|shut_up
op_increment
)paren
suffix:semicolon
id|err
op_assign
id|ad1843_init
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
id|DBGDO
c_func
(paren
id|shut_up
op_decrement
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fail4
suffix:semicolon
multiline_comment|/* install interrupt handler */
id|err
op_assign
id|request_irq
c_func
(paren
id|hw_config-&gt;irq
comma
id|vwsnd_audio_intr
comma
l_int|0
comma
l_string|&quot;vwsnd&quot;
comma
id|devc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fail5
suffix:semicolon
multiline_comment|/* register this device&squot;s drivers. */
id|devc-&gt;audio_minor
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|vwsnd_audio_fops
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|devc-&gt;audio_minor
)paren
OL
l_int|0
)paren
(brace
id|DBGDO
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;attach_vwsnd: register_sound_dsp error %d&bslash;n&quot;
comma
id|err
)paren
)paren
suffix:semicolon
r_goto
id|fail6
suffix:semicolon
)brace
id|devc-&gt;mixer_minor
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|vwsnd_mixer_fops
comma
id|devc-&gt;audio_minor
op_rshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|devc-&gt;mixer_minor
)paren
OL
l_int|0
)paren
(brace
id|DBGDO
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;attach_vwsnd: register_sound_mixer error %d&bslash;n&quot;
comma
id|err
)paren
)paren
suffix:semicolon
r_goto
id|fail7
suffix:semicolon
)brace
multiline_comment|/* Squirrel away device indices for unload routine. */
id|hw_config-&gt;slots
(braket
l_int|0
)braket
op_assign
id|devc-&gt;audio_minor
suffix:semicolon
multiline_comment|/* Initialize as much of *devc as possible */
id|devc-&gt;open_sema
op_assign
id|MUTEX
suffix:semicolon
id|devc-&gt;io_sema
op_assign
id|MUTEX
suffix:semicolon
id|devc-&gt;mix_sema
op_assign
id|MUTEX
suffix:semicolon
id|devc-&gt;open_mode
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;rport.lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue
c_func
(paren
op_amp
id|devc-&gt;rport.queue
)paren
suffix:semicolon
id|devc-&gt;rport.swstate
op_assign
id|SW_OFF
suffix:semicolon
id|devc-&gt;rport.hwstate
op_assign
id|HW_STOPPED
suffix:semicolon
id|devc-&gt;rport.flags
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;rport.swbuf
op_assign
l_int|NULL
suffix:semicolon
id|devc-&gt;wport.lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue
c_func
(paren
op_amp
id|devc-&gt;wport.queue
)paren
suffix:semicolon
id|devc-&gt;wport.swstate
op_assign
id|SW_OFF
suffix:semicolon
id|devc-&gt;wport.hwstate
op_assign
id|HW_STOPPED
suffix:semicolon
id|devc-&gt;wport.flags
op_assign
l_int|0
suffix:semicolon
id|devc-&gt;wport.swbuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Success.  Link us onto the local device list. */
id|devc-&gt;next_dev
op_assign
id|vwsnd_dev_list
suffix:semicolon
id|vwsnd_dev_list
op_assign
id|devc
suffix:semicolon
r_return
id|devc-&gt;audio_minor
suffix:semicolon
multiline_comment|/* So many ways to fail.  Undo what we did. */
id|fail7
suffix:colon
id|unregister_sound_dsp
c_func
(paren
id|devc-&gt;audio_minor
)paren
suffix:semicolon
id|fail6
suffix:colon
id|free_irq
c_func
(paren
id|hw_config-&gt;irq
comma
id|devc
)paren
suffix:semicolon
id|fail5
suffix:colon
id|fail4
suffix:colon
id|free_pages
c_func
(paren
id|devc-&gt;wport.hwbuf_vaddr
comma
id|HWBUF_ORDER
)paren
suffix:semicolon
id|fail3
suffix:colon
id|free_pages
c_func
(paren
id|devc-&gt;rport.hwbuf_vaddr
comma
id|HWBUF_ORDER
)paren
suffix:semicolon
id|fail2
suffix:colon
id|li_destroy
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
id|fail1
suffix:colon
id|kfree
c_func
(paren
id|devc
)paren
suffix:semicolon
id|fail0
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|unload_vwsnd
r_static
r_int
id|__exit
id|unload_vwsnd
c_func
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
id|vwsnd_dev_t
op_star
id|devc
comma
op_star
op_star
id|devcp
suffix:semicolon
id|DBGE
c_func
(paren
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|devcp
op_assign
op_amp
id|vwsnd_dev_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|devc
op_assign
op_star
id|devcp
)paren
)paren
(brace
r_if
c_cond
(paren
id|devc-&gt;audio_minor
op_eq
id|hw_config-&gt;slots
(braket
l_int|0
)braket
)paren
(brace
op_star
id|devcp
op_assign
id|devc-&gt;next_dev
suffix:semicolon
r_break
suffix:semicolon
)brace
id|devcp
op_assign
op_amp
id|devc-&gt;next_dev
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|devc
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|unregister_sound_mixer
c_func
(paren
id|devc-&gt;mixer_minor
)paren
suffix:semicolon
id|unregister_sound_dsp
c_func
(paren
id|devc-&gt;audio_minor
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|hw_config-&gt;irq
comma
id|devc
)paren
suffix:semicolon
id|free_pages
c_func
(paren
id|devc-&gt;wport.hwbuf_vaddr
comma
id|HWBUF_ORDER
)paren
suffix:semicolon
id|free_pages
c_func
(paren
id|devc-&gt;rport.hwbuf_vaddr
comma
id|HWBUF_ORDER
)paren
suffix:semicolon
id|li_destroy
c_func
(paren
op_amp
id|devc-&gt;lith
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|devc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/* initialization and loadable kernel module interface */
DECL|variable|the_hw_config
r_static
r_struct
id|address_info
id|the_hw_config
op_assign
(brace
l_int|0xFF001000
comma
multiline_comment|/* lithium phys addr  */
id|CO_IRQ
c_func
(paren
id|CO_APIC_LI_AUDIO
)paren
multiline_comment|/* irq */
)brace
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;SGI Visual Workstation sound module&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Bob Miller &lt;kbob@sgi.com&gt;&quot;
)paren
suffix:semicolon
DECL|function|init_vwsnd
r_static
r_int
id|__init
id|init_vwsnd
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|DBGXV
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|DBGXV
c_func
(paren
l_string|&quot;sound::vwsnd::init_module()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_vwsnd
c_func
(paren
op_amp
id|the_hw_config
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|err
op_assign
id|attach_vwsnd
c_func
(paren
op_amp
id|the_hw_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_vwsnd
r_static
r_void
id|__exit
id|cleanup_vwsnd
c_func
(paren
r_void
)paren
(brace
id|DBGX
c_func
(paren
l_string|&quot;sound::vwsnd::cleanup_module()&bslash;n&quot;
)paren
suffix:semicolon
id|unload_vwsnd
c_func
(paren
op_amp
id|the_hw_config
)paren
suffix:semicolon
)brace
DECL|variable|init_vwsnd
id|module_init
c_func
(paren
id|init_vwsnd
)paren
suffix:semicolon
DECL|variable|cleanup_vwsnd
id|module_exit
c_func
(paren
id|cleanup_vwsnd
)paren
suffix:semicolon
eof
