multiline_comment|/*&n; *&t;Intel i810 and friends ICH driver for Linux&n; *&t;Alan Cox &lt;alan@redhat.com&gt;&n; *&n; *  Built from:&n; *&t;Low level code:  Zach Brown (original nonworking i810 OSS driver)&n; *&t;&t;&t; Jaroslav Kysela &lt;perex@suse.cz&gt; (working ALSA driver)&n; *&n; *&t;Framework: Thomas Sailer &lt;sailer@ife.ee.ethz.ch&gt;&n; *&t;Extended by: Zach Brown &lt;zab@redhat.com&gt;  &n; *&t;&t;&t;and others..&n; *&n; *  Hardware Provided By:&n; *&t;Analog Devices (A major AC97 codec maker)&n; *&t;Intel Corp  (you&squot;ve probably heard of them already)&n; *&n; * AC97 clues and assistance provided by&n; *&t;Analog Devices&n; *&t;Zach &squot;Fufu&squot; Brown&n; *&t;Jeff Garzik&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *&n; *&t;Intel 810 theory of operation&n; *&n; *&t;The chipset provides three DMA channels that talk to an AC97&n; *&t;CODEC (AC97 is a digital/analog mixer standard). At its simplest&n; *&t;you get 48Khz audio with basic volume and mixer controls. At the&n; *&t;best you get rate adaption in the codec. We set the card up so&n; *&t;that we never take completion interrupts but instead keep the card&n; *&t;chasing its tail around a ring buffer. This is needed for mmap&n; *&t;mode audio and happens to work rather well for non-mmap modes too.&n; *&n; *&t;The board has one output channel for PCM audio (supported) and&n; *&t;a stereo line in and mono microphone input. Again these are normally&n; *&t;locked to 48Khz only. Right now recording is not finished.&n; *&n; *&t;There is no midi support, no synth support. Use timidity. To get&n; *&t;esd working you need to use esd -r 48000 as it won&squot;t probe 48KHz&n; *&t;by default. mpg123 can&squot;t handle 48Khz only audio so use xmms.&n; *&n; *&t;Fix The Sound On Dell&n; *&n; *&t;Not everyone uses 48KHz. We know of no way to detect this reliably&n; *&t;and certainly not to get the right data. If your i810 audio sounds&n; *&t;stupid you may need to investigate other speeds. According to Analog&n; *&t;they tend to use a 14.318MHz clock which gives you a base rate of&n; *&t;41194Hz.&n; *&n; *&t;This is available via the &squot;ftsodell=1&squot; option. &n; *&n; *&t;If you need to force a specific rate set the clocking= option&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#ifndef PCI_DEVICE_ID_INTEL_82801
DECL|macro|PCI_DEVICE_ID_INTEL_82801
mdefine_line|#define PCI_DEVICE_ID_INTEL_82801&t;0x2415
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_82901
DECL|macro|PCI_DEVICE_ID_INTEL_82901
mdefine_line|#define PCI_DEVICE_ID_INTEL_82901&t;0x2425
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_ICH2
DECL|macro|PCI_DEVICE_ID_INTEL_ICH2
mdefine_line|#define PCI_DEVICE_ID_INTEL_ICH2&t;0x2445
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_440MX
DECL|macro|PCI_DEVICE_ID_INTEL_440MX
mdefine_line|#define PCI_DEVICE_ID_INTEL_440MX&t;0x7195
macro_line|#endif
DECL|variable|ftsodell
r_static
r_int
id|ftsodell
op_assign
l_int|0
suffix:semicolon
DECL|variable|clocking
r_static
r_int
r_int
id|clocking
op_assign
l_int|48000
suffix:semicolon
DECL|macro|ADC_RUNNING
mdefine_line|#define ADC_RUNNING&t;1
DECL|macro|DAC_RUNNING
mdefine_line|#define DAC_RUNNING&t;2
DECL|macro|I810_FMT_16BIT
mdefine_line|#define I810_FMT_16BIT&t;1
DECL|macro|I810_FMT_STEREO
mdefine_line|#define I810_FMT_STEREO&t;2
DECL|macro|I810_FMT_MASK
mdefine_line|#define I810_FMT_MASK&t;3
multiline_comment|/* the 810&squot;s array of pointers to data buffers */
DECL|struct|sg_item
r_struct
id|sg_item
(brace
DECL|macro|BUSADDR_MASK
mdefine_line|#define BUSADDR_MASK&t;0xFFFFFFFE
DECL|member|busaddr
id|u32
id|busaddr
suffix:semicolon
DECL|macro|CON_IOC
mdefine_line|#define CON_IOC &t;0x80000000 /* interrupt on completion */
DECL|macro|CON_BUFPAD
mdefine_line|#define CON_BUFPAD&t;0x40000000 /* pad underrun with last sample, else 0 */
DECL|macro|CON_BUFLEN_MASK
mdefine_line|#define CON_BUFLEN_MASK&t;0x0000ffff /* buffer length in samples */
DECL|member|control
id|u32
id|control
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* an instance of the i810 channel */
DECL|macro|SG_LEN
mdefine_line|#define SG_LEN 32
DECL|struct|i810_channel
r_struct
id|i810_channel
(brace
multiline_comment|/* these sg guys should probably be allocated&n;&t;   seperately as nocache. Must be 8 byte aligned */
DECL|member|sg
r_struct
id|sg_item
id|sg
(braket
id|SG_LEN
)braket
suffix:semicolon
multiline_comment|/* 32*8 */
DECL|member|offset
id|u32
id|offset
suffix:semicolon
multiline_comment|/* 4 */
DECL|member|port
id|u32
id|port
suffix:semicolon
multiline_comment|/* 4 */
DECL|member|used
id|u32
id|used
suffix:semicolon
DECL|member|num
id|u32
id|num
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * we have 3 seperate dma engines.  pcm in, pcm out, and mic.&n; * each dma engine has controlling registers.  These goofy&n; * names are from the datasheet, but make it easy to write&n; * code while leafing through it.&n; */
DECL|macro|ENUM_ENGINE
mdefine_line|#define ENUM_ENGINE(PRE,DIG) &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;enum {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;PRE##_BDBAR =&t;0x##DIG##0,&t;&t;/* Buffer Descriptor list Base Address */&t;&bslash;&n;&t;PRE##_CIV =&t;0x##DIG##4,&t;&t;/* Current Index Value */&t;&t;&t;&bslash;&n;&t;PRE##_LVI =&t;0x##DIG##5,&t;&t;/* Last Valid Index */&t;&t;&t;&t;&bslash;&n;&t;PRE##_SR =&t;0x##DIG##6,&t;&t;/* Status Register */&t;&t;&t;&t;&bslash;&n;&t;PRE##_PICB =&t;0x##DIG##8,&t;&t;/* Position In Current Buffer */&t;&t;&bslash;&n;&t;PRE##_PIV =&t;0x##DIG##a,&t;&t;/* Prefetched Index Value */&t;&t;&t;&bslash;&n;&t;PRE##_CR =&t;0x##DIG##b&t;&t;/* Control Register */&t;&t;&t;&t;&bslash;&n;}
id|ENUM_ENGINE
c_func
(paren
id|OFF
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Offsets */
id|ENUM_ENGINE
c_func
(paren
id|PI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* PCM In */
id|ENUM_ENGINE
c_func
(paren
id|PO
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* PCM Out */
id|ENUM_ENGINE
c_func
(paren
id|MC
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Mic In */
r_enum
(brace
DECL|enumerator|GLOB_CNT
id|GLOB_CNT
op_assign
l_int|0x2c
comma
multiline_comment|/* Global Control */
DECL|enumerator|GLOB_STA
id|GLOB_STA
op_assign
l_int|0x30
comma
multiline_comment|/* Global Status */
DECL|enumerator|CAS
id|CAS
op_assign
l_int|0x34
multiline_comment|/* Codec Write Semaphore Register */
)brace
suffix:semicolon
multiline_comment|/* interrupts for a dma engine */
DECL|macro|DMA_INT_FIFO
mdefine_line|#define DMA_INT_FIFO&t;&t;(1&lt;&lt;4)  /* fifo under/over flow */
DECL|macro|DMA_INT_COMPLETE
mdefine_line|#define DMA_INT_COMPLETE&t;(1&lt;&lt;3)  /* buffer read/write complete and ioc set */
DECL|macro|DMA_INT_LVI
mdefine_line|#define DMA_INT_LVI&t;&t;(1&lt;&lt;2)  /* last valid done */
DECL|macro|DMA_INT_CELV
mdefine_line|#define DMA_INT_CELV&t;&t;(1&lt;&lt;1)  /* last valid is current */
DECL|macro|DMA_INT_MASK
mdefine_line|#define DMA_INT_MASK (DMA_INT_FIFO|DMA_INT_COMPLETE|DMA_INT_LVI)
multiline_comment|/* interrupts for the whole chip */
DECL|macro|INT_SEC
mdefine_line|#define INT_SEC&t;&t;(1&lt;&lt;11)
DECL|macro|INT_PRI
mdefine_line|#define INT_PRI&t;&t;(1&lt;&lt;10)
DECL|macro|INT_MC
mdefine_line|#define INT_MC&t;&t;(1&lt;&lt;7)
DECL|macro|INT_PO
mdefine_line|#define INT_PO&t;&t;(1&lt;&lt;6)
DECL|macro|INT_PI
mdefine_line|#define INT_PI&t;&t;(1&lt;&lt;5)
DECL|macro|INT_MO
mdefine_line|#define INT_MO&t;&t;(1&lt;&lt;2)
DECL|macro|INT_NI
mdefine_line|#define INT_NI&t;&t;(1&lt;&lt;1)
DECL|macro|INT_GPI
mdefine_line|#define INT_GPI&t;&t;(1&lt;&lt;0)
DECL|macro|INT_MASK
mdefine_line|#define INT_MASK (INT_SEC|INT_PRI|INT_MC|INT_PO|INT_PI|INT_MO|INT_NI|INT_GPI)
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.01&quot;
multiline_comment|/* magic numbers to protect our data structures */
DECL|macro|I810_CARD_MAGIC
mdefine_line|#define I810_CARD_MAGIC&t;&t;0x5072696E /* &quot;Prin&quot; */
DECL|macro|I810_STATE_MAGIC
mdefine_line|#define I810_STATE_MAGIC&t;0x63657373 /* &quot;cess&quot; */
DECL|macro|I810_DMA_MASK
mdefine_line|#define I810_DMA_MASK&t;&t;0xffffffff /* DMA buffer mask for pci_alloc_consist */
DECL|macro|NR_HW_CH
mdefine_line|#define NR_HW_CH&t;&t;3
multiline_comment|/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
DECL|macro|NR_AC97
mdefine_line|#define NR_AC97&t;&t;2
DECL|variable|sample_size
r_static
r_const
r_int
id|sample_size
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|4
)brace
suffix:semicolon
DECL|variable|sample_shift
r_static
r_const
r_int
id|sample_shift
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|ICH82801AA
id|ICH82801AA
op_assign
l_int|0
comma
DECL|enumerator|ICH82901AB
id|ICH82901AB
comma
DECL|enumerator|INTEL440MX
id|INTEL440MX
comma
DECL|enumerator|INTELICH2
id|INTELICH2
comma
)brace
suffix:semicolon
DECL|variable|card_names
r_static
r_char
op_star
id|card_names
(braket
)braket
op_assign
(brace
l_string|&quot;Intel ICH 82801AA&quot;
comma
l_string|&quot;Intel ICH 82901AB&quot;
comma
l_string|&quot;Intel 440MX&quot;
comma
l_string|&quot;Intel ICH2&quot;
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|i810_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82801
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|ICH82801AA
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82901
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|ICH82901AB
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_440MX
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|INTEL440MX
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_ICH2
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|INTELICH2
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|i810_pci_tbl
)paren
suffix:semicolon
multiline_comment|/* &quot;software&quot; or virtual channel, an instance of opened /dev/dsp */
DECL|struct|i810_state
r_struct
id|i810_state
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
DECL|member|card
r_struct
id|i810_card
op_star
id|card
suffix:semicolon
multiline_comment|/* Card info */
multiline_comment|/* single open lock mechanism, only used for recording */
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
multiline_comment|/* file mode */
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
multiline_comment|/* virtual channel number */
DECL|member|virt
r_int
id|virt
suffix:semicolon
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
multiline_comment|/* wave sample stuff */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
DECL|member|fmt
DECL|member|enable
r_int
r_char
id|fmt
comma
id|enable
suffix:semicolon
multiline_comment|/* hardware channel */
DECL|member|channel
r_struct
id|i810_channel
op_star
id|channel
suffix:semicolon
multiline_comment|/* OSS buffer management stuff */
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
DECL|member|dma_handle
id|dma_addr_t
id|dma_handle
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
multiline_comment|/* our buffer acts like a circular ring */
DECL|member|hwptr
r_int
id|hwptr
suffix:semicolon
multiline_comment|/* where dma last started, updated by update_ptr */
DECL|member|swptr
r_int
id|swptr
suffix:semicolon
multiline_comment|/* where driver last clear/filled, updated by read/write */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* bytes to be comsumed or been generated by dma machine */
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
multiline_comment|/* total bytes dmaed by hardware */
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* number of over/underruns */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* put process on wait queue when no more space in buffer */
multiline_comment|/* redundant, but makes calculations easier */
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
multiline_comment|/* OSS stuff */
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
DECL|member|endcleared
r_int
id|endcleared
suffix:colon
l_int|1
suffix:semicolon
DECL|member|update_flag
r_int
id|update_flag
suffix:semicolon
DECL|member|ossfragshift
r_int
id|ossfragshift
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|dmabuf
)brace
id|dmabuf
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|i810_card
r_struct
id|i810_card
(brace
DECL|member|channel
r_struct
id|i810_channel
id|channel
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* We keep i810 cards in a linked list */
DECL|member|next
r_struct
id|i810_card
op_star
id|next
suffix:semicolon
multiline_comment|/* The i810 has a certain amount of cross channel interaction&n;&t;   so we use a single per card lock */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* PCI device stuff */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
DECL|member|pci_id
id|u16
id|pci_id
suffix:semicolon
multiline_comment|/* soundcore stuff */
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
multiline_comment|/* structures for abstraction of hardware facilities, codecs, banks and channels*/
DECL|member|ac97_codec
r_struct
id|ac97_codec
op_star
id|ac97_codec
(braket
id|NR_AC97
)braket
suffix:semicolon
DECL|member|states
r_struct
id|i810_state
op_star
id|states
(braket
id|NR_HW_CH
)braket
suffix:semicolon
DECL|member|ac97_features
id|u16
id|ac97_features
suffix:semicolon
multiline_comment|/* hardware resources */
DECL|member|iobase
r_int
r_int
id|iobase
suffix:semicolon
DECL|member|ac97base
r_int
r_int
id|ac97base
suffix:semicolon
DECL|member|irq
id|u32
id|irq
suffix:semicolon
multiline_comment|/* Function support */
DECL|member|alloc_pcm_channel
r_struct
id|i810_channel
op_star
(paren
op_star
id|alloc_pcm_channel
)paren
(paren
r_struct
id|i810_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_pcm_channel
r_struct
id|i810_channel
op_star
(paren
op_star
id|alloc_rec_pcm_channel
)paren
(paren
r_struct
id|i810_card
op_star
)paren
suffix:semicolon
DECL|member|free_pcm_channel
r_void
(paren
op_star
id|free_pcm_channel
)paren
(paren
r_struct
id|i810_card
op_star
comma
r_int
id|chan
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|i810_card
op_star
id|devs
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|i810_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|i810_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
id|loff_t
id|i810_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
suffix:semicolon
DECL|function|ld2
r_extern
id|__inline__
r_int
id|ld2
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10000
)paren
(brace
id|x
op_rshift_assign
l_int|16
suffix:semicolon
id|r
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x100
)paren
(brace
id|x
op_rshift_assign
l_int|8
suffix:semicolon
id|r
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10
)paren
(brace
id|x
op_rshift_assign
l_int|4
suffix:semicolon
id|r
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|4
)paren
(brace
id|x
op_rshift_assign
l_int|2
suffix:semicolon
id|r
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|2
)paren
id|r
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_static
id|u16
id|i810_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
suffix:semicolon
r_static
r_void
id|i810_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
suffix:semicolon
DECL|function|i810_alloc_pcm_channel
r_static
r_struct
id|i810_channel
op_star
id|i810_alloc_pcm_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|port
op_assign
l_int|0x10
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|num
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|i810_alloc_rec_pcm_channel
r_static
r_struct
id|i810_channel
op_star
id|i810_alloc_rec_pcm_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|port
op_assign
l_int|0x00
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|num
op_assign
l_int|0
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|i810_free_pcm_channel
r_static
r_void
id|i810_free_pcm_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
comma
r_int
id|channel
)paren
(brace
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|used
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set playback sample rate */
DECL|function|i810_set_dac_rate
r_static
r_int
r_int
id|i810_set_dac_rate
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|dacp
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Adjust for misclocked crap&n;&t; */
id|rate
op_assign
(paren
id|rate
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
multiline_comment|/* Analog codecs can go lower via magic registers but others&n;&t;   might not */
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
(brace
id|rate
op_assign
l_int|8000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
op_ne
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_PCM_FRONT_DAC_RATE
)paren
)paren
(brace
multiline_comment|/* Power down the DAC */
id|dacp
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|dacp
op_or
l_int|0x0200
)paren
suffix:semicolon
multiline_comment|/* Load the rate and read the effective rate */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_PCM_FRONT_DAC_RATE
comma
id|rate
)paren
suffix:semicolon
id|rate
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_PCM_FRONT_DAC_RATE
)paren
suffix:semicolon
multiline_comment|/* Power it back up */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|dacp
)paren
suffix:semicolon
)brace
id|rate
op_assign
(paren
id|rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: called i810_set_dac_rate : rate = %d&bslash;n&quot;
comma
id|rate
)paren
suffix:semicolon
macro_line|#endif
r_return
id|rate
suffix:semicolon
)brace
multiline_comment|/* set recording sample rate */
DECL|function|i810_set_adc_rate
r_static
r_int
r_int
id|i810_set_adc_rate
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|dacp
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Adjust for misclocked crap&n;&t; */
id|rate
op_assign
(paren
id|rate
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
multiline_comment|/* Analog codecs can go lower via magic registers but others&n;&t;   might not */
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
(brace
id|rate
op_assign
l_int|8000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
op_ne
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_PCM_LR_DAC_RATE
)paren
)paren
(brace
multiline_comment|/* Power down the ADC */
id|dacp
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|dacp
op_or
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* Load the rate and read the effective rate */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_PCM_LR_DAC_RATE
comma
id|rate
)paren
suffix:semicolon
id|rate
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_PCM_LR_DAC_RATE
)paren
suffix:semicolon
multiline_comment|/* Power it back up */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|dacp
)paren
suffix:semicolon
)brace
id|rate
op_assign
(paren
id|rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: called i810_set_adc_rate : rate = %d&bslash;n&quot;
comma
id|rate
)paren
suffix:semicolon
macro_line|#endif
r_return
id|rate
suffix:semicolon
)brace
multiline_comment|/* prepare channel attributes for playback */
DECL|function|i810_play_setup
r_static
r_void
id|i810_play_setup
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
singleline_comment|//&t;struct dmabuf *dmabuf = &amp;state-&gt;dmabuf;
singleline_comment|//&t;struct i810_channel *channel = dmabuf-&gt;channel;
multiline_comment|/* Fixed format. .. */
singleline_comment|//if (dmabuf-&gt;fmt &amp; I810_FMT_16BIT)
singleline_comment|//if (dmabuf-&gt;fmt &amp; I810_FMT_STEREO)
)brace
multiline_comment|/* prepare channel attributes for recording */
DECL|function|i810_rec_setup
r_static
r_void
id|i810_rec_setup
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
singleline_comment|//&t;u16 w;
singleline_comment|//&t;struct i810_card *card = state-&gt;card;
singleline_comment|//&t;struct dmabuf *dmabuf = &amp;state-&gt;dmabuf;
singleline_comment|//&t;struct i810_channel *channel = dmabuf-&gt;channel;
multiline_comment|/* Enable AC-97 ADC (capture) */
singleline_comment|//&t;if (dmabuf-&gt;fmt &amp; I810_FMT_16BIT) {
singleline_comment|//&t;if (dmabuf-&gt;fmt &amp; I810_FMT_STEREO)
)brace
multiline_comment|/* get current playback/recording dma buffer pointer (byte offset from LBA),&n;   called with spinlock held! */
DECL|function|i810_get_dma_addr
r_extern
id|__inline__
r_int
id|i810_get_dma_addr
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|civ
comma
id|offset
suffix:semicolon
r_struct
id|i810_channel
op_star
id|c
op_assign
id|dmabuf-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
id|civ
op_assign
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
id|offset
op_assign
(paren
id|civ
op_plus
l_int|1
)paren
op_star
(paren
id|dmabuf-&gt;dmasize
op_div
id|SG_LEN
)paren
op_minus
l_int|2
op_star
id|inw
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_PICB
)paren
suffix:semicolon
multiline_comment|/* CIV changed before we read PICB (very seldom) ?&n;&t;&t; * then PICB was rubbish, so try again */
)brace
r_while
c_loop
(paren
id|civ
op_ne
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|resync_dma_ptrs
r_static
r_void
id|resync_dma_ptrs
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_channel
op_star
id|c
op_assign
id|dmabuf-&gt;channel
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|offset
op_assign
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
id|offset
op_mul_assign
(paren
id|dmabuf-&gt;dmasize
op_div
id|SG_LEN
)paren
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|dmabuf-&gt;swptr
op_assign
id|offset
suffix:semicolon
)brace
multiline_comment|/* Stop recording (lock held) */
DECL|function|__stop_adc
r_extern
id|__inline__
r_void
id|__stop_adc
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|ADC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;mapped
op_logical_or
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
)paren
op_logical_and
id|dmabuf-&gt;ready
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|ADC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
l_int|1
op_lshift
l_int|2
op_or
l_int|1
comma
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* stop playback (lock held) */
DECL|function|__stop_dac
r_extern
id|__inline__
r_void
id|__stop_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|DAC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
suffix:semicolon
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;mapped
op_logical_or
id|dmabuf-&gt;count
OG
l_int|0
)paren
op_logical_and
id|dmabuf-&gt;ready
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|DAC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
l_int|1
op_lshift
l_int|2
op_or
l_int|1
comma
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER (15-PAGE_SHIFT)
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1
multiline_comment|/* allocate DMA buffer, playback and recording buffer should be allocated seperately */
DECL|function|alloc_dmabuf
r_static
r_int
id|alloc_dmabuf
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|rawbuf
suffix:semicolon
r_int
id|order
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
multiline_comment|/* alloc as big a chunk as we can, FIXME: is this necessary ?? */
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
id|pci_alloc_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|order
comma
op_amp
id|dmabuf-&gt;dma_handle
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|rawbuf
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;ready
op_assign
id|dmabuf-&gt;mapped
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;rawbuf
op_assign
id|rawbuf
suffix:semicolon
id|dmabuf-&gt;buforder
op_assign
id|order
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free DMA buffer */
DECL|function|dealloc_dmabuf
r_static
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
(brace
multiline_comment|/* undo marking the pages as reserved */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
comma
id|dmabuf-&gt;rawbuf
comma
id|dmabuf-&gt;dma_handle
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|sg_item
op_star
id|sg
suffix:semicolon
r_int
id|bytepersec
suffix:semicolon
r_int
id|bufsize
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|fragsize
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer if not allocated yet */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;rawbuf
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* FIXME: figure out all this OSS fragment stuff */
id|bytepersec
op_assign
id|dmabuf-&gt;rate
op_lshift
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|bufsize
op_assign
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragshift
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1000
op_lshift
id|dmabuf-&gt;ossfragshift
)paren
OL
id|bytepersec
)paren
id|dmabuf-&gt;fragshift
op_assign
id|ld2
c_func
(paren
id|bytepersec
op_div
l_int|1000
)paren
suffix:semicolon
r_else
id|dmabuf-&gt;fragshift
op_assign
id|dmabuf-&gt;ossfragshift
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lets hand out reasonable big ass buffers by default */
id|dmabuf-&gt;fragshift
op_assign
(paren
id|dmabuf-&gt;buforder
op_plus
id|PAGE_SHIFT
op_minus
l_int|2
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;numfrag
op_assign
id|bufsize
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
r_while
c_loop
(paren
id|dmabuf-&gt;numfrag
template_param
l_int|3
)paren
(brace
id|dmabuf-&gt;fragshift
op_decrement
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
id|bufsize
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
)brace
id|dmabuf-&gt;fragsize
op_assign
l_int|1
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_ge
l_int|4
op_logical_and
id|dmabuf-&gt;ossmaxfrags
OL
id|dmabuf-&gt;numfrag
)paren
id|dmabuf-&gt;numfrag
op_assign
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
id|dmabuf-&gt;fragsize
op_rshift
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
id|dmabuf-&gt;numfrag
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|I810_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now set up the ring &n;&t; */
id|sg
op_assign
op_amp
id|dmabuf-&gt;channel-&gt;sg
(braket
l_int|0
)braket
suffix:semicolon
id|fragsize
op_assign
id|bufsize
op_div
id|SG_LEN
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load up 32 sg entries and take an interrupt at half&n;&t; *&t;way (we might want more interrupts later..) &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sg-&gt;busaddr
op_assign
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|fragsize
op_star
id|i
)paren
suffix:semicolon
id|sg-&gt;control
op_assign
(paren
id|fragsize
op_rshift
l_int|1
)paren
suffix:semicolon
id|sg-&gt;control
op_or_assign
id|CON_IOC
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;channel-&gt;port
op_plus
id|OFF_CR
)paren
suffix:semicolon
multiline_comment|/* reset DMA machine */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|dmabuf-&gt;channel-&gt;sg
(braket
l_int|0
)braket
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;channel-&gt;port
op_plus
id|OFF_BDBAR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|16
comma
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;channel-&gt;port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;channel-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
(brace
id|i810_rec_setup
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|i810_play_setup
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* set the ready flag for the dma buffer */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: prog_dmabuf, sample rate = %d, format = %d, numfrag = %d, &quot;
l_string|&quot;fragsize = %d dmasize = %d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
comma
id|dmabuf-&gt;fmt
comma
id|dmabuf-&gt;numfrag
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear the rest of the last i810 dma buffer, normally there is no rest&n; * because the OSS fragment size is the same as the size of this buffer.&n; */
DECL|function|i810_clear_tail
r_static
r_void
id|i810_clear_tail
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
r_char
id|silence
op_assign
(paren
id|dmabuf-&gt;fmt
op_amp
id|I810_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;dmasize
)paren
(brace
id|len
op_assign
id|swptr
op_mod
(paren
id|dmabuf-&gt;dmasize
op_div
id|SG_LEN
)paren
suffix:semicolon
)brace
r_else
id|len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|silence
comma
id|len
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_add_assign
id|len
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|len
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* restart the dma machine in case it is halted */
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_or
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* It seems that we have to set the current state to TASK_INTERRUPTIBLE&n;&t;&t;   every time to make the process really go to sleep */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
id|dmabuf-&gt;rate
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
id|tmo
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: drain_dac, dma timeout?&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* update buffer manangement pointers, especially, dmabuf-&gt;count and dmabuf-&gt;hwptr */
DECL|function|i810_update_ptr
r_static
r_void
id|i810_update_ptr
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|hwptr
comma
id|swptr
suffix:semicolon
r_int
id|clear_cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|diff
suffix:semicolon
r_int
r_char
id|silence
suffix:semicolon
singleline_comment|//&t;unsigned half_dmasize;
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|i810_get_dma_addr
c_func
(paren
id|state
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
singleline_comment|//&t;printk(&quot;HWP %d,%d,%d&bslash;n&quot;, hwptr, dmabuf-&gt;hwptr, diff);
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
template_param
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun, we have no way to recover&n;&t;&t;&t;&t;   it here, just stop the machine and let the process force hwptr&n;&t;&t;&t;&t;   and swptr to sync */
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;endcleared
)paren
(brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|silence
op_assign
(paren
id|dmabuf-&gt;fmt
op_amp
id|I810_FMT_16BIT
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
(brace
id|clear_cnt
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|swptr
op_plus
id|clear_cnt
)paren
OG
id|dmabuf-&gt;dmasize
)paren
id|clear_cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
id|memset
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|silence
comma
id|clear_cnt
)paren
suffix:semicolon
id|dmabuf-&gt;endcleared
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
template_param
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun, we have no way to recover&n;&t;&t;&t;&t;   it here, just stop the machine and let the process force hwptr&n;&t;&t;&t;&t;   and swptr to sync */
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DMA overrun on send&bslash;n&quot;
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|i810_channel_interrupt
r_static
r_void
id|i810_channel_interrupt
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_int
id|i
suffix:semicolon
singleline_comment|//&t;printk(&quot;CHANNEL IRQ .. &quot;);&t;
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_struct
id|i810_channel
op_star
id|c
suffix:semicolon
r_int
r_int
id|port
op_assign
id|card-&gt;iobase
suffix:semicolon
id|u16
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;dmabuf.ready
)paren
(brace
r_continue
suffix:semicolon
)brace
id|c
op_assign
id|state-&gt;dmabuf.channel
suffix:semicolon
id|port
op_add_assign
id|c-&gt;port
suffix:semicolon
singleline_comment|//&t;&t;printk(&quot;PORT %lX (&quot;, port);
id|status
op_assign
id|inw
c_func
(paren
id|port
op_plus
id|OFF_SR
)paren
suffix:semicolon
singleline_comment|//&t;&t;printk(&quot;ST%d &quot;, status);
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_LVI
)paren
(brace
multiline_comment|/* Back to the start */
singleline_comment|//&t;&t;&t;printk(&quot;LVI - STOP&quot;);
id|outb
c_func
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_minus
l_int|1
)paren
op_amp
l_int|31
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|port
op_plus
id|OFF_CR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_COMPLETE
)paren
(brace
r_int
id|x
suffix:semicolon
multiline_comment|/* Keep the card chasing its tail */
id|outb
c_func
(paren
id|x
op_assign
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_minus
l_int|1
)paren
op_amp
l_int|31
)paren
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
singleline_comment|//&t;&t;&t;printk(&quot;COMP%d &quot;,x);
)brace
singleline_comment|//&t;&t;printk(&quot;)&quot;);
id|outw
c_func
(paren
id|status
op_amp
id|DMA_INT_MASK
comma
id|port
op_plus
id|OFF_SR
)paren
suffix:semicolon
)brace
singleline_comment|//&t;printk(&quot;&bslash;n&quot;);
)brace
DECL|function|i810_interrupt
r_static
r_void
id|i810_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
(paren
r_struct
id|i810_card
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|INT_MASK
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* not for us */
)brace
singleline_comment|//&t;printk(&quot;Interrupt %X: &quot;, status);
r_if
c_cond
(paren
id|status
op_amp
(paren
id|INT_PO
op_or
id|INT_PI
op_or
id|INT_MC
)paren
)paren
(brace
id|i810_channel_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
multiline_comment|/* clear &squot;em */
id|outl
c_func
(paren
id|status
op_amp
id|INT_MASK
comma
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|i810_llseek
r_static
id|loff_t
id|i810_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be copied to&n;   the user&squot;s buffer.  it is filled by the dma machine and drained by this loop. */
DECL|function|i810_read
r_static
id|ssize_t
id|i810_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_read called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer overrun, we are recovering from sleep_on_timeout,&n;&t;&t;&t;   resync hwptr and swptr, make process flush the buffer */
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|cnt
)paren
id|cnt
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
multiline_comment|/* buffer is empty, start the dma machine and wait for data to be&n;&t;&t;&t;   recorded */
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This isnt strictly right for the 810  but it&squot;ll do */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|2
)paren
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer overrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
id|tmo
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: recording schedule timeout, &quot;
l_string|&quot;dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;count
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;swptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* a buffer overrun, we delay the recovery untill next time the&n;&t;&t;&t;&t;   while loop begin and we REALLY have space to record */
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be dma to&n;   the soundcard.  it is drained by the dma machine and filled by this loop. */
DECL|function|i810_write
r_static
id|ssize_t
id|i810_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_write called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun, we are recovering from sleep_on_timeout,&n;&t;&t;&t;   resync hwptr and swptr */
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_plus
id|cnt
OG
id|dmabuf-&gt;dmasize
)paren
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
multiline_comment|/* buffer is full, start the dma machine and wait for data to be&n;&t;&t;&t;   played */
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Not strictly correct but works */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|2
)paren
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer underrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
id|tmo
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: playback schedule timeout, &quot;
l_string|&quot;dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;count
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;swptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* a buffer underrun, we delay the recovery untill next time the&n;&t;&t;&t;&t;   while loop begin and we REALLY have data to play */
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|cnt
suffix:semicolon
id|dmabuf-&gt;endcleared
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - we have our own spinlock */
DECL|function|i810_poll
r_static
r_int
r_int
id|i810_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_ge
id|dmabuf-&gt;count
op_plus
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|i810_mmap
r_static
r_int
id|i810_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|i810_ioctl
r_static
r_int
id|i810_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
comma
id|mapped
comma
id|ret
suffix:semicolon
id|mapped
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|dmabuf-&gt;mapped
)paren
op_logical_or
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|dmabuf-&gt;mapped
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_ioctl, command = %2d, arg = 0x%08x&bslash;n&quot;
comma
id|_IOC_NR
c_func
(paren
id|cmd
)paren
comma
id|arg
ques
c_cond
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
multiline_comment|/* FIXME: spin_lock ? */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|drain_dac
c_func
(paren
id|state
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* set smaple rate */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_set_adc_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* set stereo or mono channel */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;fmt
op_assign
id|I810_FMT_STEREO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;fmt
op_assign
id|I810_FMT_STEREO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask of supported sample format*/
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Select sample format */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_QUERY
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
l_int|2
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/* FIXME: the same as RESET ?? */
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
op_logical_and
id|val
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragshift
OL
l_int|4
)paren
id|dmabuf-&gt;ossfragshift
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragshift
OG
l_int|15
)paren
id|dmabuf-&gt;ossfragshift
op_assign
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
OL
l_int|4
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
op_or
id|DSP_CAP_BIND
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|dmabuf-&gt;enable
)paren
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dmabuf-&gt;enable
)paren
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|I810_FMT_STEREO
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_MAPINBUF
suffix:colon
r_case
id|SNDCTL_DSP_MAPOUTBUF
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|i810_open
r_static
r_int
id|i810_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|i810_state
op_star
id|state
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* find an avaiable virtual channel (instance of /dev/dsp) */
r_while
c_loop
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;states
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i810_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|i810_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_goto
id|found_virt
suffix:semicolon
)brace
)brace
id|card
op_assign
id|card-&gt;next
suffix:semicolon
)brace
multiline_comment|/* no more virtual channel avaiable */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|found_virt
suffix:colon
multiline_comment|/* found a free virtual channel, allocate hardware channels */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|dmabuf-&gt;channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;channel
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* initialize the virtual channel */
id|state-&gt;virt
op_assign
id|i
suffix:semicolon
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;magic
op_assign
id|I810_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
multiline_comment|/* set default sample format. According to OSS Programmer&squot;s Guide  /dev/dsp&n;&t;   should be default to unsigned 8-bits, mono, with sample rate 8kHz and&n;&t;   /dev/dspW will accept 16-bits sample */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|I810_FMT_MASK
suffix:semicolon
id|dmabuf-&gt;fmt
op_or_assign
id|I810_FMT_16BIT
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|i810_set_dac_rate
c_func
(paren
id|state
comma
l_int|48000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|I810_FMT_MASK
suffix:semicolon
id|dmabuf-&gt;fmt
op_or_assign
id|I810_FMT_16BIT
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|i810_set_adc_rate
c_func
(paren
id|state
comma
l_int|48000
)paren
suffix:semicolon
)brace
id|state-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_release
r_static
r_int
id|i810_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|i810_clear_tail
c_func
(paren
id|state
)paren
suffix:semicolon
id|drain_dac
c_func
(paren
id|state
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
)brace
multiline_comment|/* stop DMA state machine and free DMA buffers/channels */
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;channel-&gt;num
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;channel-&gt;num
)paren
suffix:semicolon
)brace
multiline_comment|/* we&squot;re covered by the open_sem */
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
)paren
suffix:semicolon
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|i810_audio_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|i810_audio_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|i810_llseek
comma
id|read
suffix:colon
id|i810_read
comma
id|write
suffix:colon
id|i810_write
comma
id|poll
suffix:colon
id|i810_poll
comma
id|ioctl
suffix:colon
id|i810_ioctl
comma
id|mmap
suffix:colon
id|i810_mmap
comma
id|open
suffix:colon
id|i810_open
comma
id|release
suffix:colon
id|i810_release
comma
)brace
suffix:semicolon
multiline_comment|/* Write AC97 codec registers */
DECL|function|i810_ac97_get
r_static
id|u16
id|i810_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
op_logical_and
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CAS
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|inw
c_func
(paren
id|card-&gt;ac97base
op_plus
(paren
id|reg
op_amp
l_int|0x7f
)paren
)paren
suffix:semicolon
)brace
DECL|function|i810_ac97_set
r_static
r_void
id|i810_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
op_logical_and
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CAS
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|data
comma
id|card-&gt;ac97base
op_plus
(paren
id|reg
op_amp
l_int|0x7f
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* OSS /dev/mixer file operation methods */
DECL|function|i810_open_mixdev
r_static
r_int
id|i810_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|devs
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
r_goto
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|file-&gt;private_data
op_assign
id|card-&gt;ac97_codec
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_ioctl_mixdev
r_static
r_int
id|i810_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
(paren
r_struct
id|ac97_codec
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|codec
op_member_access_from_pointer
id|mixer_ioctl
c_func
(paren
id|codec
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|i810_mixer_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|i810_mixer_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|i810_llseek
comma
id|ioctl
suffix:colon
id|i810_ioctl_mixdev
comma
id|open
suffix:colon
id|i810_open_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/* AC97 codec initialisation. */
DECL|function|i810_ac97_init
r_static
r_int
id|__init
id|i810_ac97_init
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_int
id|num_ac97
op_assign
l_int|0
suffix:semicolon
r_int
id|ready_2nd
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
suffix:semicolon
id|u16
id|eid
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|u32
id|reg
suffix:semicolon
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Cold required */
id|reg
op_or_assign
l_int|2
suffix:semicolon
)brace
r_else
id|reg
op_or_assign
l_int|4
suffix:semicolon
multiline_comment|/* Warm */
id|reg
op_and_assign
op_complement
l_int|8
suffix:semicolon
multiline_comment|/* ACLink on */
id|outl
c_func
(paren
id|reg
comma
id|card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
l_int|10
)paren
(brace
r_if
c_cond
(paren
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|10
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: AC&squot;97 reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|5
)paren
suffix:semicolon
id|inw
c_func
(paren
id|card-&gt;ac97base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|codec
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some basic codec information, other fields will be filled&n;&t;&t;   in ac97_probe_codec */
id|codec-&gt;private_data
op_assign
id|card
suffix:semicolon
id|codec-&gt;id
op_assign
id|num_ac97
suffix:semicolon
id|codec-&gt;codec_read
op_assign
id|i810_ac97_get
suffix:semicolon
id|codec-&gt;codec_write
op_assign
id|i810_ac97_set
suffix:semicolon
r_if
c_cond
(paren
id|ac97_probe_codec
c_func
(paren
id|codec
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|eid
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
l_int|0xFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: no codec attached ?&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_features
op_assign
id|eid
suffix:semicolon
multiline_comment|/* Now check the codec for useful features to make up for&n;&t;&t;   the dumbness of the 810 hardware engine */
r_if
c_cond
(paren
op_logical_neg
(paren
id|eid
op_amp
l_int|0x0001
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: only 48Khz playback available.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Enable variable rate mode */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
l_int|9
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
op_or
l_int|0xE800
)paren
suffix:semicolon
multiline_comment|/* power up everything, modify this when implementing power saving */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
op_amp
op_complement
l_int|0x7f00
)paren
suffix:semicolon
multiline_comment|/* wait for analog ready */
r_for
c_loop
(paren
id|i
op_assign
l_int|10
suffix:semicolon
id|i
op_logical_and
(paren
(paren
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|0xf
)paren
op_ne
l_int|0xf
)paren
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: Codec refused to allow VRA, using 48Khz only.&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;ac97_features
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|i810_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
id|codec
suffix:semicolon
multiline_comment|/* if there is no secondary codec at all, don&squot;t probe any more */
r_if
c_cond
(paren
op_logical_neg
id|ready_2nd
)paren
r_return
id|num_ac97
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|num_ac97
suffix:semicolon
)brace
multiline_comment|/* install the driver, we do not allocate hardware channel nor DMA buffer now, they are defered &n;   untill &quot;ACCESS&quot; time (in prog_dmabuf called by open/read/write/ioctl/mmap) */
DECL|function|i810_probe
r_static
r_int
id|__init
id|i810_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|pci_id
)paren
(brace
r_struct
id|i810_card
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_dma_supported
c_func
(paren
id|pci_dev
comma
id|I810_DMA_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;intel810: architecture does not support&quot;
l_string|&quot; 32bit PCI busmaster DMA&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pci_dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i810_card
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|card
)paren
)paren
suffix:semicolon
id|card-&gt;iobase
op_assign
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|1
)paren
suffix:semicolon
id|card-&gt;ac97base
op_assign
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|0
)paren
suffix:semicolon
id|card-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|card-&gt;pci_id
op_assign
id|pci_id-&gt;device
suffix:semicolon
id|card-&gt;irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|card-&gt;next
op_assign
id|devs
suffix:semicolon
id|card-&gt;magic
op_assign
id|I810_CARD_MAGIC
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|devs
op_assign
id|card
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i810: %s found at IO 0x%04lx and 0x%04lx, IRQ %d&bslash;n&quot;
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
comma
id|card-&gt;iobase
comma
id|card-&gt;ac97base
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|card-&gt;alloc_pcm_channel
op_assign
id|i810_alloc_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_pcm_channel
op_assign
id|i810_alloc_rec_pcm_channel
suffix:semicolon
id|card-&gt;free_pcm_channel
op_assign
id|i810_free_pcm_channel
suffix:semicolon
multiline_comment|/* claim our iospace and irq */
id|request_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|card-&gt;irq
comma
op_amp
id|i810_interrupt
comma
id|SA_SHIRQ
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: unable to allocate irq %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* register /dev/dsp */
r_if
c_cond
(paren
(paren
id|card-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|i810_audio_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: couldn&squot;t register DSP device!&bslash;n&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* initialize AC97 codec and register /dev/mixer */
r_if
c_cond
(paren
id|i810_ac97_init
c_func
(paren
id|card
)paren
op_le
l_int|0
)paren
(brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pci_dev-&gt;driver_data
op_assign
id|card
suffix:semicolon
id|pci_dev-&gt;dma_mask
op_assign
id|I810_DMA_MASK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_remove
r_static
r_void
id|__exit
id|i810_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|pci_dev-&gt;driver_data
suffix:semicolon
multiline_comment|/* free hardware resources */
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|devs
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
multiline_comment|/* unregister audio devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|devs-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Intel 810 audio support&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ftsodell
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|clocking
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|I810_MODULE_NAME
mdefine_line|#define I810_MODULE_NAME &quot;intel810_audio&quot;
DECL|variable|i810_pci_driver
r_static
r_struct
id|pci_driver
id|i810_pci_driver
op_assign
(brace
id|name
suffix:colon
id|I810_MODULE_NAME
comma
id|id_table
suffix:colon
id|i810_pci_tbl
comma
id|probe
suffix:colon
id|i810_probe
comma
id|remove
suffix:colon
id|i810_remove
comma
)brace
suffix:semicolon
DECL|function|i810_init_module
r_static
r_int
id|__init
id|i810_init_module
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
multiline_comment|/* No PCI bus in this machine! */
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ftsodell
op_eq
l_int|1
)paren
(brace
id|clocking
op_assign
l_int|41194
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Intel 810 + AC97 Audio, version &quot;
id|DRIVER_VERSION
l_string|&quot;, &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_register_driver
c_func
(paren
op_amp
id|i810_pci_driver
)paren
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|i810_pci_driver
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_cleanup_module
r_static
r_void
id|__exit
id|i810_cleanup_module
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|i810_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|i810_init_module
id|module_init
c_func
(paren
id|i810_init_module
)paren
suffix:semicolon
DECL|variable|i810_cleanup_module
id|module_exit
c_func
(paren
id|i810_cleanup_module
)paren
suffix:semicolon
eof
