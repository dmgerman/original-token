multiline_comment|/*&n; *&t;Crystal SoundFusion CS46xx driver&n; *&n; *&t;Copyright 1999-2000 Jaroslav Kysela &lt;perex@suse.cz&gt;&n; *&t;Copyright 2000 Alan Cox &lt;alan@redhat.com&gt;&n; *&n; *&t;The core of this code is taken from the ALSA project driver by &n; *&t;Jaroslav. Please send Jaroslav the credit for the driver and &n; *&t;report bugs in this port to &lt;alan@redhat.com&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Changes:&n; *&t;20000815&t;Updated driver to kernel 2.4, some cleanups/fixes&n; *&t;&t;&t;Nils Faerber &lt;nils@kernelconcepts.de&gt;&n; *&n; *&t;20000909&t;Changed cs_read, cs_write and drain_dac&n; *&t;&t;&t;Nils Faerber &lt;nils@kernelconcepts.de&gt;&n; *&n; *&t;20001110&t;Added __initdata to BA1Struct in cs461x_image.h&n; *&t;&t;&t;and three more __init here&n; *&t;&t;&t;Bartlomiej Zolnierkiewicz &lt;bkz@linux-ide.org&gt;&n; *&n; *&t;20001023&t;Ported to Linux 2.4 PCI interface, some cleanups&n; *&t;&t;&t;Christoph Hellwig &lt;hch@caldera.de&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &quot;cs461x.h&quot;
DECL|macro|ADC_RUNNING
mdefine_line|#define ADC_RUNNING&t;1
DECL|macro|DAC_RUNNING
mdefine_line|#define DAC_RUNNING&t;2
DECL|macro|CS_FMT_16BIT
mdefine_line|#define CS_FMT_16BIT&t;1&t;&t;/* These are fixed in fact */
DECL|macro|CS_FMT_STEREO
mdefine_line|#define CS_FMT_STEREO&t;2
DECL|macro|CS_FMT_MASK
mdefine_line|#define CS_FMT_MASK&t;3
multiline_comment|/*&n; *&t;CS461x definitions&n; */
DECL|macro|CS461X_BA0_SIZE
mdefine_line|#define CS461X_BA0_SIZE&t;&t;0x2000
DECL|macro|CS461X_BA1_DATA0_SIZE
mdefine_line|#define CS461X_BA1_DATA0_SIZE&t;0x3000
DECL|macro|CS461X_BA1_DATA1_SIZE
mdefine_line|#define CS461X_BA1_DATA1_SIZE&t;0x3800
DECL|macro|CS461X_BA1_PRG_SIZE
mdefine_line|#define CS461X_BA1_PRG_SIZE&t;0x7000
DECL|macro|CS461X_BA1_REG_SIZE
mdefine_line|#define CS461X_BA1_REG_SIZE&t;0x0100
DECL|macro|GOF_PER_SEC
mdefine_line|#define GOF_PER_SEC&t;200
DECL|variable|external_amp
r_static
r_int
id|external_amp
op_assign
l_int|0
suffix:semicolon
DECL|variable|thinkpad
r_static
r_int
id|thinkpad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An instance of the 4610 channel */
DECL|struct|cs_channel
r_struct
id|cs_channel
(brace
DECL|member|used
r_int
id|used
suffix:semicolon
DECL|member|num
r_int
id|num
suffix:semicolon
DECL|member|state
r_void
op_star
id|state
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.14&quot;
multiline_comment|/* magic numbers to protect our data structures */
DECL|macro|CS_CARD_MAGIC
mdefine_line|#define CS_CARD_MAGIC&t;&t;0x46524F4D /* &quot;FROM&quot; */
DECL|macro|CS_STATE_MAGIC
mdefine_line|#define CS_STATE_MAGIC&t;&t;0x414c5341 /* &quot;ALSA&quot; */
DECL|macro|NR_HW_CH
mdefine_line|#define NR_HW_CH&t;&t;3
multiline_comment|/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
DECL|macro|NR_AC97
mdefine_line|#define NR_AC97&t;&t;2
DECL|variable|sample_size
r_static
r_const
r_int
id|sample_size
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|4
)brace
suffix:semicolon
DECL|variable|sample_shift
r_static
r_const
r_int
id|sample_shift
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
)brace
suffix:semicolon
multiline_comment|/* &quot;software&quot; or virtual channel, an instance of opened /dev/dsp */
DECL|struct|cs_state
r_struct
id|cs_state
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
DECL|member|card
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
multiline_comment|/* Card info */
multiline_comment|/* single open lock mechanism, only used for recording */
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
multiline_comment|/* file mode */
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
multiline_comment|/* virtual channel number */
DECL|member|virt
r_int
id|virt
suffix:semicolon
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
multiline_comment|/* wave sample stuff */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
DECL|member|fmt
DECL|member|enable
r_int
r_char
id|fmt
comma
id|enable
suffix:semicolon
multiline_comment|/* hardware channel */
DECL|member|channel
r_struct
id|cs_channel
op_star
id|channel
suffix:semicolon
DECL|member|pringbuf
r_int
id|pringbuf
suffix:semicolon
multiline_comment|/* Software ring slot */
DECL|member|ppingbuf
r_int
id|ppingbuf
suffix:semicolon
multiline_comment|/* Hardware ring slot */
DECL|member|pbuf
r_void
op_star
id|pbuf
suffix:semicolon
multiline_comment|/* 4K hardware DMA buffer */
multiline_comment|/* OSS buffer management stuff */
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
DECL|member|dma_handle
id|dma_addr_t
id|dma_handle
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
multiline_comment|/* our buffer acts like a circular ring */
DECL|member|hwptr
r_int
id|hwptr
suffix:semicolon
multiline_comment|/* where dma last started, updated by update_ptr */
DECL|member|swptr
r_int
id|swptr
suffix:semicolon
multiline_comment|/* where driver last clear/filled, updated by read/write */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* bytes to be comsumed or been generated by dma machine */
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
multiline_comment|/* total bytes dmaed by hardware */
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* number of over/underruns */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* put process on wait queue when no more space in buffer */
multiline_comment|/* redundant, but makes calculations easier */
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
multiline_comment|/* OSS stuff */
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
DECL|member|endcleared
r_int
id|endcleared
suffix:colon
l_int|1
suffix:semicolon
DECL|member|update_flag
r_int
id|update_flag
suffix:semicolon
DECL|member|ossfragshift
r_int
id|ossfragshift
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|dmabuf
)brace
id|dmabuf
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cs_card
r_struct
id|cs_card
(brace
DECL|member|channel
r_struct
id|cs_channel
id|channel
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* We keep cs461x cards in a linked list */
DECL|member|devs
r_struct
id|list_head
id|devs
suffix:semicolon
multiline_comment|/* The cs461x has a certain amount of cross channel interaction&n;&t;   so we use a single per card lock */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* PCI device stuff */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
DECL|member|pctl
DECL|member|cctl
r_int
r_int
id|pctl
comma
id|cctl
suffix:semicolon
multiline_comment|/* Hardware DMA flag sets */
multiline_comment|/* soundcore stuff */
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
multiline_comment|/* structures for abstraction of hardware facilities, codecs, banks and channels*/
DECL|member|ac97_codec
r_struct
id|ac97_codec
op_star
id|ac97_codec
(braket
id|NR_AC97
)braket
suffix:semicolon
DECL|member|states
r_struct
id|cs_state
op_star
id|states
(braket
id|NR_HW_CH
)braket
suffix:semicolon
DECL|member|ac97_features
id|u16
id|ac97_features
suffix:semicolon
DECL|member|amplifier
r_int
id|amplifier
suffix:semicolon
multiline_comment|/* Amplifier control */
DECL|member|amplifier_ctrl
r_void
(paren
op_star
id|amplifier_ctrl
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|active
r_int
id|active
suffix:semicolon
multiline_comment|/* Active clocking */
DECL|member|active_ctrl
r_void
(paren
op_star
id|active_ctrl
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* hardware resources */
DECL|member|ba0_addr
r_int
r_int
id|ba0_addr
suffix:semicolon
DECL|member|ba1_addr
r_int
r_int
id|ba1_addr
suffix:semicolon
DECL|member|irq
id|u32
id|irq
suffix:semicolon
multiline_comment|/* mappings */
DECL|member|ba0
r_void
op_star
id|ba0
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|data0
id|u8
op_star
id|data0
suffix:semicolon
DECL|member|data1
id|u8
op_star
id|data1
suffix:semicolon
DECL|member|pmem
id|u8
op_star
id|pmem
suffix:semicolon
DECL|member|reg
id|u8
op_star
id|reg
suffix:semicolon
DECL|member|name
)brace
id|name
suffix:semicolon
DECL|member|idx
id|u8
op_star
id|idx
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ba1
)brace
id|ba1
suffix:semicolon
multiline_comment|/* Function support */
DECL|member|alloc_pcm_channel
r_struct
id|cs_channel
op_star
(paren
op_star
id|alloc_pcm_channel
)paren
(paren
r_struct
id|cs_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_pcm_channel
r_struct
id|cs_channel
op_star
(paren
op_star
id|alloc_rec_pcm_channel
)paren
(paren
r_struct
id|cs_card
op_star
)paren
suffix:semicolon
DECL|member|free_pcm_channel
r_void
(paren
op_star
id|free_pcm_channel
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
id|chan
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|devs
)paren
suffix:semicolon
r_static
r_int
id|cs_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|cs_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|cs_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
id|loff_t
id|cs_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
suffix:semicolon
DECL|function|ld2
r_extern
id|__inline__
r_int
id|ld2
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10000
)paren
(brace
id|x
op_rshift_assign
l_int|16
suffix:semicolon
id|r
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x100
)paren
(brace
id|x
op_rshift_assign
l_int|8
suffix:semicolon
id|r
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10
)paren
(brace
id|x
op_rshift_assign
l_int|4
suffix:semicolon
id|r
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|4
)paren
(brace
id|x
op_rshift_assign
l_int|2
suffix:semicolon
id|r
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|2
)paren
id|r
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; *  common I/O routines&n; */
DECL|function|cs461x_poke
r_static
r_void
id|cs461x_poke
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
(brace
id|writel
c_func
(paren
id|val
comma
id|codec-&gt;ba1.idx
(braket
(paren
id|reg
op_rshift
l_int|16
)paren
op_amp
l_int|3
)braket
op_plus
(paren
id|reg
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
DECL|function|cs461x_peek
r_static
r_int
r_int
id|cs461x_peek
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
)paren
(brace
r_return
id|readl
c_func
(paren
id|codec-&gt;ba1.idx
(braket
(paren
id|reg
op_rshift
l_int|16
)paren
op_amp
l_int|3
)braket
op_plus
(paren
id|reg
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
DECL|function|cs461x_pokeBA0
r_static
r_void
id|cs461x_pokeBA0
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
(brace
id|writel
c_func
(paren
id|val
comma
id|codec-&gt;ba0
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|cs461x_peekBA0
r_static
r_int
r_int
id|cs461x_peekBA0
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
)paren
(brace
r_return
id|readl
c_func
(paren
id|codec-&gt;ba0
op_plus
id|reg
)paren
suffix:semicolon
)brace
r_static
id|u16
id|cs_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
suffix:semicolon
r_static
r_void
id|cs_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
suffix:semicolon
DECL|function|cs_alloc_pcm_channel
r_static
r_struct
id|cs_channel
op_star
id|cs_alloc_pcm_channel
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|num
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|cs_alloc_rec_pcm_channel
r_static
r_struct
id|cs_channel
op_star
id|cs_alloc_rec_pcm_channel
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|num
op_assign
l_int|0
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|cs_free_pcm_channel
r_static
r_void
id|cs_free_pcm_channel
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|channel
)paren
(brace
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|state
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|used
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set playback sample rate */
DECL|function|cs_set_dac_rate
r_static
r_int
r_int
id|cs_set_dac_rate
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|tmp1
comma
id|tmp2
suffix:semicolon
r_int
r_int
id|phiIncr
suffix:semicolon
r_int
r_int
id|correctionPerGOF
comma
id|correctionPerSec
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the values used to drive the actual sample rate conversion.&n;&t; *  The following formulas are being computed, using inline assembly&n;&t; *  since we need to use 64 bit arithmetic to compute the values:&n;&t; *&n;&t; *  phiIncr = floor((Fs,in * 2^26) / Fs,out)&n;&t; *  correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /&n;         *                                   GOF_PER_SEC)&n;         *  ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -M&n;         *                       GOF_PER_SEC * correctionPerGOF&n;&t; *&n;&t; *  i.e.&n;&t; *&n;&t; *  phiIncr:other = dividend:remainder((Fs,in * 2^26) / Fs,out)&n;&t; *  correctionPerGOF:correctionPerSec =&n;&t; *      dividend:remainder(ulOther / GOF_PER_SEC)&n;&t; */
id|tmp1
op_assign
id|rate
op_lshift
l_int|16
suffix:semicolon
id|phiIncr
op_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|tmp1
op_sub_assign
id|phiIncr
op_star
l_int|48000
suffix:semicolon
id|tmp1
op_lshift_assign
l_int|10
suffix:semicolon
id|phiIncr
op_lshift_assign
l_int|10
suffix:semicolon
id|tmp2
op_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|phiIncr
op_add_assign
id|tmp2
suffix:semicolon
id|tmp1
op_sub_assign
id|tmp2
op_star
l_int|48000
suffix:semicolon
id|correctionPerGOF
op_assign
id|tmp1
op_div
id|GOF_PER_SEC
suffix:semicolon
id|tmp1
op_sub_assign
id|correctionPerGOF
op_star
id|GOF_PER_SEC
suffix:semicolon
id|correctionPerSec
op_assign
id|tmp1
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill in the SampleRateConverter control block.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|state-&gt;card
comma
id|BA1_PSRC
comma
(paren
(paren
id|correctionPerSec
op_lshift
l_int|16
)paren
op_amp
l_int|0xFFFF0000
)paren
op_or
(paren
id|correctionPerGOF
op_amp
l_int|0xFFFF
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|state-&gt;card
comma
id|BA1_PPI
comma
id|phiIncr
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
)paren
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
r_return
id|rate
suffix:semicolon
)brace
multiline_comment|/* set recording sample rate */
DECL|function|cs_set_adc_rate
r_static
r_int
r_int
id|cs_set_adc_rate
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|phiIncr
comma
id|coeffIncr
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
r_int
r_int
id|correctionPerGOF
comma
id|correctionPerSec
comma
id|initialDelay
suffix:semicolon
r_int
r_int
id|frameGroupLength
comma
id|cnt
suffix:semicolon
multiline_comment|/*&n;&t; *  We can only decimate by up to a factor of 1/9th the hardware rate.&n;&t; *  Correct the value if an attempt is made to stray outside that limit.&n;&t; */
r_if
c_cond
(paren
(paren
id|rate
op_star
l_int|9
)paren
OL
l_int|48000
)paren
id|rate
op_assign
l_int|48000
op_div
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; *  We can not capture at at rate greater than the Input Rate (48000).&n;&t; *  Return an error if an attempt is made to stray outside that limit.&n;&t; */
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the values used to drive the actual sample rate conversion.&n;&t; *  The following formulas are being computed, using inline assembly&n;&t; *  since we need to use 64 bit arithmetic to compute the values:&n;&t; *&n;&t; *     coeffIncr = -floor((Fs,out * 2^23) / Fs,in)&n;&t; *     phiIncr = floor((Fs,in * 2^26) / Fs,out)&n;&t; *     correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /&n;&t; *                                GOF_PER_SEC)&n;&t; *     correctionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -&n;&t; *                          GOF_PER_SEC * correctionPerGOF&n;&t; *     initialDelay = ceil((24 * Fs,in) / Fs,out)&n;&t; *&n;&t; * i.e.&n;&t; *&n;&t; *     coeffIncr = neg(dividend((Fs,out * 2^23) / Fs,in))&n;&t; *     phiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out)&n;&t; *     correctionPerGOF:correctionPerSec =&n;&t; * &t;    dividend:remainder(ulOther / GOF_PER_SEC)&n;&t; *     initialDelay = dividend(((24 * Fs,in) + Fs,out - 1) / Fs,out)&n;&t; */
id|tmp1
op_assign
id|rate
op_lshift
l_int|16
suffix:semicolon
id|coeffIncr
op_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|tmp1
op_sub_assign
id|coeffIncr
op_star
l_int|48000
suffix:semicolon
id|tmp1
op_lshift_assign
l_int|7
suffix:semicolon
id|coeffIncr
op_lshift_assign
l_int|7
suffix:semicolon
id|coeffIncr
op_add_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|coeffIncr
op_xor_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|coeffIncr
op_increment
suffix:semicolon
id|tmp1
op_assign
l_int|48000
op_lshift
l_int|16
suffix:semicolon
id|phiIncr
op_assign
id|tmp1
op_div
id|rate
suffix:semicolon
id|tmp1
op_sub_assign
id|phiIncr
op_star
id|rate
suffix:semicolon
id|tmp1
op_lshift_assign
l_int|10
suffix:semicolon
id|phiIncr
op_lshift_assign
l_int|10
suffix:semicolon
id|tmp2
op_assign
id|tmp1
op_div
id|rate
suffix:semicolon
id|phiIncr
op_add_assign
id|tmp2
suffix:semicolon
id|tmp1
op_sub_assign
id|tmp2
op_star
id|rate
suffix:semicolon
id|correctionPerGOF
op_assign
id|tmp1
op_div
id|GOF_PER_SEC
suffix:semicolon
id|tmp1
op_sub_assign
id|correctionPerGOF
op_star
id|GOF_PER_SEC
suffix:semicolon
id|correctionPerSec
op_assign
id|tmp1
suffix:semicolon
id|initialDelay
op_assign
(paren
(paren
l_int|48000
op_star
l_int|24
)paren
op_plus
id|rate
op_minus
l_int|1
)paren
op_div
id|rate
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill in the VariDecimate control block.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CSRC
comma
(paren
(paren
id|correctionPerSec
op_lshift
l_int|16
)paren
op_amp
l_int|0xFFFF0000
)paren
op_or
(paren
id|correctionPerGOF
op_amp
l_int|0xFFFF
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCI
comma
id|coeffIncr
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CD
comma
(paren
(paren
(paren
id|BA1_VARIDEC_BUF_1
op_plus
(paren
id|initialDelay
op_lshift
l_int|2
)paren
)paren
op_lshift
l_int|16
)paren
op_amp
l_int|0xFFFF0000
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CPI
comma
id|phiIncr
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Figure out the frame group length for the write back task.  Basically,&n;&t; *  this is just the factors of 24000 (2^6*3*5^3) that are not present in&n;&t; *  the output sample rate.&n;&t; */
id|frameGroupLength
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|2
suffix:semicolon
id|cnt
op_le
l_int|64
suffix:semicolon
id|cnt
op_mul_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|rate
op_div
id|cnt
)paren
op_star
id|cnt
)paren
op_ne
id|rate
)paren
id|frameGroupLength
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|rate
op_div
l_int|3
)paren
op_star
l_int|3
)paren
op_ne
id|rate
)paren
(brace
id|frameGroupLength
op_mul_assign
l_int|3
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|5
suffix:semicolon
id|cnt
op_le
l_int|125
suffix:semicolon
id|cnt
op_mul_assign
l_int|5
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|rate
op_div
id|cnt
)paren
op_star
id|cnt
)paren
op_ne
id|rate
)paren
id|frameGroupLength
op_mul_assign
l_int|5
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the WriteBack control block.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CFG1
comma
id|frameGroupLength
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CFG2
comma
(paren
l_int|0x00800000
op_or
id|frameGroupLength
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCST
comma
l_int|0x0000FFFF
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CSPB
comma
(paren
(paren
l_int|65536
op_star
id|rate
)paren
op_div
l_int|24000
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
(paren
id|BA1_CSPB
op_plus
l_int|4
)paren
comma
l_int|0x0000FFFF
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
r_return
id|rate
suffix:semicolon
)brace
multiline_comment|/* prepare channel attributes for playback */
DECL|function|cs_play_setup
r_static
r_void
id|cs_play_setup
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|tmp
comma
id|tmp1
suffix:semicolon
id|tmp1
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
)paren
id|tmp1
op_rshift_assign
l_int|1
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PVOL
comma
l_int|0x80008000
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PBA
comma
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;pbuf
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PDTC
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x000003FF
suffix:semicolon
id|tmp
op_or_assign
id|tmp1
op_minus
l_int|1
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PDTC
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PFIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000F03F
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
)paren
(brace
id|tmp
op_or_assign
l_int|0x00002000
suffix:semicolon
)brace
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PFIE
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* prepare channel attributes for recording */
DECL|function|cs_rec_setup
r_static
r_void
id|cs_rec_setup
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
multiline_comment|/* set the attenuation to 0dB */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CVOL
comma
l_int|0x80008000
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CBA
comma
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;pbuf
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* get current playback/recording dma buffer pointer (byte offset from LBA),&n;   called with spinlock held! */
DECL|function|cs_get_dma_addr
r_extern
id|__inline__
r_int
id|cs_get_dma_addr
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_assign
id|dmabuf-&gt;pringbuf
op_star
l_int|2048
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|resync_dma_ptrs
r_static
r_void
id|resync_dma_ptrs
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|dmabuf-&gt;swptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ppingbuf
op_assign
id|dmabuf-&gt;pringbuf
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ppingbuf
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
(brace
id|memset
c_func
(paren
id|dmabuf-&gt;pbuf
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
id|dmabuf-&gt;pbuf
comma
l_int|0x80
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop recording (lock held) */
DECL|function|__stop_adc
r_extern
id|__inline__
r_void
id|__stop_adc
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|ADC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;mapped
op_logical_or
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
)paren
op_logical_and
id|dmabuf-&gt;ready
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|ADC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF
suffix:semicolon
id|tmp
op_or_assign
id|card-&gt;cctl
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* stop playback (lock held) */
DECL|function|__stop_dac
r_extern
id|__inline__
r_void
id|__stop_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|DAC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;mapped
op_logical_or
id|dmabuf-&gt;count
OG
l_int|0
)paren
op_logical_and
id|dmabuf-&gt;ready
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|DAC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF
suffix:semicolon
id|tmp
op_or_assign
id|card-&gt;pctl
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER (15-PAGE_SHIFT)
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1
multiline_comment|/* allocate DMA buffer, playback and recording buffer should be allocated seperately */
DECL|function|alloc_dmabuf
r_static
r_int
id|alloc_dmabuf
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
multiline_comment|/* alloc as big a chunk as we can */
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
comma
id|order
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;cs461x: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|rawbuf
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;ready
op_assign
id|dmabuf-&gt;mapped
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;rawbuf
op_assign
id|rawbuf
suffix:semicolon
id|dmabuf-&gt;buforder
op_assign
id|order
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free DMA buffer */
DECL|function|dealloc_dmabuf
r_static
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
(brace
multiline_comment|/* undo marking the pages as reserved */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
comma
id|dmabuf-&gt;rawbuf
comma
id|dmabuf-&gt;dma_handle
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|bytepersec
suffix:semicolon
r_int
id|bufsize
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer if not allocated yet */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;rawbuf
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* FIXME: figure out all this OSS fragment stuff */
id|bytepersec
op_assign
id|dmabuf-&gt;rate
op_lshift
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|bufsize
op_assign
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragshift
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1000
op_lshift
id|dmabuf-&gt;ossfragshift
)paren
OL
id|bytepersec
)paren
id|dmabuf-&gt;fragshift
op_assign
id|ld2
c_func
(paren
id|bytepersec
op_div
l_int|1000
)paren
suffix:semicolon
r_else
id|dmabuf-&gt;fragshift
op_assign
id|dmabuf-&gt;ossfragshift
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lets hand out reasonable big ass buffers by default */
id|dmabuf-&gt;fragshift
op_assign
(paren
id|dmabuf-&gt;buforder
op_plus
id|PAGE_SHIFT
op_minus
l_int|2
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;numfrag
op_assign
id|bufsize
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
r_while
c_loop
(paren
id|dmabuf-&gt;numfrag
template_param
l_int|3
)paren
(brace
id|dmabuf-&gt;fragshift
op_decrement
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
id|bufsize
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
)brace
id|dmabuf-&gt;fragsize
op_assign
l_int|1
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_ge
l_int|4
op_logical_and
id|dmabuf-&gt;ossmaxfrags
OL
id|dmabuf-&gt;numfrag
)paren
id|dmabuf-&gt;numfrag
op_assign
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
id|dmabuf-&gt;fragsize
op_rshift
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
id|dmabuf-&gt;numfrag
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now set up the ring &n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
(brace
id|cs_rec_setup
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|cs_play_setup
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* set the ready flag for the dma buffer */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;cs461x: prog_dmabuf, sample rate = %d, format = %d, numfrag = %d, &quot;
l_string|&quot;fragsize = %d dmasize = %d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
comma
id|dmabuf-&gt;fmt
comma
id|dmabuf-&gt;numfrag
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_clear_tail
r_static
r_void
id|cs_clear_tail
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_or
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* It seems that we have to set the current state to TASK_INTERRUPTIBLE&n;&t;&t;   every time to make the process really go to sleep */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
id|dmabuf-&gt;rate
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|tmo
op_add_assign
(paren
l_int|2048
op_star
id|HZ
)paren
op_div
id|dmabuf-&gt;rate
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
id|tmo
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: drain_dac, dma timeout? %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* update buffer manangement pointers, especially, dmabuf-&gt;count and dmabuf-&gt;hwptr */
DECL|function|cs_update_ptr
r_static
r_void
id|cs_update_ptr
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|hwptr
comma
id|swptr
suffix:semicolon
r_int
id|clear_cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|diff
suffix:semicolon
r_int
r_char
id|silence
suffix:semicolon
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|cs_get_dma_addr
c_func
(paren
id|state
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
template_param
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun, we have no way to recover&n;&t;&t;&t;&t;   it here, just stop the machine and let the process force hwptr&n;&t;&t;&t;&t;   and swptr to sync */
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;endcleared
)paren
(brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|silence
op_assign
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
(brace
id|clear_cnt
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|swptr
op_plus
id|clear_cnt
)paren
OG
id|dmabuf-&gt;dmasize
)paren
id|clear_cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
id|memset
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|silence
comma
id|clear_cnt
)paren
suffix:semicolon
id|dmabuf-&gt;endcleared
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_div
l_int|2
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
template_param
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun, we have no way to recover&n;&t;&t;&t;&t;   it here, just stop the machine and let the process force hwptr&n;&t;&t;&t;&t;   and swptr to sync */
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_div
l_int|2
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|cs_record_interrupt
r_static
r_void
id|cs_record_interrupt
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
id|memcpy
c_func
(paren
id|state-&gt;dmabuf.rawbuf
op_plus
(paren
l_int|2048
op_star
id|state-&gt;dmabuf.pringbuf
op_increment
)paren
comma
id|state-&gt;dmabuf.pbuf
op_plus
l_int|2048
op_star
id|state-&gt;dmabuf.ppingbuf
op_increment
comma
l_int|2048
)paren
suffix:semicolon
id|state-&gt;dmabuf.ppingbuf
op_and_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;dmabuf.pringbuf
op_ge
(paren
id|PAGE_SIZE
op_lshift
id|state-&gt;dmabuf.buforder
)paren
op_div
l_int|2048
)paren
(brace
id|state-&gt;dmabuf.pringbuf
op_assign
l_int|0
suffix:semicolon
)brace
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
DECL|function|cs_play_interrupt
r_static
r_void
id|cs_play_interrupt
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
id|memcpy
c_func
(paren
id|state-&gt;dmabuf.pbuf
op_plus
l_int|2048
op_star
id|state-&gt;dmabuf.ppingbuf
op_increment
comma
id|state-&gt;dmabuf.rawbuf
op_plus
(paren
l_int|2048
op_star
id|state-&gt;dmabuf.pringbuf
op_increment
)paren
comma
l_int|2048
)paren
suffix:semicolon
id|state-&gt;dmabuf.ppingbuf
op_and_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;dmabuf.pringbuf
op_ge
(paren
id|PAGE_SIZE
op_lshift
id|state-&gt;dmabuf.buforder
)paren
op_div
l_int|2048
)paren
(brace
id|state-&gt;dmabuf.pringbuf
op_assign
l_int|0
suffix:semicolon
)brace
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
DECL|function|cs_interrupt
r_static
r_void
id|cs_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|dev_id
suffix:semicolon
multiline_comment|/* Single channel card */
r_struct
id|cs_state
op_star
id|recstate
op_assign
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|state
suffix:semicolon
r_struct
id|cs_state
op_star
id|playstate
op_assign
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|state
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_HISR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x7fffffff
)paren
op_eq
l_int|0
)paren
(brace
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_CHGM
op_or
id|HICR_IEV
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|HISR_VC0
)paren
op_logical_and
id|playstate
op_logical_and
id|playstate-&gt;dmabuf.ready
)paren
(brace
id|cs_play_interrupt
c_func
(paren
id|playstate
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|HISR_VC1
)paren
op_logical_and
id|recstate
op_logical_and
id|recstate-&gt;dmabuf.ready
)paren
(brace
id|cs_record_interrupt
c_func
(paren
id|recstate
)paren
suffix:semicolon
)brace
multiline_comment|/* clear &squot;em */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_CHGM
op_or
id|HICR_IEV
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|cs_llseek
r_static
id|loff_t
id|cs_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be copied to&n;   the user&squot;s buffer.  it is filled by the dma machine and drained by this loop. */
DECL|function|cs_read
r_static
id|ssize_t
id|cs_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_read called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer overrun, we are recovering from sleep_on_timeout,&n;&t;&t;&t;   resync hwptr and swptr, make process flush the buffer */
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|cnt
)paren
id|cnt
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
multiline_comment|/* buffer is empty, start the dma machine and wait for data to be&n;&t;&t;&t;   recorded */
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be dma to&n;   the soundcard.  it is drained by the dma machine and filled by this loop. */
DECL|function|cs_write
r_static
id|ssize_t
id|cs_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_write called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun, we are recovering from sleep_on_timeout,&n;&t;&t;&t;   resync hwptr and swptr */
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_plus
id|cnt
OG
id|dmabuf-&gt;dmasize
)paren
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
multiline_comment|/* buffer is full, start the dma machine and wait for data to be&n;&t;&t;&t;   played */
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|cnt
suffix:semicolon
id|dmabuf-&gt;endcleared
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs_poll
r_static
r_int
r_int
id|cs_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_ge
id|dmabuf-&gt;count
op_plus
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n; * We let users mmap the ring buffer. Its not the real DMA buffer but&n; * that side of the code is hidden in the IRQ handling. We do a software&n; * emulation of DMA from a 64K or so buffer into a 2K FIFO.&n; * (the hardware probably deserves a moan here but Crystal send me nice&n; * toys ;)).&n; */
DECL|function|cs_mmap
r_static
r_int
id|cs_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_ioctl
r_static
r_int
id|cs_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
comma
id|mapped
comma
id|ret
suffix:semicolon
id|mapped
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|dmabuf-&gt;mapped
)paren
op_logical_or
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|dmabuf-&gt;mapped
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_ioctl, command = %2d, arg = 0x%08x&bslash;n&quot;
comma
id|_IOC_NR
c_func
(paren
id|cmd
)paren
comma
id|arg
ques
c_cond
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
multiline_comment|/* FIXME: spin_lock ? */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|drain_dac
c_func
(paren
id|state
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* set smaple rate */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|cs_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|cs_set_adc_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* set stereo or mono channel */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
r_return
id|put_user
c_func
(paren
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Needs extra work to support this */
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask of supported sample format*/
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Select sample format */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_QUERY
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
multiline_comment|/* || val==AFMT_U8*/
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_16BIT
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_16BIT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
(brace
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_else
r_return
id|put_user
c_func
(paren
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|1
)paren
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/* FIXME: the same as RESET ?? */
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_switch
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
)paren
(brace
r_case
l_int|1
suffix:colon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|12
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Fragments must be 2K long */
id|dmabuf-&gt;ossfragshift
op_assign
l_int|11
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|dmabuf-&gt;enable
)paren
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dmabuf-&gt;enable
)paren
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_MAPINBUF
suffix:colon
r_case
id|SNDCTL_DSP_MAPOUTBUF
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;AMP control - null AMP&n; */
DECL|function|amp_none
r_static
r_void
id|amp_none
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
)brace
multiline_comment|/*&n; *&t;Crystal EAPD mode&n; */
DECL|function|amp_voyetra
r_static
r_void
id|amp_voyetra
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
multiline_comment|/* Manage the EAPD bit on the Crystal 4297 and the Analog AD1885 */
r_int
id|old
op_assign
id|card-&gt;amplifier
suffix:semicolon
id|card-&gt;amplifier
op_add_assign
id|change
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;amplifier
op_logical_and
op_logical_neg
id|old
)paren
(brace
multiline_comment|/* Turn the EAPD amp on */
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_or
l_int|0x8000
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|old
op_logical_and
op_logical_neg
id|card-&gt;amplifier
)paren
(brace
multiline_comment|/* Turn the EAPD amp off */
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
op_complement
l_int|0x8000
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Untested&n; */
macro_line|#if 0
r_static
r_void
id|amp_voyetra_4294
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
r_struct
id|ac97_codec
op_star
id|c
op_assign
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
id|card-&gt;amplifier
op_add_assign
id|change
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;amplifier
)paren
(brace
multiline_comment|/* Switch the GPIO pins 7 and 8 to open drain */
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x4C
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x4C
)paren
op_amp
l_int|0xFE7F
)paren
suffix:semicolon
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x4E
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x4E
)paren
op_or
l_int|0x0180
)paren
suffix:semicolon
multiline_comment|/* Now wake the AMP (this might be backwards) */
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x54
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x54
)paren
op_amp
op_complement
l_int|0x0180
)paren
suffix:semicolon
)brace
r_else
(brace
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x54
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x54
)paren
op_or
l_int|0x0180
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Handle the CLKRUN on a thinkpad. We must disable CLKRUN support&n; *&t;whenever we need to beat on the chip.&n; *&n; *&t;The original idea and code for this hack comes from David Kaiser at&n; *&t;Linuxcare. Perhaps one day Crystal will document their chips well&n; *&t;enough to make them useful.&n; */
DECL|function|clkrun_hack
r_static
r_void
id|clkrun_hack
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
r_struct
id|pci_dev
op_star
id|acpi_dev
suffix:semicolon
id|u16
id|control
suffix:semicolon
id|u8
id|pp
suffix:semicolon
r_int
r_int
id|port
suffix:semicolon
r_int
id|old
op_assign
id|card-&gt;amplifier
suffix:semicolon
id|card-&gt;amplifier
op_add_assign
id|change
suffix:semicolon
id|acpi_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82371AB_3
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_dev
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Not a thinkpad thats for sure */
multiline_comment|/* Find the control port */
id|pci_read_config_byte
c_func
(paren
id|acpi_dev
comma
l_int|0x41
comma
op_amp
id|pp
)paren
suffix:semicolon
id|port
op_assign
id|pp
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* Read ACPI port */
id|control
op_assign
id|inw
c_func
(paren
id|port
op_plus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* Flip CLKRUN off while running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;amplifier
op_logical_and
id|old
)paren
(brace
id|outw
c_func
(paren
id|control
op_or
l_int|0x2000
comma
id|port
op_plus
l_int|0x10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;amplifier
op_logical_and
op_logical_neg
id|old
)paren
(brace
id|outw
c_func
(paren
id|control
op_amp
op_complement
l_int|0x2000
comma
id|port
op_plus
l_int|0x10
)paren
suffix:semicolon
)brace
)brace
DECL|function|cs_open
r_static
r_int
id|cs_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
macro_line|#ifndef CS46XX_ENABLE_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|list
op_assign
id|devs.next
suffix:semicolon
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|devs
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|card
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|cs_card
comma
id|devs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;states
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cs_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;pbuf
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;pbuf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_goto
id|found_virt
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* no more virtual channel avaiable */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|found_virt
suffix:colon
multiline_comment|/* found a free virtual channel, allocate hardware channels */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|dmabuf-&gt;channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;channel
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Now turn on external AMP if needed */
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|state-&gt;card
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|state-&gt;card
comma
l_int|1
)paren
suffix:semicolon
id|dmabuf-&gt;channel-&gt;state
op_assign
id|state
suffix:semicolon
multiline_comment|/* initialize the virtual channel */
id|state-&gt;virt
op_assign
id|i
suffix:semicolon
id|state-&gt;magic
op_assign
id|CS_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
multiline_comment|/* set default sample format. According to OSS Programmer&squot;s Guide  /dev/dsp&n;&t;   should be default to unsigned 8-bits, mono, with sample rate 8kHz and&n;&t;   /dev/dspW will accept 16-bits sample */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* Output is 16bit only mono or stereo */
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_MASK
suffix:semicolon
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_16BIT
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|cs_set_dac_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
multiline_comment|/* Input is 16bit stereo only */
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_MASK
suffix:semicolon
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_16BIT
op_or
id|CS_FMT_STEREO
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|cs_set_adc_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
)brace
id|state-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_release
r_static
r_int
id|cs_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* FIXME :.. */
id|cs_clear_tail
c_func
(paren
id|state
)paren
suffix:semicolon
id|drain_dac
c_func
(paren
id|state
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
)brace
multiline_comment|/* stop DMA state machine and free DMA buffers/channels */
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;channel-&gt;num
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;channel-&gt;num
)paren
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|state-&gt;dmabuf.pbuf
)paren
suffix:semicolon
multiline_comment|/* we&squot;re covered by the open_sem */
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|state-&gt;open_mode
op_and_assign
(paren
op_complement
id|file-&gt;f_mode
)paren
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
multiline_comment|/* Now turn off external AMP if needed */
id|state-&gt;card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|state-&gt;card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|state-&gt;card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cs461x_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|cs461x_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs_llseek
comma
id|read
suffix:colon
id|cs_read
comma
id|write
suffix:colon
id|cs_write
comma
id|poll
suffix:colon
id|cs_poll
comma
id|ioctl
suffix:colon
id|cs_ioctl
comma
id|mmap
suffix:colon
id|cs_mmap
comma
id|open
suffix:colon
id|cs_open
comma
id|release
suffix:colon
id|cs_release
comma
)brace
suffix:semicolon
multiline_comment|/* Write AC97 codec registers */
DECL|function|cs_ac97_get
r_static
id|u16
id|cs_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address&n;&t; *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97 &n;&t; *  3. Write ACCTL = Control Register = 460h for initiating the write&n;&t; *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h&n;&t; *  5. if DCV not cleared, break and return error&n;&t; *  6. Read ACSTS = Status Register = 464h, check VSTS bit&n;&t; */
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSDA
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Setup the AC97 control registers on the CS461x to send the&n;&t; *  appropriate command to the AC97 to perform the read.&n;&t; *  ACCAD = Command Address Register = 46Ch&n;&t; *  ACCDA = Command Data Register = 470h&n;&t; *  ACCTL = Control Register = 460h&n;&t; *  set DCV - will clear when process completed&n;&t; *  set CRW - Read command&n;&t; *  set VFRM - valid frame enabled&n;&t; *  set ESYN - ASYNC generation enabled&n;&t; *  set RSTN - ARST# inactive, AC97 codec not reset&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCAD
comma
id|reg
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCDA
comma
l_int|0
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_DCV
op_or
id|ACCTL_CRW
op_or
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait for the read to occur.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|500
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, we want to wait for a short time.&n;&t; &t; */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Now, check to see if the read has completed.&n;&t;&t; *  ACCTL = 460h, DCV should be reset by now and 460h = 17h&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure the read completed.&n;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: AC&squot;97 read problem (ACCTL_DCV), reg = 0x%x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Wait for the valid status bit to go active.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|100
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Read the AC97 status register.&n;&t;&t; *  ACSTS = Status Register = 464h&n;&t;&t; *  VSTS - Valid Status&n;&t;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_VSTS
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure we got valid status.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_VSTS
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: AC&squot;97 read problem (ACSTS_VSTS), reg = 0x%x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Read the data returned from the AC97 register.&n;&t; *  ACSDA = Status Data Register = 474h&n;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;e) reg = 0x%x, val = 0x%x, BA0_ACCAD = 0x%x&bslash;n&quot;
comma
id|reg
comma
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSDA
)paren
comma
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCAD
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSDA
)paren
suffix:semicolon
)brace
DECL|function|cs_ac97_set
r_static
r_void
id|cs_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|val
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|val2
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
id|AC97_CD_VOL
)paren
id|val2
op_assign
id|cs_ac97_get
c_func
(paren
id|dev
comma
id|AC97_CD_VOL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address&n;&t; *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97&n;&t; *  3. Write ACCTL = Control Register = 460h for initiating the write&n;&t; *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h&n;&t; *  5. if DCV not cleared, break and return error&n;&t; */
multiline_comment|/*&n;&t; *  Setup the AC97 control registers on the CS461x to send the&n;&t; *  appropriate command to the AC97 to perform the read.&n;&t; *  ACCAD = Command Address Register = 46Ch&n;&t; *  ACCDA = Command Data Register = 470h&n;&t; *  ACCTL = Control Register = 460h&n;&t; *  set DCV - will clear when process completed&n;&t; *  reset CRW - Write command&n;&t; *  set VFRM - valid frame enabled&n;&t; *  set ESYN - ASYNC generation enabled&n;&t; *  set RSTN - ARST# inactive, AC97 codec not reset&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCAD
comma
id|reg
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCDA
comma
id|val
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_DCV
op_or
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|1000
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, we want to wait for a short time.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Now, check to see if the write has completed.&n;&t;&t; *  ACCTL = 460h, DCV should be reset by now and 460h = 07h&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure the write completed.&n;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: AC&squot;97 write problem, reg = 0x%x, val = 0x%x&bslash;n&quot;
comma
id|reg
comma
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Adjust power if the mixer is selected/deselected according&n;&t; *&t;to the CD.&n;&t; *&n;&t; *&t;IF the CD is a valid input source (mixer or direct) AND&n;&t; *&t;&t;the CD is not muted THEN power is needed&n;&t; *&n;&t; *&t;We do two things. When record select changes the input to&n;&t; *&t;add/remove the CD we adjust the power count if the CD is&n;&t; *&t;unmuted.&n;&t; *&n;&t; *&t;When the CD mute changes we adjust the power level if the&n;&t; *&t;CD was a valid input.&n;&t; *&n;&t; *&t;We also check for CD volume != 0, as the CD mute isn&squot;t&n;&t; *&t;normally tweaked from userspace.&n;&t; */
multiline_comment|/* CD mute change ? */
r_if
c_cond
(paren
id|reg
op_eq
id|AC97_CD_VOL
)paren
(brace
multiline_comment|/* Mute bit change ? */
r_if
c_cond
(paren
(paren
id|val2
op_xor
id|val
)paren
op_amp
l_int|0x8000
op_logical_or
(paren
(paren
id|val2
op_eq
l_int|0x1f1f
op_logical_or
id|val
op_eq
l_int|0x1f1f
)paren
op_logical_and
id|val2
op_ne
id|val
)paren
)paren
(brace
multiline_comment|/* This is a hack but its cleaner than the alternatives.&n;&t;&t;&t;   Right now card-&gt;ac97_codec[0] might be NULL as we are&n;&t;&t;&t;   still doing codec setup. This does an early assignment&n;&t;&t;&t;   to avoid the problem if it occurs */
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Mute on */
r_if
c_cond
(paren
id|val
op_amp
l_int|0x8000
op_logical_or
id|val
op_eq
l_int|0x1f1f
)paren
(brace
id|card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Mute off power on */
id|card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OSS /dev/mixer file operation methods */
DECL|function|cs_open_mixdev
r_static
r_int
id|cs_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|devs.next
suffix:semicolon
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|devs
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|card
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|cs_card
comma
id|devs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
r_goto
id|match
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|file-&gt;private_data
op_assign
id|card-&gt;ac97_codec
(braket
id|i
)braket
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_release_mixdev
r_static
r_int
id|cs_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|devs.next
suffix:semicolon
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|devs
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|card
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|cs_card
comma
id|devs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
r_goto
id|match
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_ioctl_mixdev
r_static
r_int
id|cs_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
(paren
r_struct
id|ac97_codec
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|codec
op_member_access_from_pointer
id|mixer_ioctl
c_func
(paren
id|codec
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|cs_mixer_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|cs_mixer_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs_llseek
comma
id|ioctl
suffix:colon
id|cs_ioctl_mixdev
comma
id|open
suffix:colon
id|cs_open_mixdev
comma
id|release
suffix:colon
id|cs_release_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/* AC97 codec initialisation. */
DECL|function|cs_ac97_init
r_static
r_int
id|__init
id|cs_ac97_init
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|num_ac97
op_assign
l_int|0
suffix:semicolon
r_int
id|ready_2nd
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
suffix:semicolon
id|u16
id|eid
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|codec
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some basic codec information, other fields will be filled&n;&t;&t;   in ac97_probe_codec */
id|codec-&gt;private_data
op_assign
id|card
suffix:semicolon
id|codec-&gt;id
op_assign
id|num_ac97
suffix:semicolon
id|codec-&gt;codec_read
op_assign
id|cs_ac97_get
suffix:semicolon
id|codec-&gt;codec_write
op_assign
id|cs_ac97_set
suffix:semicolon
r_if
c_cond
(paren
id|ac97_probe_codec
c_func
(paren
id|codec
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|eid
op_assign
id|cs_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
l_int|0xFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: no codec attached ?&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_features
op_assign
id|eid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|cs_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
id|codec
suffix:semicolon
multiline_comment|/* if there is no secondary codec at all, don&squot;t probe any more */
r_if
c_cond
(paren
op_logical_neg
id|ready_2nd
)paren
r_return
id|num_ac97
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|num_ac97
suffix:semicolon
)brace
multiline_comment|/* Boot the card&n; */
DECL|function|cs461x_download
r_static
r_void
id|__init
id|cs461x_download
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
id|u32
op_star
id|src
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|counter
suffix:semicolon
r_void
op_star
id|dst
suffix:semicolon
id|dst
op_assign
id|card-&gt;ba1.idx
(braket
(paren
id|offset
op_rshift
l_int|16
)paren
op_amp
l_int|3
)braket
suffix:semicolon
id|dst
op_add_assign
(paren
id|offset
op_amp
l_int|0xFFFF
)paren
op_lshift
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|len
suffix:semicolon
id|counter
op_add_assign
l_int|4
)paren
(brace
id|writel
c_func
(paren
op_star
id|src
op_increment
comma
id|dst
op_plus
id|counter
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* 3*1024 parameter, 3.5*1024 sample, 2*3.5*1024 code */
DECL|macro|BA1_DWORD_SIZE
mdefine_line|#define BA1_DWORD_SIZE&t;&t;(13 * 1024 + 512)
DECL|macro|BA1_MEMORY_COUNT
mdefine_line|#define BA1_MEMORY_COUNT&t;3
DECL|struct|BA1struct
r_struct
id|BA1struct
(brace
r_struct
(brace
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|memory
)brace
id|memory
(braket
id|BA1_MEMORY_COUNT
)braket
suffix:semicolon
DECL|member|map
r_int
r_int
id|map
(braket
id|BA1_DWORD_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#include &quot;cs461x_image.h&quot;
DECL|function|cs461x_download_image
r_static
r_void
id|__init
id|cs461x_download_image
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|idx
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|BA1_MEMORY_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|cs461x_download
c_func
(paren
id|card
comma
op_amp
id|BA1Struct.map
(braket
id|offset
)braket
comma
id|BA1Struct.memory
(braket
id|idx
)braket
dot
id|offset
comma
id|BA1Struct.memory
(braket
id|idx
)braket
dot
id|size
)paren
suffix:semicolon
id|offset
op_add_assign
id|BA1Struct.memory
(braket
id|idx
)braket
dot
id|size
op_rshift
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Chip reset&n; */
DECL|function|cs461x_reset
r_static
r_void
id|cs461x_reset
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|idx
suffix:semicolon
multiline_comment|/*&n;&t; *  Write the reset bit of the SP control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
id|SPCR_RSTSP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Write the control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
id|SPCR_DRQEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Clear the trap registers.&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|8
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_DREG
comma
id|DREG_REGID_TRAP_SELECT
op_plus
id|idx
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_TWPR
comma
l_int|0xFFFF
)paren
suffix:semicolon
)brace
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_DREG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the frame timer to reflect the number of cycles per frame.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_FRMT
comma
l_int|0xadf
)paren
suffix:semicolon
)brace
DECL|function|cs461x_clear_serial_FIFOs
r_static
r_void
id|cs461x_clear_serial_FIFOs
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|idx
comma
id|loop
comma
id|powerdown
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; *  See if the devices are powered down.  If so, we must power them up first&n;&t; *  or they will not respond.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
)paren
)paren
op_amp
id|CLKCR1_SWCE
)paren
)paren
(brace
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
op_or
id|CLKCR1_SWCE
)paren
suffix:semicolon
id|powerdown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We want to clear out the serial port FIFOs so we don&squot;t end up playing&n;&t; *  whatever random garbage happens to be in them.  We fill the sample FIFOS&n;&t; *  with zero (silence).&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERBWP
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill all 256 sample FIFO locations.&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|256
suffix:semicolon
id|idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Make sure the previous FIFO write operation has completed.&n;&t;&t; */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|5
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_SERBST
)paren
op_amp
id|SERBST_WBSY
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_SERBST
)paren
op_amp
id|SERBST_WBSY
)paren
(brace
r_if
c_cond
(paren
id|powerdown
)paren
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Write the serial port FIFO index.&n;&t;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERBAD
comma
id|idx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Tell the serial port to load the new value into the FIFO location.&n;&t;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERBCM
comma
id|SERBCM_WRC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Now, if we powered up the devices, then power them back down again.&n;&t; *  This is kinda ugly, but should never happen.&n;&t; */
r_if
c_cond
(paren
id|powerdown
)paren
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|cs461x_powerup_dac
r_static
r_void
id|cs461x_powerup_dac
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; *  Power on the DACs on the AC97 card.  We turn off the DAC&n;&t; *  powerdown bit and write the new value of the power control&n;&t; *  register.&n;&t; */
id|tmp
op_assign
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|2
)paren
multiline_comment|/* already */
r_return
suffix:semicolon
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|tmp
op_amp
l_int|0xfdff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now, we wait until we sample a DAC ready state.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|32
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, lets wait a short while to let things settle out a&n;&t;&t; *  bit, and to prevent retrying the read too quickly.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Read the current state of the power control register.&n;&t;&t; */
r_if
c_cond
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|2
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check the status..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|2
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: powerup DAC failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|cs461x_powerup_adc
r_static
r_void
id|cs461x_powerup_adc
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; *  Power on the ADCs on the AC97 card.  We turn off the DAC&n;&t; *  powerdown bit and write the new value of the power control&n;&t; *  register.&n;&t; */
id|tmp
op_assign
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|1
)paren
multiline_comment|/* already */
r_return
suffix:semicolon
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|tmp
op_amp
l_int|0xfeff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now, we wait until we sample a ADC ready state.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|32
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, lets wait a short while to let things settle out a&n;&t;&t; *  bit, and to prevent retrying the read too quickly.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Read the current state of the power control register.&n;&t;&t; */
r_if
c_cond
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|1
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check the status..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: powerup ADC failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|cs461x_proc_start
r_static
r_void
id|cs461x_proc_start
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|cnt
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the frame timer to reflect the number of cycles per frame.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_FRMT
comma
l_int|0xadf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Turn on the run, run at frame, and DMA enable bits in the local copy of&n;&t; *  the SP control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
id|SPCR_RUN
op_or
id|SPCR_RUNFR
op_or
id|SPCR_DRQEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait until the run at frame bit resets itself in the SP control&n;&t; *  register.&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|25
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_SPCR
)paren
op_amp
id|SPCR_RUNFR
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_SPCR
)paren
op_amp
id|SPCR_RUNFR
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: SPCR_RUNFR never reset&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|cs461x_proc_stop
r_static
r_void
id|cs461x_proc_stop
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
multiline_comment|/*&n;&t; *  Turn off the run, run at frame, and DMA enable bits in the local copy of&n;&t; *  the SP control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cs_hardware_init
r_static
r_int
id|__init
id|cs_hardware_init
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
r_int
id|end_time
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/* &n;&t; *  First, blast the clock control register to zero so that the PLL starts&n;         *  out in a known state, and blast the master serial port control register&n;         *  to zero so that the serial ports also start out in a known state.&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
l_int|0
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERMC1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are in AC97 mode, then we must set the part to a host controlled&n;         *  AC-link.  Otherwise, we won&squot;t be able to bring up the link.&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERACC
comma
id|SERACC_HSP
op_or
id|SERACC_CODEC_TYPE_1_03
)paren
suffix:semicolon
multiline_comment|/* 1.03 card */
multiline_comment|/* cs461x_pokeBA0(card, BA0_SERACC, SERACC_HSP | SERACC_CODEC_TYPE_2_0); */
multiline_comment|/* 2.00 card */
multiline_comment|/*&n;         *  Drive the ARST# pin low for a minimum of 1uS (as defined in the AC97&n;         *  spec) and then drive it high.  This is done for non AC97 modes since&n;         *  there might be logic external to the CS461x that uses the ARST# line&n;         *  for a reset.&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The first thing we do here is to enable sync generation.  As soon&n;&t; *  as we start receiving bit clock, we&squot;ll start producing the SYNC&n;&t; *  signal.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now wait for a short while to allow the AC97 part to start&n;&t; *  generating bit clock (so we don&squot;t try to start the PLL without an&n;&t; *  input clock).&n;&t; */
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* 1 should be enough ?? */
multiline_comment|/*&n;&t; *  Set the serial port timing configuration, so that&n;&t; *  the clock control circuit gets its clock from the correct place.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERMC1
comma
id|SERMC1_PTC_AC97
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Write the selected clock control setup to the hardware.  Do not turn on&n;&t; *  SWCE yet (if requested), so that the devices clocked by the output of&n;&t; *  PLL are not clocked until the PLL is stable.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_PLLCC
comma
id|PLLCC_LPF_1050_2780_KHZ
op_or
id|PLLCC_CDR_73_104_MHZ
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_PLLM
comma
l_int|0x3a
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR2
comma
id|CLKCR2_PDIVS_8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power up the PLL.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|CLKCR1_PLLP
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Wait until the PLL has stabilized.&n;&t; */
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Again 1 should be enough ?? */
multiline_comment|/*&n;&t; *  Turn on clocking of the core so that we can setup the serial ports.&n;&t; */
id|tmp
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
)paren
op_or
id|CLKCR1_SWCE
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill the serial port FIFOs with silence.&n;&t; */
id|cs461x_clear_serial_FIFOs
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the serial port FIFO pointer to the first sample in the FIFO.&n;&t; */
multiline_comment|/* cs461x_pokeBA0(card, BA0_SERBSP, 0); */
multiline_comment|/*&n;&t; *  Write the serial port configuration to the part.  The master&n;&t; *  enable bit is not set until all other values have been written.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERC1
comma
id|SERC1_SO1F_AC97
op_or
id|SERC1_SO1EN
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERC2
comma
id|SERC2_SI1F_AC97
op_or
id|SERC1_SO1EN
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERMC1
comma
id|SERMC1_PTC_AC97
op_or
id|SERMC1_MSPE
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Shouldnt be needed ?? */
multiline_comment|/*&n;&t; * Wait for the card ready signal from the AC97 card.&n;&t; */
id|end_time
op_assign
id|jiffies
op_plus
l_int|3
op_star
(paren
id|HZ
op_rshift
l_int|2
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; *  Read the AC97 status register to see if we&squot;ve seen a CODEC READY&n;&t;&t; *  signal from the AC97 card.&n;&t;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_CRDY
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|end_time
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Make sure CODEC is READY.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_CRDY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: create - never read card ready from AC&squot;97&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: it is probably not a bug, try using the CS4232 driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Assert the vaid frame signal so that we can start sending commands&n;&t; *  to the AC97 card.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait until we&squot;ve sampled input slots 3 and 4 as valid, meaning that&n;&t; *  the card is pumping ADC data across the AC-link.&n;&t; */
id|end_time
op_assign
id|jiffies
op_plus
l_int|3
op_star
(paren
id|HZ
op_rshift
l_int|2
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; *  Read the input slot valid register and see if input slots 3 and&n;&t;&t; *  4 are valid yet.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACISV
)paren
op_amp
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
op_eq
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|end_time
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Make sure input slots 3 and 4 are valid.  If not, then return&n;&t; *  an error.&n;&t; */
r_if
c_cond
(paren
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACISV
)paren
op_amp
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
op_ne
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: create - never read ISV3 &amp; ISV4 from AC&squot;97&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Now, assert valid frame and the slot 3 and 4 valid bits.  This will&n;&t; *  commense the transfer of digital audio data to the AC97 card.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACOSV
comma
id|ACOSV_SLV3
op_or
id|ACOSV_SLV4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power down the DAC and ADC.  We will power them up (if) when we need&n;&t; *  them.&n;&t; */
multiline_comment|/* cs461x_pokeBA0(card, BA0_AC97_POWERDOWN, 0x300); */
multiline_comment|/*&n;&t; *  Turn off the Processor by turning off the software clock enable flag in &n;&t; *  the clock control register.&n;&t; */
multiline_comment|/* tmp = cs461x_peekBA0(card, BA0_CLKCR1) &amp; ~CLKCR1_SWCE; */
multiline_comment|/* cs461x_pokeBA0(card, BA0_CLKCR1, tmp); */
multiline_comment|/*&n;         *  Reset the processor.&n;         */
id|cs461x_reset
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Download the image to the processor.&n;&t; */
id|cs461x_download_image
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Stop playback DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|card-&gt;pctl
op_assign
id|tmp
op_amp
l_int|0xffff0000
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
op_amp
l_int|0x0000ffff
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Stop capture DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|card-&gt;cctl
op_assign
id|tmp
op_amp
l_int|0x0000ffff
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
op_amp
l_int|0xffff0000
)paren
suffix:semicolon
multiline_comment|/* initialize AC97 codec and register /dev/mixer */
r_if
c_cond
(paren
id|cs_ac97_init
c_func
(paren
id|card
)paren
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Do we need this ?? */
id|cs461x_powerup_adc
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs461x_powerup_dac
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs461x_proc_start
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Enable interrupts on the part.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_IEV
op_or
id|HICR_CHGM
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PFIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000f03f
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PFIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* playback interrupt enable */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000003f
suffix:semicolon
id|tmp
op_or_assign
l_int|0x00000001
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* capture interrupt enable */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* install the driver, we do not allocate hardware channel nor DMA buffer now, they are defered &n;   until &quot;ACCESS&quot; time (in prog_dmabuf called by open/read/write/ioctl/mmap) */
multiline_comment|/*&n; *&t;Card subid table&n; */
DECL|struct|cs_card_type
r_struct
id|cs_card_type
(brace
DECL|member|vendor
id|u16
id|vendor
suffix:semicolon
DECL|member|id
id|u16
id|id
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|amp
r_void
(paren
op_star
id|amp
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|active
r_void
(paren
op_star
id|active
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cards
r_static
r_struct
id|cs_card_type
id|__devinitdata
id|cards
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|function|cs_probe
r_static
r_int
id|__devinit
id|cs_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
r_struct
id|cs_card_type
op_star
id|cp
op_assign
op_amp
id|cards
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs_card
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|card
)paren
)paren
suffix:semicolon
id|card-&gt;ba0_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pci_dev
comma
l_int|0
)paren
suffix:semicolon
id|card-&gt;ba1_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pci_dev
comma
l_int|1
)paren
suffix:semicolon
id|card-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|card-&gt;irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|card-&gt;magic
op_assign
id|CS_CARD_MAGIC
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Card found at 0x%08lx and 0x%08lx, IRQ %d&bslash;n&quot;
comma
id|card-&gt;ba0_addr
comma
id|card-&gt;ba1_addr
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|card-&gt;alloc_pcm_channel
op_assign
id|cs_alloc_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_pcm_channel
op_assign
id|cs_alloc_rec_pcm_channel
suffix:semicolon
id|card-&gt;free_pcm_channel
op_assign
id|cs_free_pcm_channel
suffix:semicolon
id|card-&gt;amplifier_ctrl
op_assign
id|amp_none
suffix:semicolon
id|card-&gt;active_ctrl
op_assign
id|amp_none
suffix:semicolon
r_while
c_loop
(paren
id|cp-&gt;name
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;vendor
op_eq
id|id-&gt;subvendor
op_logical_and
id|cp-&gt;id
op_eq
id|id-&gt;subdevice
)paren
(brace
id|card-&gt;amplifier_ctrl
op_assign
id|cp-&gt;amp
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;active
)paren
(brace
id|card-&gt;active_ctrl
op_assign
id|cp-&gt;active
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|cp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;name
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Unknown card (%04X:%04X) at 0x%08lx/0x%08lx, IRQ %d&bslash;n&quot;
comma
id|id-&gt;subvendor
comma
id|id-&gt;subdevice
comma
id|card-&gt;ba0_addr
comma
id|card-&gt;ba1_addr
comma
id|card-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: %s at 0x%08lx/0x%08lx, IRQ %d&bslash;n&quot;
comma
id|cp-&gt;name
comma
id|card-&gt;ba0_addr
comma
id|card-&gt;ba1_addr
comma
id|card-&gt;irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;amplifier_ctrl
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: Unsupported configuration due to lack of documentation.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|external_amp
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Crystal EAPD support forced on.&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;amplifier_ctrl
op_assign
id|amp_voyetra
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thinkpad
op_eq
l_int|1
)paren
(brace
id|card-&gt;active_ctrl
op_assign
id|clkrun_hack
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Activating CLKRUN hack for Thinkpad.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* claim our iospace and irq */
id|card-&gt;ba0
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba0_addr
comma
id|CS461X_BA0_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.data0
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_DMEM0
comma
id|CS461X_BA1_DATA0_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.data1
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_DMEM1
comma
id|CS461X_BA1_DATA1_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.pmem
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_PMEM
comma
id|CS461X_BA1_PRG_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.reg
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_REG
comma
id|CS461X_BA1_REG_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;ba0
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.data0
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.data1
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.pmem
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.reg
op_eq
l_int|0
)paren
(brace
r_goto
id|fail2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|card-&gt;irq
comma
op_amp
id|cs_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;cs461x&quot;
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: unable to allocate irq %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
r_goto
id|fail2
suffix:semicolon
)brace
multiline_comment|/* register /dev/dsp */
r_if
c_cond
(paren
(paren
id|card-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|cs461x_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: unable to register dsp&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cs_hardware_init
c_func
(paren
id|card
)paren
OL
l_int|0
)paren
(brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|pci_set_drvdata
(paren
id|pci_dev
comma
id|card
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|card-&gt;devs
comma
op_amp
id|devs
)paren
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|fail2
suffix:colon
r_if
c_cond
(paren
id|card-&gt;ba0
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.data0
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.data1
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.pmem
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.pmem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.reg
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.reg
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|cs_remove
r_static
r_void
id|__devexit
id|cs_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|pci_get_drvdata
(paren
id|pci_dev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|card-&gt;devs
)paren
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PFIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000f03f
suffix:semicolon
id|tmp
op_or_assign
l_int|0x00000010
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PFIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* playback interrupt disable */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000003f
suffix:semicolon
id|tmp
op_or_assign
l_int|0x00000011
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* capture interrupt disable */
multiline_comment|/*&n;         *  Stop playback DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
op_amp
l_int|0x0000ffff
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Stop capture DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
op_amp
l_int|0xffff0000
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Reset the processor.&n;         */
id|cs461x_reset
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs461x_proc_stop
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power down the DAC and ADC.  We will power them up (if) when we need&n;&t; *  them.&n;&t; */
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
l_int|0x300
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power down the PLL.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Turn off the Processor by turning off the software clock enable flag in &n;&t; *  the clock control register.&n;&t; */
id|tmp
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
)paren
op_amp
op_complement
id|CLKCR1_SWCE
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* free hardware resources */
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba0
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data0
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data1
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.pmem
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.reg
)paren
suffix:semicolon
multiline_comment|/* unregister audio devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Alan Cox &lt;alan@redhat.com&gt;, Jaroslav Kysela&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Crystal SoundFusion Audio Support&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|external_amp
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|thinkpad
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|cs_pci_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_CIRRUS
comma
l_int|0x6001
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|PCI_VENDOR_ID_CIRRUS
comma
l_int|0x6003
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|PCI_VENDOR_ID_CIRRUS
comma
l_int|0x6004
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|cs_pci_tbl
)paren
suffix:semicolon
DECL|variable|cs_pci_driver
r_static
r_struct
id|pci_driver
id|cs_pci_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;cs46xx&quot;
comma
id|id_table
suffix:colon
id|cs_pci_tbl
comma
id|probe
suffix:colon
id|cs_probe
comma
id|remove
suffix:colon
id|cs_remove
comma
)brace
suffix:semicolon
DECL|function|cs_init
r_static
r_int
id|__init
id|cs_init
c_func
(paren
r_void
)paren
(brace
r_int
id|foundone
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Crystal 4280/461x + AC97 Audio, version &quot;
id|DRIVER_VERSION
l_string|&quot;, &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|pci_module_init
c_func
(paren
op_amp
id|cs_pci_driver
)paren
suffix:semicolon
)brace
DECL|function|cs_exit
r_static
r_void
id|__exit
id|cs_exit
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|cs_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|cs_init
id|module_init
c_func
(paren
id|cs_init
)paren
suffix:semicolon
DECL|variable|cs_exit
id|module_exit
c_func
(paren
id|cs_exit
)paren
suffix:semicolon
eof
