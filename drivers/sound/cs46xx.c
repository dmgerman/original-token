multiline_comment|/*&n; *&t;Crystal SoundFusion CS46xx driver&n; *&n; *&t;Copyright 1998-2000 Cirrus Logic Corporation &lt;audio@crystal.cirrus.com&gt;&n; *&t;Copyright 1999-2000 Jaroslav Kysela &lt;perex@suse.cz&gt;&n; *&t;Copyright 2000 Alan Cox &lt;alan@redhat.com&gt;&n; *&n; *&t;The core of this code is taken from the ALSA project driver by &n; *&t;Jaroslav. Please send Jaroslav the credit for the driver and &n; *&t;report bugs in this port to &lt;alan@redhat.com&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *&t;Current maintainers:&n; *&t;&t;Cirrus Logic Corporation, Thomas Woller (tw)&n; *&t;&t;&t;&lt;twoller@crystal.cirrus.com&gt;&n; *&t;&t;Nils Faerber (nf)&n; *&t;&t;&t;&lt;nils@kernelconcepts.de&gt;&n; *&t;&t;Thanks to David Pollard for testing.&n; *&n; *&t;Changes:&n; *&t;20000909-nf&t;Changed cs_read, cs_write and drain_dac&n; *&t;20001025-tw&t;Separate Playback/Capture structs and buffers.&n; *&t;&t;&t;Added Scatter/Gather support for Playback.&n; *&t;&t;&t;Added Capture.&n; *&t;20001027-nf&t;Port to kernel 2.4.0-test9, some clean-ups&n; *&t;&t;&t;Start of powermanagement support (CS46XX_PM).&n; *&t;20001128-tw&t;Add module parm for default buffer order.&n; *&t;&t;&t;added DMA_GFP flag to kmalloc dma buffer allocs.&n; *&t;&t;&t;backfill silence to eliminate stuttering on&n; *&t;&t;&t;underruns.&n; *&t;20001201-tw&t;add resyncing of swptr on underruns.&n; *&t;20001205-tw-nf&t;fixed GETOSPACE ioctl() after open()&n; *&n; *&n; *&t;Status:&n; *&t;Playback/Capture supported from 8k-48k.&n; *&t;16Bit Signed LE &amp; 8Bit Unsigned, with Mono or Stereo supported.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#ifdef CS46XX_PM
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &quot;cs461x.h&quot;
multiline_comment|/* MIDI buffer sizes */
DECL|macro|CS_MIDIINBUF
mdefine_line|#define CS_MIDIINBUF  500
DECL|macro|CS_MIDIOUTBUF
mdefine_line|#define CS_MIDIOUTBUF 500
DECL|macro|ADC_RUNNING
mdefine_line|#define ADC_RUNNING&t;1
DECL|macro|DAC_RUNNING
mdefine_line|#define DAC_RUNNING&t;2
DECL|macro|CS_FMT_16BIT
mdefine_line|#define CS_FMT_16BIT&t;1&t;&t;/* These are fixed in fact */
DECL|macro|CS_FMT_STEREO
mdefine_line|#define CS_FMT_STEREO&t;2
DECL|macro|CS_FMT_MASK
mdefine_line|#define CS_FMT_MASK&t;3
DECL|macro|CS_TYPE_ADC
mdefine_line|#define CS_TYPE_ADC&t;1
DECL|macro|CS_TYPE_DAC
mdefine_line|#define CS_TYPE_DAC&t;2
multiline_comment|/*&n; *&t;CS461x definitions&n; */
DECL|macro|CS461X_BA0_SIZE
mdefine_line|#define CS461X_BA0_SIZE&t;&t;0x2000
DECL|macro|CS461X_BA1_DATA0_SIZE
mdefine_line|#define CS461X_BA1_DATA0_SIZE&t;0x3000
DECL|macro|CS461X_BA1_DATA1_SIZE
mdefine_line|#define CS461X_BA1_DATA1_SIZE&t;0x3800
DECL|macro|CS461X_BA1_PRG_SIZE
mdefine_line|#define CS461X_BA1_PRG_SIZE&t;0x7000
DECL|macro|CS461X_BA1_REG_SIZE
mdefine_line|#define CS461X_BA1_REG_SIZE&t;0x0100
DECL|macro|GOF_PER_SEC
mdefine_line|#define GOF_PER_SEC&t;200
DECL|macro|CSDEBUG_INTERFACE
mdefine_line|#define CSDEBUG_INTERFACE 1
DECL|macro|CSDEBUG
mdefine_line|#define CSDEBUG 1
multiline_comment|/*&n; * Turn on/off debugging compilation by using 1/0 respectively for CSDEBUG&n; *&n; *&n; * CSDEBUG is usual mode is set to 1, then use the&n; * cs_debuglevel and cs_debugmask to turn on or off debugging.&n; * Debug level of 1 has been defined to be kernel errors and info&n; * that should be printed on any released driver.&n; */
macro_line|#if CSDEBUG
DECL|macro|CS_DBGOUT
mdefine_line|#define CS_DBGOUT(mask,level,x) if((cs_debuglevel &gt;= (level)) &amp;&amp; ((mask) &amp; cs_debugmask)) {x;} 
macro_line|#else
DECL|macro|CS_DBGOUT
mdefine_line|#define CS_DBGOUT(mask,level,x) 
macro_line|#endif
multiline_comment|/*&n; * cs_debugmask areas&n; */
DECL|macro|CS_INIT
mdefine_line|#define CS_INIT&t; &t;0x00000001&t;&t;/* initialization and probe functions */
DECL|macro|CS_ERROR
mdefine_line|#define CS_ERROR &t;0x00000002&t;&t;/* tmp debugging bit placeholder */
DECL|macro|CS_INTERRUPT
mdefine_line|#define CS_INTERRUPT&t;0x00000004&t;&t;/* interrupt handler (separate from all other) */
DECL|macro|CS_FUNCTION
mdefine_line|#define CS_FUNCTION &t;0x00000008&t;&t;/* enter/leave functions */
DECL|macro|CS_WAVE_WRITE
mdefine_line|#define CS_WAVE_WRITE &t;0x00000010&t;&t;/* write information for wave */
DECL|macro|CS_WAVE_READ
mdefine_line|#define CS_WAVE_READ &t;0x00000020&t;&t;/* read information for wave */
DECL|macro|CS_MIDI_WRITE
mdefine_line|#define CS_MIDI_WRITE &t;0x00000040&t;&t;/* write information for midi */
DECL|macro|CS_MIDI_READ
mdefine_line|#define CS_MIDI_READ &t;0x00000080&t;&t;/* read information for midi */
DECL|macro|CS_MPU401_WRITE
mdefine_line|#define CS_MPU401_WRITE 0x00000100&t;&t;/* write information for mpu401 */
DECL|macro|CS_MPU401_READ
mdefine_line|#define CS_MPU401_READ &t;0x00000200&t;&t;/* read information for mpu401 */
DECL|macro|CS_OPEN
mdefine_line|#define CS_OPEN&t;&t;0x00000400&t;&t;/* all open functions in the driver */
DECL|macro|CS_RELEASE
mdefine_line|#define CS_RELEASE&t;0x00000800&t;&t;/* all release functions in the driver */
DECL|macro|CS_PARMS
mdefine_line|#define CS_PARMS&t;0x00001000&t;&t;/* functional and operational parameters */
DECL|macro|CS_IOCTL
mdefine_line|#define CS_IOCTL&t;0x00002000&t;&t;/* ioctl (non-mixer) */
DECL|macro|CS_TMP
mdefine_line|#define CS_TMP&t;&t;0x10000000&t;&t;/* tmp debug mask bit */
macro_line|#if CSDEBUG
DECL|variable|cs_debuglevel
r_static
r_int
r_int
id|cs_debuglevel
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* levels range from 1-9 */
DECL|variable|cs_debugmask
r_static
r_int
r_int
id|cs_debugmask
op_assign
id|CS_INIT
op_or
id|CS_ERROR
suffix:semicolon
multiline_comment|/* use CS_DBGOUT with various mask values */
macro_line|#endif
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER 3
DECL|variable|defaultorder
r_static
r_int
r_int
id|defaultorder
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
macro_line|#if MODULE
id|MODULE_PARM
c_func
(paren
id|defaultorder
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cs_debuglevel
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cs_debugmask
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|external_amp
r_static
r_int
id|external_amp
op_assign
l_int|0
suffix:semicolon
DECL|variable|thinkpad
r_static
r_int
id|thinkpad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An instance of the 4610 channel */
DECL|struct|cs_channel
r_struct
id|cs_channel
(brace
DECL|member|used
r_int
id|used
suffix:semicolon
DECL|member|num
r_int
id|num
suffix:semicolon
DECL|member|state
r_void
op_star
id|state
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;1.10&quot;
multiline_comment|/* magic numbers to protect our data structures */
DECL|macro|CS_CARD_MAGIC
mdefine_line|#define CS_CARD_MAGIC&t;&t;0x43525553 /* &quot;CRUS&quot; */
DECL|macro|CS_STATE_MAGIC
mdefine_line|#define CS_STATE_MAGIC&t;&t;0x4c4f4749 /* &quot;LOGI&quot; */
DECL|macro|NR_HW_CH
mdefine_line|#define NR_HW_CH&t;&t;3
multiline_comment|/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
DECL|macro|NR_AC97
mdefine_line|#define NR_AC97&t;&t;2
DECL|variable|sample_size
r_static
r_const
r_int
id|sample_size
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|4
)brace
suffix:semicolon
DECL|variable|sample_shift
r_static
r_const
r_int
id|sample_shift
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
)brace
suffix:semicolon
multiline_comment|/* &quot;software&quot; or virtual channel, an instance of opened /dev/dsp */
DECL|struct|cs_state
r_struct
id|cs_state
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
DECL|member|card
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
multiline_comment|/* Card info */
multiline_comment|/* single open lock mechanism, only used for recording */
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
multiline_comment|/* file mode */
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
multiline_comment|/* virtual channel number */
DECL|member|virt
r_int
id|virt
suffix:semicolon
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
multiline_comment|/* wave sample stuff */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
DECL|member|fmt
DECL|member|enable
r_int
r_char
id|fmt
comma
id|enable
suffix:semicolon
multiline_comment|/* hardware channel */
DECL|member|channel
r_struct
id|cs_channel
op_star
id|channel
suffix:semicolon
DECL|member|pringbuf
r_int
id|pringbuf
suffix:semicolon
multiline_comment|/* Software ring slot */
DECL|member|pbuf
r_void
op_star
id|pbuf
suffix:semicolon
multiline_comment|/* 4K hardware DMA buffer */
multiline_comment|/* OSS buffer management stuff */
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
DECL|member|dma_handle
id|dma_addr_t
id|dma_handle
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
DECL|member|divisor
r_int
id|divisor
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|tmpbuff
r_void
op_star
id|tmpbuff
suffix:semicolon
multiline_comment|/* tmp buffer for sample conversions */
DECL|member|dma_handle_tmpbuff
id|dma_addr_t
id|dma_handle_tmpbuff
suffix:semicolon
DECL|member|buforder_tmpbuff
r_int
id|buforder_tmpbuff
suffix:semicolon
multiline_comment|/* Log base 2 of size in bytes.. */
multiline_comment|/* our buffer acts like a circular ring */
DECL|member|hwptr
r_int
id|hwptr
suffix:semicolon
multiline_comment|/* where dma last started, updated by update_ptr */
DECL|member|swptr
r_int
id|swptr
suffix:semicolon
multiline_comment|/* where driver last clear/filled, updated by read/write */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* bytes to be comsumed or been generated by dma machine */
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
multiline_comment|/* total bytes dmaed by hardware */
DECL|member|blocks
r_int
id|blocks
suffix:semicolon
multiline_comment|/* total blocks */
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* number of over/underruns */
DECL|member|underrun
r_int
id|underrun
suffix:semicolon
multiline_comment|/* underrun pending before next write has occurred */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* put process on wait queue when no more space in buffer */
multiline_comment|/* redundant, but makes calculations easier */
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
multiline_comment|/* OSS stuff */
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
DECL|member|endcleared
r_int
id|endcleared
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SGok
r_int
id|SGok
suffix:colon
l_int|1
suffix:semicolon
DECL|member|update_flag
r_int
id|update_flag
suffix:semicolon
DECL|member|ossfragshift
r_int
id|ossfragshift
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|dmabuf
)brace
id|dmabuf
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cs_card
r_struct
id|cs_card
(brace
DECL|member|channel
r_struct
id|cs_channel
id|channel
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* We keep cs461x cards in a linked list */
DECL|member|next
r_struct
id|cs_card
op_star
id|next
suffix:semicolon
multiline_comment|/* The cs461x has a certain amount of cross channel interaction&n;&t;   so we use a single per card lock */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* PCI device stuff */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
DECL|member|pctl
DECL|member|cctl
r_int
r_int
id|pctl
comma
id|cctl
suffix:semicolon
multiline_comment|/* Hardware DMA flag sets */
multiline_comment|/* soundcore stuff */
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
DECL|member|dev_midi
r_int
id|dev_midi
suffix:semicolon
multiline_comment|/* structures for abstraction of hardware facilities, codecs, banks and channels*/
DECL|member|ac97_codec
r_struct
id|ac97_codec
op_star
id|ac97_codec
(braket
id|NR_AC97
)braket
suffix:semicolon
DECL|member|states
r_struct
id|cs_state
op_star
id|states
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|ac97_features
id|u16
id|ac97_features
suffix:semicolon
DECL|member|amplifier
r_int
id|amplifier
suffix:semicolon
multiline_comment|/* Amplifier control */
DECL|member|amplifier_ctrl
r_void
(paren
op_star
id|amplifier_ctrl
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|active
r_int
id|active
suffix:semicolon
multiline_comment|/* Active clocking */
DECL|member|active_ctrl
r_void
(paren
op_star
id|active_ctrl
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* hardware resources */
DECL|member|ba0_addr
r_int
r_int
id|ba0_addr
suffix:semicolon
DECL|member|ba1_addr
r_int
r_int
id|ba1_addr
suffix:semicolon
DECL|member|irq
id|u32
id|irq
suffix:semicolon
multiline_comment|/* mappings */
DECL|member|ba0
r_void
op_star
id|ba0
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|data0
id|u8
op_star
id|data0
suffix:semicolon
DECL|member|data1
id|u8
op_star
id|data1
suffix:semicolon
DECL|member|pmem
id|u8
op_star
id|pmem
suffix:semicolon
DECL|member|reg
id|u8
op_star
id|reg
suffix:semicolon
DECL|member|name
)brace
id|name
suffix:semicolon
DECL|member|idx
id|u8
op_star
id|idx
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ba1
)brace
id|ba1
suffix:semicolon
multiline_comment|/* Function support */
DECL|member|alloc_pcm_channel
r_struct
id|cs_channel
op_star
(paren
op_star
id|alloc_pcm_channel
)paren
(paren
r_struct
id|cs_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_pcm_channel
r_struct
id|cs_channel
op_star
(paren
op_star
id|alloc_rec_pcm_channel
)paren
(paren
r_struct
id|cs_card
op_star
)paren
suffix:semicolon
DECL|member|free_pcm_channel
r_void
(paren
op_star
id|free_pcm_channel
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
id|chan
)paren
suffix:semicolon
multiline_comment|/* /dev/midi stuff */
r_struct
(brace
DECL|member|ird
DECL|member|iwr
DECL|member|icnt
r_int
id|ird
comma
id|iwr
comma
id|icnt
suffix:semicolon
DECL|member|ord
DECL|member|owr
DECL|member|ocnt
r_int
id|ord
comma
id|owr
comma
id|ocnt
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|iwait
id|wait_queue_head_t
id|iwait
suffix:semicolon
DECL|member|owait
id|wait_queue_head_t
id|owait
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|ibuf
r_int
r_char
id|ibuf
(braket
id|CS_MIDIINBUF
)braket
suffix:semicolon
DECL|member|obuf
r_int
r_char
id|obuf
(braket
id|CS_MIDIOUTBUF
)braket
suffix:semicolon
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|midi
)brace
id|midi
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|cs_card
op_star
id|devs
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|cs_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|cs_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|cs_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
id|loff_t
id|cs_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
suffix:semicolon
DECL|function|ld2
r_extern
id|__inline__
r_int
id|ld2
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10000
)paren
(brace
id|x
op_rshift_assign
l_int|16
suffix:semicolon
id|r
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x100
)paren
(brace
id|x
op_rshift_assign
l_int|8
suffix:semicolon
id|r
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10
)paren
(brace
id|x
op_rshift_assign
l_int|4
suffix:semicolon
id|r
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|4
)paren
(brace
id|x
op_rshift_assign
l_int|2
suffix:semicolon
id|r
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|2
)paren
id|r
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
macro_line|#if CSDEBUG
multiline_comment|/* DEBUG ROUTINES */
DECL|macro|SOUND_MIXER_CS_GETDBGLEVEL
mdefine_line|#define SOUND_MIXER_CS_GETDBGLEVEL &t;_SIOWR(&squot;M&squot;,120, int)
DECL|macro|SOUND_MIXER_CS_SETDBGLEVEL
mdefine_line|#define SOUND_MIXER_CS_SETDBGLEVEL &t;_SIOWR(&squot;M&squot;,121, int)
DECL|macro|SOUND_MIXER_CS_GETDBGMASK
mdefine_line|#define SOUND_MIXER_CS_GETDBGMASK &t;_SIOWR(&squot;M&squot;,122, int)
DECL|macro|SOUND_MIXER_CS_SETDBGMASK
mdefine_line|#define SOUND_MIXER_CS_SETDBGMASK &t;_SIOWR(&squot;M&squot;,123, int)
DECL|macro|SNDCTL_DSP_CS_GETDBGLEVEL
mdefine_line|#define SNDCTL_DSP_CS_GETDBGLEVEL &t;_SIOWR(&squot;P&squot;, 50, int)
DECL|macro|SNDCTL_DSP_CS_SETDBGLEVEL
mdefine_line|#define SNDCTL_DSP_CS_SETDBGLEVEL &t;_SIOWR(&squot;P&squot;, 51, int)
DECL|macro|SNDCTL_DSP_CS_GETDBGMASK
mdefine_line|#define SNDCTL_DSP_CS_GETDBGMASK &t;_SIOWR(&squot;P&squot;, 52, int)
DECL|macro|SNDCTL_DSP_CS_SETDBGMASK
mdefine_line|#define SNDCTL_DSP_CS_SETDBGMASK &t;_SIOWR(&squot;P&squot;, 53, int)
DECL|function|printioctl
r_static
r_void
id|printioctl
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|vidx
suffix:semicolon
multiline_comment|/* these values are incorrect for the ac97 driver, fix.&n;         * Index of mixtable1[] member is Device ID &n;         * and must be &lt;= SOUND_MIXER_NRDEVICES.&n;         * Value of array member is index into s-&gt;mix.vol[]&n;         */
r_static
r_const
r_int
r_char
id|mixtable1
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
l_int|1
comma
multiline_comment|/* voice */
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
l_int|2
comma
multiline_comment|/* AUX */
(braket
id|SOUND_MIXER_CD
)braket
op_assign
l_int|3
comma
multiline_comment|/* CD */
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
l_int|4
comma
multiline_comment|/* Line */
(braket
id|SOUND_MIXER_SYNTH
)braket
op_assign
l_int|5
comma
multiline_comment|/* FM */
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
l_int|6
comma
multiline_comment|/* Mic */
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
l_int|7
comma
multiline_comment|/* Speaker */
(braket
id|SOUND_MIXER_RECLEV
)braket
op_assign
l_int|8
comma
multiline_comment|/* Recording level */
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
l_int|9
multiline_comment|/* Master Volume */
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|x
)paren
(brace
r_case
id|SOUND_MIXER_CS_GETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_GETDBGMASK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_GETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_GETDBGLEVEL: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_SETDBGMASK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_SETDBGLEVEL: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OSS_GETVERSION
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;OSS_GETVERSION: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SYNC: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETDUPLEX: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCAPS: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_RESET: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_STEREO: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CHANNELS: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETFMTS: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFMT: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_POST: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETTRIGGER: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETTRIGGER: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_NONBLOCK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETODELAY: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETIPTR: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOPTR: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SUBDIVIDE: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_RATE: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_CHANNELS: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_BITS: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_WRITE_FILTER: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETSYNCRO: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_FILTER: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_GETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_GETDBGMASK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_GETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_GETDBGLEVEL: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_SETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_SETDBGMASK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_SETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_SETDBGLEVEL: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE1
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE1: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE2
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE2: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE3
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE3: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE4
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE4: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE5
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE5: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_INFO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_INFO: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_OLD_MIXER_INFO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_OLD_MIXER_INFO: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|x
)paren
)paren
(brace
r_case
id|SOUND_MIXER_VOLUME
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_VOLUME: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SPEAKER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_SPEAKER: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECLEV: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_MIC: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_SYNTH: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECSRC: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_DEVMASK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECMASK: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_STEREODEVS: &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CAPS:&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;UNKNOWN IOCTL: 0x%.8x NR=%d &quot;
comma
id|x
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_IOCTL AC9x: 0x%.8x NR=%d &quot;
comma
id|x
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;command = 0x%x IOC_NR=%d&bslash;n&quot;
comma
id|x
comma
id|_IOC_NR
c_func
(paren
id|x
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *  common I/O routines&n; */
DECL|function|cs461x_poke
r_static
r_void
id|cs461x_poke
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
(brace
id|writel
c_func
(paren
id|val
comma
id|codec-&gt;ba1.idx
(braket
(paren
id|reg
op_rshift
l_int|16
)paren
op_amp
l_int|3
)braket
op_plus
(paren
id|reg
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
DECL|function|cs461x_peek
r_static
r_int
r_int
id|cs461x_peek
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
)paren
(brace
r_return
id|readl
c_func
(paren
id|codec-&gt;ba1.idx
(braket
(paren
id|reg
op_rshift
l_int|16
)paren
op_amp
l_int|3
)braket
op_plus
(paren
id|reg
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
DECL|function|cs461x_pokeBA0
r_static
r_void
id|cs461x_pokeBA0
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
(brace
id|writel
c_func
(paren
id|val
comma
id|codec-&gt;ba0
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|cs461x_peekBA0
r_static
r_int
r_int
id|cs461x_peekBA0
c_func
(paren
r_struct
id|cs_card
op_star
id|codec
comma
r_int
r_int
id|reg
)paren
(brace
r_return
id|readl
c_func
(paren
id|codec-&gt;ba0
op_plus
id|reg
)paren
suffix:semicolon
)brace
r_static
id|u16
id|cs_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
suffix:semicolon
r_static
r_void
id|cs_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
suffix:semicolon
DECL|function|cs_alloc_pcm_channel
r_static
r_struct
id|cs_channel
op_star
id|cs_alloc_pcm_channel
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|num
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|cs_alloc_rec_pcm_channel
r_static
r_struct
id|cs_channel
op_star
id|cs_alloc_rec_pcm_channel
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|num
op_assign
l_int|0
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|cs_free_pcm_channel
r_static
r_void
id|cs_free_pcm_channel
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|channel
)paren
(brace
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|state
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|used
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * setup a divisor value to help with conversion from&n; * 16bit Stereo, down to 8bit stereo/mono or 16bit mono.&n; * assign a divisor of 1 if using 16bit Stereo as that is&n; * the only format that the static image will capture.&n; */
DECL|function|cs_set_divisor
r_static
r_void
id|cs_set_divisor
c_func
(paren
r_struct
id|dmabuf
op_star
id|dmabuf
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;type
op_eq
id|CS_TYPE_DAC
)paren
(brace
id|dmabuf-&gt;divisor
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
op_logical_and
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
id|dmabuf-&gt;divisor
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
op_logical_and
op_logical_neg
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
id|dmabuf-&gt;divisor
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
op_logical_and
op_logical_neg
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
id|dmabuf-&gt;divisor
op_assign
l_int|4
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;divisor
op_assign
l_int|1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
op_or
id|CS_FUNCTION
comma
l_int|8
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_set_divisor()- %s %d&bslash;n&quot;
comma
(paren
id|dmabuf-&gt;type
op_eq
id|CS_TYPE_ADC
)paren
ques
c_cond
l_string|&quot;ADC&quot;
suffix:colon
l_string|&quot;DAC&quot;
comma
id|dmabuf-&gt;divisor
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* set playback sample rate */
DECL|function|cs_set_dac_rate
r_static
r_int
r_int
id|cs_set_dac_rate
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|tmp1
comma
id|tmp2
suffix:semicolon
r_int
r_int
id|phiIncr
suffix:semicolon
r_int
r_int
id|correctionPerGOF
comma
id|correctionPerSec
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_set_dac_rate()+ %d&bslash;n&quot;
comma
id|rate
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the values used to drive the actual sample rate conversion.&n;&t; *  The following formulas are being computed, using inline assembly&n;&t; *  since we need to use 64 bit arithmetic to compute the values:&n;&t; *&n;&t; *  phiIncr = floor((Fs,in * 2^26) / Fs,out)&n;&t; *  correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /&n;         *                                   GOF_PER_SEC)&n;         *  ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -M&n;         *                       GOF_PER_SEC * correctionPerGOF&n;&t; *&n;&t; *  i.e.&n;&t; *&n;&t; *  phiIncr:other = dividend:remainder((Fs,in * 2^26) / Fs,out)&n;&t; *  correctionPerGOF:correctionPerSec =&n;&t; *      dividend:remainder(ulOther / GOF_PER_SEC)&n;&t; */
id|tmp1
op_assign
id|rate
op_lshift
l_int|16
suffix:semicolon
id|phiIncr
op_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|tmp1
op_sub_assign
id|phiIncr
op_star
l_int|48000
suffix:semicolon
id|tmp1
op_lshift_assign
l_int|10
suffix:semicolon
id|phiIncr
op_lshift_assign
l_int|10
suffix:semicolon
id|tmp2
op_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|phiIncr
op_add_assign
id|tmp2
suffix:semicolon
id|tmp1
op_sub_assign
id|tmp2
op_star
l_int|48000
suffix:semicolon
id|correctionPerGOF
op_assign
id|tmp1
op_div
id|GOF_PER_SEC
suffix:semicolon
id|tmp1
op_sub_assign
id|correctionPerGOF
op_star
id|GOF_PER_SEC
suffix:semicolon
id|correctionPerSec
op_assign
id|tmp1
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill in the SampleRateConverter control block.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|state-&gt;card
comma
id|BA1_PSRC
comma
(paren
(paren
id|correctionPerSec
op_lshift
l_int|16
)paren
op_amp
l_int|0xFFFF0000
)paren
op_or
(paren
id|correctionPerGOF
op_amp
l_int|0xFFFF
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|state-&gt;card
comma
id|BA1_PPI
comma
id|phiIncr
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
)paren
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_set_dac_rate()- %d&bslash;n&quot;
comma
id|rate
)paren
)paren
suffix:semicolon
r_return
id|rate
suffix:semicolon
)brace
multiline_comment|/* set recording sample rate */
DECL|function|cs_set_adc_rate
r_static
r_int
r_int
id|cs_set_adc_rate
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|phiIncr
comma
id|coeffIncr
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
r_int
r_int
id|correctionPerGOF
comma
id|correctionPerSec
comma
id|initialDelay
suffix:semicolon
r_int
r_int
id|frameGroupLength
comma
id|cnt
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_set_adc_rate()+ %d&bslash;n&quot;
comma
id|rate
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  We can only decimate by up to a factor of 1/9th the hardware rate.&n;&t; *  Correct the value if an attempt is made to stray outside that limit.&n;&t; */
r_if
c_cond
(paren
(paren
id|rate
op_star
l_int|9
)paren
OL
l_int|48000
)paren
id|rate
op_assign
l_int|48000
op_div
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; *  We can not capture at at rate greater than the Input Rate (48000).&n;&t; *  Return an error if an attempt is made to stray outside that limit.&n;&t; */
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the values used to drive the actual sample rate conversion.&n;&t; *  The following formulas are being computed, using inline assembly&n;&t; *  since we need to use 64 bit arithmetic to compute the values:&n;&t; *&n;&t; *     coeffIncr = -floor((Fs,out * 2^23) / Fs,in)&n;&t; *     phiIncr = floor((Fs,in * 2^26) / Fs,out)&n;&t; *     correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /&n;&t; *                                GOF_PER_SEC)&n;&t; *     correctionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -&n;&t; *                          GOF_PER_SEC * correctionPerGOF&n;&t; *     initialDelay = ceil((24 * Fs,in) / Fs,out)&n;&t; *&n;&t; * i.e.&n;&t; *&n;&t; *     coeffIncr = neg(dividend((Fs,out * 2^23) / Fs,in))&n;&t; *     phiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out)&n;&t; *     correctionPerGOF:correctionPerSec =&n;&t; * &t;    dividend:remainder(ulOther / GOF_PER_SEC)&n;&t; *     initialDelay = dividend(((24 * Fs,in) + Fs,out - 1) / Fs,out)&n;&t; */
id|tmp1
op_assign
id|rate
op_lshift
l_int|16
suffix:semicolon
id|coeffIncr
op_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|tmp1
op_sub_assign
id|coeffIncr
op_star
l_int|48000
suffix:semicolon
id|tmp1
op_lshift_assign
l_int|7
suffix:semicolon
id|coeffIncr
op_lshift_assign
l_int|7
suffix:semicolon
id|coeffIncr
op_add_assign
id|tmp1
op_div
l_int|48000
suffix:semicolon
id|coeffIncr
op_xor_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|coeffIncr
op_increment
suffix:semicolon
id|tmp1
op_assign
l_int|48000
op_lshift
l_int|16
suffix:semicolon
id|phiIncr
op_assign
id|tmp1
op_div
id|rate
suffix:semicolon
id|tmp1
op_sub_assign
id|phiIncr
op_star
id|rate
suffix:semicolon
id|tmp1
op_lshift_assign
l_int|10
suffix:semicolon
id|phiIncr
op_lshift_assign
l_int|10
suffix:semicolon
id|tmp2
op_assign
id|tmp1
op_div
id|rate
suffix:semicolon
id|phiIncr
op_add_assign
id|tmp2
suffix:semicolon
id|tmp1
op_sub_assign
id|tmp2
op_star
id|rate
suffix:semicolon
id|correctionPerGOF
op_assign
id|tmp1
op_div
id|GOF_PER_SEC
suffix:semicolon
id|tmp1
op_sub_assign
id|correctionPerGOF
op_star
id|GOF_PER_SEC
suffix:semicolon
id|correctionPerSec
op_assign
id|tmp1
suffix:semicolon
id|initialDelay
op_assign
(paren
(paren
l_int|48000
op_star
l_int|24
)paren
op_plus
id|rate
op_minus
l_int|1
)paren
op_div
id|rate
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill in the VariDecimate control block.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CSRC
comma
(paren
(paren
id|correctionPerSec
op_lshift
l_int|16
)paren
op_amp
l_int|0xFFFF0000
)paren
op_or
(paren
id|correctionPerGOF
op_amp
l_int|0xFFFF
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCI
comma
id|coeffIncr
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CD
comma
(paren
(paren
(paren
id|BA1_VARIDEC_BUF_1
op_plus
(paren
id|initialDelay
op_lshift
l_int|2
)paren
)paren
op_lshift
l_int|16
)paren
op_amp
l_int|0xFFFF0000
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CPI
comma
id|phiIncr
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Figure out the frame group length for the write back task.  Basically,&n;&t; *  this is just the factors of 24000 (2^6*3*5^3) that are not present in&n;&t; *  the output sample rate.&n;&t; */
id|frameGroupLength
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|2
suffix:semicolon
id|cnt
op_le
l_int|64
suffix:semicolon
id|cnt
op_mul_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|rate
op_div
id|cnt
)paren
op_star
id|cnt
)paren
op_ne
id|rate
)paren
id|frameGroupLength
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|rate
op_div
l_int|3
)paren
op_star
l_int|3
)paren
op_ne
id|rate
)paren
(brace
id|frameGroupLength
op_mul_assign
l_int|3
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|5
suffix:semicolon
id|cnt
op_le
l_int|125
suffix:semicolon
id|cnt
op_mul_assign
l_int|5
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|rate
op_div
id|cnt
)paren
op_star
id|cnt
)paren
op_ne
id|rate
)paren
id|frameGroupLength
op_mul_assign
l_int|5
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the WriteBack control block.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CFG1
comma
id|frameGroupLength
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CFG2
comma
(paren
l_int|0x00800000
op_or
id|frameGroupLength
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCST
comma
l_int|0x0000FFFF
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CSPB
comma
(paren
(paren
l_int|65536
op_star
id|rate
)paren
op_div
l_int|24000
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
(paren
id|BA1_CSPB
op_plus
l_int|4
)paren
comma
l_int|0x0000FFFF
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_set_adc_rate()- %d&bslash;n&quot;
comma
id|rate
)paren
)paren
suffix:semicolon
r_return
id|rate
suffix:semicolon
)brace
multiline_comment|/* prepare channel attributes for playback */
DECL|function|cs_play_setup
r_static
r_void
id|cs_play_setup
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|tmp
comma
id|Count
comma
id|playFormat
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_play_setup()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PVOL
comma
l_int|0x80008000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;SGok
)paren
(brace
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PBA
comma
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;pbuf
)paren
)paren
suffix:semicolon
)brace
id|Count
op_assign
l_int|4
suffix:semicolon
id|playFormat
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PFIE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
)paren
(brace
id|playFormat
op_and_assign
op_complement
id|DMA_RQ_C2_AC_MONO_TO_STEREO
suffix:semicolon
id|Count
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_else
id|playFormat
op_or_assign
id|DMA_RQ_C2_AC_MONO_TO_STEREO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
id|playFormat
op_and_assign
op_complement
(paren
id|DMA_RQ_C2_AC_8_TO_16_BIT
op_or
id|DMA_RQ_C2_AC_SIGNED_CONVERT
)paren
suffix:semicolon
id|Count
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_else
id|playFormat
op_or_assign
(paren
id|DMA_RQ_C2_AC_8_TO_16_BIT
op_or
id|DMA_RQ_C2_AC_SIGNED_CONVERT
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PFIE
comma
id|playFormat
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PDTC
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xfffffe00
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PDTC
comma
id|tmp
op_or
op_decrement
id|Count
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_play_setup()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|struct|InitStruct
r_struct
id|InitStruct
(brace
DECL|member|off
id|u32
r_int
id|off
suffix:semicolon
DECL|member|val
id|u32
r_int
id|val
suffix:semicolon
DECL|variable|InitArray
)brace
id|InitArray
(braket
)braket
op_assign
(brace
(brace
l_int|0x00000040
comma
l_int|0x3fc0000f
)brace
comma
(brace
l_int|0x0000004c
comma
l_int|0x04800000
)brace
comma
(brace
l_int|0x000000b3
comma
l_int|0x00000780
)brace
comma
(brace
l_int|0x000000b7
comma
l_int|0x00000000
)brace
comma
(brace
l_int|0x000000bc
comma
l_int|0x07800000
)brace
comma
(brace
l_int|0x000000cd
comma
l_int|0x00800000
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * &quot;SetCaptureSPValues()&quot; -- Initialize record task values before each&n; * &t;capture startup.  &n; */
DECL|function|SetCaptureSPValues
r_void
id|SetCaptureSPValues
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|i
comma
id|offset
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|8
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: SetCaptureSPValues()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|InitArray
)paren
op_div
r_sizeof
(paren
r_struct
id|InitStruct
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
id|InitArray
(braket
id|i
)braket
dot
id|off
op_star
l_int|4
suffix:semicolon
multiline_comment|/* 8bit to 32bit offset value */
id|cs461x_poke
c_func
(paren
id|card
comma
id|offset
comma
id|InitArray
(braket
id|i
)braket
dot
id|val
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|8
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: SetCaptureSPValues()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* prepare channel attributes for recording */
DECL|function|cs_rec_setup
r_static
r_void
id|cs_rec_setup
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_rec_setup()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SetCaptureSPValues
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set the attenuation to 0dB &n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CVOL
comma
l_int|0x80008000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set the physical address of the capture buffer into the SP&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CBA
comma
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_rec_setup()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* get current playback/recording dma buffer pointer (byte offset from LBA),&n;   called with spinlock held! */
DECL|function|cs_get_dma_addr
r_extern
id|__inline__
r_int
id|cs_get_dma_addr
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: ERROR cs_get_dma_addr(): not enabled &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ganularity is byte boundry, good part.&n;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|offset
op_assign
id|cs461x_peek
c_func
(paren
id|state-&gt;card
comma
id|BA1_PBA
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* ADC_RUNNING must be set */
(brace
id|offset
op_assign
id|cs461x_peek
c_func
(paren
id|state-&gt;card
comma
id|BA1_CBA
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
op_or
id|CS_FUNCTION
comma
l_int|9
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_get_dma_addr() %d&bslash;n&quot;
comma
id|offset
)paren
)paren
suffix:semicolon
id|offset
op_assign
(paren
id|u32
)paren
id|bus_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
id|offset
)paren
op_minus
(paren
id|u32
)paren
id|dmabuf-&gt;rawbuf
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
op_or
id|CS_FUNCTION
comma
l_int|8
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_get_dma_addr()- %d&bslash;n&quot;
comma
id|offset
)paren
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|resync_dma_ptrs
r_static
r_void
id|resync_dma_ptrs
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: resync_dma_ptrs()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|dmabuf-&gt;swptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;pringbuf
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: resync_dma_ptrs()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop recording (lock held) */
DECL|function|__stop_adc
r_extern
id|__inline__
r_void
id|__stop_adc
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|ADC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF0000
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: stop_adc()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: stop_adc()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
op_logical_and
(paren
(paren
id|dmabuf-&gt;mapped
op_logical_or
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
)paren
op_logical_and
id|dmabuf-&gt;ready
)paren
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|ADC_RUNNING
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF0000
suffix:semicolon
id|tmp
op_or_assign
id|card-&gt;cctl
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: start_adc() poke 0x%x &bslash;n&quot;
comma
id|tmp
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* stop playback (lock held) */
DECL|function|__stop_dac
r_extern
id|__inline__
r_void
id|__stop_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|DAC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: stop_dac()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: stop_dac()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: start_dac()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
op_logical_and
(paren
(paren
id|dmabuf-&gt;mapped
op_logical_or
id|dmabuf-&gt;count
OG
l_int|0
)paren
op_logical_and
id|dmabuf-&gt;ready
)paren
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|DAC_RUNNING
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|tmp
op_and_assign
l_int|0xFFFF
suffix:semicolon
id|tmp
op_or_assign
id|card-&gt;pctl
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: start_dac() poke card=0x%.08x tmp=0x%.08x addr=0x%.08x &bslash;n&quot;
comma
(paren
r_int
)paren
id|card
comma
(paren
r_int
)paren
id|tmp
comma
(paren
r_int
)paren
id|card-&gt;ba1.idx
(braket
(paren
id|BA1_PCTL
op_rshift
l_int|16
)paren
op_amp
l_int|3
)braket
op_plus
(paren
id|BA1_PCTL
op_amp
l_int|0xffff
)paren
)paren
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: start_dac()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1
multiline_comment|/*&n; * allocate DMA buffer, playback and recording buffers are separate.&n; */
DECL|function|alloc_dmabuf
r_static
r_int
id|alloc_dmabuf
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|tmpbuff
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
multiline_comment|/* alloc as big a chunk as we can */
r_for
c_loop
(paren
id|order
op_assign
id|defaultorder
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
comma
id|order
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dmabuf-&gt;buforder
op_assign
id|order
suffix:semicolon
id|dmabuf-&gt;rawbuf
op_assign
id|rawbuf
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|9
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|rawbuf
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * now the temp buffer for 16/8 conversions&n; */
r_for
c_loop
(paren
id|order
op_assign
id|defaultorder
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|tmpbuff
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
comma
id|order
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmpbuff
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|9
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|tmpbuff
)paren
)paren
suffix:semicolon
id|dmabuf-&gt;tmpbuff
op_assign
id|tmpbuff
suffix:semicolon
id|dmabuf-&gt;buforder_tmpbuff
op_assign
id|order
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|tmpbuff
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|tmpbuff
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|9
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|tmpbuff
)paren
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
id|dmabuf-&gt;mapped
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free DMA buffer */
DECL|function|dealloc_dmabuf
r_static
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
(brace
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
comma
id|dmabuf-&gt;rawbuf
comma
id|dmabuf-&gt;dma_handle
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;tmpbuff
)paren
(brace
multiline_comment|/* undo marking the pages as reserved */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;tmpbuff
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder_tmpbuff
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;tmpbuff
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder_tmpbuff
comma
id|dmabuf-&gt;tmpbuff
comma
id|dmabuf-&gt;dma_handle_tmpbuff
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;tmpbuff
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|allocated_pages
comma
id|allocated_bytes
suffix:semicolon
r_int
r_int
id|tmp1
comma
id|tmp2
comma
id|fmt
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|ptmp
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmabuf-&gt;pbuf
suffix:semicolon
r_int
r_int
id|SGarray
(braket
l_int|9
)braket
comma
id|nSGpages
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * check for CAPTURE and use only non-sg for initial release&n; */
r_if
c_cond
(paren
id|dmabuf-&gt;type
op_eq
id|CS_TYPE_ADC
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf() ADC&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * add in non-sg support for capture.&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* add code to reset the rawbuf memory. TRW */
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_assign
id|dmabuf-&gt;blocks
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
id|dmabuf-&gt;underrun
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer if not allocated yet */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;rawbuf
op_logical_or
op_logical_neg
id|dmabuf-&gt;tmpbuff
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * static image only supports 16Bit signed, stereo - hard code fmt&n;&t; */
id|fmt
op_assign
id|CS_FMT_16BIT
op_or
id|CS_FMT_STEREO
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
l_int|2
suffix:semicolon
id|dmabuf-&gt;fragsize
op_assign
l_int|2048
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
l_int|2048
op_rshift
id|sample_shift
(braket
id|fmt
)braket
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
l_int|4096
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|11
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
(paren
id|fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;tmpbuff
comma
(paren
id|fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder_tmpbuff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      Now set up the ring&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_rec_setup
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* set the ready flag for the dma buffer */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: prog_dmabuf(): CAPTURE rate=%d fmt=0x%x numfrag=%d &quot;
l_string|&quot;fragsize=%d dmasize=%d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
comma
id|dmabuf-&gt;fmt
comma
id|dmabuf-&gt;numfrag
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;dmasize
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf()- 0 &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;type
op_eq
id|CS_TYPE_DAC
)paren
(brace
multiline_comment|/*&n;&t; * Must be DAC&n;&t; */
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf() DAC&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_assign
id|dmabuf-&gt;blocks
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
id|dmabuf-&gt;underrun
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer if not allocated yet */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;rawbuf
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|allocated_pages
op_assign
l_int|1
op_lshift
id|dmabuf-&gt;buforder
suffix:semicolon
id|allocated_bytes
op_assign
id|allocated_pages
op_star
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|allocated_pages
OL
l_int|2
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf() Error: allocated_pages too small (%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|allocated_pages
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Use all the pages allocated, fragsize 4k. */
multiline_comment|/* Use &squot;pbuf&squot; for S/G page map table. */
id|dmabuf-&gt;SGok
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Use S/G. */
id|nSGpages
op_assign
id|allocated_bytes
op_div
l_int|4096
suffix:semicolon
multiline_comment|/* S/G pages always 4k. */
multiline_comment|/* Set up S/G variables. */
op_star
id|ptmp
op_assign
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
op_star
(paren
id|ptmp
op_plus
l_int|1
)paren
op_assign
l_int|0x00000008
suffix:semicolon
r_for
c_loop
(paren
id|tmp1
op_assign
l_int|1
suffix:semicolon
id|tmp1
OL
id|nSGpages
suffix:semicolon
id|tmp1
op_increment
)paren
(brace
op_star
(paren
id|ptmp
op_plus
l_int|2
op_star
id|tmp1
)paren
op_assign
id|virt_to_bus
c_func
(paren
(paren
id|dmabuf-&gt;rawbuf
)paren
op_plus
l_int|4096
op_star
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_eq
id|nSGpages
op_minus
l_int|1
)paren
(brace
id|tmp2
op_assign
l_int|0xbfff0000
suffix:semicolon
)brace
r_else
id|tmp2
op_assign
l_int|0x80000000
op_plus
l_int|8
op_star
(paren
id|tmp1
op_plus
l_int|1
)paren
suffix:semicolon
op_star
(paren
id|ptmp
op_plus
l_int|2
op_star
id|tmp1
op_plus
l_int|1
)paren
op_assign
id|tmp2
suffix:semicolon
)brace
id|SGarray
(braket
l_int|0
)braket
op_assign
l_int|0x82c0200d
suffix:semicolon
id|SGarray
(braket
l_int|1
)braket
op_assign
l_int|0xffff0000
suffix:semicolon
id|SGarray
(braket
l_int|2
)braket
op_assign
op_star
id|ptmp
suffix:semicolon
id|SGarray
(braket
l_int|3
)braket
op_assign
l_int|0x00010600
suffix:semicolon
id|SGarray
(braket
l_int|4
)braket
op_assign
op_star
(paren
id|ptmp
op_plus
l_int|2
)paren
suffix:semicolon
id|SGarray
(braket
l_int|5
)braket
op_assign
l_int|0x80000010
suffix:semicolon
id|SGarray
(braket
l_int|6
)braket
op_assign
op_star
id|ptmp
suffix:semicolon
id|SGarray
(braket
l_int|7
)braket
op_assign
op_star
(paren
id|ptmp
op_plus
l_int|2
)paren
suffix:semicolon
id|SGarray
(braket
l_int|8
)braket
op_assign
(paren
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;pbuf
)paren
op_amp
l_int|0xffff000
)paren
op_or
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;SGok
)paren
(brace
id|dmabuf-&gt;numfrag
op_assign
id|nSGpages
suffix:semicolon
id|dmabuf-&gt;fragsize
op_assign
l_int|4096
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
l_int|4096
op_rshift
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|12
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
id|dmabuf-&gt;numfrag
op_star
l_int|4096
suffix:semicolon
)brace
r_else
(brace
id|SGarray
(braket
l_int|0
)braket
op_assign
l_int|0xf2c0000f
suffix:semicolon
id|SGarray
(braket
l_int|1
)braket
op_assign
l_int|0x00000200
suffix:semicolon
id|SGarray
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|SGarray
(braket
l_int|3
)braket
op_assign
l_int|0x00010600
suffix:semicolon
id|SGarray
(braket
l_int|4
)braket
op_assign
id|SGarray
(braket
l_int|5
)braket
op_assign
id|SGarray
(braket
l_int|6
)braket
op_assign
id|SGarray
(braket
l_int|7
)braket
op_assign
id|SGarray
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
l_int|2
suffix:semicolon
id|dmabuf-&gt;fragsize
op_assign
l_int|2048
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
l_int|2048
op_rshift
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
l_int|4096
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|11
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
id|tmp1
OL
r_sizeof
(paren
id|SGarray
)paren
op_div
l_int|4
suffix:semicolon
id|tmp1
op_increment
)paren
(brace
id|cs461x_poke
c_func
(paren
id|state-&gt;card
comma
id|BA1_PDTC
op_plus
id|tmp1
op_star
l_int|4
comma
id|SGarray
(braket
id|tmp1
)braket
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      Now set up the ring&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_play_setup
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* set the ready flag for the dma buffer */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: prog_dmabuf(): PLAYBACK rate=%d fmt=0x%x numfrag=%d &quot;
l_string|&quot;fragsize=%d dmasize=%d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
comma
id|dmabuf-&gt;fmt
comma
id|dmabuf-&gt;numfrag
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;dmasize
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: prog_dmabuf()- Invalid Type %d&bslash;n&quot;
comma
id|dmabuf-&gt;type
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cs_clear_tail
r_static
r_void
id|cs_clear_tail
c_func
(paren
r_struct
id|cs_state
op_star
id|state
)paren
(brace
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|cs_state
op_star
id|state
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_or
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* It seems that we have to set the current state to TASK_INTERRUPTIBLE&n;&t;&t;   every time to make the process really go to sleep */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
id|dmabuf-&gt;rate
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
id|tmo
op_add_assign
(paren
l_int|2048
op_star
id|HZ
)paren
op_div
id|dmabuf-&gt;rate
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
id|tmo
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: drain_dac, dma timeout? %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* update buffer manangement pointers, especially, dmabuf-&gt;count and dmabuf-&gt;hwptr */
DECL|function|cs_update_ptr
r_static
r_void
id|cs_update_ptr
c_func
(paren
r_void
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
id|hwptr
suffix:semicolon
r_int
id|diff
suffix:semicolon
multiline_comment|/* error handling and process wake up for ADC */
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|cs_get_dma_addr
c_func
(paren
id|state
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|9
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_update_ptr()+ ADC hwptr=%d diff=%d&bslash;n&quot;
comma
id|hwptr
comma
id|diff
)paren
)paren
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
l_int|0
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Now the DAC&n; */
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|cs_get_dma_addr
c_func
(paren
id|state
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|9
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_update_ptr()+ DAC hwptr=%d diff=%d&bslash;n&quot;
comma
id|hwptr
comma
id|diff
)paren
)paren
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * other drivers use fragsize, but don&squot;t see any sense&n;&t;&t;&t;&t; * in that, since dmasize is the buffer asked for&n;&t;&t;&t;&t; * via mmap.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
(brace
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;dmasize
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * backfill with silence and clear out the last &n;&t;&t;&t;&t; * &quot;diff&quot; number of bytes.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|hwptr
op_ge
id|diff
)paren
(brace
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|hwptr
op_minus
id|diff
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|diff
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
(paren
r_int
)paren
id|hwptr
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
(paren
(paren
r_int
)paren
id|dmabuf-&gt;rawbuf
op_plus
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|diff
)paren
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|diff
op_minus
id|hwptr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
template_param
id|dmabuf-&gt;dmasize
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: ERROR DAC count&lt;0 or count &gt; dmasize (%d)&bslash;n&quot;
comma
id|dmabuf-&gt;count
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;* buffer underrun or buffer overrun, reset the&n;&t;&t;&t;&t;&t;* count of bytes written back to 0.&n;&t;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
id|dmabuf-&gt;underrun
op_assign
l_int|1
suffix:semicolon
)brace
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_div
l_int|2
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* hold spinlock for the following! */
DECL|function|cs_handle_midi
r_static
r_void
id|cs_handle_midi
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
r_int
id|wake
suffix:semicolon
r_int
id|temp1
suffix:semicolon
id|wake
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_MIDSR
)paren
op_amp
id|MIDSR_RBE
)paren
)paren
(brace
id|ch
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_MIDRP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;midi.icnt
OL
id|CS_MIDIINBUF
)paren
(brace
id|card-&gt;midi.ibuf
(braket
id|card-&gt;midi.iwr
)braket
op_assign
id|ch
suffix:semicolon
id|card-&gt;midi.iwr
op_assign
(paren
id|card-&gt;midi.iwr
op_plus
l_int|1
)paren
op_mod
id|CS_MIDIINBUF
suffix:semicolon
id|card-&gt;midi.icnt
op_increment
suffix:semicolon
)brace
id|wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wake
)paren
id|wake_up
c_func
(paren
op_amp
id|card-&gt;midi.iwait
)paren
suffix:semicolon
id|wake
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_MIDSR
)paren
op_amp
id|MIDSR_TBF
)paren
op_logical_and
id|card-&gt;midi.ocnt
OG
l_int|0
)paren
(brace
id|temp1
op_assign
(paren
id|card-&gt;midi.obuf
(braket
id|card-&gt;midi.ord
)braket
)paren
op_amp
l_int|0x000000ff
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_MIDWP
comma
id|temp1
)paren
suffix:semicolon
id|card-&gt;midi.ord
op_assign
(paren
id|card-&gt;midi.ord
op_plus
l_int|1
)paren
op_mod
id|CS_MIDIOUTBUF
suffix:semicolon
id|card-&gt;midi.ocnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;midi.ocnt
OL
id|CS_MIDIOUTBUF
op_minus
l_int|16
)paren
id|wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wake
)paren
id|wake_up
c_func
(paren
op_amp
id|card-&gt;midi.owait
)paren
suffix:semicolon
)brace
DECL|function|cs_interrupt
r_static
r_void
id|cs_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|dev_id
suffix:semicolon
multiline_comment|/* Single channel card */
r_struct
id|cs_state
op_star
id|recstate
op_assign
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|state
suffix:semicolon
r_struct
id|cs_state
op_star
id|playstate
op_assign
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|state
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_interrupt()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_HISR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x7fffffff
)paren
op_eq
l_int|0
)paren
(brace
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_CHGM
op_or
id|HICR_IEV
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for playback or capture interrupt only&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|status
op_amp
id|HISR_VC0
)paren
op_logical_and
id|playstate
op_logical_and
id|playstate-&gt;dmabuf.ready
)paren
op_logical_or
(paren
(paren
(paren
id|status
op_amp
id|HISR_VC1
)paren
op_logical_and
id|recstate
op_logical_and
id|recstate-&gt;dmabuf.ready
)paren
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|8
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_interrupt() interrupt bit(s) set (0x%x)&bslash;n&quot;
comma
id|status
)paren
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|HISR_MIDI
)paren
(brace
id|cs_handle_midi
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
multiline_comment|/* clear &squot;em */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_CHGM
op_or
id|HICR_IEV
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_interrupt()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************/
DECL|function|cs_midi_read
r_static
id|ssize_t
id|cs_midi_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ptr
op_assign
id|card-&gt;midi.ird
suffix:semicolon
id|cnt
op_assign
id|CS_MIDIINBUF
op_minus
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;midi.icnt
OL
id|cnt
)paren
id|cnt
op_assign
id|card-&gt;midi.icnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|card-&gt;midi.iwait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|card-&gt;midi.ibuf
op_plus
id|ptr
comma
id|cnt
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
(paren
id|ptr
op_plus
id|cnt
)paren
op_mod
id|CS_MIDIINBUF
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|card-&gt;midi.ird
op_assign
id|ptr
suffix:semicolon
id|card-&gt;midi.icnt
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs_midi_write
r_static
id|ssize_t
id|cs_midi_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ptr
op_assign
id|card-&gt;midi.owr
suffix:semicolon
id|cnt
op_assign
id|CS_MIDIOUTBUF
op_minus
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;midi.ocnt
op_plus
id|cnt
OG
id|CS_MIDIOUTBUF
)paren
id|cnt
op_assign
id|CS_MIDIOUTBUF
op_minus
id|card-&gt;midi.ocnt
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
id|cs_handle_midi
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|card-&gt;midi.owait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|card-&gt;midi.obuf
op_plus
id|ptr
comma
id|buffer
comma
id|cnt
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
(paren
id|ptr
op_plus
id|cnt
)paren
op_mod
id|CS_MIDIOUTBUF
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|card-&gt;midi.owr
op_assign
id|ptr
suffix:semicolon
id|card-&gt;midi.ocnt
op_add_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_handle_midi
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs_midi_poll
r_static
r_int
r_int
id|cs_midi_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_WRITE
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|card-&gt;midi.owait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_READ
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|card-&gt;midi.iwait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;midi.icnt
OG
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;midi.ocnt
OL
id|CS_MIDIOUTBUF
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|cs_midi_open
r_static
r_int
id|cs_midi_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
id|card
op_logical_and
id|card-&gt;dev_midi
op_ne
id|minor
)paren
id|card
op_assign
id|card-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|file-&gt;private_data
op_assign
id|card
suffix:semicolon
multiline_comment|/* wait for device to become free */
id|down
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
id|card-&gt;midi.open_mode
op_amp
id|file-&gt;f_mode
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|card-&gt;midi.open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|down
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;midi.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|card-&gt;midi.open_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
)paren
(brace
id|card-&gt;midi.ird
op_assign
id|card-&gt;midi.iwr
op_assign
id|card-&gt;midi.icnt
op_assign
l_int|0
suffix:semicolon
id|card-&gt;midi.ord
op_assign
id|card-&gt;midi.owr
op_assign
id|card-&gt;midi.ocnt
op_assign
l_int|0
suffix:semicolon
id|card-&gt;midi.ird
op_assign
id|card-&gt;midi.iwr
op_assign
id|card-&gt;midi.icnt
op_assign
l_int|0
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_MIDCR
comma
l_int|0x0000000f
)paren
suffix:semicolon
multiline_comment|/* Enable xmit, rcv. */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_IEV
op_or
id|HICR_CHGM
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts */
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|card-&gt;midi.ird
op_assign
id|card-&gt;midi.iwr
op_assign
id|card-&gt;midi.icnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|card-&gt;midi.ord
op_assign
id|card-&gt;midi.owr
op_assign
id|card-&gt;midi.ocnt
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;midi.lock
comma
id|flags
)paren
suffix:semicolon
id|card-&gt;midi.open_mode
op_or_assign
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_midi_release
r_static
r_int
id|cs_midi_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
comma
id|tmo
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|card-&gt;midi.owait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;midi.lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|card-&gt;midi.ocnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;midi.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|card-&gt;midi.owait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|count
op_star
id|HZ
)paren
op_div
l_int|3100
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs46xx: midi timed out??&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|card-&gt;midi.owait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
id|card-&gt;midi.open_mode
op_and_assign
(paren
op_complement
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|card-&gt;midi.open_wait
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *   Midi file operations struct.&n; */
DECL|variable|cs_midi_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|cs_midi_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs_llseek
comma
id|read
suffix:colon
id|cs_midi_read
comma
id|write
suffix:colon
id|cs_midi_write
comma
id|poll
suffix:colon
id|cs_midi_poll
comma
id|open
suffix:colon
id|cs_midi_open
comma
id|release
suffix:colon
id|cs_midi_release
comma
)brace
suffix:semicolon
DECL|function|cs_llseek
r_static
id|loff_t
id|cs_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * CopySamples copies 16-bit stereo signed samples from the source to the&n; * destination, possibly converting down to unsigned 8-bit and/or mono.&n; * count specifies the number of output bytes to write.&n; *&n; *  Arguments:&n; *&n; *  dst             - Pointer to a destination buffer.&n; *  src             - Pointer to a source buffer&n; *  count           - The number of bytes to copy into the destination buffer.&n; *  fmt             - CS_FMT_16BIT and/or CS_FMT_STEREO bits&n; *  dmabuf          - pointer to the dma buffer structure&n; *&n; * NOTES: only call this routine if the output desired is not 16 Signed Stereo&n; * &t;&n; *&n; */
DECL|function|CopySamples
r_static
r_void
id|CopySamples
c_func
(paren
r_char
op_star
id|dst
comma
r_char
op_star
id|src
comma
r_int
id|count
comma
r_int
id|fmt
comma
r_struct
id|dmabuf
op_star
id|dmabuf
)paren
(brace
id|s32
id|s32AudioSample
suffix:semicolon
id|s16
op_star
id|psSrc
op_assign
(paren
id|s16
op_star
)paren
id|src
suffix:semicolon
id|s16
op_star
id|psDst
op_assign
(paren
id|s16
op_star
)paren
id|dst
suffix:semicolon
id|u8
op_star
id|pucDst
op_assign
(paren
id|u8
op_star
)paren
id|dst
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: CopySamples()+ &quot;
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; dst=0x%x src=0x%x count=%d fmt=0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|dst
comma
(paren
r_int
)paren
id|src
comma
(paren
r_int
)paren
id|count
comma
(paren
r_int
)paren
id|fmt
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * See if the data should be output as 8-bit unsigned stereo.&n;     */
r_if
c_cond
(paren
(paren
id|fmt
op_amp
id|CS_FMT_STEREO
)paren
op_logical_and
op_logical_neg
(paren
id|fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
multiline_comment|/*&n;         * Convert each 16-bit signed stereo sample to 8-bit unsigned &n;&t; * stereo using rounding.&n;         */
id|psSrc
op_assign
(paren
id|s16
op_star
)paren
id|src
suffix:semicolon
id|count
op_assign
id|count
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
op_star
(paren
id|pucDst
op_increment
)paren
op_assign
(paren
id|u8
)paren
(paren
(paren
(paren
id|s16
)paren
(paren
op_star
id|psSrc
op_increment
)paren
op_plus
(paren
id|s16
)paren
l_int|0x8000
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * See if the data should be output at 8-bit unsigned mono.&n;     */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|fmt
op_amp
id|CS_FMT_STEREO
)paren
op_logical_and
op_logical_neg
(paren
id|fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
multiline_comment|/*&n;         * Convert each 16-bit signed stereo sample to 8-bit unsigned &n;&t; * mono using averaging and rounding.&n;         */
id|psSrc
op_assign
(paren
id|s16
op_star
)paren
id|src
suffix:semicolon
id|count
op_assign
id|count
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|s32AudioSample
op_assign
(paren
(paren
op_star
id|psSrc
)paren
op_plus
(paren
op_star
(paren
id|psSrc
op_plus
l_int|1
)paren
)paren
)paren
op_div
l_int|2
op_plus
(paren
id|s32
)paren
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
id|s32AudioSample
OG
l_int|0x7fff
)paren
(brace
id|s32AudioSample
op_assign
l_int|0x7fff
suffix:semicolon
)brace
op_star
(paren
id|pucDst
op_increment
)paren
op_assign
(paren
id|u8
)paren
(paren
(paren
(paren
id|s16
)paren
id|s32AudioSample
op_plus
(paren
id|s16
)paren
l_int|0x8000
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|psSrc
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * See if the data should be output at 16-bit signed mono.&n;     */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|fmt
op_amp
id|CS_FMT_STEREO
)paren
op_logical_and
(paren
id|fmt
op_amp
id|CS_FMT_16BIT
)paren
)paren
(brace
multiline_comment|/*&n;         * Convert each 16-bit signed stereo sample to 16-bit signed &n;&t; * mono using averaging.&n;         */
id|psSrc
op_assign
(paren
id|s16
op_star
)paren
id|src
suffix:semicolon
id|count
op_assign
id|count
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
op_star
(paren
id|psDst
op_increment
)paren
op_assign
(paren
id|s16
)paren
(paren
(paren
op_star
id|psSrc
)paren
op_plus
(paren
op_star
(paren
id|psSrc
op_plus
l_int|1
)paren
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|psSrc
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * cs_copy_to_user()&n; * replacement for the standard copy_to_user, to allow for a conversion from&n; * 16 bit to 8 bit and from stereo to mono, if the record conversion is active.  &n; * The current CS46xx/CS4280 static image only records in 16bit unsigned Stereo, &n; * so we convert from any of the other format combinations.&n; */
DECL|function|cs_copy_to_user
r_static
r_int
id|cs_copy_to_user
c_func
(paren
r_struct
id|cs_state
op_star
id|s
comma
r_void
op_star
id|dest
comma
r_void
op_star
id|hwsrc
comma
r_int
id|cnt
comma
r_int
op_star
id|copied
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|s-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|src
op_assign
id|hwsrc
suffix:semicolon
multiline_comment|/* default to the standard destination buffer addr */
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs_copy_to_user()+ fmt=0x%x cnt=%d dest=0x%.8x&bslash;n&quot;
comma
id|dmabuf-&gt;fmt
comma
(paren
r_int
)paren
id|cnt
comma
(paren
r_int
)paren
id|dest
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|dmabuf-&gt;dmasize
)paren
(brace
id|cnt
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
(brace
op_star
id|copied
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;divisor
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;tmpbuff
)paren
(brace
op_star
id|copied
op_assign
id|cnt
op_div
id|dmabuf-&gt;divisor
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|CopySamples
c_func
(paren
(paren
r_char
op_star
)paren
id|dmabuf-&gt;tmpbuff
comma
(paren
r_char
op_star
)paren
id|hwsrc
comma
id|cnt
comma
id|dmabuf-&gt;fmt
comma
id|dmabuf
)paren
suffix:semicolon
id|src
op_assign
id|dmabuf-&gt;tmpbuff
suffix:semicolon
id|cnt
op_assign
id|cnt
op_div
id|dmabuf-&gt;divisor
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dest
comma
id|src
comma
id|cnt
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: cs_copy_to_user()- fault dest=0x%x src=0x%x cnt=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|dest
comma
(paren
r_int
)paren
id|src
comma
id|cnt
)paren
)paren
suffix:semicolon
op_star
id|copied
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
op_star
id|copied
op_assign
id|cnt
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs_copy_to_user()- copied bytes is %d &bslash;n&quot;
comma
id|cnt
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be copied to&n;   the user&squot;s buffer.  it is filled by the dma machine and drained by this loop. */
DECL|function|cs_read
r_static
id|ssize_t
id|cs_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_read()+ %d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|cnt
)paren
id|cnt
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
(paren
id|count
op_star
id|dmabuf-&gt;divisor
)paren
)paren
id|cnt
op_assign
id|count
op_star
id|dmabuf-&gt;divisor
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
multiline_comment|/* buffer is empty, start the dma machine and wait for data to be&n;&t;&t;&t;   recorded */
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;_read() copy_to cnt=%d count=%d &quot;
comma
id|cnt
comma
id|count
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; .dmasize=%d .count=%d buffer=0x%.8x ret=%d&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;count
comma
(paren
r_int
)paren
id|buffer
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cs_copy_to_user
c_func
(paren
id|state
comma
id|buffer
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
)paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
)paren
comma
id|cnt
comma
op_amp
id|copied
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|copied
suffix:semicolon
id|buffer
op_add_assign
id|copied
suffix:semicolon
id|ret
op_add_assign
id|copied
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_read()- %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be dma to&n;   the soundcard.  it is drained by the dma machine and filled by this loop. */
DECL|function|cs_write
r_static
id|ssize_t
id|cs_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
op_or
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_write called, count = %d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun, we are recovering from sleep_on_timeout,&n;&t;&t;&t;   resync hwptr and swptr */
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;underrun
)paren
(brace
id|dmabuf-&gt;underrun
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|cs_get_dma_addr
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_plus
id|cnt
OG
id|dmabuf-&gt;dmasize
)paren
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
multiline_comment|/* buffer is full, start the dma machine and wait for data to be&n;&t;&t;&t;   played */
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_write() d-&gt;count &gt; dmasize - resetting&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
id|dmabuf-&gt;endcleared
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_write()- ret=0x%x&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs_poll
r_static
r_int
r_int
id|cs_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_poll()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_WRITE
op_or
id|FMODE_READ
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_ge
id|dmabuf-&gt;count
op_plus
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_poll()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We let users mmap the ring buffer. Its not the real DMA buffer but&n; *&t;that side of the code is hidden in the IRQ handling. We do a software&n; *&t;emulation of DMA from a 64K or so buffer into a 2K FIFO. &n; *&t;(the hardware probably deserves a moan here but Crystal send me nice&n; *&t;toys ;)).&n; */
DECL|function|cs_mmap
r_static
r_int
id|cs_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_PARMS
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_mmap()+ file=0x%x %s %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|file
comma
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
ques
c_cond
l_string|&quot;VM_WRITE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|vma-&gt;vm_flags
op_amp
id|VM_READ
ques
c_cond
l_string|&quot;VM_READ&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_mmap() VM_WRITE - state TRUE prog_dmabuf DAC&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_mmap() VM_READ - state TRUE prog_dmabuf ADC&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
)brace
r_else
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_mmap() return -EINVAL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * For now ONLY support playback, but seems like the only way to use&n; * mmap() is to open an FD with RDWR, just read or just write access&n; * does not function, get an error back from the kernel.&n; * Also, QuakeIII opens with RDWR!  So, there must be something&n; * to needing read/write access mapping.  So, allow read/write but &n; * use the DAC only.&n; */
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_int
)paren
id|state
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_mmap(): size=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
l_int|1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_mmap()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_ioctl
r_static
r_int
id|cs_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
comma
id|valsave
comma
id|mapped
comma
id|ret
suffix:semicolon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|mapped
op_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|dmabuf-&gt;mapped
suffix:semicolon
)brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|mapped
op_or_assign
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|dmabuf-&gt;mapped
suffix:semicolon
)brace
macro_line|#if CSDEBUG
id|printioctl
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
multiline_comment|/* FIXME: spin_lock ? */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;blocks
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;blocks
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: DSP_RESET()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|drain_dac
c_func
(paren
id|state
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* set sample rate */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
id|cs_set_adc_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
id|cs_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_ioctl() DSP_SPEED %s %s %d&bslash;n&quot;
comma
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
ques
c_cond
l_string|&quot;DAC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|file-&gt;f_mode
op_amp
id|FMODE_READ
ques
c_cond
l_string|&quot;ADC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dmabuf-&gt;rate
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* set stereo or mono channel */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: DSP_STEREO() DAC %s&bslash;n&quot;
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
ques
c_cond
l_string|&quot;STEREO&quot;
suffix:colon
l_string|&quot;MONO&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: DSP_STEREO() ADC %s&bslash;n&quot;
comma
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
ques
c_cond
l_string|&quot;STEREO&quot;
suffix:colon
l_string|&quot;MONO&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
op_div
id|dmabuf-&gt;divisor
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask of supported sample format*/
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Select sample format */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_ioctl() DSP_SETFMT %s %s %s %s&bslash;n&quot;
comma
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
ques
c_cond
l_string|&quot;DAC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|file-&gt;f_mode
op_amp
id|FMODE_READ
ques
c_cond
l_string|&quot;ADC&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|val
op_eq
id|AFMT_S16_LE
ques
c_cond
l_string|&quot;16Bit Signed&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|val
op_eq
id|AFMT_U8
ques
c_cond
l_string|&quot;8Bit Unsigned&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|valsave
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_QUERY
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
op_logical_or
id|val
op_eq
id|AFMT_U8
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_16BIT
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_16BIT
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|val
op_assign
id|valsave
suffix:semicolon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_16BIT
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_16BIT
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: DSP_SETFMT() Unsupported format (0x%x)&bslash;n&quot;
comma
id|valsave
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|dmabuf
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_16BIT
)paren
(brace
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_else
r_return
id|put_user
c_func
(paren
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|1
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;SGok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|1
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
id|put_user
c_func
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/*&n;&t;&t; * There will be a longer than normal pause in the data.&n;&t;&t; * so... do nothing, because there is nothing that we can do.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
multiline_comment|/*&n;&t;&t; * for mmap we always have total space available&n;&t;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
r_else
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
op_div
id|dmabuf-&gt;divisor
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;count
op_div
id|dmabuf-&gt;divisor
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: DSP_GETTRIGGER()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|state
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
)brace
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: DSP_GETTRIGGER()- val=0x%x&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
op_div
id|dmabuf-&gt;divisor
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_div
id|dmabuf-&gt;divisor
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
op_div
id|dmabuf-&gt;divisor
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|cinfo.blocks
op_assign
(paren
id|cinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
)paren
op_minus
id|dmabuf-&gt;blocks
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
l_string|&quot;total_bytes=%d blocks=%d dmabuf-&gt;blocks=%d&bslash;n&quot;
comma
id|cinfo.bytes
comma
id|cinfo.blocks
comma
id|dmabuf-&gt;blocks
)paren
)paren
suffix:semicolon
id|dmabuf-&gt;blocks
op_assign
id|cinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
)brace
r_else
(brace
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
)brace
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: GETOPTR bytes=%d blocks=%d ptr=%d&bslash;n&quot;
comma
id|cinfo.bytes
comma
id|cinfo.blocks
comma
id|cinfo.ptr
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|val
op_assign
l_int|0
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_return
id|put_user
c_func
(paren
(paren
id|dmabuf-&gt;fmt
op_amp
id|CS_FMT_STEREO
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_MAPINBUF
suffix:colon
r_case
id|SNDCTL_DSP_MAPOUTBUF
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;AMP control - null AMP&n; */
DECL|function|amp_none
r_static
r_void
id|amp_none
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
)brace
multiline_comment|/*&n; *&t;Crystal EAPD mode&n; */
DECL|function|amp_voyetra
r_static
r_void
id|amp_voyetra
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
multiline_comment|/* Manage the EAPD bit on the Crystal 4297 &n;&t;   and the Analog AD1885 */
r_int
id|old
op_assign
id|card-&gt;amplifier
suffix:semicolon
id|card-&gt;amplifier
op_add_assign
id|change
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;amplifier
op_logical_and
op_logical_neg
id|old
)paren
(brace
multiline_comment|/* Turn the EAPD amp on */
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_or
l_int|0x8000
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|old
op_logical_and
op_logical_neg
id|card-&gt;amplifier
)paren
(brace
multiline_comment|/* Turn the EAPD amp off */
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
op_complement
l_int|0x8000
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Untested&n; */
DECL|function|amp_voyetra_4294
r_static
r_void
id|amp_voyetra_4294
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
r_struct
id|ac97_codec
op_star
id|c
op_assign
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
id|card-&gt;amplifier
op_add_assign
id|change
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;amplifier
)paren
(brace
multiline_comment|/* Switch the GPIO pins 7 and 8 to open drain */
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x4C
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x4C
)paren
op_amp
l_int|0xFE7F
)paren
suffix:semicolon
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x4E
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x4E
)paren
op_or
l_int|0x0180
)paren
suffix:semicolon
multiline_comment|/* Now wake the AMP (this might be backwards) */
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x54
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x54
)paren
op_amp
op_complement
l_int|0x0180
)paren
suffix:semicolon
)brace
r_else
(brace
id|cs_ac97_set
c_func
(paren
id|c
comma
l_int|0x54
comma
id|cs_ac97_get
c_func
(paren
id|c
comma
l_int|0x54
)paren
op_or
l_int|0x0180
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Handle the CLKRUN on a thinkpad. We must disable CLKRUN support&n; *&t;whenever we need to beat on the chip.&n; *&n; *&t;The original idea and code for this hack comes from David Kaiser at&n; *&t;Linuxcare. Perhaps one day Crystal will document their chips well&n; *&t;enough to make them useful.&n; */
DECL|function|clkrun_hack
r_static
r_void
id|clkrun_hack
c_func
(paren
r_struct
id|cs_card
op_star
id|card
comma
r_int
id|change
)paren
(brace
r_struct
id|pci_dev
op_star
id|acpi_dev
suffix:semicolon
id|u16
id|control
suffix:semicolon
id|u8
id|pp
suffix:semicolon
r_int
r_int
id|port
suffix:semicolon
r_int
id|old
op_assign
id|card-&gt;amplifier
suffix:semicolon
id|card-&gt;amplifier
op_add_assign
id|change
suffix:semicolon
id|acpi_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82371AB_3
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_dev
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Not a thinkpad thats for sure */
multiline_comment|/* Find the control port */
id|pci_read_config_byte
c_func
(paren
id|acpi_dev
comma
l_int|0x41
comma
op_amp
id|pp
)paren
suffix:semicolon
id|port
op_assign
id|pp
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* Read ACPI port */
id|control
op_assign
id|inw
c_func
(paren
id|port
op_plus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* Flip CLKRUN off while running */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;amplifier
op_logical_and
id|old
)paren
(brace
id|outw
c_func
(paren
id|control
op_or
l_int|0x2000
comma
id|port
op_plus
l_int|0x10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;amplifier
op_logical_and
op_logical_neg
id|old
)paren
(brace
id|outw
c_func
(paren
id|control
op_amp
op_complement
l_int|0x2000
comma
id|port
op_plus
l_int|0x10
)paren
suffix:semicolon
)brace
)brace
DECL|function|cs_open
r_static
r_int
id|cs_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_open()+ file=0x%x %s %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|file
comma
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
ques
c_cond
l_string|&quot;FMODE_WRITE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|file-&gt;f_mode
op_amp
id|FMODE_READ
ques
c_cond
l_string|&quot;FMODE_READ&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hardcode state[0] for capture, [1] for playback&n;&t; */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_open() FMODE_READ&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;states
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cs_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;pbuf
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;pbuf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;open_mode
op_amp
id|FMODE_READ
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|dmabuf-&gt;channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;channel
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|card-&gt;states
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Now turn on external AMP if needed */
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|state-&gt;card
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|state-&gt;card
comma
l_int|1
)paren
suffix:semicolon
id|dmabuf-&gt;channel-&gt;state
op_assign
id|state
suffix:semicolon
multiline_comment|/* initialize the virtual channel */
id|state-&gt;virt
op_assign
l_int|0
suffix:semicolon
id|state-&gt;magic
op_assign
id|CS_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|card
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
multiline_comment|/* set default sample format. According to OSS Programmer&squot;s Guide  /dev/dsp&n;&t;&t;   should be default to unsigned 8-bits, mono, with sample rate 8kHz and&n;&t;&t;   /dev/dspW will accept 16-bits sample */
multiline_comment|/* Default input is 8bit mono */
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_MASK
suffix:semicolon
id|dmabuf-&gt;type
op_assign
id|CS_TYPE_ADC
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|cs_set_adc_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
id|state-&gt;open_mode
op_or_assign
id|FMODE_READ
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_open() FMODE_WRITE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;states
(braket
l_int|1
)braket
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cs_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;pbuf
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;pbuf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|card-&gt;states
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;open_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|dmabuf-&gt;channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;channel
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|card-&gt;states
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Now turn on external AMP if needed */
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|state-&gt;card
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|state-&gt;card
comma
l_int|1
)paren
suffix:semicolon
id|dmabuf-&gt;channel-&gt;state
op_assign
id|state
suffix:semicolon
multiline_comment|/* initialize the virtual channel */
id|state-&gt;virt
op_assign
l_int|1
suffix:semicolon
id|state-&gt;magic
op_assign
id|CS_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|card
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
multiline_comment|/* set default sample format. According to OSS Programmer&squot;s Guide  /dev/dsp&n;&t;&t;   should be default to unsigned 8-bits, mono, with sample rate 8kHz and&n;&t;&t;   /dev/dspW will accept 16-bits sample */
multiline_comment|/* Default output is 8bit mono. */
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_MASK
suffix:semicolon
id|dmabuf-&gt;type
op_assign
id|CS_TYPE_DAC
suffix:semicolon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|cs_set_dac_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
id|cs_set_divisor
c_func
(paren
id|dmabuf
)paren
suffix:semicolon
id|state-&gt;open_mode
op_or_assign
id|FMODE_WRITE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_open()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_release
r_static
r_int
id|cs_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
(paren
r_struct
id|cs_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_struct
id|cs_state
op_star
id|state
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_RELEASE
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_release()+ file=0x%x %s %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|file
comma
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
ques
c_cond
l_string|&quot;FMODE_WRITE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|file-&gt;f_mode
op_amp
id|FMODE_READ
ques
c_cond
l_string|&quot;FMODE_READ&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_WRITE
op_or
id|FMODE_READ
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
r_if
c_cond
(paren
(paren
id|state-&gt;open_mode
op_amp
id|FMODE_WRITE
)paren
op_amp
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_RELEASE
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_release() FMODE_WRITE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|cs_clear_tail
c_func
(paren
id|state
)paren
suffix:semicolon
id|drain_dac
c_func
(paren
id|state
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
multiline_comment|/* stop DMA state machine and free DMA buffers/channels */
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;channel-&gt;num
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|state-&gt;dmabuf.pbuf
)paren
suffix:semicolon
multiline_comment|/* we&squot;re covered by the open_sem */
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|state-&gt;open_mode
op_and_assign
(paren
op_complement
id|file-&gt;f_mode
)paren
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
multiline_comment|/* Now turn off external AMP if needed */
id|state-&gt;card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|state-&gt;card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|state-&gt;card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
r_if
c_cond
(paren
(paren
id|state-&gt;open_mode
op_amp
id|FMODE_READ
)paren
op_amp
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_RELEASE
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_release() FMODE_READ&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;channel-&gt;num
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|state-&gt;dmabuf.pbuf
)paren
suffix:semicolon
multiline_comment|/* we&squot;re covered by the open_sem */
id|up
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|state-&gt;open_mode
op_and_assign
(paren
op_complement
id|file-&gt;f_mode
)paren
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
multiline_comment|/* Now turn off external AMP if needed */
id|state-&gt;card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|state-&gt;card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|state-&gt;card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|state-&gt;card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_RELEASE
comma
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;cs46xx: cs_release()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cs461x_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|cs461x_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs_llseek
comma
id|read
suffix:colon
id|cs_read
comma
id|write
suffix:colon
id|cs_write
comma
id|poll
suffix:colon
id|cs_poll
comma
id|ioctl
suffix:colon
id|cs_ioctl
comma
id|mmap
suffix:colon
id|cs_mmap
comma
id|open
suffix:colon
id|cs_open
comma
id|release
suffix:colon
id|cs_release
comma
)brace
suffix:semicolon
multiline_comment|/* Write AC97 codec registers */
DECL|function|cs_ac97_get
r_static
id|u16
id|cs_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address&n;&t; *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97 &n;&t; *  3. Write ACCTL = Control Register = 460h for initiating the write&n;&t; *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h&n;&t; *  5. if DCV not cleared, break and return error&n;&t; *  6. Read ACSTS = Status Register = 464h, check VSTS bit&n;&t; */
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSDA
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Setup the AC97 control registers on the CS461x to send the&n;&t; *  appropriate command to the AC97 to perform the read.&n;&t; *  ACCAD = Command Address Register = 46Ch&n;&t; *  ACCDA = Command Data Register = 470h&n;&t; *  ACCTL = Control Register = 460h&n;&t; *  set DCV - will clear when process completed&n;&t; *  set CRW - Read command&n;&t; *  set VFRM - valid frame enabled&n;&t; *  set ESYN - ASYNC generation enabled&n;&t; *  set RSTN - ARST# inactive, AC97 codec not reset&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCAD
comma
id|reg
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCDA
comma
l_int|0
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_DCV
op_or
id|ACCTL_CRW
op_or
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait for the read to occur.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|500
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, we want to wait for a short time.&n;&t; &t; */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Now, check to see if the read has completed.&n;&t;&t; *  ACCTL = 460h, DCV should be reset by now and 460h = 17h&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure the read completed.&n;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: AC&squot;97 read problem (ACCTL_DCV), reg = 0x%x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Wait for the valid status bit to go active.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|100
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Read the AC97 status register.&n;&t;&t; *  ACSTS = Status Register = 464h&n;&t;&t; *  VSTS - Valid Status&n;&t;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_VSTS
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure we got valid status.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_VSTS
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: AC&squot;97 read problem (ACSTS_VSTS), reg = 0x%x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Read the data returned from the AC97 register.&n;&t; *  ACSDA = Status Data Register = 474h&n;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;e) reg = 0x%x, val = 0x%x, BA0_ACCAD = 0x%x&bslash;n&quot;
comma
id|reg
comma
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSDA
)paren
comma
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCAD
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSDA
)paren
suffix:semicolon
)brace
DECL|function|cs_ac97_set
r_static
r_void
id|cs_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|val
)paren
(brace
r_struct
id|cs_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|val2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
id|AC97_CD_VOL
)paren
(brace
id|val2
op_assign
id|cs_ac97_get
c_func
(paren
id|dev
comma
id|AC97_CD_VOL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address&n;&t; *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97&n;&t; *  3. Write ACCTL = Control Register = 460h for initiating the write&n;&t; *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h&n;&t; *  5. if DCV not cleared, break and return error&n;&t; */
multiline_comment|/*&n;&t; *  Setup the AC97 control registers on the CS461x to send the&n;&t; *  appropriate command to the AC97 to perform the read.&n;&t; *  ACCAD = Command Address Register = 46Ch&n;&t; *  ACCDA = Command Data Register = 470h&n;&t; *  ACCTL = Control Register = 460h&n;&t; *  set DCV - will clear when process completed&n;&t; *  reset CRW - Write command&n;&t; *  set VFRM - valid frame enabled&n;&t; *  set ESYN - ASYNC generation enabled&n;&t; *  set RSTN - ARST# inactive, AC97 codec not reset&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCAD
comma
id|reg
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCDA
comma
id|val
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_DCV
op_or
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|1000
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, we want to wait for a short time.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Now, check to see if the write has completed.&n;&t;&t; *  ACCTL = 460h, DCV should be reset by now and 460h = 07h&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure the write completed.&n;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: AC&squot;97 write problem, reg = 0x%x, val = 0x%x&bslash;n&quot;
comma
id|reg
comma
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Adjust power if the mixer is selected/deselected according&n;&t; *&t;to the CD.&n;&t; *&n;&t; *&t;IF the CD is a valid input source (mixer or direct) AND&n;&t; *&t;&t;the CD is not muted THEN power is needed&n;&t; *&n;&t; *&t;We do two things. When record select changes the input to&n;&t; *&t;add/remove the CD we adjust the power count if the CD is&n;&t; *&t;unmuted.&n;&t; *&n;&t; *&t;When the CD mute changes we adjust the power level if the&n;&t; *&t;CD was a valid input.&n;&t; *&n;&t; *      We also check for CD volume != 0, as the CD mute isn&squot;t&n;&t; *      normally tweaked from userspace.&n;&t; */
multiline_comment|/* CD mute change ? */
r_if
c_cond
(paren
id|reg
op_eq
id|AC97_CD_VOL
)paren
(brace
multiline_comment|/* Mute bit change ? */
r_if
c_cond
(paren
(paren
id|val2
op_xor
id|val
)paren
op_amp
l_int|0x8000
op_logical_or
(paren
(paren
id|val2
op_eq
l_int|0x1f1f
op_logical_or
id|val
op_eq
l_int|0x1f1f
)paren
op_logical_and
id|val2
op_ne
id|val
)paren
)paren
(brace
multiline_comment|/* This is a hack but its cleaner than the alternatives.&n;&t;&t;&t;   Right now card-&gt;ac97_codec[0] might be NULL as we are&n;&t;&t;&t;   still doing codec setup. This does an early assignment&n;&t;&t;&t;   to avoid the problem if it occurs */
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
op_assign
id|dev
suffix:semicolon
)brace
multiline_comment|/* Mute on */
r_if
c_cond
(paren
id|val
op_amp
l_int|0x8000
op_logical_or
id|val
op_eq
l_int|0x1f1f
)paren
(brace
id|card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Mute off power on */
id|card
op_member_access_from_pointer
id|amplifier_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OSS /dev/mixer file operation methods */
DECL|function|cs_open_mixdev
r_static
r_int
id|cs_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|devs
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
r_goto
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|file-&gt;private_data
op_assign
id|card-&gt;ac97_codec
(braket
id|i
)braket
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_release_mixdev
r_static
r_int
id|cs_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|devs
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
r_goto
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs_ioctl_mixdev
r_static
r_int
id|cs_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
(paren
r_struct
id|ac97_codec
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
macro_line|#if CSDEBUG_INTERFACE
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_GETDBGMASK
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_SETDBGMASK
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_GETDBGLEVEL
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_SETDBGLEVEL
)paren
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_CS_GETDBGMASK
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debugmask
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CS_GETDBGLEVEL
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debuglevel
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGMASK
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debugmask
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGLEVEL
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debuglevel
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: mixer_ioctl(): ERROR unknown debug cmd&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|codec
op_member_access_from_pointer
id|mixer_ioctl
c_func
(paren
id|codec
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|cs_mixer_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|cs_mixer_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs_llseek
comma
id|ioctl
suffix:colon
id|cs_ioctl_mixdev
comma
id|open
suffix:colon
id|cs_open_mixdev
comma
id|release
suffix:colon
id|cs_release_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/* AC97 codec initialisation. */
DECL|function|cs_ac97_init
r_static
r_int
id|__init
id|cs_ac97_init
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|num_ac97
op_assign
l_int|0
suffix:semicolon
r_int
id|ready_2nd
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
suffix:semicolon
id|u16
id|eid
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|codec
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some basic codec information, other fields will be filled&n;&t;&t;   in ac97_probe_codec */
id|codec-&gt;private_data
op_assign
id|card
suffix:semicolon
id|codec-&gt;id
op_assign
id|num_ac97
suffix:semicolon
id|codec-&gt;codec_read
op_assign
id|cs_ac97_get
suffix:semicolon
id|codec-&gt;codec_write
op_assign
id|cs_ac97_set
suffix:semicolon
r_if
c_cond
(paren
id|ac97_probe_codec
c_func
(paren
id|codec
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|eid
op_assign
id|cs_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
l_int|0xFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: no codec attached ?&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_features
op_assign
id|eid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|cs_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
id|codec
suffix:semicolon
multiline_comment|/* if there is no secondary codec at all, don&squot;t probe any more */
r_if
c_cond
(paren
op_logical_neg
id|ready_2nd
)paren
r_return
id|num_ac97
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|num_ac97
suffix:semicolon
)brace
multiline_comment|/*&n; * load the static image into the DSP&n; */
macro_line|#include &quot;cs461x_image.h&quot;
DECL|function|cs461x_download_image
r_static
r_void
id|cs461x_download_image
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|i
comma
id|j
comma
id|temp1
comma
id|temp2
comma
id|offset
comma
id|count
suffix:semicolon
r_int
r_char
op_star
id|pBA1
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
comma
l_int|0x40000
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CLEAR__COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
id|ClrStat
(braket
id|i
)braket
dot
id|BA1__DestByteOffset
suffix:semicolon
id|count
op_assign
id|ClrStat
(braket
id|i
)braket
dot
id|BA1__SourceSize
suffix:semicolon
r_for
c_loop
(paren
id|temp1
op_assign
id|offset
suffix:semicolon
id|temp1
OL
(paren
id|offset
op_plus
id|count
)paren
suffix:semicolon
id|temp1
op_add_assign
l_int|4
)paren
(brace
suffix:semicolon
)brace
id|writel
c_func
(paren
l_int|0
comma
id|pBA1
op_plus
id|temp1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILL__COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp2
op_assign
id|FillStat
(braket
id|i
)braket
dot
id|Offset
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
id|FillStat
(braket
id|i
)braket
dot
id|Size
)paren
op_div
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|temp1
op_assign
(paren
id|FillStat
(braket
id|i
)braket
)paren
dot
id|pFill
(braket
id|j
)braket
suffix:semicolon
id|writel
c_func
(paren
id|temp1
comma
id|pBA1
op_plus
id|temp2
op_plus
id|j
op_star
l_int|4
)paren
suffix:semicolon
)brace
)brace
id|iounmap
c_func
(paren
id|pBA1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Chip reset&n; */
DECL|function|cs461x_reset
r_static
r_void
id|cs461x_reset
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|idx
suffix:semicolon
multiline_comment|/*&n;&t; *  Write the reset bit of the SP control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
id|SPCR_RSTSP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Write the control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
id|SPCR_DRQEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Clear the trap registers.&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|8
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_DREG
comma
id|DREG_REGID_TRAP_SELECT
op_plus
id|idx
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_TWPR
comma
l_int|0xFFFF
)paren
suffix:semicolon
)brace
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_DREG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the frame timer to reflect the number of cycles per frame.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_FRMT
comma
l_int|0xadf
)paren
suffix:semicolon
)brace
DECL|function|cs461x_clear_serial_FIFOs
r_static
r_void
id|cs461x_clear_serial_FIFOs
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|idx
comma
id|loop
comma
id|powerdown
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; *  See if the devices are powered down.  If so, we must power them up first&n;&t; *  or they will not respond.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
)paren
)paren
op_amp
id|CLKCR1_SWCE
)paren
)paren
(brace
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
op_or
id|CLKCR1_SWCE
)paren
suffix:semicolon
id|powerdown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We want to clear out the serial port FIFOs so we don&squot;t end up playing&n;&t; *  whatever random garbage happens to be in them.  We fill the sample FIFOS&n;&t; *  with zero (silence).&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERBWP
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill all 256 sample FIFO locations.&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|256
suffix:semicolon
id|idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Make sure the previous FIFO write operation has completed.&n;&t;&t; */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|5
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_SERBST
)paren
op_amp
id|SERBST_WBSY
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_SERBST
)paren
op_amp
id|SERBST_WBSY
)paren
(brace
r_if
c_cond
(paren
id|powerdown
)paren
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Write the serial port FIFO index.&n;&t;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERBAD
comma
id|idx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Tell the serial port to load the new value into the FIFO location.&n;&t;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERBCM
comma
id|SERBCM_WRC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Now, if we powered up the devices, then power them back down again.&n;&t; *  This is kinda ugly, but should never happen.&n;&t; */
r_if
c_cond
(paren
id|powerdown
)paren
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|cs461x_powerup_dac
r_static
r_void
id|cs461x_powerup_dac
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; *  Power on the DACs on the AC97 card.  We turn off the DAC&n;&t; *  powerdown bit and write the new value of the power control&n;&t; *  register.&n;&t; */
id|tmp
op_assign
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|2
)paren
multiline_comment|/* already */
r_return
suffix:semicolon
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|tmp
op_amp
l_int|0xfdff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now, we wait until we sample a DAC ready state.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|32
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, lets wait a short while to let things settle out a&n;&t;&t; *  bit, and to prevent retrying the read too quickly.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Read the current state of the power control register.&n;&t;&t; */
r_if
c_cond
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|2
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check the status..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|2
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: powerup DAC failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|cs461x_powerup_adc
r_static
r_void
id|cs461x_powerup_adc
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; *  Power on the ADCs on the AC97 card.  We turn off the DAC&n;&t; *  powerdown bit and write the new value of the power control&n;&t; *  register.&n;&t; */
id|tmp
op_assign
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|1
)paren
multiline_comment|/* already */
r_return
suffix:semicolon
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
id|tmp
op_amp
l_int|0xfeff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now, we wait until we sample a ADC ready state.&n;&t; */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|32
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  First, lets wait a short while to let things settle out a&n;&t;&t; *  bit, and to prevent retrying the read too quickly.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Read the current state of the power control register.&n;&t;&t; */
r_if
c_cond
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|1
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check the status..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs_ac97_get
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: powerup ADC failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|cs461x_proc_start
r_static
r_void
id|cs461x_proc_start
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|cnt
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the frame timer to reflect the number of cycles per frame.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_FRMT
comma
l_int|0xadf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Turn on the run, run at frame, and DMA enable bits in the local copy of&n;&t; *  the SP control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
id|SPCR_RUN
op_or
id|SPCR_RUNFR
op_or
id|SPCR_DRQEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait until the run at frame bit resets itself in the SP control&n;&t; *  register.&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|25
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_SPCR
)paren
op_amp
id|SPCR_RUNFR
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_SPCR
)paren
op_amp
id|SPCR_RUNFR
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: SPCR_RUNFR never reset&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|cs461x_proc_stop
r_static
r_void
id|cs461x_proc_stop
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
multiline_comment|/*&n;&t; *  Turn off the run, run at frame, and DMA enable bits in the local copy of&n;&t; *  the SP control register.&n;&t; */
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_SPCR
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cs_hardware_init
r_static
r_int
id|cs_hardware_init
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
r_int
id|end_time
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/* &n;&t; *  First, blast the clock control register to zero so that the PLL starts&n;         *  out in a known state, and blast the master serial port control register&n;         *  to zero so that the serial ports also start out in a known state.&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
l_int|0
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERMC1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are in AC97 mode, then we must set the part to a host controlled&n;         *  AC-link.  Otherwise, we won&squot;t be able to bring up the link.&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERACC
comma
id|SERACC_HSP
op_or
id|SERACC_CODEC_TYPE_1_03
)paren
suffix:semicolon
multiline_comment|/* 1.03 card */
multiline_comment|/* cs461x_pokeBA0(card, BA0_SERACC, SERACC_HSP | SERACC_CODEC_TYPE_2_0); */
multiline_comment|/* 2.00 card */
multiline_comment|/*&n;         *  Drive the ARST# pin low for a minimum of 1uS (as defined in the AC97&n;         *  spec) and then drive it high.  This is done for non AC97 modes since&n;         *  there might be logic external to the CS461x that uses the ARST# line&n;         *  for a reset.&n;         */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The first thing we do here is to enable sync generation.  As soon&n;&t; *  as we start receiving bit clock, we&squot;ll start producing the SYNC&n;&t; *  signal.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now wait for a short while to allow the AC97 part to start&n;&t; *  generating bit clock (so we don&squot;t try to start the PLL without an&n;&t; *  input clock).&n;&t; */
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* 1 should be enough ?? (and pigs might fly) */
multiline_comment|/*&n;&t; *  Set the serial port timing configuration, so that&n;&t; *  the clock control circuit gets its clock from the correct place.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERMC1
comma
id|SERMC1_PTC_AC97
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Write the selected clock control setup to the hardware.  Do not turn on&n;&t; *  SWCE yet (if requested), so that the devices clocked by the output of&n;&t; *  PLL are not clocked until the PLL is stable.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_PLLCC
comma
id|PLLCC_LPF_1050_2780_KHZ
op_or
id|PLLCC_CDR_73_104_MHZ
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_PLLM
comma
l_int|0x3a
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR2
comma
id|CLKCR2_PDIVS_8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power up the PLL.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|CLKCR1_PLLP
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Wait until the PLL has stabilized.&n;&t; */
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Again 1 should be enough ?? */
multiline_comment|/*&n;&t; *  Turn on clocking of the core so that we can setup the serial ports.&n;&t; */
id|tmp
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
)paren
op_or
id|CLKCR1_SWCE
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill the serial port FIFOs with silence.&n;&t; */
id|cs461x_clear_serial_FIFOs
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the serial port FIFO pointer to the first sample in the FIFO.&n;&t; */
multiline_comment|/* cs461x_pokeBA0(card, BA0_SERBSP, 0); */
multiline_comment|/*&n;&t; *  Write the serial port configuration to the part.  The master&n;&t; *  enable bit is not set until all other values have been written.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERC1
comma
id|SERC1_SO1F_AC97
op_or
id|SERC1_SO1EN
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERC2
comma
id|SERC2_SI1F_AC97
op_or
id|SERC1_SO1EN
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_SERMC1
comma
id|SERMC1_PTC_AC97
op_or
id|SERMC1_MSPE
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Shouldnt be needed ?? */
multiline_comment|/*&n;&t; * Wait for the card ready signal from the AC97 card.&n;&t; */
id|end_time
op_assign
id|jiffies
op_plus
l_int|3
op_star
(paren
id|HZ
op_rshift
l_int|2
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; *  Read the AC97 status register to see if we&squot;ve seen a CODEC READY&n;&t;&t; *  signal from the AC97 card.&n;&t;&t; */
r_if
c_cond
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_CRDY
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|end_time
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Make sure CODEC is READY.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_CRDY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: create - never read card ready from AC&squot;97&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: it is probably not a bug, try using the CS4232 driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Assert the vaid frame signal so that we can start sending commands&n;&t; *  to the AC97 card.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACCTL
comma
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
op_or
id|ACCTL_RSTN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait until we&squot;ve sampled input slots 3 and 4 as valid, meaning that&n;&t; *  the card is pumping ADC data across the AC-link.&n;&t; */
id|end_time
op_assign
id|jiffies
op_plus
l_int|3
op_star
(paren
id|HZ
op_rshift
l_int|2
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; *  Read the input slot valid register and see if input slots 3 and&n;&t;&t; *  4 are valid yet.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACISV
)paren
op_amp
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
op_eq
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|end_time
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Make sure input slots 3 and 4 are valid.  If not, then return&n;&t; *  an error.&n;&t; */
r_if
c_cond
(paren
(paren
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_ACISV
)paren
op_amp
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
op_ne
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs461x: create - never read ISV3 &amp; ISV4 from AC&squot;97&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Now, assert valid frame and the slot 3 and 4 valid bits.  This will&n;&t; *  commense the transfer of digital audio data to the AC97 card.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_ACOSV
comma
id|ACOSV_SLV3
op_or
id|ACOSV_SLV4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power down the DAC and ADC.  We will power them up (if) when we need&n;&t; *  them.&n;&t; */
multiline_comment|/* cs461x_pokeBA0(card, BA0_AC97_POWERDOWN, 0x300); */
multiline_comment|/*&n;&t; *  Turn off the Processor by turning off the software clock enable flag in &n;&t; *  the clock control register.&n;&t; */
multiline_comment|/* tmp = cs461x_peekBA0(card, BA0_CLKCR1) &amp; ~CLKCR1_SWCE; */
multiline_comment|/* cs461x_pokeBA0(card, BA0_CLKCR1, tmp); */
multiline_comment|/*&n;         *  Reset the processor.&n;         */
id|cs461x_reset
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Download the image to the processor.&n;&t; */
id|cs461x_download_image
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Stop playback DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|card-&gt;pctl
op_assign
id|tmp
op_amp
l_int|0xffff0000
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
op_amp
l_int|0x0000ffff
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Stop capture DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|card-&gt;cctl
op_assign
id|tmp
op_amp
l_int|0x0000ffff
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
op_amp
l_int|0xffff0000
)paren
suffix:semicolon
multiline_comment|/* initialize AC97 codec and register /dev/mixer */
r_if
c_cond
(paren
id|cs_ac97_init
c_func
(paren
id|card
)paren
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Do we need this ?? */
id|cs461x_powerup_adc
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs461x_powerup_dac
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs461x_proc_start
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Enable interrupts on the part.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_HICR
comma
id|HICR_IEV
op_or
id|HICR_CHGM
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PFIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000f03f
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PFIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* playback interrupt enable */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000003f
suffix:semicolon
id|tmp
op_or_assign
l_int|0x00000001
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* capture interrupt enable */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* install the driver, we do not allocate hardware channel nor DMA buffer now, they are defered &n;   untill &quot;ACCESS&quot; time (in prog_dmabuf called by open/read/write/ioctl/mmap) */
multiline_comment|/*&n; *&t;Card subid table&n; */
DECL|struct|cs_card_type
r_struct
id|cs_card_type
(brace
DECL|member|vendor
id|u16
id|vendor
suffix:semicolon
DECL|member|id
id|u16
id|id
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|amp
r_void
(paren
op_star
id|amp
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|active
r_void
(paren
op_star
id|active
)paren
(paren
r_struct
id|cs_card
op_star
comma
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cards
r_static
r_struct
id|cs_card_type
id|__initdata
id|cards
(braket
)braket
op_assign
initialization_block
suffix:semicolon
macro_line|#ifdef CS46XX_PM
DECL|function|cs46xx_pm_callback
r_static
r_int
id|cs46xx_pm_callback
c_func
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|dev-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
r_switch
c_cond
(paren
id|rqst
)paren
(brace
r_case
id|PM_RESUME
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs46xx: PM resume request&bslash;n&quot;
)paren
suffix:semicolon
id|cs_hardware_init
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_SUSPEND
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs46xx: PM suspend request&bslash;n&quot;
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|resync_dma_ptrs
c_func
(paren
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|cs_install
r_static
r_int
id|__init
id|cs_install
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
)paren
(brace
r_struct
id|cs_card
op_star
id|card
suffix:semicolon
r_struct
id|cs_card_type
op_star
id|cp
op_assign
op_amp
id|cards
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef CS46XX_PM
r_struct
id|pm_dev
op_star
id|pmdev
suffix:semicolon
macro_line|#endif
id|u16
id|ss_card
comma
id|ss_vendor
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pci_dev
comma
id|PCI_SUBSYSTEM_VENDOR_ID
comma
op_amp
id|ss_vendor
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pci_dev
comma
id|PCI_SUBSYSTEM_ID
comma
op_amp
id|ss_card
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs_card
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|card
)paren
)paren
suffix:semicolon
id|card-&gt;ba0_addr
op_assign
id|pci_dev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|card-&gt;ba1_addr
op_assign
id|pci_dev-&gt;resource
(braket
l_int|1
)braket
dot
id|start
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|card-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|card-&gt;irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|card-&gt;magic
op_assign
id|CS_CARD_MAGIC
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Card found at 0x%08lx and 0x%08lx, IRQ %d&bslash;n&quot;
comma
id|card-&gt;ba0_addr
comma
id|card-&gt;ba1_addr
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|card-&gt;alloc_pcm_channel
op_assign
id|cs_alloc_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_pcm_channel
op_assign
id|cs_alloc_rec_pcm_channel
suffix:semicolon
id|card-&gt;free_pcm_channel
op_assign
id|cs_free_pcm_channel
suffix:semicolon
id|card-&gt;amplifier_ctrl
op_assign
id|amp_none
suffix:semicolon
id|card-&gt;active_ctrl
op_assign
id|amp_none
suffix:semicolon
r_while
c_loop
(paren
id|cp-&gt;name
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;vendor
op_eq
id|ss_vendor
op_logical_and
id|cp-&gt;id
op_eq
id|ss_card
)paren
(brace
id|card-&gt;amplifier_ctrl
op_assign
id|cp-&gt;amp
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;active
)paren
(brace
id|card-&gt;active_ctrl
op_assign
id|cp-&gt;active
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|cp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;name
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Unknown card (%04X:%04X) at 0x%08lx/0x%08lx, IRQ %d&bslash;n&quot;
comma
id|ss_vendor
comma
id|ss_card
comma
id|card-&gt;ba0_addr
comma
id|card-&gt;ba1_addr
comma
id|card-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: %s at 0x%08lx/0x%08lx, IRQ %d&bslash;n&quot;
comma
id|cp-&gt;name
comma
id|card-&gt;ba0_addr
comma
id|card-&gt;ba1_addr
comma
id|card-&gt;irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;amplifier_ctrl
op_eq
l_int|NULL
)paren
(brace
id|card-&gt;amplifier_ctrl
op_assign
id|amp_none
suffix:semicolon
id|card-&gt;active_ctrl
op_assign
id|clkrun_hack
suffix:semicolon
)brace
r_if
c_cond
(paren
id|external_amp
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Crystal EAPD support forced on.&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;amplifier_ctrl
op_assign
id|amp_voyetra
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thinkpad
op_eq
l_int|1
)paren
(brace
id|card-&gt;active_ctrl
op_assign
id|clkrun_hack
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Activating CLKRUN hack for Thinkpad.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* claim our iospace and irq */
id|card-&gt;ba0
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba0_addr
comma
id|CS461X_BA0_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.data0
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_DMEM0
comma
id|CS461X_BA1_DATA0_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.data1
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_DMEM1
comma
id|CS461X_BA1_DATA1_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.pmem
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_PMEM
comma
id|CS461X_BA1_PRG_SIZE
)paren
suffix:semicolon
id|card-&gt;ba1.name.reg
op_assign
id|ioremap
c_func
(paren
id|card-&gt;ba1_addr
op_plus
id|BA1_SP_REG
comma
id|CS461X_BA1_REG_SIZE
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;card-&gt;ba0=0x%.08x&bslash;n&quot;
comma
(paren
r_int
)paren
id|card-&gt;ba0
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;card-&gt;ba1=0x%.08x 0x%.08x 0x%.08x 0x%.08x&bslash;n&quot;
comma
(paren
r_int
)paren
id|card-&gt;ba1.name.data0
comma
(paren
r_int
)paren
id|card-&gt;ba1.name.data1
comma
(paren
r_int
)paren
id|card-&gt;ba1.name.pmem
comma
(paren
r_int
)paren
id|card-&gt;ba1.name.reg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;ba0
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.data0
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.data1
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.pmem
op_eq
l_int|0
op_logical_or
id|card-&gt;ba1.name.reg
op_eq
l_int|0
)paren
(brace
r_goto
id|fail2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|card-&gt;irq
comma
op_amp
id|cs_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;cs461x&quot;
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: unable to allocate irq %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
r_goto
id|fail2
suffix:semicolon
)brace
multiline_comment|/* register /dev/dsp */
r_if
c_cond
(paren
(paren
id|card-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|cs461x_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: unable to register dsp&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* register /dev/midi */
r_if
c_cond
(paren
(paren
id|card-&gt;dev_midi
op_assign
id|register_sound_midi
c_func
(paren
op_amp
id|cs_midi_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: unable to register midi&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cs_hardware_init
c_func
(paren
id|card
)paren
OL
l_int|0
)paren
(brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev_midi
)paren
(brace
id|unregister_sound_midi
c_func
(paren
id|card-&gt;dev_midi
)paren
suffix:semicolon
)brace
r_goto
id|fail
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|card-&gt;midi.open_wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|card-&gt;midi.open_sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|card-&gt;midi.iwait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|card-&gt;midi.owait
)paren
suffix:semicolon
id|card-&gt;next
op_assign
id|devs
suffix:semicolon
id|devs
op_assign
id|card
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_MIDCR
comma
id|MIDCR_MRST
)paren
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_MIDCR
comma
l_int|0
)paren
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CS46XX_PM
id|pmdev
op_assign
id|pm_register
c_func
(paren
id|PM_PCI_DEV
comma
id|PM_PCI_ID
c_func
(paren
id|pci_dev
)paren
comma
id|cs46xx_pm_callback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmdev
)paren
id|pmdev-&gt;data
op_assign
id|card
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|fail2
suffix:colon
r_if
c_cond
(paren
id|card-&gt;ba0
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.data0
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.data1
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.pmem
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.pmem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;ba1.name.reg
)paren
(brace
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.reg
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|cs_remove
r_static
r_void
id|cs_remove
c_func
(paren
r_struct
id|cs_card
op_star
id|card
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PFIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000f03f
suffix:semicolon
id|tmp
op_or_assign
l_int|0x00000010
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PFIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* playback interrupt disable */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CIE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0000003f
suffix:semicolon
id|tmp
op_or_assign
l_int|0x00000011
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CIE
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* capture interrupt disable */
multiline_comment|/*&n;         *  Stop playback DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_PCTL
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_PCTL
comma
id|tmp
op_amp
l_int|0x0000ffff
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Stop capture DMA.&n;&t; */
id|tmp
op_assign
id|cs461x_peek
c_func
(paren
id|card
comma
id|BA1_CCTL
)paren
suffix:semicolon
id|cs461x_poke
c_func
(paren
id|card
comma
id|BA1_CCTL
comma
id|tmp
op_amp
l_int|0xffff0000
)paren
suffix:semicolon
multiline_comment|/*&n;         *  Reset the processor.&n;         */
id|cs461x_reset
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs461x_proc_stop
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power down the DAC and ADC.  We will power them up (if) when we need&n;&t; *  them.&n;&t; */
id|cs_ac97_set
c_func
(paren
id|card-&gt;ac97_codec
(braket
l_int|0
)braket
comma
id|AC97_POWER_CONTROL
comma
l_int|0x300
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Power down the PLL.&n;&t; */
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Turn off the Processor by turning off the software clock enable flag in &n;&t; *  the clock control register.&n;&t; */
id|tmp
op_assign
id|cs461x_peekBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
)paren
op_amp
op_complement
id|CLKCR1_SWCE
suffix:semicolon
id|cs461x_pokeBA0
c_func
(paren
id|card
comma
id|BA0_CLKCR1
comma
id|tmp
)paren
suffix:semicolon
id|card
op_member_access_from_pointer
id|active_ctrl
c_func
(paren
id|card
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* free hardware resources */
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba0
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data0
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.data1
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.pmem
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|card-&gt;ba1.name.reg
)paren
suffix:semicolon
multiline_comment|/* unregister audio devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev_midi
)paren
(brace
id|unregister_sound_midi
c_func
(paren
id|card-&gt;dev_midi
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Alan Cox &lt;alan@redhat.com&gt;, Jaroslav Kysela, &lt;audio@crystal.cirrus.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Crystal SoundFusion Audio Support&quot;
)paren
suffix:semicolon
DECL|function|cs_probe
r_int
id|__init
id|cs_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|foundone
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
multiline_comment|/* No PCI bus in this machine! */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Crystal 4280/461x + AC97 Audio, version &quot;
id|DRIVER_VERSION
l_string|&quot;, &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_CIRRUS
comma
l_int|0x6001
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cs_install
c_func
(paren
id|pcidev
)paren
op_eq
l_int|0
)paren
id|foundone
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_CIRRUS
comma
l_int|0x6003
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cs_install
c_func
(paren
id|pcidev
)paren
op_eq
l_int|0
)paren
id|foundone
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_CIRRUS
comma
l_int|0x6004
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cs_install
c_func
(paren
id|pcidev
)paren
op_eq
l_int|0
)paren
id|foundone
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs461x: Found %d audio device(s).&bslash;n&quot;
comma
id|foundone
)paren
suffix:semicolon
r_return
id|foundone
suffix:semicolon
)brace
DECL|function|init_module
r_int
id|__init
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cs_probe
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: No devices found.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|__exit
id|cleanup_module
(paren
r_void
)paren
(brace
r_struct
id|cs_card
op_star
id|next
suffix:semicolon
macro_line|#ifdef CS46XX_PM
id|pm_unregister_all
c_func
(paren
id|cs46xx_pm_callback
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|devs
)paren
(brace
id|next
op_assign
id|devs-&gt;next
suffix:semicolon
id|cs_remove
c_func
(paren
id|devs
)paren
suffix:semicolon
id|devs
op_assign
id|next
suffix:semicolon
)brace
)brace
id|MODULE_PARM
c_func
(paren
id|external_amp
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|thinkpad
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
eof
