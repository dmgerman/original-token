multiline_comment|/*     &n; **********************************************************************&n; *     ecard.c - E-card initialization code&n; *     Copyright 1999, 2000 Creative Labs, Inc. &n; * &n; ********************************************************************** &n; * &n; *     Date                 Author          Summary of changes &n; *     ----                 ------          ------------------ &n; *     October 20, 1999     Bertrand Lee    base code release &n; * &n; ********************************************************************** &n; * &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version. &n; * &n; *     This program is distributed in the hope that it will be useful, &n; *     but WITHOUT ANY WARRANTY; without even the implied warranty of &n; *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &n; *     GNU General Public License for more details. &n; * &n; *     You should have received a copy of the GNU General Public &n; *     License along with this program; if not, write to the Free &n; *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, &n; *     USA. &n; * &n; ********************************************************************** &n; */
macro_line|#include &quot;ecard.h&quot;
macro_line|#include &quot;hwaccess.h&quot;
multiline_comment|/* Private routines */
r_static
r_void
id|ecard_setadcgain
c_func
(paren
r_struct
id|emu10k1_card
op_star
comma
r_struct
id|ecard_state
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
r_void
id|ecard_write
c_func
(paren
r_struct
id|emu10k1_card
op_star
comma
id|u32
)paren
suffix:semicolon
multiline_comment|/**************************************************************************&n; * @func Set the gain of the ECARD&squot;s CS3310 Trim/gain controller.  The&n; * trim value consists of a 16bit value which is composed of two&n; * 8 bit gain/trim values, one for the left channel and one for the&n; * right channel.  The following table maps from the Gain/Attenuation&n; * value in decibels into the corresponding bit pattern for a single&n; * channel.&n; */
DECL|function|ecard_setadcgain
r_static
r_void
id|ecard_setadcgain
c_func
(paren
r_struct
id|emu10k1_card
op_star
id|card
comma
r_struct
id|ecard_state
op_star
id|ecard
comma
id|u16
id|gain
)paren
(brace
id|u32
id|currbit
suffix:semicolon
id|ecard-&gt;adc_gain
op_assign
id|gain
suffix:semicolon
multiline_comment|/* Enable writing to the TRIM registers */
id|ecard_write
c_func
(paren
id|card
comma
id|ecard-&gt;control_bits
op_amp
op_complement
id|EC_TRIM_CSN
)paren
suffix:semicolon
multiline_comment|/* Do it again to insure that we meet hold time requirements */
id|ecard_write
c_func
(paren
id|card
comma
id|ecard-&gt;control_bits
op_amp
op_complement
id|EC_TRIM_CSN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|currbit
op_assign
(paren
l_int|1L
op_lshift
l_int|15
)paren
suffix:semicolon
id|currbit
suffix:semicolon
id|currbit
op_rshift_assign
l_int|1
)paren
(brace
id|u32
id|value
op_assign
id|ecard-&gt;control_bits
op_amp
op_complement
(paren
id|EC_TRIM_CSN
op_or
id|EC_TRIM_SDATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gain
op_amp
id|currbit
)paren
id|value
op_or_assign
id|EC_TRIM_SDATA
suffix:semicolon
multiline_comment|/* Clock the bit */
id|ecard_write
c_func
(paren
id|card
comma
id|value
)paren
suffix:semicolon
id|ecard_write
c_func
(paren
id|card
comma
id|value
op_or
id|EC_TRIM_SCLK
)paren
suffix:semicolon
id|ecard_write
c_func
(paren
id|card
comma
id|value
)paren
suffix:semicolon
)brace
id|ecard_write
c_func
(paren
id|card
comma
id|ecard-&gt;control_bits
)paren
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * @func Clock bits into the Ecard&squot;s control latch.  The Ecard uses a&n; *  control latch will is loaded bit-serially by toggling the Modem control&n; *  lines from function 2 on the E8010.  This function hides these details&n; *  and presents the illusion that we are actually writing to a distinct&n; *  register.&n; */
DECL|function|ecard_write
r_static
r_void
id|ecard_write
c_func
(paren
r_struct
id|emu10k1_card
op_star
id|card
comma
id|u32
id|value
)paren
(brace
id|u16
id|count
suffix:semicolon
id|u32
id|data
comma
id|hcvalue
suffix:semicolon
id|hcvalue
op_assign
id|emu10k1_readfn0
c_func
(paren
id|card
comma
id|HCFG
)paren
op_amp
op_complement
(paren
id|HOOKN_BIT
op_or
id|HANDN_BIT
op_or
id|PULSEN_BIT
)paren
suffix:semicolon
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|EC_NUM_CONTROL_BITS
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/* Set up the value */
id|data
op_assign
(paren
(paren
id|value
op_amp
l_int|0x1
)paren
ques
c_cond
id|PULSEN_BIT
suffix:colon
l_int|0
)paren
suffix:semicolon
id|value
op_rshift_assign
l_int|1
suffix:semicolon
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
op_or
id|data
)paren
suffix:semicolon
multiline_comment|/* Clock the shift register */
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
op_or
id|data
op_or
id|HANDN_BIT
)paren
suffix:semicolon
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
op_or
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* Latch the bits */
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
op_or
id|HOOKN_BIT
)paren
suffix:semicolon
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
)paren
suffix:semicolon
)brace
DECL|function|emu10k1_ecard_init
r_int
id|__devinit
id|emu10k1_ecard_init
c_func
(paren
r_struct
id|emu10k1_card
op_star
id|card
)paren
(brace
id|u32
id|hcvalue
suffix:semicolon
r_struct
id|ecard_state
id|ecard
suffix:semicolon
multiline_comment|/* Set up the initial settings */
id|ecard.mux0_setting
op_assign
id|EC_DEFAULT_SPDIF0_SEL
suffix:semicolon
id|ecard.mux1_setting
op_assign
id|EC_DEFAULT_SPDIF1_SEL
suffix:semicolon
id|ecard.mux2_setting
op_assign
l_int|0
suffix:semicolon
id|ecard.adc_gain
op_assign
id|EC_DEFAULT_ADC_GAIN
suffix:semicolon
id|ecard.control_bits
op_assign
id|EC_RAW_RUN_MODE
op_or
id|EC_SPDIF0_SELECT
c_func
(paren
id|ecard.mux0_setting
)paren
op_or
id|EC_SPDIF1_SELECT
c_func
(paren
id|ecard.mux1_setting
)paren
suffix:semicolon
multiline_comment|/* Step 0: Set the codec type in the hardware control register &n;&t; * and enable audio output */
id|hcvalue
op_assign
id|emu10k1_readfn0
c_func
(paren
id|card
comma
id|HCFG
)paren
suffix:semicolon
id|emu10k1_writefn0
c_func
(paren
id|card
comma
id|HCFG
comma
id|hcvalue
op_or
id|HCFG_AUDIOENABLE
op_or
id|HCFG_CODECFORMAT_I2S
)paren
suffix:semicolon
id|emu10k1_readfn0
c_func
(paren
id|card
comma
id|HCFG
)paren
suffix:semicolon
multiline_comment|/* Step 1: Turn off the led and deassert TRIM_CS */
id|ecard_write
c_func
(paren
id|card
comma
id|EC_ADCCAL
op_or
id|EC_LEDN
op_or
id|EC_TRIM_CSN
)paren
suffix:semicolon
multiline_comment|/* Step 2: Calibrate the ADC and DAC */
id|ecard_write
c_func
(paren
id|card
comma
id|EC_DACCAL
op_or
id|EC_LEDN
op_or
id|EC_TRIM_CSN
)paren
suffix:semicolon
multiline_comment|/* Step 3: Wait for awhile; FIXME: Is this correct? */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/* Step 4: Switch off the DAC and ADC calibration.  Note&n;&t; * That ADC_CAL is actually an inverted signal, so we assert&n;&t; * it here to stop calibration.  */
id|ecard_write
c_func
(paren
id|card
comma
id|EC_ADCCAL
op_or
id|EC_LEDN
op_or
id|EC_TRIM_CSN
)paren
suffix:semicolon
multiline_comment|/* Step 4: Switch into run mode */
id|ecard_write
c_func
(paren
id|card
comma
id|ecard.control_bits
)paren
suffix:semicolon
multiline_comment|/* Step 5: Set the analog input gain */
id|ecard_setadcgain
c_func
(paren
id|card
comma
op_amp
id|ecard
comma
id|ecard.adc_gain
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
