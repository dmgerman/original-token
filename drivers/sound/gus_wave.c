multiline_comment|/*&n; * sound/gus_wave.c&n; *&n; * Driver for the Gravis UltraSound wave table synth.&n; */
multiline_comment|/*&n; * Copyright (C) by Hannu Savolainen 1993-1997&n; *&n; * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)&n; * Version 2 (June 1991). See the &quot;COPYING&quot; file distributed with this software&n; * for more info.&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|GUSPNP_AUTODETECT
mdefine_line|#define GUSPNP_AUTODETECT
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &lt;linux/ultrasound.h&gt;
macro_line|#include &quot;gus_hw.h&quot;
macro_line|#if defined(CONFIG_GUSHW)
DECL|macro|GUS_BANK_SIZE
mdefine_line|#define GUS_BANK_SIZE (((iw_mode) ? 256*1024*1024 : 256*1024))
DECL|macro|MAX_SAMPLE
mdefine_line|#define MAX_SAMPLE&t;150
DECL|macro|MAX_PATCH
mdefine_line|#define MAX_PATCH&t;256
DECL|macro|NOT_SAMPLE
mdefine_line|#define NOT_SAMPLE&t;0xffff
DECL|struct|voice_info
r_struct
id|voice_info
(brace
DECL|member|orig_freq
r_int
r_int
id|orig_freq
suffix:semicolon
DECL|member|current_freq
r_int
r_int
id|current_freq
suffix:semicolon
DECL|member|mode
r_int
r_int
id|mode
suffix:semicolon
DECL|member|fixed_pitch
r_int
id|fixed_pitch
suffix:semicolon
DECL|member|bender
r_int
id|bender
suffix:semicolon
DECL|member|bender_range
r_int
id|bender_range
suffix:semicolon
DECL|member|panning
r_int
id|panning
suffix:semicolon
DECL|member|midi_volume
r_int
id|midi_volume
suffix:semicolon
DECL|member|initial_volume
r_int
r_int
id|initial_volume
suffix:semicolon
DECL|member|current_volume
r_int
r_int
id|current_volume
suffix:semicolon
DECL|member|loop_irq_mode
DECL|member|loop_irq_parm
r_int
id|loop_irq_mode
comma
id|loop_irq_parm
suffix:semicolon
DECL|macro|LMODE_FINISH
mdefine_line|#define LMODE_FINISH&t;&t;1
DECL|macro|LMODE_PCM
mdefine_line|#define LMODE_PCM&t;&t;2
DECL|macro|LMODE_PCM_STOP
mdefine_line|#define LMODE_PCM_STOP&t;&t;3
DECL|member|volume_irq_mode
DECL|member|volume_irq_parm
r_int
id|volume_irq_mode
comma
id|volume_irq_parm
suffix:semicolon
DECL|macro|VMODE_HALT
mdefine_line|#define VMODE_HALT&t;&t;1
DECL|macro|VMODE_ENVELOPE
mdefine_line|#define VMODE_ENVELOPE&t;&t;2
DECL|macro|VMODE_START_NOTE
mdefine_line|#define VMODE_START_NOTE&t;3
DECL|member|env_phase
r_int
id|env_phase
suffix:semicolon
DECL|member|env_rate
r_int
r_char
id|env_rate
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|env_offset
r_int
r_char
id|env_offset
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*&n;     * Volume computation parameters for gus_adagio_vol()&n;     */
DECL|member|main_vol
DECL|member|expression_vol
DECL|member|patch_vol
r_int
id|main_vol
comma
id|expression_vol
comma
id|patch_vol
suffix:semicolon
multiline_comment|/* Variables for &quot;Ultraclick&quot; removal */
DECL|member|dev_pending
DECL|member|note_pending
DECL|member|volume_pending
DECL|member|sample_pending
r_int
id|dev_pending
comma
id|note_pending
comma
id|volume_pending
comma
id|sample_pending
suffix:semicolon
DECL|member|kill_pending
r_char
id|kill_pending
suffix:semicolon
DECL|member|offset_pending
r_int
id|offset_pending
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|voice_alloc
r_static
r_struct
id|voice_alloc_info
op_star
id|voice_alloc
suffix:semicolon
r_extern
r_int
id|gus_base
suffix:semicolon
r_extern
r_int
id|gus_irq
comma
id|gus_dma
suffix:semicolon
r_extern
r_int
id|gus_pnp_flag
suffix:semicolon
DECL|variable|gus_dma2
r_static
r_int
id|gus_dma2
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|dual_dma_mode
r_static
r_int
id|dual_dma_mode
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_mem_size
r_static
r_int
id|gus_mem_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_rom_size
r_static
r_int
id|gus_rom_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|free_mem_ptr
r_static
r_int
id|free_mem_ptr
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_busy
r_static
r_int
id|gus_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_no_dma
r_static
r_int
id|gus_no_dma
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_voices
r_static
r_int
id|nr_voices
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_devnum
r_static
r_int
id|gus_devnum
op_assign
l_int|0
suffix:semicolon
DECL|variable|volume_base
DECL|variable|volume_scale
DECL|variable|volume_method
r_static
r_int
id|volume_base
comma
id|volume_scale
comma
id|volume_method
suffix:semicolon
DECL|variable|gus_recmask
r_static
r_int
id|gus_recmask
op_assign
id|SOUND_MASK_MIC
suffix:semicolon
DECL|variable|recording_active
r_static
r_int
id|recording_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|only_read_access
r_static
r_int
id|only_read_access
op_assign
l_int|0
suffix:semicolon
DECL|variable|only_8_bits
r_static
r_int
id|only_8_bits
op_assign
l_int|0
suffix:semicolon
DECL|variable|iw_mode
r_int
id|iw_mode
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_wave_volume
r_int
id|gus_wave_volume
op_assign
l_int|60
suffix:semicolon
DECL|variable|gus_pcm_volume
r_int
id|gus_pcm_volume
op_assign
l_int|80
suffix:semicolon
DECL|variable|have_gus_max
r_int
id|have_gus_max
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_line_vol
DECL|variable|gus_mic_vol
r_static
r_int
id|gus_line_vol
op_assign
l_int|100
comma
id|gus_mic_vol
op_assign
l_int|0
suffix:semicolon
DECL|variable|mix_image
r_static
r_int
r_char
id|mix_image
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|gus_timer_enabled
r_int
id|gus_timer_enabled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Current version of this driver doesn&squot;t allow synth and PCM functions&n; * at the same time. The active_device specifies the active driver&n; */
DECL|variable|active_device
r_static
r_int
id|active_device
op_assign
l_int|0
suffix:semicolon
DECL|macro|GUS_DEV_WAVE
mdefine_line|#define GUS_DEV_WAVE&t;&t;1&t;/* Wave table synth */
DECL|macro|GUS_DEV_PCM_DONE
mdefine_line|#define GUS_DEV_PCM_DONE&t;2&t;/* PCM device, transfer done */
DECL|macro|GUS_DEV_PCM_CONTINUE
mdefine_line|#define GUS_DEV_PCM_CONTINUE&t;3&t;/* PCM device, transfer done ch. 1/2 */
DECL|variable|gus_audio_speed
r_static
r_int
id|gus_audio_speed
suffix:semicolon
DECL|variable|gus_audio_channels
r_static
r_int
id|gus_audio_channels
suffix:semicolon
DECL|variable|gus_audio_bits
r_static
r_int
id|gus_audio_bits
suffix:semicolon
DECL|variable|gus_audio_bsize
r_static
r_int
id|gus_audio_bsize
suffix:semicolon
DECL|variable|bounce_buf
r_static
r_char
id|bounce_buf
(braket
l_int|8
op_star
l_int|1024
)braket
suffix:semicolon
multiline_comment|/* Must match value set to max_fragment */
DECL|variable|dram_sleeper
r_static
r_struct
id|wait_queue
op_star
id|dram_sleeper
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|dram_sleep_flag
r_static
r_volatile
r_struct
id|snd_wait
id|dram_sleep_flag
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Variables and buffers for PCM output&n; */
DECL|macro|MAX_PCM_BUFFERS
mdefine_line|#define MAX_PCM_BUFFERS&t;&t;(128*MAX_REALTIME_FACTOR)&t;/* Don&squot;t change */
DECL|variable|pcm_bsize
DECL|variable|pcm_nblk
DECL|variable|pcm_banksize
r_static
r_int
id|pcm_bsize
comma
id|pcm_nblk
comma
id|pcm_banksize
suffix:semicolon
DECL|variable|pcm_datasize
r_static
r_int
id|pcm_datasize
(braket
id|MAX_PCM_BUFFERS
)braket
suffix:semicolon
DECL|variable|pcm_head
DECL|variable|pcm_tail
DECL|variable|pcm_qlen
r_static
r_volatile
r_int
id|pcm_head
comma
id|pcm_tail
comma
id|pcm_qlen
suffix:semicolon
DECL|variable|pcm_active
r_static
r_volatile
r_int
id|pcm_active
suffix:semicolon
DECL|variable|dma_active
r_static
r_volatile
r_int
id|dma_active
suffix:semicolon
DECL|variable|pcm_opened
r_static
r_int
id|pcm_opened
op_assign
l_int|0
suffix:semicolon
DECL|variable|pcm_current_dev
r_static
r_int
id|pcm_current_dev
suffix:semicolon
DECL|variable|pcm_current_block
r_static
r_int
id|pcm_current_block
suffix:semicolon
DECL|variable|pcm_current_buf
r_static
r_int
r_int
id|pcm_current_buf
suffix:semicolon
DECL|variable|pcm_current_count
r_static
r_int
id|pcm_current_count
suffix:semicolon
DECL|variable|pcm_current_intrflag
r_static
r_int
id|pcm_current_intrflag
suffix:semicolon
r_extern
r_int
op_star
id|gus_osp
suffix:semicolon
DECL|variable|voices
r_static
r_struct
id|voice_info
id|voices
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|freq_div_table
r_static
r_int
id|freq_div_table
(braket
)braket
op_assign
(brace
l_int|44100
comma
l_int|44100
comma
multiline_comment|/* 14 */
l_int|41160
comma
multiline_comment|/* 15 */
l_int|38587
comma
multiline_comment|/* 16 */
l_int|36317
comma
multiline_comment|/* 17 */
l_int|34300
comma
multiline_comment|/* 18 */
l_int|32494
comma
multiline_comment|/* 19 */
l_int|30870
comma
multiline_comment|/* 20 */
l_int|29400
comma
multiline_comment|/* 21 */
l_int|28063
comma
multiline_comment|/* 22 */
l_int|26843
comma
multiline_comment|/* 23 */
l_int|25725
comma
multiline_comment|/* 24 */
l_int|24696
comma
multiline_comment|/* 25 */
l_int|23746
comma
multiline_comment|/* 26 */
l_int|22866
comma
multiline_comment|/* 27 */
l_int|22050
comma
multiline_comment|/* 28 */
l_int|21289
comma
multiline_comment|/* 29 */
l_int|20580
comma
multiline_comment|/* 30 */
l_int|19916
comma
multiline_comment|/* 31 */
l_int|19293
multiline_comment|/* 32 */
)brace
suffix:semicolon
DECL|variable|samples
r_static
r_struct
id|patch_info
op_star
id|samples
suffix:semicolon
DECL|variable|sample_ptrs
r_static
r_int
id|sample_ptrs
(braket
id|MAX_SAMPLE
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|sample_map
r_static
r_int
id|sample_map
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|free_sample
r_static
r_int
id|free_sample
suffix:semicolon
DECL|variable|mixer_type
r_static
r_int
id|mixer_type
op_assign
l_int|0
suffix:semicolon
DECL|variable|patch_table
r_static
r_int
id|patch_table
(braket
id|MAX_PATCH
)braket
suffix:semicolon
DECL|variable|patch_map
r_static
r_int
id|patch_map
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|gus_info
r_static
r_struct
id|synth_info
id|gus_info
op_assign
(brace
l_string|&quot;Gravis UltraSound&quot;
comma
l_int|0
comma
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_GUS
comma
l_int|0
comma
l_int|16
comma
l_int|0
comma
id|MAX_PATCH
)brace
suffix:semicolon
r_static
r_void
id|gus_poke
(paren
r_int
id|addr
comma
r_int
r_char
id|data
)paren
suffix:semicolon
r_static
r_void
id|compute_and_set_volume
(paren
r_int
id|voice
comma
r_int
id|volume
comma
r_int
id|ramp_time
)paren
suffix:semicolon
r_extern
r_int
r_int
id|gus_adagio_vol
(paren
r_int
id|vel
comma
r_int
id|mainv
comma
r_int
id|xpn
comma
r_int
id|voicev
)paren
suffix:semicolon
r_extern
r_int
r_int
id|gus_linear_vol
(paren
r_int
id|vol
comma
r_int
id|mainvol
)paren
suffix:semicolon
r_static
r_void
id|compute_volume
(paren
r_int
id|voice
comma
r_int
id|volume
)paren
suffix:semicolon
r_static
r_void
id|do_volume_irq
(paren
r_int
id|voice
)paren
suffix:semicolon
r_static
r_void
id|set_input_volumes
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|gus_tmr_install
(paren
r_int
id|io_base
)paren
suffix:semicolon
DECL|macro|INSTANT_RAMP
mdefine_line|#define&t;INSTANT_RAMP&t;&t;-1&t;/* Instant change. No ramping */
DECL|macro|FAST_RAMP
mdefine_line|#define FAST_RAMP&t;&t;0&t;/* Fastest possible ramp */
r_static
r_void
DECL|function|reset_sample_memory
id|reset_sample_memory
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
id|sample_ptrs
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|sample_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|patch_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|gus_poke
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Put a silent sample to the beginning */
id|gus_poke
(paren
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|free_mem_ptr
op_assign
l_int|2
suffix:semicolon
id|free_sample
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
id|patch_table
(braket
id|i
)braket
op_assign
id|NOT_SAMPLE
suffix:semicolon
)brace
r_void
DECL|function|gus_delay
id|gus_delay
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|inb
(paren
id|u_DRAMIO
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_poke
id|gus_poke
(paren
r_int
id|addr
comma
r_int
r_char
id|data
)paren
(brace
multiline_comment|/* Writes a byte to the DRAM */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x43
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|outb
(paren
(paren
id|addr
op_amp
l_int|0xff
)paren
comma
id|u_DataLo
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
id|addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x44
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
id|addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|outb
(paren
(paren
id|data
)paren
comma
id|u_DRAMIO
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|gus_peek
id|gus_peek
(paren
r_int
id|addr
)paren
(brace
multiline_comment|/* Reads a byte from the DRAM */
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x43
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|outb
(paren
(paren
id|addr
op_amp
l_int|0xff
)paren
comma
id|u_DataLo
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
id|addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x44
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
id|addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|tmp
op_assign
id|inb
(paren
id|u_DRAMIO
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_void
DECL|function|gus_write8
id|gus_write8
(paren
r_int
id|reg
comma
r_int
r_int
id|data
)paren
(brace
multiline_comment|/* Writes to an indirect register (8 bit) */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
id|reg
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|data
op_amp
l_int|0xff
)paren
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|gus_read8
id|gus_read8
(paren
r_int
id|reg
)paren
(brace
multiline_comment|/* Reads from an indirect register (8 bit). Offset 0x80. */
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
id|reg
op_or
l_int|0x80
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|val
op_assign
id|inb
(paren
id|u_DataHi
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|gus_look8
id|gus_look8
(paren
r_int
id|reg
)paren
(brace
multiline_comment|/* Reads from an indirect register (8 bit). No additional offset. */
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
id|reg
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|val
op_assign
id|inb
(paren
id|u_DataHi
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_write16
id|gus_write16
(paren
r_int
id|reg
comma
r_int
r_int
id|data
)paren
(brace
multiline_comment|/* Writes to an indirect register (16 bit) */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
id|reg
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|data
op_amp
l_int|0xff
)paren
)paren
comma
id|u_DataLo
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|gus_read16
id|gus_read16
(paren
r_int
id|reg
)paren
(brace
multiline_comment|/* Reads from an indirect register (16 bit). Offset 0x80. */
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|hi
comma
id|lo
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
id|reg
op_or
l_int|0x80
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|lo
op_assign
id|inb
(paren
id|u_DataLo
)paren
suffix:semicolon
id|hi
op_assign
id|inb
(paren
id|u_DataHi
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
(paren
id|hi
op_lshift
l_int|8
)paren
op_amp
l_int|0xff00
)paren
op_or
id|lo
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|gus_look16
id|gus_look16
(paren
r_int
id|reg
)paren
(brace
multiline_comment|/* Reads from an indirect register (16 bit). No additional offset. */
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|hi
comma
id|lo
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
id|reg
)paren
comma
id|u_Command
)paren
suffix:semicolon
id|lo
op_assign
id|inb
(paren
id|u_DataLo
)paren
suffix:semicolon
id|hi
op_assign
id|inb
(paren
id|u_DataHi
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
(paren
id|hi
op_lshift
l_int|8
)paren
op_amp
l_int|0xff00
)paren
op_or
id|lo
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_write_addr
id|gus_write_addr
(paren
r_int
id|reg
comma
r_int
r_int
id|address
comma
r_int
id|frac
comma
r_int
id|is16bit
)paren
(brace
multiline_comment|/* Writes an 24 bit memory address */
r_int
r_int
id|hold_address
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is16bit
)paren
(brace
r_if
c_cond
(paren
id|iw_mode
)paren
(brace
multiline_comment|/* Interwave spesific address translations */
id|address
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;   * Special processing required for 16 bit patches&n;&t;   */
id|hold_address
op_assign
id|address
suffix:semicolon
id|address
op_assign
id|address
op_rshift
l_int|1
suffix:semicolon
id|address
op_and_assign
l_int|0x0001ffffL
suffix:semicolon
id|address
op_or_assign
(paren
id|hold_address
op_amp
l_int|0x000c0000L
)paren
suffix:semicolon
)brace
)brace
id|gus_write16
(paren
id|reg
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|address
op_rshift
l_int|7
)paren
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
id|gus_write16
(paren
id|reg
op_plus
l_int|1
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|address
op_lshift
l_int|9
)paren
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|frac
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* Could writing twice fix problems with GUS_VOICE_POS() ? Lets try... */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write16
(paren
id|reg
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|address
op_rshift
l_int|7
)paren
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
id|gus_write16
(paren
id|reg
op_plus
l_int|1
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|address
op_lshift
l_int|9
)paren
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|frac
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_select_voice
id|gus_select_voice
(paren
r_int
id|voice
)paren
(brace
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
suffix:semicolon
id|outb
(paren
(paren
id|voice
)paren
comma
id|u_Voice
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_select_max_voices
id|gus_select_max_voices
(paren
r_int
id|nvoices
)paren
(brace
r_if
c_cond
(paren
id|iw_mode
)paren
id|nvoices
op_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|nvoices
OL
l_int|14
)paren
id|nvoices
op_assign
l_int|14
suffix:semicolon
r_if
c_cond
(paren
id|nvoices
OG
l_int|32
)paren
id|nvoices
op_assign
l_int|32
suffix:semicolon
id|voice_alloc-&gt;max_voice
op_assign
id|nr_voices
op_assign
id|nvoices
suffix:semicolon
id|gus_write8
(paren
l_int|0x0e
comma
(paren
id|nvoices
op_minus
l_int|1
)paren
op_or
l_int|0xc0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_on
id|gus_voice_on
(paren
r_int
r_int
id|mode
)paren
(brace
id|gus_write8
(paren
l_int|0x00
comma
(paren
r_int
r_char
)paren
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x00
comma
(paren
r_int
r_char
)paren
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_off
id|gus_voice_off
(paren
r_void
)paren
(brace
id|gus_write8
(paren
l_int|0x00
comma
id|gus_read8
(paren
l_int|0x00
)paren
op_or
l_int|0x03
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_mode
id|gus_voice_mode
(paren
r_int
r_int
id|m
)paren
(brace
r_int
r_char
id|mode
op_assign
(paren
r_int
r_char
)paren
(paren
id|m
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x00
comma
(paren
id|gus_read8
(paren
l_int|0x00
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t touch last two bits */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x00
comma
(paren
id|gus_read8
(paren
l_int|0x00
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_freq
id|gus_voice_freq
(paren
r_int
r_int
id|freq
)paren
(brace
r_int
r_int
id|divisor
op_assign
id|freq_div_table
(braket
id|nr_voices
op_minus
l_int|14
)braket
suffix:semicolon
r_int
r_int
id|fc
suffix:semicolon
multiline_comment|/* Interwave plays at 44100 Hz with any number of voices */
r_if
c_cond
(paren
id|iw_mode
)paren
id|fc
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|freq
op_lshift
l_int|9
)paren
op_plus
(paren
l_int|44100
op_rshift
l_int|1
)paren
)paren
op_div
l_int|44100
)paren
suffix:semicolon
r_else
id|fc
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|freq
op_lshift
l_int|9
)paren
op_plus
(paren
id|divisor
op_rshift
l_int|1
)paren
)paren
op_div
id|divisor
)paren
suffix:semicolon
id|fc
op_assign
id|fc
op_lshift
l_int|1
suffix:semicolon
id|gus_write16
(paren
l_int|0x01
comma
id|fc
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_volume
id|gus_voice_volume
(paren
r_int
r_int
id|vol
)paren
(brace
id|gus_write8
(paren
l_int|0x0d
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Stop ramp before setting volume */
id|gus_write16
(paren
l_int|0x09
comma
(paren
r_int
r_int
)paren
(paren
id|vol
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_balance
id|gus_voice_balance
(paren
r_int
r_int
id|balance
)paren
(brace
id|gus_write8
(paren
l_int|0x0c
comma
(paren
r_int
r_char
)paren
(paren
id|balance
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_ramp_range
id|gus_ramp_range
(paren
r_int
r_int
id|low
comma
r_int
r_int
id|high
)paren
(brace
id|gus_write8
(paren
l_int|0x07
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|low
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x08
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|high
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_ramp_rate
id|gus_ramp_rate
(paren
r_int
r_int
id|scale
comma
r_int
r_int
id|rate
)paren
(brace
id|gus_write8
(paren
l_int|0x06
comma
(paren
r_int
r_char
)paren
(paren
(paren
(paren
id|scale
op_amp
l_int|0x03
)paren
op_lshift
l_int|6
)paren
op_or
(paren
id|rate
op_amp
l_int|0x3f
)paren
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_rampon
id|gus_rampon
(paren
r_int
r_int
id|m
)paren
(brace
r_int
r_char
id|mode
op_assign
(paren
r_int
r_char
)paren
(paren
id|m
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
id|mode
op_amp
l_int|0xfc
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
id|mode
op_amp
l_int|0xfc
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_ramp_mode
id|gus_ramp_mode
(paren
r_int
r_int
id|m
)paren
(brace
r_int
r_char
id|mode
op_assign
(paren
r_int
r_char
)paren
(paren
id|m
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
(paren
id|gus_read8
(paren
l_int|0x0d
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
multiline_comment|/* Leave the last 2 bits alone */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
(paren
id|gus_read8
(paren
l_int|0x0d
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_rampoff
id|gus_rampoff
(paren
r_void
)paren
(brace
id|gus_write8
(paren
l_int|0x0d
comma
l_int|0x03
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_set_voice_pos
id|gus_set_voice_pos
(paren
r_int
id|voice
comma
r_int
id|position
)paren
(brace
r_int
id|sample_no
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sample_no
op_assign
id|sample_map
(braket
id|voice
)braket
)paren
op_ne
op_minus
l_int|1
)paren
r_if
c_cond
(paren
id|position
OL
id|samples
(braket
id|sample_no
)braket
dot
id|len
)paren
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
op_assign
id|position
suffix:semicolon
r_else
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample_no
)braket
op_plus
id|position
comma
l_int|0
comma
id|samples
(braket
id|sample_no
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_init
id|gus_voice_init
(paren
r_int
id|voice
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_volume
(paren
l_int|0
)paren
suffix:semicolon
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_write_addr
(paren
l_int|0x0a
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set current position to 0 */
id|gus_write8
(paren
l_int|0x00
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Voice off */
id|gus_write8
(paren
l_int|0x0d
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Ramping off */
id|voice_alloc-&gt;map
(braket
id|voice
)braket
op_assign
l_int|0
suffix:semicolon
id|voice_alloc-&gt;alloc_times
(braket
id|voice
)braket
op_assign
l_int|0
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_init2
id|gus_voice_init2
(paren
r_int
id|voice
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
op_assign
l_int|20000
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
l_int|20000
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender_range
op_assign
l_int|200
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_parm
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_parm
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|main_vol
op_assign
l_int|127
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|patch_vol
op_assign
l_int|127
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
op_assign
l_int|127
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
op_minus
l_int|1
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|fixed_pitch
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|step_envelope
id|step_envelope
(paren
r_int
id|voice
)paren
(brace
r_int
id|vol
comma
id|prev_vol
comma
id|phase
suffix:semicolon
r_int
r_char
id|rate
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_SUSTAIN_ON
op_logical_and
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_eq
l_int|2
)paren
(brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;       * Sustain phase begins. Continue envelope after receiving note off.&n;       */
)brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_ge
l_int|5
)paren
(brace
multiline_comment|/* Envelope finished. Shoot the voice down */
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prev_vol
op_assign
id|voices
(braket
id|voice
)braket
dot
id|current_volume
suffix:semicolon
id|phase
op_assign
op_increment
id|voices
(braket
id|voice
)braket
dot
id|env_phase
suffix:semicolon
id|compute_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
)paren
suffix:semicolon
id|vol
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_star
id|voices
(braket
id|voice
)braket
dot
id|env_offset
(braket
id|phase
)braket
op_div
l_int|255
suffix:semicolon
id|rate
op_assign
id|voices
(braket
id|voice
)braket
dot
id|env_rate
(braket
id|phase
)braket
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|prev_vol
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x06
comma
id|rate
)paren
suffix:semicolon
multiline_comment|/* Ramping rate */
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_ENVELOPE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|vol
op_minus
id|prev_vol
)paren
op_div
l_int|64
)paren
op_eq
l_int|0
)paren
multiline_comment|/* No significant volume change */
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
multiline_comment|/* Continue the envelope on the next step */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol
OG
id|prev_vol
)paren
(brace
r_if
c_cond
(paren
id|vol
op_ge
(paren
l_int|4096
op_minus
l_int|64
)paren
)paren
id|vol
op_assign
l_int|4096
op_minus
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
l_int|0
comma
id|vol
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* Increasing volume, with IRQ */
)brace
r_else
(brace
r_if
c_cond
(paren
id|vol
op_le
l_int|64
)paren
id|vol
op_assign
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
id|vol
comma
l_int|4030
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x60
)paren
suffix:semicolon
multiline_comment|/* Decreasing volume, with IRQ */
)brace
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|vol
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|init_envelope
id|init_envelope
(paren
r_int
id|voice
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_assign
op_minus
l_int|1
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
l_int|64
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|start_release
id|start_release
(paren
r_int
id|voice
comma
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|gus_read8
(paren
l_int|0x00
)paren
op_amp
l_int|0x03
)paren
r_return
suffix:semicolon
multiline_comment|/* Voice already stopped */
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Will be incremented by step_envelope */
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Get current volume */
id|voices
(braket
id|voice
)braket
dot
id|mode
op_and_assign
op_complement
id|WAVE_SUSTAIN_ON
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_fade
id|gus_voice_fade
(paren
r_int
id|voice
)paren
(brace
r_int
id|instr_no
op_assign
id|sample_map
(braket
id|voice
)braket
comma
id|is16bits
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instr_no
template_param
id|MAX_SAMPLE
)paren
(brace
id|gus_write8
(paren
l_int|0x00
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Hard stop */
id|voice_alloc-&gt;map
(braket
id|voice
)braket
op_assign
l_int|0
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|is16bits
op_assign
(paren
id|samples
(braket
id|instr_no
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* 8 or 16 bits */
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
id|start_release
(paren
id|voice
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * Ramp the volume down but not too quickly.&n;   */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
)paren
OL
l_int|100
)paren
multiline_comment|/* Get current volume */
(brace
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gus_ramp_range
(paren
l_int|65
comma
l_int|4030
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|2
comma
l_int|4
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x40
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* Down, once, with IRQ */
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_HALT
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_reset
id|gus_reset
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|gus_select_max_voices
(paren
l_int|24
)paren
suffix:semicolon
id|volume_base
op_assign
l_int|3071
suffix:semicolon
id|volume_scale
op_assign
l_int|4
suffix:semicolon
id|volume_method
op_assign
id|VOL_METHOD_ADAGIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|gus_voice_init
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Turn voice off */
id|gus_voice_init2
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|gus_initialize
id|gus_initialize
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|dma_image
comma
id|irq_image
comma
id|tmp
suffix:semicolon
r_static
r_int
r_char
id|gus_irq_map
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|4
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|5
comma
l_int|6
comma
l_int|0
comma
l_int|0
comma
l_int|7
)brace
suffix:semicolon
r_static
r_int
r_char
id|gus_dma_map
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|3
comma
l_int|4
comma
l_int|5
)brace
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reset GF1 */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Release Reset */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Clear all interrupts&n;   */
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* DMA control */
id|gus_write8
(paren
l_int|0x45
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Timer control */
id|gus_write8
(paren
l_int|0x49
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Sample control */
id|gus_select_max_voices
(paren
l_int|24
)paren
suffix:semicolon
id|inb
(paren
id|u_Status
)paren
suffix:semicolon
multiline_comment|/* Touch the status register */
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* Clear any pending DMA IRQs */
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* Clear any pending sample IRQs */
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* Clear pending IRQs */
id|gus_reset
(paren
)paren
suffix:semicolon
multiline_comment|/* Resets all voices */
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* Clear any pending DMA IRQs */
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* Clear any pending sample IRQs */
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* Clear pending IRQs */
id|gus_write8
(paren
l_int|0x4c
comma
l_int|7
)paren
suffix:semicolon
multiline_comment|/* Master reset | DAC enable | IRQ enable */
multiline_comment|/*&n;   * Set up for Digital ASIC&n;   */
id|outb
(paren
(paren
l_int|0x05
)paren
comma
id|gus_base
op_plus
l_int|0x0f
)paren
suffix:semicolon
id|mix_image
op_or_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* Disable line out (for a moment) */
id|outb
(paren
(paren
id|mix_image
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x00
)paren
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x00
)paren
comma
id|gus_base
op_plus
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now set up the DMA and IRQ interface&n;   *&n;   * The GUS supports two IRQs and two DMAs.&n;   *&n;   * Just one DMA channel is used. This prevents simultaneous ADC and DAC.&n;   * Adding this support requires significant changes to the dmabuf.c, dsp.c&n;   * and audio.c also.&n;   */
id|irq_image
op_assign
l_int|0
suffix:semicolon
id|tmp
op_assign
id|gus_irq_map
(braket
id|gus_irq
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gus_pnp_flag
op_logical_and
op_logical_neg
id|tmp
)paren
id|printk
(paren
l_string|&quot;Warning! GUS IRQ not selected&bslash;n&quot;
)paren
suffix:semicolon
id|irq_image
op_or_assign
id|tmp
suffix:semicolon
id|irq_image
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* Combine IRQ1 (GF1) and IRQ2 (Midi) */
id|dual_dma_mode
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|gus_dma2
op_eq
id|gus_dma
op_logical_or
id|gus_dma2
op_eq
op_minus
l_int|1
)paren
(brace
id|dual_dma_mode
op_assign
l_int|0
suffix:semicolon
id|dma_image
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* Combine DMA1 (DRAM) and IRQ2 (ADC) */
id|tmp
op_assign
id|gus_dma_map
(braket
id|gus_dma
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
id|printk
(paren
l_string|&quot;Warning! GUS DMA not selected&bslash;n&quot;
)paren
suffix:semicolon
id|dma_image
op_or_assign
id|tmp
suffix:semicolon
)brace
r_else
multiline_comment|/* Setup dual DMA channel mode for GUS MAX */
(brace
id|dma_image
op_assign
id|gus_dma_map
(braket
id|gus_dma
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_image
)paren
id|printk
(paren
l_string|&quot;Warning! GUS DMA not selected&bslash;n&quot;
)paren
suffix:semicolon
id|tmp
op_assign
id|gus_dma_map
(braket
id|gus_dma2
)braket
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
(paren
l_string|&quot;Warning! Invalid GUS MAX DMA&bslash;n&quot;
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* Combine DMA channels */
id|dual_dma_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|dma_image
op_or_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n;   * For some reason the IRQ and DMA addresses must be written twice&n;   */
multiline_comment|/*&n;   * Doing it first time&n;   */
id|outb
(paren
(paren
id|mix_image
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* Select DMA control */
id|outb
(paren
(paren
id|dma_image
op_or
l_int|0x80
)paren
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* Set DMA address */
id|outb
(paren
(paren
id|mix_image
op_or
l_int|0x40
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* Select IRQ control */
id|outb
(paren
(paren
id|irq_image
)paren
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* Set IRQ address */
multiline_comment|/*&n;   * Doing it second time&n;   */
id|outb
(paren
(paren
id|mix_image
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* Select DMA control */
id|outb
(paren
(paren
id|dma_image
)paren
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* Set DMA address */
id|outb
(paren
(paren
id|mix_image
op_or
l_int|0x40
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* Select IRQ control */
id|outb
(paren
(paren
id|irq_image
)paren
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* Set IRQ address */
id|gus_select_voice
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This disables writes to IRQ/DMA reg */
id|mix_image
op_and_assign
op_complement
l_int|0x02
suffix:semicolon
multiline_comment|/* Enable line out */
id|mix_image
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* Enable IRQ */
id|outb
(paren
(paren
id|mix_image
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;   * Turn mixer channels on&n;&t;&t;&t;&t;   * Note! Mic in is left off.&n;&t;&t;&t;&t; */
id|gus_select_voice
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This disables writes to IRQ/DMA reg */
id|gusintr
(paren
id|gus_irq
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Serve pending interrupts */
id|inb
(paren
id|u_Status
)paren
suffix:semicolon
multiline_comment|/* Touch the status register */
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* Clear any pending DMA IRQs */
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* Clear any pending sample IRQs */
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* Clear pending IRQs */
r_if
c_cond
(paren
id|iw_mode
)paren
id|gus_write8
(paren
l_int|0x19
comma
id|gus_read8
(paren
l_int|0x19
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pnp_mem_init
id|pnp_mem_init
(paren
r_void
)paren
(brace
macro_line|#include &quot;iwmem.h&quot;
DECL|macro|CHUNK_SIZE
mdefine_line|#define CHUNK_SIZE (256*1024)
DECL|macro|BANK_SIZE
mdefine_line|#define BANK_SIZE (4*1024*1024)
DECL|macro|CHUNKS_PER_BANK
mdefine_line|#define CHUNKS_PER_BANK (BANK_SIZE/CHUNK_SIZE)
r_int
id|bank
comma
id|chunk
comma
id|addr
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_int
id|bank_sizes
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|bits
op_assign
op_minus
l_int|1
comma
id|nbanks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This routine determines what kind of RAM is installed in each of the four&n; * SIMM banks and configures the DRAM address decode logic accordingly.&n; */
multiline_comment|/*&n; *    Place the chip into enhanced mode&n; */
id|gus_write8
(paren
l_int|0x19
comma
id|gus_read8
(paren
l_int|0x19
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x53
comma
id|gus_look8
(paren
l_int|0x53
)paren
op_amp
op_complement
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* Select DRAM I/O access */
multiline_comment|/*&n; * Set memory configuration to 4 DRAM banks of 4M in each (16M total).&n; */
id|gus_write16
(paren
l_int|0x52
comma
(paren
id|gus_look16
(paren
l_int|0x52
)paren
op_amp
l_int|0xfff0
)paren
op_or
l_int|0x000c
)paren
suffix:semicolon
multiline_comment|/*&n; * Perform the DRAM size detection for each bank individually.&n; */
r_for
c_loop
(paren
id|bank
op_assign
l_int|0
suffix:semicolon
id|bank
OL
l_int|4
suffix:semicolon
id|bank
op_increment
)paren
(brace
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|addr
op_assign
id|bank
op_star
id|BANK_SIZE
suffix:semicolon
multiline_comment|/* Clean check points of each chunk */
r_for
c_loop
(paren
id|chunk
op_assign
l_int|0
suffix:semicolon
id|chunk
OL
id|CHUNKS_PER_BANK
suffix:semicolon
id|chunk
op_increment
)paren
(brace
id|gus_poke
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|0L
comma
l_int|0x00
)paren
suffix:semicolon
id|gus_poke
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|1L
comma
l_int|0x00
)paren
suffix:semicolon
)brace
multiline_comment|/* Write a value to each chunk point and verify the result */
r_for
c_loop
(paren
id|chunk
op_assign
l_int|0
suffix:semicolon
id|chunk
OL
id|CHUNKS_PER_BANK
suffix:semicolon
id|chunk
op_increment
)paren
(brace
id|gus_poke
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|0L
comma
l_int|0x55
)paren
suffix:semicolon
id|gus_poke
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|1L
comma
l_int|0xAA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|0L
)paren
op_eq
l_int|0x55
op_logical_and
id|gus_peek
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|1L
)paren
op_eq
l_int|0xAA
)paren
(brace
multiline_comment|/* OK. There is RAM. Now check for possible shadows */
r_int
id|ok
op_assign
l_int|1
comma
id|chunk2
suffix:semicolon
r_for
c_loop
(paren
id|chunk2
op_assign
l_int|0
suffix:semicolon
id|ok
op_logical_and
id|chunk2
OL
id|chunk
suffix:semicolon
id|chunk2
op_increment
)paren
r_if
c_cond
(paren
id|gus_peek
(paren
id|addr
op_plus
id|chunk2
op_star
id|CHUNK_SIZE
op_plus
l_int|0L
)paren
op_logical_or
id|gus_peek
(paren
id|addr
op_plus
id|chunk2
op_star
id|CHUNK_SIZE
op_plus
l_int|1L
)paren
)paren
id|ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Addressing wraps */
r_if
c_cond
(paren
id|ok
)paren
id|size
op_assign
(paren
id|chunk
op_plus
l_int|1
)paren
op_star
id|CHUNK_SIZE
suffix:semicolon
)brace
id|gus_poke
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|0L
comma
l_int|0x00
)paren
suffix:semicolon
id|gus_poke
(paren
id|addr
op_plus
id|chunk
op_star
id|CHUNK_SIZE
op_plus
l_int|1L
comma
l_int|0x00
)paren
suffix:semicolon
)brace
id|bank_sizes
(braket
id|bank
)braket
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
id|nbanks
op_assign
id|bank
op_plus
l_int|1
suffix:semicolon
id|DDB
(paren
id|printk
(paren
l_string|&quot;Interwave: Bank %d, size=%dk&bslash;n&quot;
comma
id|bank
comma
id|size
op_div
l_int|1024
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nbanks
op_eq
l_int|0
)paren
multiline_comment|/* No RAM - Give up */
(brace
id|printk
(paren
l_string|&quot;Sound: An Interwave audio chip detected but no DRAM&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Sound: Unable to work with this card.&bslash;n&quot;
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x19
comma
id|gus_read8
(paren
l_int|0x19
)paren
op_amp
op_complement
l_int|0x01
)paren
suffix:semicolon
id|gus_mem_size
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Now we know how much DRAM there is in each bank. The next step is&n; * to find a DRAM size encoding (0 to 12) which is best for the combination&n; * we have.&n; *&n; * First try if any of the possible alternatives matches exactly the amount&n; * of memory we have.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|bits
op_eq
op_minus
l_int|1
op_logical_and
id|i
OL
l_int|13
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bits
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|bits
op_ne
op_minus
l_int|1
op_logical_and
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|mem_decode
(braket
id|i
)braket
(braket
id|j
)braket
op_ne
id|bank_sizes
(braket
id|j
)braket
)paren
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No hit */
)brace
multiline_comment|/*&n; * If necessary, try to find a combination where other than the last&n; * bank matches our configuration and the last bank is left oversized.&n; * In this way we don&squot;t leave holes in the middle of memory.&n; */
r_if
c_cond
(paren
id|bits
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* No luck yet */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|bits
op_eq
op_minus
l_int|1
op_logical_and
id|i
OL
l_int|13
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bits
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|bits
op_ne
op_minus
l_int|1
op_logical_and
id|j
OL
id|nbanks
op_minus
l_int|1
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|mem_decode
(braket
id|i
)braket
(braket
id|j
)braket
op_ne
id|bank_sizes
(braket
id|j
)braket
)paren
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No hit */
r_if
c_cond
(paren
id|mem_decode
(braket
id|i
)braket
(braket
id|nbanks
op_minus
l_int|1
)braket
OL
id|bank_sizes
(braket
id|nbanks
op_minus
l_int|1
)braket
)paren
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* The last bank is too small */
)brace
multiline_comment|/*&n; * The last resort is to search for a combination where the last bank is&n; * smaller than the actual SIMM. This leaves some memory in the last bank&n; * unused but doesn&squot;t leave holes in the DRAM address space.&n; */
r_if
c_cond
(paren
id|bits
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* No luck yet */
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|bits
op_eq
op_minus
l_int|1
op_logical_and
id|i
OL
l_int|13
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bits
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|bits
op_ne
op_minus
l_int|1
op_logical_and
id|j
OL
id|nbanks
op_minus
l_int|1
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|mem_decode
(braket
id|i
)braket
(braket
id|j
)braket
op_ne
id|bank_sizes
(braket
id|j
)braket
)paren
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No hit */
)brace
r_if
c_cond
(paren
id|bits
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;Interwave: Can&squot;t use all installed RAM.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Interwave: Try reordering SIMMS.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bits
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;Interwave: Can&squot;t find working DRAM encoding.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Interwave: Defaulting to 256k. Try reordering SIMMS.&bslash;n&quot;
)paren
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
)brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;Interwave: Selecting DRAM addressing mode %d&bslash;n&quot;
comma
id|bits
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bank
op_assign
l_int|0
suffix:semicolon
id|bank
OL
l_int|4
suffix:semicolon
id|bank
op_increment
)paren
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;  Bank %d, mem=%dk (limit %dk)&bslash;n&quot;
comma
id|bank
comma
id|bank_sizes
(braket
id|bank
)braket
op_div
l_int|1024
comma
id|mem_decode
(braket
id|bits
)braket
(braket
id|bank
)braket
op_div
l_int|1024
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank_sizes
(braket
id|bank
)braket
OG
id|mem_decode
(braket
id|bits
)braket
(braket
id|bank
)braket
)paren
id|total
op_add_assign
id|mem_decode
(braket
id|bits
)braket
(braket
id|bank
)braket
suffix:semicolon
r_else
id|total
op_add_assign
id|bank_sizes
(braket
id|bank
)braket
suffix:semicolon
)brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;Total %dk of DRAM (enhanced mode)&bslash;n&quot;
comma
id|total
op_div
l_int|1024
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; *    Set the memory addressing mode.&n; */
id|gus_write16
(paren
l_int|0x52
comma
(paren
id|gus_look16
(paren
l_int|0x52
)paren
op_amp
l_int|0xfff0
)paren
op_or
id|bits
)paren
suffix:semicolon
multiline_comment|/*      Leave the chip into enhanced mode. Disable LFO  */
id|gus_mem_size
op_assign
id|total
suffix:semicolon
id|iw_mode
op_assign
l_int|1
suffix:semicolon
id|gus_write8
(paren
l_int|0x19
comma
(paren
id|gus_read8
(paren
l_int|0x19
)paren
op_or
l_int|0x01
)paren
op_amp
op_complement
l_int|0x02
)paren
suffix:semicolon
)brace
r_int
DECL|function|gus_wave_detect
id|gus_wave_detect
(paren
r_int
id|baseaddr
)paren
(brace
r_int
r_int
id|i
comma
id|max_mem
op_assign
l_int|1024L
suffix:semicolon
r_int
r_int
id|loc
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
id|gus_base
op_assign
id|baseaddr
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reset GF1 */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Release Reset */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
macro_line|#ifdef GUSPNP_AUTODETECT
id|val
op_assign
id|gus_look8
(paren
l_int|0x5b
)paren
suffix:semicolon
multiline_comment|/* Version number register */
id|gus_write8
(paren
l_int|0x5b
comma
op_complement
id|val
)paren
suffix:semicolon
multiline_comment|/* Invert all bits */
r_if
c_cond
(paren
(paren
id|gus_look8
(paren
l_int|0x5b
)paren
op_amp
l_int|0xf0
)paren
op_eq
(paren
id|val
op_amp
l_int|0xf0
)paren
)paren
multiline_comment|/* No change */
r_if
c_cond
(paren
(paren
id|gus_look8
(paren
l_int|0x5b
)paren
op_amp
l_int|0x0f
)paren
op_eq
(paren
(paren
op_complement
id|val
)paren
op_amp
l_int|0x0f
)paren
)paren
multiline_comment|/* Change */
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;Interwave chip version %d detected&bslash;n&quot;
comma
(paren
id|val
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|gus_pnp_flag
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|DDB
(paren
id|printk
(paren
l_string|&quot;Not an Interwave chip (%x)&bslash;n&quot;
comma
id|gus_look8
(paren
l_int|0x5b
)paren
)paren
)paren
suffix:semicolon
id|gus_pnp_flag
op_assign
l_int|0
suffix:semicolon
)brace
id|gus_write8
(paren
l_int|0x5b
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* Restore all bits */
macro_line|#endif
r_if
c_cond
(paren
id|gus_pnp_flag
)paren
id|pnp_mem_init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iw_mode
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* See if there is first block there.... */
id|gus_poke
(paren
l_int|0L
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
l_int|0L
)paren
op_ne
l_int|0xaa
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Now zero it out so that I can check for mirroring .. */
id|gus_poke
(paren
l_int|0L
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1L
suffix:semicolon
id|i
OL
id|max_mem
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
comma
id|failed
suffix:semicolon
multiline_comment|/* check for mirroring ... */
r_if
c_cond
(paren
id|gus_peek
(paren
l_int|0L
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|loc
op_assign
id|i
op_lshift
l_int|10
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|loc
op_minus
l_int|1
comma
id|failed
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|loc
suffix:semicolon
id|n
op_increment
)paren
(brace
id|gus_poke
(paren
id|loc
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
id|loc
)paren
op_ne
l_int|0xaa
)paren
id|failed
op_assign
l_int|1
suffix:semicolon
id|gus_poke
(paren
id|loc
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
id|loc
)paren
op_ne
l_int|0x55
)paren
id|failed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
r_break
suffix:semicolon
)brace
id|gus_mem_size
op_assign
id|i
op_lshift
l_int|10
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|guswave_ioctl
id|guswave_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDCTL_SYNTH_INFO
suffix:colon
id|gus_info.nr_voices
op_assign
id|nr_voices
suffix:semicolon
id|memcpy
(paren
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
(braket
l_int|0
)braket
)paren
comma
(paren
r_char
op_star
)paren
op_amp
id|gus_info
comma
r_sizeof
(paren
id|gus_info
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_RESETSAMPLES
suffix:colon
id|reset_sample_memory
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_PERCMODE
suffix:colon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SYNTH_MEMAVL
suffix:colon
r_return
(paren
id|gus_mem_size
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|gus_mem_size
op_minus
id|free_mem_ptr
op_minus
l_int|32
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|guswave_set_instr
id|guswave_set_instr
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|instr_no
)paren
(brace
r_int
id|sample_no
suffix:semicolon
r_if
c_cond
(paren
id|instr_no
template_param
id|MAX_PATCH
)paren
id|instr_no
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default to acoustic piano */
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
id|instr_no
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sample_no
op_assign
id|patch_table
(braket
id|instr_no
)braket
suffix:semicolon
id|patch_map
(braket
id|voice
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sample_no
op_eq
id|NOT_SAMPLE
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Undefined patch %d for voice %d&bslash;n&quot;
comma
id|instr_no
comma
id|voice
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Patch not defined */
)brace
r_if
c_cond
(paren
id|sample_ptrs
(braket
id|sample_no
)braket
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* Sample not loaded */
(brace
id|printk
(paren
l_string|&quot;GUS: Sample #%d not loaded for patch %d (voice %d)&bslash;n&quot;
comma
id|sample_no
comma
id|instr_no
comma
id|voice
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sample_map
(braket
id|voice
)braket
op_assign
id|sample_no
suffix:semicolon
id|patch_map
(braket
id|voice
)braket
op_assign
id|instr_no
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|guswave_kill_note
id|guswave_kill_note
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|note
comma
r_int
id|velocity
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/* voice_alloc-&gt;map[voice] = 0xffff; */
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|kill_pending
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|gus_voice_fade
(paren
id|voice
)paren
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_aftertouch
id|guswave_aftertouch
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|pressure
)paren
(brace
)brace
r_static
r_void
DECL|function|guswave_panning
id|guswave_panning
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|value
)paren
(brace
r_if
c_cond
(paren
id|voice
op_ge
l_int|0
op_logical_or
id|voice
OL
l_int|32
)paren
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
id|value
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_volume_method
id|guswave_volume_method
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|VOL_METHOD_LINEAR
op_logical_or
id|mode
op_eq
id|VOL_METHOD_ADAGIO
)paren
id|volume_method
op_assign
id|mode
suffix:semicolon
)brace
r_static
r_void
DECL|function|compute_volume
id|compute_volume
(paren
r_int
id|voice
comma
r_int
id|volume
)paren
(brace
r_if
c_cond
(paren
id|volume
OL
l_int|128
)paren
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
op_assign
id|volume
suffix:semicolon
r_switch
c_cond
(paren
id|volume_method
)paren
(brace
r_case
id|VOL_METHOD_ADAGIO
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|gus_adagio_vol
(paren
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
comma
id|voices
(braket
id|voice
)braket
dot
id|main_vol
comma
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
comma
id|voices
(braket
id|voice
)braket
dot
id|patch_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VOL_METHOD_LINEAR
suffix:colon
multiline_comment|/* Totally ignores patch-volume and expression */
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|gus_linear_vol
(paren
id|volume
comma
id|voices
(braket
id|voice
)braket
dot
id|main_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|volume_base
op_plus
(paren
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
op_star
id|volume_scale
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
OG
l_int|4030
)paren
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
l_int|4030
suffix:semicolon
)brace
r_static
r_void
DECL|function|compute_and_set_volume
id|compute_and_set_volume
(paren
r_int
id|voice
comma
r_int
id|volume
comma
r_int
id|ramp_time
)paren
(brace
r_int
id|curr
comma
id|target
comma
id|rate
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|compute_volume
(paren
id|voice
comma
id|volume
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * CAUTION! Interrupts disabled. Enable them before returning&n;   */
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|curr
op_assign
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
suffix:semicolon
id|target
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
suffix:semicolon
r_if
c_cond
(paren
id|ramp_time
op_eq
id|INSTANT_RAMP
)paren
(brace
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|target
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ramp_time
op_eq
id|FAST_RAMP
)paren
id|rate
op_assign
l_int|63
suffix:semicolon
r_else
id|rate
op_assign
l_int|16
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|0
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|target
op_minus
id|curr
)paren
op_div
l_int|64
op_eq
l_int|0
)paren
multiline_comment|/* Close enough to target. */
(brace
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|target
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|target
OG
id|curr
)paren
(brace
r_if
c_cond
(paren
id|target
OG
(paren
l_int|4095
op_minus
l_int|65
)paren
)paren
id|target
op_assign
l_int|4095
op_minus
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
id|curr
comma
id|target
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Ramp up, once, no IRQ */
)brace
r_else
(brace
r_if
c_cond
(paren
id|target
OL
l_int|65
)paren
id|target
op_assign
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
id|target
comma
id|curr
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Ramp down, once, no irq */
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dynamic_volume_change
id|dynamic_volume_change
(paren
r_int
id|voice
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|status
op_assign
id|gus_read8
(paren
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Get voice status */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x03
)paren
r_return
suffix:semicolon
multiline_comment|/* Voice was not running */
r_if
c_cond
(paren
op_logical_neg
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
)paren
(brace
id|compute_and_set_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * Voice is running and has envelopes.&n;   */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|status
op_assign
id|gus_read8
(paren
l_int|0x0d
)paren
suffix:semicolon
multiline_comment|/* Ramping status */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x03
)paren
multiline_comment|/* Sustain phase? */
(brace
id|compute_and_set_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|env_phase
OL
l_int|0
)paren
r_return
suffix:semicolon
id|compute_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_controller
id|guswave_controller
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|ctrl_num
comma
r_int
id|value
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|freq
suffix:semicolon
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl_num
)paren
(brace
r_case
id|CTRL_PITCH_BENDER
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_ne
id|VMODE_START_NOTE
)paren
(brace
id|freq
op_assign
id|compute_finetune
(paren
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
comma
id|value
comma
id|voices
(braket
id|voice
)braket
dot
id|bender_range
comma
l_int|0
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
id|freq
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|freq
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CTRL_PITCH_BENDER_RANGE
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|bender_range
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_EXPRESSION
suffix:colon
id|value
op_div_assign
l_int|128
suffix:semicolon
r_case
id|CTRL_EXPRESSION
suffix:colon
r_if
c_cond
(paren
id|volume_method
op_eq
id|VOL_METHOD_ADAGIO
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_ne
id|VMODE_START_NOTE
)paren
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CTL_PAN
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
(paren
id|value
op_star
l_int|2
)paren
op_minus
l_int|128
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_MAIN_VOLUME
suffix:colon
id|value
op_assign
(paren
id|value
op_star
l_int|100
)paren
op_div
l_int|16383
suffix:semicolon
r_case
id|CTRL_MAIN_VOLUME
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|main_vol
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_ne
id|VMODE_START_NOTE
)paren
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|guswave_start_note2
id|guswave_start_note2
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|note_num
comma
r_int
id|volume
)paren
(brace
r_int
id|sample
comma
id|best_sample
comma
id|best_delta
comma
id|delta_freq
suffix:semicolon
r_int
id|is16bits
comma
id|samplep
comma
id|patch
comma
id|pan
suffix:semicolon
r_int
r_int
id|note_freq
comma
id|base_note
comma
id|freq
comma
id|flags
suffix:semicolon
r_int
r_char
id|mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid voice&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|note_num
op_eq
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
op_assign
id|volume
suffix:semicolon
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|compute_and_set_volume
(paren
id|voice
comma
id|volume
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|patch
op_assign
id|patch_map
(braket
id|voice
)braket
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|samplep
op_assign
id|patch_table
(braket
id|patch
)braket
)paren
op_eq
id|NOT_SAMPLE
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|note_freq
op_assign
id|note_to_freq
(paren
id|note_num
)paren
suffix:semicolon
multiline_comment|/*&n;   * Find a sample within a patch so that the note_freq is between low_note&n;   * and high_note.&n;   */
id|sample
op_assign
op_minus
l_int|1
suffix:semicolon
id|best_sample
op_assign
id|samplep
suffix:semicolon
id|best_delta
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
id|samplep
op_ne
l_int|0
op_logical_and
id|samplep
op_ne
id|NOT_SAMPLE
op_logical_and
id|sample
op_eq
op_minus
l_int|1
)paren
(brace
id|delta_freq
op_assign
id|note_freq
op_minus
id|samples
(braket
id|samplep
)braket
dot
id|base_note
suffix:semicolon
r_if
c_cond
(paren
id|delta_freq
OL
l_int|0
)paren
id|delta_freq
op_assign
op_minus
id|delta_freq
suffix:semicolon
r_if
c_cond
(paren
id|delta_freq
OL
id|best_delta
)paren
(brace
id|best_sample
op_assign
id|samplep
suffix:semicolon
id|best_delta
op_assign
id|delta_freq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|samples
(braket
id|samplep
)braket
dot
id|low_note
op_le
id|note_freq
op_logical_and
id|note_freq
op_le
id|samples
(braket
id|samplep
)braket
dot
id|high_note
)paren
id|sample
op_assign
id|samplep
suffix:semicolon
r_else
id|samplep
op_assign
id|samples
(braket
id|samplep
)braket
dot
id|key
suffix:semicolon
multiline_comment|/* Link to next sample */
)brace
r_if
c_cond
(paren
id|sample
op_eq
op_minus
l_int|1
)paren
id|sample
op_assign
id|best_sample
suffix:semicolon
r_if
c_cond
(paren
id|sample
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Patch %d not defined for note %d&bslash;n&quot;
comma
id|patch
comma
id|note_num
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Should play default patch ??? */
)brace
id|is16bits
op_assign
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|mode
op_assign
id|samples
(braket
id|sample
)braket
dot
id|mode
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|patch_vol
op_assign
id|samples
(braket
id|sample
)braket
dot
id|volume
suffix:semicolon
r_if
c_cond
(paren
id|iw_mode
)paren
id|gus_write8
(paren
l_int|0x15
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* RAM, Reset voice deactivate bit of SMSI */
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|env_rate
(braket
id|i
)braket
op_assign
id|samples
(braket
id|sample
)braket
dot
id|env_rate
(braket
id|i
)braket
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|env_offset
(braket
id|i
)braket
op_assign
id|samples
(braket
id|sample
)braket
dot
id|env_offset
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|sample_map
(braket
id|voice
)braket
op_assign
id|sample
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|fixed_pitch
)paren
multiline_comment|/* Fixed pitch */
(brace
id|freq
op_assign
id|samples
(braket
id|sample
)braket
dot
id|base_freq
suffix:semicolon
)brace
r_else
(brace
id|base_note
op_assign
id|samples
(braket
id|sample
)braket
dot
id|base_note
op_div
l_int|100
suffix:semicolon
id|note_freq
op_div_assign
l_int|100
suffix:semicolon
id|freq
op_assign
id|samples
(braket
id|sample
)braket
dot
id|base_freq
op_star
id|note_freq
op_div
id|base_note
suffix:semicolon
)brace
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
op_assign
id|freq
suffix:semicolon
multiline_comment|/*&n;   * Since the pitch bender may have been set before playing the note, we&n;   * have to calculate the bending now.&n;   */
id|freq
op_assign
id|compute_finetune
(paren
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
comma
id|voices
(braket
id|voice
)braket
dot
id|bender
comma
id|voices
(braket
id|voice
)braket
dot
id|bender_range
comma
l_int|0
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
id|freq
suffix:semicolon
id|pan
op_assign
(paren
id|samples
(braket
id|sample
)braket
dot
id|panning
op_plus
id|voices
(braket
id|voice
)braket
dot
id|panning
)paren
op_div
l_int|32
suffix:semicolon
id|pan
op_add_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|pan
OL
l_int|0
)paren
id|pan
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pan
OG
l_int|15
)paren
id|pan
op_assign
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
(brace
id|mode
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* 16 bits */
r_if
c_cond
(paren
(paren
id|sample_ptrs
(braket
id|sample
)braket
op_div
id|GUS_BANK_SIZE
)paren
op_ne
(paren
(paren
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|len
)paren
op_div
id|GUS_BANK_SIZE
)paren
)paren
id|printk
(paren
l_string|&quot;GUS: Sample address error&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*************************************************************************&n;   *    CAUTION!        Interrupts disabled. Don&squot;t return before enabling&n;   *************************************************************************/
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
id|compute_volume
(paren
id|voice
comma
id|volume
)paren
suffix:semicolon
id|init_envelope
(paren
id|voice
)paren
suffix:semicolon
)brace
r_else
(brace
id|compute_and_set_volume
(paren
id|voice
comma
id|volume
comma
l_int|0
)paren
suffix:semicolon
)brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_LOOP_BACK
)paren
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|len
op_minus
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* start=end */
r_else
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Sample start=begin */
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_LOOPING
)paren
(brace
id|mode
op_or_assign
l_int|0x08
suffix:semicolon
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_BIDIR_LOOP
)paren
id|mode
op_or_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_LOOP_BACK
)paren
(brace
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|loop_end
op_minus
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
comma
(paren
id|samples
(braket
id|sample
)braket
dot
id|fractions
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
comma
id|is16bits
)paren
suffix:semicolon
id|mode
op_or_assign
l_int|0x40
suffix:semicolon
)brace
id|gus_write_addr
(paren
l_int|0x02
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|loop_start
comma
id|samples
(braket
id|sample
)braket
dot
id|fractions
op_amp
l_int|0x0f
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop start location */
id|gus_write_addr
(paren
l_int|0x04
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|loop_end
comma
(paren
id|samples
(braket
id|sample
)braket
dot
id|fractions
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop end location */
)brace
r_else
(brace
id|mode
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* Loop IRQ at the end */
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
id|LMODE_FINISH
suffix:semicolon
multiline_comment|/* Ramp down at the end */
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_parm
op_assign
l_int|1
suffix:semicolon
id|gus_write_addr
(paren
l_int|0x02
comma
id|sample_ptrs
(braket
id|sample
)braket
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop start location */
id|gus_write_addr
(paren
l_int|0x04
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|len
op_minus
l_int|1
comma
(paren
id|samples
(braket
id|sample
)braket
dot
id|fractions
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop end location */
)brace
id|gus_voice_freq
(paren
id|freq
)paren
suffix:semicolon
id|gus_voice_balance
(paren
id|pan
)paren
suffix:semicolon
id|gus_voice_on
(paren
id|mode
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * New guswave_start_note by Andrew J. Robinson attempts to minimize clicking&n; * when the note playing on the voice is changed.  It uses volume&n; * ramping.&n; */
r_static
r_int
DECL|function|guswave_start_note
id|guswave_start_note
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|note_num
comma
r_int
id|volume
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|ret_val
op_assign
l_int|0
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|note_num
op_eq
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|volume_pending
op_assign
id|volume
suffix:semicolon
)brace
r_else
(brace
id|ret_val
op_assign
id|guswave_start_note2
(paren
id|dev
comma
id|voice
comma
id|note_num
comma
id|volume
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|mode
op_assign
id|gus_read8
(paren
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
l_int|0x20
)paren
id|gus_write8
(paren
l_int|0x00
comma
id|mode
op_amp
l_int|0xdf
)paren
suffix:semicolon
multiline_comment|/* No interrupt! */
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|kill_pending
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_ge
l_int|0
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Run temporarily with interrupts enabled */
id|guswave_set_instr
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
op_minus
l_int|1
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
multiline_comment|/* Reselect the voice (just to be sure) */
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
l_int|0x01
)paren
op_logical_or
(paren
r_int
)paren
(paren
(paren
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
)paren
OL
(paren
r_int
)paren
l_int|2065
)paren
)paren
(brace
id|ret_val
op_assign
id|guswave_start_note2
(paren
id|dev
comma
id|voice
comma
id|note_num
comma
id|volume
)paren
suffix:semicolon
)brace
r_else
(brace
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
op_assign
id|dev
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|note_pending
op_assign
id|note_num
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_pending
op_assign
id|volume
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_START_NOTE
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_ramp_range
(paren
l_int|2000
comma
l_int|4065
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|0
comma
l_int|63
)paren
suffix:semicolon
multiline_comment|/* Fastest possible rate */
id|gus_rampon
(paren
l_int|0x20
op_or
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Ramp down, once, irq */
)brace
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_reset
id|guswave_reset
(paren
r_int
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|gus_voice_init
(paren
id|i
)paren
suffix:semicolon
id|gus_voice_init2
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|guswave_open
id|guswave_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|gus_busy
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|voice_alloc-&gt;timestamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|DMAbuf_open_dma
(paren
id|gus_devnum
)paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* printk (&quot;GUS: Loading samples without DMA&bslash;n&quot;); */
id|gus_no_dma
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Upload samples using PIO */
)brace
r_else
id|gus_no_dma
op_assign
l_int|0
suffix:semicolon
id|dram_sleep_flag.opts
op_assign
id|WK_NONE
suffix:semicolon
id|gus_busy
op_assign
l_int|1
suffix:semicolon
id|active_device
op_assign
id|GUS_DEV_WAVE
suffix:semicolon
id|gusintr
(paren
id|gus_irq
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Serve pending interrupts */
id|gus_initialize
(paren
)paren
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
id|gusintr
(paren
id|gus_irq
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Serve pending interrupts */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_close
id|guswave_close
(paren
r_int
id|dev
)paren
(brace
id|gus_busy
op_assign
l_int|0
suffix:semicolon
id|active_device
op_assign
l_int|0
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gus_no_dma
)paren
id|DMAbuf_close_dma
(paren
id|gus_devnum
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|guswave_load_patch
id|guswave_load_patch
(paren
r_int
id|dev
comma
r_int
id|format
comma
r_const
r_char
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
(brace
r_struct
id|patch_info
id|patch
suffix:semicolon
r_int
id|instr
suffix:semicolon
r_int
id|sizeof_patch
suffix:semicolon
r_int
r_int
id|blk_sz
comma
id|blk_end
comma
id|left
comma
id|src_offs
comma
id|target
suffix:semicolon
id|sizeof_patch
op_assign
(paren
r_int
)paren
op_amp
id|patch.data
(braket
l_int|0
)braket
op_minus
(paren
r_int
)paren
op_amp
id|patch
suffix:semicolon
multiline_comment|/* Header size */
r_if
c_cond
(paren
id|format
op_ne
id|GUS_PATCH
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: Invalid patch format (key) 0x%x&bslash;n&quot;
comma
id|format
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
id|sizeof_patch
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: Patch header too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|count
op_sub_assign
id|sizeof_patch
suffix:semicolon
r_if
c_cond
(paren
id|free_sample
op_ge
id|MAX_SAMPLE
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Sample table full&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*&n;   * Copy the header from user space but ignore the first bytes which have&n;   * been transferred already.&n;   */
id|copy_from_user
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
op_amp
id|patch
)paren
(braket
id|offs
)braket
comma
op_amp
(paren
id|addr
)paren
(braket
id|offs
)braket
comma
id|sizeof_patch
op_minus
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_ROM
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|gus_mem_size
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|instr
op_assign
id|patch.instr_no
suffix:semicolon
r_if
c_cond
(paren
id|instr
template_param
id|MAX_PATCH
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid patch number %d&bslash;n&quot;
comma
id|instr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
id|patch.len
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Warning: Patch record too short (%d&lt;%d)&bslash;n&quot;
comma
id|count
comma
(paren
r_int
)paren
id|patch.len
)paren
suffix:semicolon
id|patch.len
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch.len
op_le
l_int|0
op_logical_or
id|patch.len
OG
id|gus_mem_size
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid sample length %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|patch.len
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_LOOPING
)paren
(brace
r_if
c_cond
(paren
id|patch.loop_start
OL
l_int|0
op_logical_or
id|patch.loop_start
op_ge
id|patch.len
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid loop start&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch.loop_end
template_param
id|patch.len
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid loop end&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|free_mem_ptr
op_assign
(paren
id|free_mem_ptr
op_plus
l_int|31
)paren
op_amp
op_complement
l_int|31
suffix:semicolon
multiline_comment|/* 32 byte alignment */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_16_BITS
)paren
(brace
multiline_comment|/*&n;       * 16 bit samples must fit one 256k bank.&n;       */
r_if
c_cond
(paren
id|patch.len
op_ge
id|GUS_BANK_SIZE
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Sample (16 bit) too long %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|patch.len
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|free_mem_ptr
op_div
id|GUS_BANK_SIZE
)paren
op_ne
(paren
(paren
id|free_mem_ptr
op_plus
id|patch.len
)paren
op_div
id|GUS_BANK_SIZE
)paren
)paren
(brace
r_int
r_int
id|tmp_mem
op_assign
multiline_comment|/* Align to 256K */
(paren
(paren
id|free_mem_ptr
op_div
id|GUS_BANK_SIZE
)paren
op_plus
l_int|1
)paren
op_star
id|GUS_BANK_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp_mem
op_plus
id|patch.len
)paren
OG
id|gus_mem_size
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|free_mem_ptr
op_assign
id|tmp_mem
suffix:semicolon
multiline_comment|/* This leaves unusable memory */
)brace
)brace
r_if
c_cond
(paren
(paren
id|free_mem_ptr
op_plus
id|patch.len
)paren
OG
id|gus_mem_size
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|sample_ptrs
(braket
id|free_sample
)braket
op_assign
id|free_mem_ptr
suffix:semicolon
multiline_comment|/*&n;   * Tremolo is not possible with envelopes&n;   */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_ENVELOPES
)paren
id|patch.mode
op_and_assign
op_complement
id|WAVE_TREMOLO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|patch.mode
op_amp
id|WAVE_FRACTIONS
)paren
)paren
(brace
id|patch.fractions
op_assign
l_int|0
suffix:semicolon
)brace
id|memcpy
(paren
(paren
r_char
op_star
)paren
op_amp
id|samples
(braket
id|free_sample
)braket
comma
op_amp
id|patch
comma
id|sizeof_patch
)paren
suffix:semicolon
multiline_comment|/*&n;   * Link this_one sample to the list of samples for patch &squot;instr&squot;.&n;   */
id|samples
(braket
id|free_sample
)braket
dot
id|key
op_assign
id|patch_table
(braket
id|instr
)braket
suffix:semicolon
id|patch_table
(braket
id|instr
)braket
op_assign
id|free_sample
suffix:semicolon
multiline_comment|/*&n;   * Use DMA to transfer the wave data to the DRAM&n;   */
id|left
op_assign
id|patch.len
suffix:semicolon
id|src_offs
op_assign
l_int|0
suffix:semicolon
id|target
op_assign
id|free_mem_ptr
suffix:semicolon
r_while
c_loop
(paren
id|left
)paren
multiline_comment|/* Not completely transferred yet */
(brace
id|blk_sz
op_assign
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;bytes_in_use
suffix:semicolon
r_if
c_cond
(paren
id|blk_sz
OG
id|left
)paren
id|blk_sz
op_assign
id|left
suffix:semicolon
multiline_comment|/*&n;       * DMA cannot cross bank (256k) boundaries. Check for that.&n;       */
id|blk_end
op_assign
id|target
op_plus
id|blk_sz
suffix:semicolon
r_if
c_cond
(paren
(paren
id|target
op_div
id|GUS_BANK_SIZE
)paren
op_ne
(paren
id|blk_end
op_div
id|GUS_BANK_SIZE
)paren
)paren
(brace
multiline_comment|/* Split the block */
id|blk_end
op_and_assign
op_complement
(paren
id|GUS_BANK_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|blk_sz
op_assign
id|blk_end
op_minus
id|target
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gus_no_dma
)paren
(brace
multiline_comment|/*&n;&t;   * For some reason the DMA is not possible. We have to use PIO.&n;&t;   */
r_int
id|i
suffix:semicolon
r_int
r_char
id|data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blk_sz
suffix:semicolon
id|i
op_increment
)paren
(brace
id|get_user
(paren
op_star
(paren
r_int
r_char
op_star
)paren
op_amp
id|data
comma
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
(paren
id|addr
)paren
(braket
id|sizeof_patch
op_plus
id|i
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_UNSIGNED
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|patch.mode
op_amp
id|WAVE_16_BITS
)paren
op_logical_or
(paren
id|i
op_amp
l_int|0x01
)paren
)paren
id|data
op_xor_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* Convert to signed */
id|gus_poke
(paren
id|target
op_plus
id|i
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_int
id|address
comma
id|hold_address
suffix:semicolon
r_int
r_char
id|dma_command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;raw_buf
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: DMA buffer == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   * OK, move now. First in and then out.&n;&t;   */
id|copy_from_user
(paren
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;raw_buf
comma
op_amp
(paren
id|addr
)paren
(braket
id|sizeof_patch
op_plus
id|src_offs
)braket
comma
id|blk_sz
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/******** INTERRUPTS DISABLED NOW ********/
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable GF1 DMA */
id|DMAbuf_start_dma
(paren
id|gus_devnum
comma
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;raw_buf_phys
comma
id|blk_sz
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   * Set the DRAM address for the wave data&n;&t;   */
r_if
c_cond
(paren
id|iw_mode
)paren
(brace
multiline_comment|/* Different address translation in enhanced mode */
r_int
r_char
id|hi
suffix:semicolon
r_if
c_cond
(paren
id|gus_dma
OG
l_int|4
)paren
id|address
op_assign
id|target
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* Convert to 16 bit word address */
r_else
id|address
op_assign
id|target
suffix:semicolon
id|hi
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|address
op_rshift
l_int|16
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
id|hi
op_add_assign
(paren
r_int
r_char
)paren
(paren
id|address
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|gus_write16
(paren
l_int|0x42
comma
(paren
id|address
op_rshift
l_int|4
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* DMA address (low) */
id|gus_write8
(paren
l_int|0x50
comma
id|hi
)paren
suffix:semicolon
)brace
r_else
(brace
id|address
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
OG
l_int|3
)paren
(brace
id|hold_address
op_assign
id|address
suffix:semicolon
id|address
op_assign
id|address
op_rshift
l_int|1
suffix:semicolon
id|address
op_and_assign
l_int|0x0001ffffL
suffix:semicolon
id|address
op_or_assign
(paren
id|hold_address
op_amp
l_int|0x000c0000L
)paren
suffix:semicolon
)brace
id|gus_write16
(paren
l_int|0x42
comma
(paren
id|address
op_rshift
l_int|4
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* DRAM DMA address */
)brace
multiline_comment|/*&n;&t;   * Start the DMA transfer&n;&t;   */
id|dma_command
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* IRQ enable, DMA start */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_UNSIGNED
)paren
id|dma_command
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* Invert MSB */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_16_BITS
)paren
id|dma_command
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* 16 bit _DATA_ */
r_if
c_cond
(paren
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
OG
l_int|3
)paren
id|dma_command
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* 16 bit DMA _channel_ */
id|gus_write8
(paren
l_int|0x41
comma
id|dma_command
)paren
suffix:semicolon
multiline_comment|/* Lets go luteet (=bugs) */
multiline_comment|/*&n;&t;   * Sleep here until the DRAM DMA done interrupt is served&n;&t;   */
id|active_device
op_assign
id|GUS_DEV_WAVE
suffix:semicolon
(brace
r_int
r_int
id|tlimit
suffix:semicolon
r_if
c_cond
(paren
id|HZ
)paren
id|current-&gt;timeout
op_assign
id|tlimit
op_assign
id|jiffies
op_plus
(paren
id|HZ
)paren
suffix:semicolon
r_else
id|tlimit
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
id|dram_sleep_flag.opts
op_assign
id|WK_SLEEP
suffix:semicolon
id|interruptible_sleep_on
(paren
op_amp
id|dram_sleeper
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dram_sleep_flag.opts
op_amp
id|WK_WAKEUP
)paren
)paren
(brace
r_if
c_cond
(paren
id|jiffies
op_ge
id|tlimit
)paren
id|dram_sleep_flag.opts
op_or_assign
id|WK_TIMEOUT
suffix:semicolon
)brace
id|dram_sleep_flag.opts
op_and_assign
op_complement
id|WK_SLEEP
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dram_sleep_flag.opts
op_amp
id|WK_TIMEOUT
)paren
)paren
id|printk
(paren
l_string|&quot;GUS: DMA Transfer timed out&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * Now the next part&n;       */
id|left
op_sub_assign
id|blk_sz
suffix:semicolon
id|src_offs
op_add_assign
id|blk_sz
suffix:semicolon
id|target
op_add_assign
id|blk_sz
suffix:semicolon
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Stop DMA */
)brace
id|free_mem_ptr
op_add_assign
id|patch.len
suffix:semicolon
id|free_sample
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_hw_control
id|guswave_hw_control
(paren
r_int
id|dev
comma
r_int
r_char
op_star
id|event_rec
)paren
(brace
r_int
id|voice
comma
id|cmd
suffix:semicolon
r_int
r_int
id|p1
comma
id|p2
suffix:semicolon
r_int
r_int
id|plong
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|cmd
op_assign
id|event_rec
(braket
l_int|2
)braket
suffix:semicolon
id|voice
op_assign
id|event_rec
(braket
l_int|3
)braket
suffix:semicolon
id|p1
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|event_rec
(braket
l_int|4
)braket
suffix:semicolon
id|p2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|event_rec
(braket
l_int|6
)braket
suffix:semicolon
id|plong
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|event_rec
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
op_logical_and
(paren
id|cmd
op_ne
id|_GUS_VOICESAMPLE
)paren
op_logical_and
(paren
id|cmd
op_ne
id|_GUS_VOICE_POS
)paren
)paren
id|do_volume_irq
(paren
id|voice
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|_GUS_NUMVOICES
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_select_max_voices
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICESAMPLE
suffix:colon
id|guswave_set_instr
(paren
id|dev
comma
id|voice
comma
id|p1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEON
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* Don&squot;t allow interrupts */
id|gus_voice_on
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEOFF
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEFADE
suffix:colon
id|gus_voice_fade
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEMODE
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* Don&squot;t allow interrupts */
id|gus_voice_mode
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEBALA
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_balance
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEFREQ
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|plong
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEVOL
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEVOL2
suffix:colon
multiline_comment|/* Just update the software voice level */
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|p1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPRANGE
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* NO-NO */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_ramp_range
(paren
id|p1
comma
id|p2
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPRATE
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* NJET-NJET */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
id|p1
comma
id|p2
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPMODE
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* NO-NO */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* Don&squot;t allow interrupts */
id|gus_ramp_mode
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPON
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* EI-EI */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* Don&squot;t allow interrupts */
id|gus_rampon
(paren
id|p1
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPOFF
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* NEJ-NEJ */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOLUME_SCALE
suffix:colon
id|volume_base
op_assign
id|p1
suffix:semicolon
id|volume_scale
op_assign
id|p2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICE_POS
suffix:colon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_set_voice_pos
(paren
id|voice
comma
id|plong
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|gus_audio_set_speed
id|gus_audio_set_speed
(paren
r_int
id|speed
)paren
(brace
r_if
c_cond
(paren
id|speed
op_le
l_int|0
)paren
id|speed
op_assign
id|gus_audio_speed
suffix:semicolon
r_if
c_cond
(paren
id|speed
OL
l_int|4000
)paren
id|speed
op_assign
l_int|4000
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
l_int|44100
)paren
id|speed
op_assign
l_int|44100
suffix:semicolon
id|gus_audio_speed
op_assign
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|only_read_access
)paren
(brace
multiline_comment|/* Compute nearest valid recording speed  and return it */
multiline_comment|/* speed = (9878400 / (gus_audio_speed + 2)) / 16; */
id|speed
op_assign
(paren
(paren
(paren
l_int|9878400
op_plus
id|gus_audio_speed
op_div
l_int|2
)paren
op_div
(paren
id|gus_audio_speed
op_plus
l_int|2
)paren
)paren
op_plus
l_int|8
)paren
op_div
l_int|16
suffix:semicolon
id|speed
op_assign
(paren
l_int|9878400
op_div
(paren
id|speed
op_star
l_int|16
)paren
)paren
op_minus
l_int|2
suffix:semicolon
)brace
r_return
id|speed
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_audio_set_channels
id|gus_audio_set_channels
(paren
r_int
id|channels
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|channels
)paren
r_return
id|gus_audio_channels
suffix:semicolon
r_if
c_cond
(paren
id|channels
OG
l_int|2
)paren
id|channels
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|channels
OL
l_int|1
)paren
id|channels
op_assign
l_int|1
suffix:semicolon
id|gus_audio_channels
op_assign
id|channels
suffix:semicolon
r_return
id|channels
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_audio_set_bits
id|gus_audio_set_bits
(paren
r_int
id|bits
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
r_return
id|gus_audio_bits
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_ne
l_int|8
op_logical_and
id|bits
op_ne
l_int|16
)paren
id|bits
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|only_8_bits
)paren
id|bits
op_assign
l_int|8
suffix:semicolon
id|gus_audio_bits
op_assign
id|bits
suffix:semicolon
r_return
id|bits
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_audio_ioctl
id|gus_audio_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
r_int
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_PCM_WRITE_RATE
suffix:colon
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_set_speed
(paren
id|val
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_speed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_set_channels
(paren
id|val
op_plus
l_int|1
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_CHANNELS
suffix:colon
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_set_channels
(paren
id|val
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_channels
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_set_bits
(paren
id|val
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_audio_bits
)paren
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
multiline_comment|/* NOT POSSIBLE */
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
op_minus
id|EINVAL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
op_minus
id|EINVAL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_audio_reset
id|gus_audio_reset
(paren
r_int
id|dev
)paren
(brace
r_if
c_cond
(paren
id|recording_active
)paren
(brace
id|gus_write8
(paren
l_int|0x49
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Halt recording */
id|set_input_volumes
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|saved_iw_mode
r_static
r_int
id|saved_iw_mode
suffix:semicolon
multiline_comment|/* A hack hack hack */
r_static
r_int
DECL|function|gus_audio_open
id|gus_audio_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
id|gus_busy
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|gus_pnp_flag
op_logical_and
id|mode
op_amp
id|OPEN_READ
)paren
(brace
id|printk
(paren
l_string|&quot;Sound: This audio device doesn&squot;t have recording capability&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|gus_initialize
(paren
)paren
suffix:semicolon
id|gus_busy
op_assign
l_int|1
suffix:semicolon
id|active_device
op_assign
l_int|0
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
id|reset_sample_memory
(paren
)paren
suffix:semicolon
id|gus_select_max_voices
(paren
l_int|14
)paren
suffix:semicolon
id|saved_iw_mode
op_assign
id|iw_mode
suffix:semicolon
r_if
c_cond
(paren
id|iw_mode
)paren
(brace
multiline_comment|/* There are some problems with audio in enhanced mode so disable it */
id|gus_write8
(paren
l_int|0x19
comma
id|gus_read8
(paren
l_int|0x19
)paren
op_amp
op_complement
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Disable enhanced mode */
id|iw_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|pcm_active
op_assign
l_int|0
suffix:semicolon
id|dma_active
op_assign
l_int|0
suffix:semicolon
id|pcm_opened
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|OPEN_READ
)paren
(brace
id|recording_active
op_assign
l_int|1
suffix:semicolon
id|set_input_volumes
(paren
)paren
suffix:semicolon
)brace
id|only_read_access
op_assign
op_logical_neg
(paren
id|mode
op_amp
id|OPEN_WRITE
)paren
suffix:semicolon
id|only_8_bits
op_assign
id|mode
op_amp
id|OPEN_READ
suffix:semicolon
r_if
c_cond
(paren
id|only_8_bits
)paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|format_mask
op_assign
id|AFMT_U8
suffix:semicolon
r_else
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|format_mask
op_assign
id|AFMT_U8
op_or
id|AFMT_S16_LE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_audio_close
id|gus_audio_close
(paren
r_int
id|dev
)paren
(brace
id|iw_mode
op_assign
id|saved_iw_mode
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
id|gus_busy
op_assign
l_int|0
suffix:semicolon
id|pcm_opened
op_assign
l_int|0
suffix:semicolon
id|active_device
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|recording_active
)paren
(brace
id|gus_write8
(paren
l_int|0x49
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Halt recording */
id|set_input_volumes
(paren
)paren
suffix:semicolon
)brace
id|recording_active
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_audio_update_volume
id|gus_audio_update_volume
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|voice
suffix:semicolon
r_if
c_cond
(paren
id|pcm_active
op_logical_and
id|pcm_opened
)paren
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|gus_audio_channels
suffix:semicolon
id|voice
op_increment
)paren
(brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|gus_ramp_range
(paren
l_int|65
comma
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|play_next_pcm_block
id|play_next_pcm_block
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|speed
op_assign
id|gus_audio_speed
suffix:semicolon
r_int
id|this_one
comma
id|is16bits
comma
id|chn
suffix:semicolon
r_int
r_int
id|dram_loc
suffix:semicolon
r_int
r_char
id|mode
(braket
l_int|2
)braket
comma
id|ramp_mode
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcm_qlen
)paren
r_return
suffix:semicolon
id|this_one
op_assign
id|pcm_head
suffix:semicolon
r_for
c_loop
(paren
id|chn
op_assign
l_int|0
suffix:semicolon
id|chn
OL
id|gus_audio_channels
suffix:semicolon
id|chn
op_increment
)paren
(brace
id|mode
(braket
id|chn
)braket
op_assign
l_int|0x00
suffix:semicolon
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* Ramping and rollover off */
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
(brace
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* Loop IRQ */
id|voices
(braket
id|chn
)braket
dot
id|loop_irq_mode
op_assign
id|LMODE_PCM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gus_audio_bits
op_ne
l_int|8
)paren
(brace
id|is16bits
op_assign
l_int|1
suffix:semicolon
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* 16 bit data */
)brace
r_else
id|is16bits
op_assign
l_int|0
suffix:semicolon
id|dram_loc
op_assign
id|this_one
op_star
id|pcm_bsize
suffix:semicolon
id|dram_loc
op_add_assign
id|chn
op_star
id|pcm_banksize
suffix:semicolon
r_if
c_cond
(paren
id|this_one
op_eq
(paren
id|pcm_nblk
op_minus
l_int|1
)paren
)paren
multiline_comment|/* Last fragment of the DRAM buffer */
(brace
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* Enable loop */
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* Disable rollover bit */
)brace
r_else
(brace
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Enable rollover bit */
)brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|chn
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|speed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_audio_channels
op_eq
l_int|1
)paren
id|gus_voice_balance
(paren
l_int|7
)paren
suffix:semicolon
multiline_comment|/* mono */
r_else
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
id|gus_voice_balance
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* left */
r_else
id|gus_voice_balance
(paren
l_int|15
)paren
suffix:semicolon
multiline_comment|/* right */
r_if
c_cond
(paren
op_logical_neg
id|pcm_active
)paren
multiline_comment|/* Playback not already active */
(brace
multiline_comment|/*&n;&t;   * The playback was not started yet (or there has been a pause).&n;&t;   * Start the voice (again) and ask for a rollover irq at the end of&n;&t;   * this_one block. If this_one one is last of the buffers, use just&n;&t;   * the normal loop with irq.&n;&t;   */
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|gus_ramp_range
(paren
l_int|65
comma
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|gus_write_addr
(paren
l_int|0x0a
comma
id|chn
op_star
id|pcm_banksize
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Starting position */
id|gus_write_addr
(paren
l_int|0x02
comma
id|chn
op_star
id|pcm_banksize
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop start */
r_if
c_cond
(paren
id|chn
op_ne
l_int|0
)paren
id|gus_write_addr
(paren
l_int|0x04
comma
id|pcm_banksize
op_plus
(paren
id|pcm_bsize
op_star
id|pcm_nblk
)paren
op_minus
l_int|1
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop end location */
)brace
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
id|gus_write_addr
(paren
l_int|0x04
comma
id|dram_loc
op_plus
id|pcm_bsize
op_minus
l_int|1
comma
l_int|0
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Loop end location */
r_else
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* Enable looping */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|chn
op_assign
l_int|0
suffix:semicolon
id|chn
OL
id|gus_audio_channels
suffix:semicolon
id|chn
op_increment
)paren
(brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|chn
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
id|ramp_mode
(braket
id|chn
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iw_mode
)paren
id|gus_write8
(paren
l_int|0x15
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Reset voice deactivate bit of SMSI */
id|gus_voice_on
(paren
id|mode
(braket
id|chn
)braket
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
id|pcm_active
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_transfer_output_block
id|gus_transfer_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|total_count
comma
r_int
id|intrflag
comma
r_int
id|chn
)paren
(brace
multiline_comment|/*&n;   * This routine transfers one block of audio data to the DRAM. In mono mode&n;   * it&squot;s called just once. When in stereo mode, this_one routine is called&n;   * once for both channels.&n;   *&n;   * The left/mono channel data is transferred to the beginning of dram and the&n;   * right data to the area pointed by gus_page_size.&n;   */
r_int
id|this_one
comma
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|dma_command
suffix:semicolon
r_int
r_int
id|address
comma
id|hold_address
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|count
op_assign
id|total_count
op_div
id|gus_audio_channels
suffix:semicolon
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pcm_qlen
op_ge
id|pcm_nblk
)paren
id|printk
(paren
l_string|&quot;GUS Warning: PCM buffers out of sync&bslash;n&quot;
)paren
suffix:semicolon
id|this_one
op_assign
id|pcm_current_block
op_assign
id|pcm_tail
suffix:semicolon
id|pcm_qlen
op_increment
suffix:semicolon
id|pcm_tail
op_assign
(paren
id|pcm_tail
op_plus
l_int|1
)paren
op_mod
id|pcm_nblk
suffix:semicolon
id|pcm_datasize
(braket
id|this_one
)braket
op_assign
id|count
suffix:semicolon
)brace
r_else
id|this_one
op_assign
id|pcm_current_block
suffix:semicolon
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable GF1 DMA */
id|DMAbuf_start_dma
(paren
id|dev
comma
id|buf
op_plus
(paren
id|chn
op_star
id|count
)paren
comma
id|count
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|address
op_assign
id|this_one
op_star
id|pcm_bsize
suffix:semicolon
id|address
op_add_assign
id|chn
op_star
id|pcm_banksize
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
OG
l_int|3
)paren
(brace
id|hold_address
op_assign
id|address
suffix:semicolon
id|address
op_assign
id|address
op_rshift
l_int|1
suffix:semicolon
id|address
op_and_assign
l_int|0x0001ffffL
suffix:semicolon
id|address
op_or_assign
(paren
id|hold_address
op_amp
l_int|0x000c0000L
)paren
suffix:semicolon
)brace
id|gus_write16
(paren
l_int|0x42
comma
(paren
id|address
op_rshift
l_int|4
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* DRAM DMA address */
id|dma_command
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* IRQ enable, DMA start */
r_if
c_cond
(paren
id|gus_audio_bits
op_ne
l_int|8
)paren
id|dma_command
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* 16 bit _DATA_ */
r_else
id|dma_command
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* Invert MSB */
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
OG
l_int|3
)paren
id|dma_command
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* 16 bit DMA channel */
id|gus_write8
(paren
l_int|0x41
comma
id|dma_command
)paren
suffix:semicolon
multiline_comment|/* Kick start */
r_if
c_cond
(paren
id|chn
op_eq
(paren
id|gus_audio_channels
op_minus
l_int|1
)paren
)paren
multiline_comment|/* Last channel */
(brace
multiline_comment|/*&n;       * Last (right or mono) channel data&n;       */
id|dma_active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DMA started. There is a unacknowledged buffer */
id|active_device
op_assign
id|GUS_DEV_PCM_DONE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcm_active
op_logical_and
(paren
id|pcm_qlen
OG
l_int|1
op_logical_or
id|count
OL
id|pcm_bsize
)paren
)paren
(brace
id|play_next_pcm_block
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;         * Left channel data. The right channel&n;         * is transferred after DMA interrupt&n;       */
id|active_device
op_assign
id|GUS_DEV_PCM_CONTINUE
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_uninterleave8
id|gus_uninterleave8
(paren
r_char
op_star
id|buf
comma
r_int
id|l
)paren
(brace
multiline_comment|/* This routine uninterleaves 8 bit stereo output (LRLRLR-&gt;LLLRRR) */
r_int
id|i
comma
id|p
op_assign
l_int|0
comma
id|halfsize
op_assign
id|l
op_div
l_int|2
suffix:semicolon
r_char
op_star
id|buf2
op_assign
id|buf
op_plus
id|halfsize
comma
op_star
id|src
op_assign
id|bounce_buf
suffix:semicolon
id|memcpy
(paren
id|bounce_buf
comma
id|buf
comma
id|l
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|halfsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|src
(braket
id|p
op_increment
)braket
suffix:semicolon
multiline_comment|/* Left channel */
id|buf2
(braket
id|i
)braket
op_assign
id|src
(braket
id|p
op_increment
)braket
suffix:semicolon
multiline_comment|/* Right channel */
)brace
)brace
r_static
r_void
DECL|function|gus_uninterleave16
id|gus_uninterleave16
(paren
r_int
op_star
id|buf
comma
r_int
id|l
)paren
(brace
multiline_comment|/* This routine uninterleaves 16 bit stereo output (LRLRLR-&gt;LLLRRR) */
r_int
id|i
comma
id|p
op_assign
l_int|0
comma
id|halfsize
op_assign
id|l
op_div
l_int|2
suffix:semicolon
r_int
op_star
id|buf2
op_assign
id|buf
op_plus
id|halfsize
comma
op_star
id|src
op_assign
(paren
r_int
op_star
)paren
id|bounce_buf
suffix:semicolon
id|memcpy
(paren
id|bounce_buf
comma
(paren
r_char
op_star
)paren
id|buf
comma
id|l
op_star
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|halfsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|src
(braket
id|p
op_increment
)braket
suffix:semicolon
multiline_comment|/* Left channel */
id|buf2
(braket
id|i
)braket
op_assign
id|src
(braket
id|p
op_increment
)braket
suffix:semicolon
multiline_comment|/* Right channel */
)brace
)brace
r_static
r_void
DECL|function|gus_audio_output_block
id|gus_audio_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|total_count
comma
r_int
id|intrflag
)paren
(brace
r_struct
id|dma_buffparms
op_star
id|dmap
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out
suffix:semicolon
id|dmap-&gt;flags
op_or_assign
id|DMA_NODMA
op_or
id|DMA_NOTIMEOUT
suffix:semicolon
id|pcm_current_buf
op_assign
id|buf
suffix:semicolon
id|pcm_current_count
op_assign
id|total_count
suffix:semicolon
id|pcm_current_intrflag
op_assign
id|intrflag
suffix:semicolon
id|pcm_current_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|gus_audio_channels
op_eq
l_int|2
)paren
(brace
r_char
op_star
id|b
op_assign
id|dmap-&gt;raw_buf
op_plus
(paren
id|buf
op_minus
id|dmap-&gt;raw_buf_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_audio_bits
op_eq
l_int|8
)paren
id|gus_uninterleave8
(paren
id|b
comma
id|total_count
)paren
suffix:semicolon
r_else
id|gus_uninterleave16
(paren
(paren
r_int
op_star
)paren
id|b
comma
id|total_count
op_div
l_int|2
)paren
suffix:semicolon
)brace
id|gus_transfer_output_block
(paren
id|dev
comma
id|buf
comma
id|total_count
comma
id|intrflag
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_audio_start_input
id|gus_audio_start_input
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|mode
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|DMAbuf_start_dma
(paren
id|dev
comma
id|buf
comma
id|count
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|mode
op_assign
l_int|0xa0
suffix:semicolon
multiline_comment|/* DMA IRQ enabled, invert MSB */
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_in-&gt;dma
OG
l_int|3
)paren
id|mode
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* 16 bit DMA channel */
r_if
c_cond
(paren
id|gus_audio_channels
OG
l_int|1
)paren
id|mode
op_or_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* Stereo */
id|mode
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* DMA enable */
id|gus_write8
(paren
l_int|0x49
comma
id|mode
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_audio_prepare_for_input
id|gus_audio_prepare_for_input
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_int
r_int
id|rate
suffix:semicolon
id|gus_audio_bsize
op_assign
id|bsize
suffix:semicolon
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_in-&gt;flags
op_or_assign
id|DMA_NODMA
suffix:semicolon
id|rate
op_assign
(paren
(paren
(paren
l_int|9878400
op_plus
id|gus_audio_speed
op_div
l_int|2
)paren
op_div
(paren
id|gus_audio_speed
op_plus
l_int|2
)paren
)paren
op_plus
l_int|8
)paren
op_div
l_int|16
suffix:semicolon
id|gus_write8
(paren
l_int|0x48
comma
id|rate
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Set sampling rate */
r_if
c_cond
(paren
id|gus_audio_bits
op_ne
l_int|8
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: 16 bit recording not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_audio_prepare_for_output
id|gus_audio_prepare_for_output
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|mem_ptr
comma
id|mem_size
suffix:semicolon
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;flags
op_or_assign
id|DMA_NODMA
op_or
id|DMA_NOTIMEOUT
suffix:semicolon
id|mem_ptr
op_assign
l_int|0
suffix:semicolon
id|mem_size
op_assign
id|gus_mem_size
op_div
id|gus_audio_channels
suffix:semicolon
r_if
c_cond
(paren
id|mem_size
OG
(paren
l_int|256
op_star
l_int|1024
)paren
)paren
id|mem_size
op_assign
l_int|256
op_star
l_int|1024
suffix:semicolon
id|pcm_bsize
op_assign
id|bsize
op_div
id|gus_audio_channels
suffix:semicolon
id|pcm_head
op_assign
id|pcm_tail
op_assign
id|pcm_qlen
op_assign
l_int|0
suffix:semicolon
id|pcm_nblk
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* MAX_PCM_BUFFERS; */
r_if
c_cond
(paren
(paren
id|pcm_bsize
op_star
id|pcm_nblk
)paren
OG
id|mem_size
)paren
id|pcm_nblk
op_assign
id|mem_size
op_div
id|pcm_bsize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pcm_nblk
suffix:semicolon
id|i
op_increment
)paren
id|pcm_datasize
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|pcm_banksize
op_assign
id|pcm_nblk
op_star
id|pcm_bsize
suffix:semicolon
r_if
c_cond
(paren
id|gus_audio_bits
op_ne
l_int|8
op_logical_and
id|pcm_banksize
op_eq
(paren
l_int|256
op_star
l_int|1024
)paren
)paren
id|pcm_nblk
op_decrement
suffix:semicolon
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable GF1 DMA */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_local_qlen
id|gus_local_qlen
(paren
r_int
id|dev
)paren
(brace
r_return
id|pcm_qlen
suffix:semicolon
)brace
DECL|variable|gus_audio_driver
r_static
r_struct
id|audio_driver
id|gus_audio_driver
op_assign
(brace
id|gus_audio_open
comma
id|gus_audio_close
comma
id|gus_audio_output_block
comma
id|gus_audio_start_input
comma
id|gus_audio_ioctl
comma
id|gus_audio_prepare_for_input
comma
id|gus_audio_prepare_for_output
comma
id|gus_audio_reset
comma
id|gus_local_qlen
comma
l_int|NULL
)brace
suffix:semicolon
r_static
r_void
DECL|function|guswave_setup_voice
id|guswave_setup_voice
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|chn
)paren
(brace
r_struct
id|channel_info
op_star
id|info
op_assign
op_amp
id|synth_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|chn_info
(braket
id|chn
)braket
suffix:semicolon
id|guswave_set_instr
(paren
id|dev
comma
id|voice
comma
id|info-&gt;pgm_num
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
op_assign
id|info-&gt;controllers
(braket
id|CTL_EXPRESSION
)braket
suffix:semicolon
multiline_comment|/* Just MSB */
id|voices
(braket
id|voice
)braket
dot
id|main_vol
op_assign
(paren
id|info-&gt;controllers
(braket
id|CTL_MAIN_VOLUME
)braket
op_star
l_int|100
)paren
op_div
(paren
r_int
)paren
l_int|128
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
(paren
id|info-&gt;controllers
(braket
id|CTL_PAN
)braket
op_star
l_int|2
)paren
op_minus
l_int|128
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender_range
op_assign
id|info-&gt;bender_range
suffix:semicolon
r_if
c_cond
(paren
id|chn
op_eq
l_int|9
)paren
id|voices
(braket
id|voice
)braket
dot
id|fixed_pitch
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_bender
id|guswave_bender
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|value
)paren
(brace
r_int
id|freq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
id|value
op_minus
l_int|8192
suffix:semicolon
id|freq
op_assign
id|compute_finetune
(paren
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
comma
id|value
op_minus
l_int|8192
comma
id|voices
(braket
id|voice
)braket
dot
id|bender_range
comma
l_int|0
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
id|freq
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|freq
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|guswave_alloc
id|guswave_alloc
(paren
r_int
id|dev
comma
r_int
id|chn
comma
r_int
id|note
comma
r_struct
id|voice_alloc_info
op_star
id|alloc
)paren
(brace
r_int
id|i
comma
id|p
comma
id|best
op_assign
op_minus
l_int|1
comma
id|best_time
op_assign
l_int|0x7fffffff
suffix:semicolon
id|p
op_assign
id|alloc-&gt;ptr
suffix:semicolon
multiline_comment|/*&n;     * First look for a completely stopped voice&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc-&gt;max_voice
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|alloc-&gt;map
(braket
id|p
)braket
op_eq
l_int|0
)paren
(brace
id|alloc-&gt;ptr
op_assign
id|p
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc-&gt;alloc_times
(braket
id|p
)braket
OL
id|best_time
)paren
(brace
id|best
op_assign
id|p
suffix:semicolon
id|best_time
op_assign
id|alloc-&gt;alloc_times
(braket
id|p
)braket
suffix:semicolon
)brace
id|p
op_assign
(paren
id|p
op_plus
l_int|1
)paren
op_mod
id|alloc-&gt;max_voice
suffix:semicolon
)brace
multiline_comment|/*&n;     * Then look for a releasing voice&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc-&gt;max_voice
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|alloc-&gt;map
(braket
id|p
)braket
op_eq
l_int|0xffff
)paren
(brace
id|alloc-&gt;ptr
op_assign
id|p
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
id|p
op_assign
(paren
id|p
op_plus
l_int|1
)paren
op_mod
id|alloc-&gt;max_voice
suffix:semicolon
)brace
r_if
c_cond
(paren
id|best
op_ge
l_int|0
)paren
id|p
op_assign
id|best
suffix:semicolon
id|alloc-&gt;ptr
op_assign
id|p
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|variable|guswave_operations
r_static
r_struct
id|synth_operations
id|guswave_operations
op_assign
(brace
l_string|&quot;GUS&quot;
comma
op_amp
id|gus_info
comma
l_int|0
comma
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_GUS
comma
id|guswave_open
comma
id|guswave_close
comma
id|guswave_ioctl
comma
id|guswave_kill_note
comma
id|guswave_start_note
comma
id|guswave_set_instr
comma
id|guswave_reset
comma
id|guswave_hw_control
comma
id|guswave_load_patch
comma
id|guswave_aftertouch
comma
id|guswave_controller
comma
id|guswave_panning
comma
id|guswave_volume_method
comma
id|guswave_bender
comma
id|guswave_alloc
comma
id|guswave_setup_voice
)brace
suffix:semicolon
r_static
r_void
DECL|function|set_input_volumes
id|set_input_volumes
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|mask
op_assign
l_int|0xff
op_amp
op_complement
l_int|0x06
suffix:semicolon
multiline_comment|/* Just line out enabled */
r_if
c_cond
(paren
id|have_gus_max
)paren
multiline_comment|/* Don&squot;t disturb GUS MAX */
r_return
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;   *    Enable channels having vol &gt; 10%&n;   *      Note! bit 0x01 means the line in DISABLED while 0x04 means&n;   *            the mic in ENABLED.&n;   */
r_if
c_cond
(paren
id|gus_line_vol
OG
l_int|10
)paren
id|mask
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|gus_mic_vol
OG
l_int|10
)paren
id|mask
op_or_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|recording_active
)paren
(brace
multiline_comment|/*&n;       *    Disable channel, if not selected for recording&n;       */
r_if
c_cond
(paren
op_logical_neg
(paren
id|gus_recmask
op_amp
id|SOUND_MASK_LINE
)paren
)paren
id|mask
op_or_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gus_recmask
op_amp
id|SOUND_MASK_MIC
)paren
)paren
id|mask
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
)brace
id|mix_image
op_and_assign
op_complement
l_int|0x07
suffix:semicolon
id|mix_image
op_or_assign
id|mask
op_amp
l_int|0x07
suffix:semicolon
id|outb
(paren
(paren
id|mix_image
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_int
DECL|function|gus_default_mixer_ioctl
id|gus_default_mixer_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
DECL|macro|MIX_DEVS
mdefine_line|#define MIX_DEVS&t;(SOUND_MASK_MIC|SOUND_MASK_LINE| &bslash;&n;&t;&t;&t; SOUND_MASK_SYNTH|SOUND_MASK_PCM)
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_eq
l_char|&squot;M&squot;
)paren
(brace
r_if
c_cond
(paren
id|_SIOC_DIR
(paren
id|cmd
)paren
op_amp
id|_SIOC_WRITE
)paren
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|0xff
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|gus_recmask
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|gus_recmask
op_and_assign
id|MIX_DEVS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gus_recmask
op_amp
(paren
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_LINE
)paren
)paren
)paren
id|gus_recmask
op_assign
id|SOUND_MASK_MIC
suffix:semicolon
multiline_comment|/* Note! Input volumes are updated during next open for recording */
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_recmask
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
(brace
r_int
id|vol
suffix:semicolon
id|vol
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|vol
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|vol
OL
l_int|0
)paren
id|vol
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol
OG
l_int|100
)paren
id|vol
op_assign
l_int|100
suffix:semicolon
id|gus_mic_vol
op_assign
id|vol
suffix:semicolon
id|set_input_volumes
(paren
)paren
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|vol
op_or
(paren
id|vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_LINE
suffix:colon
(brace
r_int
id|vol
suffix:semicolon
id|vol
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|vol
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|vol
OL
l_int|0
)paren
id|vol
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol
OG
l_int|100
)paren
id|vol
op_assign
l_int|100
suffix:semicolon
id|gus_line_vol
op_assign
id|vol
suffix:semicolon
id|set_input_volumes
(paren
)paren
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|vol
op_or
(paren
id|vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PCM
suffix:colon
id|gus_pcm_volume
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|gus_pcm_volume
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|gus_pcm_volume
OL
l_int|0
)paren
id|gus_pcm_volume
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gus_pcm_volume
OG
l_int|100
)paren
id|gus_pcm_volume
op_assign
l_int|100
suffix:semicolon
id|gus_audio_update_volume
(paren
)paren
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_pcm_volume
op_or
(paren
id|gus_pcm_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
(brace
r_int
id|voice
suffix:semicolon
id|gus_wave_volume
op_assign
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|gus_wave_volume
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|gus_wave_volume
OL
l_int|0
)paren
id|gus_wave_volume
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gus_wave_volume
OG
l_int|100
)paren
id|gus_wave_volume
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|active_device
op_eq
id|GUS_DEV_WAVE
)paren
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|nr_voices
suffix:semicolon
id|voice
op_increment
)paren
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
multiline_comment|/* Apply the new vol */
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_wave_volume
op_or
(paren
id|gus_wave_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|0xff
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Return parameters&n;&t;&t;&t;&t; */
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_recmask
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|MIX_DEVS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_LINE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_mic_vol
op_or
(paren
id|gus_mic_vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_LINE
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_line_vol
op_or
(paren
id|gus_line_vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PCM
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_pcm_volume
op_or
(paren
id|gus_pcm_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
r_return
(paren
op_star
(paren
r_int
op_star
)paren
id|arg
op_assign
id|gus_wave_volume
op_or
(paren
id|gus_wave_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|gus_mixer_operations
r_static
r_struct
id|mixer_operations
id|gus_mixer_operations
op_assign
(brace
l_string|&quot;GUS&quot;
comma
l_string|&quot;Gravis Ultrasound&quot;
comma
id|gus_default_mixer_ioctl
)brace
suffix:semicolon
r_static
r_void
DECL|function|gus_default_mixer_init
id|gus_default_mixer_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|num_mixers
OL
id|MAX_MIXER_DEV
)paren
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Don&squot;t install if there is another&n;&t;&t;&t;&t;&t; * mixer&n;&t;&t;&t;&t;&t; */
id|mixer_devs
(braket
id|num_mixers
op_increment
)braket
op_assign
op_amp
id|gus_mixer_operations
suffix:semicolon
r_if
c_cond
(paren
id|have_gus_max
)paren
(brace
multiline_comment|/*&n; *  Enable all mixer channels on the GF1 side. Otherwise recording will&n; *  not be possible using GUS MAX.&n; */
id|mix_image
op_and_assign
op_complement
l_int|0x07
suffix:semicolon
id|mix_image
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* All channels enabled */
id|outb
(paren
(paren
id|mix_image
)paren
comma
id|u_Mixer
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|gus_wave_init
id|gus_wave_init
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
r_char
op_star
id|model_num
op_assign
l_string|&quot;2.4&quot;
suffix:semicolon
r_char
id|tmp
(braket
l_int|64
)braket
comma
id|tmp2
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|gus_type
op_assign
l_int|0x24
suffix:semicolon
multiline_comment|/* 2.4 */
r_int
id|irq
op_assign
id|hw_config-&gt;irq
comma
id|dma
op_assign
id|hw_config-&gt;dma
comma
id|dma2
op_assign
id|hw_config-&gt;dma2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gus_pnp_flag
)paren
r_if
c_cond
(paren
id|irq
template_param
l_int|15
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR! Invalid IRQ#%d. GUS Disabled&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma
template_param
l_int|7
op_logical_or
id|dma
op_eq
l_int|4
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR! Invalid DMA#%d. GUS Disabled&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gus_irq
op_assign
id|irq
suffix:semicolon
id|gus_dma
op_assign
id|dma
suffix:semicolon
id|gus_dma2
op_assign
id|dma2
suffix:semicolon
r_if
c_cond
(paren
id|gus_dma2
op_eq
op_minus
l_int|1
)paren
id|gus_dma2
op_assign
id|dma
suffix:semicolon
multiline_comment|/*&n;     * Try to identify the GUS model.&n;     *&n;     *  Versions &lt; 3.6 don&squot;t have the digital ASIC. Try to probe it first.&n;   */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|outb
(paren
(paren
l_int|0x20
)paren
comma
id|gus_base
op_plus
l_int|0x0f
)paren
suffix:semicolon
id|val
op_assign
id|inb
(paren
id|gus_base
op_plus
l_int|0x0f
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_pnp_flag
op_logical_or
(paren
id|val
op_ne
l_int|0xff
op_logical_and
(paren
id|val
op_amp
l_int|0x06
)paren
)paren
)paren
multiline_comment|/* Should be 0x02?? */
(brace
r_int
id|ad_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gus_pnp_flag
)paren
id|ad_flags
op_assign
l_int|0x12345678
suffix:semicolon
multiline_comment|/* Interwave &quot;magic&quot; */
multiline_comment|/*&n;         * It has the digital ASIC so the card is at least v3.4.&n;         * Next try to detect the true model.&n;       */
r_if
c_cond
(paren
id|gus_pnp_flag
)paren
multiline_comment|/* Hack hack hack */
id|val
op_assign
l_int|10
suffix:semicolon
r_else
id|val
op_assign
id|inb
(paren
id|u_MixSelect
)paren
suffix:semicolon
multiline_comment|/*&n;         * Value 255 means pre-3.7 which don&squot;t have mixer.&n;         * Values 5 thru 9 mean v3.7 which has a ICS2101 mixer.&n;         * 10 and above is GUS MAX which has the CS4231 codec/mixer.&n;         *&n;       */
r_if
c_cond
(paren
id|val
op_eq
l_int|255
op_logical_or
id|val
OL
l_int|5
)paren
(brace
id|model_num
op_assign
l_string|&quot;3.4&quot;
suffix:semicolon
id|gus_type
op_assign
l_int|0x34
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|val
OL
l_int|10
)paren
(brace
id|model_num
op_assign
l_string|&quot;3.7&quot;
suffix:semicolon
id|gus_type
op_assign
l_int|0x37
suffix:semicolon
id|mixer_type
op_assign
id|ICS2101
suffix:semicolon
id|request_region
(paren
id|u_MixSelect
comma
l_int|1
comma
l_string|&quot;GUS mixer&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|model_num
op_assign
l_string|&quot;MAX&quot;
suffix:semicolon
id|gus_type
op_assign
l_int|0x40
suffix:semicolon
id|mixer_type
op_assign
id|CS4231
suffix:semicolon
macro_line|#ifdef CONFIG_GUSMAX
(brace
r_int
r_char
id|max_config
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* Codec enable */
r_if
c_cond
(paren
id|gus_dma2
op_eq
op_minus
l_int|1
)paren
id|gus_dma2
op_assign
id|gus_dma
suffix:semicolon
r_if
c_cond
(paren
id|gus_dma
OG
l_int|3
)paren
id|max_config
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* 16 bit capture DMA */
r_if
c_cond
(paren
id|gus_dma2
OG
l_int|3
)paren
id|max_config
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* 16 bit playback DMA */
id|max_config
op_or_assign
(paren
id|gus_base
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
suffix:semicolon
multiline_comment|/* Extract the X from 2X0 */
id|outb
(paren
(paren
id|max_config
)paren
comma
id|gus_base
op_plus
l_int|0x106
)paren
suffix:semicolon
multiline_comment|/* UltraMax control */
)brace
r_if
c_cond
(paren
id|ad1848_detect
(paren
id|gus_base
op_plus
l_int|0x10c
comma
op_amp
id|ad_flags
comma
id|hw_config-&gt;osp
)paren
)paren
(brace
r_char
op_star
id|name
op_assign
l_string|&quot;GUS MAX&quot;
suffix:semicolon
r_int
id|old_num_mixers
op_assign
id|num_mixers
suffix:semicolon
r_if
c_cond
(paren
id|gus_pnp_flag
)paren
id|name
op_assign
l_string|&quot;GUS PnP&quot;
suffix:semicolon
id|gus_mic_vol
op_assign
id|gus_line_vol
op_assign
id|gus_pcm_volume
op_assign
l_int|100
suffix:semicolon
id|gus_wave_volume
op_assign
l_int|90
suffix:semicolon
id|have_gus_max
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hw_config-&gt;name
)paren
id|name
op_assign
id|hw_config-&gt;name
suffix:semicolon
id|ad1848_init
(paren
id|name
comma
id|gus_base
op_plus
l_int|0x10c
comma
op_minus
id|irq
comma
id|gus_dma2
comma
multiline_comment|/* Playback DMA */
id|gus_dma
comma
multiline_comment|/* Capture DMA */
l_int|1
comma
multiline_comment|/* Share DMA channels with GF1 */
id|hw_config-&gt;osp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_mixers
OG
id|old_num_mixers
)paren
(brace
multiline_comment|/* GUS has it&squot;s own mixer map */
id|AD1848_REROUTE
(paren
id|SOUND_MIXER_LINE1
comma
id|SOUND_MIXER_SYNTH
)paren
suffix:semicolon
id|AD1848_REROUTE
(paren
id|SOUND_MIXER_LINE2
comma
id|SOUND_MIXER_CD
)paren
suffix:semicolon
id|AD1848_REROUTE
(paren
id|SOUND_MIXER_LINE3
comma
id|SOUND_MIXER_LINE
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
(paren
l_string|&quot;[Where&squot;s the CS4231?]&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
(paren
l_string|&quot;&bslash;n&bslash;n&bslash;nGUS MAX support was not compiled in!!!&bslash;n&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
multiline_comment|/*&n;         * ASIC not detected so the card must be 2.2 or 2.4.&n;         * There could still be the 16-bit/mixer daughter card.&n;       */
)brace
r_if
c_cond
(paren
id|hw_config-&gt;name
)paren
(brace
id|strncpy
(paren
id|tmp
comma
id|hw_config-&gt;name
comma
l_int|45
)paren
suffix:semicolon
id|tmp
(braket
l_int|45
)braket
op_assign
l_int|0
suffix:semicolon
id|sprintf
(paren
id|tmp2
comma
l_string|&quot;%s (%dk)&quot;
comma
id|tmp
comma
(paren
r_int
)paren
id|gus_mem_size
op_div
l_int|1024
)paren
suffix:semicolon
id|tmp2
(braket
r_sizeof
(paren
id|tmp2
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gus_pnp_flag
)paren
(brace
id|sprintf
(paren
id|tmp2
comma
l_string|&quot;Gravis UltraSound PnP (%dk)&quot;
comma
(paren
r_int
)paren
id|gus_mem_size
op_div
l_int|1024
)paren
suffix:semicolon
)brace
r_else
id|sprintf
(paren
id|tmp2
comma
l_string|&quot;Gravis UltraSound %s (%dk)&quot;
comma
id|model_num
comma
(paren
r_int
)paren
id|gus_mem_size
op_div
l_int|1024
)paren
suffix:semicolon
id|samples
op_assign
(paren
r_struct
id|patch_info
op_star
)paren
(paren
id|sound_mem_blocks
(braket
id|sound_nblocks
)braket
op_assign
id|vmalloc
(paren
(paren
id|MAX_SAMPLE
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|samples
)paren
)paren
)paren
suffix:semicolon
id|sound_mem_sizes
(braket
id|sound_nblocks
)braket
op_assign
(paren
id|MAX_SAMPLE
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|samples
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sound_nblocks
OL
l_int|1024
)paren
id|sound_nblocks
op_increment
suffix:semicolon
suffix:semicolon
r_if
c_cond
(paren
id|samples
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: Cant allocate memory for instrument tables&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|conf_printf
(paren
id|tmp2
comma
id|hw_config
)paren
suffix:semicolon
id|tmp2
(braket
r_sizeof
(paren
id|gus_info.name
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|strcpy
(paren
id|gus_info.name
comma
id|tmp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_synths
op_ge
id|MAX_SYNTH_DEV
)paren
id|printk
(paren
l_string|&quot;GUS Error: Too many synthesizers&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|voice_alloc
op_assign
op_amp
id|guswave_operations.alloc
suffix:semicolon
r_if
c_cond
(paren
id|iw_mode
)paren
id|guswave_operations.id
op_assign
l_string|&quot;IWAVE&quot;
suffix:semicolon
id|synth_devs
(braket
id|num_synths
op_increment
)braket
op_assign
op_amp
id|guswave_operations
suffix:semicolon
id|sequencer_init
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SEQUENCER
id|gus_tmr_install
(paren
id|gus_base
op_plus
l_int|8
)paren
suffix:semicolon
macro_line|#endif
)brace
id|reset_sample_memory
(paren
)paren
suffix:semicolon
id|gus_initialize
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_mem_size
OG
l_int|0
)paren
r_if
c_cond
(paren
id|num_audiodevs
OL
id|MAX_AUDIO_DEV
)paren
(brace
r_if
c_cond
(paren
(paren
id|gus_devnum
op_assign
id|sound_install_audiodrv
(paren
id|AUDIO_DRIVER_VERSION
comma
l_string|&quot;Ultrasound&quot;
comma
op_amp
id|gus_audio_driver
comma
r_sizeof
(paren
r_struct
id|audio_driver
)paren
comma
id|NEEDS_RESTART
op_or
(paren
(paren
op_logical_neg
id|iw_mode
op_logical_and
id|dma2
op_ne
id|dma
op_logical_and
id|dma2
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|DMA_DUPLEX
suffix:colon
l_int|0
)paren
comma
id|AFMT_U8
op_or
id|AFMT_S16_LE
comma
l_int|NULL
comma
id|dma
comma
id|dma2
)paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|min_fragment
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* 512k */
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|max_fragment
op_assign
l_int|11
suffix:semicolon
multiline_comment|/* 8k (must match size of bounce_buf */
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|mixer_dev
op_assign
id|num_mixers
suffix:semicolon
multiline_comment|/* Next mixer# */
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|DMA_HARDSTOP
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;GUS: Too many audio devices available&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     *  Mixer dependent initialization.&n;   */
r_switch
c_cond
(paren
id|mixer_type
)paren
(brace
r_case
id|ICS2101
suffix:colon
id|gus_mic_vol
op_assign
id|gus_line_vol
op_assign
id|gus_pcm_volume
op_assign
l_int|100
suffix:semicolon
id|gus_wave_volume
op_assign
l_int|90
suffix:semicolon
id|request_region
(paren
id|u_MixSelect
comma
l_int|1
comma
l_string|&quot;GUS mixer&quot;
)paren
suffix:semicolon
id|ics2101_mixer_init
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|CS4231
suffix:colon
multiline_comment|/* Initialized elsewhere (ad1848.c) */
r_default
suffix:colon
id|gus_default_mixer_init
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_void
DECL|function|gus_wave_unload
id|gus_wave_unload
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_GUSMAX
r_if
c_cond
(paren
id|have_gus_max
)paren
(brace
id|ad1848_unload
(paren
id|gus_base
op_plus
l_int|0x10c
comma
op_minus
id|gus_irq
comma
id|gus_dma2
comma
multiline_comment|/* Playback DMA */
id|gus_dma
comma
multiline_comment|/* Capture DMA */
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Share DMA channels with GF1 */
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mixer_type
op_eq
id|ICS2101
)paren
(brace
id|release_region
(paren
id|u_MixSelect
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|do_loop_irq
id|do_loop_irq
(paren
r_int
id|voice
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|mode
comma
id|parm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|tmp
op_assign
id|gus_read8
(paren
l_int|0x00
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Disable wave IRQ for this_one voice&n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x00
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x03
)paren
multiline_comment|/* Voice stopped */
id|voice_alloc-&gt;map
(braket
id|voice
)braket
op_assign
l_int|0
suffix:semicolon
id|mode
op_assign
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
l_int|0
suffix:semicolon
id|parm
op_assign
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_parm
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|LMODE_FINISH
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Final loop finished, shoot volume down&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
)paren
OL
l_int|100
)paren
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t; * Get current volume&n;&t;&t;&t;&t;&t;&t;&t; */
(brace
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|gus_ramp_range
(paren
l_int|65
comma
l_int|4065
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|0
comma
l_int|63
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Fastest possible rate&n;&t;&t;&t;&t; */
id|gus_rampon
(paren
l_int|0x20
op_or
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Ramp down, once, irq&n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_HALT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMODE_PCM_STOP
suffix:colon
id|pcm_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Signal to the play_next_pcm_block routine */
r_case
id|LMODE_PCM
suffix:colon
(brace
id|pcm_qlen
op_decrement
suffix:semicolon
id|pcm_head
op_assign
(paren
id|pcm_head
op_plus
l_int|1
)paren
op_mod
id|pcm_nblk
suffix:semicolon
r_if
c_cond
(paren
id|pcm_qlen
op_logical_and
id|pcm_active
)paren
(brace
id|play_next_pcm_block
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Underrun. Just stop the voice */
id|gus_select_voice
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Left channel */
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Right channel */
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|pcm_active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the queue was full before this interrupt, the DMA transfer was&n;&t; * suspended. Let it continue now.&n;&t; */
r_if
c_cond
(paren
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;qlen
OG
l_int|0
)paren
id|DMAbuf_outputintr
(paren
id|gus_devnum
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_volume_irq
id|do_volume_irq
(paren
r_int
id|voice
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|mode
comma
id|parm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|tmp
op_assign
id|gus_read8
(paren
l_int|0x0d
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Disable volume ramp IRQ&n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x0d
comma
id|tmp
)paren
suffix:semicolon
id|mode
op_assign
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
l_int|0
suffix:semicolon
id|parm
op_assign
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_parm
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|VMODE_HALT
suffix:colon
multiline_comment|/* Decay phase finished */
r_if
c_cond
(paren
id|iw_mode
)paren
id|gus_write8
(paren
l_int|0x15
comma
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* Set voice deactivate bit of SMSI */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VMODE_ENVELOPE
suffix:colon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VMODE_START_NOTE
suffix:colon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|guswave_start_note2
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|note_pending
comma
id|voices
(braket
id|voice
)braket
dot
id|volume_pending
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|kill_pending
)paren
id|guswave_kill_note
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|note_pending
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_ge
l_int|0
)paren
(brace
id|guswave_set_instr
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
)brace
r_void
DECL|function|gus_voice_irq
id|gus_voice_irq
(paren
r_void
)paren
(brace
r_int
r_int
id|wave_ignore
op_assign
l_int|0
comma
id|volume_ignore
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|voice_bit
suffix:semicolon
r_int
r_char
id|src
comma
id|voice
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|src
op_assign
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Get source info&n;&t;&t;&t;&t; */
id|voice
op_assign
id|src
op_amp
l_int|0x1f
suffix:semicolon
id|src
op_and_assign
l_int|0xc0
suffix:semicolon
r_if
c_cond
(paren
id|src
op_eq
(paren
l_int|0x80
op_or
l_int|0x40
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * No interrupt&n;&t;&t;&t;&t; */
id|voice_bit
op_assign
l_int|1
op_lshift
id|voice
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|src
op_amp
l_int|0x80
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Wave IRQ pending&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|wave_ignore
op_amp
id|voice_bit
)paren
op_logical_and
(paren
r_int
)paren
id|voice
OL
id|nr_voices
)paren
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   * Not done&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   * yet&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
(brace
id|wave_ignore
op_or_assign
id|voice_bit
suffix:semicolon
id|do_loop_irq
(paren
id|voice
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|src
op_amp
l_int|0x40
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Volume IRQ pending&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|volume_ignore
op_amp
id|voice_bit
)paren
op_logical_and
(paren
r_int
)paren
id|voice
OL
id|nr_voices
)paren
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   * Not done&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   * yet&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
(brace
id|volume_ignore
op_or_assign
id|voice_bit
suffix:semicolon
id|do_volume_irq
(paren
id|voice
)paren
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|guswave_dma_irq
id|guswave_dma_irq
(paren
r_void
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|status
op_assign
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* Get DMA IRQ Status */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
multiline_comment|/* DMA interrupt pending */
r_switch
c_cond
(paren
id|active_device
)paren
(brace
r_case
id|GUS_DEV_WAVE
suffix:colon
r_if
c_cond
(paren
(paren
id|dram_sleep_flag.opts
op_amp
id|WK_SLEEP
)paren
)paren
(brace
id|dram_sleep_flag.opts
op_assign
id|WK_WAKEUP
suffix:semicolon
id|wake_up
(paren
op_amp
id|dram_sleeper
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GUS_DEV_PCM_CONTINUE
suffix:colon
multiline_comment|/* Left channel data transferred */
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable GF1 DMA */
id|gus_transfer_output_block
(paren
id|pcm_current_dev
comma
id|pcm_current_buf
comma
id|pcm_current_count
comma
id|pcm_current_intrflag
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GUS_DEV_PCM_DONE
suffix:colon
multiline_comment|/* Right or mono channel data transferred */
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable GF1 DMA */
r_if
c_cond
(paren
id|pcm_qlen
OL
id|pcm_nblk
)paren
(brace
id|dma_active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gus_busy
)paren
(brace
r_if
c_cond
(paren
id|audio_devs
(braket
id|gus_devnum
)braket
op_member_access_from_pointer
id|dmap_out-&gt;qlen
OG
l_int|0
)paren
id|DMAbuf_outputintr
(paren
id|gus_devnum
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|status
op_assign
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Get Sampling IRQ Status&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Sampling Irq pending&n;&t;&t;&t;&t; */
(brace
id|DMAbuf_inputintr
(paren
id|gus_devnum
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SEQUENCER
multiline_comment|/*&n; * Timer stuff&n; */
DECL|variable|select_addr
DECL|variable|data_addr
r_static
r_volatile
r_int
id|select_addr
comma
id|data_addr
suffix:semicolon
DECL|variable|curr_timer
r_static
r_volatile
r_int
id|curr_timer
op_assign
l_int|0
suffix:semicolon
r_void
DECL|function|gus_timer_command
id|gus_timer_command
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|addr
op_amp
l_int|0xff
)paren
)paren
comma
id|select_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|inb
(paren
id|select_addr
)paren
suffix:semicolon
id|outb
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|val
op_amp
l_int|0xff
)paren
)paren
comma
id|data_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|inb
(paren
id|select_addr
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|arm_timer
id|arm_timer
(paren
r_int
id|timer
comma
r_int
r_int
id|interval
)paren
(brace
id|curr_timer
op_assign
id|timer
suffix:semicolon
r_if
c_cond
(paren
id|timer
op_eq
l_int|1
)paren
(brace
id|gus_write8
(paren
l_int|0x46
comma
l_int|256
op_minus
id|interval
)paren
suffix:semicolon
multiline_comment|/* Set counter for timer 1 */
id|gus_write8
(paren
l_int|0x45
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* Enable timer 1 IRQ */
id|gus_timer_command
(paren
l_int|0x04
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Start timer 1 */
)brace
r_else
(brace
id|gus_write8
(paren
l_int|0x47
comma
l_int|256
op_minus
id|interval
)paren
suffix:semicolon
multiline_comment|/* Set counter for timer 2 */
id|gus_write8
(paren
l_int|0x45
comma
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* Enable timer 2 IRQ */
id|gus_timer_command
(paren
l_int|0x04
comma
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* Start timer 2 */
)brace
id|gus_timer_enabled
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|gus_tmr_start
id|gus_tmr_start
(paren
r_int
id|dev
comma
r_int
r_int
id|usecs_per_tick
)paren
(brace
r_int
id|timer_no
comma
id|resolution
suffix:semicolon
r_int
id|divisor
suffix:semicolon
r_if
c_cond
(paren
id|usecs_per_tick
OG
(paren
l_int|256
op_star
l_int|80
)paren
)paren
(brace
id|timer_no
op_assign
l_int|2
suffix:semicolon
id|resolution
op_assign
l_int|320
suffix:semicolon
multiline_comment|/* usec */
)brace
r_else
(brace
id|timer_no
op_assign
l_int|1
suffix:semicolon
id|resolution
op_assign
l_int|80
suffix:semicolon
multiline_comment|/* usec */
)brace
id|divisor
op_assign
(paren
id|usecs_per_tick
op_plus
(paren
id|resolution
op_div
l_int|2
)paren
)paren
op_div
id|resolution
suffix:semicolon
id|arm_timer
(paren
id|timer_no
comma
id|divisor
)paren
suffix:semicolon
r_return
id|divisor
op_star
id|resolution
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_tmr_disable
id|gus_tmr_disable
(paren
r_int
id|dev
)paren
(brace
id|gus_write8
(paren
l_int|0x45
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable both timers */
id|gus_timer_enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_tmr_restart
id|gus_tmr_restart
(paren
r_int
id|dev
)paren
(brace
r_if
c_cond
(paren
id|curr_timer
op_eq
l_int|1
)paren
id|gus_write8
(paren
l_int|0x45
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* Start timer 1 again */
r_else
id|gus_write8
(paren
l_int|0x45
comma
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* Start timer 2 again */
id|gus_timer_enabled
op_assign
l_int|1
suffix:semicolon
)brace
DECL|variable|gus_tmr
r_static
r_struct
id|sound_lowlev_timer
id|gus_tmr
op_assign
(brace
l_int|0
comma
l_int|1
comma
id|gus_tmr_start
comma
id|gus_tmr_disable
comma
id|gus_tmr_restart
)brace
suffix:semicolon
r_static
r_void
DECL|function|gus_tmr_install
id|gus_tmr_install
(paren
r_int
id|io_base
)paren
(brace
r_struct
id|sound_lowlev_timer
op_star
id|tmr
suffix:semicolon
id|select_addr
op_assign
id|io_base
suffix:semicolon
id|data_addr
op_assign
id|io_base
op_plus
l_int|1
suffix:semicolon
id|tmr
op_assign
op_amp
id|gus_tmr
suffix:semicolon
macro_line|#ifdef THIS_GETS_FIXED
id|sound_timer_init
(paren
op_amp
id|gus_tmr
comma
l_string|&quot;GUS&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
macro_line|#endif
eof
