multiline_comment|/* &n; * sound/gus_wave.c&n; * &n; * Driver for the Gravis UltraSound wave table synth.&n; * &n; * Copyright by Hannu Savolainen 1993&n; * &n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions are&n; * met: 1. Redistributions of source code must retain the above copyright&n; * notice, this list of conditions and the following disclaimer. 2.&n; * Redistributions in binary form must reproduce the above copyright notice,&n; * this list of conditions and the following disclaimer in the documentation&n; * and/or other materials provided with the distribution.&n; * &n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND ANY&n; * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED&n; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER&n; * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; * &n; */
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &lt;linux/ultrasound.h&gt;
macro_line|#include &quot;gus_hw.h&quot;
macro_line|#if defined(CONFIGURE_SOUNDCARD) &amp;&amp; !defined(EXCLUDE_GUS)
DECL|macro|MAX_SAMPLE
mdefine_line|#define MAX_SAMPLE&t;128
DECL|macro|MAX_PATCH
mdefine_line|#define MAX_PATCH&t;256
DECL|struct|voice_info
r_struct
id|voice_info
(brace
DECL|member|orig_freq
r_int
r_int
id|orig_freq
suffix:semicolon
DECL|member|current_freq
r_int
r_int
id|current_freq
suffix:semicolon
DECL|member|mode
r_int
r_int
id|mode
suffix:semicolon
DECL|member|bender
r_int
id|bender
suffix:semicolon
DECL|member|bender_range
r_int
id|bender_range
suffix:semicolon
DECL|member|panning
r_int
id|panning
suffix:semicolon
DECL|member|midi_volume
r_int
id|midi_volume
suffix:semicolon
DECL|member|initial_volume
r_int
r_int
id|initial_volume
suffix:semicolon
DECL|member|current_volume
r_int
r_int
id|current_volume
suffix:semicolon
DECL|member|loop_irq_mode
DECL|member|loop_irq_parm
r_int
id|loop_irq_mode
comma
id|loop_irq_parm
suffix:semicolon
DECL|macro|LMODE_FINISH
mdefine_line|#define LMODE_FINISH&t;&t;1
DECL|macro|LMODE_PCM
mdefine_line|#define LMODE_PCM&t;&t;2
DECL|macro|LMODE_PCM_STOP
mdefine_line|#define LMODE_PCM_STOP&t;&t;3
DECL|member|volume_irq_mode
DECL|member|volume_irq_parm
r_int
id|volume_irq_mode
comma
id|volume_irq_parm
suffix:semicolon
DECL|macro|VMODE_HALT
mdefine_line|#define VMODE_HALT&t;&t;1
DECL|macro|VMODE_ENVELOPE
mdefine_line|#define VMODE_ENVELOPE&t;&t;2
DECL|macro|VMODE_START_NOTE
mdefine_line|#define VMODE_START_NOTE&t;3
DECL|member|env_phase
r_int
id|env_phase
suffix:semicolon
DECL|member|env_rate
r_int
r_char
id|env_rate
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|env_offset
r_int
r_char
id|env_offset
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* &n;     * Volume computation parameters for gus_adagio_vol()&n;     */
DECL|member|main_vol
DECL|member|expression_vol
DECL|member|patch_vol
r_int
id|main_vol
comma
id|expression_vol
comma
id|patch_vol
suffix:semicolon
multiline_comment|/* Variables for &quot;Ultraclick&quot; removal */
DECL|member|dev_pending
DECL|member|note_pending
DECL|member|volume_pending
DECL|member|sample_pending
r_int
id|dev_pending
comma
id|note_pending
comma
id|volume_pending
comma
id|sample_pending
suffix:semicolon
DECL|member|kill_pending
r_char
id|kill_pending
suffix:semicolon
DECL|member|offset_pending
r_int
id|offset_pending
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_int
id|gus_base
suffix:semicolon
r_extern
r_int
id|gus_irq
comma
id|gus_dma
suffix:semicolon
r_extern
r_char
op_star
id|snd_raw_buf
(braket
id|MAX_DSP_DEV
)braket
(braket
id|DSP_BUFFCOUNT
)braket
suffix:semicolon
r_extern
r_int
r_int
id|snd_raw_buf_phys
(braket
id|MAX_DSP_DEV
)braket
(braket
id|DSP_BUFFCOUNT
)braket
suffix:semicolon
r_extern
r_int
id|snd_raw_count
(braket
id|MAX_DSP_DEV
)braket
suffix:semicolon
DECL|variable|gus_mem_size
r_static
r_int
id|gus_mem_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|free_mem_ptr
r_static
r_int
id|free_mem_ptr
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_busy
r_static
r_int
id|gus_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_voices
r_static
r_int
id|nr_voices
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_devnum
r_static
r_int
id|gus_devnum
op_assign
l_int|0
suffix:semicolon
DECL|variable|volume_base
DECL|variable|volume_scale
DECL|variable|volume_method
r_static
r_int
id|volume_base
comma
id|volume_scale
comma
id|volume_method
suffix:semicolon
DECL|variable|gus_line_vol
DECL|variable|gus_mic_vol
r_static
r_int
id|gus_line_vol
op_assign
l_int|100
comma
id|gus_mic_vol
op_assign
l_int|0
suffix:semicolon
DECL|variable|gus_recmask
r_static
r_int
id|gus_recmask
op_assign
id|SOUND_MASK_MIC
suffix:semicolon
DECL|variable|recording_active
r_static
r_int
id|recording_active
op_assign
l_int|0
suffix:semicolon
DECL|macro|VOL_METHOD_ADAGIO
mdefine_line|#define VOL_METHOD_ADAGIO&t;1
DECL|variable|gus_wave_volume
r_int
id|gus_wave_volume
op_assign
l_int|60
suffix:semicolon
DECL|variable|gus_pcm_volume
r_int
id|gus_pcm_volume
op_assign
l_int|80
suffix:semicolon
DECL|variable|mix_image
r_static
r_int
r_char
id|mix_image
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* &n; * Current version of this driver doesn&squot;t allow synth and PCM functions&n; * at the same time. The active_device specifies the active driver&n; */
DECL|variable|active_device
r_static
r_int
id|active_device
op_assign
l_int|0
suffix:semicolon
DECL|macro|GUS_DEV_WAVE
mdefine_line|#define GUS_DEV_WAVE&t;&t;1&t;/* &n;&t;&t;&t;&t;&t; * * * Wave table synth   */
DECL|macro|GUS_DEV_PCM_DONE
mdefine_line|#define GUS_DEV_PCM_DONE&t;2&t;/* &n;&t;&t;&t;&t;&t; * * * PCM device, transfer done   */
DECL|macro|GUS_DEV_PCM_CONTINUE
mdefine_line|#define GUS_DEV_PCM_CONTINUE&t;3&t;/* &n;&t;&t;&t;&t;&t; * * * PCM device, transfer the&n;&t;&t;&t;&t;&t; * second * * * chn   */
DECL|variable|gus_sampling_speed
r_static
r_int
id|gus_sampling_speed
suffix:semicolon
DECL|variable|gus_sampling_channels
r_static
r_int
id|gus_sampling_channels
suffix:semicolon
DECL|variable|gus_sampling_bits
r_static
r_int
id|gus_sampling_bits
suffix:semicolon
id|DEFINE_WAIT_QUEUE
(paren
id|dram_sleeper
comma
id|dram_sleep_flag
)paren
suffix:semicolon
multiline_comment|/* &n; * Variables and buffers for PCM output&n; */
DECL|macro|MAX_PCM_BUFFERS
mdefine_line|#define MAX_PCM_BUFFERS&t;&t;(32*MAX_REALTIME_FACTOR)&t;/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * * * Don&squot;t&n;&t;&t;&t;&t;&t;&t;&t;&t; * * * change &n;&t;&t;&t;&t;&t;&t;&t;&t; * &n;&t;&t;&t;&t;&t;&t;&t;&t; */
DECL|variable|pcm_bsize
r_static
r_int
id|pcm_bsize
comma
multiline_comment|/* &n;&t;&t;&t;&t; * Current blocksize &n;&t;&t;&t;&t; */
DECL|variable|pcm_nblk
id|pcm_nblk
comma
multiline_comment|/* &n;&t;&t;&t;&t; * Current # of blocks &n;&t;&t;&t;&t; */
DECL|variable|pcm_banksize
id|pcm_banksize
suffix:semicolon
multiline_comment|/* &n;&n;&t;&t;&t;&t; * &n;&t;&t;&t;&t; * *  * * # bytes allocated for channels   */
DECL|variable|pcm_datasize
r_static
r_int
id|pcm_datasize
(braket
id|MAX_PCM_BUFFERS
)braket
suffix:semicolon
multiline_comment|/* &n;&n;&t;&t;&t;&t;&t;&t; * &n;&t;&t;&t;&t;&t;&t; * *  * * Actual # of bytes&n;&t;&t;&t;&t;&t;&t; * in blk  *  */
DECL|variable|pcm_head
DECL|variable|pcm_tail
DECL|variable|pcm_qlen
r_static
r_volatile
r_int
id|pcm_head
comma
id|pcm_tail
comma
id|pcm_qlen
suffix:semicolon
multiline_comment|/* &n;&n;&t;&t;&t;&t;&t;&t;&t; * &n;&t;&t;&t;&t;&t;&t;&t; * *  * * DRAM queue&n;&t;&t;&t;&t;&t;&t;&t; *  */
DECL|variable|pcm_active
r_static
r_volatile
r_int
id|pcm_active
suffix:semicolon
DECL|variable|pcm_opened
r_static
r_int
id|pcm_opened
op_assign
l_int|0
suffix:semicolon
DECL|variable|pcm_current_dev
r_static
r_int
id|pcm_current_dev
suffix:semicolon
DECL|variable|pcm_current_block
r_static
r_int
id|pcm_current_block
suffix:semicolon
DECL|variable|pcm_current_buf
r_static
r_int
r_int
id|pcm_current_buf
suffix:semicolon
DECL|variable|pcm_current_count
r_static
r_int
id|pcm_current_count
suffix:semicolon
DECL|variable|pcm_current_intrflag
r_static
r_int
id|pcm_current_intrflag
suffix:semicolon
DECL|variable|voices
r_struct
id|voice_info
id|voices
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|freq_div_table
r_static
r_int
id|freq_div_table
(braket
)braket
op_assign
(brace
l_int|44100
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 14 &n;&t;&t;&t;&t; */
l_int|41160
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 15 &n;&t;&t;&t;&t; */
l_int|38587
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 16 &n;&t;&t;&t;&t; */
l_int|36317
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 17 &n;&t;&t;&t;&t; */
l_int|34300
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 18 &n;&t;&t;&t;&t; */
l_int|32494
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 19 &n;&t;&t;&t;&t; */
l_int|30870
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 20 &n;&t;&t;&t;&t; */
l_int|29400
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 21 &n;&t;&t;&t;&t; */
l_int|28063
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 22 &n;&t;&t;&t;&t; */
l_int|26843
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 23 &n;&t;&t;&t;&t; */
l_int|25725
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 24 &n;&t;&t;&t;&t; */
l_int|24696
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 25 &n;&t;&t;&t;&t; */
l_int|23746
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 26 &n;&t;&t;&t;&t; */
l_int|22866
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 27 &n;&t;&t;&t;&t; */
l_int|22050
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 28 &n;&t;&t;&t;&t; */
l_int|21289
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 29 &n;&t;&t;&t;&t; */
l_int|20580
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 30 &n;&t;&t;&t;&t; */
l_int|19916
comma
multiline_comment|/* &n;&t;&t;&t;&t; * 31 &n;&t;&t;&t;&t; */
l_int|19293
multiline_comment|/* &n;&t;&t;&t;&t; * 32 &n;&t;&t;&t;&t; */
)brace
suffix:semicolon
DECL|variable|samples
r_static
r_struct
id|patch_info
op_star
id|samples
suffix:semicolon
DECL|variable|sample_ptrs
r_static
r_int
id|sample_ptrs
(braket
id|MAX_SAMPLE
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|sample_map
r_static
r_int
id|sample_map
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|free_sample
r_static
r_int
id|free_sample
suffix:semicolon
DECL|variable|patch_table
r_static
r_int
id|patch_table
(braket
id|MAX_PATCH
)braket
suffix:semicolon
DECL|variable|patch_map
r_static
r_int
id|patch_map
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|gus_info
r_static
r_struct
id|synth_info
id|gus_info
op_assign
(brace
l_string|&quot;Gravis UltraSound&quot;
comma
l_int|0
comma
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_GUS
comma
l_int|0
comma
l_int|16
comma
l_int|0
comma
id|MAX_PATCH
)brace
suffix:semicolon
r_static
r_void
id|gus_poke
(paren
r_int
id|addr
comma
r_int
r_char
id|data
)paren
suffix:semicolon
r_static
r_void
id|compute_and_set_volume
(paren
r_int
id|voice
comma
r_int
id|volume
comma
r_int
id|ramp_time
)paren
suffix:semicolon
r_extern
r_int
r_int
id|gus_adagio_vol
(paren
r_int
id|vel
comma
r_int
id|mainv
comma
r_int
id|xpn
comma
r_int
id|voicev
)paren
suffix:semicolon
r_static
r_void
id|compute_volume
(paren
r_int
id|voice
comma
r_int
id|volume
)paren
suffix:semicolon
r_static
r_void
id|do_volume_irq
(paren
r_int
id|voice
)paren
suffix:semicolon
r_static
r_void
id|set_input_volumes
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|INSTANT_RAMP
mdefine_line|#define&t;INSTANT_RAMP&t;&t;-1&t;/* &n;&t;&t;&t;&t;&t; * * * Dont use ramping   */
DECL|macro|FAST_RAMP
mdefine_line|#define FAST_RAMP&t;&t;0&t;/* &n;&t;&t;&t;&t;&t; * * * Fastest possible ramp   */
r_static
r_void
DECL|function|reset_sample_memory
id|reset_sample_memory
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
id|sample_ptrs
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|sample_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|patch_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|gus_poke
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Put silence here &n;&t;&t;&t;&t; */
id|gus_poke
(paren
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|free_mem_ptr
op_assign
l_int|2
suffix:semicolon
id|free_sample
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
id|patch_table
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|gus_delay
id|gus_delay
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|INB
(paren
id|u_DRAMIO
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_poke
id|gus_poke
(paren
r_int
id|addr
comma
r_int
r_char
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0x43
comma
id|u_Command
)paren
suffix:semicolon
id|OUTB
(paren
id|addr
op_amp
l_int|0xff
comma
id|u_DataLo
)paren
suffix:semicolon
id|OUTB
(paren
(paren
id|addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|u_DataHi
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0x44
comma
id|u_Command
)paren
suffix:semicolon
id|OUTB
(paren
(paren
id|addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|u_DataHi
)paren
suffix:semicolon
id|OUTB
(paren
id|data
comma
id|u_DRAMIO
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|gus_peek
id|gus_peek
(paren
r_int
id|addr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0x43
comma
id|u_Command
)paren
suffix:semicolon
id|OUTB
(paren
id|addr
op_amp
l_int|0xff
comma
id|u_DataLo
)paren
suffix:semicolon
id|OUTB
(paren
(paren
id|addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|u_DataHi
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0x44
comma
id|u_Command
)paren
suffix:semicolon
id|OUTB
(paren
(paren
id|addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|u_DataHi
)paren
suffix:semicolon
id|tmp
op_assign
id|INB
(paren
id|u_DRAMIO
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_void
DECL|function|gus_write8
id|gus_write8
(paren
r_int
id|reg
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
id|reg
comma
id|u_Command
)paren
suffix:semicolon
id|OUTB
(paren
(paren
r_int
r_char
)paren
(paren
id|data
op_amp
l_int|0xff
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|gus_read8
id|gus_read8
(paren
r_int
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
id|reg
op_or
l_int|0x80
comma
id|u_Command
)paren
suffix:semicolon
id|val
op_assign
id|INB
(paren
id|u_DataHi
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_int
r_char
DECL|function|gus_look8
id|gus_look8
(paren
r_int
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
id|reg
comma
id|u_Command
)paren
suffix:semicolon
id|val
op_assign
id|INB
(paren
id|u_DataHi
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_void
DECL|function|gus_write16
id|gus_write16
(paren
r_int
id|reg
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
id|reg
comma
id|u_Command
)paren
suffix:semicolon
id|OUTB
(paren
(paren
r_int
r_char
)paren
(paren
id|data
op_amp
l_int|0xff
)paren
comma
id|u_DataLo
)paren
suffix:semicolon
id|OUTB
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|u_DataHi
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|gus_read16
id|gus_read16
(paren
r_int
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|hi
comma
id|lo
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|OUTB
(paren
id|reg
op_or
l_int|0x80
comma
id|u_Command
)paren
suffix:semicolon
id|lo
op_assign
id|INB
(paren
id|u_DataLo
)paren
suffix:semicolon
id|hi
op_assign
id|INB
(paren
id|u_DataHi
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
(paren
id|hi
op_lshift
l_int|8
)paren
op_amp
l_int|0xff00
)paren
op_or
id|lo
suffix:semicolon
)brace
r_void
DECL|function|gus_write_addr
id|gus_write_addr
(paren
r_int
id|reg
comma
r_int
r_int
id|address
comma
r_int
id|is16bit
)paren
(brace
r_int
r_int
id|hold_address
suffix:semicolon
r_if
c_cond
(paren
id|is16bit
)paren
(brace
multiline_comment|/* &n;       * Special processing required for 16 bit patches&n;       */
id|hold_address
op_assign
id|address
suffix:semicolon
id|address
op_assign
id|address
op_rshift
l_int|1
suffix:semicolon
id|address
op_and_assign
l_int|0x0001ffffL
suffix:semicolon
id|address
op_or_assign
(paren
id|hold_address
op_amp
l_int|0x000c0000L
)paren
suffix:semicolon
)brace
id|gus_write16
(paren
id|reg
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|address
op_rshift
l_int|7
)paren
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
id|gus_write16
(paren
id|reg
op_plus
l_int|1
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|address
op_lshift
l_int|9
)paren
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_select_voice
id|gus_select_voice
(paren
r_int
id|voice
)paren
(brace
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
suffix:semicolon
id|OUTB
(paren
id|voice
comma
id|u_Voice
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_select_max_voices
id|gus_select_max_voices
(paren
r_int
id|nvoices
)paren
(brace
r_if
c_cond
(paren
id|nvoices
OL
l_int|14
)paren
id|nvoices
op_assign
l_int|14
suffix:semicolon
r_if
c_cond
(paren
id|nvoices
OG
l_int|32
)paren
id|nvoices
op_assign
l_int|32
suffix:semicolon
id|nr_voices
op_assign
id|nvoices
suffix:semicolon
id|gus_write8
(paren
l_int|0x0e
comma
(paren
id|nvoices
op_minus
l_int|1
)paren
op_or
l_int|0xc0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_on
id|gus_voice_on
(paren
r_int
r_int
id|mode
)paren
(brace
id|gus_write8
(paren
l_int|0x00
comma
(paren
r_int
r_char
)paren
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x00
comma
(paren
r_int
r_char
)paren
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_off
id|gus_voice_off
(paren
r_void
)paren
(brace
id|gus_write8
(paren
l_int|0x00
comma
id|gus_read8
(paren
l_int|0x00
)paren
op_or
l_int|0x03
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_mode
id|gus_voice_mode
(paren
r_int
r_int
id|m
)paren
(brace
r_int
r_char
id|mode
op_assign
(paren
r_int
r_char
)paren
(paren
id|m
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x00
comma
(paren
id|gus_read8
(paren
l_int|0x00
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Don&squot;t &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * start &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * or &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * stop&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * *&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * voice &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x00
comma
(paren
id|gus_read8
(paren
l_int|0x00
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_freq
id|gus_voice_freq
(paren
r_int
r_int
id|freq
)paren
(brace
r_int
r_int
id|divisor
op_assign
id|freq_div_table
(braket
id|nr_voices
op_minus
l_int|14
)braket
suffix:semicolon
r_int
r_int
id|fc
suffix:semicolon
id|fc
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|freq
op_lshift
l_int|9
)paren
op_plus
(paren
id|divisor
op_rshift
l_int|1
)paren
)paren
op_div
id|divisor
)paren
suffix:semicolon
id|fc
op_assign
id|fc
op_lshift
l_int|1
suffix:semicolon
id|gus_write16
(paren
l_int|0x01
comma
id|fc
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_volume
id|gus_voice_volume
(paren
r_int
r_int
id|vol
)paren
(brace
id|gus_write8
(paren
l_int|0x0d
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Stop ramp before setting volume &n;&t;&t;&t;&t; */
id|gus_write16
(paren
l_int|0x09
comma
(paren
r_int
r_int
)paren
(paren
id|vol
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_balance
id|gus_voice_balance
(paren
r_int
r_int
id|balance
)paren
(brace
id|gus_write8
(paren
l_int|0x0c
comma
(paren
r_int
r_char
)paren
(paren
id|balance
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_ramp_range
id|gus_ramp_range
(paren
r_int
r_int
id|low
comma
r_int
r_int
id|high
)paren
(brace
id|gus_write8
(paren
l_int|0x07
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|low
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x08
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|high
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_ramp_rate
id|gus_ramp_rate
(paren
r_int
r_int
id|scale
comma
r_int
r_int
id|rate
)paren
(brace
id|gus_write8
(paren
l_int|0x06
comma
(paren
r_int
r_char
)paren
(paren
(paren
(paren
id|scale
op_amp
l_int|0x03
)paren
op_lshift
l_int|6
)paren
op_or
(paren
id|rate
op_amp
l_int|0x3f
)paren
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_rampon
id|gus_rampon
(paren
r_int
r_int
id|m
)paren
(brace
r_int
r_char
id|mode
op_assign
(paren
r_int
r_char
)paren
(paren
id|m
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
id|mode
op_amp
l_int|0xfc
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
id|mode
op_amp
l_int|0xfc
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_ramp_mode
id|gus_ramp_mode
(paren
r_int
r_int
id|m
)paren
(brace
r_int
r_char
id|mode
op_assign
(paren
r_int
r_char
)paren
(paren
id|m
op_amp
l_int|0xff
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
(paren
id|gus_read8
(paren
l_int|0x0d
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Don&squot;t &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * start &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * or &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * stop&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * *&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * ramping &n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
(paren
id|gus_read8
(paren
l_int|0x0d
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
id|mode
op_amp
l_int|0xfc
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_rampoff
id|gus_rampoff
(paren
r_void
)paren
(brace
id|gus_write8
(paren
l_int|0x0d
comma
l_int|0x03
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_set_voice_pos
id|gus_set_voice_pos
(paren
r_int
id|voice
comma
r_int
id|position
)paren
(brace
r_int
id|sample_no
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sample_no
op_assign
id|sample_map
(braket
id|voice
)braket
)paren
op_ne
op_minus
l_int|1
)paren
r_if
c_cond
(paren
id|position
OL
id|samples
(braket
id|sample_no
)braket
dot
id|len
)paren
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
op_assign
id|position
suffix:semicolon
r_else
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample_no
)braket
op_plus
id|position
comma
id|samples
(braket
id|sample_no
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_init
id|gus_voice_init
(paren
r_int
id|voice
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_volume
(paren
l_int|0
)paren
suffix:semicolon
id|gus_write_addr
(paren
l_int|0x0a
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Set current position to 0 &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x00
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Voice off &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x0d
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramping off &n;&t;&t;&t;&t; */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_init2
id|gus_voice_init2
(paren
r_int
id|voice
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
op_assign
l_int|20000
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
l_int|20000
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender_range
op_assign
l_int|200
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_parm
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_parm
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|main_vol
op_assign
l_int|127
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|patch_vol
op_assign
l_int|127
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
op_assign
l_int|127
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|step_envelope
id|step_envelope
(paren
r_int
id|voice
)paren
(brace
r_int
id|vol
comma
id|prev_vol
comma
id|phase
suffix:semicolon
r_int
r_char
id|rate
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_SUSTAIN_ON
op_logical_and
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_eq
l_int|2
)paren
(brace
id|gus_rampoff
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Sustain &n;&t;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_ge
l_int|5
)paren
(brace
multiline_comment|/* &n;       * Shoot the voice off&n;       */
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prev_vol
op_assign
id|voices
(braket
id|voice
)braket
dot
id|current_volume
suffix:semicolon
id|gus_voice_volume
(paren
id|prev_vol
)paren
suffix:semicolon
id|phase
op_assign
op_increment
id|voices
(braket
id|voice
)braket
dot
id|env_phase
suffix:semicolon
id|compute_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
)paren
suffix:semicolon
id|vol
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_star
id|voices
(braket
id|voice
)braket
dot
id|env_offset
(braket
id|phase
)braket
op_div
l_int|255
suffix:semicolon
id|rate
op_assign
id|voices
(braket
id|voice
)braket
dot
id|env_rate
(braket
id|phase
)braket
suffix:semicolon
id|gus_write8
(paren
l_int|0x06
comma
id|rate
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramping rate &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_ENVELOPE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|vol
op_minus
id|prev_vol
)paren
op_div
l_int|64
)paren
op_eq
l_int|0
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t; * No significant volume change &n;&t;&t;&t;&t;&t; */
(brace
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Continue with the next phase &n;&t;&t;&t;&t; */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vol
OG
id|prev_vol
)paren
(brace
r_if
c_cond
(paren
id|vol
op_ge
(paren
l_int|4096
op_minus
l_int|64
)paren
)paren
id|vol
op_assign
l_int|4096
op_minus
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
l_int|0
comma
id|vol
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Increasing, irq &n;&t;&t;&t;&t; */
)brace
r_else
(brace
r_if
c_cond
(paren
id|vol
op_le
l_int|64
)paren
id|vol
op_assign
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
id|vol
comma
l_int|4030
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x60
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Decreasing, irq &n;&t;&t;&t;&t; */
)brace
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|vol
suffix:semicolon
)brace
r_static
r_void
DECL|function|init_envelope
id|init_envelope
(paren
r_int
id|voice
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_assign
op_minus
l_int|1
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
l_int|64
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|start_release
id|start_release
(paren
r_int
id|voice
)paren
(brace
r_if
c_cond
(paren
id|gus_read8
(paren
l_int|0x00
)paren
op_amp
l_int|0x03
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Voice already stopped &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Will be incremented by step_envelope &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Get current volume &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|mode
op_and_assign
op_complement
id|WAVE_SUSTAIN_ON
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_voice_fade
id|gus_voice_fade
(paren
r_int
id|voice
)paren
(brace
r_int
id|instr_no
op_assign
id|sample_map
(braket
id|voice
)braket
comma
id|is16bits
suffix:semicolon
r_if
c_cond
(paren
id|instr_no
template_param
id|MAX_SAMPLE
)paren
(brace
id|gus_write8
(paren
l_int|0x00
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Hard stop &n;&t;&t;&t;&t; */
r_return
suffix:semicolon
)brace
id|is16bits
op_assign
(paren
id|samples
(braket
id|instr_no
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * 8 or 16&n;&t;&t;&t;&t;&t;&t;&t;&t; * bit&n;&t;&t;&t;&t;&t;&t;&t;&t; * samples &n;&t;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
id|start_release
(paren
id|voice
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;   * Ramp the volume down but not too quickly.&n;   */
r_if
c_cond
(paren
(paren
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
)paren
OL
l_int|100
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Get current volume &n;&t;&t;&t;&t;&t; */
(brace
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gus_ramp_range
(paren
l_int|65
comma
l_int|4030
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|2
comma
l_int|4
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x40
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Down, once, irq &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_HALT
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_reset
id|gus_reset
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|gus_select_max_voices
(paren
l_int|24
)paren
suffix:semicolon
id|volume_base
op_assign
l_int|3071
suffix:semicolon
id|volume_scale
op_assign
l_int|4
suffix:semicolon
id|volume_method
op_assign
id|VOL_METHOD_ADAGIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|gus_voice_init
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Turn voice off &n;&t;&t;&t;&t; */
id|gus_voice_init2
(paren
id|i
)paren
suffix:semicolon
)brace
id|INB
(paren
id|u_Status
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Touch the status register &n;&t;&t;&t;&t; */
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear any pending DMA IRQs &n;&t;&t;&t;&t; */
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear any pending sample IRQs &n;&t;&t;&t;&t; */
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear pending IRQs &n;&t;&t;&t;&t; */
)brace
r_static
r_void
DECL|function|gus_initialize
id|gus_initialize
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|dma_image
comma
id|irq_image
comma
id|tmp
suffix:semicolon
r_static
r_int
r_char
id|gus_irq_map
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|3
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|5
comma
l_int|6
comma
l_int|0
comma
l_int|0
comma
l_int|7
)brace
suffix:semicolon
r_static
r_int
r_char
id|gus_dma_map
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|3
comma
l_int|4
comma
l_int|5
)brace
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Reset GF1 &n;&t;&t;&t;&t; */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Release Reset &n;&t;&t;&t;&t; */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;   * Clear all interrupts&n;   */
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * DMA control &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x45
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Timer control &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x49
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Sample control &n;&t;&t;&t;&t; */
id|gus_select_max_voices
(paren
l_int|24
)paren
suffix:semicolon
id|INB
(paren
id|u_Status
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Touch the status register &n;&t;&t;&t;&t; */
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear any pending DMA IRQs &n;&t;&t;&t;&t; */
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear any pending sample IRQs &n;&t;&t;&t;&t; */
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear pending IRQs &n;&t;&t;&t;&t; */
id|gus_reset
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Resets all voices &n;&t;&t;&t;&t; */
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear any pending DMA IRQs &n;&t;&t;&t;&t; */
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear any pending sample IRQs &n;&t;&t;&t;&t; */
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clear pending IRQs &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x4c
comma
l_int|7
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Master reset | DAC enable | IRQ enable &n;&t;&t;&t;&t; */
multiline_comment|/* &n;   * Set up for Digital ASIC&n;   */
id|OUTB
(paren
l_int|0x05
comma
id|gus_base
op_plus
l_int|0x0f
)paren
suffix:semicolon
id|mix_image
op_or_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable line out &n;&t;&t;&t;&t; */
id|OUTB
(paren
id|mix_image
comma
id|u_Mixer
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0x00
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
id|OUTB
(paren
l_int|0x00
comma
id|gus_base
op_plus
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* &n;   * Now set up the DMA and IRQ interface&n;   * &n;   * The GUS supports two IRQs and two DMAs.&n;   * &n;   * Just one DMA channel is used. This prevents simultaneous ADC and DAC.&n;   * Adding this support requires significant changes to the dmabuf.c, dsp.c&n;   * and audio.c also.&n;   */
id|irq_image
op_assign
l_int|0
suffix:semicolon
id|tmp
op_assign
id|gus_irq_map
(braket
id|gus_irq
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
id|printk
(paren
l_string|&quot;Warning! GUS IRQ not selected&bslash;n&quot;
)paren
suffix:semicolon
id|irq_image
op_or_assign
id|tmp
suffix:semicolon
id|irq_image
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Combine IRQ1 (GF1) and IRQ2 (Midi) &n;&t;&t;&t;&t; */
id|dma_image
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Combine DMA1 (DRAM) and IRQ2 (ADC) &n;&t;&t;&t;&t; */
id|tmp
op_assign
id|gus_dma_map
(braket
id|gus_dma
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
id|printk
(paren
l_string|&quot;Warning! GUS DMA not selected&bslash;n&quot;
)paren
suffix:semicolon
id|dma_image
op_or_assign
id|tmp
suffix:semicolon
multiline_comment|/* &n;   * For some reason the IRQ and DMA addresses must be written twice&n;   */
multiline_comment|/* &n;   * Doing it first time &n;   */
id|OUTB
(paren
id|mix_image
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Select DMA control &n;&t;&t;&t;&t; */
id|OUTB
(paren
id|dma_image
op_or
l_int|0x80
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Set DMA address &n;&t;&t;&t;&t;&t;&t; */
id|OUTB
(paren
id|mix_image
op_or
l_int|0x40
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Select IRQ control &n;&t;&t;&t;&t;&t; */
id|OUTB
(paren
id|irq_image
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Set IRQ address &n;&t;&t;&t;&t;&t; */
multiline_comment|/* &n;   * Doing it second time &n;   */
id|OUTB
(paren
id|mix_image
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Select DMA control &n;&t;&t;&t;&t; */
id|OUTB
(paren
id|dma_image
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Set DMA address &n;&t;&t;&t;&t;&t; */
id|OUTB
(paren
id|mix_image
op_or
l_int|0x40
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Select IRQ control &n;&t;&t;&t;&t;&t; */
id|OUTB
(paren
id|irq_image
comma
id|u_IRQDMAControl
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Set IRQ address &n;&t;&t;&t;&t;&t; */
id|gus_select_voice
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * This disables writes to IRQ/DMA reg &n;&t;&t;&t;&t; */
id|mix_image
op_and_assign
op_complement
l_int|0x02
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Enable line out &n;&t;&t;&t;&t; */
id|mix_image
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Enable IRQ &n;&t;&t;&t;&t; */
id|OUTB
(paren
id|mix_image
comma
id|u_Mixer
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Turn mixer channels on &n;&t;&t;&t;&t; * Note! Mic in is left off.&n;&t;&t;&t;&t; */
id|gus_select_voice
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * This disables writes to IRQ/DMA reg &n;&t;&t;&t;&t; */
id|gusintr
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Serve pending interrupts &n;&t;&t;&t;&t; */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_int
DECL|function|gus_wave_detect
id|gus_wave_detect
(paren
r_int
id|baseaddr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|loc
suffix:semicolon
id|gus_base
op_assign
id|baseaddr
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reset GF1 */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x4c
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Release Reset */
id|gus_delay
(paren
)paren
suffix:semicolon
id|gus_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* See if there is first block there.... */
id|gus_poke
(paren
l_int|0L
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
l_int|0L
)paren
op_ne
l_int|0xaa
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Now zero it out so that I can check for mirroring .. */
id|gus_poke
(paren
l_int|0L
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1L
suffix:semicolon
id|i
OL
l_int|1024L
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
comma
id|failed
suffix:semicolon
multiline_comment|/* check for mirroring ... */
r_if
c_cond
(paren
id|gus_peek
(paren
l_int|0L
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|loc
op_assign
id|i
op_lshift
l_int|10
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|loc
op_minus
l_int|1
comma
id|failed
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|loc
suffix:semicolon
id|n
op_increment
)paren
(brace
id|gus_poke
(paren
id|loc
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
id|loc
)paren
op_ne
l_int|0xaa
)paren
id|failed
op_assign
l_int|1
suffix:semicolon
id|gus_poke
(paren
id|loc
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_peek
(paren
id|loc
)paren
op_ne
l_int|0x55
)paren
id|failed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
r_break
suffix:semicolon
)brace
id|gus_mem_size
op_assign
id|i
op_lshift
l_int|10
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|guswave_ioctl
id|guswave_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDCTL_SYNTH_INFO
suffix:colon
id|gus_info.nr_voices
op_assign
id|nr_voices
suffix:semicolon
id|IOCTL_TO_USER
(paren
(paren
r_char
op_star
)paren
id|arg
comma
l_int|0
comma
op_amp
id|gus_info
comma
r_sizeof
(paren
id|gus_info
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_RESETSAMPLES
suffix:colon
id|reset_sample_memory
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SEQ_PERCMODE
suffix:colon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_SYNTH_MEMAVL
suffix:colon
r_return
id|gus_mem_size
op_minus
id|free_mem_ptr
op_minus
l_int|32
suffix:semicolon
r_default
suffix:colon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|guswave_set_instr
id|guswave_set_instr
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|instr_no
)paren
(brace
r_int
id|sample_no
suffix:semicolon
r_if
c_cond
(paren
id|instr_no
template_param
id|MAX_PATCH
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
id|instr_no
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sample_no
op_assign
id|patch_table
(braket
id|instr_no
)braket
suffix:semicolon
id|patch_map
(braket
id|voice
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sample_no
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Undefined patch %d for voice %d&bslash;n&quot;
comma
id|instr_no
comma
id|voice
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Patch not defined &n;&t;&t;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|sample_ptrs
(braket
id|sample_no
)braket
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Sample not loaded &n;&t;&t;&t;&t;&t; */
(brace
id|printk
(paren
l_string|&quot;GUS: Sample #%d not loaded for patch %d (voice %d)&bslash;n&quot;
comma
id|sample_no
comma
id|instr_no
comma
id|voice
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|sample_map
(braket
id|voice
)braket
op_assign
id|sample_no
suffix:semicolon
id|patch_map
(braket
id|voice
)braket
op_assign
id|instr_no
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
macro_line|#ifdef FUTURE_VERSION
DECL|function|guswave_kill_note
id|guswave_kill_note
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|note
comma
r_int
id|velocity
)paren
macro_line|#else
id|guswave_kill_note
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|velocity
)paren
macro_line|#endif
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
id|voices
(braket
id|voice
)braket
dot
id|kill_pending
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_fade
(paren
id|voice
)paren
suffix:semicolon
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_aftertouch
id|guswave_aftertouch
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|pressure
)paren
(brace
r_int
id|lo_limit
comma
id|hi_limit
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Currently disabled &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
op_logical_and
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_ne
l_int|2
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Don&squot;t mix with envelopes &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pressure
OL
l_int|32
)paren
(brace
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|compute_and_set_volume
(paren
id|voice
comma
l_int|255
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Back to original volume &n;&t;&t;&t;&t;&t;&t; */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hi_limit
op_assign
id|voices
(braket
id|voice
)braket
dot
id|current_volume
suffix:semicolon
id|lo_limit
op_assign
id|hi_limit
op_star
l_int|99
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|lo_limit
OL
l_int|65
)paren
id|lo_limit
op_assign
l_int|65
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi_limit
OG
(paren
l_int|4095
op_minus
l_int|65
)paren
)paren
(brace
id|hi_limit
op_assign
l_int|4095
op_minus
l_int|65
suffix:semicolon
id|gus_voice_volume
(paren
id|hi_limit
)paren
suffix:semicolon
)brace
id|gus_ramp_range
(paren
id|lo_limit
comma
id|hi_limit
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|3
comma
l_int|8
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x58
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Bidirectional, Down, Loop &n;&t;&t;&t;&t; */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_panning
id|guswave_panning
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|value
)paren
(brace
r_if
c_cond
(paren
id|voice
op_ge
l_int|0
op_logical_or
id|voice
OL
l_int|32
)paren
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
id|value
suffix:semicolon
)brace
r_static
r_void
DECL|function|compute_volume
id|compute_volume
(paren
r_int
id|voice
comma
r_int
id|volume
)paren
(brace
r_if
c_cond
(paren
id|volume
OL
l_int|128
)paren
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
op_assign
id|volume
suffix:semicolon
r_switch
c_cond
(paren
id|volume_method
)paren
(brace
r_case
id|VOL_METHOD_ADAGIO
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|gus_adagio_vol
(paren
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
comma
id|voices
(braket
id|voice
)braket
dot
id|main_vol
comma
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
comma
id|voices
(braket
id|voice
)braket
dot
id|patch_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|volume_base
op_plus
(paren
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
op_star
id|volume_scale
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
OG
l_int|4030
)paren
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
l_int|4030
suffix:semicolon
)brace
r_static
r_void
DECL|function|compute_and_set_volume
id|compute_and_set_volume
(paren
r_int
id|voice
comma
r_int
id|volume
comma
r_int
id|ramp_time
)paren
(brace
r_int
id|current
comma
id|target
comma
id|rate
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n; * CAUTION! Interrupts disabled. Enable them before returning&n; */
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|compute_volume
(paren
id|voice
comma
id|volume
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
suffix:semicolon
id|current
op_assign
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
suffix:semicolon
id|target
op_assign
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
suffix:semicolon
r_if
c_cond
(paren
id|ramp_time
op_eq
id|INSTANT_RAMP
)paren
(brace
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|target
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ramp_time
op_eq
id|FAST_RAMP
)paren
id|rate
op_assign
l_int|63
suffix:semicolon
r_else
id|rate
op_assign
l_int|16
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|0
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|target
op_minus
id|current
)paren
op_div
l_int|64
op_eq
l_int|0
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Too close &n;&t;&t;&t;&t;&t; */
(brace
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|target
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|target
OG
id|current
)paren
(brace
r_if
c_cond
(paren
id|target
OG
(paren
l_int|4095
op_minus
l_int|65
)paren
)paren
id|target
op_assign
l_int|4095
op_minus
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
id|current
comma
id|target
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramp up, once, no irq &n;&t;&t;&t;&t; */
)brace
r_else
(brace
r_if
c_cond
(paren
id|target
OL
l_int|65
)paren
id|target
op_assign
l_int|65
suffix:semicolon
id|gus_ramp_range
(paren
id|target
comma
id|current
)paren
suffix:semicolon
id|gus_rampon
(paren
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramp down, once, no irq &n;&t;&t;&t;&t; */
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dynamic_volume_change
id|dynamic_volume_change
(paren
r_int
id|voice
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|status
op_assign
id|gus_read8
(paren
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Voice status &n;&t;&t;&t;&t; */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x03
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Voice not started &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
)paren
(brace
id|compute_and_set_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;   * Voice is running and has envelopes.&n;   */
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|status
op_assign
id|gus_read8
(paren
l_int|0x0d
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramping status &n;&t;&t;&t;&t; */
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x03
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Sustain phase? &n;&t;&t;&t;&t; */
(brace
id|compute_and_set_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|env_phase
OL
l_int|0
)paren
r_return
suffix:semicolon
id|compute_volume
(paren
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
)paren
suffix:semicolon
macro_line|#if 0&t;&t;&t;&t;/* &n;&t;&t;&t;&t; * * * Is this really required   */
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Get current volume &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|env_phase
op_decrement
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|guswave_controller
id|guswave_controller
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|ctrl_num
comma
r_int
id|value
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|freq
suffix:semicolon
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl_num
)paren
(brace
r_case
id|CTRL_PITCH_BENDER
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_ne
id|VMODE_START_NOTE
)paren
(brace
id|freq
op_assign
id|compute_finetune
(paren
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
comma
id|value
comma
id|voices
(braket
id|voice
)braket
dot
id|bender_range
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
id|freq
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|freq
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CTRL_PITCH_BENDER_RANGE
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|bender_range
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef FUTURE_VERSION
r_case
id|CTL_EXPRESSION
suffix:colon
id|value
op_div_assign
l_int|128
suffix:semicolon
macro_line|#endif
r_case
id|CTRL_EXPRESSION
suffix:colon
id|volume_method
op_assign
id|VOL_METHOD_ADAGIO
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|expression_vol
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_ne
id|VMODE_START_NOTE
)paren
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef FUTURE_VERSION
r_case
id|CTL_PAN
suffix:colon
id|voices
(braket
id|voice
)braket
dot
id|panning
op_assign
(paren
id|value
op_star
l_int|2
)paren
op_minus
l_int|128
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTL_MAIN_VOLUME
suffix:colon
id|value
op_assign
(paren
id|value
op_star
l_int|100
)paren
op_div
l_int|16383
suffix:semicolon
macro_line|#endif
r_case
id|CTRL_MAIN_VOLUME
suffix:colon
id|volume_method
op_assign
id|VOL_METHOD_ADAGIO
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|main_vol
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_ne
id|VMODE_START_NOTE
)paren
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * Ignore &n;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|guswave_start_note2
id|guswave_start_note2
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|note_num
comma
r_int
id|volume
)paren
(brace
r_int
id|sample
comma
id|best_sample
comma
id|best_delta
comma
id|delta_freq
suffix:semicolon
r_int
id|is16bits
comma
id|samplep
comma
id|patch
comma
id|pan
suffix:semicolon
r_int
r_int
id|note_freq
comma
id|base_note
comma
id|freq
comma
id|flags
suffix:semicolon
r_int
r_char
id|mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|voice
template_param
l_int|31
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid voice&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|note_num
op_eq
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|midi_volume
op_assign
id|volume
suffix:semicolon
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|compute_and_set_volume
(paren
id|voice
comma
id|volume
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|patch
op_assign
id|patch_map
(braket
id|voice
)braket
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|samplep
op_assign
id|patch_table
(braket
id|patch
)braket
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|note_freq
op_assign
id|note_to_freq
(paren
id|note_num
)paren
suffix:semicolon
multiline_comment|/* &n;   * Find a sample within a patch so that the note_freq is between low_note&n;   * and high_note.&n;   */
id|sample
op_assign
op_minus
l_int|1
suffix:semicolon
id|best_sample
op_assign
id|samplep
suffix:semicolon
id|best_delta
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
id|samplep
op_ge
l_int|0
op_logical_and
id|sample
op_eq
op_minus
l_int|1
)paren
(brace
id|delta_freq
op_assign
id|note_freq
op_minus
id|samples
(braket
id|samplep
)braket
dot
id|base_note
suffix:semicolon
r_if
c_cond
(paren
id|delta_freq
OL
l_int|0
)paren
id|delta_freq
op_assign
op_minus
id|delta_freq
suffix:semicolon
r_if
c_cond
(paren
id|delta_freq
OL
id|best_delta
)paren
(brace
id|best_sample
op_assign
id|samplep
suffix:semicolon
id|best_delta
op_assign
id|delta_freq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|samples
(braket
id|samplep
)braket
dot
id|low_note
op_le
id|note_freq
op_logical_and
id|note_freq
op_le
id|samples
(braket
id|samplep
)braket
dot
id|high_note
)paren
id|sample
op_assign
id|samplep
suffix:semicolon
r_else
id|samplep
op_assign
id|samples
(braket
id|samplep
)braket
dot
id|key
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Follow link &n;&t;&t;&t;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|sample
op_eq
op_minus
l_int|1
)paren
id|sample
op_assign
id|best_sample
suffix:semicolon
r_if
c_cond
(paren
id|sample
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Patch %d not defined for note %d&bslash;n&quot;
comma
id|patch
comma
id|note_num
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Should play default patch ??? &n;&t;&t;&t;&t; */
)brace
id|is16bits
op_assign
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * 8 or 16&n;&t;&t;&t;&t;&t;&t;&t;&t; * bit&n;&t;&t;&t;&t;&t;&t;&t;&t; * samples &n;&t;&t;&t;&t;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|mode
op_assign
id|samples
(braket
id|sample
)braket
dot
id|mode
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|patch_vol
op_assign
id|samples
(braket
id|sample
)braket
dot
id|volume
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|voices
(braket
id|voice
)braket
dot
id|env_rate
(braket
id|i
)braket
op_assign
id|samples
(braket
id|sample
)braket
dot
id|env_rate
(braket
id|i
)braket
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|env_offset
(braket
id|i
)braket
op_assign
id|samples
(braket
id|sample
)braket
dot
id|env_offset
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|sample_map
(braket
id|voice
)braket
op_assign
id|sample
suffix:semicolon
id|base_note
op_assign
id|samples
(braket
id|sample
)braket
dot
id|base_note
op_div
l_int|100
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * To avoid overflows &n;&t;&t;&t;&t;&t;&t; */
id|note_freq
op_div_assign
l_int|100
suffix:semicolon
id|freq
op_assign
id|samples
(braket
id|sample
)braket
dot
id|base_freq
op_star
id|note_freq
op_div
id|base_note
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
op_assign
id|freq
suffix:semicolon
multiline_comment|/* &n;   * Since the pitch bender may have been set before playing the note, we&n;   * have to calculate the bending now.&n;   */
id|freq
op_assign
id|compute_finetune
(paren
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
comma
id|voices
(braket
id|voice
)braket
dot
id|bender
comma
id|voices
(braket
id|voice
)braket
dot
id|bender_range
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
id|freq
suffix:semicolon
id|pan
op_assign
(paren
id|samples
(braket
id|sample
)braket
dot
id|panning
op_plus
id|voices
(braket
id|voice
)braket
dot
id|panning
)paren
op_div
l_int|32
suffix:semicolon
id|pan
op_add_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|pan
OL
l_int|0
)paren
id|pan
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pan
OG
l_int|15
)paren
id|pan
op_assign
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_16_BITS
)paren
(brace
id|mode
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bits &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sample_ptrs
(braket
id|sample
)braket
op_rshift
l_int|18
)paren
op_ne
(paren
(paren
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|len
)paren
op_rshift
l_int|18
)paren
)paren
id|printk
(paren
l_string|&quot;GUS: Sample address error&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*************************************************************************&n;   *    CAUTION!        Interrupts disabled. Don&squot;t return before enabling&n;   *************************************************************************/
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_off
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * It may still be running &n;&t;&t;&t;&t; */
id|gus_rampoff
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
(brace
id|compute_volume
(paren
id|voice
comma
id|volume
)paren
suffix:semicolon
id|init_envelope
(paren
id|voice
)paren
suffix:semicolon
)brace
r_else
id|compute_and_set_volume
(paren
id|voice
comma
id|volume
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_LOOP_BACK
)paren
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|len
op_minus
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Sample&n;&t;&t;&t;&t;&t;&t;&t;&t; * start=end */
r_else
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* Sample start=begin */
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_LOOPING
)paren
(brace
id|mode
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Looping on &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_BIDIR_LOOP
)paren
id|mode
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Bidirectional looping on &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|samples
(braket
id|sample
)braket
dot
id|mode
op_amp
id|WAVE_LOOP_BACK
)paren
(brace
id|gus_write_addr
(paren
l_int|0x0a
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|loop_end
op_minus
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
comma
id|is16bits
)paren
suffix:semicolon
id|mode
op_or_assign
l_int|0x40
suffix:semicolon
)brace
id|gus_write_addr
(paren
l_int|0x02
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|loop_start
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Loop &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * start &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|gus_write_addr
(paren
l_int|0x04
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|loop_end
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Loop &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * end &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
)brace
r_else
(brace
id|mode
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Loop irq at the end &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
id|LMODE_FINISH
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t; * Ramp it down at&n;&t;&t;&t;&t;&t;&t;&t; * the * end &n;&t;&t;&t;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_parm
op_assign
l_int|1
suffix:semicolon
id|gus_write_addr
(paren
l_int|0x02
comma
id|sample_ptrs
(braket
id|sample
)braket
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * Loop start &n;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t; */
id|gus_write_addr
(paren
l_int|0x04
comma
id|sample_ptrs
(braket
id|sample
)braket
op_plus
id|samples
(braket
id|sample
)braket
dot
id|len
op_minus
l_int|1
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Loop &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * end &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
)brace
id|gus_voice_freq
(paren
id|freq
)paren
suffix:semicolon
id|gus_voice_balance
(paren
id|pan
)paren
suffix:semicolon
id|gus_voice_on
(paren
id|mode
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * * New guswave_start_note by Andrew J. Robinson attempts to minimize&n; * clicking  * when the note playing on the voice is changed.  It uses volume &n; * ramping. */
r_static
r_int
DECL|function|guswave_start_note
id|guswave_start_note
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|note_num
comma
r_int
id|volume
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|ret_val
op_assign
l_int|0
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|note_num
op_eq
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
id|voices
(braket
id|voice
)braket
dot
id|volume_pending
op_assign
id|volume
suffix:semicolon
r_else
id|ret_val
op_assign
id|guswave_start_note2
(paren
id|dev
comma
id|voice
comma
id|note_num
comma
id|volume
)paren
suffix:semicolon
)brace
r_else
(brace
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|mode
op_assign
id|gus_read8
(paren
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
l_int|0x20
)paren
id|gus_write8
(paren
l_int|0x00
comma
id|mode
op_amp
l_int|0xdf
)paren
suffix:semicolon
multiline_comment|/* No interrupt! */
id|voices
(braket
id|voice
)braket
dot
id|offset_pending
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|kill_pending
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
l_int|0
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_ge
l_int|0
)paren
(brace
id|guswave_set_instr
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
l_int|0x01
)paren
op_logical_or
(paren
(paren
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
)paren
OL
l_int|2065
)paren
)paren
(brace
id|ret_val
op_assign
id|guswave_start_note2
(paren
id|dev
comma
id|voice
comma
id|note_num
comma
id|volume
)paren
suffix:semicolon
)brace
r_else
(brace
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
op_assign
id|dev
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|note_pending
op_assign
id|note_num
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_pending
op_assign
id|volume
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_START_NOTE
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_ramp_range
(paren
l_int|2000
comma
l_int|4065
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|0
comma
l_int|63
)paren
suffix:semicolon
multiline_comment|/* Fastest possible rate */
id|gus_rampon
(paren
l_int|0x20
op_or
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Ramp down, once, irq */
)brace
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_reset
id|guswave_reset
(paren
r_int
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|gus_voice_init
(paren
id|i
)paren
suffix:semicolon
id|gus_voice_init2
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|guswave_open
id|guswave_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|gus_busy
)paren
r_return
id|RET_ERROR
(paren
id|EBUSY
)paren
suffix:semicolon
id|gus_initialize
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|DMAbuf_open_dma
(paren
id|gus_devnum
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
id|RESET_WAIT_QUEUE
(paren
id|dram_sleeper
comma
id|dram_sleep_flag
)paren
suffix:semicolon
id|gus_busy
op_assign
l_int|1
suffix:semicolon
id|active_device
op_assign
id|GUS_DEV_WAVE
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_close
id|guswave_close
(paren
r_int
id|dev
)paren
(brace
id|gus_busy
op_assign
l_int|0
suffix:semicolon
id|active_device
op_assign
l_int|0
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
id|DMAbuf_close_dma
(paren
id|gus_devnum
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|guswave_load_patch
id|guswave_load_patch
(paren
r_int
id|dev
comma
r_int
id|format
comma
id|snd_rw_buf
op_star
id|addr
comma
r_int
id|offs
comma
r_int
id|count
comma
r_int
id|pmgr_flag
)paren
(brace
r_struct
id|patch_info
id|patch
suffix:semicolon
r_int
id|instr
suffix:semicolon
r_int
id|sizeof_patch
suffix:semicolon
r_int
r_int
id|blk_size
comma
id|blk_end
comma
id|left
comma
id|src_offs
comma
id|target
suffix:semicolon
id|sizeof_patch
op_assign
(paren
r_int
)paren
op_amp
id|patch.data
(braket
l_int|0
)braket
op_minus
(paren
r_int
)paren
op_amp
id|patch
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * Size of&n;&t;&t;&t;&t;&t;&t;&t;&t; * the header&n;&t;&t;&t;&t;&t;&t;&t;&t; * * info &n;&t;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|format
op_ne
id|GUS_PATCH
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: Invalid patch format (key) 0x%x&bslash;n&quot;
comma
id|format
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
id|sizeof_patch
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: Patch header too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|count
op_sub_assign
id|sizeof_patch
suffix:semicolon
r_if
c_cond
(paren
id|free_sample
op_ge
id|MAX_SAMPLE
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Sample table full&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;   * Copy the header from user space but ignore the first bytes which have&n;   * been transferred already.&n;   */
id|COPY_FROM_USER
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
op_amp
id|patch
)paren
(braket
id|offs
)braket
comma
id|addr
comma
id|offs
comma
id|sizeof_patch
op_minus
id|offs
)paren
suffix:semicolon
id|instr
op_assign
id|patch.instr_no
suffix:semicolon
r_if
c_cond
(paren
id|instr
template_param
id|MAX_PATCH
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid patch number %d&bslash;n&quot;
comma
id|instr
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
id|patch.len
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Warning: Patch record too short (%d&lt;%d)&bslash;n&quot;
comma
id|count
comma
(paren
r_int
)paren
id|patch.len
)paren
suffix:semicolon
id|patch.len
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch.len
op_le
l_int|0
op_logical_or
id|patch.len
OG
id|gus_mem_size
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid sample length %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|patch.len
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_LOOPING
)paren
(brace
r_if
c_cond
(paren
id|patch.loop_start
OL
l_int|0
op_logical_or
id|patch.loop_start
op_ge
id|patch.len
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid loop start&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch.loop_end
template_param
id|patch.len
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Invalid loop end&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
id|free_mem_ptr
op_assign
(paren
id|free_mem_ptr
op_plus
l_int|31
)paren
op_amp
op_complement
l_int|31
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Alignment 32 bytes &n;&t;&t;&t;&t;&t;&t; */
DECL|macro|GUS_BANK_SIZE
mdefine_line|#define GUS_BANK_SIZE (256*1024)
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_16_BITS
)paren
(brace
multiline_comment|/* &n;       * 16 bit samples must fit one 256k bank.&n;       */
r_if
c_cond
(paren
id|patch.len
op_ge
id|GUS_BANK_SIZE
)paren
(brace
id|printk
(paren
l_string|&quot;GUS: Sample (16 bit) too long %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|patch.len
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|free_mem_ptr
op_div
id|GUS_BANK_SIZE
)paren
op_ne
(paren
(paren
id|free_mem_ptr
op_plus
id|patch.len
)paren
op_div
id|GUS_BANK_SIZE
)paren
)paren
(brace
r_int
r_int
id|tmp_mem
op_assign
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Align to 256K*N &n;&t;&t;&t;&t;&t; */
(paren
(paren
id|free_mem_ptr
op_div
id|GUS_BANK_SIZE
)paren
op_plus
l_int|1
)paren
op_star
id|GUS_BANK_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp_mem
op_plus
id|patch.len
)paren
OG
id|gus_mem_size
)paren
r_return
id|RET_ERROR
(paren
id|ENOSPC
)paren
suffix:semicolon
id|free_mem_ptr
op_assign
id|tmp_mem
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * This leaves unusable memory &n;&t;&t;&t;&t;&t; */
)brace
)brace
r_if
c_cond
(paren
(paren
id|free_mem_ptr
op_plus
id|patch.len
)paren
OG
id|gus_mem_size
)paren
r_return
id|RET_ERROR
(paren
id|ENOSPC
)paren
suffix:semicolon
id|sample_ptrs
(braket
id|free_sample
)braket
op_assign
id|free_mem_ptr
suffix:semicolon
multiline_comment|/* &n;   * Tremolo is not possible with envelopes &n;   */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_ENVELOPES
)paren
id|patch.mode
op_and_assign
op_complement
id|WAVE_TREMOLO
suffix:semicolon
id|memcpy
(paren
(paren
r_char
op_star
)paren
op_amp
id|samples
(braket
id|free_sample
)braket
comma
op_amp
id|patch
comma
id|sizeof_patch
)paren
suffix:semicolon
multiline_comment|/* &n;   * Link this_one sample to the list of samples for patch &squot;instr&squot;.&n;   */
id|samples
(braket
id|free_sample
)braket
dot
id|key
op_assign
id|patch_table
(braket
id|instr
)braket
suffix:semicolon
id|patch_table
(braket
id|instr
)braket
op_assign
id|free_sample
suffix:semicolon
multiline_comment|/* &n;   * Use DMA to transfer the wave data to the DRAM&n;   */
id|left
op_assign
id|patch.len
suffix:semicolon
id|src_offs
op_assign
l_int|0
suffix:semicolon
id|target
op_assign
id|free_mem_ptr
suffix:semicolon
r_while
c_loop
(paren
id|left
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Not all moved &n;&t;&t;&t;&t; */
(brace
id|blk_size
op_assign
id|sound_buffsizes
(braket
id|gus_devnum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
OG
id|left
)paren
id|blk_size
op_assign
id|left
suffix:semicolon
multiline_comment|/* &n;       * DMA cannot cross 256k bank boundaries. Check for that.&n;       */
id|blk_end
op_assign
id|target
op_plus
id|blk_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|target
op_rshift
l_int|18
)paren
op_ne
(paren
id|blk_end
op_rshift
l_int|18
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * Have to split the block &n;&t;&t;&t;&t; */
id|blk_end
op_and_assign
op_complement
(paren
l_int|256
op_star
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
id|blk_size
op_assign
id|blk_end
op_minus
id|target
suffix:semicolon
)brace
macro_line|#if defined(GUS_NO_DMA) || defined(GUS_PATCH_NO_DMA)
multiline_comment|/* &n;       * For some reason the DMA is not possible. We have to use PIO.&n;       */
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blk_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|GET_BYTE_FROM_USER
(paren
id|data
comma
id|addr
comma
id|sizeof_patch
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_UNSIGNED
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|patch.mode
op_amp
id|WAVE_16_BITS
)paren
op_logical_or
(paren
id|i
op_amp
l_int|0x01
)paren
)paren
id|data
op_xor_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Convert to signed &n;&t;&t;&t;&t; */
id|gus_poke
(paren
id|target
op_plus
id|i
comma
id|data
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* &n;       * * * GUS_NO_DMA   */
(brace
r_int
r_int
id|address
comma
id|hold_address
suffix:semicolon
r_int
r_char
id|dma_command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;&t; * OK, move now. First in and then out.&n;&t; */
id|COPY_FROM_USER
(paren
id|snd_raw_buf
(braket
id|gus_devnum
)braket
(braket
l_int|0
)braket
comma
id|addr
comma
id|sizeof_patch
op_plus
id|src_offs
comma
id|blk_size
)paren
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/******** INTERRUPTS DISABLED NOW ********/
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable GF1 DMA &n;&t;&t;&t;&t; */
id|DMAbuf_start_dma
(paren
id|gus_devnum
comma
id|snd_raw_buf_phys
(braket
id|gus_devnum
)braket
(braket
l_int|0
)braket
comma
id|blk_size
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Set the DRAM address for the wave data&n;&t; */
id|address
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|sound_dsp_dmachan
(braket
id|gus_devnum
)braket
OG
l_int|3
)paren
(brace
id|hold_address
op_assign
id|address
suffix:semicolon
id|address
op_assign
id|address
op_rshift
l_int|1
suffix:semicolon
id|address
op_and_assign
l_int|0x0001ffffL
suffix:semicolon
id|address
op_or_assign
(paren
id|hold_address
op_amp
l_int|0x000c0000L
)paren
suffix:semicolon
)brace
id|gus_write16
(paren
l_int|0x42
comma
(paren
id|address
op_rshift
l_int|4
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t; * DRAM DMA address &n;&t;&t;&t;&t;&t;&t;&t; */
multiline_comment|/* &n;&t; * Start the DMA transfer&n;&t; */
id|dma_command
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * IRQ enable, DMA start &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_UNSIGNED
)paren
id|dma_command
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Invert MSB &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|patch.mode
op_amp
id|WAVE_16_BITS
)paren
id|dma_command
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bit _DATA_ &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sound_dsp_dmachan
(braket
id|gus_devnum
)braket
OG
l_int|3
)paren
id|dma_command
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bit DMA channel &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x41
comma
id|dma_command
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Let&squot;s go luteet (=bugs) &n;&t;&t;&t;&t;&t;&t; */
multiline_comment|/* &n;&t; * Sleep here until the DRAM DMA done interrupt is served&n;&t; */
id|active_device
op_assign
id|GUS_DEV_WAVE
suffix:semicolon
id|DO_SLEEP
(paren
id|dram_sleeper
comma
id|dram_sleep_flag
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TIMED_OUT
(paren
id|dram_sleeper
comma
id|dram_sleep_flag
)paren
)paren
id|printk
(paren
l_string|&quot;GUS: DMA Transfer timed out&bslash;n&quot;
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* &n;        * * * GUS_NO_DMA   */
multiline_comment|/* &n;       * Now the next part&n;       */
id|left
op_sub_assign
id|blk_size
suffix:semicolon
id|src_offs
op_add_assign
id|blk_size
suffix:semicolon
id|target
op_add_assign
id|blk_size
suffix:semicolon
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Stop DMA &n;&t;&t;&t;&t; */
)brace
id|free_mem_ptr
op_add_assign
id|patch.len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmgr_flag
)paren
id|pmgr_inform
(paren
id|dev
comma
id|PM_E_PATCH_LOADED
comma
id|instr
comma
id|free_sample
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|free_sample
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|guswave_hw_control
id|guswave_hw_control
(paren
r_int
id|dev
comma
r_int
r_char
op_star
id|event
)paren
(brace
r_int
id|voice
comma
id|cmd
suffix:semicolon
r_int
r_int
id|p1
comma
id|p2
suffix:semicolon
r_int
r_int
id|plong
comma
id|flags
suffix:semicolon
id|cmd
op_assign
id|event
(braket
l_int|2
)braket
suffix:semicolon
id|voice
op_assign
id|event
(braket
l_int|3
)braket
suffix:semicolon
id|p1
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|event
(braket
l_int|4
)braket
suffix:semicolon
id|p2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|event
(braket
l_int|6
)braket
suffix:semicolon
id|plong
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|event
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_eq
id|VMODE_START_NOTE
)paren
op_logical_and
(paren
id|cmd
op_ne
id|_GUS_VOICESAMPLE
)paren
op_logical_and
(paren
id|cmd
op_ne
id|_GUS_VOICE_POS
)paren
)paren
id|do_volume_irq
(paren
id|voice
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|_GUS_NUMVOICES
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_select_max_voices
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICESAMPLE
suffix:colon
id|guswave_set_instr
(paren
id|dev
comma
id|voice
comma
id|p1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEON
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable intr &n;&t;&t;&t;&t; */
id|gus_voice_on
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEOFF
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEFADE
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_fade
(paren
id|voice
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEMODE
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable intr &n;&t;&t;&t;&t; */
id|gus_voice_mode
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEBALA
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_balance
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEFREQ
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|plong
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEVOL
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_volume
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICEVOL2
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * Just update the voice value &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|initial_volume
op_assign
id|voices
(braket
id|voice
)braket
dot
id|current_volume
op_assign
id|p1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPRANGE
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * NO-NO &n;&t;&t;&t;&t; */
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_ramp_range
(paren
id|p1
comma
id|p2
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPRATE
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * NO-NO &n;&t;&t;&t;&t; */
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
id|p1
comma
id|p2
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPMODE
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * NO-NO &n;&t;&t;&t;&t; */
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable intr &n;&t;&t;&t;&t; */
id|gus_ramp_mode
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPON
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * NO-NO &n;&t;&t;&t;&t; */
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|p1
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable intr &n;&t;&t;&t;&t; */
id|gus_rampon
(paren
id|p1
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_RAMPOFF
suffix:colon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|mode
op_amp
id|WAVE_ENVELOPES
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * NO-NO &n;&t;&t;&t;&t; */
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOLUME_SCALE
suffix:colon
id|volume_base
op_assign
id|p1
suffix:semicolon
id|volume_scale
op_assign
id|p2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_GUS_VOICE_POS
suffix:colon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_set_voice_pos
(paren
id|voice
comma
id|plong
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|gus_sampling_set_speed
id|gus_sampling_set_speed
(paren
r_int
id|speed
)paren
(brace
r_if
c_cond
(paren
id|speed
op_le
l_int|0
)paren
r_return
id|gus_sampling_speed
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
l_int|44100
)paren
id|speed
op_assign
l_int|44100
suffix:semicolon
id|gus_sampling_speed
op_assign
id|speed
suffix:semicolon
r_return
id|speed
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_sampling_set_channels
id|gus_sampling_set_channels
(paren
r_int
id|channels
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|channels
)paren
r_return
id|gus_sampling_channels
suffix:semicolon
r_if
c_cond
(paren
id|channels
OG
l_int|2
)paren
id|channels
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|channels
OL
l_int|1
)paren
id|channels
op_assign
l_int|1
suffix:semicolon
id|gus_sampling_channels
op_assign
id|channels
suffix:semicolon
r_return
id|channels
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_sampling_set_bits
id|gus_sampling_set_bits
(paren
r_int
id|bits
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
r_return
id|gus_sampling_bits
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_ne
l_int|8
op_logical_and
id|bits
op_ne
l_int|16
)paren
id|bits
op_assign
l_int|8
suffix:semicolon
id|gus_sampling_bits
op_assign
id|bits
suffix:semicolon
r_return
id|bits
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_sampling_ioctl
id|gus_sampling_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
comma
r_int
id|local
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_PCM_WRITE_RATE
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_set_speed
(paren
id|arg
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_set_speed
(paren
id|IOCTL_IN
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_speed
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_speed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_set_channels
(paren
id|arg
op_plus
l_int|1
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_set_channels
(paren
id|IOCTL_IN
(paren
id|arg
)paren
op_plus
l_int|1
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_set_channels
(paren
id|arg
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_set_channels
(paren
id|IOCTL_IN
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_channels
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_channels
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SAMPLESIZE
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_set_bits
(paren
id|arg
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_set_bits
(paren
id|IOCTL_IN
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_if
c_cond
(paren
id|local
)paren
r_return
id|gus_sampling_bits
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_sampling_bits
)paren
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * NOT YET IMPLEMENTED &n;&t;&t;&t;&t;&t; */
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|RET_ERROR
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|RET_ERROR
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_sampling_reset
id|gus_sampling_reset
(paren
r_int
id|dev
)paren
(brace
)brace
r_static
r_int
DECL|function|gus_sampling_open
id|gus_sampling_open
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
macro_line|#ifdef GUS_NO_DMA
id|printk
(paren
l_string|&quot;GUS: DMA mode not enabled. Device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|ENXIO
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|gus_busy
)paren
r_return
id|RET_ERROR
(paren
id|EBUSY
)paren
suffix:semicolon
id|gus_initialize
(paren
)paren
suffix:semicolon
id|gus_busy
op_assign
l_int|1
suffix:semicolon
id|active_device
op_assign
l_int|0
suffix:semicolon
id|gus_reset
(paren
)paren
suffix:semicolon
id|reset_sample_memory
(paren
)paren
suffix:semicolon
id|gus_select_max_voices
(paren
l_int|14
)paren
suffix:semicolon
id|pcm_active
op_assign
l_int|0
suffix:semicolon
id|pcm_opened
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|OPEN_READ
)paren
(brace
id|recording_active
op_assign
l_int|1
suffix:semicolon
id|set_input_volumes
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_sampling_close
id|gus_sampling_close
(paren
r_int
id|dev
)paren
(brace
id|gus_reset
(paren
)paren
suffix:semicolon
id|gus_busy
op_assign
l_int|0
suffix:semicolon
id|pcm_opened
op_assign
l_int|0
suffix:semicolon
id|active_device
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|recording_active
)paren
id|set_input_volumes
c_func
(paren
)paren
suffix:semicolon
id|recording_active
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_sampling_update_volume
id|gus_sampling_update_volume
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|voice
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcm_active
op_logical_and
id|pcm_opened
)paren
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|gus_sampling_channels
suffix:semicolon
id|voice
op_increment
)paren
(brace
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|gus_ramp_range
(paren
l_int|65
comma
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|play_next_pcm_block
id|play_next_pcm_block
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|speed
op_assign
id|gus_sampling_speed
suffix:semicolon
r_int
id|this_one
comma
id|is16bits
comma
id|chn
suffix:semicolon
r_int
r_int
id|dram_loc
suffix:semicolon
r_int
r_char
id|mode
(braket
l_int|2
)braket
comma
id|ramp_mode
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcm_qlen
)paren
r_return
suffix:semicolon
id|this_one
op_assign
id|pcm_head
suffix:semicolon
r_for
c_loop
(paren
id|chn
op_assign
l_int|0
suffix:semicolon
id|chn
OL
id|gus_sampling_channels
suffix:semicolon
id|chn
op_increment
)paren
(brace
id|mode
(braket
id|chn
)braket
op_assign
l_int|0x00
suffix:semicolon
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramping and rollover off &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
(brace
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Loop irq &n;&t;&t;&t;&t; */
id|voices
(braket
id|chn
)braket
dot
id|loop_irq_mode
op_assign
id|LMODE_PCM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gus_sampling_bits
op_ne
l_int|8
)paren
(brace
id|is16bits
op_assign
l_int|1
suffix:semicolon
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bit data &n;&t;&t;&t;&t; */
)brace
r_else
id|is16bits
op_assign
l_int|0
suffix:semicolon
id|dram_loc
op_assign
id|this_one
op_star
id|pcm_bsize
suffix:semicolon
id|dram_loc
op_add_assign
id|chn
op_star
id|pcm_banksize
suffix:semicolon
r_if
c_cond
(paren
id|this_one
op_eq
(paren
id|pcm_nblk
op_minus
l_int|1
)paren
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Last of the DRAM buffers &n;&t;&t;&t;&t;&t; */
(brace
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Enable loop &n;&t;&t;&t;&t; */
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Disable rollover &n;&t;&t;&t;&t;&t; */
)brace
r_else
(brace
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Enable rollover bit &n;&t;&t;&t;&t;&t; */
)brace
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|chn
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|speed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gus_sampling_channels
op_eq
l_int|1
)paren
id|gus_voice_balance
(paren
l_int|7
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * mono &n;&t;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
id|gus_voice_balance
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * left &n;&t;&t;&t;&t; */
r_else
id|gus_voice_balance
(paren
l_int|15
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * right &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pcm_active
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Voice not started yet &n;&t;&t;&t;&t; */
(brace
multiline_comment|/* &n;&t;   * The playback was not started yet (or there has been a pause).&n;&t;   * Start the voice (again) and ask for a rollover irq at the end of&n;&t;   * this_one block. If this_one one is last of the buffers, use just&n;&t;   * the normal loop with irq.&n;&t;   */
id|gus_voice_off
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * It could already be running &n;&t;&t;&t;&t; */
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_volume
(paren
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|gus_ramp_range
(paren
l_int|65
comma
l_int|1530
op_plus
(paren
l_int|25
op_star
id|gus_pcm_volume
)paren
)paren
suffix:semicolon
id|gus_write_addr
(paren
l_int|0x0a
comma
id|dram_loc
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t; * Starting position &n;&t;&t;&t;&t;&t;&t;&t; */
id|gus_write_addr
(paren
l_int|0x02
comma
id|chn
op_star
id|pcm_banksize
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * Loop start &n;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|chn
op_ne
l_int|0
)paren
id|gus_write_addr
(paren
l_int|0x04
comma
id|pcm_banksize
op_plus
(paren
id|pcm_bsize
op_star
id|pcm_nblk
)paren
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Loop end location &n;&t;&t;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
id|gus_write_addr
(paren
l_int|0x04
comma
id|dram_loc
op_plus
id|pcm_datasize
(braket
id|this_one
)braket
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Loop &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * end &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
r_else
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Enable loop &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pcm_datasize
(braket
id|this_one
)braket
op_ne
id|pcm_bsize
)paren
(brace
multiline_comment|/* &n;&t;   * Incomplete block. Possibly the last one. &n;&t;   */
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
(brace
id|mode
(braket
id|chn
)braket
op_and_assign
op_complement
l_int|0x08
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Disable loop &n;&t;&t;&t;&t;&t; */
id|mode
(braket
id|chn
)braket
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Enable loop IRQ &n;&t;&t;&t;&t;&t; */
id|voices
(braket
l_int|0
)braket
dot
id|loop_irq_mode
op_assign
id|LMODE_PCM_STOP
suffix:semicolon
id|ramp_mode
(braket
id|chn
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * No rollover bit &n;&t;&t;&t;&t;&t; */
)brace
r_else
(brace
id|gus_write_addr
(paren
l_int|0x04
comma
id|dram_loc
op_plus
id|pcm_datasize
(braket
id|this_one
)braket
comma
id|is16bits
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * Loop &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * end &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; * location &n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|mode
(braket
id|chn
)braket
op_and_assign
op_complement
l_int|0x08
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Disable loop &n;&t;&t;&t;&t;&t; */
)brace
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|chn
op_assign
l_int|0
suffix:semicolon
id|chn
OL
id|gus_sampling_channels
suffix:semicolon
id|chn
op_increment
)paren
(brace
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|chn
)paren
suffix:semicolon
id|gus_write8
(paren
l_int|0x0d
comma
id|ramp_mode
(braket
id|chn
)braket
)paren
suffix:semicolon
id|gus_voice_on
(paren
id|mode
(braket
id|chn
)braket
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
id|pcm_active
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_transfer_output_block
id|gus_transfer_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|total_count
comma
r_int
id|intrflag
comma
r_int
id|chn
)paren
(brace
multiline_comment|/* &n;   * This routine transfers one block of audio data to the DRAM. In mono mode&n;   * it&squot;s called just once. When in stereo mode, this_one routine is called&n;   * once for both channels.&n;   * &n;   * The left/mono channel data is transferred to the beginning of dram and the&n;   * right data to the area pointed by gus_page_size.&n;   */
r_int
id|this_one
comma
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|dma_command
suffix:semicolon
r_int
r_int
id|address
comma
id|hold_address
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|total_count
op_div
id|gus_sampling_channels
suffix:semicolon
r_if
c_cond
(paren
id|chn
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pcm_qlen
op_ge
id|pcm_nblk
)paren
id|printk
(paren
l_string|&quot;GUS Warning: PCM buffers out of sync&bslash;n&quot;
)paren
suffix:semicolon
id|this_one
op_assign
id|pcm_current_block
op_assign
id|pcm_tail
suffix:semicolon
id|pcm_qlen
op_increment
suffix:semicolon
id|pcm_tail
op_assign
(paren
id|pcm_tail
op_plus
l_int|1
)paren
op_mod
id|pcm_nblk
suffix:semicolon
id|pcm_datasize
(braket
id|this_one
)braket
op_assign
id|count
suffix:semicolon
)brace
r_else
id|this_one
op_assign
id|pcm_current_block
suffix:semicolon
id|gus_write8
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable GF1 DMA &n;&t;&t;&t;&t; */
id|DMAbuf_start_dma
(paren
id|dev
comma
id|buf
op_plus
(paren
id|chn
op_star
id|count
)paren
comma
id|count
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|address
op_assign
id|this_one
op_star
id|pcm_bsize
suffix:semicolon
id|address
op_add_assign
id|chn
op_star
id|pcm_banksize
suffix:semicolon
r_if
c_cond
(paren
id|sound_dsp_dmachan
(braket
id|dev
)braket
OG
l_int|3
)paren
(brace
id|hold_address
op_assign
id|address
suffix:semicolon
id|address
op_assign
id|address
op_rshift
l_int|1
suffix:semicolon
id|address
op_and_assign
l_int|0x0001ffffL
suffix:semicolon
id|address
op_or_assign
(paren
id|hold_address
op_amp
l_int|0x000c0000L
)paren
suffix:semicolon
)brace
id|gus_write16
(paren
l_int|0x42
comma
(paren
id|address
op_rshift
l_int|4
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * DRAM DMA address &n;&t;&t;&t;&t;&t;&t; */
id|dma_command
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * IRQ enable, DMA start &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gus_sampling_bits
op_ne
l_int|8
)paren
id|dma_command
op_or_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bit _DATA_ &n;&t;&t;&t;&t; */
r_else
id|dma_command
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Invert MSB &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sound_dsp_dmachan
(braket
id|dev
)braket
OG
l_int|3
)paren
id|dma_command
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bit DMA channel &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x41
comma
id|dma_command
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Kick on &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|chn
op_eq
(paren
id|gus_sampling_channels
op_minus
l_int|1
)paren
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Last channel &n;&t;&t;&t;&t;&t;&t; */
(brace
multiline_comment|/* &n;       * Last (right or mono) channel data &n;       */
id|active_device
op_assign
id|GUS_DEV_PCM_DONE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcm_active
op_logical_and
(paren
id|pcm_qlen
OG
l_int|2
op_logical_or
id|count
OL
id|pcm_bsize
)paren
)paren
(brace
id|play_next_pcm_block
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* &n;&t;&t;&t;&t; * * * Left channel data. The right channel&n;&t;&t;&t;&t; * is * * * transferred after DMA interrupt   */
id|active_device
op_assign
id|GUS_DEV_PCM_CONTINUE
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_sampling_output_block
id|gus_sampling_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|total_count
comma
r_int
id|intrflag
comma
r_int
id|restart_dma
)paren
(brace
id|pcm_current_buf
op_assign
id|buf
suffix:semicolon
id|pcm_current_count
op_assign
id|total_count
suffix:semicolon
id|pcm_current_intrflag
op_assign
id|intrflag
suffix:semicolon
id|pcm_current_dev
op_assign
id|dev
suffix:semicolon
id|gus_transfer_output_block
(paren
id|dev
comma
id|buf
comma
id|total_count
comma
id|intrflag
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_sampling_start_input
id|gus_sampling_start_input
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
comma
r_int
id|restart_dma
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|mode
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|DMAbuf_start_dma
(paren
id|dev
comma
id|buf
comma
id|count
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|mode
op_assign
l_int|0xa0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * DMA IRQ enable, invert MSB &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sound_dsp_dmachan
(braket
id|dev
)braket
OG
l_int|3
)paren
id|mode
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * 16 bit DMA channel &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gus_sampling_channels
OG
l_int|1
)paren
id|mode
op_or_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Stereo &n;&t;&t;&t;&t; */
id|mode
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * DMA enable &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x49
comma
id|mode
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_sampling_prepare_for_input
id|gus_sampling_prepare_for_input
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_int
r_int
id|rate
suffix:semicolon
id|rate
op_assign
(paren
l_int|9878400
op_div
(paren
id|gus_sampling_speed
op_plus
l_int|2
)paren
)paren
op_div
l_int|16
suffix:semicolon
id|gus_write8
(paren
l_int|0x48
comma
id|rate
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Set sampling frequency &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gus_sampling_bits
op_ne
l_int|8
)paren
(brace
id|printk
(paren
l_string|&quot;GUS Error: 16 bit recording not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_sampling_prepare_for_output
id|gus_sampling_prepare_for_output
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|mem_ptr
comma
id|mem_size
suffix:semicolon
id|mem_ptr
op_assign
l_int|0
suffix:semicolon
id|mem_size
op_assign
id|gus_mem_size
op_div
id|gus_sampling_channels
suffix:semicolon
r_if
c_cond
(paren
id|mem_size
OG
(paren
l_int|256
op_star
l_int|1024
)paren
)paren
id|mem_size
op_assign
l_int|256
op_star
l_int|1024
suffix:semicolon
id|pcm_bsize
op_assign
id|bsize
op_div
id|gus_sampling_channels
suffix:semicolon
id|pcm_head
op_assign
id|pcm_tail
op_assign
id|pcm_qlen
op_assign
l_int|0
suffix:semicolon
id|pcm_nblk
op_assign
id|MAX_PCM_BUFFERS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcm_bsize
op_star
id|pcm_nblk
)paren
OG
id|mem_size
)paren
id|pcm_nblk
op_assign
id|mem_size
op_div
id|pcm_bsize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pcm_nblk
suffix:semicolon
id|i
op_increment
)paren
id|pcm_datasize
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|pcm_banksize
op_assign
id|pcm_nblk
op_star
id|pcm_bsize
suffix:semicolon
r_if
c_cond
(paren
id|gus_sampling_bits
op_ne
l_int|8
op_logical_and
id|pcm_banksize
op_eq
(paren
l_int|256
op_star
l_int|1024
)paren
)paren
id|pcm_nblk
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_has_output_drained
id|gus_has_output_drained
(paren
r_int
id|dev
)paren
(brace
r_return
op_logical_neg
id|pcm_qlen
suffix:semicolon
)brace
r_static
r_void
DECL|function|gus_copy_from_user
id|gus_copy_from_user
(paren
r_int
id|dev
comma
r_char
op_star
id|localbuf
comma
r_int
id|localoffs
comma
id|snd_rw_buf
op_star
id|userbuf
comma
r_int
id|useroffs
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|gus_sampling_channels
op_eq
l_int|1
)paren
(brace
id|COPY_FROM_USER
(paren
op_amp
id|localbuf
(braket
id|localoffs
)braket
comma
id|userbuf
comma
id|useroffs
comma
id|len
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gus_sampling_bits
op_eq
l_int|8
)paren
(brace
r_int
id|in_left
op_assign
id|useroffs
suffix:semicolon
r_int
id|in_right
op_assign
id|useroffs
op_plus
l_int|1
suffix:semicolon
r_char
op_star
id|out_left
comma
op_star
id|out_right
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_div_assign
l_int|2
suffix:semicolon
id|localoffs
op_div_assign
l_int|2
suffix:semicolon
id|out_left
op_assign
op_amp
id|localbuf
(braket
id|localoffs
)braket
suffix:semicolon
id|out_right
op_assign
id|out_left
op_plus
id|pcm_bsize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|GET_BYTE_FROM_USER
(paren
op_star
id|out_left
op_increment
comma
id|userbuf
comma
id|in_left
)paren
suffix:semicolon
id|in_left
op_add_assign
l_int|2
suffix:semicolon
id|GET_BYTE_FROM_USER
(paren
op_star
id|out_right
op_increment
comma
id|userbuf
comma
id|in_right
)paren
suffix:semicolon
id|in_right
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|in_left
op_assign
id|useroffs
suffix:semicolon
r_int
id|in_right
op_assign
id|useroffs
op_plus
l_int|1
suffix:semicolon
r_int
op_star
id|out_left
comma
op_star
id|out_right
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_div_assign
l_int|4
suffix:semicolon
id|localoffs
op_div_assign
l_int|4
suffix:semicolon
id|out_left
op_assign
(paren
r_int
op_star
)paren
op_amp
id|localbuf
(braket
id|localoffs
)braket
suffix:semicolon
id|out_right
op_assign
id|out_left
op_plus
(paren
id|pcm_bsize
op_div
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|GET_SHORT_FROM_USER
(paren
op_star
id|out_left
op_increment
comma
(paren
r_int
op_star
)paren
id|userbuf
comma
id|in_left
)paren
suffix:semicolon
id|in_left
op_add_assign
l_int|2
suffix:semicolon
id|GET_SHORT_FROM_USER
(paren
op_star
id|out_right
op_increment
comma
(paren
r_int
op_star
)paren
id|userbuf
comma
id|in_right
)paren
suffix:semicolon
id|in_right
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
DECL|variable|gus_sampling_operations
r_static
r_struct
id|audio_operations
id|gus_sampling_operations
op_assign
(brace
l_string|&quot;Gravis UltraSound&quot;
comma
id|gus_sampling_open
comma
id|gus_sampling_close
comma
id|gus_sampling_output_block
comma
id|gus_sampling_start_input
comma
id|gus_sampling_ioctl
comma
id|gus_sampling_prepare_for_input
comma
id|gus_sampling_prepare_for_output
comma
id|gus_sampling_reset
comma
id|gus_sampling_reset
comma
id|gus_has_output_drained
comma
id|gus_copy_from_user
)brace
suffix:semicolon
macro_line|#ifdef FUTURE_VERSION
r_static
r_void
DECL|function|guswave_bender
id|guswave_bender
(paren
r_int
id|dev
comma
r_int
id|voice
comma
r_int
id|value
)paren
(brace
r_int
id|freq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|bender
op_assign
id|value
op_minus
l_int|8192
suffix:semicolon
id|freq
op_assign
id|compute_finetune
(paren
id|voices
(braket
id|voice
)braket
dot
id|orig_freq
comma
id|value
comma
id|voices
(braket
id|voice
)braket
dot
id|bender_range
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|current_freq
op_assign
id|freq
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|gus_voice_freq
(paren
id|freq
)paren
suffix:semicolon
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|guswave_patchmgr
id|guswave_patchmgr
(paren
r_int
id|dev
comma
r_struct
id|patmgr_info
op_star
id|rec
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_switch
c_cond
(paren
id|rec-&gt;command
)paren
(brace
r_case
id|PM_GET_DEVTYPE
suffix:colon
id|rec-&gt;parm1
op_assign
id|PMTYPE_WAVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_GET_NRPGM
suffix:colon
id|rec-&gt;parm1
op_assign
id|MAX_PATCH
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_GET_PGMMAP
suffix:colon
id|rec-&gt;parm1
op_assign
id|MAX_PATCH
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ptr
op_assign
id|patch_table
(braket
id|i
)braket
suffix:semicolon
id|rec-&gt;data.data8
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ptr
op_ge
l_int|0
op_logical_and
id|ptr
OL
id|free_sample
)paren
(brace
id|rec-&gt;data.data8
(braket
id|i
)braket
op_increment
suffix:semicolon
id|ptr
op_assign
id|samples
(braket
id|ptr
)braket
dot
id|key
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Follow link &n;&t;&t;&t;&t;&t; */
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_GET_PGM_PATCHES
suffix:colon
(brace
r_int
id|ptr
op_assign
id|patch_table
(braket
id|rec-&gt;parm1
)braket
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ptr
op_ge
l_int|0
op_logical_and
id|ptr
OL
id|free_sample
)paren
(brace
id|rec-&gt;data.data32
(braket
id|n
op_increment
)braket
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|samples
(braket
id|ptr
)braket
dot
id|key
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Follow link &n;&t;&t;&t;&t;&t; */
)brace
)brace
id|rec-&gt;parm1
op_assign
id|n
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_GET_PATCH
suffix:colon
(brace
r_int
id|ptr
op_assign
id|rec-&gt;parm1
suffix:semicolon
r_struct
id|patch_info
op_star
id|pat
suffix:semicolon
r_if
c_cond
(paren
id|ptr
OL
l_int|0
op_logical_or
id|ptr
op_ge
id|free_sample
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
id|memcpy
(paren
id|rec-&gt;data.data8
comma
(paren
r_char
op_star
)paren
op_amp
id|samples
(braket
id|ptr
)braket
comma
r_sizeof
(paren
r_struct
id|patch_info
)paren
)paren
suffix:semicolon
id|pat
op_assign
(paren
r_struct
id|patch_info
op_star
)paren
id|rec-&gt;data.data8
suffix:semicolon
id|pat-&gt;key
op_assign
id|GUS_PATCH
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Restore patch type &n;&t;&t;&t;&t; */
id|rec-&gt;parm1
op_assign
id|sample_ptrs
(braket
id|ptr
)braket
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * DRAM address &n;&t;&t;&t;&t;&t; */
id|rec-&gt;parm2
op_assign
r_sizeof
(paren
r_struct
id|patch_info
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_SET_PATCH
suffix:colon
(brace
r_int
id|ptr
op_assign
id|rec-&gt;parm1
suffix:semicolon
r_struct
id|patch_info
op_star
id|pat
suffix:semicolon
r_if
c_cond
(paren
id|ptr
OL
l_int|0
op_logical_or
id|ptr
op_ge
id|free_sample
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
id|pat
op_assign
(paren
r_struct
id|patch_info
op_star
)paren
id|rec-&gt;data.data8
suffix:semicolon
r_if
c_cond
(paren
id|pat-&gt;len
OG
id|samples
(braket
id|ptr
)braket
dot
id|len
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Cannot expand sample &n;&t;&t;&t;&t;&t;&t; */
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
id|pat-&gt;key
op_assign
id|samples
(braket
id|ptr
)braket
dot
id|key
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Ensure the link is correct &n;&t;&t;&t;&t;&t; */
id|memcpy
(paren
(paren
r_char
op_star
)paren
op_amp
id|samples
(braket
id|ptr
)braket
comma
id|rec-&gt;data.data8
comma
r_sizeof
(paren
r_struct
id|patch_info
)paren
)paren
suffix:semicolon
id|pat-&gt;key
op_assign
id|GUS_PATCH
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_READ_PATCH
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * Returns a block of wave data from the DRAM &n;&t;&t;&t;&t; */
(brace
r_int
id|sample
op_assign
id|rec-&gt;parm1
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|offs
op_assign
id|rec-&gt;parm2
suffix:semicolon
r_int
id|l
op_assign
id|rec-&gt;parm3
suffix:semicolon
r_if
c_cond
(paren
id|sample
OL
l_int|0
op_logical_or
id|sample
op_ge
id|free_sample
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offs
OL
l_int|0
op_logical_or
id|offs
op_ge
id|samples
(braket
id|sample
)braket
dot
id|len
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Invalid offset &n;&t;&t;&t;&t;&t; */
id|n
op_assign
id|samples
(braket
id|sample
)braket
dot
id|len
op_minus
id|offs
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Nr of bytes left &n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|l
OG
id|n
)paren
id|l
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
r_sizeof
(paren
id|rec-&gt;data.data8
)paren
)paren
id|l
op_assign
r_sizeof
(paren
id|rec-&gt;data.data8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_le
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Was there a bug? &n;&t;&t;&t;&t;&t; */
id|offs
op_add_assign
id|sample_ptrs
(braket
id|sample
)braket
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Begin offsess + offset to DRAM &n;&t;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|l
suffix:semicolon
id|n
op_increment
)paren
id|rec-&gt;data.data8
(braket
id|n
)braket
op_assign
id|gus_peek
(paren
id|offs
op_increment
)paren
suffix:semicolon
id|rec-&gt;parm1
op_assign
id|n
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Nr of bytes copied &n;&t;&t;&t;&t; */
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_WRITE_PATCH
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * Writes a block of wave data to the DRAM &n;&t;&t;&t;&t; */
(brace
r_int
id|sample
op_assign
id|rec-&gt;parm1
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|offs
op_assign
id|rec-&gt;parm2
suffix:semicolon
r_int
id|l
op_assign
id|rec-&gt;parm3
suffix:semicolon
r_if
c_cond
(paren
id|sample
OL
l_int|0
op_logical_or
id|sample
op_ge
id|free_sample
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offs
OL
l_int|0
op_logical_or
id|offs
op_ge
id|samples
(braket
id|sample
)braket
dot
id|len
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Invalid offset &n;&t;&t;&t;&t;&t; */
id|n
op_assign
id|samples
(braket
id|sample
)braket
dot
id|len
op_minus
id|offs
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Nr of bytes left &n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|l
OG
id|n
)paren
id|l
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
r_sizeof
(paren
id|rec-&gt;data.data8
)paren
)paren
id|l
op_assign
r_sizeof
(paren
id|rec-&gt;data.data8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_le
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Was there a bug? &n;&t;&t;&t;&t;&t; */
id|offs
op_add_assign
id|sample_ptrs
(braket
id|sample
)braket
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Begin offsess + offset to DRAM &n;&t;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|l
suffix:semicolon
id|n
op_increment
)paren
id|gus_poke
(paren
id|offs
op_increment
comma
id|rec-&gt;data.data8
(braket
id|n
)braket
)paren
suffix:semicolon
id|rec-&gt;parm1
op_assign
id|n
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Nr of bytes copied &n;&t;&t;&t;&t; */
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
DECL|variable|guswave_operations
r_static
r_struct
id|synth_operations
id|guswave_operations
op_assign
(brace
op_amp
id|gus_info
comma
macro_line|#ifdef FUTURE_VERSION
l_int|0
comma
macro_line|#endif
id|SYNTH_TYPE_SAMPLE
comma
id|SAMPLE_TYPE_GUS
comma
id|guswave_open
comma
id|guswave_close
comma
id|guswave_ioctl
comma
id|guswave_kill_note
comma
id|guswave_start_note
comma
id|guswave_set_instr
comma
id|guswave_reset
comma
id|guswave_hw_control
comma
id|guswave_load_patch
comma
id|guswave_aftertouch
comma
id|guswave_controller
comma
id|guswave_panning
comma
id|guswave_patchmgr
comma
macro_line|#ifdef FUTURE_VERSION
id|guswave_bender
macro_line|#endif
)brace
suffix:semicolon
r_static
r_void
DECL|function|set_input_volumes
id|set_input_volumes
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|mask
op_assign
l_int|0xff
op_amp
op_complement
l_int|0x06
suffix:semicolon
multiline_comment|/* Just line out enabled */
id|DISABLE_INTR
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Enable channels having vol &gt; 10%&n; *&t;Note! bit 0x01 means line in DISABLED while 0x04 means&n; *&t;      mic in ENABLED.&n; */
r_if
c_cond
(paren
id|gus_line_vol
OG
l_int|10
)paren
id|mask
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|gus_mic_vol
OG
l_int|10
)paren
id|mask
op_or_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|recording_active
)paren
(brace
multiline_comment|/*&n; *&t;Disable channel, if not selected for recording&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|gus_recmask
op_amp
id|SOUND_MASK_LINE
)paren
)paren
id|mask
op_or_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gus_recmask
op_amp
id|SOUND_MASK_MIC
)paren
)paren
id|mask
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
)brace
id|mix_image
op_and_assign
op_complement
l_int|0x07
suffix:semicolon
id|mix_image
op_or_assign
id|mask
op_amp
l_int|0x07
suffix:semicolon
id|OUTB
(paren
id|mix_image
comma
id|u_Mixer
)paren
suffix:semicolon
id|RESTORE_INTR
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|gus_mixer_ioctl
id|gus_mixer_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
DECL|macro|MIX_DEVS
mdefine_line|#define MIX_DEVS&t;(SOUND_MASK_MIC|SOUND_MASK_LINE| &bslash;&n;&t;&t;&t; SOUND_MASK_SYNTH|SOUND_MASK_PCM)
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_eq
l_char|&squot;M&squot;
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_amp
id|IOC_IN
)paren
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|0xff
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|gus_recmask
op_assign
id|IOCTL_IN
c_func
(paren
id|arg
)paren
op_amp
id|MIX_DEVS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gus_recmask
op_amp
(paren
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_LINE
)paren
)paren
)paren
id|gus_recmask
op_assign
id|SOUND_MASK_MIC
suffix:semicolon
multiline_comment|/* Note! Input volumes are updated during next open for recording */
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_recmask
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
(brace
r_int
id|vol
op_assign
id|IOCTL_IN
(paren
id|arg
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|vol
OL
l_int|0
)paren
id|vol
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol
OG
l_int|100
)paren
id|vol
op_assign
l_int|100
suffix:semicolon
id|gus_mic_vol
op_assign
id|vol
suffix:semicolon
id|set_input_volumes
c_func
(paren
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|vol
op_or
(paren
id|vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_LINE
suffix:colon
(brace
r_int
id|vol
op_assign
id|IOCTL_IN
(paren
id|arg
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|vol
OL
l_int|0
)paren
id|vol
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol
OG
l_int|100
)paren
id|vol
op_assign
l_int|100
suffix:semicolon
id|gus_line_vol
op_assign
id|vol
suffix:semicolon
id|set_input_volumes
c_func
(paren
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|vol
op_or
(paren
id|vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PCM
suffix:colon
id|gus_pcm_volume
op_assign
id|IOCTL_IN
(paren
id|arg
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|gus_pcm_volume
OL
l_int|0
)paren
id|gus_pcm_volume
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gus_pcm_volume
OG
l_int|100
)paren
id|gus_pcm_volume
op_assign
l_int|100
suffix:semicolon
id|gus_sampling_update_volume
(paren
)paren
suffix:semicolon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_pcm_volume
op_or
(paren
id|gus_pcm_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
(brace
r_int
id|voice
suffix:semicolon
id|gus_wave_volume
op_assign
id|IOCTL_IN
(paren
id|arg
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|gus_wave_volume
OL
l_int|0
)paren
id|gus_wave_volume
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gus_wave_volume
OG
l_int|100
)paren
id|gus_wave_volume
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|active_device
op_eq
id|GUS_DEV_WAVE
)paren
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|nr_voices
suffix:semicolon
id|voice
op_increment
)paren
id|dynamic_volume_change
(paren
id|voice
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t; * Apply the new&n;&t;&t;&t;&t;&t;&t;&t; * volume &n;&t;&t;&t;&t;&t;&t;&t; */
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_wave_volume
op_or
(paren
id|gus_wave_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|0xff
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Return parameters &n;&t;&t;&t;&t; */
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_recmask
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|MIX_DEVS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_LINE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_mic_vol
op_or
(paren
id|gus_mic_vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_LINE
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_line_vol
op_or
(paren
id|gus_line_vol
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PCM
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_pcm_volume
op_or
(paren
id|gus_pcm_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
r_return
id|IOCTL_OUT
(paren
id|arg
comma
id|gus_wave_volume
op_or
(paren
id|gus_wave_volume
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_else
r_return
id|RET_ERROR
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|variable|gus_mixer_operations
r_static
r_struct
id|mixer_operations
id|gus_mixer_operations
op_assign
(brace
id|gus_mixer_ioctl
)brace
suffix:semicolon
r_int
DECL|function|gus_wave_init
id|gus_wave_init
(paren
r_int
id|mem_start
comma
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
id|printk
(paren
l_string|&quot; &lt;Gravis UltraSound %dk&gt;&quot;
comma
(paren
r_int
)paren
id|gus_mem_size
op_div
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
template_param
l_int|15
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR! Invalid IRQ#%d. GUS Disabled&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma
template_param
l_int|7
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR! Invalid DMA#%d. GUS Disabled&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|gus_irq
op_assign
id|irq
suffix:semicolon
id|gus_dma
op_assign
id|dma
suffix:semicolon
r_if
c_cond
(paren
id|num_synths
op_ge
id|MAX_SYNTH_DEV
)paren
id|printk
(paren
l_string|&quot;GUS Error: Too many synthesizers&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|synth_devs
(braket
id|num_synths
op_increment
)braket
op_assign
op_amp
id|guswave_operations
suffix:semicolon
id|PERMANENT_MALLOC
(paren
r_struct
id|patch_info
op_star
comma
id|samples
comma
(paren
id|MAX_SAMPLE
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|samples
)paren
comma
id|mem_start
)paren
suffix:semicolon
id|reset_sample_memory
(paren
)paren
suffix:semicolon
id|gus_initialize
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_dspdevs
OL
id|MAX_DSP_DEV
)paren
(brace
id|dsp_devs
(braket
id|gus_devnum
op_assign
id|num_dspdevs
op_increment
)braket
op_assign
op_amp
id|gus_sampling_operations
suffix:semicolon
id|sound_dsp_dmachan
(braket
id|gus_devnum
)braket
op_assign
id|dma
suffix:semicolon
id|sound_buffcounts
(braket
id|gus_devnum
)braket
op_assign
l_int|1
suffix:semicolon
id|sound_buffsizes
(braket
id|gus_devnum
)braket
op_assign
id|DSP_BUFFSIZE
suffix:semicolon
id|sound_dma_automode
(braket
id|gus_devnum
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;GUS: Too many PCM devices available&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_mixers
OL
id|MAX_MIXER_DEV
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Don&squot;t install if there is another&n;&t;&t;&t;&t;&t; * mixer &n;&t;&t;&t;&t;&t; */
id|mixer_devs
(braket
id|num_mixers
op_increment
)braket
op_assign
op_amp
id|gus_mixer_operations
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_loop_irq
id|do_loop_irq
(paren
r_int
id|voice
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|mode
comma
id|parm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|tmp
op_assign
id|gus_read8
(paren
l_int|0x00
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable wave IRQ for this_one voice &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x00
comma
id|tmp
)paren
suffix:semicolon
id|mode
op_assign
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_mode
op_assign
l_int|0
suffix:semicolon
id|parm
op_assign
id|voices
(braket
id|voice
)braket
dot
id|loop_irq_parm
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|LMODE_FINISH
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * Final loop finished, shoot volume down &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|gus_read16
(paren
l_int|0x09
)paren
op_rshift
l_int|4
)paren
OL
l_int|100
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Get current volume &n;&t;&t;&t;&t;&t;&t; */
(brace
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|gus_ramp_range
(paren
l_int|65
comma
l_int|4065
)paren
suffix:semicolon
id|gus_ramp_rate
(paren
l_int|0
comma
l_int|63
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Fastest possible rate &n;&t;&t;&t;&t; */
id|gus_rampon
(paren
l_int|0x20
op_or
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Ramp down, once, irq &n;&t;&t;&t;&t; */
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
id|VMODE_HALT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMODE_PCM_STOP
suffix:colon
id|pcm_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Requires extensive processing &n;&t;&t;&t;&t; */
r_case
id|LMODE_PCM
suffix:colon
(brace
r_int
id|orig_qlen
op_assign
id|pcm_qlen
suffix:semicolon
id|pcm_qlen
op_decrement
suffix:semicolon
id|pcm_head
op_assign
(paren
id|pcm_head
op_plus
l_int|1
)paren
op_mod
id|pcm_nblk
suffix:semicolon
r_if
c_cond
(paren
id|pcm_qlen
)paren
(brace
id|play_next_pcm_block
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * Out of data. Just stop the voice &n;&t;&t;&t;&t; */
id|gus_voice_off
(paren
)paren
suffix:semicolon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|pcm_active
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_qlen
op_eq
id|pcm_nblk
)paren
(brace
id|DMAbuf_outputintr
(paren
id|gus_devnum
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_volume_irq
id|do_volume_irq
(paren
r_int
id|voice
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|mode
comma
id|parm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DISABLE_INTR
(paren
id|flags
)paren
suffix:semicolon
id|gus_select_voice
(paren
id|voice
)paren
suffix:semicolon
id|tmp
op_assign
id|gus_read8
(paren
l_int|0x0d
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Disable volume ramp IRQ &n;&t;&t;&t;&t; */
id|gus_write8
(paren
l_int|0x0d
comma
id|tmp
)paren
suffix:semicolon
id|mode
op_assign
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_mode
op_assign
l_int|0
suffix:semicolon
id|parm
op_assign
id|voices
(braket
id|voice
)braket
dot
id|volume_irq_parm
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|VMODE_HALT
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * Decay phase finished &n;&t;&t;&t;&t; */
id|gus_voice_init
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VMODE_ENVELOPE
suffix:colon
id|gus_rampoff
(paren
)paren
suffix:semicolon
id|step_envelope
(paren
id|voice
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VMODE_START_NOTE
suffix:colon
id|guswave_start_note2
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|note_pending
comma
id|voices
(braket
id|voice
)braket
dot
id|volume_pending
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|kill_pending
)paren
id|guswave_kill_note
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_ge
l_int|0
)paren
(brace
id|guswave_set_instr
(paren
id|voices
(braket
id|voice
)braket
dot
id|dev_pending
comma
id|voice
comma
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
)paren
suffix:semicolon
id|voices
(braket
id|voice
)braket
dot
id|sample_pending
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|RESTORE_INTR
(paren
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|gus_voice_irq
id|gus_voice_irq
(paren
r_void
)paren
(brace
r_int
r_int
id|wave_ignore
op_assign
l_int|0
comma
id|volume_ignore
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|voice_bit
suffix:semicolon
r_int
r_char
id|src
comma
id|voice
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|src
op_assign
id|gus_read8
(paren
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Get source info &n;&t;&t;&t;&t; */
id|voice
op_assign
id|src
op_amp
l_int|0x1f
suffix:semicolon
id|src
op_and_assign
l_int|0xc0
suffix:semicolon
r_if
c_cond
(paren
id|src
op_eq
(paren
l_int|0x80
op_or
l_int|0x40
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * No interrupt &n;&t;&t;&t;&t; */
id|voice_bit
op_assign
l_int|1
op_lshift
id|voice
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|src
op_amp
l_int|0x80
)paren
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Wave IRQ pending &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|wave_ignore
op_amp
id|voice_bit
)paren
op_logical_and
id|voice
OL
id|nr_voices
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * Not done&n;&t;&t;&t;&t;&t;&t;&t;&t; * yet &n;&t;&t;&t;&t;&t;&t;&t;&t; */
(brace
id|wave_ignore
op_or_assign
id|voice_bit
suffix:semicolon
id|do_loop_irq
(paren
id|voice
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|src
op_amp
l_int|0x40
)paren
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Volume IRQ pending &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|volume_ignore
op_amp
id|voice_bit
)paren
op_logical_and
id|voice
OL
id|nr_voices
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;&t;&t; * Not done&n;&t;&t;&t;&t;&t;&t;&t;&t; * yet &n;&t;&t;&t;&t;&t;&t;&t;&t; */
(brace
id|volume_ignore
op_or_assign
id|voice_bit
suffix:semicolon
id|do_volume_irq
(paren
id|voice
)paren
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|guswave_dma_irq
id|guswave_dma_irq
(paren
r_void
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|status
op_assign
id|gus_look8
(paren
l_int|0x41
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Get DMA IRQ Status &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * DMA Irq pending &n;&t;&t;&t;&t; */
r_switch
c_cond
(paren
id|active_device
)paren
(brace
r_case
id|GUS_DEV_WAVE
suffix:colon
r_if
c_cond
(paren
id|SOMEONE_WAITING
(paren
id|dram_sleeper
comma
id|dram_sleep_flag
)paren
)paren
id|WAKE_UP
(paren
id|dram_sleeper
comma
id|dram_sleep_flag
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GUS_DEV_PCM_CONTINUE
suffix:colon
id|gus_transfer_output_block
(paren
id|pcm_current_dev
comma
id|pcm_current_buf
comma
id|pcm_current_count
comma
id|pcm_current_intrflag
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GUS_DEV_PCM_DONE
suffix:colon
r_if
c_cond
(paren
id|pcm_qlen
OL
id|pcm_nblk
)paren
(brace
id|DMAbuf_outputintr
(paren
id|gus_devnum
comma
id|pcm_qlen
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
id|status
op_assign
id|gus_look8
(paren
l_int|0x49
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Get Sampling IRQ Status &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
multiline_comment|/* &n;&t;&t;&t;&t; * Sampling Irq pending &n;&t;&t;&t;&t; */
(brace
id|DMAbuf_inputintr
(paren
id|gus_devnum
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
