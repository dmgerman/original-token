multiline_comment|/*&n; *  linux/drivers/sound/vidc.c&n; *&n; *  Copyright (C) 1997-2000 by Russell King &lt;rmk@arm.linux.org.uk&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  VIDC20 audio driver.&n; *&n; * The VIDC20 sound hardware consists of the VIDC20 itself, a DAC and a DMA&n; * engine.  The DMA transfers fixed-format (16-bit little-endian linear)&n; * samples to the VIDC20, which then transfers this data serially to the&n; * DACs.  The samplerate is controlled by the VIDC.&n; *&n; * We currently support a mixer device, but it is currently non-functional.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/hardware/iomd.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &quot;vidc.h&quot;
macro_line|#ifndef _SIOC_TYPE
DECL|macro|_SIOC_TYPE
mdefine_line|#define _SIOC_TYPE(x)&t;_IOC_TYPE(x)
macro_line|#endif
macro_line|#ifndef _SIOC_NR
DECL|macro|_SIOC_NR
mdefine_line|#define _SIOC_NR(x)&t;_IOC_NR(x)
macro_line|#endif
DECL|macro|VIDC_SOUND_CLOCK
mdefine_line|#define VIDC_SOUND_CLOCK&t;(250000)
multiline_comment|/*&n; * When using SERIAL SOUND mode (external DAC), the number of physical&n; * channels is fixed at 2.&n; */
DECL|variable|vidc_busy
r_static
r_int
id|vidc_busy
suffix:semicolon
DECL|variable|vidc_adev
r_static
r_int
id|vidc_adev
suffix:semicolon
DECL|variable|vidc_audio_rate
r_static
r_int
id|vidc_audio_rate
suffix:semicolon
DECL|variable|vidc_audio_format
r_static
r_char
id|vidc_audio_format
suffix:semicolon
DECL|variable|vidc_audio_channels
r_static
r_char
id|vidc_audio_channels
suffix:semicolon
DECL|variable|vidc_level_l
r_static
r_int
r_char
id|vidc_level_l
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
l_int|85
comma
multiline_comment|/* master&t;*/
l_int|50
comma
multiline_comment|/* bass&t;&t;*/
l_int|50
comma
multiline_comment|/* treble&t;*/
l_int|0
comma
multiline_comment|/* synth&t;*/
l_int|75
comma
multiline_comment|/* pcm&t;&t;*/
l_int|0
comma
multiline_comment|/* speaker&t;*/
l_int|100
comma
multiline_comment|/* ext line&t;*/
l_int|0
comma
multiline_comment|/* mic&t;&t;*/
l_int|100
comma
multiline_comment|/* CD&t;&t;*/
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|vidc_level_r
r_static
r_int
r_char
id|vidc_level_r
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
l_int|85
comma
multiline_comment|/* master&t;*/
l_int|50
comma
multiline_comment|/* bass&t;&t;*/
l_int|50
comma
multiline_comment|/* treble&t;*/
l_int|0
comma
multiline_comment|/* synth&t;*/
l_int|75
comma
multiline_comment|/* pcm&t;&t;*/
l_int|0
comma
multiline_comment|/* speaker&t;*/
l_int|100
comma
multiline_comment|/* ext line&t;*/
l_int|0
comma
multiline_comment|/* mic&t;&t;*/
l_int|100
comma
multiline_comment|/* CD&t;&t;*/
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|vidc_audio_volume_l
r_static
r_int
r_int
id|vidc_audio_volume_l
suffix:semicolon
multiline_comment|/* left PCM vol, 0 - 65536 */
DECL|variable|vidc_audio_volume_r
r_static
r_int
r_int
id|vidc_audio_volume_r
suffix:semicolon
multiline_comment|/* right PCM vol, 0 - 65536 */
DECL|variable|old_mksound
r_static
r_void
(paren
op_star
id|old_mksound
)paren
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|kd_mksound
)paren
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
suffix:semicolon
r_extern
r_void
id|vidc_update_filler
c_func
(paren
r_int
id|bits
comma
r_int
id|channels
)paren
suffix:semicolon
r_static
r_void
DECL|function|vidc_mksound
id|vidc_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
singleline_comment|//&t;printk(&quot;BEEP - %d %d!&bslash;n&quot;, hz, ticks);
)brace
r_static
r_void
DECL|function|vidc_mixer_set
id|vidc_mixer_set
c_func
(paren
r_int
id|mdev
comma
r_int
r_int
id|level
)paren
(brace
r_int
r_int
id|lev_l
op_assign
id|level
op_amp
l_int|0x007f
suffix:semicolon
r_int
r_int
id|lev_r
op_assign
(paren
id|level
op_amp
l_int|0x7f00
)paren
op_rshift
l_int|8
suffix:semicolon
r_int
r_int
id|mlev_l
comma
id|mlev_r
suffix:semicolon
r_if
c_cond
(paren
id|lev_l
OG
l_int|100
)paren
id|lev_l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|lev_r
OG
l_int|100
)paren
id|lev_r
op_assign
l_int|100
suffix:semicolon
DECL|macro|SCALE
mdefine_line|#define SCALE(lev,master)&t;((lev) * (master) * 65536 / 10000)
id|mlev_l
op_assign
id|vidc_level_l
(braket
id|SOUND_MIXER_VOLUME
)braket
suffix:semicolon
id|mlev_r
op_assign
id|vidc_level_r
(braket
id|SOUND_MIXER_VOLUME
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|mdev
)paren
(brace
r_case
id|SOUND_MIXER_VOLUME
suffix:colon
r_case
id|SOUND_MIXER_PCM
suffix:colon
id|vidc_level_l
(braket
id|mdev
)braket
op_assign
id|lev_l
suffix:semicolon
id|vidc_level_r
(braket
id|mdev
)braket
op_assign
id|lev_r
suffix:semicolon
id|vidc_audio_volume_l
op_assign
id|SCALE
c_func
(paren
id|lev_l
comma
id|mlev_l
)paren
suffix:semicolon
id|vidc_audio_volume_r
op_assign
id|SCALE
c_func
(paren
id|lev_r
comma
id|mlev_r
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;VIDC: PCM vol %05X %05X&bslash;n&quot;, vidc_audio_volume_l, vidc_audio_volume_r);*/
r_break
suffix:semicolon
)brace
DECL|macro|SCALE
macro_line|#undef SCALE
)brace
DECL|function|vidc_mixer_ioctl
r_static
r_int
id|vidc_mixer_ioctl
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|mdev
suffix:semicolon
r_if
c_cond
(paren
id|_SIOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
l_char|&squot;M&squot;
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|mdev
op_assign
id|_SIOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_SIOC_WRITE
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|mdev
OL
id|SOUND_MIXER_NRDEVICES
)paren
id|vidc_mixer_set
c_func
(paren
id|mdev
comma
id|val
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return parameters&n;&t; */
r_switch
c_cond
(paren
id|mdev
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
id|val
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_SYNTH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
id|val
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_SYNTH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|mdev
OL
id|SOUND_MIXER_NRDEVICES
)paren
id|val
op_assign
id|vidc_level_l
(braket
id|mdev
)braket
op_or
id|vidc_level_r
(braket
id|mdev
)braket
op_lshift
l_int|8
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|vidc_audio_set_format
r_static
r_int
r_int
id|vidc_audio_set_format
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|fmt
)paren
(brace
r_switch
c_cond
(paren
id|fmt
)paren
(brace
r_default
suffix:colon
id|fmt
op_assign
id|AFMT_S16_LE
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
r_case
id|AFMT_S8
suffix:colon
r_case
id|AFMT_S16_LE
suffix:colon
id|vidc_audio_format
op_assign
id|fmt
suffix:semicolon
id|vidc_update_filler
c_func
(paren
id|vidc_audio_format
comma
id|vidc_audio_channels
)paren
suffix:semicolon
r_case
id|AFMT_QUERY
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|vidc_audio_format
suffix:semicolon
)brace
DECL|function|vidc_audio_set_speed
r_static
r_int
id|vidc_audio_set_speed
c_func
(paren
r_int
id|dev
comma
r_int
id|rate
)paren
(brace
r_if
c_cond
(paren
id|rate
)paren
(brace
r_int
r_int
id|hwctrl
comma
id|hwrate
suffix:semicolon
r_int
r_int
id|newsize
comma
id|new2size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have selected 44.1kHz, use the DAC clock.&n;&t;&t; */
r_if
c_cond
(paren
l_int|0
op_logical_and
id|rate
op_eq
l_int|44100
)paren
(brace
id|hwctrl
op_assign
l_int|0x00000002
suffix:semicolon
id|hwrate
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|hwctrl
op_assign
l_int|0x00000003
suffix:semicolon
id|hwrate
op_assign
(paren
(paren
(paren
id|VIDC_SOUND_CLOCK
op_star
l_int|2
)paren
op_div
id|rate
)paren
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hwrate
OL
l_int|3
)paren
id|hwrate
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|hwrate
OG
l_int|255
)paren
id|hwrate
op_assign
l_int|255
suffix:semicolon
id|rate
op_assign
id|VIDC_SOUND_CLOCK
op_div
id|hwrate
suffix:semicolon
)brace
id|outl
c_func
(paren
l_int|0xb0000000
op_or
(paren
id|hwrate
op_minus
l_int|2
)paren
comma
id|IO_VIDC_BASE
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0xb1000000
op_or
id|hwctrl
comma
id|IO_VIDC_BASE
)paren
suffix:semicolon
id|newsize
op_assign
(paren
l_int|10000
op_div
id|hwrate
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OL
l_int|208
)paren
id|newsize
op_assign
l_int|208
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OG
l_int|4096
)paren
id|newsize
op_assign
l_int|4096
suffix:semicolon
r_for
c_loop
(paren
id|new2size
op_assign
l_int|128
suffix:semicolon
id|new2size
OL
id|newsize
suffix:semicolon
id|new2size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new2size
op_minus
id|newsize
OG
id|newsize
op_minus
(paren
id|new2size
op_rshift
l_int|1
)paren
)paren
id|new2size
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|new2size
OG
l_int|4096
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VIDC: error: dma buffer (%d) %d &gt; 4K&bslash;n&quot;
comma
id|newsize
comma
id|new2size
)paren
suffix:semicolon
id|new2size
op_assign
l_int|4096
suffix:semicolon
)brace
id|dma_bufsize
op_assign
id|new2size
suffix:semicolon
id|vidc_audio_rate
op_assign
id|rate
suffix:semicolon
)brace
r_return
id|vidc_audio_rate
suffix:semicolon
)brace
DECL|function|vidc_audio_set_channels
r_static
r_int
id|vidc_audio_set_channels
c_func
(paren
r_int
id|dev
comma
r_int
id|channels
)paren
(brace
r_switch
c_cond
(paren
id|channels
)paren
(brace
r_default
suffix:colon
id|channels
op_assign
l_int|2
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
id|vidc_audio_channels
op_assign
id|channels
suffix:semicolon
id|vidc_update_filler
c_func
(paren
id|vidc_audio_format
comma
id|vidc_audio_channels
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|vidc_audio_channels
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the device&n; */
DECL|function|vidc_audio_open
r_static
r_int
id|vidc_audio_open
c_func
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
multiline_comment|/* This audio device does not have recording capability */
r_if
c_cond
(paren
id|mode
op_eq
id|OPEN_READ
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|vidc_busy
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|vidc_busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the device&n; */
DECL|function|vidc_audio_close
r_static
r_void
id|vidc_audio_close
c_func
(paren
r_int
id|dev
)paren
(brace
id|vidc_busy
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Output a block via DMA to sound device.&n; *&n; * We just set the DMA start and count; the DMA interrupt routine&n; * will take care of formatting the samples (via the appropriate&n; * vidc_filler routine), and flag via vidc_audio_dma_interrupt when&n; * more data is required.&n; */
r_static
r_void
DECL|function|vidc_audio_output_block
id|vidc_audio_output_block
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|total_count
comma
r_int
id|one
)paren
(brace
r_struct
id|dma_buffparms
op_star
id|dmap
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dma_start
op_assign
id|buf
op_minus
(paren
r_int
r_int
)paren
id|dmap-&gt;raw_buf_phys
op_plus
(paren
r_int
r_int
)paren
id|dmap-&gt;raw_buf
suffix:semicolon
id|dma_count
op_assign
id|total_count
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|vidc_audio_start_input
id|vidc_audio_start_input
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
)paren
(brace
)brace
DECL|function|vidc_audio_prepare_for_input
r_static
r_int
id|vidc_audio_prepare_for_input
c_func
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|vidc_audio_dma_interrupt
r_static
r_void
id|vidc_audio_dma_interrupt
c_func
(paren
r_void
)paren
(brace
id|DMAbuf_outputintr
c_func
(paren
id|vidc_adev
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare for outputting samples.&n; *&n; * Each buffer that will be passed will be `bsize&squot; bytes long,&n; * with a total of `bcount&squot; buffers.&n; */
DECL|function|vidc_audio_prepare_for_output
r_static
r_int
id|vidc_audio_prepare_for_output
c_func
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_struct
id|audio_operations
op_star
id|adev
op_assign
id|audio_devs
(braket
id|dev
)braket
suffix:semicolon
id|dma_interrupt
op_assign
l_int|NULL
suffix:semicolon
id|adev-&gt;dmap_out-&gt;flags
op_or_assign
id|DMA_NODMA
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Stop our current operation.&n; */
DECL|function|vidc_audio_reset
r_static
r_void
id|vidc_audio_reset
c_func
(paren
r_int
id|dev
)paren
(brace
id|dma_interrupt
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|vidc_audio_local_qlen
r_static
r_int
id|vidc_audio_local_qlen
c_func
(paren
r_int
id|dev
)paren
(brace
r_return
multiline_comment|/*dma_count !=*/
l_int|0
suffix:semicolon
)brace
DECL|function|vidc_audio_trigger
r_static
r_void
id|vidc_audio_trigger
c_func
(paren
r_int
id|dev
comma
r_int
id|enable_bits
)paren
(brace
r_struct
id|audio_operations
op_star
id|adev
op_assign
id|audio_devs
(braket
id|dev
)braket
suffix:semicolon
r_if
c_cond
(paren
id|enable_bits
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|adev-&gt;flags
op_amp
id|DMA_ACTIVE
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* prevent recusion */
id|adev-&gt;flags
op_or_assign
id|DMA_ACTIVE
suffix:semicolon
id|dma_interrupt
op_assign
id|vidc_audio_dma_interrupt
suffix:semicolon
id|vidc_sound_dma_irq
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DMA_CR_E
op_or
l_int|0x10
comma
id|IOMD_SD0CR
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|vidc_audio_driver
r_static
r_struct
id|audio_driver
id|vidc_audio_driver
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|vidc_audio_open
comma
id|close
suffix:colon
id|vidc_audio_close
comma
id|output_block
suffix:colon
id|vidc_audio_output_block
comma
id|start_input
suffix:colon
id|vidc_audio_start_input
comma
id|prepare_for_input
suffix:colon
id|vidc_audio_prepare_for_input
comma
id|prepare_for_output
suffix:colon
id|vidc_audio_prepare_for_output
comma
id|halt_io
suffix:colon
id|vidc_audio_reset
comma
id|local_qlen
suffix:colon
id|vidc_audio_local_qlen
comma
id|trigger
suffix:colon
id|vidc_audio_trigger
comma
id|set_speed
suffix:colon
id|vidc_audio_set_speed
comma
id|set_bits
suffix:colon
id|vidc_audio_set_format
comma
id|set_channels
suffix:colon
id|vidc_audio_set_channels
)brace
suffix:semicolon
DECL|variable|vidc_mixer_operations
r_static
r_struct
id|mixer_operations
id|vidc_mixer_operations
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|id
suffix:colon
l_string|&quot;VIDC&quot;
comma
id|name
suffix:colon
l_string|&quot;VIDCsound&quot;
comma
id|ioctl
suffix:colon
id|vidc_mixer_ioctl
)brace
suffix:semicolon
DECL|function|vidc_update_filler
r_void
id|vidc_update_filler
c_func
(paren
r_int
id|format
comma
r_int
id|channels
)paren
(brace
DECL|macro|TYPE
mdefine_line|#define TYPE(fmt,ch) (((fmt)&lt;&lt;2) | ((ch)&amp;3))
r_switch
c_cond
(paren
id|TYPE
c_func
(paren
id|format
comma
id|channels
)paren
)paren
(brace
r_default
suffix:colon
r_case
id|TYPE
c_func
(paren
id|AFMT_U8
comma
l_int|1
)paren
suffix:colon
id|vidc_filler
op_assign
id|vidc_fill_1x8_u
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE
c_func
(paren
id|AFMT_U8
comma
l_int|2
)paren
suffix:colon
id|vidc_filler
op_assign
id|vidc_fill_2x8_u
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE
c_func
(paren
id|AFMT_S8
comma
l_int|1
)paren
suffix:colon
id|vidc_filler
op_assign
id|vidc_fill_1x8_s
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE
c_func
(paren
id|AFMT_S8
comma
l_int|2
)paren
suffix:colon
id|vidc_filler
op_assign
id|vidc_fill_2x8_s
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE
c_func
(paren
id|AFMT_S16_LE
comma
l_int|1
)paren
suffix:colon
id|vidc_filler
op_assign
id|vidc_fill_1x16_s
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE
c_func
(paren
id|AFMT_S16_LE
comma
l_int|2
)paren
suffix:colon
id|vidc_filler
op_assign
id|vidc_fill_2x16_s
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|attach_vidc
r_static
r_void
id|__init
id|attach_vidc
c_func
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|i
comma
id|adev
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;VIDC %d-bit sound&quot;
comma
id|hw_config-&gt;card_subtype
)paren
suffix:semicolon
id|conf_printf
c_func
(paren
id|name
comma
id|hw_config
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dma_buf
comma
l_int|0
comma
r_sizeof
(paren
id|dma_buf
)paren
)paren
suffix:semicolon
id|adev
op_assign
id|sound_install_audiodrv
c_func
(paren
id|AUDIO_DRIVER_VERSION
comma
id|name
comma
op_amp
id|vidc_audio_driver
comma
r_sizeof
(paren
id|vidc_audio_driver
)paren
comma
id|DMA_AUTOMODE
comma
id|AFMT_U8
op_or
id|AFMT_S8
op_or
id|AFMT_S16_LE
comma
l_int|NULL
comma
id|hw_config-&gt;dma
comma
id|hw_config-&gt;dma2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adev
OL
l_int|0
)paren
r_goto
id|audio_failed
suffix:semicolon
multiline_comment|/*&n;&t; * 1024 bytes =&gt; 64 buffers&n;&t; */
id|audio_devs
(braket
id|adev
)braket
op_member_access_from_pointer
id|min_fragment
op_assign
l_int|10
suffix:semicolon
id|audio_devs
(braket
id|adev
)braket
op_member_access_from_pointer
id|mixer_dev
op_assign
id|num_mixers
suffix:semicolon
id|audio_devs
(braket
id|adev
)braket
op_member_access_from_pointer
id|mixer_dev
op_assign
id|sound_install_mixer
c_func
(paren
id|MIXER_DRIVER_VERSION
comma
id|name
comma
op_amp
id|vidc_mixer_operations
comma
r_sizeof
(paren
id|vidc_mixer_operations
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|adev
)braket
op_member_access_from_pointer
id|mixer_dev
OL
l_int|0
)paren
r_goto
id|mixer_failed
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dma_buf
(braket
id|i
)braket
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_buf
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t allocate required buffers&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_goto
id|mem_failed
suffix:semicolon
)brace
id|dma_pbuf
(braket
id|i
)braket
op_assign
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
id|dma_buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sound_alloc_dma
c_func
(paren
id|hw_config-&gt;dma
comma
id|hw_config-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: DMA %d is in  use&bslash;n&quot;
comma
id|name
comma
id|hw_config-&gt;dma
)paren
suffix:semicolon
r_goto
id|dma_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hw_config-&gt;irq
comma
id|vidc_sound_dma_irq
comma
l_int|0
comma
id|hw_config-&gt;name
comma
op_amp
id|dma_start
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: IRQ %d is in use&bslash;n&quot;
comma
id|name
comma
id|hw_config-&gt;irq
)paren
suffix:semicolon
r_goto
id|irq_failed
suffix:semicolon
)brace
id|old_mksound
op_assign
id|kd_mksound
suffix:semicolon
id|kd_mksound
op_assign
id|vidc_mksound
suffix:semicolon
id|vidc_adev
op_assign
id|adev
suffix:semicolon
id|vidc_mixer_set
c_func
(paren
id|SOUND_MIXER_VOLUME
comma
(paren
l_int|85
op_or
l_int|85
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|irq_failed
suffix:colon
id|sound_free_dma
c_func
(paren
id|hw_config-&gt;dma
)paren
suffix:semicolon
id|dma_failed
suffix:colon
id|mem_failed
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|free_page
c_func
(paren
id|dma_buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|sound_unload_mixerdev
c_func
(paren
id|audio_devs
(braket
id|adev
)braket
op_member_access_from_pointer
id|mixer_dev
)paren
suffix:semicolon
id|mixer_failed
suffix:colon
id|sound_unload_audiodev
c_func
(paren
id|adev
)paren
suffix:semicolon
id|audio_failed
suffix:colon
r_return
suffix:semicolon
)brace
DECL|function|probe_vidc
r_static
r_int
id|__init
id|probe_vidc
c_func
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
id|hw_config-&gt;irq
op_assign
id|IRQ_DMAS0
suffix:semicolon
id|hw_config-&gt;dma
op_assign
id|DMA_VIRTUAL_SOUND
suffix:semicolon
id|hw_config-&gt;dma2
op_assign
op_minus
l_int|1
suffix:semicolon
id|hw_config-&gt;card_subtype
op_assign
l_int|16
suffix:semicolon
id|hw_config-&gt;name
op_assign
l_string|&quot;VIDC20&quot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|unload_vidc
r_static
r_void
id|__exit
id|unload_vidc
c_func
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
id|i
comma
id|adev
op_assign
id|vidc_adev
suffix:semicolon
id|vidc_adev
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|old_mksound
)paren
id|kd_mksound
op_assign
id|old_mksound
suffix:semicolon
id|free_irq
c_func
(paren
id|hw_config-&gt;irq
comma
op_amp
id|dma_start
)paren
suffix:semicolon
id|sound_free_dma
c_func
(paren
id|hw_config-&gt;dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adev
op_ge
l_int|0
)paren
(brace
id|sound_unload_mixerdev
c_func
(paren
id|audio_devs
(braket
id|adev
)braket
op_member_access_from_pointer
id|mixer_dev
)paren
suffix:semicolon
id|sound_unload_audiodev
c_func
(paren
id|adev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|free_page
c_func
(paren
id|dma_buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|variable|cfg
r_static
r_struct
id|address_info
id|cfg
suffix:semicolon
DECL|function|init_vidc
r_static
r_int
id|__init
id|init_vidc
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|probe_vidc
c_func
(paren
op_amp
id|cfg
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|attach_vidc
c_func
(paren
op_amp
id|cfg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_vidc
r_static
r_void
id|__exit
id|cleanup_vidc
c_func
(paren
r_void
)paren
(brace
id|unload_vidc
c_func
(paren
op_amp
id|cfg
)paren
suffix:semicolon
)brace
DECL|variable|init_vidc
id|module_init
c_func
(paren
id|init_vidc
)paren
suffix:semicolon
DECL|variable|cleanup_vidc
id|module_exit
c_func
(paren
id|cleanup_vidc
)paren
suffix:semicolon
eof
