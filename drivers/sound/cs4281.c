singleline_comment|//*****************************************************************************
singleline_comment|//
singleline_comment|//      &quot;cs4281.c&quot; --  Cirrus Logic-Crystal CS4281 linux audio driver.
singleline_comment|//
singleline_comment|//      Copyright (C) 2000  Cirrus Logic Corp.  
singleline_comment|//            -- adapted from drivers by Thomas Sailer, 
singleline_comment|//            -- but don&squot;t bug him; Problems should go to:
singleline_comment|//            -- gw boynton (wesb@crystal.cirrus.com) or
singleline_comment|//            -- tom woller (twoller@crystal.cirrus.com).
singleline_comment|//
singleline_comment|//      This program is free software; you can redistribute it and/or modify
singleline_comment|//      it under the terms of the GNU General Public License as published by
singleline_comment|//      the Free Software Foundation; either version 2 of the License, or
singleline_comment|//      (at your option) any later version.
singleline_comment|//
singleline_comment|//      This program is distributed in the hope that it will be useful,
singleline_comment|//      but WITHOUT ANY WARRANTY; without even the implied warranty of
singleline_comment|//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
singleline_comment|//      GNU General Public License for more details.
singleline_comment|//
singleline_comment|//      You should have received a copy of the GNU General Public License
singleline_comment|//      along with this program; if not, write to the Free Software
singleline_comment|//      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
singleline_comment|//
singleline_comment|// Module command line parameters:
singleline_comment|//   none
singleline_comment|//
singleline_comment|//  Supported devices:
singleline_comment|//  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible
singleline_comment|//  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
singleline_comment|//  /dev/midi   simple MIDI UART interface, no ioctl
singleline_comment|//
singleline_comment|// Modification History
singleline_comment|// 08/20/00 trw - silence and no stopping DAC until release
singleline_comment|// 08/23/00 trw - added CS_DBG statements, fix interrupt hang issue on DAC stop.
singleline_comment|// 09/18/00 trw - added 16bit only record with conversion 
singleline_comment|// 09/24/00 trw - added Enhanced Full duplex (separate simultaneous 
singleline_comment|//                capture/playback rates)
singleline_comment|// 10/03/00 trw - fixed mmap (fixed GRECORD and the XMMS mmap test plugin  
singleline_comment|//                libOSSm.so)
singleline_comment|// 10/11/00 trw - modified for 2.4.0-test9 kernel enhancements (NR_MAP removal)
singleline_comment|// 11/03/00 trw - fixed interrupt loss/stutter, added debug.
singleline_comment|// 11/10/00 bkz - added __devinit to cs4281_hw_init()
singleline_comment|//
singleline_comment|// *****************************************************************************
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
singleline_comment|//#include &lt;linux/vmalloc.h&gt;
macro_line|#include &quot;dm.h&quot;
macro_line|#include &quot;cs4281_hwdefs.h&quot;
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|macro|OSS_DOCUMENTED_MIXER_SEMANTICS
macro_line|#undef OSS_DOCUMENTED_MIXER_SEMANTICS
singleline_comment|// --------------------------------------------------------------------- 
macro_line|#ifndef PCI_VENDOR_ID_CIRRUS
DECL|macro|PCI_VENDOR_ID_CIRRUS
mdefine_line|#define PCI_VENDOR_ID_CIRRUS          0x1013
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_CRYSTAL_CS4281
DECL|macro|PCI_DEVICE_ID_CRYSTAL_CS4281
mdefine_line|#define PCI_DEVICE_ID_CRYSTAL_CS4281  0x6005
macro_line|#endif
DECL|macro|CS4281_MAGIC
mdefine_line|#define CS4281_MAGIC  ((PCI_DEVICE_ID_CRYSTAL_CS4281&lt;&lt;16) | PCI_VENDOR_ID_CIRRUS)
singleline_comment|// Turn on/off debugging compilation by using 1/0 respectively for CSDEBUG
singleline_comment|//
DECL|macro|CSDEBUG_INTERFACE
mdefine_line|#define CSDEBUG_INTERFACE 1
DECL|macro|CSDEBUG
mdefine_line|#define CSDEBUG 1
singleline_comment|//
singleline_comment|// CSDEBUG is usual mode is set to 1, then use the
singleline_comment|// cs_debuglevel and cs_debugmask to turn on or off debugging.
singleline_comment|// Debug level of 1 has been defined to be kernel errors and info
singleline_comment|// that should be printed on any released driver.
singleline_comment|//
macro_line|#if CSDEBUG
r_extern
r_int
r_int
id|cs_debugmask
suffix:semicolon
r_extern
r_int
r_int
id|cs_debuglevel
suffix:semicolon
DECL|macro|CS_DBGOUT
mdefine_line|#define CS_DBGOUT(mask,level,x) if((cs_debuglevel &gt;= (level)) &amp;&amp; ((mask) &amp; cs_debugmask) ) {x;}
macro_line|#else
DECL|macro|CS_DBGOUT
mdefine_line|#define CS_DBGOUT(mask,level,x)
macro_line|#endif
singleline_comment|//
singleline_comment|// cs_debugmask areas
singleline_comment|//
DECL|macro|CS_INIT
mdefine_line|#define CS_INIT&t; &t;0x00000001&t;
singleline_comment|// initialization and probe functions
DECL|macro|CS_ERROR
mdefine_line|#define CS_ERROR &t;0x00000002&t;
singleline_comment|// tmp debugging bit placeholder
DECL|macro|CS_INTERRUPT
mdefine_line|#define CS_INTERRUPT&t;0x00000004&t;
singleline_comment|// interrupt handler (separate from all other)
DECL|macro|CS_FUNCTION
mdefine_line|#define CS_FUNCTION &t;0x00000008&t;
singleline_comment|// enter/leave functions
DECL|macro|CS_WAVE_WRITE
mdefine_line|#define CS_WAVE_WRITE &t;0x00000010&t;
singleline_comment|// write information for wave
DECL|macro|CS_WAVE_READ
mdefine_line|#define CS_WAVE_READ &t;0x00000020&t;
singleline_comment|// read information for wave
DECL|macro|CS_MIDI_WRITE
mdefine_line|#define CS_MIDI_WRITE &t;0x00000040&t;
singleline_comment|// write information for midi
DECL|macro|CS_MIDI_READ
mdefine_line|#define CS_MIDI_READ &t;0x00000080&t;
singleline_comment|// read information for midi
DECL|macro|CS_MPU401_WRITE
mdefine_line|#define CS_MPU401_WRITE 0x00000100&t;
singleline_comment|// write information for mpu401
DECL|macro|CS_MPU401_READ
mdefine_line|#define CS_MPU401_READ &t;0x00000200&t;
singleline_comment|// read information for mpu401
DECL|macro|CS_OPEN
mdefine_line|#define CS_OPEN&t;&t;0x00000400&t;
singleline_comment|// all open functions in the driver
DECL|macro|CS_RELEASE
mdefine_line|#define CS_RELEASE&t;0x00000800&t;
singleline_comment|// all release functions in the driver
DECL|macro|CS_PARMS
mdefine_line|#define CS_PARMS&t;0x00001000&t;
singleline_comment|// functional and operational parameters
DECL|macro|CS_IOCTL
mdefine_line|#define CS_IOCTL&t;0x00002000&t;
singleline_comment|// ioctl (non-mixer)
DECL|macro|CS_TMP
mdefine_line|#define CS_TMP&t;&t;0x10000000&t;
singleline_comment|// tmp debug mask bit
macro_line|#if CSDEBUG
DECL|variable|cs_debuglevel
r_static
r_int
r_int
id|cs_debuglevel
op_assign
l_int|1
suffix:semicolon
singleline_comment|// levels range from 1-9
DECL|variable|cs_debugmask
r_static
r_int
r_int
id|cs_debugmask
op_assign
id|CS_INIT
op_or
id|CS_ERROR
suffix:semicolon
singleline_comment|// use CS_DBGOUT with various mask values
macro_line|#if MODULE
id|MODULE_PARM
c_func
(paren
id|cs_debuglevel
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cs_debugmask
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
singleline_comment|// MIDI buffer sizes 
DECL|macro|MIDIINBUF
mdefine_line|#define MIDIINBUF  500
DECL|macro|MIDIOUTBUF
mdefine_line|#define MIDIOUTBUF 500
DECL|macro|FMODE_MIDI_SHIFT
mdefine_line|#define FMODE_MIDI_SHIFT 3
DECL|macro|FMODE_MIDI_READ
mdefine_line|#define FMODE_MIDI_READ  (FMODE_READ &lt;&lt; FMODE_MIDI_SHIFT)
DECL|macro|FMODE_MIDI_WRITE
mdefine_line|#define FMODE_MIDI_WRITE (FMODE_WRITE &lt;&lt; FMODE_MIDI_SHIFT)
DECL|macro|RSRCISIOREGION
mdefine_line|#define RSRCISIOREGION(dev,num) ((dev)-&gt;resource[(num)].start != 0 &amp;&amp; &bslash;&n;&t; ((dev)-&gt;resource[(num)].flags &amp; PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO)
DECL|macro|RSRCISMEMORYREGION
mdefine_line|#define RSRCISMEMORYREGION(dev,num) ((dev)-&gt;resource[(num)].start != 0 &amp;&amp; &bslash;&n;&t; ((dev)-&gt;resource[(num)].flags &amp; PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_MEMORY)
DECL|macro|RSRCADDRESS
mdefine_line|#define RSRCADDRESS(dev,num) ((dev)-&gt;resource[(num)].start)
DECL|macro|CS4281_MAJOR_VERSION
mdefine_line|#define CS4281_MAJOR_VERSION &t;1
DECL|macro|CS4281_MINOR_VERSION
mdefine_line|#define CS4281_MINOR_VERSION &t;1
macro_line|#ifdef __ia64__
DECL|macro|CS4281_ARCH
mdefine_line|#define CS4281_ARCH&t;     &t;64&t;
singleline_comment|//architecture key
macro_line|#else
DECL|macro|CS4281_ARCH
mdefine_line|#define CS4281_ARCH&t;     &t;32&t;
singleline_comment|//architecture key
macro_line|#endif
DECL|macro|CS_TYPE_ADC
mdefine_line|#define CS_TYPE_ADC 0
DECL|macro|CS_TYPE_DAC
mdefine_line|#define CS_TYPE_DAC 1
DECL|struct|cs4281_state
r_struct
id|cs4281_state
(brace
singleline_comment|// magic 
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
singleline_comment|// we keep the cards in a linked list 
DECL|member|next
r_struct
id|cs4281_state
op_star
id|next
suffix:semicolon
singleline_comment|// pcidev is needed to turn off the DDMA controller at driver shutdown 
DECL|member|pcidev
r_struct
id|pci_dev
op_star
id|pcidev
suffix:semicolon
singleline_comment|// soundcore stuff 
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
DECL|member|dev_mixer
r_int
id|dev_mixer
suffix:semicolon
DECL|member|dev_midi
r_int
id|dev_midi
suffix:semicolon
singleline_comment|// hardware resources 
DECL|member|pBA0phys
DECL|member|pBA1phys
r_int
r_int
id|pBA0phys
comma
id|pBA1phys
suffix:semicolon
DECL|member|pBA0
DECL|member|pBA1
r_char
op_star
id|pBA0
comma
op_star
id|pBA1
suffix:semicolon
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
singleline_comment|// mixer registers 
r_struct
(brace
DECL|member|vol
r_int
r_int
id|vol
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|recsrc
r_int
r_int
id|recsrc
suffix:semicolon
DECL|member|modcnt
r_int
r_int
id|modcnt
suffix:semicolon
DECL|member|micpreamp
r_int
r_int
id|micpreamp
suffix:semicolon
DECL|member|mix
)brace
id|mix
suffix:semicolon
singleline_comment|// wave stuff   
DECL|struct|properties
r_struct
id|properties
(brace
DECL|member|fmt
r_int
id|fmt
suffix:semicolon
DECL|member|fmt_original
r_int
id|fmt_original
suffix:semicolon
singleline_comment|// original requested format
DECL|member|channels
r_int
id|channels
suffix:semicolon
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|clkdiv
r_int
r_char
id|clkdiv
suffix:semicolon
DECL|member|prop_dac
DECL|member|prop_adc
)brace
id|prop_dac
comma
id|prop_adc
suffix:semicolon
DECL|member|conversion
r_int
id|conversion
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// conversion from 16 to 8 bit in progress
DECL|member|tmpbuff
r_void
op_star
id|tmpbuff
suffix:semicolon
singleline_comment|// tmp buffer for sample conversions
DECL|member|ena
r_int
id|ena
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_sem_adc
r_struct
id|semaphore
id|open_sem_adc
suffix:semicolon
DECL|member|open_sem_dac
r_struct
id|semaphore
id|open_sem_dac
suffix:semicolon
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|open_wait_adc
id|wait_queue_head_t
id|open_wait_adc
suffix:semicolon
DECL|member|open_wait_dac
id|wait_queue_head_t
id|open_wait_dac
suffix:semicolon
DECL|member|dmaaddr_tmpbuff
id|dma_addr_t
id|dmaaddr_tmpbuff
suffix:semicolon
DECL|member|buforder_tmpbuff
r_int
id|buforder_tmpbuff
suffix:semicolon
singleline_comment|// Log base 2 of &squot;rawbuf&squot; size in bytes..
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
singleline_comment|// Physical address of  
DECL|member|dmaaddr
id|dma_addr_t
id|dmaaddr
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
singleline_comment|// Log base 2 of &squot;rawbuf&squot; size in bytes..
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
singleline_comment|// # of &squot;fragments&squot; in the buffer.
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
singleline_comment|// Log base 2 of fragment size.
DECL|member|hwptr
DECL|member|swptr
r_int
id|hwptr
comma
id|swptr
suffix:semicolon
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
singleline_comment|// # bytes process since open.
DECL|member|blocks
r_int
id|blocks
suffix:semicolon
singleline_comment|// last returned blocks value GETOPTR
DECL|member|wakeup
r_int
id|wakeup
suffix:semicolon
singleline_comment|// interrupt occurred on block 
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
singleline_comment|// over/underrun 
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
singleline_comment|// redundant, but makes calculations easier 
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
singleline_comment|// 2**fragshift..
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
singleline_comment|// 2**buforder.
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
singleline_comment|// OSS stuff 
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// Buffer mapped in cs4281_mmap()?
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// prog_dmabuf_dac()/adc() successful?
DECL|member|endcleared
r_int
id|endcleared
suffix:colon
l_int|1
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// adc or dac buffer (CS_TYPE_XXX)
DECL|member|ossfragshift
r_int
id|ossfragshift
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|dma_dac
DECL|member|dma_adc
)brace
id|dma_dac
comma
id|dma_adc
suffix:semicolon
singleline_comment|// midi stuff 
r_struct
(brace
DECL|member|ird
DECL|member|iwr
DECL|member|icnt
r_int
id|ird
comma
id|iwr
comma
id|icnt
suffix:semicolon
DECL|member|ord
DECL|member|owr
DECL|member|ocnt
r_int
id|ord
comma
id|owr
comma
id|ocnt
suffix:semicolon
DECL|member|iwait
id|wait_queue_head_t
id|iwait
suffix:semicolon
DECL|member|owait
id|wait_queue_head_t
id|owait
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|ibuf
r_int
r_char
id|ibuf
(braket
id|MIDIINBUF
)braket
suffix:semicolon
DECL|member|obuf
r_int
r_char
id|obuf
(braket
id|MIDIOUTBUF
)braket
suffix:semicolon
DECL|member|midi
)brace
id|midi
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if CSDEBUG
singleline_comment|// DEBUG ROUTINES
DECL|macro|SOUND_MIXER_CS_GETDBGLEVEL
mdefine_line|#define SOUND_MIXER_CS_GETDBGLEVEL &t;_SIOWR(&squot;M&squot;,120, int)
DECL|macro|SOUND_MIXER_CS_SETDBGLEVEL
mdefine_line|#define SOUND_MIXER_CS_SETDBGLEVEL &t;_SIOWR(&squot;M&squot;,121, int)
DECL|macro|SOUND_MIXER_CS_GETDBGMASK
mdefine_line|#define SOUND_MIXER_CS_GETDBGMASK &t;_SIOWR(&squot;M&squot;,122, int)
DECL|macro|SOUND_MIXER_CS_SETDBGMASK
mdefine_line|#define SOUND_MIXER_CS_SETDBGMASK &t;_SIOWR(&squot;M&squot;,123, int)
DECL|macro|SNDCTL_DSP_CS_GETDBGLEVEL
mdefine_line|#define SNDCTL_DSP_CS_GETDBGLEVEL &t;_SIOWR(&squot;P&squot;, 50, int)
DECL|macro|SNDCTL_DSP_CS_SETDBGLEVEL
mdefine_line|#define SNDCTL_DSP_CS_SETDBGLEVEL &t;_SIOWR(&squot;P&squot;, 51, int)
DECL|macro|SNDCTL_DSP_CS_GETDBGMASK
mdefine_line|#define SNDCTL_DSP_CS_GETDBGMASK &t;_SIOWR(&squot;P&squot;, 52, int)
DECL|macro|SNDCTL_DSP_CS_SETDBGMASK
mdefine_line|#define SNDCTL_DSP_CS_SETDBGMASK &t;_SIOWR(&squot;P&squot;, 53, int)
DECL|function|printioctl
r_static
r_void
id|printioctl
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|vidx
suffix:semicolon
singleline_comment|// Index of mixtable1[] member is Device ID 
singleline_comment|// and must be &lt;= SOUND_MIXER_NRDEVICES.
singleline_comment|// Value of array member is index into s-&gt;mix.vol[]
r_static
r_const
r_int
r_char
id|mixtable1
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
l_int|1
comma
singleline_comment|// voice 
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
l_int|2
comma
singleline_comment|// AUX
(braket
id|SOUND_MIXER_CD
)braket
op_assign
l_int|3
comma
singleline_comment|// CD 
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
l_int|4
comma
singleline_comment|// Line 
(braket
id|SOUND_MIXER_SYNTH
)braket
op_assign
l_int|5
comma
singleline_comment|// FM
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
l_int|6
comma
singleline_comment|// Mic 
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
l_int|7
comma
singleline_comment|// Speaker 
(braket
id|SOUND_MIXER_RECLEV
)braket
op_assign
l_int|8
comma
singleline_comment|// Recording level 
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
l_int|9
singleline_comment|// Master Volume 
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|x
)paren
(brace
r_case
id|SOUND_MIXER_CS_GETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_GETDBGMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_GETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_GETDBGLEVEL:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_SETDBGMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_SETDBGLEVEL:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OSS_GETVERSION
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;OSS_GETVERSION:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SYNC:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETDUPLEX:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCAPS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_RESET:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_STEREO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CHANNELS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETFMTS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFMT:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_POST:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETTRIGGER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETTRIGGER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_NONBLOCK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETODELAY:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETIPTR:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOPTR:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SUBDIVIDE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_RATE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_CHANNELS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_BITS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_WRITE_FILTER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETSYNCRO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_FILTER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_GETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_GETDBGMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_GETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_GETDBGLEVEL:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_SETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_SETDBGMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_SETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CS_SETDBGLEVEL:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE1
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE1:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE2
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE2:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE3
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE3:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE4
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE4:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE5
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE5:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_INFO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_INFO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_OLD_MIXER_INFO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_OLD_MIXER_INFO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|x
)paren
)paren
(brace
r_case
id|SOUND_MIXER_VOLUME
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_VOLUME:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SPEAKER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_SPEAKER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECLEV:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_MIC:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_SYNTH:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECSRC:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_DEVMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_STEREODEVS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CAPS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
(paren
l_string|&quot;UNKNOWN IOCTL: 0x%.8x NR=%d&bslash;n&quot;
comma
id|x
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
(paren
l_string|&quot;SOUND_MIXER_IOCTL AC9x: 0x%.8x NR=%d&bslash;n&quot;
comma
id|x
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_static
r_int
id|prog_dmabuf_adc
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|prog_codec
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_int
id|type
)paren
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|cs4281_state
op_star
id|devs
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// --------------------------------------------------------------------- 
singleline_comment|//
singleline_comment|//              Hardware Interfaces For the CS4281
singleline_comment|//
singleline_comment|//******************************************************************************
singleline_comment|// &quot;delayus()-- Delay for the specified # of microseconds.
singleline_comment|//******************************************************************************
DECL|function|delayus
r_static
r_void
id|delayus
c_func
(paren
id|u32
id|delay
)paren
(brace
id|u32
id|j
suffix:semicolon
r_if
c_cond
(paren
id|delay
OG
l_int|9999
)paren
(brace
id|j
op_assign
(paren
id|delay
op_star
id|HZ
)paren
op_div
l_int|1000000
suffix:semicolon
multiline_comment|/* calculate delay in jiffies  */
r_if
c_cond
(paren
id|j
OL
l_int|1
)paren
id|j
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* minimum one jiffy. */
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|j
)paren
suffix:semicolon
)brace
r_else
id|udelay
c_func
(paren
id|delay
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// &quot;cs4281_read_ac97&quot; -- Reads a word from the specified location in the
singleline_comment|//               CS4281&squot;s address space(based on the BA0 register).
singleline_comment|//
singleline_comment|// 1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
singleline_comment|// 2. Write ACCDA = Command Data Register = 470h for data to write to AC97 register,
singleline_comment|//                                            0h for reads.
singleline_comment|// 3. Write ACCTL = Control Register = 460h for initiating the write
singleline_comment|// 4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h
singleline_comment|// 5. if DCV not cleared, break and return error
singleline_comment|// 6. Read ACSTS = Status Register = 464h, check VSTS bit
singleline_comment|//****************************************************************************
DECL|function|cs4281_read_ac97
r_static
r_int
id|cs4281_read_ac97
c_func
(paren
r_struct
id|cs4281_state
op_star
id|card
comma
id|u32
id|offset
comma
id|u32
op_star
id|value
)paren
(brace
id|u32
id|count
comma
id|status
suffix:semicolon
singleline_comment|// Make sure that there is not data sitting
singleline_comment|// around from a previous uncompleted access.
singleline_comment|// ACSDA = Status Data Register = 47Ch
id|status
op_assign
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACSDA
)paren
suffix:semicolon
singleline_comment|// Setup the AC97 control registers on the CS4281 to send the
singleline_comment|// appropriate command to the AC97 to perform the read.
singleline_comment|// ACCAD = Command Address Register = 46Ch
singleline_comment|// ACCDA = Command Data Register = 470h
singleline_comment|// ACCTL = Control Register = 460h
singleline_comment|// bit DCV - will clear when process completed
singleline_comment|// bit CRW - Read command
singleline_comment|// bit VFRM - valid frame enabled
singleline_comment|// bit ESYN - ASYNC generation enabled
singleline_comment|// Get the actual AC97 register from the offset
id|writel
c_func
(paren
id|offset
op_minus
id|BA0_AC97_RESET
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCAD
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCDA
)paren
suffix:semicolon
id|writel
c_func
(paren
id|ACCTL_DCV
op_or
id|ACCTL_CRW
op_or
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
suffix:semicolon
singleline_comment|// Wait for the read to occur.
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|10
suffix:semicolon
id|count
op_increment
)paren
(brace
singleline_comment|// First, we want to wait for a short time.
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
singleline_comment|// Now, check to see if the read has completed.
singleline_comment|// ACCTL = 460h, DCV should be reset by now and 460h = 17h
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
)paren
r_break
suffix:semicolon
)brace
singleline_comment|// Make sure the read completed.
r_if
c_cond
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
op_amp
id|ACCTL_DCV
)paren
r_return
l_int|1
suffix:semicolon
singleline_comment|// Wait for the valid status bit to go active.
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|10
suffix:semicolon
id|count
op_increment
)paren
(brace
singleline_comment|// Read the AC97 status register.
singleline_comment|// ACSTS = Status Register = 464h
id|status
op_assign
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACSTS
)paren
suffix:semicolon
singleline_comment|// See if we have valid status.
singleline_comment|// VSTS - Valid Status
r_if
c_cond
(paren
id|status
op_amp
id|ACSTS_VSTS
)paren
r_break
suffix:semicolon
singleline_comment|// Wait for a short while.
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
)brace
singleline_comment|// Make sure we got valid status.
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|ACSTS_VSTS
)paren
)paren
r_return
l_int|1
suffix:semicolon
singleline_comment|// Read the data returned from the AC97 register.
singleline_comment|// ACSDA = Status Data Register = 474h
op_star
id|value
op_assign
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACSDA
)paren
suffix:semicolon
singleline_comment|// Success.
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|//****************************************************************************
singleline_comment|//
singleline_comment|// &quot;cs4281_write_ac97()&quot;-- writes a word to the specified location in the
singleline_comment|// CS461x&squot;s address space (based on the part&squot;s base address zero register).
singleline_comment|//
singleline_comment|// 1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
singleline_comment|// 2. Write ACCDA = Command Data Register = 470h for data to write to AC97 reg.
singleline_comment|// 3. Write ACCTL = Control Register = 460h for initiating the write
singleline_comment|// 4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h
singleline_comment|// 5. if DCV not cleared, break and return error
singleline_comment|//
singleline_comment|//****************************************************************************
DECL|function|cs4281_write_ac97
r_static
r_int
id|cs4281_write_ac97
c_func
(paren
r_struct
id|cs4281_state
op_star
id|card
comma
id|u32
id|offset
comma
id|u32
id|value
)paren
(brace
id|u32
id|count
comma
id|status
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs_4281_write_ac97()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|// Setup the AC97 control registers on the CS4281 to send the
singleline_comment|// appropriate command to the AC97 to perform the read.
singleline_comment|// ACCAD = Command Address Register = 46Ch
singleline_comment|// ACCDA = Command Data Register = 470h
singleline_comment|// ACCTL = Control Register = 460h
singleline_comment|// set DCV - will clear when process completed
singleline_comment|// reset CRW - Write command
singleline_comment|// set VFRM - valid frame enabled
singleline_comment|// set ESYN - ASYNC generation enabled
singleline_comment|// set RSTN - ARST# inactive, AC97 codec not reset
singleline_comment|// Get the actual AC97 register from the offset
id|writel
c_func
(paren
id|offset
op_minus
id|BA0_AC97_RESET
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCAD
)paren
suffix:semicolon
id|writel
c_func
(paren
id|value
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCDA
)paren
suffix:semicolon
id|writel
c_func
(paren
id|ACCTL_DCV
op_or
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
suffix:semicolon
singleline_comment|// Wait for the write to occur.
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|10
suffix:semicolon
id|count
op_increment
)paren
(brace
singleline_comment|// First, we want to wait for a short time.
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
singleline_comment|// Now, check to see if the write has completed.
singleline_comment|// ACCTL = 460h, DCV should be reset by now and 460h = 07h
id|status
op_assign
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|ACCTL_DCV
)paren
)paren
r_break
suffix:semicolon
)brace
singleline_comment|// Make sure the write completed.
r_if
c_cond
(paren
id|status
op_amp
id|ACCTL_DCV
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs_4281_write_ac97()- unable to write. ACCTL_DCV active&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs_4281_write_ac97()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|// Success.
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// &quot;Init4281()&quot; -- Bring up the part.
singleline_comment|//******************************************************************************
DECL|function|cs4281_hw_init
r_static
r_int
id|__devinit
id|cs4281_hw_init
c_func
(paren
r_struct
id|cs4281_state
op_star
id|card
)paren
(brace
id|u32
id|ac97_slotid
suffix:semicolon
id|u32
id|temp1
comma
id|temp2
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_hw_init()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|//***************************************7
singleline_comment|//  Set up the Sound System Configuration
singleline_comment|//***************************************
singleline_comment|// Set the &squot;Configuration Write Protect&squot; register
singleline_comment|// to 4281h.  Allows vendor-defined configuration
singleline_comment|// space between 0e4h and 0ffh to be written.
id|writel
c_func
(paren
l_int|0x4281
comma
id|card-&gt;pBA0
op_plus
id|BA0_CWPR
)paren
suffix:semicolon
singleline_comment|// (3e0h)
singleline_comment|// (0), Blast the clock control register to zero so that the
singleline_comment|// PLL starts out in a known state, and blast the master serial
singleline_comment|// port control register to zero so that the serial ports also
singleline_comment|// start out in a known state.
id|writel
c_func
(paren
l_int|0
comma
id|card-&gt;pBA0
op_plus
id|BA0_CLKCR1
)paren
suffix:semicolon
singleline_comment|// (400h)
id|writel
c_func
(paren
l_int|0
comma
id|card-&gt;pBA0
op_plus
id|BA0_SERMC
)paren
suffix:semicolon
singleline_comment|// (420h)
singleline_comment|// (1), Make ESYN go to zero to turn off
singleline_comment|// the Sync pulse on the AC97 link.
id|writel
c_func
(paren
l_int|0
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// (2) Drive the ARST# pin low for a minimum of 1uS (as defined in
singleline_comment|// the AC97 spec) and then drive it high.  This is done for non
singleline_comment|// AC97 modes since there might be logic external to the CS461x
singleline_comment|// that uses the ARST# line for a reset.
id|writel
c_func
(paren
l_int|0
comma
id|card-&gt;pBA0
op_plus
id|BA0_SPMC
)paren
suffix:semicolon
singleline_comment|// (3ech)
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|writel
c_func
(paren
id|SPMC_RSTN
comma
id|card-&gt;pBA0
op_plus
id|BA0_SPMC
)paren
suffix:semicolon
id|delayus
c_func
(paren
l_int|50000
)paren
suffix:semicolon
singleline_comment|// Wait 50 ms for ABITCLK to become stable.
singleline_comment|// (3) Turn on the Sound System Clocks.
id|writel
c_func
(paren
id|CLKCR1_PLLP
comma
id|card-&gt;pBA0
op_plus
id|BA0_CLKCR1
)paren
suffix:semicolon
singleline_comment|// (400h)
id|delayus
c_func
(paren
l_int|50000
)paren
suffix:semicolon
singleline_comment|// Wait for the PLL to stabilize.
singleline_comment|// Turn on clocking of the core (CLKCR1(400h) = 0x00000030)
id|writel
c_func
(paren
id|CLKCR1_PLLP
op_or
id|CLKCR1_SWCE
comma
id|card-&gt;pBA0
op_plus
id|BA0_CLKCR1
)paren
suffix:semicolon
singleline_comment|// (4) Power on everything for now..
id|writel
c_func
(paren
l_int|0x7E
comma
id|card-&gt;pBA0
op_plus
id|BA0_SSPM
)paren
suffix:semicolon
singleline_comment|// (740h)
singleline_comment|// (5) Wait for clock stabilization.
r_for
c_loop
(paren
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
OL
l_int|1000
suffix:semicolon
id|temp1
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_CLKCR1
)paren
op_amp
id|CLKCR1_DLLRDY
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_CLKCR1
)paren
op_amp
id|CLKCR1_DLLRDY
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: DLLRDY failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
singleline_comment|// (6) Enable ASYNC generation.
id|writel
c_func
(paren
id|ACCTL_ESYN
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
suffix:semicolon
singleline_comment|// (460h)
singleline_comment|// Now wait &squot;for a short while&squot; to allow the  AC97
singleline_comment|// part to start generating bit clock. (so we don&squot;t
singleline_comment|// Try to start the PLL without an input clock.)
id|delayus
c_func
(paren
l_int|50000
)paren
suffix:semicolon
singleline_comment|// Set the serial port timing configuration, so that the
singleline_comment|// clock control circuit gets its clock from the right place.
id|writel
c_func
(paren
id|SERMC_PTC_AC97
comma
id|card-&gt;pBA0
op_plus
id|BA0_SERMC
)paren
suffix:semicolon
singleline_comment|// (420h)=2.
singleline_comment|// (7) Wait for the codec ready signal from the AC97 codec.
r_for
c_loop
(paren
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
OL
l_int|1000
suffix:semicolon
id|temp1
op_increment
)paren
(brace
singleline_comment|// Delay a mil to let things settle out and
singleline_comment|// to prevent retrying the read too quickly.
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_CRDY
)paren
singleline_comment|// If ready,  (464h)
r_break
suffix:semicolon
singleline_comment|//   exit the &squot;for&squot; loop.
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACSTS
)paren
op_amp
id|ACSTS_CRDY
)paren
)paren
singleline_comment|// If never came ready,
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: ACSTS never came ready!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|//   exit initialization.
)brace
singleline_comment|// (8) Assert the &squot;valid frame&squot; signal so we can
singleline_comment|// begin sending commands to the AC97 codec.
id|writel
c_func
(paren
id|ACCTL_VFRM
op_or
id|ACCTL_ESYN
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACCTL
)paren
suffix:semicolon
singleline_comment|// (460h)
singleline_comment|// (9), Wait until CODEC calibration is finished.
singleline_comment|// Print an error message if it doesn&squot;t.
r_for
c_loop
(paren
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
OL
l_int|1000
suffix:semicolon
id|temp1
op_increment
)paren
(brace
id|delayus
c_func
(paren
l_int|10000
)paren
suffix:semicolon
singleline_comment|// Read the AC97 Powerdown Control/Status Register.
id|cs4281_read_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
op_amp
id|temp2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp2
op_amp
l_int|0x0000000F
)paren
op_eq
l_int|0x0000000F
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|temp2
op_amp
l_int|0x0000000F
)paren
op_ne
l_int|0x0000000F
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: Codec failed to calibrate.  Status = %.8x.&bslash;n&quot;
comma
id|temp2
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
singleline_comment|// (10), Set the serial port timing configuration, so that the
singleline_comment|// clock control circuit gets its clock from the right place.
id|writel
c_func
(paren
id|SERMC_PTC_AC97
comma
id|card-&gt;pBA0
op_plus
id|BA0_SERMC
)paren
suffix:semicolon
singleline_comment|// (420h)=2.
singleline_comment|// (11) Wait until we&squot;ve sampled input slots 3 &amp; 4 as valid, meaning
singleline_comment|// that the codec is pumping ADC data across the AC link.
r_for
c_loop
(paren
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
OL
l_int|1000
suffix:semicolon
id|temp1
op_increment
)paren
(brace
singleline_comment|// Delay a mil to let things settle out and
singleline_comment|// to prevent retrying the read too quickly.
id|delayus
c_func
(paren
l_int|1000
)paren
suffix:semicolon
singleline_comment|//(test)
singleline_comment|// Read the input slot valid register;  See
singleline_comment|// if input slots 3 and 4 are valid yet.
r_if
c_cond
(paren
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACISV
)paren
op_amp
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
op_eq
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
r_break
suffix:semicolon
singleline_comment|// Exit the &squot;for&squot; if slots are valid.
)brace
singleline_comment|// If we never got valid data, exit initialization.
r_if
c_cond
(paren
(paren
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_ACISV
)paren
op_amp
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
op_ne
(paren
id|ACISV_ISV3
op_or
id|ACISV_ISV4
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: Never got valid data!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// If no valid data, exit initialization.
)brace
singleline_comment|// (12), Start digital data transfer of audio data to the codec.
id|writel
c_func
(paren
id|ACOSV_SLV3
op_or
id|ACOSV_SLV4
comma
id|card-&gt;pBA0
op_plus
id|BA0_ACOSV
)paren
suffix:semicolon
singleline_comment|// (468h)
singleline_comment|//**************************************
singleline_comment|// Unmute the Master and Alternate
singleline_comment|// (headphone) volumes.  Set to max.
singleline_comment|//**************************************
id|cs4281_write_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_HEADPHONE_VOLUME
comma
l_int|0
)paren
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_MASTER_VOLUME
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|//******************************************
singleline_comment|// Power on the DAC(AddDACUser()from main())
singleline_comment|//******************************************
id|cs4281_read_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
id|temp1
op_and_assign
l_int|0xfdff
)paren
suffix:semicolon
singleline_comment|// Wait until we sample a DAC ready state.
r_for
c_loop
(paren
id|temp2
op_assign
l_int|0
suffix:semicolon
id|temp2
OL
l_int|32
suffix:semicolon
id|temp2
op_increment
)paren
(brace
singleline_comment|// Let&squot;s wait a mil to let things settle.
id|delayus
c_func
(paren
l_int|1000
)paren
suffix:semicolon
singleline_comment|// Read the current state of the power control reg.
id|cs4281_read_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
op_amp
id|temp1
)paren
suffix:semicolon
singleline_comment|// If the DAC ready state bit is set, stop waiting.
r_if
c_cond
(paren
id|temp1
op_amp
l_int|0x2
)paren
r_break
suffix:semicolon
)brace
singleline_comment|//******************************************
singleline_comment|// Power on the ADC(AddADCUser()from main())
singleline_comment|//******************************************
id|cs4281_read_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
id|temp1
op_and_assign
l_int|0xfeff
)paren
suffix:semicolon
singleline_comment|// Wait until we sample ADC ready state.
r_for
c_loop
(paren
id|temp2
op_assign
l_int|0
suffix:semicolon
id|temp2
OL
l_int|32
suffix:semicolon
id|temp2
op_increment
)paren
(brace
singleline_comment|// Let&squot;s wait a mil to let things settle.
id|delayus
c_func
(paren
l_int|1000
)paren
suffix:semicolon
singleline_comment|// Read the current state of the power control reg.
id|cs4281_read_ac97
c_func
(paren
id|card
comma
id|BA0_AC97_POWERDOWN
comma
op_amp
id|temp1
)paren
suffix:semicolon
singleline_comment|// If the ADC ready state bit is set, stop waiting.
r_if
c_cond
(paren
id|temp1
op_amp
l_int|0x1
)paren
r_break
suffix:semicolon
)brace
singleline_comment|// Set up 4281 Register contents that
singleline_comment|// don&squot;t change for boot duration.
singleline_comment|// For playback, we map AC97 slot 3 and 4(Left
singleline_comment|// &amp; Right PCM playback) to DMA Channel 0.
singleline_comment|// Set the fifo to be 15 bytes at offset zero.
id|ac97_slotid
op_assign
l_int|0x01000f00
suffix:semicolon
singleline_comment|// FCR0.RS[4:0]=1(=&gt;slot4, right PCM playback).
singleline_comment|// FCR0.LS[4:0]=0(=&gt;slot3, left PCM playback).
singleline_comment|// FCR0.SZ[6-0]=15; FCR0.OF[6-0]=0.
id|writel
c_func
(paren
id|ac97_slotid
comma
id|card-&gt;pBA0
op_plus
id|BA0_FCR0
)paren
suffix:semicolon
singleline_comment|// (180h)
id|writel
c_func
(paren
id|ac97_slotid
op_or
id|FCRn_FEN
comma
id|card-&gt;pBA0
op_plus
id|BA0_FCR0
)paren
suffix:semicolon
singleline_comment|// Turn on FIFO Enable.
singleline_comment|// For capture, we map AC97 slot 10 and 11(Left
singleline_comment|// and Right PCM Record) to DMA Channel 1.
singleline_comment|// Set the fifo to be 15 bytes at offset sixteen.
id|ac97_slotid
op_assign
l_int|0x0B0A0f10
suffix:semicolon
singleline_comment|// FCR1.RS[4:0]=11(=&gt;slot11, right PCM record).
singleline_comment|// FCR1.LS[4:0]=10(=&gt;slot10, left PCM record).
singleline_comment|// FCR1.SZ[6-0]=15; FCR1.OF[6-0]=16.
id|writel
c_func
(paren
id|ac97_slotid
op_or
id|FCRn_PSH
comma
id|card-&gt;pBA0
op_plus
id|BA0_FCR1
)paren
suffix:semicolon
singleline_comment|// (184h)
id|writel
c_func
(paren
id|ac97_slotid
op_or
id|FCRn_FEN
comma
id|card-&gt;pBA0
op_plus
id|BA0_FCR1
)paren
suffix:semicolon
singleline_comment|// Turn on FIFO Enable.
singleline_comment|// Map the Playback SRC to the same AC97 slots(3 &amp; 4--
singleline_comment|// --Playback left &amp; right)as DMA channel 0.
singleline_comment|// Map the record SRC to the same AC97 slots(10 &amp; 11--
singleline_comment|// -- Record left &amp; right) as DMA channel 1.
id|ac97_slotid
op_assign
l_int|0x0b0a0100
suffix:semicolon
singleline_comment|// SCRSA.PRSS[4:0]=1(=&gt;slot4, right PCM playback).
singleline_comment|// SCRSA.PLSS[4:0]=0(=&gt;slot3, left PCM playback).
singleline_comment|// SCRSA.CRSS[4:0]=11(=&gt;slot11, right PCM record)
singleline_comment|// SCRSA.CLSS[4:0]=10(=&gt;slot10, left PCM record).
id|writel
c_func
(paren
id|ac97_slotid
comma
id|card-&gt;pBA0
op_plus
id|BA0_SRCSA
)paren
suffix:semicolon
singleline_comment|// (75ch)
singleline_comment|// Set &squot;Half Terminal Count Interrupt Enable&squot; and &squot;Terminal
singleline_comment|// Count Interrupt Enable&squot; in DMA Control Registers 0 &amp; 1.
singleline_comment|// Set &squot;MSK&squot; flag to 1 to keep the DMA engines paused.
id|temp1
op_assign
(paren
id|DCRn_HTCIE
op_or
id|DCRn_TCIE
op_or
id|DCRn_MSK
)paren
suffix:semicolon
singleline_comment|// (00030001h)
id|writel
c_func
(paren
id|temp1
comma
id|card-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
suffix:semicolon
singleline_comment|// (154h
id|writel
c_func
(paren
id|temp1
comma
id|card-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
suffix:semicolon
singleline_comment|// (15ch)
singleline_comment|// Set &squot;Auto-Initialize Control&squot; to &squot;enabled&squot;; For playback,
singleline_comment|// set &squot;Transfer Type Control&squot;(TR[1:0]) to &squot;read transfer&squot;,
singleline_comment|// for record, set Transfer Type Control to &squot;write transfer&squot;.
singleline_comment|// All other bits set to zero;  Some will be changed @ transfer start.
id|temp1
op_assign
(paren
id|DMRn_DMA
op_or
id|DMRn_AUTO
op_or
id|DMRn_TR_READ
)paren
suffix:semicolon
singleline_comment|// (20000018h)
id|writel
c_func
(paren
id|temp1
comma
id|card-&gt;pBA0
op_plus
id|BA0_DMR0
)paren
suffix:semicolon
singleline_comment|// (150h)
id|temp1
op_assign
(paren
id|DMRn_DMA
op_or
id|DMRn_AUTO
op_or
id|DMRn_TR_WRITE
)paren
suffix:semicolon
singleline_comment|// (20000014h)
id|writel
c_func
(paren
id|temp1
comma
id|card-&gt;pBA0
op_plus
id|BA0_DMR1
)paren
suffix:semicolon
singleline_comment|// (158h)
singleline_comment|// Enable DMA interrupts generally, and
singleline_comment|// DMA0 &amp; DMA1 interrupts specifically.
id|temp1
op_assign
id|readl
c_func
(paren
id|card-&gt;pBA0
op_plus
id|BA0_HIMR
)paren
op_amp
l_int|0xfffbfcff
suffix:semicolon
id|writel
c_func
(paren
id|temp1
comma
id|card-&gt;pBA0
op_plus
id|BA0_HIMR
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_hw_init()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// &quot;cs4281_play_rate()&quot; --
singleline_comment|//******************************************************************************
DECL|function|cs4281_play_rate
r_static
r_void
id|cs4281_play_rate
c_func
(paren
r_struct
id|cs4281_state
op_star
id|card
comma
id|u32
id|playrate
)paren
(brace
id|u32
id|DACSRvalue
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Based on the sample rate, program the DACSR register.
r_if
c_cond
(paren
id|playrate
op_eq
l_int|8000
)paren
id|DACSRvalue
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|playrate
op_eq
l_int|11025
)paren
id|DACSRvalue
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|playrate
op_eq
l_int|22050
)paren
id|DACSRvalue
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|playrate
op_eq
l_int|44100
)paren
id|DACSRvalue
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|playrate
op_le
l_int|48000
)paren
op_logical_and
(paren
id|playrate
op_ge
l_int|6023
)paren
)paren
id|DACSRvalue
op_assign
l_int|24576000
op_div
(paren
id|playrate
op_star
l_int|16
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|playrate
OL
l_int|6023
)paren
singleline_comment|// Not allowed by open.
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|playrate
OG
l_int|48000
)paren
singleline_comment|// Not allowed by open.
r_return
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
op_or
id|CS_PARMS
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_play_rate(): DACSRvalue=0x%.8x playrate=%d&bslash;n&quot;
comma
id|DACSRvalue
comma
id|playrate
)paren
)paren
suffix:semicolon
singleline_comment|//  Write the &squot;sample rate select code&squot;
singleline_comment|//  to the &squot;DAC Sample Rate&squot; register.
id|writel
c_func
(paren
id|DACSRvalue
comma
id|card-&gt;pBA0
op_plus
id|BA0_DACSR
)paren
suffix:semicolon
singleline_comment|// (744h)
)brace
singleline_comment|//******************************************************************************
singleline_comment|// &quot;cs4281_record_rate()&quot; -- Initialize the record sample rate converter.
singleline_comment|//******************************************************************************
DECL|function|cs4281_record_rate
r_static
r_void
id|cs4281_record_rate
c_func
(paren
r_struct
id|cs4281_state
op_star
id|card
comma
id|u32
id|outrate
)paren
(brace
id|u32
id|ADCSRvalue
op_assign
l_int|1
suffix:semicolon
singleline_comment|//
singleline_comment|// Based on the sample rate, program the ADCSR register
singleline_comment|//
r_if
c_cond
(paren
id|outrate
op_eq
l_int|8000
)paren
id|ADCSRvalue
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|outrate
op_eq
l_int|11025
)paren
id|ADCSRvalue
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|outrate
op_eq
l_int|22050
)paren
id|ADCSRvalue
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|outrate
op_eq
l_int|44100
)paren
id|ADCSRvalue
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|outrate
op_le
l_int|48000
)paren
op_logical_and
(paren
id|outrate
op_ge
l_int|6023
)paren
)paren
id|ADCSRvalue
op_assign
l_int|24576000
op_div
(paren
id|outrate
op_star
l_int|16
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|outrate
OL
l_int|6023
)paren
(brace
singleline_comment|// Not allowed by open.
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|outrate
OG
l_int|48000
)paren
(brace
singleline_comment|// Not allowed by open.
r_return
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
op_or
id|CS_PARMS
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_record_rate(): ADCSRvalue=0x%.8x outrate=%d&bslash;n&quot;
comma
id|ADCSRvalue
comma
id|outrate
)paren
)paren
suffix:semicolon
singleline_comment|//  Write the &squot;sample rate select code
singleline_comment|//  to the &squot;ADC Sample Rate&squot; register.
id|writel
c_func
(paren
id|ADCSRvalue
comma
id|card-&gt;pBA0
op_plus
id|BA0_ADCSR
)paren
suffix:semicolon
singleline_comment|// (748h)
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|temp1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: stop_dac():&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
op_or
id|DCRn_MSK
suffix:semicolon
id|writel
c_func
(paren
id|temp1
comma
id|s-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|temp1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_dac()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
op_logical_and
(paren
id|s-&gt;dma_dac.mapped
op_logical_or
id|s-&gt;dma_dac.count
OG
l_int|0
)paren
op_logical_and
id|s-&gt;dma_dac.ready
)paren
(brace
id|s-&gt;ena
op_or_assign
id|FMODE_WRITE
suffix:semicolon
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
op_amp
op_complement
id|DCRn_MSK
suffix:semicolon
singleline_comment|// Clear DMA0 channel mask.
id|writel
c_func
(paren
id|temp1
comma
id|s-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
suffix:semicolon
singleline_comment|// Start DMA&squot;ing.
id|writel
c_func
(paren
id|HICR_IEV
op_or
id|HICR_CHGM
comma
id|s-&gt;pBA0
op_plus
id|BA0_HICR
)paren
suffix:semicolon
singleline_comment|// Enable interrupts.              
id|writel
c_func
(paren
l_int|7
comma
id|s-&gt;pBA0
op_plus
id|BA0_PPRVC
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|7
comma
id|s-&gt;pBA0
op_plus
id|BA0_PPLVC
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
op_or
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_dac(): writel 0x%x start dma&bslash;n&quot;
comma
id|temp1
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_dac()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|temp1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: stop_adc()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;conversion
op_eq
l_int|1
)paren
(brace
id|s-&gt;conversion
op_assign
l_int|0
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_assign
id|s-&gt;prop_adc.fmt_original
suffix:semicolon
)brace
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
op_or
id|DCRn_MSK
suffix:semicolon
id|writel
c_func
(paren
id|temp1
comma
id|s-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: stop_adc()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|temp1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_adc()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
op_logical_and
(paren
id|s-&gt;dma_adc.mapped
op_logical_or
id|s-&gt;dma_adc.count
op_le
(paren
r_int
)paren
(paren
id|s-&gt;dma_adc.dmasize
op_minus
l_int|2
op_star
id|s-&gt;dma_adc.fragsize
)paren
)paren
op_logical_and
id|s-&gt;dma_adc.ready
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_S8
op_logical_or
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_U8
)paren
(brace
singleline_comment|// 
singleline_comment|// now only use 16 bit capture, due to truncation issue
singleline_comment|// in the chip, noticable distortion occurs.
singleline_comment|// allocate buffer and then convert from 16 bit to 
singleline_comment|// 8 bit for the user buffer.
singleline_comment|//
id|s-&gt;prop_adc.fmt_original
op_assign
id|s-&gt;prop_adc.fmt
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_S8
)paren
(brace
id|s-&gt;prop_adc.fmt
op_and_assign
op_complement
id|AFMT_S8
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_or_assign
id|AFMT_S16_LE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_U8
)paren
(brace
id|s-&gt;prop_adc.fmt
op_and_assign
op_complement
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_or_assign
id|AFMT_U16_LE
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// prog_dmabuf_adc performs a stop_adc() but that is
singleline_comment|// ok since we really haven&squot;t started the DMA yet.
singleline_comment|//
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
op_ne
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_adc(): error in prog_dmabuf_adc&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|s-&gt;conversion
op_assign
l_int|1
suffix:semicolon
)brace
id|s-&gt;ena
op_or_assign
id|FMODE_READ
suffix:semicolon
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
op_amp
op_complement
id|DCRn_MSK
suffix:semicolon
singleline_comment|// Clear DMA1 channel mask bit.
id|writel
c_func
(paren
id|temp1
comma
id|s-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
suffix:semicolon
singleline_comment|// Start recording
id|writel
c_func
(paren
id|HICR_IEV
op_or
id|HICR_CHGM
comma
id|s-&gt;pBA0
op_plus
id|BA0_HICR
)paren
suffix:semicolon
singleline_comment|// Enable interrupts.
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_adc(): writel 0x%x &bslash;n&quot;
comma
id|temp1
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: start_adc()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
singleline_comment|// use 64k (+1) rather than 32k as some of the higher frequencies need a larger buffer.
singleline_comment|// comments reflect 32k.
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER (15-PAGE_SHIFT+1)&t;
singleline_comment|// == 3(for PC), = log base 2( buff sz = 32k).
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1&t;
singleline_comment|// ==&gt; min buffer size = 8K.
DECL|function|dealloc_dmabuf
r_extern
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_struct
id|dmabuf
op_star
id|db
)paren
(brace
r_struct
id|page
op_star
id|map
comma
op_star
id|mapend
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;rawbuf
)paren
(brace
singleline_comment|// Undo prog_dmabuf()&squot;s marking the pages as reserved 
id|mapend
op_assign
id|virt_to_page
c_func
(paren
id|db-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|virt_to_page
c_func
(paren
id|db-&gt;rawbuf
)paren
suffix:semicolon
id|map
op_le
id|mapend
suffix:semicolon
id|map
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|map
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|s-&gt;pcidev
comma
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
comma
id|db-&gt;rawbuf
comma
id|db-&gt;dmaaddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;tmpbuff
op_logical_and
(paren
id|db-&gt;type
op_eq
id|CS_TYPE_ADC
)paren
)paren
(brace
singleline_comment|// Undo prog_dmabuf()&squot;s marking the pages as reserved 
id|mapend
op_assign
id|virt_to_page
c_func
(paren
id|s-&gt;tmpbuff
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|s-&gt;buforder_tmpbuff
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|virt_to_page
c_func
(paren
id|s-&gt;tmpbuff
)paren
suffix:semicolon
id|map
op_le
id|mapend
suffix:semicolon
id|map
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|map
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|s-&gt;pcidev
comma
id|PAGE_SIZE
op_lshift
id|s-&gt;buforder_tmpbuff
comma
id|s-&gt;tmpbuff
comma
id|s-&gt;dmaaddr_tmpbuff
)paren
suffix:semicolon
)brace
id|s-&gt;tmpbuff
op_assign
l_int|NULL
suffix:semicolon
id|db-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|db-&gt;mapped
op_assign
id|db-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_struct
id|dmabuf
op_star
id|db
)paren
(brace
r_int
id|order
suffix:semicolon
r_int
id|bytespersec
comma
id|temp1
suffix:semicolon
r_int
id|bufs
comma
id|sample_shift
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
id|map
comma
op_star
id|mapend
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_dmabuf()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|db-&gt;hwptr
op_assign
id|db-&gt;swptr
op_assign
id|db-&gt;total_bytes
op_assign
id|db-&gt;count
op_assign
id|db-&gt;error
op_assign
id|db-&gt;endcleared
op_assign
id|db-&gt;blocks
op_assign
id|db-&gt;wakeup
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db-&gt;rawbuf
)paren
(brace
id|db-&gt;ready
op_assign
id|db-&gt;mapped
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|db-&gt;rawbuf
op_assign
(paren
r_void
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|s-&gt;pcidev
comma
id|PAGE_SIZE
op_lshift
id|order
comma
op_amp
id|db
op_member_access_from_pointer
id|dmaaddr
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db-&gt;rawbuf
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: prog_dmabuf(): unable to allocate rawbuf&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|db-&gt;buforder
op_assign
id|order
suffix:semicolon
singleline_comment|// Now mark the pages as reserved; otherwise the 
singleline_comment|// remap_page_range() in cs4281_mmap doesn&squot;t work.
singleline_comment|// 1. get index to last page in mem_map array for rawbuf.
id|mapend
op_assign
id|virt_to_page
c_func
(paren
id|db-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
singleline_comment|// 2. mark each physical page in range as &squot;reserved&squot;.
r_for
c_loop
(paren
id|map
op_assign
id|virt_to_page
c_func
(paren
id|db-&gt;rawbuf
)paren
suffix:semicolon
id|map
op_le
id|mapend
suffix:semicolon
id|map
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|map
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;tmpbuff
op_logical_and
(paren
id|db-&gt;type
op_eq
id|CS_TYPE_ADC
)paren
)paren
(brace
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|s-&gt;tmpbuff
op_assign
(paren
r_void
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|s-&gt;pcidev
comma
id|PAGE_SIZE
op_lshift
id|order
comma
op_amp
id|s
op_member_access_from_pointer
id|dmaaddr_tmpbuff
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;tmpbuff
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: prog_dmabuf(): unable to allocate tmpbuff&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|s-&gt;buforder_tmpbuff
op_assign
id|order
suffix:semicolon
singleline_comment|// Now mark the pages as reserved; otherwise the 
singleline_comment|// remap_page_range() in cs4281_mmap doesn&squot;t work.
singleline_comment|// 1. get index to last page in mem_map array for rawbuf.
id|mapend
op_assign
id|virt_to_page
c_func
(paren
id|s-&gt;tmpbuff
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|s-&gt;buforder_tmpbuff
)paren
op_minus
l_int|1
)paren
suffix:semicolon
singleline_comment|// 2. mark each physical page in range as &squot;reserved&squot;.
r_for
c_loop
(paren
id|map
op_assign
id|virt_to_page
c_func
(paren
id|s-&gt;tmpbuff
)paren
suffix:semicolon
id|map
op_le
id|mapend
suffix:semicolon
id|map
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|map
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|db-&gt;type
op_eq
id|CS_TYPE_DAC
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;prop_dac.fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
)paren
)paren
id|sample_shift
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_dac.channels
OG
l_int|1
)paren
id|sample_shift
op_increment
suffix:semicolon
id|bytespersec
op_assign
id|s-&gt;prop_dac.rate
op_lshift
id|sample_shift
suffix:semicolon
)brace
r_else
singleline_comment|// CS_TYPE_ADC
(brace
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
)paren
)paren
id|sample_shift
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc.channels
OG
l_int|1
)paren
id|sample_shift
op_increment
suffix:semicolon
id|bytespersec
op_assign
id|s-&gt;prop_adc.rate
op_lshift
id|sample_shift
suffix:semicolon
)brace
id|bufs
op_assign
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
suffix:semicolon
DECL|macro|INTERRUPT_RATE_MS
mdefine_line|#define INTERRUPT_RATE_MS       100&t;
singleline_comment|// Interrupt rate in milliseconds.
id|db-&gt;numfrag
op_assign
l_int|2
suffix:semicolon
id|temp1
op_assign
id|bytespersec
op_div
(paren
l_int|1000
op_div
id|INTERRUPT_RATE_MS
)paren
suffix:semicolon
singleline_comment|// Nominal frag size(bytes/interrupt)
id|db-&gt;fragshift
op_assign
l_int|8
suffix:semicolon
singleline_comment|// Min 256 bytes.
r_while
c_loop
(paren
l_int|1
op_lshift
id|db-&gt;fragshift
OL
id|temp1
)paren
singleline_comment|// Calc power of 2 frag size.
id|db-&gt;fragshift
op_add_assign
l_int|1
suffix:semicolon
id|db-&gt;fragsize
op_assign
l_int|1
op_lshift
id|db-&gt;fragshift
suffix:semicolon
id|db-&gt;dmasize
op_assign
id|db-&gt;fragsize
op_star
l_int|2
suffix:semicolon
id|db-&gt;fragsamples
op_assign
id|db-&gt;fragsize
op_rshift
id|sample_shift
suffix:semicolon
singleline_comment|// # samples/fragment.
singleline_comment|// If the calculated size is larger than the allocated
singleline_comment|//  buffer, divide the allocated buffer into 2 fragments.
r_if
c_cond
(paren
id|db-&gt;dmasize
OG
id|bufs
)paren
(brace
id|db-&gt;numfrag
op_assign
l_int|2
suffix:semicolon
singleline_comment|// Two fragments.
id|db-&gt;fragsize
op_assign
id|bufs
op_rshift
l_int|1
suffix:semicolon
singleline_comment|// Each 1/2 the alloc&squot;ed buffer.
id|db-&gt;fragsamples
op_assign
id|db-&gt;fragsize
op_rshift
id|sample_shift
suffix:semicolon
singleline_comment|// # samples/fragment.
id|db-&gt;dmasize
op_assign
id|bufs
suffix:semicolon
singleline_comment|// Use all the alloc&squot;ed buffer.
id|db-&gt;fragshift
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Calculate &squot;fragshift&squot;.
id|temp1
op_assign
id|db-&gt;fragsize
suffix:semicolon
singleline_comment|// update_ptr() uses it 
r_while
c_loop
(paren
(paren
id|temp1
op_rshift_assign
l_int|1
)paren
OG
l_int|1
)paren
singleline_comment|// to calc &squot;total-bytes&squot;
id|db-&gt;fragshift
op_add_assign
l_int|1
suffix:semicolon
singleline_comment|// returned in DSP_GETI/OPTR. 
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_dmabuf()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_dmabuf(): numfrag=%d fragsize=%d fragsamples=%d fragshift=%d bufs=%d fmt=0x%x ch=%d&bslash;n&quot;
comma
id|db-&gt;numfrag
comma
id|db-&gt;fragsize
comma
id|db-&gt;fragsamples
comma
id|db-&gt;fragshift
comma
id|bufs
comma
(paren
id|db-&gt;type
op_eq
id|CS_TYPE_DAC
)paren
ques
c_cond
id|s-&gt;prop_dac.fmt
suffix:colon
id|s-&gt;prop_adc.fmt
comma
(paren
id|db-&gt;type
op_eq
id|CS_TYPE_DAC
)paren
ques
c_cond
id|s-&gt;prop_dac.channels
suffix:colon
id|s
op_member_access_from_pointer
id|prop_adc.channels
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf_adc
r_static
r_int
id|prog_dmabuf_adc
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_int
id|va
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|c
suffix:semicolon
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.type
op_assign
id|CS_TYPE_ADC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
op_amp
id|s-&gt;dma_adc
)paren
)paren
)paren
r_return
id|c
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.rawbuf
)paren
(brace
id|memset
c_func
(paren
id|s-&gt;dma_adc.rawbuf
comma
(paren
id|s-&gt;prop_adc
dot
id|fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
comma
id|s-&gt;dma_adc.dmasize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;tmpbuff
)paren
(brace
id|memset
c_func
(paren
id|s-&gt;tmpbuff
comma
(paren
id|s-&gt;prop_adc
dot
id|fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
comma
id|PAGE_SIZE
op_lshift
id|s-&gt;buforder_tmpbuff
)paren
suffix:semicolon
)brace
id|va
op_assign
id|virt_to_bus
c_func
(paren
id|s-&gt;dma_adc.rawbuf
)paren
suffix:semicolon
id|count
op_assign
id|s-&gt;dma_adc.dmasize
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc
dot
id|fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S16_BE
op_or
id|AFMT_U16_BE
)paren
)paren
id|count
op_div_assign
l_int|2
suffix:semicolon
singleline_comment|// 16-bit.
r_if
c_cond
(paren
id|s-&gt;prop_adc.channels
OG
l_int|1
)paren
id|count
op_div_assign
l_int|2
suffix:semicolon
singleline_comment|// Assume stereo.
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_dmabuf_adc(): count=%d va=0x%.8x&bslash;n&quot;
comma
id|count
comma
(paren
r_int
)paren
id|va
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|va
comma
id|s-&gt;pBA0
op_plus
id|BA0_DBA1
)paren
suffix:semicolon
singleline_comment|// Set buffer start address.
id|writel
c_func
(paren
id|count
op_minus
l_int|1
comma
id|s-&gt;pBA0
op_plus
id|BA0_DBC1
)paren
suffix:semicolon
singleline_comment|// Set count. 
id|s-&gt;dma_adc.ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf_dac
r_static
r_int
id|prog_dmabuf_dac
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_int
id|va
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|c
suffix:semicolon
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.type
op_assign
id|CS_TYPE_DAC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|prog_dmabuf
c_func
(paren
id|s
comma
op_amp
id|s-&gt;dma_dac
)paren
)paren
)paren
r_return
id|c
suffix:semicolon
id|memset
c_func
(paren
id|s-&gt;dma_dac.rawbuf
comma
(paren
id|s-&gt;prop_dac.fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
comma
id|s-&gt;dma_dac.dmasize
)paren
suffix:semicolon
id|va
op_assign
id|virt_to_bus
c_func
(paren
id|s-&gt;dma_dac.rawbuf
)paren
suffix:semicolon
id|count
op_assign
id|s-&gt;dma_dac.dmasize
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S16_BE
op_or
id|AFMT_U16_BE
)paren
)paren
id|count
op_div_assign
l_int|2
suffix:semicolon
singleline_comment|// 16-bit.
r_if
c_cond
(paren
id|s-&gt;prop_dac.channels
OG
l_int|1
)paren
id|count
op_div_assign
l_int|2
suffix:semicolon
singleline_comment|// Assume stereo.
id|writel
c_func
(paren
id|va
comma
id|s-&gt;pBA0
op_plus
id|BA0_DBA0
)paren
suffix:semicolon
singleline_comment|// Set buffer start address.
id|writel
c_func
(paren
id|count
op_minus
l_int|1
comma
id|s-&gt;pBA0
op_plus
id|BA0_DBC0
)paren
suffix:semicolon
singleline_comment|// Set count.             
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_dmabuf_dac(): count=%d va=0x%.8x&bslash;n&quot;
comma
id|count
comma
(paren
r_int
)paren
id|va
)paren
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|clear_advance
r_static
r_void
id|clear_advance
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|bsize
comma
r_int
id|bptr
comma
r_int
id|len
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|bptr
op_plus
id|len
OG
id|bsize
)paren
(brace
r_int
id|x
op_assign
id|bsize
op_minus
id|bptr
suffix:semicolon
id|memset
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_plus
id|bptr
comma
id|c
comma
id|x
)paren
suffix:semicolon
id|bptr
op_assign
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|x
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: clear_advance(): memset %d at 0x%.8x for %d size &bslash;n&quot;
comma
(paren
r_int
)paren
id|c
comma
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_plus
id|bptr
comma
id|len
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_plus
id|bptr
comma
id|c
comma
id|len
)paren
suffix:semicolon
)brace
singleline_comment|// call with spinlock held! 
DECL|function|cs4281_update_ptr
r_static
r_void
id|cs4281_update_ptr
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
id|diff
suffix:semicolon
r_int
id|hwptr
comma
id|va
suffix:semicolon
singleline_comment|// update ADC pointer 
r_if
c_cond
(paren
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
(brace
id|hwptr
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCA1
)paren
suffix:semicolon
singleline_comment|// Read capture DMA address.
id|va
op_assign
id|virt_to_bus
c_func
(paren
id|s-&gt;dma_adc.rawbuf
)paren
suffix:semicolon
id|hwptr
op_sub_assign
(paren
r_int
)paren
id|va
suffix:semicolon
id|diff
op_assign
(paren
id|s-&gt;dma_adc.dmasize
op_plus
id|hwptr
op_minus
id|s-&gt;dma_adc.hwptr
)paren
op_mod
id|s-&gt;dma_adc.dmasize
suffix:semicolon
id|s-&gt;dma_adc.hwptr
op_assign
id|hwptr
suffix:semicolon
id|s-&gt;dma_adc.total_bytes
op_add_assign
id|diff
suffix:semicolon
id|s-&gt;dma_adc.count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OG
id|s-&gt;dma_adc.dmasize
)paren
id|s-&gt;dma_adc.count
op_assign
id|s-&gt;dma_adc.dmasize
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_adc.fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|s
op_member_access_from_pointer
id|dma_adc
dot
id|wait
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OG
l_int|0
)paren
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d &bslash;n&quot;
comma
(paren
r_int
)paren
id|s
comma
id|s-&gt;dma_adc.hwptr
comma
id|s-&gt;dma_adc.total_bytes
comma
id|s-&gt;dma_adc.count
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// update DAC pointer 
singleline_comment|//
singleline_comment|// check for end of buffer, means that we are going to wait for another interrupt
singleline_comment|// to allow silence to fill the fifos on the part, to keep pops down to a minimum.
singleline_comment|//
r_if
c_cond
(paren
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
(brace
id|hwptr
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCA0
)paren
suffix:semicolon
singleline_comment|// Read play DMA address.
id|va
op_assign
id|virt_to_bus
c_func
(paren
id|s-&gt;dma_dac.rawbuf
)paren
suffix:semicolon
id|hwptr
op_sub_assign
(paren
r_int
)paren
id|va
suffix:semicolon
id|diff
op_assign
(paren
id|s-&gt;dma_dac.dmasize
op_plus
id|hwptr
op_minus
id|s-&gt;dma_dac.hwptr
)paren
op_mod
id|s-&gt;dma_dac.dmasize
suffix:semicolon
id|s-&gt;dma_dac.hwptr
op_assign
id|hwptr
suffix:semicolon
id|s-&gt;dma_dac.total_bytes
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
id|s-&gt;dma_dac.count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_ge
id|s-&gt;dma_dac.fragsize
)paren
(brace
id|s-&gt;dma_dac.wakeup
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
OG
id|s-&gt;dma_dac.dmasize
)paren
id|s-&gt;dma_dac.count
op_and_assign
id|s-&gt;dma_dac.dmasize
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|s-&gt;dma_dac.count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_le
l_int|0
)paren
(brace
singleline_comment|//
singleline_comment|// fill with silence, and do not shut down the DAC.
singleline_comment|// Continue to play silence until the _release.
singleline_comment|//
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_update_ptr(): memset %d at 0x%.8x for %d size &bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
comma
(paren
r_int
)paren
id|s-&gt;dma_dac
dot
id|rawbuf
comma
id|s-&gt;dma_dac.dmasize
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|s-&gt;dma_dac.rawbuf
comma
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
comma
id|s-&gt;dma_dac.dmasize
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_le
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
op_logical_and
op_logical_neg
id|s-&gt;dma_dac.endcleared
)paren
(brace
id|clear_advance
c_func
(paren
id|s-&gt;dma_dac.rawbuf
comma
id|s-&gt;dma_dac.dmasize
comma
id|s-&gt;dma_dac.swptr
comma
id|s-&gt;dma_dac.fragsize
comma
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
suffix:semicolon
id|s-&gt;dma_dac.endcleared
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
OL
(paren
r_int
)paren
id|s-&gt;dma_dac.dmasize
)paren
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d &bslash;n&quot;
comma
(paren
r_int
)paren
id|s
comma
id|s-&gt;dma_dac.hwptr
comma
id|s-&gt;dma_dac.total_bytes
comma
id|s-&gt;dma_dac.count
)paren
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|prog_codec
r_static
r_void
id|prog_codec
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|temp1
comma
id|format
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_codec()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CS_TYPE_ADC
)paren
(brace
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
suffix:semicolon
id|writel
c_func
(paren
id|temp1
op_or
id|DCRn_MSK
comma
id|s-&gt;pBA0
op_plus
id|BA0_DCR1
)paren
suffix:semicolon
singleline_comment|// Stop capture DMA, if active.
singleline_comment|// program sampling rates  
singleline_comment|// Note, for CS4281, capture &amp; play rates can be set independently.
id|cs4281_record_rate
c_func
(paren
id|s
comma
id|s-&gt;prop_adc.rate
)paren
suffix:semicolon
singleline_comment|// program ADC parameters 
id|format
op_assign
id|DMRn_DMA
op_or
id|DMRn_AUTO
op_or
id|DMRn_TR_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc
dot
id|fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S16_BE
op_or
id|AFMT_U16_BE
)paren
)paren
(brace
singleline_comment|// 16-bit
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
(paren
id|AFMT_S16_BE
op_or
id|AFMT_U16_BE
)paren
)paren
singleline_comment|// Big-endian?
id|format
op_or_assign
id|DMRn_BEND
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
(paren
id|AFMT_U16_LE
op_or
id|AFMT_U16_BE
)paren
)paren
id|format
op_or_assign
id|DMRn_USIGN
suffix:semicolon
singleline_comment|// Unsigned.      
)brace
r_else
id|format
op_or_assign
id|DMRn_SIZE8
op_or
id|DMRn_USIGN
suffix:semicolon
singleline_comment|// 8-bit, unsigned
r_if
c_cond
(paren
id|s-&gt;prop_adc.channels
OL
l_int|2
)paren
id|format
op_or_assign
id|DMRn_MONO
suffix:semicolon
id|writel
c_func
(paren
id|format
comma
id|s-&gt;pBA0
op_plus
id|BA0_DMR1
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_codec(): adc %s %s %s rate=%d DMR0 format=0x%.8x&bslash;n&quot;
comma
(paren
id|format
op_amp
id|DMRn_SIZE8
)paren
ques
c_cond
l_string|&quot;8&quot;
suffix:colon
l_string|&quot;16&quot;
comma
(paren
id|format
op_amp
id|DMRn_USIGN
)paren
ques
c_cond
l_string|&quot;Unsigned&quot;
suffix:colon
l_string|&quot;Signed&quot;
comma
(paren
id|format
op_amp
id|DMRn_MONO
)paren
ques
c_cond
l_string|&quot;Mono&quot;
suffix:colon
l_string|&quot;Stereo&quot;
comma
id|s-&gt;prop_adc.rate
comma
id|format
)paren
)paren
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
singleline_comment|// not capturing data yet
)brace
r_if
c_cond
(paren
id|type
op_eq
id|CS_TYPE_DAC
)paren
(brace
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
suffix:semicolon
id|writel
c_func
(paren
id|temp1
op_or
id|DCRn_MSK
comma
id|s-&gt;pBA0
op_plus
id|BA0_DCR0
)paren
suffix:semicolon
singleline_comment|// Stop play DMA, if active.
singleline_comment|// program sampling rates  
singleline_comment|// Note, for CS4281, capture &amp; play rates can be set independently.
id|cs4281_play_rate
c_func
(paren
id|s
comma
id|s-&gt;prop_dac.rate
)paren
suffix:semicolon
singleline_comment|// program DAC parameters 
id|format
op_assign
id|DMRn_DMA
op_or
id|DMRn_AUTO
op_or
id|DMRn_TR_READ
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S16_BE
op_or
id|AFMT_U16_BE
)paren
)paren
(brace
singleline_comment|// 16-bit
r_if
c_cond
(paren
id|s-&gt;prop_dac.fmt
op_amp
(paren
id|AFMT_S16_BE
op_or
id|AFMT_U16_BE
)paren
)paren
id|format
op_or_assign
id|DMRn_BEND
suffix:semicolon
singleline_comment|// Big Endian.
r_if
c_cond
(paren
id|s-&gt;prop_dac.fmt
op_amp
(paren
id|AFMT_U16_LE
op_or
id|AFMT_U16_BE
)paren
)paren
id|format
op_or_assign
id|DMRn_USIGN
suffix:semicolon
singleline_comment|// Unsigned.      
)brace
r_else
id|format
op_or_assign
id|DMRn_SIZE8
op_or
id|DMRn_USIGN
suffix:semicolon
singleline_comment|// 8-bit, unsigned
r_if
c_cond
(paren
id|s-&gt;prop_dac.channels
OL
l_int|2
)paren
id|format
op_or_assign
id|DMRn_MONO
suffix:semicolon
id|writel
c_func
(paren
id|format
comma
id|s-&gt;pBA0
op_plus
id|BA0_DMR0
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_codec(): dac %s %s %s rate=%d DMR0 format=0x%.8x&bslash;n&quot;
comma
(paren
id|format
op_amp
id|DMRn_SIZE8
)paren
ques
c_cond
l_string|&quot;8&quot;
suffix:colon
l_string|&quot;16&quot;
comma
(paren
id|format
op_amp
id|DMRn_USIGN
)paren
ques
c_cond
l_string|&quot;Unsigned&quot;
suffix:colon
l_string|&quot;Signed&quot;
comma
(paren
id|format
op_amp
id|DMRn_MONO
)paren
ques
c_cond
l_string|&quot;Mono&quot;
suffix:colon
l_string|&quot;Stereo&quot;
comma
id|s-&gt;prop_dac.rate
comma
id|format
)paren
)paren
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
singleline_comment|// not capturing data yet
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: prog_codec()- &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|variable|invalid_magic
r_static
r_const
r_char
id|invalid_magic
(braket
)braket
op_assign
id|KERN_CRIT
l_string|&quot;cs4281: invalid magic value&bslash;n&quot;
suffix:semicolon
DECL|macro|VALIDATE_STATE
mdefine_line|#define VALIDATE_STATE(s)                         &bslash;&n;({                                                &bslash;&n;        if (!(s) || (s)-&gt;magic != CS4281_MAGIC) { &bslash;&n;                printk(invalid_magic);            &bslash;&n;                return -ENXIO;                    &bslash;&n;        }                                         &bslash;&n;})
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|mixer_ioctl
r_static
r_int
id|mixer_ioctl
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
singleline_comment|// Index to mixer_src[] is value of AC97 Input Mux Select Reg.
singleline_comment|// Value of array member is recording source Device ID Mask.
r_static
r_const
r_int
r_int
id|mixer_src
(braket
l_int|8
)braket
op_assign
(brace
id|SOUND_MASK_MIC
comma
id|SOUND_MASK_CD
comma
l_int|0
comma
id|SOUND_MASK_LINE1
comma
id|SOUND_MASK_LINE
comma
id|SOUND_MASK_VOLUME
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
singleline_comment|// Index of mixtable1[] member is Device ID 
singleline_comment|// and must be &lt;= SOUND_MIXER_NRDEVICES.
singleline_comment|// Value of array member is index into s-&gt;mix.vol[]
r_static
r_const
r_int
r_char
id|mixtable1
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
l_int|1
comma
singleline_comment|// voice 
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
l_int|2
comma
singleline_comment|// AUX
(braket
id|SOUND_MIXER_CD
)braket
op_assign
l_int|3
comma
singleline_comment|// CD 
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
l_int|4
comma
singleline_comment|// Line 
(braket
id|SOUND_MIXER_SYNTH
)braket
op_assign
l_int|5
comma
singleline_comment|// FM
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
l_int|6
comma
singleline_comment|// Mic 
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
l_int|7
comma
singleline_comment|// Speaker 
(braket
id|SOUND_MIXER_RECLEV
)braket
op_assign
l_int|8
comma
singleline_comment|// Recording level 
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
l_int|9
singleline_comment|// Master Volume 
)brace
suffix:semicolon
r_static
r_const
r_int
id|mixreg
(braket
)braket
op_assign
(brace
id|BA0_AC97_PCM_OUT_VOLUME
comma
id|BA0_AC97_AUX_VOLUME
comma
id|BA0_AC97_CD_VOLUME
comma
id|BA0_AC97_LINE_IN_VOLUME
)brace
suffix:semicolon
r_int
r_char
id|l
comma
id|r
comma
id|rl
comma
id|rr
comma
id|vidx
suffix:semicolon
r_int
r_char
id|attentbl
(braket
l_int|11
)braket
op_assign
(brace
l_int|63
comma
l_int|42
comma
l_int|26
comma
l_int|17
comma
l_int|14
comma
l_int|11
comma
l_int|8
comma
l_int|6
comma
l_int|4
comma
l_int|2
comma
l_int|0
)brace
suffix:semicolon
r_int
id|temp1
suffix:semicolon
r_int
id|i
comma
id|val
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: mixer_ioctl(): s=0x%.8x cmd=0x%.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|s
comma
id|cmd
)paren
)paren
suffix:semicolon
macro_line|#if CSDEBUG
id|printioctl
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if CSDEBUG_INTERFACE
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_GETDBGMASK
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_SETDBGMASK
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_GETDBGLEVEL
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_SETDBGLEVEL
)paren
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_CS_GETDBGMASK
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debugmask
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CS_GETDBGLEVEL
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debuglevel
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGMASK
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debugmask
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGLEVEL
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debuglevel
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: mixer_ioctl(): ERROR unknown debug cmd&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_PRIVATE1
)paren
(brace
singleline_comment|// enable/disable/query mixer preamp 
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
op_minus
l_int|1
)paren
(brace
id|cs4281_read_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_MIC_VOLUME
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|temp1
op_assign
id|val
ques
c_cond
(paren
id|temp1
op_or
l_int|0x40
)paren
suffix:colon
(paren
id|temp1
op_amp
l_int|0xffbf
)paren
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_MIC_VOLUME
comma
id|temp1
)paren
suffix:semicolon
)brace
id|cs4281_read_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_MIC_VOLUME
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|val
op_assign
(paren
id|temp1
op_amp
l_int|0x40
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_PRIVATE2
)paren
(brace
singleline_comment|// enable/disable/query spatializer 
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
op_minus
l_int|1
)paren
(brace
id|temp1
op_assign
(paren
id|val
op_amp
l_int|0x3f
)paren
op_rshift
l_int|2
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_3D_CONTROL
comma
id|temp1
)paren
suffix:semicolon
id|cs4281_read_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_GENERAL_PURPOSE
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_GENERAL_PURPOSE
comma
id|temp1
op_or
l_int|0x2000
)paren
suffix:semicolon
)brace
id|cs4281_read_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_3D_CONTROL
comma
op_amp
id|temp1
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
(paren
id|temp1
op_lshift
l_int|2
)paren
op_or
l_int|3
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_INFO
)paren
(brace
id|mixer_info
id|info
suffix:semicolon
id|strncpy
c_func
(paren
id|info.id
comma
l_string|&quot;CS4281&quot;
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.name
comma
l_string|&quot;Crystal CS4281&quot;
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
id|info.modify_counter
op_assign
id|s-&gt;mix.modcnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_OLD_MIXER_INFO
)paren
(brace
id|_old_mixer_info
id|info
suffix:semicolon
id|strncpy
c_func
(paren
id|info.id
comma
l_string|&quot;CS4281&quot;
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.name
comma
l_string|&quot;Crystal CS4281&quot;
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|OSS_GETVERSION
)paren
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
l_char|&squot;M&squot;
op_logical_or
id|_SIOC_SIZE
c_func
(paren
id|cmd
)paren
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// If ioctl has only the SIOC_READ bit(bit 31)
singleline_comment|// on, process the only-read commands. 
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_eq
id|_SIOC_READ
)paren
(brace
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
singleline_comment|// Arg contains a bit for each recording source 
id|cs4281_read_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_RECORD_SELECT
comma
op_amp
id|temp1
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|mixer_src
(braket
id|temp1
op_amp
l_int|7
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
singleline_comment|// Arg contains a bit for each supported device 
r_return
id|put_user
c_func
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_SYNTH
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_LINE1
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_RECLEV
op_or
id|SOUND_MASK_SPEAKER
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
singleline_comment|// Arg contains a bit for each supported recording source 
r_return
id|put_user
c_func
(paren
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_LINE1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
singleline_comment|// Mixer channels supporting stereo 
r_return
id|put_user
c_func
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_SYNTH
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_LINE1
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_RECLEV
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_CAP_EXCL_INPUT
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// If ioctl doesn&squot;t have both the SIOC_READ and 
singleline_comment|// the SIOC_WRITE bit set, return invalid.
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
(paren
id|_SIOC_READ
op_or
id|_SIOC_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// Increment the count of volume writes.
id|s-&gt;mix.modcnt
op_increment
suffix:semicolon
singleline_comment|// Isolate the command; it must be a write.
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
singleline_comment|// Arg contains a bit for each recording source 
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|i
op_assign
id|hweight32
c_func
(paren
id|val
)paren
suffix:semicolon
singleline_comment|// i = # bits on in val.
r_if
c_cond
(paren
id|i
op_ne
l_int|1
)paren
singleline_comment|// One &amp; only 1 bit must be on.
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|mixer_src
)paren
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
id|mixer_src
(braket
id|i
)braket
)paren
(brace
id|temp1
op_assign
(paren
id|i
op_lshift
l_int|8
)paren
op_or
id|i
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_RECORD_SELECT
comma
id|temp1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_MIXER_VOLUME
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
singleline_comment|// Max soundcard.h vol is 100.
r_if
c_cond
(paren
id|l
OL
l_int|6
)paren
(brace
id|rl
op_assign
l_int|63
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rl
op_assign
id|attentbl
(braket
(paren
l_int|10
op_star
id|l
)paren
op_div
l_int|100
)braket
suffix:semicolon
singleline_comment|// Convert 0-100 vol to 63-0 atten.
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
singleline_comment|// Max right volume is 100, too
r_if
c_cond
(paren
id|r
OL
l_int|6
)paren
(brace
id|rr
op_assign
l_int|63
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rr
op_assign
id|attentbl
(braket
(paren
l_int|10
op_star
id|r
)paren
op_div
l_int|100
)braket
suffix:semicolon
singleline_comment|// Convert volume to attenuation.
r_if
c_cond
(paren
(paren
id|rl
OG
l_int|60
)paren
op_logical_and
(paren
id|rr
OG
l_int|60
)paren
)paren
singleline_comment|// If both l &amp; r are &squot;low&squot;,          
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
singleline_comment|//  turn on the mute bit.
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
op_or_assign
(paren
id|rl
op_lshift
l_int|8
)paren
op_or
id|rr
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_MASTER_VOLUME
comma
id|temp1
)paren
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_HEADPHONE_VOLUME
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|8
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|8
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|8
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_SPEAKER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|3
)paren
(brace
id|rl
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rl
op_assign
(paren
id|l
op_star
l_int|2
op_minus
l_int|5
)paren
op_div
l_int|13
suffix:semicolon
singleline_comment|// Convert 0-100 range to 0-15.
id|l
op_assign
(paren
id|rl
op_star
l_int|13
op_plus
l_int|5
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rl
OL
l_int|3
)paren
(brace
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
id|rl
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|15
op_minus
id|rl
suffix:semicolon
singleline_comment|// Convert volume to attenuation.
id|temp1
op_or_assign
id|rl
op_lshift
l_int|1
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_PC_BEEP_VOLUME
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|6
)braket
op_assign
id|l
op_lshift
l_int|8
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|6
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|6
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
id|rl
op_assign
(paren
id|l
op_star
l_int|2
op_minus
l_int|5
)paren
op_div
l_int|13
suffix:semicolon
singleline_comment|// Convert 0-100 scale to 0-15.
id|rr
op_assign
(paren
id|r
op_star
l_int|2
op_minus
l_int|5
)paren
op_div
l_int|13
suffix:semicolon
r_if
c_cond
(paren
id|rl
OL
l_int|3
op_logical_and
id|rr
OL
l_int|3
)paren
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
op_assign
id|temp1
op_or
(paren
id|rl
op_lshift
l_int|8
)paren
op_or
id|rr
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_RECORD_GAIN
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|7
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|7
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|7
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|1
)paren
(brace
id|l
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rl
op_assign
(paren
(paren
r_int
)paren
id|l
op_star
l_int|5
op_minus
l_int|4
)paren
op_div
l_int|16
suffix:semicolon
singleline_comment|// Convert 0-100 range to 0-31.
id|l
op_assign
(paren
id|rl
op_star
l_int|16
op_plus
l_int|4
)paren
op_div
l_int|5
suffix:semicolon
)brace
id|cs4281_read_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_MIC_VOLUME
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|temp1
op_and_assign
l_int|0x40
suffix:semicolon
singleline_comment|// Isolate 20db gain bit.
r_if
c_cond
(paren
id|rl
OL
l_int|3
)paren
(brace
id|temp1
op_or_assign
l_int|0x8000
suffix:semicolon
id|rl
op_assign
l_int|0
suffix:semicolon
)brace
id|rl
op_assign
l_int|31
op_minus
id|rl
suffix:semicolon
singleline_comment|// Convert volume to attenuation.
id|temp1
op_or_assign
id|rl
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|BA0_AC97_MIC_VOLUME
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|5
)braket
op_assign
id|val
op_lshift
l_int|8
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|5
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|5
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
id|rl
op_assign
(paren
id|l
op_star
l_int|2
op_minus
l_int|11
)paren
op_div
l_int|3
suffix:semicolon
singleline_comment|// Convert 0-100 range to 0-63.
id|rr
op_assign
(paren
id|r
op_star
l_int|2
op_minus
l_int|11
)paren
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|rl
OL
l_int|3
)paren
singleline_comment|// If l is low, turn on
id|temp1
op_assign
l_int|0x0080
suffix:semicolon
singleline_comment|//  the mute bit.
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|63
op_minus
id|rl
suffix:semicolon
singleline_comment|// Convert vol to attenuation.
id|writel
c_func
(paren
id|temp1
op_or
id|rl
comma
id|s-&gt;pBA0
op_plus
id|BA0_FMLVC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rr
OL
l_int|3
)paren
singleline_comment|//  If rr is low, turn on
id|temp1
op_assign
l_int|0x0080
suffix:semicolon
singleline_comment|//   the mute bit.
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|rr
op_assign
l_int|63
op_minus
id|rr
suffix:semicolon
singleline_comment|// Convert vol to attenuation.
id|writel
c_func
(paren
id|temp1
op_or
id|rr
comma
id|s-&gt;pBA0
op_plus
id|BA0_FMRVC
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|4
)braket
op_assign
(paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|4
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|4
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: mixer_ioctl(): default&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|1
)paren
(brace
id|l
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|31
suffix:semicolon
)brace
r_else
id|rl
op_assign
(paren
id|attentbl
(braket
(paren
id|l
op_star
l_int|10
)paren
op_div
l_int|100
)braket
)paren
op_rshift
l_int|1
suffix:semicolon
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|1
)paren
(brace
id|r
op_assign
l_int|0
suffix:semicolon
id|rr
op_assign
l_int|31
suffix:semicolon
)brace
r_else
id|rr
op_assign
(paren
id|attentbl
(braket
(paren
id|r
op_star
l_int|10
)paren
op_div
l_int|100
)braket
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rl
OG
l_int|30
)paren
op_logical_and
(paren
id|rr
OG
l_int|30
)paren
)paren
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
op_assign
id|temp1
op_or
(paren
id|rl
op_lshift
l_int|8
)paren
op_or
id|rr
suffix:semicolon
id|cs4281_write_ac97
c_func
(paren
id|s
comma
id|mixreg
(braket
id|vidx
op_minus
l_int|1
)braket
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4281_llseek
r_static
id|loff_t
id|cs4281_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4281_open_mixdev
r_static
r_int
id|cs4281_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs4281_state
op_star
id|s
op_assign
id|devs
suffix:semicolon
r_while
c_loop
(paren
id|s
op_logical_and
id|s-&gt;dev_mixer
op_ne
id|minor
)paren
id|s
op_assign
id|s-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|s
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4281_release_mixdev
r_static
r_int
id|cs4281_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4281_ioctl_mixdev
r_static
r_int
id|cs4281_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|mixer_ioctl
c_func
(paren
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
singleline_comment|// ******************************************************************************************
singleline_comment|//   Mixer file operations struct.
singleline_comment|// ******************************************************************************************
DECL|variable|cs4281_mixer_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|cs4281_mixer_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs4281_llseek
comma
id|ioctl
suffix:colon
id|cs4281_ioctl_mixdev
comma
id|open
suffix:colon
id|cs4281_open_mixdev
comma
id|release
suffix:colon
id|cs4281_release_mixdev
comma
)brace
suffix:semicolon
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|drain_adc
r_static
r_int
id|drain_adc
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|tmo
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|s-&gt;dma_adc.count
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: drain_adc() %d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: drain_adc() count&lt;0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
l_int|3
op_star
id|HZ
op_star
(paren
id|count
op_plus
id|s-&gt;dma_adc.fragsize
)paren
op_div
l_int|2
op_div
id|s-&gt;prop_adc.rate
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
)paren
)paren
id|tmo
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc.channels
OG
l_int|1
)paren
id|tmo
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
op_plus
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs4281: dma timed out??&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|tmo
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
l_int|3
op_star
id|HZ
op_star
(paren
id|count
op_plus
id|s-&gt;dma_dac.fragsize
)paren
op_div
l_int|2
op_div
id|s-&gt;prop_dac.rate
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_dac.fmt
op_amp
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
)paren
)paren
id|tmo
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_dac.channels
OG
l_int|1
)paren
id|tmo
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
op_plus
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs4281: dma timed out??&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//****************************************************************************
singleline_comment|//
singleline_comment|// CopySamples copies 16-bit stereo samples from the source to the
singleline_comment|// destination, possibly converting down to either 8-bit or mono or both.
singleline_comment|// count specifies the number of output bytes to write.
singleline_comment|//
singleline_comment|//  Arguments:
singleline_comment|//
singleline_comment|//  dst             - Pointer to a destination buffer.
singleline_comment|//  src             - Pointer to a source buffer
singleline_comment|//  count           - The number of bytes to copy into the destination buffer.
singleline_comment|//  iChannels       - Stereo - 2
singleline_comment|//                    Mono   - 1
singleline_comment|//  fmt             - AFMT_xxx (soundcard.h formats)
singleline_comment|//
singleline_comment|// NOTES: only call this routine for conversion to 8bit from 16bit
singleline_comment|//
singleline_comment|//****************************************************************************
DECL|function|CopySamples
r_static
r_void
id|CopySamples
c_func
(paren
r_char
op_star
id|dst
comma
r_char
op_star
id|src
comma
r_int
id|count
comma
r_int
id|iChannels
comma
r_int
id|fmt
)paren
(brace
r_int
r_int
op_star
id|psSrc
suffix:semicolon
r_int
id|lAudioSample
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: CopySamples()+ &quot;
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; dst=0x%x src=0x%x count=%d iChannels=%d fmt=0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|dst
comma
(paren
r_int
)paren
id|src
comma
(paren
r_int
)paren
id|count
comma
(paren
r_int
)paren
id|iChannels
comma
(paren
r_int
)paren
id|fmt
)paren
)paren
suffix:semicolon
singleline_comment|// Gershwin does format conversion in hardware so normally
singleline_comment|// we don&squot;t do any host based coversion. The data formatter
singleline_comment|// truncates 16 bit data to 8 bit and that causes some hiss.
singleline_comment|// We have already forced the HW to do 16 bit sampling and 
singleline_comment|// 2 channel so that we can use software to round instead 
singleline_comment|// of truncate
singleline_comment|//
singleline_comment|// See if the data should be output as 8-bit unsigned stereo.
singleline_comment|//
r_if
c_cond
(paren
(paren
id|iChannels
op_eq
l_int|2
)paren
op_logical_and
(paren
id|fmt
op_amp
id|AFMT_U8
)paren
)paren
(brace
singleline_comment|//
singleline_comment|// Convert each 16-bit unsigned stereo sample to 8-bit unsigned 
singleline_comment|// stereo using rounding.
singleline_comment|//
id|psSrc
op_assign
(paren
r_int
r_int
op_star
)paren
id|src
suffix:semicolon
id|count
op_assign
id|count
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|lAudioSample
op_assign
(paren
r_int
)paren
id|psSrc
(braket
id|count
)braket
op_plus
(paren
r_int
)paren
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
id|lAudioSample
OG
l_int|0xffff
)paren
(brace
id|lAudioSample
op_assign
l_int|0xffff
suffix:semicolon
)brace
id|dst
(braket
id|count
)braket
op_assign
(paren
r_char
)paren
(paren
id|lAudioSample
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
singleline_comment|//
singleline_comment|// check for 8-bit signed stereo.
singleline_comment|//
r_else
r_if
c_cond
(paren
(paren
id|iChannels
op_eq
l_int|2
)paren
op_logical_and
(paren
id|fmt
op_amp
id|AFMT_S8
)paren
)paren
(brace
singleline_comment|//
singleline_comment|// Convert each 16-bit stereo sample to 8-bit stereo using rounding.
singleline_comment|//
id|psSrc
op_assign
(paren
r_int
op_star
)paren
id|src
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|lAudioSample
op_assign
(paren
(paren
(paren
r_int
)paren
id|psSrc
(braket
l_int|0
)braket
op_plus
(paren
r_int
)paren
id|psSrc
(braket
l_int|1
)braket
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|psSrc
op_add_assign
l_int|2
suffix:semicolon
op_star
id|dst
op_increment
op_assign
(paren
r_char
)paren
(paren
(paren
r_int
)paren
id|lAudioSample
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
singleline_comment|//
singleline_comment|// See if the data should be output at 8-bit unsigned mono.
singleline_comment|//
r_else
r_if
c_cond
(paren
(paren
id|iChannels
op_eq
l_int|1
)paren
op_logical_and
(paren
id|fmt
op_amp
id|AFMT_U8
)paren
)paren
(brace
singleline_comment|//
singleline_comment|// Convert each 16-bit unsigned mono sample to 8-bit unsigned
singleline_comment|// mono using rounding.
singleline_comment|//
id|psSrc
op_assign
(paren
r_int
op_star
)paren
id|src
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|lAudioSample
op_assign
(paren
r_int
)paren
op_star
id|psSrc
op_increment
op_plus
(paren
r_int
)paren
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
id|lAudioSample
OG
l_int|0x7fff
)paren
(brace
id|lAudioSample
op_assign
l_int|0x7fff
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Convert Signed to Unsigned.
singleline_comment|//
op_star
id|dst
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
(paren
r_int
)paren
id|lAudioSample
op_plus
(paren
r_int
)paren
l_int|0x8000
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
singleline_comment|//
singleline_comment|// Otherwise, the data should be output as 8-bit signed mono.
singleline_comment|//
r_else
r_if
c_cond
(paren
(paren
id|iChannels
op_eq
l_int|1
)paren
op_logical_and
(paren
id|fmt
op_amp
id|AFMT_S8
)paren
)paren
(brace
singleline_comment|//
singleline_comment|// Convert each 16-bit signed mono sample to 8-bit signed mono 
singleline_comment|// using rounding.
singleline_comment|//
id|psSrc
op_assign
(paren
r_int
op_star
)paren
id|src
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|lAudioSample
op_assign
(paren
(paren
(paren
r_int
)paren
id|psSrc
(braket
l_int|0
)braket
op_plus
(paren
r_int
)paren
id|psSrc
(braket
l_int|1
)braket
)paren
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lAudioSample
OG
l_int|0x7fff
)paren
(brace
id|lAudioSample
op_assign
l_int|0x7fff
suffix:semicolon
)brace
id|psSrc
op_add_assign
l_int|2
suffix:semicolon
op_star
id|dst
op_increment
op_assign
(paren
r_char
)paren
(paren
(paren
r_int
)paren
id|lAudioSample
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
)brace
singleline_comment|//
singleline_comment|// cs_copy_to_user()
singleline_comment|// replacement for the standard copy_to_user, to allow for a conversion from
singleline_comment|// 16 bit to 8 bit if the record conversion is active.  the cs4281 has some
singleline_comment|// issues with 8 bit capture, so the driver always captures data in 16 bit
singleline_comment|// and then if the user requested 8 bit, converts from 16 to 8 bit.
singleline_comment|//
DECL|function|cs_copy_to_user
r_static
r_int
id|cs_copy_to_user
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
comma
r_void
op_star
id|dest
comma
r_int
op_star
id|hwsrc
comma
r_int
id|cnt
comma
r_int
op_star
id|copied
)paren
(brace
r_void
op_star
id|src
op_assign
id|hwsrc
suffix:semicolon
singleline_comment|//default to the standard destination buffer addr
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs_copy_to_user()+ fmt=0x%x fmt_o=0x%x cnt=%d dest=0x%.8x&bslash;n&quot;
comma
id|s-&gt;prop_adc.fmt
comma
id|s-&gt;prop_adc.fmt_original
comma
(paren
r_int
)paren
id|cnt
comma
(paren
r_int
)paren
id|dest
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|s-&gt;dma_adc.dmasize
)paren
(brace
id|cnt
op_assign
id|s-&gt;dma_adc.dmasize
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
(brace
op_star
id|copied
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;tmpbuff
)paren
(brace
op_star
id|copied
op_assign
id|cnt
op_div
l_int|2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|CopySamples
c_func
(paren
id|s-&gt;tmpbuff
comma
(paren
r_void
op_star
)paren
id|hwsrc
comma
id|cnt
comma
(paren
r_int
)paren
id|s-&gt;prop_adc.channels
comma
id|s-&gt;prop_adc.fmt_original
)paren
suffix:semicolon
id|src
op_assign
id|s-&gt;tmpbuff
suffix:semicolon
id|cnt
op_assign
id|cnt
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dest
comma
id|src
comma
id|cnt
)paren
)paren
(brace
op_star
id|copied
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
op_star
id|copied
op_assign
id|cnt
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs_copy_to_user()- copied bytes is %d &bslash;n&quot;
comma
id|cnt
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4281_read
r_static
id|ssize_t
id|cs4281_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_read()+ %d &bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
singleline_comment|//
singleline_comment|// &quot;count&quot; is the amount of bytes to read (from app), is decremented each loop
singleline_comment|//      by the amount of bytes that have been returned to the user buffer.
singleline_comment|// &quot;cnt&quot; is the running total of each read from the buffer (changes each loop)
singleline_comment|// &quot;buffer&quot; points to the app&squot;s buffer
singleline_comment|// &quot;ret&quot; keeps a running total of the amount of bytes that have been copied
singleline_comment|//      to the user buffer.
singleline_comment|// &quot;copied&quot; is the total bytes copied into the user buffer for each loop.
singleline_comment|//
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;_read() count&gt;0 count=%d .count=%d .swptr=%d .hwptr=%d &bslash;n&quot;
comma
id|count
comma
id|s-&gt;dma_adc.count
comma
id|s-&gt;dma_adc.swptr
comma
id|s-&gt;dma_adc.hwptr
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// get the current copy point of the sw buffer
id|swptr
op_assign
id|s-&gt;dma_adc.swptr
suffix:semicolon
singleline_comment|// cnt is the amount of unread bytes from the end of the 
singleline_comment|// hw buffer to the current sw pointer
id|cnt
op_assign
id|s-&gt;dma_adc.dmasize
op_minus
id|swptr
suffix:semicolon
singleline_comment|// dma_adc.count is the current total bytes that have not been read.
singleline_comment|// if the amount of unread bytes from the current sw pointer to the
singleline_comment|// end of the buffer is greater than the current total bytes that
singleline_comment|// have not been read, then set the &quot;cnt&quot; (unread bytes) to the
singleline_comment|// amount of unread bytes.  
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OL
id|cnt
)paren
id|cnt
op_assign
id|s-&gt;dma_adc.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// if we are converting from 8/16 then we need to copy
singleline_comment|// twice the number of 16 bit bytes then 8 bit bytes.
singleline_comment|// 
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
r_if
c_cond
(paren
id|cnt
OG
(paren
id|count
op_star
l_int|2
)paren
)paren
id|cnt
op_assign
(paren
id|count
op_star
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// &quot;cnt&quot; NOW is the smaller of the amount that will be read,
singleline_comment|// and the amount that is requested in this read (or partial).
singleline_comment|// if there are no bytes in the buffer to read, then start the
singleline_comment|// ADC and wait for the interrupt handler to wake us up.
singleline_comment|//
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
singleline_comment|// start up the dma engine and then continue back to the top of
singleline_comment|// the loop when wake up occurs.
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// there are bytes in the buffer to read.
singleline_comment|// copy from the hw buffer over to the user buffer.
singleline_comment|// user buffer is designated by &quot;buffer&quot;
singleline_comment|// virtual address to copy from is rawbuf+swptr
singleline_comment|// the &quot;cnt&quot; is the number of bytes to read.
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;_read() copy_to cnt=%d count=%d &quot;
comma
id|cnt
comma
id|count
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; .dmasize=%d .count=%d buffer=0x%.8x ret=%d&bslash;n&quot;
comma
id|s-&gt;dma_adc.dmasize
comma
id|s-&gt;dma_adc.count
comma
(paren
r_int
)paren
id|buffer
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cs_copy_to_user
(paren
id|s
comma
id|buffer
comma
id|s-&gt;dma_adc.rawbuf
op_plus
id|swptr
comma
id|cnt
comma
op_amp
id|copied
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|s-&gt;dma_adc.dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;dma_adc.swptr
op_assign
id|swptr
suffix:semicolon
id|s-&gt;dma_adc.count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|copied
suffix:semicolon
id|buffer
op_add_assign
id|copied
suffix:semicolon
id|ret
op_add_assign
id|copied
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_read()- %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs4281_write
r_static
id|ssize_t
id|cs4281_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_write()+ count=%d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
OL
l_int|0
)paren
(brace
id|s-&gt;dma_dac.count
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|s-&gt;dma_dac.hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|s-&gt;dma_dac.swptr
suffix:semicolon
id|cnt
op_assign
id|s-&gt;dma_dac.dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_plus
id|cnt
OG
id|s-&gt;dma_dac.dmasize
)paren
id|cnt
op_assign
id|s-&gt;dma_dac.dmasize
op_minus
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|s-&gt;dma_dac.rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|s-&gt;dma_dac.dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|swptr
suffix:semicolon
id|s-&gt;dma_dac.count
op_add_assign
id|cnt
suffix:semicolon
id|s-&gt;dma_dac.endcleared
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_write()- %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs4281_poll
r_static
r_int
r_int
id|cs4281_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_poll()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_poll() wait on FMODE_WRITE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;dma_dac.wait
comma
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_poll() wait on FMODE_READ&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;dma_adc.wait
comma
id|wait
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.wakeup
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_else
id|mask
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.wakeup
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|s-&gt;dma_dac.dmasize
OG
id|s-&gt;dma_dac.count
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_adc.fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OG
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_poll()- 0x%.8x&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|cs4281_mmap
r_static
r_int
id|cs4281_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|db
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_PARMS
op_or
id|CS_OPEN
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_mmap()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|db
op_assign
op_amp
id|s-&gt;dma_dac
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|db
op_assign
op_amp
id|s-&gt;dma_adc
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|//
singleline_comment|// only support PLAYBACK for now
singleline_comment|//
id|db
op_assign
op_amp
id|s-&gt;dma_dac
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|db-&gt;buforder
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|db-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|db-&gt;mapped
op_assign
l_int|1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_PARMS
op_or
id|CS_OPEN
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_mmap()- 0 size=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4281_ioctl
r_static
r_int
id|cs4281_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
comma
id|mapped
comma
id|ret
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): file=0x%.8x cmd=0x%.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|file
comma
id|cmd
)paren
)paren
suffix:semicolon
macro_line|#if CSDEBUG
id|printioctl
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|mapped
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|s-&gt;dma_dac.mapped
)paren
op_logical_or
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|s-&gt;dma_adc.mapped
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): SOUND_VERSION=0x%.8x&bslash;n&quot;
comma
id|SOUND_VERSION
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_SYNC&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|drain_dac
c_func
(paren
id|s
comma
l_int|0
multiline_comment|/*file-&gt;f_flags &amp; O_NONBLOCK */
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|DSP_CAP_DUPLEX
op_or
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_RESET&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|s-&gt;dma_dac.hwptr
op_assign
id|s-&gt;dma_dac.count
op_assign
id|s-&gt;dma_dac.total_bytes
op_assign
id|s-&gt;dma_dac.blocks
op_assign
id|s-&gt;dma_dac.wakeup
op_assign
l_int|0
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_DAC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|s-&gt;dma_adc.swptr
op_assign
id|s-&gt;dma_adc.hwptr
op_assign
id|s-&gt;dma_adc.count
op_assign
id|s-&gt;dma_adc.total_bytes
op_assign
id|s-&gt;dma_adc.blocks
op_assign
id|s-&gt;dma_dac.wakeup
op_assign
l_int|0
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_SPEED val=%d&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// support independent capture and playback channels
singleline_comment|// assume that the file mode bit determines the 
singleline_comment|// direction of the data flow.
singleline_comment|//
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
singleline_comment|// program sampling rates 
r_if
c_cond
(paren
id|val
OG
l_int|48000
)paren
id|val
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
l_int|6300
)paren
id|val
op_assign
l_int|6300
suffix:semicolon
id|s-&gt;prop_adc.rate
op_assign
id|val
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
singleline_comment|// program sampling rates 
r_if
c_cond
(paren
id|val
OG
l_int|48000
)paren
id|val
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
l_int|6300
)paren
id|val
op_assign
l_int|6300
suffix:semicolon
id|s-&gt;prop_dac.rate
op_assign
id|val
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_DAC
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|val
op_assign
id|s-&gt;prop_dac.rate
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|val
op_assign
id|s-&gt;prop_adc.rate
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_STEREO val=%d&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
id|s-&gt;prop_adc.channels
op_assign
id|val
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
id|s-&gt;prop_dac.channels
op_assign
id|val
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_DAC
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_CHANNELS val=%d&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|2
)paren
id|s-&gt;prop_adc.channels
op_assign
l_int|2
suffix:semicolon
r_else
id|s-&gt;prop_adc.channels
op_assign
l_int|1
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|2
)paren
id|s-&gt;prop_dac.channels
op_assign
l_int|2
suffix:semicolon
r_else
id|s-&gt;prop_dac.channels
op_assign
l_int|1
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_DAC
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|val
op_assign
id|s-&gt;prop_dac.channels
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|val
op_assign
id|s-&gt;prop_adc.channels
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
singleline_comment|// Returns a mask 
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_GETFMT val=0x%.8x&bslash;n&quot;
comma
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S8
op_or
id|AFMT_U8
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S8
op_or
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_SETFMT val=0x%.8x&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_QUERY
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_S16_LE
op_logical_and
id|val
op_ne
id|AFMT_U16_LE
op_logical_and
id|val
op_ne
id|AFMT_S8
op_logical_and
id|val
op_ne
id|AFMT_U8
)paren
id|val
op_assign
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_assign
id|val
suffix:semicolon
id|s-&gt;prop_adc.fmt_original
op_assign
id|s-&gt;prop_adc.fmt
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_S16_LE
op_logical_and
id|val
op_ne
id|AFMT_U16_LE
op_logical_and
id|val
op_ne
id|AFMT_S8
op_logical_and
id|val
op_ne
id|AFMT_U8
)paren
id|val
op_assign
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_dac.fmt
op_assign
id|val
suffix:semicolon
id|s-&gt;prop_dac.fmt_original
op_assign
id|s-&gt;prop_dac.fmt
suffix:semicolon
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_DAC
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|val
op_assign
id|s-&gt;prop_dac.fmt_original
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|val
op_assign
id|s-&gt;prop_adc.fmt_original
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_SETFMT return val=0x%.8x&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): DSP_POST&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|s-&gt;dma_dac.fragsize
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
id|abinfo.bytes
op_assign
id|s-&gt;dma_dac.dmasize
suffix:semicolon
r_else
id|abinfo.bytes
op_assign
id|s-&gt;dma_dac.dmasize
op_minus
id|s-&gt;dma_dac.count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_dac.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_ioctl(): GETOSPACE .fragsize=%d .bytes=%d .fragstotal=%d .fragments=%d&bslash;n&quot;
comma
id|abinfo
dot
id|fragsize
comma
id|abinfo.bytes
comma
id|abinfo
dot
id|fragstotal
comma
id|abinfo
dot
id|fragments
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
id|abinfo.fragsize
op_assign
id|s-&gt;dma_adc.fragsize
op_div
l_int|2
suffix:semicolon
id|abinfo.bytes
op_assign
id|s-&gt;dma_adc.count
op_div
l_int|2
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_adc.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
(paren
id|s-&gt;dma_adc.fragshift
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|abinfo.fragsize
op_assign
id|s-&gt;dma_adc.fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|s-&gt;dma_adc.count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_adc.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|val
op_assign
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|s-&gt;dma_adc.total_bytes
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
(brace
id|cinfo.blocks
op_assign
(paren
id|cinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
)paren
op_minus
id|s-&gt;dma_adc.blocks
suffix:semicolon
id|s-&gt;dma_adc.blocks
op_assign
id|cinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
id|cinfo.blocks
op_assign
id|s-&gt;dma_adc.count
op_div
l_int|2
op_rshift
(paren
id|s-&gt;dma_adc.fragshift
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|cinfo.blocks
op_assign
id|s-&gt;dma_adc.count
op_rshift
id|s-&gt;dma_adc
dot
id|fragshift
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
id|cinfo.ptr
op_assign
id|s-&gt;dma_adc.hwptr
op_div
l_int|2
suffix:semicolon
r_else
id|cinfo.ptr
op_assign
id|s-&gt;dma_adc.hwptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
id|s-&gt;dma_adc.count
op_and_assign
id|s-&gt;dma_adc.fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|s-&gt;dma_dac.total_bytes
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
id|cinfo.blocks
op_assign
(paren
id|cinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
)paren
op_minus
id|s-&gt;dma_dac.blocks
suffix:semicolon
id|s-&gt;dma_dac.blocks
op_assign
id|cinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
)brace
r_else
(brace
id|cinfo.blocks
op_assign
id|s-&gt;dma_dac.count
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
)brace
id|cinfo.ptr
op_assign
id|s-&gt;dma_dac.hwptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
id|s-&gt;dma_dac.count
op_and_assign
id|s-&gt;dma_dac.fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_dac.fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_adc.fragsize
op_div
l_int|2
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_adc.fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
singleline_comment|// Say OK, but do nothing.
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|s-&gt;dma_adc.subdivision
)paren
op_logical_or
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|s-&gt;dma_dac.subdivision
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
op_logical_and
id|val
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|s-&gt;dma_adc.subdivision
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|s-&gt;dma_dac.subdivision
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_adc.rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_dac.rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_adc.channels
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_dac.channels
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;prop_adc
dot
id|fmt
op_amp
(paren
id|AFMT_S8
op_or
id|AFMT_U8
)paren
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|16
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_S8
op_or
id|AFMT_U8
)paren
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|16
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if CSDEBUG_INTERFACE
r_case
id|SNDCTL_DSP_CS_GETDBGMASK
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debugmask
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_GETDBGLEVEL
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debuglevel
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_SETDBGMASK
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debugmask
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_CS_SETDBGLEVEL
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debuglevel
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_return
id|mixer_ioctl
c_func
(paren
id|s
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|cs4281_release
r_static
r_int
id|cs4281_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_RELEASE
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_release(): inode=0x%.8x file=0x%.8x f_mode=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode
comma
(paren
r_int
)paren
id|file
comma
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|drain_dac
c_func
(paren
id|s
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|s
comma
op_amp
id|s-&gt;dma_dac
)paren
suffix:semicolon
id|s-&gt;open_mode
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;open_wait_dac
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|drain_adc
c_func
(paren
id|s
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|s
comma
op_amp
id|s-&gt;dma_adc
)paren
suffix:semicolon
id|s-&gt;open_mode
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;open_wait_adc
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4281_open
r_static
r_int
id|cs4281_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs4281_state
op_star
id|s
op_assign
id|devs
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_open(): inode=0x%.8x file=0x%.8x f_mode=0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode
comma
(paren
r_int
)paren
id|file
comma
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s
op_logical_and
(paren
(paren
id|s-&gt;dev_audio
op_xor
id|minor
)paren
op_amp
op_complement
l_int|0xf
)paren
)paren
id|s
op_assign
id|s-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_open(): Error - unable to find audio state struct&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|s
suffix:semicolon
singleline_comment|// wait for device to become free 
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_WRITE
op_or
id|FMODE_READ
)paren
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_open(): Error - must open READ and/or WRITE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;open_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;open_wait_dac
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;open_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;open_wait_adc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
)brace
)brace
id|s-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|s-&gt;prop_adc.fmt
op_assign
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_adc.fmt_original
op_assign
id|s-&gt;prop_adc.fmt
suffix:semicolon
id|s-&gt;prop_adc.channels
op_assign
l_int|1
suffix:semicolon
id|s-&gt;prop_adc.rate
op_assign
l_int|8000
suffix:semicolon
id|s-&gt;prop_adc.clkdiv
op_assign
l_int|96
op_or
l_int|0x80
suffix:semicolon
id|s-&gt;conversion
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
id|s-&gt;dma_adc.ossfragshift
op_assign
id|s-&gt;dma_adc.ossmaxfrags
op_assign
id|s-&gt;dma_adc.subdivision
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: adc Program dmabufs failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cs4281_release
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|s-&gt;prop_dac.fmt
op_assign
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_dac.fmt_original
op_assign
id|s-&gt;prop_dac.fmt
suffix:semicolon
id|s-&gt;prop_dac.channels
op_assign
l_int|1
suffix:semicolon
id|s-&gt;prop_dac.rate
op_assign
l_int|8000
suffix:semicolon
id|s-&gt;prop_dac.clkdiv
op_assign
l_int|96
op_or
l_int|0x80
suffix:semicolon
id|s-&gt;conversion
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
id|s-&gt;dma_dac.ossfragshift
op_assign
id|s-&gt;dma_dac.ossmaxfrags
op_assign
id|s-&gt;dma_dac.subdivision
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: dac Program dmabufs failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cs4281_release
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_DAC
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_open()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// ******************************************************************************************
singleline_comment|//   Wave (audio) file operations struct.
singleline_comment|// ******************************************************************************************
DECL|variable|cs4281_audio_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|cs4281_audio_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs4281_llseek
comma
id|read
suffix:colon
id|cs4281_read
comma
id|write
suffix:colon
id|cs4281_write
comma
id|poll
suffix:colon
id|cs4281_poll
comma
id|ioctl
suffix:colon
id|cs4281_ioctl
comma
id|mmap
suffix:colon
id|cs4281_mmap
comma
id|open
suffix:colon
id|cs4281_open
comma
id|release
suffix:colon
id|cs4281_release
comma
)brace
suffix:semicolon
singleline_comment|// --------------------------------------------------------------------- 
singleline_comment|// hold spinlock for the following! 
DECL|function|cs4281_handle_midi
r_static
r_void
id|cs4281_handle_midi
c_func
(paren
r_struct
id|cs4281_state
op_star
id|s
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
r_int
id|wake
suffix:semicolon
r_int
id|temp1
suffix:semicolon
id|wake
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_MIDSR
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|ch
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_MIDRP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;midi.icnt
OL
id|MIDIINBUF
)paren
(brace
id|s-&gt;midi.ibuf
(braket
id|s-&gt;midi.iwr
)braket
op_assign
id|ch
suffix:semicolon
id|s-&gt;midi.iwr
op_assign
(paren
id|s-&gt;midi.iwr
op_plus
l_int|1
)paren
op_mod
id|MIDIINBUF
suffix:semicolon
id|s-&gt;midi.icnt
op_increment
suffix:semicolon
)brace
id|wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wake
)paren
id|wake_up
c_func
(paren
op_amp
id|s-&gt;midi.iwait
)paren
suffix:semicolon
id|wake
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_MIDSR
)paren
op_amp
l_int|0x40
)paren
op_logical_and
id|s-&gt;midi.ocnt
OG
l_int|0
)paren
(brace
id|temp1
op_assign
(paren
id|s-&gt;midi.obuf
(braket
id|s-&gt;midi.ord
)braket
)paren
op_amp
l_int|0x000000ff
suffix:semicolon
id|writel
c_func
(paren
id|temp1
comma
id|s-&gt;pBA0
op_plus
id|BA0_MIDWP
)paren
suffix:semicolon
id|s-&gt;midi.ord
op_assign
(paren
id|s-&gt;midi.ord
op_plus
l_int|1
)paren
op_mod
id|MIDIOUTBUF
suffix:semicolon
id|s-&gt;midi.ocnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;midi.ocnt
OL
id|MIDIOUTBUF
op_minus
l_int|16
)paren
id|wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wake
)paren
id|wake_up
c_func
(paren
op_amp
id|s-&gt;midi.owait
)paren
suffix:semicolon
)brace
DECL|function|cs4281_interrupt
r_static
r_void
id|cs4281_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|temp1
suffix:semicolon
singleline_comment|// fastpath out, to ease interrupt sharing 
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_HISR
)paren
suffix:semicolon
singleline_comment|// Get Int Status reg.
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_interrupt() BA0_HISR=0x%.8x&bslash;n&quot;
comma
id|temp1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp1
op_amp
(paren
id|HISR_DMA0
op_or
id|HISR_DMA1
op_or
id|HISR_MIDI
)paren
)paren
)paren
(brace
singleline_comment|// If not DMA or MIDI int,
id|writel
c_func
(paren
id|HICR_IEV
op_or
id|HICR_CHGM
comma
id|s-&gt;pBA0
op_plus
id|BA0_HICR
)paren
suffix:semicolon
singleline_comment|//  reenable interrupts
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_interrupt(): returning not cs4281 interrupt.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
singleline_comment|//   and return.
)brace
r_if
c_cond
(paren
id|temp1
op_amp
id|HISR_DMA0
)paren
singleline_comment|// If play interrupt,
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_HDSR0
)paren
suffix:semicolon
singleline_comment|//   clear the source.
r_if
c_cond
(paren
id|temp1
op_amp
id|HISR_DMA1
)paren
singleline_comment|// Same for play.
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_HDSR1
)paren
suffix:semicolon
id|writel
c_func
(paren
id|HICR_IEV
op_or
id|HICR_CHGM
comma
id|s-&gt;pBA0
op_plus
id|BA0_HICR
)paren
suffix:semicolon
singleline_comment|// Local EOI
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|cs4281_update_ptr
c_func
(paren
id|s
)paren
suffix:semicolon
id|cs4281_handle_midi
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
singleline_comment|// **************************************************************************
DECL|function|cs4281_midi_timer
r_static
r_void
id|cs4281_midi_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_handle_midi
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;midi.timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|s-&gt;midi.timer
)paren
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4281_midi_read
r_static
id|ssize_t
id|cs4281_midi_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ptr
op_assign
id|s-&gt;midi.ird
suffix:semicolon
id|cnt
op_assign
id|MIDIINBUF
op_minus
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;midi.icnt
OL
id|cnt
)paren
id|cnt
op_assign
id|s-&gt;midi.icnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;midi.iwait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|s-&gt;midi.ibuf
op_plus
id|ptr
comma
id|cnt
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
(paren
id|ptr
op_plus
id|cnt
)paren
op_mod
id|MIDIINBUF
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;midi.ird
op_assign
id|ptr
suffix:semicolon
id|s-&gt;midi.icnt
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs4281_midi_write
r_static
id|ssize_t
id|cs4281_midi_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ptr
op_assign
id|s-&gt;midi.owr
suffix:semicolon
id|cnt
op_assign
id|MIDIOUTBUF
op_minus
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;midi.ocnt
op_plus
id|cnt
OG
id|MIDIOUTBUF
)paren
id|cnt
op_assign
id|MIDIOUTBUF
op_minus
id|s-&gt;midi.ocnt
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
id|cs4281_handle_midi
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;midi.owait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|s-&gt;midi.obuf
op_plus
id|ptr
comma
id|buffer
comma
id|cnt
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
(paren
id|ptr
op_plus
id|cnt
)paren
op_mod
id|MIDIOUTBUF
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;midi.owr
op_assign
id|ptr
suffix:semicolon
id|s-&gt;midi.ocnt
op_add_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4281_handle_midi
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs4281_midi_poll
r_static
r_int
r_int
id|cs4281_midi_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_WRITE
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;midi.owait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_READ
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;midi.iwait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;midi.icnt
OG
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;midi.ocnt
OL
id|MIDIOUTBUF
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|cs4281_midi_open
r_static
r_int
id|cs4281_midi_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|cs4281_state
op_star
id|s
op_assign
id|devs
suffix:semicolon
r_int
r_int
id|flags
comma
id|temp1
suffix:semicolon
r_while
c_loop
(paren
id|s
op_logical_and
id|s-&gt;dev_midi
op_ne
id|minor
)paren
id|s
op_assign
id|s-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|s
suffix:semicolon
singleline_comment|// wait for device to become free 
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;open_mode
op_amp
(paren
id|file-&gt;f_mode
op_lshift
id|FMODE_MIDI_SHIFT
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;open_mode
op_amp
(paren
id|FMODE_MIDI_READ
op_or
id|FMODE_MIDI_WRITE
)paren
)paren
)paren
(brace
id|s-&gt;midi.ird
op_assign
id|s-&gt;midi.iwr
op_assign
id|s-&gt;midi.icnt
op_assign
l_int|0
suffix:semicolon
id|s-&gt;midi.ord
op_assign
id|s-&gt;midi.owr
op_assign
id|s-&gt;midi.ocnt
op_assign
l_int|0
suffix:semicolon
id|writel
c_func
(paren
l_int|1
comma
id|s-&gt;pBA0
op_plus
id|BA0_MIDCR
)paren
suffix:semicolon
singleline_comment|// Reset the interface.
id|writel
c_func
(paren
l_int|0
comma
id|s-&gt;pBA0
op_plus
id|BA0_MIDCR
)paren
suffix:semicolon
singleline_comment|// Return to normal mode.
id|s-&gt;midi.ird
op_assign
id|s-&gt;midi.iwr
op_assign
id|s-&gt;midi.icnt
op_assign
l_int|0
suffix:semicolon
id|writel
c_func
(paren
l_int|0x0000000f
comma
id|s-&gt;pBA0
op_plus
id|BA0_MIDCR
)paren
suffix:semicolon
singleline_comment|// Enable transmit, record, ints.
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_HIMR
)paren
suffix:semicolon
id|writel
c_func
(paren
id|temp1
op_amp
l_int|0xffbfffff
comma
id|s-&gt;pBA0
op_plus
id|BA0_HIMR
)paren
suffix:semicolon
singleline_comment|// Enable midi int. recognition.
id|writel
c_func
(paren
id|HICR_IEV
op_or
id|HICR_CHGM
comma
id|s-&gt;pBA0
op_plus
id|BA0_HICR
)paren
suffix:semicolon
singleline_comment|// Enable interrupts
id|init_timer
c_func
(paren
op_amp
id|s-&gt;midi.timer
)paren
suffix:semicolon
id|s-&gt;midi.timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|s-&gt;midi.timer.data
op_assign
(paren
r_int
r_int
)paren
id|s
suffix:semicolon
id|s-&gt;midi.timer.function
op_assign
id|cs4281_midi_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|s-&gt;midi.timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|s-&gt;midi.ird
op_assign
id|s-&gt;midi.iwr
op_assign
id|s-&gt;midi.icnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|s-&gt;midi.ord
op_assign
id|s-&gt;midi.owr
op_assign
id|s-&gt;midi.ocnt
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;open_mode
op_or_assign
(paren
id|file
op_member_access_from_pointer
id|f_mode
op_lshift
id|FMODE_MIDI_SHIFT
)paren
op_amp
(paren
id|FMODE_MIDI_READ
op_or
id|FMODE_MIDI_WRITE
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4281_midi_release
r_static
r_int
id|cs4281_midi_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
comma
id|tmo
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|add_wait_queue
c_func
(paren
op_amp
id|s-&gt;midi.owait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|s-&gt;midi.ocnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;midi.owait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|count
op_star
id|HZ
)paren
op_div
l_int|3100
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs4281: midi timed out??&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;midi.owait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|s-&gt;open_mode
op_and_assign
(paren
op_complement
(paren
id|file-&gt;f_mode
op_lshift
id|FMODE_MIDI_SHIFT
)paren
)paren
op_amp
(paren
id|FMODE_MIDI_READ
op_or
id|FMODE_MIDI_WRITE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;open_mode
op_amp
(paren
id|FMODE_MIDI_READ
op_or
id|FMODE_MIDI_WRITE
)paren
)paren
)paren
(brace
id|writel
c_func
(paren
l_int|0
comma
id|s-&gt;pBA0
op_plus
id|BA0_MIDCR
)paren
suffix:semicolon
singleline_comment|// Disable Midi interrupts.  
id|del_timer
c_func
(paren
op_amp
id|s-&gt;midi.timer
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// ******************************************************************************************
singleline_comment|//   Midi file operations struct.
singleline_comment|// ******************************************************************************************
DECL|variable|cs4281_midi_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|cs4281_midi_fops
op_assign
(brace
id|llseek
suffix:colon
id|cs4281_llseek
comma
id|read
suffix:colon
id|cs4281_midi_read
comma
id|write
suffix:colon
id|cs4281_midi_write
comma
id|poll
suffix:colon
id|cs4281_midi_poll
comma
id|open
suffix:colon
id|cs4281_midi_open
comma
id|release
suffix:colon
id|cs4281_midi_release
comma
)brace
suffix:semicolon
singleline_comment|// --------------------------------------------------------------------- 
singleline_comment|// maximum number of devices 
DECL|macro|NR_DEVICE
mdefine_line|#define NR_DEVICE 8&t;&t;
singleline_comment|// Only eight devices supported currently.
singleline_comment|// --------------------------------------------------------------------- 
DECL|struct|initvol
r_static
r_struct
id|initvol
(brace
DECL|member|mixch
r_int
id|mixch
suffix:semicolon
DECL|member|vol
r_int
id|vol
suffix:semicolon
DECL|variable|__initdata
)brace
id|initvol
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|SOUND_MIXER_WRITE_VOLUME
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_PCM
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_SYNTH
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_CD
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_LINE
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_LINE1
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_RECLEV
comma
l_int|0x0000
)brace
comma
(brace
id|SOUND_MIXER_WRITE_SPEAKER
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_MIC
comma
l_int|0x0000
)brace
)brace
suffix:semicolon
DECL|function|cs4281_probe
r_static
r_int
id|__devinit
id|cs4281_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcidev
comma
r_const
r_struct
id|pci_device_id
op_star
id|pciid
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
suffix:semicolon
id|dma_addr_t
id|dma_mask
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|i
comma
id|val
comma
id|index
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|temp1
comma
id|temp2
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_INIT
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: probe()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RSRCISMEMORYREGION
c_func
(paren
id|pcidev
comma
l_int|0
)paren
op_logical_or
op_logical_neg
id|RSRCISMEMORYREGION
c_func
(paren
id|pcidev
comma
l_int|1
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe()- Memory region not assigned&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcidev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe() IRQ not assigned&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pci_dma_supported
c_func
(paren
id|pcidev
comma
l_int|0xffffffff
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe() architecture does not support 32bit PCI busmaster DMA&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dma_mask
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* this enables playback and recording */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs4281_state
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe() no memory for state struct.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|s
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cs4281_state
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait_adc
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait_dac
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;midi.iwait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;midi.owait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|s-&gt;open_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|s-&gt;pBA0phys
op_assign
id|RSRCADDRESS
c_func
(paren
id|pcidev
comma
l_int|0
)paren
suffix:semicolon
id|s-&gt;pBA1phys
op_assign
id|RSRCADDRESS
c_func
(paren
id|pcidev
comma
l_int|1
)paren
suffix:semicolon
id|s-&gt;pBA0
op_assign
id|ioremap_nocache
c_func
(paren
id|s-&gt;pBA0phys
comma
l_int|4096
)paren
suffix:semicolon
singleline_comment|// Convert phys 
id|s-&gt;pBA1
op_assign
id|ioremap_nocache
c_func
(paren
id|s-&gt;pBA1phys
comma
l_int|65536
)paren
suffix:semicolon
singleline_comment|//  to linear. 
id|temp1
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_PCICFG00
)paren
suffix:semicolon
id|temp2
op_assign
id|readl
c_func
(paren
id|s-&gt;pBA0
op_plus
id|BA0_PCICFG04
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: probe() BA0=0x%.8x BA1=0x%.8x pBA0=0x%.8x pBA1=0x%.8x &bslash;n&quot;
comma
(paren
r_int
)paren
id|temp1
comma
(paren
r_int
)paren
id|temp2
comma
(paren
r_int
)paren
id|s-&gt;pBA0
comma
(paren
r_int
)paren
id|s-&gt;pBA1
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: probe() pBA0phys=0x%.8x pBA1phys=0x%.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|s-&gt;pBA0phys
comma
(paren
r_int
)paren
id|s-&gt;pBA1phys
)paren
)paren
suffix:semicolon
id|temp1
op_assign
id|cs4281_hw_init
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp1
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
op_or
id|CS_INIT
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: cs4281_hw_init() failed. Skipping part.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|s-&gt;magic
op_assign
id|CS4281_MAGIC
suffix:semicolon
id|s-&gt;pcidev
op_assign
id|pcidev
suffix:semicolon
id|s-&gt;irq
op_assign
id|pcidev-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pcidev
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: pci_enable_device() failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_irq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
(paren
id|s-&gt;irq
comma
id|cs4281_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;Crystal CS4281&quot;
comma
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: irq %u in use&bslash;n&quot;
comma
id|s-&gt;irq
)paren
)paren
suffix:semicolon
r_goto
id|err_irq
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|s-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|cs4281_audio_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe() register_sound_dsp() failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_dev1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|s-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|cs4281_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe() register_sound_mixer() failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_dev2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|s-&gt;dev_midi
op_assign
id|register_sound_midi
c_func
(paren
op_amp
id|cs4281_midi_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4281: probe() register_sound_midi() failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_dev3
suffix:semicolon
)brace
id|pci_set_master
c_func
(paren
id|pcidev
)paren
suffix:semicolon
singleline_comment|// enable bus mastering 
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|val
op_assign
id|SOUND_MASK_LINE
suffix:semicolon
id|mixer_ioctl
c_func
(paren
id|s
comma
id|SOUND_MIXER_WRITE_RECSRC
comma
(paren
r_int
r_int
)paren
op_amp
id|val
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|initvol
)paren
op_div
r_sizeof
(paren
id|initvol
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|initvol
(braket
id|i
)braket
dot
id|vol
suffix:semicolon
id|mixer_ioctl
c_func
(paren
id|s
comma
id|initvol
(braket
id|i
)braket
dot
id|mixch
comma
(paren
r_int
r_int
)paren
op_amp
id|val
)paren
suffix:semicolon
)brace
id|val
op_assign
l_int|1
suffix:semicolon
singleline_comment|// enable mic preamp 
id|mixer_ioctl
c_func
(paren
id|s
comma
id|SOUND_MIXER_PRIVATE1
comma
(paren
r_int
r_int
)paren
op_amp
id|val
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
singleline_comment|// queue it for later freeing 
id|s-&gt;next
op_assign
id|devs
suffix:semicolon
id|pcidev-&gt;driver_data
op_assign
id|s
suffix:semicolon
id|pcidev-&gt;dma_mask
op_assign
id|dma_mask
suffix:semicolon
id|devs
op_assign
id|s
suffix:semicolon
id|index
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_dev3
suffix:colon
id|unregister_sound_mixer
c_func
(paren
id|s-&gt;dev_mixer
)paren
suffix:semicolon
id|err_dev2
suffix:colon
id|unregister_sound_dsp
c_func
(paren
id|s-&gt;dev_audio
)paren
suffix:semicolon
id|err_dev1
suffix:colon
id|free_irq
c_func
(paren
id|s-&gt;irq
comma
id|s
)paren
suffix:semicolon
id|err_irq
suffix:colon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devs
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: probe()- no device allocated&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: probe()- device allocated successfully&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// probe_cs4281
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4281_remove
r_static
r_void
id|__devinit
id|cs4281_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|cs4281_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4281_state
op_star
)paren
id|dev-&gt;driver_data
suffix:semicolon
singleline_comment|// stop DMA controller 
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|s-&gt;irq
comma
id|s
)paren
suffix:semicolon
id|unregister_sound_dsp
c_func
(paren
id|s-&gt;dev_audio
)paren
suffix:semicolon
id|unregister_sound_mixer
c_func
(paren
id|s-&gt;dev_mixer
)paren
suffix:semicolon
id|unregister_sound_midi
c_func
(paren
id|s-&gt;dev_midi
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
id|dev-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cs4281_remove(): remove successful&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|id_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_CIRRUS
comma
id|PCI_DEVICE_ID_CRYSTAL_CS4281
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|id_table
)paren
suffix:semicolon
DECL|variable|cs4281_driver
r_static
r_struct
id|pci_driver
id|cs4281_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;cs4281&quot;
comma
id|id_table
suffix:colon
id|id_table
comma
id|probe
suffix:colon
id|cs4281_probe
comma
id|remove
suffix:colon
id|cs4281_remove
)brace
suffix:semicolon
DECL|function|init_cs4281
r_static
r_int
id|__init
id|init_cs4281
c_func
(paren
r_void
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: init_cs4281()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* No PCI bus in this machine! */
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: init_cs4281()- no pci bus found&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: version v%d.%02d.%d time &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
comma
id|CS4281_MAJOR_VERSION
comma
id|CS4281_MINOR_VERSION
comma
id|CS4281_ARCH
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_register_driver
c_func
(paren
op_amp
id|cs4281_driver
)paren
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|cs4281_driver
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: init_cs4281()- unable to register pci device &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: init_cs4281()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;gw boynton, wesb@crystal.cirrus.com&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Cirrus Logic CS4281 Driver&quot;
)paren
suffix:semicolon
DECL|function|cleanup_cs4281
r_static
r_void
id|__exit
id|cleanup_cs4281
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|cs4281_driver
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4281: cleanup_cs4281() finished&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|variable|init_cs4281
id|module_init
c_func
(paren
id|init_cs4281
)paren
suffix:semicolon
DECL|variable|cleanup_cs4281
id|module_exit
c_func
(paren
id|cleanup_cs4281
)paren
suffix:semicolon
eof
