multiline_comment|/* &n; * Audio driver for the NeoMagic 256AV and 256ZX chipsets in native&n; * mode, with AC97 mixer support.&n; *&n; * Overall design and parts of this code stolen from vidc_*.c and&n; * skeleton.c.&n; *&n; * Yeah, there are a lot of magic constants in here.  You tell ME what&n; * they are.  I just get this stuff psychically, remember? &n; *&n; * This driver was written by someone who wishes to remain anonymous. &n; * It is in the public domain, so share and enjoy.  Try to make a profit&n; * off of it; go on, I dare you.  &n; *&n; * Changes:&n; * 11-10-2000&t;Bartlomiej Zolnierkiewicz &lt;bkz@linux-ide.org&gt;&n; *&t;&t;Added some __init&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &quot;nm256.h&quot;
macro_line|#include &quot;nm256_coeff.h&quot;
DECL|variable|nm256_debug
r_int
id|nm256_debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|force_load
r_static
r_int
id|force_load
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; * The size of the playback reserve.  When the playback buffer has less&n; * than NM256_PLAY_WMARK_SIZE bytes to output, we request a new&n; * buffer.&n; */
DECL|macro|NM256_PLAY_WMARK_SIZE
mdefine_line|#define NM256_PLAY_WMARK_SIZE 512
DECL|variable|nm256_audio_driver
r_static
r_struct
id|audio_driver
id|nm256_audio_driver
suffix:semicolon
r_static
r_int
id|nm256_grabInterrupt
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|nm256_releaseInterrupt
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|nm256_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|nm256_interrupt_zx
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|dummy
)paren
suffix:semicolon
r_static
r_int
id|handle_pm_event
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/* These belong in linux/pci.h. */
DECL|macro|PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO
mdefine_line|#define PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO 0x8005
DECL|macro|PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO
mdefine_line|#define PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO 0x8006
DECL|macro|RSRCADDRESS
mdefine_line|#define RSRCADDRESS(dev,num) ((dev)-&gt;resource[(num)].start)
multiline_comment|/* List of cards.  */
DECL|variable|nmcard_list
r_static
r_struct
id|nm256_info
op_star
id|nmcard_list
suffix:semicolon
multiline_comment|/* Release the mapped-in memory for CARD.  */
r_static
r_void
DECL|function|nm256_release_ports
id|nm256_release_ports
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|2
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
op_ne
l_int|NULL
)paren
(brace
id|iounmap
(paren
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
)paren
suffix:semicolon
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n; * Map in the memory ports for CARD, if they aren&squot;t already mapped in&n; * and have been configured.  If successful, a zero value is returned;&n; * otherwise any previously mapped-in areas are released and a non-zero&n; * value is returned.&n; *&n; * This is invoked twice, once for each port.  Ideally it would only be&n; * called once, but we now need to map in the second port in order to&n; * check how much memory the card has on the 256ZX.&n; */
r_static
r_int
DECL|function|nm256_remap_ports
id|nm256_remap_ports
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|2
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
op_eq
l_int|NULL
op_logical_and
id|card-&gt;port
(braket
id|x
)braket
dot
id|end_offset
OG
l_int|0
)paren
(brace
id|u32
id|physaddr
op_assign
id|card-&gt;port
(braket
id|x
)braket
dot
id|physaddr
op_plus
id|card-&gt;port
(braket
id|x
)braket
dot
id|start_offset
suffix:semicolon
id|u32
id|size
op_assign
id|card-&gt;port
(braket
id|x
)braket
dot
id|end_offset
op_minus
id|card-&gt;port
(braket
id|x
)braket
dot
id|start_offset
suffix:semicolon
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
op_assign
id|ioremap_nocache
(paren
id|physaddr
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Unable to remap port %d&bslash;n&quot;
comma
id|x
op_plus
l_int|1
)paren
suffix:semicolon
id|nm256_release_ports
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Locate the card in our list. */
r_static
r_struct
id|nm256_info
op_star
DECL|function|nm256_find_card
id|nm256_find_card
(paren
r_int
id|dev
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|nmcard_list
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next_card
)paren
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|0
)braket
op_eq
id|dev
op_logical_or
id|card-&gt;dev
(braket
l_int|1
)braket
op_eq
id|dev
)paren
r_return
id|card
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Ditto, but find the card struct corresponding to the mixer device DEV &n; * instead. &n; */
r_static
r_struct
id|nm256_info
op_star
DECL|function|nm256_find_card_for_mixer
id|nm256_find_card_for_mixer
(paren
r_int
id|dev
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|nmcard_list
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next_card
)paren
r_if
c_cond
(paren
id|card-&gt;mixer_oss_dev
op_eq
id|dev
)paren
r_return
id|card
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|usecache
r_static
r_int
id|usecache
op_assign
l_int|0
suffix:semicolon
DECL|variable|buffertop
r_static
r_int
id|buffertop
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check to see if we&squot;re using the bank of cached coefficients. */
r_int
DECL|function|nm256_cachedCoefficients
id|nm256_cachedCoefficients
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_return
id|usecache
suffix:semicolon
)brace
multiline_comment|/* The actual rates supported by the card. */
DECL|variable|samplerates
r_static
r_int
id|samplerates
(braket
l_int|9
)braket
op_assign
(brace
l_int|8000
comma
l_int|11025
comma
l_int|16000
comma
l_int|22050
comma
l_int|24000
comma
l_int|32000
comma
l_int|44100
comma
l_int|48000
comma
l_int|99999999
)brace
suffix:semicolon
multiline_comment|/*&n; * Set the card samplerate, word size and stereo mode to correspond to&n; * the settings in the CARD struct for the specified device in DEV.&n; * We keep two separate sets of information, one for each device; the&n; * hardware is not actually configured until a read or write is&n; * attempted.&n; */
r_int
DECL|function|nm256_setInfo
id|nm256_setInfo
(paren
r_int
id|dev
comma
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_int
id|x
suffix:semicolon
r_int
id|w
suffix:semicolon
r_int
id|targetrate
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|0
)braket
op_eq
id|dev
)paren
id|w
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|1
)braket
op_eq
id|dev
)paren
id|w
op_assign
l_int|1
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
id|targetrate
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
op_ne
l_int|8
op_logical_and
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
op_ne
l_int|16
)paren
op_logical_or
id|targetrate
template_param
id|samplerates
(braket
l_int|7
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
r_if
c_cond
(paren
id|targetrate
OL
(paren
(paren
id|samplerates
(braket
id|x
)braket
op_plus
id|samplerates
(braket
id|x
op_plus
l_int|1
)braket
)paren
op_div
l_int|2
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|x
OL
l_int|8
)paren
(brace
id|u8
id|ratebits
op_assign
(paren
(paren
id|x
op_lshift
l_int|4
)paren
op_amp
id|NM_RATE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
op_eq
l_int|16
)paren
id|ratebits
op_or_assign
id|NM_RATE_BITS_16
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
)paren
id|ratebits
op_or_assign
id|NM_RATE_STEREO
suffix:semicolon
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
op_assign
id|samplerates
(braket
id|x
)braket
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev_for_play
op_eq
id|dev
op_logical_and
id|card-&gt;playing
)paren
(brace
r_if
c_cond
(paren
id|nm256_debug
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Setting play ratebits to 0x%x&bslash;n&quot;
comma
id|ratebits
)paren
suffix:semicolon
id|nm256_loadCoefficient
(paren
id|card
comma
l_int|0
comma
id|x
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
id|NM_PLAYBACK_REG_OFFSET
op_plus
id|NM_RATE_REG_OFFSET
comma
id|ratebits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;dev_for_record
op_eq
id|dev
op_logical_and
id|card-&gt;recording
)paren
(brace
r_if
c_cond
(paren
id|nm256_debug
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Setting record ratebits to 0x%x&bslash;n&quot;
comma
id|ratebits
)paren
suffix:semicolon
id|nm256_loadCoefficient
(paren
id|card
comma
l_int|1
comma
id|x
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
id|NM_RECORD_REG_OFFSET
op_plus
id|NM_RATE_REG_OFFSET
comma
id|ratebits
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Start the play process going. */
r_static
r_void
DECL|function|startPlay
id|startPlay
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;playing
)paren
(brace
id|card-&gt;playing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nm256_grabInterrupt
(paren
id|card
)paren
op_eq
l_int|0
)paren
(brace
id|nm256_setInfo
(paren
id|card-&gt;dev_for_play
comma
id|card
)paren
suffix:semicolon
multiline_comment|/* Enable playback engine and interrupts. */
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
id|NM_PLAYBACK_ENABLE_REG
comma
id|NM_PLAYBACK_ENABLE_FLAG
op_or
id|NM_PLAYBACK_FREERUN
)paren
suffix:semicolon
multiline_comment|/* Enable both channels. */
id|nm256_writePort16
(paren
id|card
comma
l_int|2
comma
id|NM_AUDIO_MUTE_REG
comma
l_int|0x0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n; * Request one chunk of AMT bytes from the recording device.  When the&n; * operation is complete, the data will be copied into BUFFER and the&n; * function DMAbuf_inputintr will be invoked.&n; */
r_static
r_void
DECL|function|nm256_startRecording
id|nm256_startRecording
(paren
r_struct
id|nm256_info
op_star
id|card
comma
r_char
op_star
id|buffer
comma
id|u32
id|amt
)paren
(brace
id|u32
id|endpos
suffix:semicolon
r_int
id|enableEngine
op_assign
l_int|0
suffix:semicolon
id|u32
id|ringsize
op_assign
id|card-&gt;recordBufferSize
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|amt
OG
(paren
id|ringsize
op_div
l_int|2
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Of course this won&squot;t actually work right, because the&n;&t; * caller is going to assume we will give what we got asked&n;&t; * for.&n;&t; */
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Read request too large: %d&bslash;n&quot;
comma
id|amt
)paren
suffix:semicolon
id|amt
op_assign
id|ringsize
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|amt
OL
l_int|8
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Read request too small; %d&bslash;n&quot;
comma
id|amt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we&squot;re not currently recording, set up the start and end registers&n;     * for the recording engine.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;recording
)paren
(brace
id|card-&gt;recording
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nm256_grabInterrupt
(paren
id|card
)paren
op_eq
l_int|0
)paren
(brace
id|card-&gt;curRecPos
op_assign
l_int|0
suffix:semicolon
id|nm256_setInfo
(paren
id|card-&gt;dev_for_record
comma
id|card
)paren
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_RBUFFER_START
comma
id|card-&gt;abuf2
)paren
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_RBUFFER_END
comma
id|card-&gt;abuf2
op_plus
id|ringsize
)paren
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_RBUFFER_CURRP
comma
id|card-&gt;abuf2
op_plus
id|card-&gt;curRecPos
)paren
suffix:semicolon
id|enableEngine
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not sure what else to do here.  */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;     * If we happen to go past the end of the buffer a bit (due to a&n;     * delayed interrupt) it&squot;s OK.  So might as well set the watermark&n;     * right at the end of the data we want.&n;     */
id|endpos
op_assign
id|card-&gt;abuf2
op_plus
(paren
(paren
id|card-&gt;curRecPos
op_plus
id|amt
)paren
op_mod
id|ringsize
)paren
suffix:semicolon
id|card-&gt;recBuf
op_assign
id|buffer
suffix:semicolon
id|card-&gt;requestedRecAmt
op_assign
id|amt
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_RBUFFER_WMARK
comma
id|endpos
)paren
suffix:semicolon
multiline_comment|/* Enable recording engine and interrupts. */
r_if
c_cond
(paren
id|enableEngine
)paren
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
id|NM_RECORD_ENABLE_REG
comma
id|NM_RECORD_ENABLE_FLAG
op_or
id|NM_RECORD_FREERUN
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop the play engine. */
r_static
r_void
DECL|function|stopPlay
id|stopPlay
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
multiline_comment|/* Shut off sound from both channels. */
id|nm256_writePort16
(paren
id|card
comma
l_int|2
comma
id|NM_AUDIO_MUTE_REG
comma
id|NM_AUDIO_MUTE_LEFT
op_or
id|NM_AUDIO_MUTE_RIGHT
)paren
suffix:semicolon
multiline_comment|/* Disable play engine. */
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
id|NM_PLAYBACK_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;playing
)paren
(brace
id|nm256_releaseInterrupt
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* Reset the relevant state bits. */
id|card-&gt;playing
op_assign
l_int|0
suffix:semicolon
id|card-&gt;curPlayPos
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop recording. */
r_static
r_void
DECL|function|stopRecord
id|stopRecord
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
multiline_comment|/* Disable recording engine. */
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
id|NM_RECORD_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;recording
)paren
(brace
id|nm256_releaseInterrupt
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;recording
op_assign
l_int|0
suffix:semicolon
id|card-&gt;curRecPos
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Ring buffers, man.  That&squot;s where the hip-hop, wild-n-wooly action&squot;s at.&n; * 1972?  (Well, I suppose it was cheep-n-easy to implement.)&n; *&n; * Write AMT bytes of BUFFER to the playback ring buffer, and start the&n; * playback engine running.  It will only accept up to 1/2 of the total&n; * size of the ring buffer.  No check is made that we&squot;re about to overwrite&n; * the currently-playing sample.&n; */
r_static
r_void
DECL|function|nm256_write_block
id|nm256_write_block
(paren
r_struct
id|nm256_info
op_star
id|card
comma
r_char
op_star
id|buffer
comma
id|u32
id|amt
)paren
(brace
id|u32
id|ringsize
op_assign
id|card-&gt;playbackBufferSize
suffix:semicolon
id|u32
id|endstop
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|amt
OG
(paren
id|ringsize
op_div
l_int|2
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Write request too large: %d&bslash;n&quot;
comma
id|amt
)paren
suffix:semicolon
id|amt
op_assign
(paren
id|ringsize
op_div
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|amt
OL
id|NM256_PLAY_WMARK_SIZE
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Write request too small: %d&bslash;n&quot;
comma
id|amt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|card-&gt;curPlayPos
op_mod_assign
id|ringsize
suffix:semicolon
id|card-&gt;requested_amt
op_assign
id|amt
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card-&gt;curPlayPos
op_plus
id|amt
)paren
op_ge
id|ringsize
)paren
(brace
id|u32
id|rem
op_assign
id|ringsize
op_minus
id|card-&gt;curPlayPos
suffix:semicolon
id|nm256_writeBuffer8
(paren
id|card
comma
id|buffer
comma
l_int|1
comma
id|card-&gt;abuf1
op_plus
id|card-&gt;curPlayPos
comma
id|rem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OG
id|rem
)paren
id|nm256_writeBuffer8
(paren
id|card
comma
id|buffer
op_plus
id|rem
comma
l_int|1
comma
id|card-&gt;abuf1
comma
id|amt
op_minus
id|rem
)paren
suffix:semicolon
)brace
r_else
id|nm256_writeBuffer8
(paren
id|card
comma
id|buffer
comma
l_int|1
comma
id|card-&gt;abuf1
op_plus
id|card-&gt;curPlayPos
comma
id|amt
)paren
suffix:semicolon
multiline_comment|/*&n;     * Setup the start-n-stop-n-limit registers, and start that engine&n;     * goin&squot;. &n;     *&n;     * Normally we just let it wrap around to avoid the click-click&n;     * action scene.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;playing
)paren
(brace
multiline_comment|/* The PBUFFER_END register in this case points to one sample&n;&t;   before the end of the buffer. */
r_int
id|w
op_assign
(paren
id|card-&gt;dev_for_play
op_eq
id|card-&gt;dev
(braket
l_int|0
)braket
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
r_int
id|sampsize
op_assign
(paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
op_eq
l_int|16
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
)paren
id|sampsize
op_mul_assign
l_int|2
suffix:semicolon
multiline_comment|/* Need to set the not-normally-changing-registers up. */
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_PBUFFER_START
comma
id|card-&gt;abuf1
op_plus
id|card-&gt;curPlayPos
)paren
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_PBUFFER_END
comma
id|card-&gt;abuf1
op_plus
id|ringsize
op_minus
id|sampsize
)paren
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_PBUFFER_CURRP
comma
id|card-&gt;abuf1
op_plus
id|card-&gt;curPlayPos
)paren
suffix:semicolon
)brace
id|endstop
op_assign
(paren
id|card-&gt;curPlayPos
op_plus
id|amt
op_minus
id|NM256_PLAY_WMARK_SIZE
)paren
op_mod
id|ringsize
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_PBUFFER_WMARK
comma
id|card-&gt;abuf1
op_plus
id|endstop
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;playing
)paren
id|startPlay
(paren
id|card
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*  We just got a card playback interrupt; process it.  */
r_static
r_void
DECL|function|nm256_get_new_block
id|nm256_get_new_block
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
multiline_comment|/* Check to see how much got played so far. */
id|u32
id|amt
op_assign
id|nm256_readPort32
(paren
id|card
comma
l_int|2
comma
id|NM_PBUFFER_CURRP
)paren
op_minus
id|card-&gt;abuf1
suffix:semicolon
r_if
c_cond
(paren
id|amt
op_ge
id|card-&gt;playbackBufferSize
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Sound playback pointer invalid!&bslash;n&quot;
)paren
suffix:semicolon
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|amt
OL
id|card-&gt;curPlayPos
)paren
id|amt
op_assign
(paren
id|card-&gt;playbackBufferSize
op_minus
id|card-&gt;curPlayPos
)paren
op_plus
id|amt
suffix:semicolon
r_else
id|amt
op_sub_assign
id|card-&gt;curPlayPos
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;requested_amt
OG
(paren
id|amt
op_plus
id|NM256_PLAY_WMARK_SIZE
)paren
)paren
(brace
id|u32
id|endstop
op_assign
id|card-&gt;curPlayPos
op_plus
id|card-&gt;requested_amt
op_minus
id|NM256_PLAY_WMARK_SIZE
suffix:semicolon
id|nm256_writePort32
(paren
id|card
comma
l_int|2
comma
id|NM_PBUFFER_WMARK
comma
id|card-&gt;abuf1
op_plus
id|endstop
)paren
suffix:semicolon
)brace
r_else
(brace
id|card-&gt;curPlayPos
op_add_assign
id|card-&gt;requested_amt
suffix:semicolon
multiline_comment|/* Get a new block to write.  This will eventually invoke&n;&t;   nm256_write_block () or stopPlay ().  */
id|DMAbuf_outputintr
(paren
id|card-&gt;dev_for_play
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Ultra cheez-whiz.  But I&squot;m too lazy to grep headers. */
DECL|macro|MIN
mdefine_line|#define MIN(X,Y) ((X) &lt; (Y) ? (X) : (Y))
multiline_comment|/* &n; * Read the last-recorded block from the ring buffer, copy it into the&n; * saved buffer pointer, and invoke DMAuf_inputintr() with the recording&n; * device. &n; */
r_static
r_void
DECL|function|nm256_read_block
id|nm256_read_block
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
multiline_comment|/* Grab the current position of the recording pointer. */
id|u32
id|currptr
op_assign
id|nm256_readPort32
(paren
id|card
comma
l_int|2
comma
id|NM_RBUFFER_CURRP
)paren
op_minus
id|card-&gt;abuf2
suffix:semicolon
id|u32
id|amtToRead
op_assign
id|card-&gt;requestedRecAmt
suffix:semicolon
id|u32
id|ringsize
op_assign
id|card-&gt;recordBufferSize
suffix:semicolon
r_if
c_cond
(paren
id|currptr
op_ge
id|card-&gt;recordBufferSize
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Sound buffer record pointer invalid!&bslash;n&quot;
)paren
suffix:semicolon
id|currptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * This test is probably redundant; we shouldn&squot;t be here unless&n;     * it&squot;s true.&n;     */
r_if
c_cond
(paren
id|card-&gt;recording
)paren
(brace
multiline_comment|/* If we wrapped around, copy everything from the start of our&n;&t;   recording buffer to the end of the buffer. */
r_if
c_cond
(paren
id|currptr
OL
id|card-&gt;curRecPos
)paren
(brace
id|u32
id|amt
op_assign
id|MIN
(paren
id|ringsize
op_minus
id|card-&gt;curRecPos
comma
id|amtToRead
)paren
suffix:semicolon
id|nm256_readBuffer8
(paren
id|card
comma
id|card-&gt;recBuf
comma
l_int|1
comma
id|card-&gt;abuf2
op_plus
id|card-&gt;curRecPos
comma
id|amt
)paren
suffix:semicolon
id|amtToRead
op_sub_assign
id|amt
suffix:semicolon
id|card-&gt;curRecPos
op_add_assign
id|amt
suffix:semicolon
id|card-&gt;recBuf
op_add_assign
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;curRecPos
op_eq
id|ringsize
)paren
id|card-&gt;curRecPos
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card-&gt;curRecPos
OL
id|currptr
)paren
op_logical_and
(paren
id|amtToRead
OG
l_int|0
)paren
)paren
(brace
id|u32
id|amt
op_assign
id|MIN
(paren
id|currptr
op_minus
id|card-&gt;curRecPos
comma
id|amtToRead
)paren
suffix:semicolon
id|nm256_readBuffer8
(paren
id|card
comma
id|card-&gt;recBuf
comma
l_int|1
comma
id|card-&gt;abuf2
op_plus
id|card-&gt;curRecPos
comma
id|amt
)paren
suffix:semicolon
id|card-&gt;curRecPos
op_assign
(paren
(paren
id|card-&gt;curRecPos
op_plus
id|amt
)paren
op_mod
id|ringsize
)paren
suffix:semicolon
)brace
id|card-&gt;recBuf
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;requestedRecAmt
op_assign
l_int|0
suffix:semicolon
id|DMAbuf_inputintr
(paren
id|card-&gt;dev_for_record
)paren
suffix:semicolon
)brace
)brace
DECL|macro|MIN
macro_line|#undef MIN
multiline_comment|/* &n; * Initialize the hardware. &n; */
r_static
r_void
DECL|function|nm256_initHw
id|nm256_initHw
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
multiline_comment|/* Reset everything. */
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x0
comma
l_int|0x11
)paren
suffix:semicolon
id|nm256_writePort16
(paren
id|card
comma
l_int|2
comma
l_int|0x214
comma
l_int|0
)paren
suffix:semicolon
id|stopRecord
(paren
id|card
)paren
suffix:semicolon
id|stopPlay
(paren
id|card
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Handle a potential interrupt for the device referred to by DEV_ID. &n; *&n; * I don&squot;t like the cut-n-paste job here either between the two routines,&n; * but there are sufficient differences between the two interrupt handlers&n; * that parameterizing it isn&squot;t all that great either.  (Could use a macro,&n; * I suppose...yucky bleah.)&n; */
r_static
r_void
DECL|function|nm256_interrupt
id|nm256_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|dummy
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev_id
suffix:semicolon
id|u16
id|status
suffix:semicolon
r_static
r_int
id|badintrcount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|card-&gt;magsig
op_ne
id|NM_MAGIC_SIG
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Bad card pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|status
op_assign
id|nm256_readPort16
(paren
id|card
comma
l_int|2
comma
id|NM_INT_REG
)paren
suffix:semicolon
multiline_comment|/* Not ours. */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|badintrcount
op_increment
OG
l_int|1000
)paren
(brace
multiline_comment|/*&n;&t;     * I&squot;m not sure if the best thing is to stop the card from&n;&t;     * playing or just release the interrupt (after all, we&squot;re in&n;&t;     * a bad situation, so doing fancy stuff may not be such a good&n;&t;     * idea).&n;&t;     *&n;&t;     * I worry about the card engine continuing to play noise&n;&t;     * over and over, however--that could become a very&n;&t;     * obnoxious problem.  And we know that when this usually&n;&t;     * happens things are fairly safe, it just means the user&squot;s&n;&t;     * inserted a PCMCIA card and someone&squot;s spamming us with IRQ 9s.&n;&t;     */
r_if
c_cond
(paren
id|card-&gt;playing
)paren
id|stopPlay
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;recording
)paren
id|stopRecord
(paren
id|card
)paren
suffix:semicolon
id|badintrcount
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|badintrcount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Rather boring; check for individual interrupts and process them. */
r_if
c_cond
(paren
id|status
op_amp
id|NM_PLAYBACK_INT
)paren
(brace
id|status
op_and_assign
op_complement
id|NM_PLAYBACK_INT
suffix:semicolon
id|NM_ACK_INT
(paren
id|card
comma
id|NM_PLAYBACK_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;playing
)paren
id|nm256_get_new_block
(paren
id|card
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|NM_RECORD_INT
)paren
(brace
id|status
op_and_assign
op_complement
id|NM_RECORD_INT
suffix:semicolon
id|NM_ACK_INT
(paren
id|card
comma
id|NM_RECORD_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;recording
)paren
id|nm256_read_block
(paren
id|card
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|NM_MISC_INT_1
)paren
(brace
id|u8
id|cbyte
suffix:semicolon
id|status
op_and_assign
op_complement
id|NM_MISC_INT_1
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Got misc interrupt #1&bslash;n&quot;
)paren
suffix:semicolon
id|NM_ACK_INT
(paren
id|card
comma
id|NM_MISC_INT_1
)paren
suffix:semicolon
id|nm256_writePort16
(paren
id|card
comma
l_int|2
comma
id|NM_INT_REG
comma
l_int|0x8000
)paren
suffix:semicolon
id|cbyte
op_assign
id|nm256_readPort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
comma
id|cbyte
op_or
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|NM_MISC_INT_2
)paren
(brace
id|u8
id|cbyte
suffix:semicolon
id|status
op_and_assign
op_complement
id|NM_MISC_INT_2
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Got misc interrupt #2&bslash;n&quot;
)paren
suffix:semicolon
id|NM_ACK_INT
(paren
id|card
comma
id|NM_MISC_INT_2
)paren
suffix:semicolon
id|cbyte
op_assign
id|nm256_readPort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
comma
id|cbyte
op_amp
op_complement
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Unknown interrupt. */
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Fire in the hole! Unknown status 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* Pray. */
id|NM_ACK_INT
(paren
id|card
comma
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handle a potential interrupt for the device referred to by DEV_ID.&n; * This handler is for the 256ZX, and is very similar to the non-ZX&n; * routine.&n; */
r_static
r_void
DECL|function|nm256_interrupt_zx
id|nm256_interrupt_zx
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|dummy
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|status
suffix:semicolon
r_static
r_int
id|badintrcount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|card-&gt;magsig
op_ne
id|NM_MAGIC_SIG
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Bad card pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|status
op_assign
id|nm256_readPort32
(paren
id|card
comma
l_int|2
comma
id|NM_INT_REG
)paren
suffix:semicolon
multiline_comment|/* Not ours. */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|badintrcount
op_increment
OG
l_int|1000
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Releasing interrupt, over 1000 invalid interrupts&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * I&squot;m not sure if the best thing is to stop the card from&n;&t;     * playing or just release the interrupt (after all, we&squot;re in&n;&t;     * a bad situation, so doing fancy stuff may not be such a good&n;&t;     * idea).&n;&t;     *&n;&t;     * I worry about the card engine continuing to play noise&n;&t;     * over and over, however--that could become a very&n;&t;     * obnoxious problem.  And we know that when this usually&n;&t;     * happens things are fairly safe, it just means the user&squot;s&n;&t;     * inserted a PCMCIA card and someone&squot;s spamming us with &n;&t;     * IRQ 9s.&n;&t;     */
r_if
c_cond
(paren
id|card-&gt;playing
)paren
id|stopPlay
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;recording
)paren
id|stopRecord
(paren
id|card
)paren
suffix:semicolon
id|badintrcount
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|badintrcount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Rather boring; check for individual interrupts and process them. */
r_if
c_cond
(paren
id|status
op_amp
id|NM2_PLAYBACK_INT
)paren
(brace
id|status
op_and_assign
op_complement
id|NM2_PLAYBACK_INT
suffix:semicolon
id|NM2_ACK_INT
(paren
id|card
comma
id|NM2_PLAYBACK_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;playing
)paren
id|nm256_get_new_block
(paren
id|card
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|NM2_RECORD_INT
)paren
(brace
id|status
op_and_assign
op_complement
id|NM2_RECORD_INT
suffix:semicolon
id|NM2_ACK_INT
(paren
id|card
comma
id|NM2_RECORD_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;recording
)paren
id|nm256_read_block
(paren
id|card
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|NM2_MISC_INT_1
)paren
(brace
id|u8
id|cbyte
suffix:semicolon
id|status
op_and_assign
op_complement
id|NM2_MISC_INT_1
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Got misc interrupt #1&bslash;n&quot;
)paren
suffix:semicolon
id|NM2_ACK_INT
(paren
id|card
comma
id|NM2_MISC_INT_1
)paren
suffix:semicolon
id|cbyte
op_assign
id|nm256_readPort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
comma
id|cbyte
op_or
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|NM2_MISC_INT_2
)paren
(brace
id|u8
id|cbyte
suffix:semicolon
id|status
op_and_assign
op_complement
id|NM2_MISC_INT_2
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Got misc interrupt #2&bslash;n&quot;
)paren
suffix:semicolon
id|NM2_ACK_INT
(paren
id|card
comma
id|NM2_MISC_INT_2
)paren
suffix:semicolon
id|cbyte
op_assign
id|nm256_readPort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x400
comma
id|cbyte
op_amp
op_complement
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Unknown interrupt. */
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Fire in the hole! Unknown status 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* Pray. */
id|NM2_ACK_INT
(paren
id|card
comma
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Request our interrupt.&n; */
r_static
r_int
DECL|function|nm256_grabInterrupt
id|nm256_grabInterrupt
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;has_irq
op_increment
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_irq
(paren
id|card-&gt;irq
comma
id|card-&gt;introutine
comma
id|SA_SHIRQ
comma
l_string|&quot;NM256_audio&quot;
comma
id|card
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: can&squot;t obtain IRQ %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Release our interrupt. &n; */
r_static
r_int
DECL|function|nm256_releaseInterrupt
id|nm256_releaseInterrupt
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;has_irq
op_le
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;nm256: too many calls to releaseInterrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|card-&gt;has_irq
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;has_irq
op_eq
l_int|0
)paren
(brace
id|free_irq
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Waits for the mixer to become ready to be written; returns a zero value&n; * if it timed out.&n; */
r_static
r_int
DECL|function|nm256_isReady
id|nm256_isReady
(paren
r_struct
id|ac97_hwint
op_star
id|dev
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev-&gt;driver_private
suffix:semicolon
r_int
id|t2
op_assign
l_int|10
suffix:semicolon
id|u32
id|testaddr
suffix:semicolon
id|u16
id|testb
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;magsig
op_ne
id|NM_MAGIC_SIG
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Bad magic signature in isReady!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|testaddr
op_assign
id|card-&gt;mixer_status_offset
suffix:semicolon
id|testb
op_assign
id|card-&gt;mixer_status_mask
suffix:semicolon
multiline_comment|/* &n;     * Loop around waiting for the mixer to become ready. &n;     */
r_while
c_loop
(paren
op_logical_neg
id|done
op_logical_and
id|t2
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|nm256_readPort16
(paren
id|card
comma
l_int|2
comma
id|testaddr
)paren
op_amp
id|testb
)paren
op_eq
l_int|0
)paren
id|done
op_assign
l_int|1
suffix:semicolon
r_else
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the contents of the AC97 mixer register REG.  Returns a positive&n; * value if successful, or a negative error code.&n; */
r_static
r_int
DECL|function|nm256_readAC97Reg
id|nm256_readAC97Reg
(paren
r_struct
id|ac97_hwint
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev-&gt;driver_private
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;magsig
op_ne
id|NM_MAGIC_SIG
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Bad magic signature in readAC97Reg!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg
OL
l_int|128
)paren
(brace
r_int
id|res
suffix:semicolon
id|nm256_isReady
(paren
id|dev
)paren
suffix:semicolon
id|res
op_assign
id|nm256_readPort16
(paren
id|card
comma
l_int|2
comma
id|card-&gt;mixer
op_plus
id|reg
)paren
suffix:semicolon
multiline_comment|/* Magic delay.  Bleah yucky.  */
id|udelay
(paren
l_int|1000
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* &n; * Writes VALUE to AC97 mixer register REG.  Returns 0 if successful, or&n; * a negative error code. &n; */
r_static
r_int
DECL|function|nm256_writeAC97Reg
id|nm256_writeAC97Reg
(paren
r_struct
id|ac97_hwint
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|value
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|tries
op_assign
l_int|2
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|u32
id|base
suffix:semicolon
r_struct
id|nm256_info
op_star
id|card
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev-&gt;driver_private
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;magsig
op_ne
id|NM_MAGIC_SIG
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Bad magic signature in writeAC97Reg!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_assign
id|card-&gt;mixer
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|nm256_isReady
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Wait for the write to take, too. */
r_while
c_loop
(paren
(paren
id|tries
op_decrement
OG
l_int|0
)paren
op_logical_and
op_logical_neg
id|done
)paren
(brace
id|nm256_writePort16
(paren
id|card
comma
l_int|2
comma
id|base
op_plus
id|reg
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nm256_isReady
(paren
id|dev
)paren
)paren
(brace
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|udelay
(paren
l_int|1000
)paren
suffix:semicolon
r_return
op_logical_neg
id|done
suffix:semicolon
)brace
multiline_comment|/* &n; * Initial register values to be written to the AC97 mixer.&n; * While most of these are identical to the reset values, we do this&n; * so that we have most of the register contents cached--this avoids&n; * reading from the mixer directly (which seems to be problematic,&n; * probably due to ignorance).&n; */
DECL|struct|initialValues
r_struct
id|initialValues
(brace
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
DECL|member|value
r_int
r_int
id|value
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|nm256_ac97_initial_values
r_static
r_struct
id|initialValues
id|nm256_ac97_initial_values
(braket
)braket
op_assign
(brace
(brace
id|AC97_MASTER_VOL_STEREO
comma
l_int|0x8000
)brace
comma
(brace
id|AC97_HEADPHONE_VOL
comma
l_int|0x8000
)brace
comma
(brace
id|AC97_MASTER_VOL_MONO
comma
l_int|0x0000
)brace
comma
(brace
id|AC97_PCBEEP_VOL
comma
l_int|0x0000
)brace
comma
(brace
id|AC97_PHONE_VOL
comma
l_int|0x0008
)brace
comma
(brace
id|AC97_MIC_VOL
comma
l_int|0x8000
)brace
comma
(brace
id|AC97_LINEIN_VOL
comma
l_int|0x8808
)brace
comma
(brace
id|AC97_CD_VOL
comma
l_int|0x8808
)brace
comma
(brace
id|AC97_VIDEO_VOL
comma
l_int|0x8808
)brace
comma
(brace
id|AC97_AUX_VOL
comma
l_int|0x8808
)brace
comma
(brace
id|AC97_PCMOUT_VOL
comma
l_int|0x0808
)brace
comma
(brace
id|AC97_RECORD_SELECT
comma
l_int|0x0000
)brace
comma
(brace
id|AC97_RECORD_GAIN
comma
l_int|0x0B0B
)brace
comma
(brace
id|AC97_GENERAL_PURPOSE
comma
l_int|0x0000
)brace
comma
(brace
l_int|0xffff
comma
l_int|0xffff
)brace
)brace
suffix:semicolon
multiline_comment|/* Initialize the AC97 into a known state.  */
r_static
r_int
DECL|function|nm256_resetAC97
id|nm256_resetAC97
(paren
r_struct
id|ac97_hwint
op_star
id|dev
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev-&gt;driver_private
suffix:semicolon
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;magsig
op_ne
id|NM_MAGIC_SIG
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Bad magic signature in resetAC97!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Reset the mixer.  &squot;Tis magic!  */
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x6c0
comma
l_int|1
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x6cc
comma
l_int|0x87
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x6cc
comma
l_int|0x80
)paren
suffix:semicolon
id|nm256_writePort8
(paren
id|card
comma
l_int|2
comma
l_int|0x6cc
comma
l_int|0x0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;mixer_values_init
)paren
(brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|nm256_ac97_initial_values
(braket
id|x
)braket
dot
id|port
op_ne
l_int|0xffff
suffix:semicolon
id|x
op_increment
)paren
(brace
id|ac97_put_register
(paren
id|dev
comma
id|nm256_ac97_initial_values
(braket
id|x
)braket
dot
id|port
comma
id|nm256_ac97_initial_values
(braket
id|x
)braket
dot
id|value
)paren
suffix:semicolon
id|card-&gt;mixer_values_init
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We don&squot;t do anything particularly special here; it just passes the&n; * mixer ioctl to the AC97 driver.&n; */
r_static
r_int
DECL|function|nm256_default_mixer_ioctl
id|nm256_default_mixer_ioctl
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card_for_mixer
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
r_return
id|ac97_mixer_ioctl
(paren
op_amp
(paren
id|card-&gt;mdev
)paren
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|nm256_mixer_operations
r_static
r_struct
id|mixer_operations
id|nm256_mixer_operations
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|id
suffix:colon
l_string|&quot;NeoMagic&quot;
comma
id|name
suffix:colon
l_string|&quot;NM256AC97Mixer&quot;
comma
id|ioctl
suffix:colon
id|nm256_default_mixer_ioctl
)brace
suffix:semicolon
multiline_comment|/*&n; * Default settings for the OSS mixer.  These are set last, after the&n; * mixer is initialized.&n; *&n; * I &quot;love&quot; C sometimes.  Got braces?&n; */
DECL|variable|mixer_defaults
r_static
r_struct
id|ac97_mixer_value_list
id|mixer_defaults
(braket
)braket
op_assign
(brace
(brace
id|SOUND_MIXER_VOLUME
comma
(brace
(brace
l_int|85
comma
l_int|85
)brace
)brace
)brace
comma
(brace
id|SOUND_MIXER_SPEAKER
comma
(brace
(brace
l_int|100
)brace
)brace
)brace
comma
(brace
id|SOUND_MIXER_PCM
comma
(brace
(brace
l_int|65
comma
l_int|65
)brace
)brace
)brace
comma
(brace
id|SOUND_MIXER_CD
comma
(brace
(brace
l_int|65
comma
l_int|65
)brace
)brace
)brace
comma
(brace
op_minus
l_int|1
comma
(brace
(brace
l_int|0
comma
l_int|0
)brace
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/* Installs the AC97 mixer into CARD.  */
r_static
r_int
id|__init
DECL|function|nm256_install_mixer
id|nm256_install_mixer
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
r_int
id|mixer
suffix:semicolon
id|card-&gt;mdev.reset_device
op_assign
id|nm256_resetAC97
suffix:semicolon
id|card-&gt;mdev.read_reg
op_assign
id|nm256_readAC97Reg
suffix:semicolon
id|card-&gt;mdev.write_reg
op_assign
id|nm256_writeAC97Reg
suffix:semicolon
id|card-&gt;mdev.driver_private
op_assign
(paren
r_void
op_star
)paren
id|card
suffix:semicolon
r_if
c_cond
(paren
id|ac97_init
(paren
op_amp
(paren
id|card-&gt;mdev
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|mixer
op_assign
id|sound_alloc_mixerdev
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_mixers
op_ge
id|MAX_MIXER_DEV
)paren
(brace
id|printk
(paren
l_string|&quot;NM256 mixer: Unable to alloc mixerdev&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|mixer_devs
(braket
id|mixer
)braket
op_assign
op_amp
id|nm256_mixer_operations
suffix:semicolon
id|card-&gt;mixer_oss_dev
op_assign
id|mixer
suffix:semicolon
multiline_comment|/* Some reasonable default values.  */
id|ac97_set_values
(paren
op_amp
(paren
id|card-&gt;mdev
)paren
comma
id|mixer_defaults
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Initialized AC97 mixer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Perform a full reset on the hardware; this is invoked when an APM&n;   resume event occurs.  */
r_static
r_void
DECL|function|nm256_full_reset
id|nm256_full_reset
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
id|nm256_initHw
(paren
id|card
)paren
suffix:semicolon
id|ac97_reset
(paren
op_amp
(paren
id|card-&gt;mdev
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * See if the signature left by the NM256 BIOS is intact; if so, we use&n; * the associated address as the end of our audio buffer in the video&n; * RAM.&n; */
r_static
r_void
id|__init
DECL|function|nm256_peek_for_sig
id|nm256_peek_for_sig
(paren
r_struct
id|nm256_info
op_star
id|card
)paren
(brace
id|u32
id|port1offset
op_assign
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|physaddr
op_plus
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_minus
l_int|0x0400
suffix:semicolon
multiline_comment|/* The signature is located 1K below the end of video RAM.  */
r_char
op_star
id|temp
op_assign
id|ioremap_nocache
(paren
id|port1offset
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Default buffer end is 5120 bytes below the top of RAM.  */
id|u32
id|default_value
op_assign
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_minus
l_int|0x1400
suffix:semicolon
id|u32
id|sig
suffix:semicolon
multiline_comment|/* Install the default value first, so we don&squot;t have to repeatedly&n;       do it if there is a problem.  */
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_assign
id|default_value
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: Unable to scan for card signature in video RAM&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sig
op_assign
id|readl
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sig
op_amp
id|NM_SIG_MASK
)paren
op_eq
id|NM_SIGNATURE
)paren
(brace
id|u32
id|pointer
op_assign
id|readl
(paren
id|temp
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s obviously invalid, don&squot;t use it (the port already has a&n;&t; * suitable default value set).&n;&t; */
r_if
c_cond
(paren
id|pointer
op_ne
l_int|0xffffffff
)paren
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_assign
id|pointer
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;NM256: Found card signature in video RAM: 0x%x&bslash;n&quot;
comma
id|pointer
)paren
suffix:semicolon
)brace
id|iounmap
(paren
id|temp
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Install a driver for the PCI device referenced by PCIDEV.&n; * VERSTR is a human-readable version string.&n; */
r_static
r_int
id|__init
DECL|function|nm256_install
id|nm256_install
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcidev
comma
r_enum
id|nm256rev
id|rev
comma
r_char
op_star
id|verstr
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
suffix:semicolon
r_struct
id|pm_dev
op_star
id|pmdev
suffix:semicolon
r_int
id|x
suffix:semicolon
id|card
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|nm256_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: out of memory!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|card-&gt;magsig
op_assign
id|NM_MAGIC_SIG
suffix:semicolon
id|card-&gt;playing
op_assign
l_int|0
suffix:semicolon
id|card-&gt;recording
op_assign
l_int|0
suffix:semicolon
id|card-&gt;rev
op_assign
id|rev
suffix:semicolon
multiline_comment|/* Init the memory port info.  */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|2
suffix:semicolon
id|x
op_increment
)paren
(brace
id|card-&gt;port
(braket
id|x
)braket
dot
id|physaddr
op_assign
id|RSRCADDRESS
(paren
id|pcidev
comma
id|x
)paren
suffix:semicolon
id|card-&gt;port
(braket
id|x
)braket
dot
id|ptr
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;port
(braket
id|x
)braket
dot
id|start_offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;port
(braket
id|x
)braket
dot
id|end_offset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Port 2 is easy.  */
id|card-&gt;port
(braket
l_int|1
)braket
dot
id|start_offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;port
(braket
l_int|1
)braket
dot
id|end_offset
op_assign
id|NM_PORT2_SIZE
suffix:semicolon
multiline_comment|/* Yuck.  But we have to map in port 2 so we can check how much RAM the&n;       card has.  */
r_if
c_cond
(paren
id|nm256_remap_ports
(paren
id|card
)paren
)paren
(brace
id|kfree
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;     * The NM256 has two memory ports.  The first port is nothing&n;     * more than a chunk of video RAM, which is used as the I/O ring&n;     * buffer.  The second port has the actual juicy stuff (like the&n;     * mixer and the playback engine control registers).&n;     */
r_if
c_cond
(paren
id|card-&gt;rev
op_eq
id|REV_NM256AV
)paren
(brace
multiline_comment|/* Ok, try to see if this is a non-AC97 version of the hardware. */
r_int
id|pval
op_assign
id|nm256_readPort16
(paren
id|card
comma
l_int|2
comma
id|NM_MIXER_PRESENCE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pval
op_amp
id|NM_PRESENCE_MASK
)paren
op_ne
id|NM_PRESENCE_VALUE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|force_load
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;NM256: This doesn&squot;t look to me like the AC97-compatible version.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;       You can force the driver to load by passing in the module&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;       parameter:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;              force_ac97 = 1&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;       More likely, you should be using the appropriate SB-16 or&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;       CS4232 driver instead.  (If your BIOS has settings for&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;       IRQ and/or DMA for the sound card, this is *not* the correct&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;       driver to use.)&bslash;n&quot;
)paren
suffix:semicolon
id|nm256_release_ports
(paren
id|card
)paren
suffix:semicolon
id|kfree
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;NM256: Forcing driver load as per user request.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*   printk (KERN_INFO &quot;NM256: Congratulations. You&squot;re not running Eunice.&bslash;n&quot;)*/
suffix:semicolon
)brace
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_assign
l_int|2560
op_star
l_int|1024
suffix:semicolon
id|card-&gt;introutine
op_assign
id|nm256_interrupt
suffix:semicolon
id|card-&gt;mixer_status_offset
op_assign
id|NM_MIXER_STATUS_OFFSET
suffix:semicolon
id|card-&gt;mixer_status_mask
op_assign
id|NM_MIXER_READY_MASK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not sure if there is any relevant detect for the ZX or not.  */
r_if
c_cond
(paren
id|nm256_readPort8
(paren
id|card
comma
l_int|2
comma
l_int|0xa0b
)paren
op_ne
l_int|0
)paren
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_assign
l_int|6144
op_star
l_int|1024
suffix:semicolon
r_else
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_assign
l_int|4096
op_star
l_int|1024
suffix:semicolon
id|card-&gt;introutine
op_assign
id|nm256_interrupt_zx
suffix:semicolon
id|card-&gt;mixer_status_offset
op_assign
id|NM2_MIXER_STATUS_OFFSET
suffix:semicolon
id|card-&gt;mixer_status_mask
op_assign
id|NM2_MIXER_READY_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffertop
op_ge
l_int|98304
op_logical_and
id|buffertop
OL
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
)paren
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_assign
id|buffertop
suffix:semicolon
r_else
id|nm256_peek_for_sig
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|start_offset
op_assign
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_minus
l_int|98304
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;NM256: Mapping port 1 from 0x%x - 0x%x&bslash;n&quot;
comma
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|start_offset
comma
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nm256_remap_ports
(paren
id|card
)paren
)paren
(brace
id|kfree
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See if we can get the interrupt. */
id|card-&gt;irq
op_assign
id|pcidev-&gt;irq
suffix:semicolon
id|card-&gt;has_irq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nm256_grabInterrupt
(paren
id|card
)paren
op_ne
l_int|0
)paren
(brace
id|nm256_release_ports
(paren
id|card
)paren
suffix:semicolon
id|kfree
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nm256_releaseInterrupt
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;Init the board.&n;     */
id|card-&gt;playbackBufferSize
op_assign
l_int|16384
suffix:semicolon
id|card-&gt;recordBufferSize
op_assign
l_int|16384
suffix:semicolon
id|card-&gt;coeffBuf
op_assign
id|card-&gt;port
(braket
l_int|0
)braket
dot
id|end_offset
op_minus
id|NM_MAX_COEFFICIENT
suffix:semicolon
id|card-&gt;abuf2
op_assign
id|card-&gt;coeffBuf
op_minus
id|card-&gt;recordBufferSize
suffix:semicolon
id|card-&gt;abuf1
op_assign
id|card-&gt;abuf2
op_minus
id|card-&gt;playbackBufferSize
suffix:semicolon
id|card-&gt;allCoeffBuf
op_assign
id|card-&gt;abuf2
op_minus
(paren
id|NM_TOTAL_COEFF_COUNT
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Fixed setting. */
id|card-&gt;mixer
op_assign
id|NM_MIXER_OFFSET
suffix:semicolon
id|card-&gt;mixer_values_init
op_assign
l_int|0
suffix:semicolon
id|card-&gt;is_open_play
op_assign
l_int|0
suffix:semicolon
id|card-&gt;is_open_record
op_assign
l_int|0
suffix:semicolon
id|card-&gt;coeffsCurrent
op_assign
l_int|0
suffix:semicolon
id|card-&gt;opencnt
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|card-&gt;opencnt
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reasonable default settings, but largely unnecessary. */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|2
suffix:semicolon
id|x
op_increment
)paren
(brace
id|card-&gt;sinfo
(braket
id|x
)braket
dot
id|bits
op_assign
l_int|8
suffix:semicolon
id|card-&gt;sinfo
(braket
id|x
)braket
dot
id|stereo
op_assign
l_int|0
suffix:semicolon
id|card-&gt;sinfo
(braket
id|x
)braket
dot
id|samplerate
op_assign
l_int|8000
suffix:semicolon
)brace
id|nm256_initHw
(paren
id|card
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|2
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|card-&gt;dev
(braket
id|x
)braket
op_assign
id|sound_install_audiodrv
c_func
(paren
id|AUDIO_DRIVER_VERSION
comma
l_string|&quot;NM256&quot;
comma
op_amp
id|nm256_audio_driver
comma
r_sizeof
(paren
r_struct
id|audio_driver
)paren
comma
id|DMA_NODMA
comma
id|AFMT_U8
op_or
id|AFMT_S16_LE
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* 1K minimum buffer size. */
id|audio_devs
(braket
id|card-&gt;dev
(braket
id|x
)braket
)braket
op_member_access_from_pointer
id|min_fragment
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Maximum of 8K buffer size. */
id|audio_devs
(braket
id|card-&gt;dev
(braket
id|x
)braket
)braket
op_member_access_from_pointer
id|max_fragment
op_assign
l_int|13
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NM256: Too many PCM devices available&bslash;n&quot;
)paren
suffix:semicolon
id|nm256_release_ports
(paren
id|card
)paren
suffix:semicolon
id|kfree
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert the card in the list.  */
id|card-&gt;next_card
op_assign
id|nmcard_list
suffix:semicolon
id|nmcard_list
op_assign
id|card
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Initialized NeoMagic %s audio in PCI native mode&bslash;n&quot;
comma
id|verstr
)paren
suffix:semicolon
multiline_comment|/* &n;     * And our mixer.  (We should allow support for other mixers, maybe.)&n;     */
id|nm256_install_mixer
(paren
id|card
)paren
suffix:semicolon
id|pmdev
op_assign
id|pm_register
c_func
(paren
id|PM_PCI_DEV
comma
id|PM_PCI_ID
c_func
(paren
id|pcidev
)paren
comma
id|handle_pm_event
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmdev
)paren
id|pmdev-&gt;data
op_assign
id|card
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * PM event handler, so the card is properly reinitialized after a power&n; * event.&n; */
r_static
r_int
DECL|function|handle_pm_event
id|handle_pm_event
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|nm256_info
op_star
id|crd
op_assign
(paren
r_struct
id|nm256_info
op_star
)paren
id|dev-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|crd
)paren
(brace
r_switch
c_cond
(paren
id|rqst
)paren
(brace
r_case
id|PM_SUSPEND
suffix:colon
r_break
suffix:semicolon
r_case
id|PM_RESUME
suffix:colon
(brace
r_int
id|playing
op_assign
id|crd-&gt;playing
suffix:semicolon
id|nm256_full_reset
(paren
id|crd
)paren
suffix:semicolon
multiline_comment|/*&n;                 * A little ugly, but that&squot;s ok; pretend the&n;                 * block we were playing is done. &n;                 */
r_if
c_cond
(paren
id|playing
)paren
id|DMAbuf_outputintr
(paren
id|crd-&gt;dev_for_play
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This loop walks the PCI configuration database and finds where&n; *&t;the sound cards are.&n; */
r_int
id|__init
DECL|function|init_nm256
id|init_nm256
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_NEOMAGIC
comma
id|PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|count
op_add_assign
id|nm256_install
c_func
(paren
id|pcidev
comma
id|REV_NM256AV
comma
l_string|&quot;256AV&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_NEOMAGIC
comma
id|PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|count
op_add_assign
id|nm256_install
c_func
(paren
id|pcidev
comma
id|REV_NM256ZX
comma
l_string|&quot;256ZX&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;Done installing NM256 audio driver.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the device&n; *&n; * DEV  - device&n; * MODE - mode to open device (logical OR of OPEN_READ and OPEN_WRITE)&n; *&n; * Called when opening the DMAbuf               (dmabuf.c:259)&n; */
r_static
r_int
DECL|function|nm256_audio_open
id|nm256_audio_open
c_func
(paren
r_int
id|dev
comma
r_int
id|mode
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_int
id|w
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|0
)braket
op_eq
id|dev
)paren
id|w
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|1
)braket
op_eq
id|dev
)paren
id|w
op_assign
l_int|1
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;opencnt
(braket
id|w
)braket
OG
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* No bits set? Huh? */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|mode
op_amp
id|OPEN_READ
)paren
op_logical_or
(paren
id|mode
op_amp
id|OPEN_WRITE
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;     * If it&squot;s open for both read and write, and the card&squot;s currently&n;     * being read or written to, then do the opposite of what has&n;     * already been done.  Otherwise, don&squot;t specify any mode until the&n;     * user actually tries to do I/O.  (Some programs open the device&n;     * for both read and write, but only actually do reading or writing.)&n;     */
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|OPEN_WRITE
)paren
op_logical_and
(paren
id|mode
op_amp
id|OPEN_READ
)paren
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;is_open_play
)paren
id|mode
op_assign
id|OPEN_WRITE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|card-&gt;is_open_record
)paren
id|mode
op_assign
id|OPEN_READ
suffix:semicolon
r_else
id|mode
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|OPEN_WRITE
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;is_open_play
op_eq
l_int|0
)paren
(brace
id|card-&gt;dev_for_play
op_assign
id|dev
suffix:semicolon
id|card-&gt;is_open_play
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|OPEN_READ
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;is_open_record
op_eq
l_int|0
)paren
(brace
id|card-&gt;dev_for_record
op_assign
id|dev
suffix:semicolon
id|card-&gt;is_open_record
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|card-&gt;opencnt
(braket
id|w
)braket
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the device&n; *&n; * DEV  - device&n; *&n; * Called when closing the DMAbuf               (dmabuf.c:477)&n; *      after halt_xfer&n; */
r_static
r_void
DECL|function|nm256_audio_close
id|nm256_audio_close
c_func
(paren
r_int
id|dev
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
r_int
id|w
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|0
)braket
op_eq
id|dev
)paren
id|w
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|card-&gt;dev
(braket
l_int|1
)braket
op_eq
id|dev
)paren
id|w
op_assign
l_int|1
suffix:semicolon
r_else
r_return
suffix:semicolon
id|card-&gt;opencnt
(braket
id|w
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;opencnt
(braket
id|w
)braket
op_le
l_int|0
)paren
(brace
id|card-&gt;opencnt
(braket
id|w
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev_for_play
op_eq
id|dev
)paren
(brace
id|stopPlay
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;is_open_play
op_assign
l_int|0
suffix:semicolon
id|card-&gt;dev_for_play
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;dev_for_record
op_eq
id|dev
)paren
(brace
id|stopRecord
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;is_open_record
op_assign
l_int|0
suffix:semicolon
id|card-&gt;dev_for_record
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Standard ioctl handler. */
r_static
r_int
DECL|function|nm256_audio_ioctl
id|nm256_audio_ioctl
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|cmd
comma
id|caddr_t
id|arg
)paren
(brace
r_int
id|ret
suffix:semicolon
id|u32
id|oldinfo
suffix:semicolon
r_int
id|w
suffix:semicolon
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|card-&gt;dev
(braket
l_int|0
)braket
)paren
id|w
op_assign
l_int|0
suffix:semicolon
r_else
id|w
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;     * The code here is messy.  There are probably better ways to do&n;     * it.  (It should be possible to handle it the same way the AC97 mixer &n;     * is done.)&n;     */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_PCM_WRITE_RATE
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ret
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|oldinfo
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
suffix:semicolon
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
op_assign
id|ret
suffix:semicolon
id|ret
op_assign
id|nm256_setInfo
c_func
(paren
id|dev
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
op_assign
id|oldinfo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|samplerate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ret
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
op_assign
id|ret
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ret
op_assign
id|nm256_setInfo
(paren
id|dev
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ret
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ret
template_param
l_int|3
)paren
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
op_plus
l_int|1
suffix:semicolon
r_else
(brace
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
op_assign
id|ret
op_minus
l_int|1
suffix:semicolon
id|ret
op_assign
id|nm256_setInfo
(paren
id|dev
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
op_plus
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|stereo
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ret
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|oldinfo
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
suffix:semicolon
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
op_assign
id|ret
suffix:semicolon
id|ret
op_assign
id|nm256_setInfo
(paren
id|dev
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
op_assign
id|oldinfo
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
id|ret
op_assign
id|card-&gt;sinfo
(braket
id|w
)braket
dot
id|bits
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|ret
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the sound device DEV and an associated physical buffer PHYSBUF, &n; * return a pointer to the actual buffer in kernel space. &n; *&n; * This routine should exist as part of the soundcore routines.&n; */
r_static
r_char
op_star
DECL|function|nm256_getDMAbuffer
id|nm256_getDMAbuffer
(paren
r_int
id|dev
comma
r_int
r_int
id|physbuf
)paren
(brace
r_struct
id|audio_operations
op_star
id|adev
op_assign
id|audio_devs
(braket
id|dev
)braket
suffix:semicolon
r_struct
id|dma_buffparms
op_star
id|dmap
op_assign
id|adev-&gt;dmap_out
suffix:semicolon
r_char
op_star
id|dma_start
op_assign
(paren
r_char
op_star
)paren
(paren
id|physbuf
op_minus
(paren
r_int
r_int
)paren
id|dmap-&gt;raw_buf_phys
op_plus
(paren
r_int
r_int
)paren
id|dmap-&gt;raw_buf
)paren
suffix:semicolon
r_return
id|dma_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Output a block to sound device&n; *&n; * dev          - device number&n; * buf          - physical address of buffer&n; * total_count  - total byte count in buffer&n; * intrflag     - set if this has been called from an interrupt &n; *&t;&t;&t;&t;  (via DMAbuf_outputintr)&n; * restart_dma  - set if engine needs to be re-initialised&n; *&n; * Called when:&n; *  1. Starting output                                  (dmabuf.c:1327)&n; *  2.                                                  (dmabuf.c:1504)&n; *  3. A new buffer needs to be sent to the device      (dmabuf.c:1579)&n; */
r_static
r_void
DECL|function|nm256_audio_output_block
id|nm256_audio_output_block
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|physbuf
comma
r_int
id|total_count
comma
r_int
id|intrflag
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|dma_buf
op_assign
id|nm256_getDMAbuffer
(paren
id|dev
comma
id|physbuf
)paren
suffix:semicolon
id|card-&gt;is_open_play
op_assign
l_int|1
suffix:semicolon
id|card-&gt;dev_for_play
op_assign
id|dev
suffix:semicolon
id|nm256_write_block
(paren
id|card
comma
id|dma_buf
comma
id|total_count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Ditto, but do recording instead.  */
r_static
r_void
DECL|function|nm256_audio_start_input
id|nm256_audio_start_input
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|physbuf
comma
r_int
id|count
comma
r_int
id|intrflag
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|dma_buf
op_assign
id|nm256_getDMAbuffer
(paren
id|dev
comma
id|physbuf
)paren
suffix:semicolon
id|card-&gt;is_open_record
op_assign
l_int|1
suffix:semicolon
id|card-&gt;dev_for_record
op_assign
id|dev
suffix:semicolon
id|nm256_startRecording
(paren
id|card
comma
id|dma_buf
comma
id|count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Prepare for inputting samples to DEV. &n; * Each requested buffer will be BSIZE byes long, with a total of&n; * BCOUNT buffers. &n; */
r_static
r_int
DECL|function|nm256_audio_prepare_for_input
id|nm256_audio_prepare_for_input
c_func
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;is_open_record
op_logical_and
id|card-&gt;dev_for_record
op_ne
id|dev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_in-&gt;flags
op_or_assign
id|DMA_NODMA
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare for outputting samples to `dev&squot;&n; *&n; * Each buffer that will be passed will be `bsize&squot; bytes long,&n; * with a total of `bcount&squot; buffers.&n; *&n; * Called when:&n; *  1. A trigger enables audio output                   (dmabuf.c:978)&n; *  2. We get a write buffer without dma_mode setup     (dmabuf.c:1152)&n; *  3. We restart a transfer                            (dmabuf.c:1324)&n; */
r_static
r_int
DECL|function|nm256_audio_prepare_for_output
id|nm256_audio_prepare_for_output
c_func
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;is_open_play
op_logical_and
id|card-&gt;dev_for_play
op_ne
id|dev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;flags
op_or_assign
id|DMA_NODMA
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Stop the current operations associated with DEV.  */
r_static
r_void
DECL|function|nm256_audio_reset
id|nm256_audio_reset
c_func
(paren
r_int
id|dev
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
op_assign
id|nm256_find_card
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;dev_for_play
op_eq
id|dev
)paren
id|stopPlay
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;dev_for_record
op_eq
id|dev
)paren
id|stopRecord
(paren
id|card
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|nm256_audio_local_qlen
id|nm256_audio_local_qlen
c_func
(paren
r_int
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nm256_audio_driver
r_static
r_struct
id|audio_driver
id|nm256_audio_driver
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|nm256_audio_open
comma
id|close
suffix:colon
id|nm256_audio_close
comma
id|output_block
suffix:colon
id|nm256_audio_output_block
comma
id|start_input
suffix:colon
id|nm256_audio_start_input
comma
id|ioctl
suffix:colon
id|nm256_audio_ioctl
comma
id|prepare_for_input
suffix:colon
id|nm256_audio_prepare_for_input
comma
id|prepare_for_output
suffix:colon
id|nm256_audio_prepare_for_output
comma
id|halt_io
suffix:colon
id|nm256_audio_reset
comma
id|local_qlen
suffix:colon
id|nm256_audio_local_qlen
comma
)brace
suffix:semicolon
DECL|variable|init_nm256
id|EXPORT_SYMBOL
c_func
(paren
id|init_nm256
)paren
suffix:semicolon
DECL|variable|loaded
r_static
r_int
id|loaded
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
(paren
id|usecache
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|buffertop
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|nm256_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|force_load
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|do_init_nm256
r_static
r_int
id|__init
id|do_init_nm256
c_func
(paren
r_void
)paren
(brace
id|nmcard_list
op_assign
l_int|NULL
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;NeoMagic 256AV/256ZX audio driver, version 1.1&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_nm256
(paren
)paren
op_eq
l_int|0
)paren
(brace
id|loaded
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|cleanup_nm256
r_static
r_void
id|__exit
id|cleanup_nm256
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|loaded
)paren
(brace
r_struct
id|nm256_info
op_star
id|card
suffix:semicolon
r_struct
id|nm256_info
op_star
id|next_card
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|nmcard_list
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|next_card
)paren
(brace
id|stopPlay
(paren
id|card
)paren
suffix:semicolon
id|stopRecord
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;has_irq
)paren
id|free_irq
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|nm256_release_ports
(paren
id|card
)paren
suffix:semicolon
id|sound_unload_mixerdev
(paren
id|card-&gt;mixer_oss_dev
)paren
suffix:semicolon
id|sound_unload_audiodev
(paren
id|card-&gt;dev
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sound_unload_audiodev
(paren
id|card-&gt;dev
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|next_card
op_assign
id|card-&gt;next_card
suffix:semicolon
id|kfree
(paren
id|card
)paren
suffix:semicolon
)brace
id|nmcard_list
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pm_unregister_all
(paren
op_amp
id|handle_pm_event
)paren
suffix:semicolon
)brace
DECL|variable|do_init_nm256
id|module_init
c_func
(paren
id|do_init_nm256
)paren
suffix:semicolon
DECL|variable|cleanup_nm256
id|module_exit
c_func
(paren
id|cleanup_nm256
)paren
suffix:semicolon
multiline_comment|/*&n; * Local variables:&n; *  c-basic-offset: 4&n; * End:&n; */
eof
