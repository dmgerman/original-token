multiline_comment|/*&n; *  Copyright 1999 Jaroslav Kysela &lt;perex@suse.cz&gt;&n; *  Copyright 2000 Alan Cox &lt;alan@redhat.com&gt;&n; *&n; *  Yamaha YMF7xx driver.&n; *&n; *  This code is a result of high-speed collision&n; *  between ymfpci.c of ALSA and cs46xx.c of Linux.&n; *  -- Pete Zaitcev &lt;zaitcev@metabyte.com&gt;; 2000/09/18&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *   GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program; if not, write to the Free Software&n; *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * TODO:&n; *  - Use P44Slot for 44.1 playback.&n; *  - Capture and duplex&n; *  - 96KHz playback for DVD - use pitch of 2.0.&n; *  - uLaw for Sun apps.&n; *  - Retain DMA buffer on close, do not wait the end of frame.&n; *  - Cleanup&n; *      ? merge ymf_pcm and state&n; *      ? pcm interrupt no pointer&n; *      ? underused structure members&n; *      - Remove remaining P3 tags (debug messages).&n; *  - Resolve XXX tagged questions.&n; *  - Cannot play 5133Hz.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;ymfpci.h&quot;
DECL|macro|snd_magic_cast
mdefine_line|#define snd_magic_cast(t, p, err)&t;((t *)(p))
multiline_comment|/* Channels, such as play and record. I do only play a.t.m. XXX */
DECL|macro|NR_HW_CH
mdefine_line|#define NR_HW_CH&t;1
r_static
r_int
id|ymf_playback_trigger
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_pcm_t
op_star
id|ypcm
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ymfpci_voice_alloc
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_voice_type_t
id|type
comma
r_int
id|pair
comma
id|ymfpci_voice_t
op_star
op_star
id|rvoice
)paren
suffix:semicolon
r_static
r_int
id|ymfpci_voice_free
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_voice_t
op_star
id|pvoice
)paren
suffix:semicolon
r_static
r_int
id|ymf_playback_prepare
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
r_struct
id|ymf_state
op_star
id|state
)paren
suffix:semicolon
r_static
r_int
id|ymf_state_alloc
c_func
(paren
id|ymfpci_t
op_star
id|unit
comma
r_int
id|nvirt
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ymf_devs
)paren
suffix:semicolon
multiline_comment|/*&n; *  constants&n; */
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|ymf_id_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
DECL|macro|DEV
mdefine_line|#define DEV(v, d, data) &bslash;&n;  { PCI_VENDOR_ID_##v, PCI_DEVICE_ID_##v##_##d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)data }
id|DEV
(paren
id|YAMAHA
comma
l_int|724
comma
l_string|&quot;YMF724&quot;
)paren
comma
id|DEV
(paren
id|YAMAHA
comma
l_float|724F
comma
l_string|&quot;YMF724F&quot;
)paren
comma
id|DEV
(paren
id|YAMAHA
comma
l_int|740
comma
l_string|&quot;YMF740&quot;
)paren
comma
id|DEV
(paren
id|YAMAHA
comma
l_int|740
id|C
comma
l_string|&quot;YMF740C&quot;
)paren
comma
id|DEV
(paren
id|YAMAHA
comma
l_int|744
comma
l_string|&quot;YMF744&quot;
)paren
comma
id|DEV
(paren
id|YAMAHA
comma
l_int|754
comma
l_string|&quot;YMF754&quot;
)paren
comma
DECL|macro|DEV
macro_line|#undef DEV
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|ymf_id_tbl
)paren
suffix:semicolon
multiline_comment|/*&n; * Mindlessly copied from cs46xx XXX&n; */
DECL|function|ld2
r_extern
id|__inline__
r_int
id|ld2
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10000
)paren
(brace
id|x
op_rshift_assign
l_int|16
suffix:semicolon
id|r
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x100
)paren
(brace
id|x
op_rshift_assign
l_int|8
suffix:semicolon
id|r
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10
)paren
(brace
id|x
op_rshift_assign
l_int|4
suffix:semicolon
id|r
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|4
)paren
(brace
id|x
op_rshift_assign
l_int|2
suffix:semicolon
id|r
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|2
)paren
id|r
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; *  common I/O routines&n; */
DECL|function|ymfpci_readb
r_static
r_inline
id|u8
id|ymfpci_readb
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|u32
id|offset
)paren
(brace
r_return
id|readb
c_func
(paren
id|codec-&gt;reg_area_virt
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_writeb
r_static
r_inline
r_void
id|ymfpci_writeb
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|u32
id|offset
comma
id|u8
id|val
)paren
(brace
id|writeb
c_func
(paren
id|val
comma
id|codec-&gt;reg_area_virt
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_readw
r_static
r_inline
id|u16
id|ymfpci_readw
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|u32
id|offset
)paren
(brace
r_return
id|readw
c_func
(paren
id|codec-&gt;reg_area_virt
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_writew
r_static
r_inline
r_void
id|ymfpci_writew
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|u32
id|offset
comma
id|u16
id|val
)paren
(brace
id|writew
c_func
(paren
id|val
comma
id|codec-&gt;reg_area_virt
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_readl
r_static
r_inline
id|u32
id|ymfpci_readl
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|u32
id|offset
)paren
(brace
r_return
id|readl
c_func
(paren
id|codec-&gt;reg_area_virt
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_writel
r_static
r_inline
r_void
id|ymfpci_writel
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|u32
id|offset
comma
id|u32
id|val
)paren
(brace
id|writel
c_func
(paren
id|val
comma
id|codec-&gt;reg_area_virt
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_codec_ready
r_static
r_int
id|ymfpci_codec_ready
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
r_int
id|secondary
comma
r_int
id|sched
)paren
(brace
r_int
r_int
id|end_time
suffix:semicolon
id|u32
id|reg
op_assign
id|secondary
ques
c_cond
id|YDSXGR_SECSTATUSADR
suffix:colon
id|YDSXGR_PRISTATUSADR
suffix:semicolon
id|end_time
op_assign
id|jiffies
op_plus
l_int|3
op_star
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|reg
)paren
op_amp
l_int|0x8000
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sched
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|end_time
op_minus
(paren
r_int
r_int
)paren
id|jiffies
op_ge
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ymfpci_codec_ready: codec %i is not ready [0x%x]&bslash;n&quot;
comma
id|secondary
comma
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|reg
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|ymfpci_codec_write
r_static
r_void
id|ymfpci_codec_write
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|val
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|dev-&gt;private_data
suffix:semicolon
id|u32
id|cmd
suffix:semicolon
multiline_comment|/* XXX Do make use of dev-&gt;id */
id|ymfpci_codec_ready
c_func
(paren
id|codec
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cmd
op_assign
(paren
(paren
id|YDSXG_AC97WRITECMD
op_or
id|reg
)paren
op_lshift
l_int|16
)paren
op_or
id|val
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_AC97CMDDATA
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_codec_read
r_static
id|u16
id|ymfpci_codec_read
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ymfpci_codec_ready
c_func
(paren
id|codec
comma
l_int|0
comma
l_int|0
)paren
)paren
r_return
op_complement
l_int|0
suffix:semicolon
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_AC97CMDADR
comma
id|YDSXG_AC97READCMD
op_or
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ymfpci_codec_ready
c_func
(paren
id|codec
comma
l_int|0
comma
l_int|0
)paren
)paren
r_return
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|codec-&gt;pci-&gt;device
op_eq
id|PCI_DEVICE_ID_YAMAHA_744
op_logical_and
id|codec-&gt;rev
OL
l_int|2
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|600
suffix:semicolon
id|i
op_increment
)paren
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|YDSXGR_PRISTATUSDATA
)paren
suffix:semicolon
)brace
r_return
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|YDSXGR_PRISTATUSDATA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Misc routines&n; */
multiline_comment|/*&n; * Calculate the actual sampling rate relatetively to the base clock (48kHz).&n; */
DECL|function|ymfpci_calc_delta
r_static
id|u32
id|ymfpci_calc_delta
c_func
(paren
id|u32
id|rate
)paren
(brace
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|8000
suffix:colon
r_return
l_int|0x02aaab00
suffix:semicolon
r_case
l_int|11025
suffix:colon
r_return
l_int|0x03accd00
suffix:semicolon
r_case
l_int|16000
suffix:colon
r_return
l_int|0x05555500
suffix:semicolon
r_case
l_int|22050
suffix:colon
r_return
l_int|0x07599a00
suffix:semicolon
r_case
l_int|32000
suffix:colon
r_return
l_int|0x0aaaab00
suffix:semicolon
r_case
l_int|44100
suffix:colon
r_return
l_int|0x0eb33300
suffix:semicolon
r_default
suffix:colon
r_return
(paren
(paren
id|rate
op_lshift
l_int|16
)paren
op_div
l_int|48000
)paren
op_lshift
l_int|12
suffix:semicolon
)brace
)brace
DECL|variable|def_rate
r_static
id|u32
id|def_rate
(braket
l_int|8
)braket
op_assign
(brace
l_int|100
comma
l_int|2000
comma
l_int|8000
comma
l_int|11025
comma
l_int|16000
comma
l_int|22050
comma
l_int|32000
comma
l_int|48000
)brace
suffix:semicolon
DECL|function|ymfpci_calc_lpfK
r_static
id|u32
id|ymfpci_calc_lpfK
c_func
(paren
id|u32
id|rate
)paren
(brace
id|u32
id|i
suffix:semicolon
r_static
id|u32
id|val
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x00570000
comma
l_int|0x06AA0000
comma
l_int|0x18B20000
comma
l_int|0x20930000
comma
l_int|0x2B9A0000
comma
l_int|0x35A10000
comma
l_int|0x3EAA0000
comma
l_int|0x40000000
)brace
suffix:semicolon
r_if
c_cond
(paren
id|rate
op_eq
l_int|44100
)paren
r_return
l_int|0x40000000
suffix:semicolon
multiline_comment|/* FIXME: What&squot;s the right value? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rate
op_le
id|def_rate
(braket
id|i
)braket
)paren
r_return
id|val
(braket
id|i
)braket
suffix:semicolon
r_return
id|val
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|ymfpci_calc_lpfQ
r_static
id|u32
id|ymfpci_calc_lpfQ
c_func
(paren
id|u32
id|rate
)paren
(brace
id|u32
id|i
suffix:semicolon
r_static
id|u32
id|val
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x35280000
comma
l_int|0x34A70000
comma
l_int|0x32020000
comma
l_int|0x31770000
comma
l_int|0x31390000
comma
l_int|0x31C90000
comma
l_int|0x33D00000
comma
l_int|0x40000000
)brace
suffix:semicolon
r_if
c_cond
(paren
id|rate
op_eq
l_int|44100
)paren
r_return
l_int|0x370A0000
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rate
op_le
id|def_rate
(braket
id|i
)braket
)paren
r_return
id|val
(braket
id|i
)braket
suffix:semicolon
r_return
id|val
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|ymf_calc_lend
r_static
id|u32
id|ymf_calc_lend
c_func
(paren
id|u32
id|rate
)paren
(brace
r_return
(paren
id|rate
op_star
id|YMF_SAMPF
)paren
op_div
l_int|48000
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX Find if this function exists in the OSS framework.&n; * XXX Make sure we do no panic when ADPCM is selected.&n; */
DECL|function|ymf_pcm_format_width
r_static
r_int
id|ymf_pcm_format_width
c_func
(paren
r_int
id|format
)paren
(brace
r_static
r_int
id|mask16
op_assign
id|AFMT_S16_LE
op_or
id|AFMT_S16_BE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_U16_BE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|format
op_amp
(paren
id|format
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci: format 0x%x is not a power of 2&bslash;n&quot;
comma
id|format
)paren
suffix:semicolon
r_return
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|format
op_eq
id|AFMT_IMA_ADPCM
)paren
r_return
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|format
op_amp
id|mask16
)paren
op_ne
l_int|0
)paren
r_return
l_int|16
suffix:semicolon
r_return
l_int|8
suffix:semicolon
)brace
DECL|function|ymf_pcm_update_shift
r_static
r_void
id|ymf_pcm_update_shift
c_func
(paren
r_struct
id|ymf_pcm_format
op_star
id|f
)paren
(brace
id|f-&gt;shift
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;voices
op_eq
l_int|2
)paren
id|f-&gt;shift
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ymf_pcm_format_width
c_func
(paren
id|f-&gt;format
)paren
op_eq
l_int|16
)paren
id|f-&gt;shift
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Whole OSS-style DMA machinery is taken from cs46xx.&n; */
multiline_comment|/* Are you sure 32K is not too much? See if mpg123 skips on loaded systems. */
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER (15-PAGE_SHIFT)
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1
multiline_comment|/* allocate DMA buffer, playback and recording buffer should be allocated seperately */
DECL|function|alloc_dmabuf
r_static
r_int
id|alloc_dmabuf
c_func
(paren
r_struct
id|ymf_state
op_star
id|state
)paren
(brace
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
suffix:semicolon
r_struct
id|page
op_star
id|map
comma
op_star
id|mapend
suffix:semicolon
multiline_comment|/* alloc as big a chunk as we can */
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
comma
id|order
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ymfpci: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|rawbuf
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;ready
op_assign
id|dmabuf-&gt;mapped
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;rawbuf
op_assign
id|rawbuf
suffix:semicolon
id|dmabuf-&gt;buforder
op_assign
id|order
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|mapend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|map
op_le
id|mapend
suffix:semicolon
id|map
op_increment
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|map-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free DMA buffer */
DECL|function|dealloc_dmabuf
r_static
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|ymf_state
op_star
id|state
)paren
(brace
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|page
op_star
id|map
comma
op_star
id|mapend
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
(brace
multiline_comment|/* undo marking the pages as reserved */
id|mapend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|map
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
id|map
op_le
id|mapend
suffix:semicolon
id|map
op_increment
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|map-&gt;flags
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|dmabuf-&gt;rawbuf
comma
id|dmabuf-&gt;buforder
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|ymf_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|w_16
suffix:semicolon
r_int
id|bytepersec
suffix:semicolon
r_int
id|bufsize
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|redzone
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|w_16
op_assign
id|ymf_pcm_format_width
c_func
(paren
id|state-&gt;format.format
)paren
op_eq
l_int|16
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|dmabuf-&gt;swptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer if not allocated yet */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;rawbuf
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|bytepersec
op_assign
id|state-&gt;format.rate
op_lshift
id|state-&gt;format.shift
suffix:semicolon
multiline_comment|/*&n;&t; * Create fake fragment sizes and numbers for OSS ioctls.&n;&t; */
id|bufsize
op_assign
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragshift
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1000
op_lshift
id|dmabuf-&gt;ossfragshift
)paren
OL
id|bytepersec
)paren
id|dmabuf-&gt;fragshift
op_assign
id|ld2
c_func
(paren
id|bytepersec
op_div
l_int|1000
)paren
suffix:semicolon
r_else
id|dmabuf-&gt;fragshift
op_assign
id|dmabuf-&gt;ossfragshift
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lets hand out reasonable big ass buffers by default */
id|dmabuf-&gt;fragshift
op_assign
(paren
id|dmabuf-&gt;buforder
op_plus
id|PAGE_SHIFT
op_minus
l_int|2
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;numfrag
op_assign
id|bufsize
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
r_while
c_loop
(paren
id|dmabuf-&gt;numfrag
template_param
l_int|3
)paren
(brace
id|dmabuf-&gt;fragshift
op_decrement
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
id|bufsize
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
)brace
id|dmabuf-&gt;fragsize
op_assign
l_int|1
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
id|dmabuf-&gt;fragsize
op_rshift
id|state-&gt;format.shift
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
id|dmabuf-&gt;numfrag
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
multiline_comment|/*&n;&t; * Import what Doom might have set with SNDCTL_DSD_SETFRAGMENT.&n;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_ge
l_int|2
op_logical_and
id|dmabuf-&gt;ossmaxfrags
OL
id|dmabuf-&gt;numfrag
)paren
(brace
id|dmabuf-&gt;numfrag
op_assign
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
id|dmabuf-&gt;dmasize
op_assign
id|dmabuf-&gt;numfrag
op_lshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|redzone
op_assign
id|ymf_calc_lend
c_func
(paren
id|state-&gt;format.rate
)paren
suffix:semicolon
id|redzone
op_lshift_assign
(paren
id|state-&gt;format.shift
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;dmasize
OL
id|redzone
op_star
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The driver works correctly with minimum dmasize&n;&t;&t;&t; * of redzone*2, but it produces stoppage and clicks.&n;&t;&t;&t; * So, make it little larger for smoother sound.&n;&t;&t;&t; * XXX Make dmasize a wholy divisible by fragsize.&n;&t;&t;&t; */
singleline_comment|//&t;&t;&t;printk(KERN_ERR &quot;ymfpci: dmasize=%d &lt; redzone=%d * 3&bslash;n&quot;,
singleline_comment|//&t;&t;&t;    dmabuf-&gt;dmasize, redzone);
id|dmabuf-&gt;dmasize
op_assign
id|redzone
op_star
l_int|3
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
id|w_16
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now set up the ring &n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
(brace
multiline_comment|/* ymf_rec_setup(state); */
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|ymf_playback_prepare
c_func
(paren
id|state-&gt;unit
comma
id|state
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* set the ready flag for the dma buffer (this comment is not stupid) */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;prog_dmabuf: rate %d format 0x%x,&quot;
l_string|&quot; numfrag %d fragsize %d dmasize %d&bslash;n&quot;
comma
id|state-&gt;format.rate
comma
id|state-&gt;format.format
comma
id|dmabuf-&gt;numfrag
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ymf_start_dac
r_static
r_void
id|ymf_start_dac
c_func
(paren
r_struct
id|ymf_state
op_star
id|state
)paren
(brace
id|ymf_playback_trigger
c_func
(paren
id|state-&gt;unit
comma
op_amp
id|state-&gt;ypcm
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait until output is drained.&n; * This does not kill the hardware for the sake of ioctls.&n; */
DECL|function|ymf_wait_dac
r_static
r_void
id|ymf_wait_dac
c_func
(paren
r_struct
id|ymf_state
op_star
id|state
)paren
(brace
r_struct
id|ymf_unit
op_star
id|unit
op_assign
id|state-&gt;unit
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
op_amp
id|state-&gt;ypcm
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|waita
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;dmabuf.count
op_ne
l_int|0
op_logical_and
op_logical_neg
id|state-&gt;ypcm.running
)paren
(brace
id|ymf_playback_trigger
c_func
(paren
id|unit
comma
id|ypcm
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX Our  mistake is to attach DMA buffer to state&n;&t;&t; * rather than to some per-device structure.&n;&t;&t; * Cannot skip waiting, can only make it shorter.&n;&t;&t; */
)brace
macro_line|#endif
r_while
c_loop
(paren
id|ypcm-&gt;running
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
comma
op_amp
id|waita
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This function may take up to 4 seconds to reach this point&n;&t; * (32K circular buffer, 8000 Hz). User notices.&n;&t; */
)brace
multiline_comment|/*&n; *  Hardware start management&n; */
DECL|function|ymfpci_hw_start
r_static
r_void
id|ymfpci_hw_start
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|codec-&gt;start_count
op_increment
op_eq
l_int|0
)paren
(brace
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MODE
comma
l_int|3
)paren
suffix:semicolon
id|codec-&gt;active_bank
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_CTRLSELECT
)paren
op_amp
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_hw_stop
r_static
r_void
id|ymfpci_hw_stop
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|timeout
op_assign
l_int|1000
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|codec-&gt;start_count
op_eq
l_int|0
)paren
(brace
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MODE
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_STATUS
)paren
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Playback voice management&n; */
DECL|function|voice_alloc
r_static
r_int
id|voice_alloc
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_voice_type_t
id|type
comma
r_int
id|pair
comma
id|ymfpci_voice_t
op_star
op_star
id|rvoice
)paren
(brace
id|ymfpci_voice_t
op_star
id|voice
comma
op_star
id|voice2
suffix:semicolon
r_int
id|idx
suffix:semicolon
op_star
id|rvoice
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|64
suffix:semicolon
id|idx
op_add_assign
id|pair
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
(brace
id|voice
op_assign
op_amp
id|codec-&gt;voices
(braket
id|idx
)braket
suffix:semicolon
id|voice2
op_assign
id|pair
ques
c_cond
op_amp
id|codec-&gt;voices
(braket
id|idx
op_plus
l_int|1
)braket
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|voice-&gt;use
op_logical_or
(paren
id|voice2
op_logical_and
id|voice2-&gt;use
)paren
)paren
r_continue
suffix:semicolon
id|voice-&gt;use
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|voice2
)paren
id|voice2-&gt;use
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|YMFPCI_PCM
suffix:colon
id|voice-&gt;pcm
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|voice2
)paren
id|voice2-&gt;pcm
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|YMFPCI_SYNTH
suffix:colon
id|voice-&gt;synth
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|YMFPCI_MIDI
suffix:colon
id|voice-&gt;midi
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ymfpci_hw_start
c_func
(paren
id|codec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|voice2
)paren
id|ymfpci_hw_start
c_func
(paren
id|codec
)paren
suffix:semicolon
op_star
id|rvoice
op_assign
id|voice
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|ymfpci_voice_alloc
r_static
r_int
id|ymfpci_voice_alloc
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_voice_type_t
id|type
comma
r_int
id|pair
comma
id|ymfpci_voice_t
op_star
op_star
id|rvoice
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;voice_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|result
op_assign
id|voice_alloc
c_func
(paren
id|codec
comma
id|type
comma
id|pair
comma
id|rvoice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|type
op_ne
id|YMFPCI_PCM
)paren
r_break
suffix:semicolon
multiline_comment|/* TODO: synth/midi voice deallocation */
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;voice_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ymfpci_voice_free
r_static
r_int
id|ymfpci_voice_free
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_voice_t
op_star
id|pvoice
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ymfpci_hw_stop
c_func
(paren
id|codec
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;voice_lock
comma
id|flags
)paren
suffix:semicolon
id|pvoice-&gt;use
op_assign
id|pvoice-&gt;pcm
op_assign
id|pvoice-&gt;synth
op_assign
id|pvoice-&gt;midi
op_assign
l_int|0
suffix:semicolon
id|pvoice-&gt;ypcm
op_assign
l_int|NULL
suffix:semicolon
id|pvoice-&gt;interrupt
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;voice_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  PCM part&n; */
DECL|function|ymf_pcm_interrupt
r_static
r_void
id|ymf_pcm_interrupt
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_voice_t
op_star
id|voice
)paren
(brace
id|ymfpci_pcm_t
op_star
id|ypcm
suffix:semicolon
r_int
id|redzone
suffix:semicolon
r_int
id|pos
comma
id|delta
comma
id|swptr
suffix:semicolon
r_int
id|played
comma
id|distance
suffix:semicolon
r_struct
id|ymf_state
op_star
id|state
suffix:semicolon
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
suffix:semicolon
r_char
id|silence
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ypcm
op_assign
id|voice-&gt;ypcm
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|state
op_assign
id|ypcm-&gt;state
)paren
op_eq
l_int|NULL
)paren
(brace
id|ypcm-&gt;running
op_assign
l_int|0
suffix:semicolon
singleline_comment|// lock it
r_return
suffix:semicolon
)brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;running
)paren
(brace
multiline_comment|/* P3 */
multiline_comment|/** printk(&quot;ymfpci: %d, intr bank %d count %d start 0x%x:%x&bslash;n&quot;,&n;  voice-&gt;number, codec-&gt;active_bank, dmabuf-&gt;count,&n;  voice-&gt;bank[0].start, voice-&gt;bank[1].start); **/
id|silence
op_assign
(paren
id|ymf_pcm_format_width
c_func
(paren
id|state-&gt;format.format
)paren
op_eq
l_int|16
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x80
suffix:semicolon
multiline_comment|/* We need actual left-hand-side redzone size here. */
id|redzone
op_assign
id|ymf_calc_lend
c_func
(paren
id|state-&gt;format.rate
)paren
suffix:semicolon
id|redzone
op_lshift_assign
(paren
id|state-&gt;format.shift
op_plus
l_int|1
)paren
suffix:semicolon
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|pos
op_assign
id|voice-&gt;bank
(braket
id|codec-&gt;active_bank
)braket
dot
id|start
suffix:semicolon
id|pos
op_lshift_assign
id|state-&gt;format.shift
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
op_logical_or
id|pos
op_ge
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* ucode bug */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci%d: %d: runaway: hwptr %d dmasize %d&bslash;n&quot;
comma
id|codec-&gt;dev_audio
comma
id|voice-&gt;number
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OL
id|dmabuf-&gt;hwptr
)paren
(brace
id|delta
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;hwptr
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|dmabuf-&gt;hwptr
comma
id|silence
comma
id|delta
)paren
suffix:semicolon
id|delta
op_add_assign
id|pos
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
id|silence
comma
id|pos
)paren
suffix:semicolon
)brace
r_else
(brace
id|delta
op_assign
id|pos
op_minus
id|dmabuf-&gt;hwptr
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|dmabuf-&gt;hwptr
comma
id|silence
comma
id|delta
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;hwptr
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ymfpci%d: %d: strain: hwptr %d&bslash;n&quot;
comma
id|codec-&gt;dev_audio
comma
id|voice-&gt;number
comma
id|dmabuf-&gt;hwptr
)paren
suffix:semicolon
id|ymf_playback_trigger
c_func
(paren
id|codec
comma
id|ypcm
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swptr
op_le
id|pos
)paren
(brace
id|distance
op_assign
id|pos
op_minus
id|swptr
suffix:semicolon
)brace
r_else
(brace
id|distance
op_assign
id|dmabuf-&gt;dmasize
op_minus
(paren
id|swptr
op_minus
id|pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|distance
OL
id|redzone
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * hwptr inside redzone =&gt; DMA ran out of samples.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|delta
OL
id|dmabuf-&gt;count
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Lost interrupt or other screwage.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;ymfpci%d: %d: lost: delta %d&quot;
l_string|&quot; hwptr %d swptr %d distance %d count %d&bslash;n&quot;
comma
id|codec-&gt;dev_audio
comma
id|voice-&gt;number
comma
id|delta
comma
id|dmabuf-&gt;hwptr
comma
id|swptr
comma
id|distance
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Normal end of DMA.&n;&t;&t;&t;&t; */
singleline_comment|//&t;&t;&t;&t;printk(&quot;ymfpci%d: %d: done: delta %d&quot;
singleline_comment|//&t;&t;&t;&t;    &quot; hwptr %d swptr %d distance %d count %d&bslash;n&quot;,
singleline_comment|//&t;&t;&t;&t;    codec-&gt;dev_audio, voice-&gt;number, delta,
singleline_comment|//&t;&t;&t;&t;    dmabuf-&gt;hwptr, swptr, distance, dmabuf-&gt;count);
)brace
id|played
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;running
)paren
(brace
id|ymf_playback_trigger
c_func
(paren
id|codec
comma
id|ypcm
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * hwptr is chipping away towards a remote swptr.&n;&t;&t;&t; * Calculate other distance and apply it to count.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|swptr
op_ge
id|pos
)paren
(brace
id|distance
op_assign
id|swptr
op_minus
id|pos
suffix:semicolon
)brace
r_else
(brace
id|distance
op_assign
id|dmabuf-&gt;dmasize
op_minus
(paren
id|pos
op_minus
id|swptr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|distance
OL
id|dmabuf-&gt;count
)paren
(brace
id|played
op_assign
id|dmabuf-&gt;count
op_minus
id|distance
suffix:semicolon
)brace
r_else
(brace
id|played
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|dmabuf-&gt;total_bytes
op_add_assign
id|played
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|played
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|dmabuf-&gt;dmasize
op_div
l_int|2
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
DECL|function|ymfpci_pcm_capture_interrupt
r_static
r_void
id|ymfpci_pcm_capture_interrupt
c_func
(paren
id|snd_pcm_subchn_t
op_star
id|substream
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_pcm_t
comma
id|runtime-&gt;private_data
comma
)paren
suffix:semicolon
id|ymfpci_t
op_star
id|codec
op_assign
id|ypcm-&gt;codec
suffix:semicolon
id|u32
id|pos
comma
id|delta
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;running
)paren
(brace
id|pos
op_assign
id|codec-&gt;bank_capture
(braket
id|ypcm-&gt;capture_bank_number
)braket
(braket
id|codec-&gt;active_bank
)braket
op_member_access_from_pointer
id|start
op_lshift
id|ypcm-&gt;shift_offset
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|ypcm-&gt;last_pos
)paren
singleline_comment|// &lt;--  dmabuf-&gt;hwptr
id|delta
op_assign
id|pos
op_plus
(paren
id|ypcm-&gt;buffer_size
op_minus
id|ypcm-&gt;last_pos
)paren
suffix:semicolon
r_else
id|delta
op_assign
id|pos
op_minus
id|ypcm-&gt;last_pos
suffix:semicolon
id|ypcm-&gt;frag_pos
op_add_assign
id|delta
suffix:semicolon
id|ypcm-&gt;last_pos
op_assign
id|pos
suffix:semicolon
r_while
c_loop
(paren
id|ypcm-&gt;frag_pos
op_ge
id|ypcm-&gt;frag_size
)paren
(brace
id|ypcm-&gt;frag_pos
op_sub_assign
id|ypcm-&gt;frag_size
suffix:semicolon
singleline_comment|// printk(&quot;done - active_bank = 0x%x, start = 0x%x&bslash;n&quot;, codec-&gt;active_bank, voice-&gt;bank[codec-&gt;active_bank].start);
id|spin_unlock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
id|snd_pcm_transfer_done
c_func
(paren
id|substream
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ymf_playback_trigger
r_static
r_int
id|ymf_playback_trigger
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
id|ymfpci_pcm_t
op_star
id|ypcm
comma
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_ne
l_int|0
)paren
(brace
id|codec-&gt;ctrl_playback
(braket
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_member_access_from_pointer
id|number
op_plus
l_int|1
)braket
op_assign
id|virt_to_bus
c_func
(paren
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_member_access_from_pointer
id|bank
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_ne
l_int|NULL
)paren
id|codec-&gt;ctrl_playback
(braket
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_member_access_from_pointer
id|number
op_plus
l_int|1
)braket
op_assign
id|virt_to_bus
c_func
(paren
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_member_access_from_pointer
id|bank
)paren
suffix:semicolon
id|ypcm-&gt;running
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|codec-&gt;ctrl_playback
(braket
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_member_access_from_pointer
id|number
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_ne
l_int|NULL
)paren
id|codec-&gt;ctrl_playback
(braket
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_member_access_from_pointer
id|number
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|ypcm-&gt;running
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
DECL|function|ymfpci_capture_trigger
r_static
r_int
id|ymfpci_capture_trigger
c_func
(paren
r_void
op_star
id|private_data
comma
id|snd_pcm_subchn_t
op_star
id|substream
comma
r_int
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ymfpci_t
op_star
id|codec
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_t
comma
id|private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_pcm_t
comma
id|substream-&gt;runtime-&gt;private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|SND_PCM_TRIGGER_GO
)paren
(brace
id|tmp
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_MAPOFREC
)paren
op_or
(paren
l_int|1
op_lshift
id|ypcm-&gt;capture_bank_number
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MAPOFREC
comma
id|tmp
)paren
suffix:semicolon
id|ypcm-&gt;running
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|SND_PCM_TRIGGER_STOP
)paren
(brace
id|tmp
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_MAPOFREC
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|ypcm-&gt;capture_bank_number
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MAPOFREC
comma
id|tmp
)paren
suffix:semicolon
id|ypcm-&gt;running
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ymfpci_pcm_voice_alloc
r_static
r_int
id|ymfpci_pcm_voice_alloc
c_func
(paren
id|ymfpci_pcm_t
op_star
id|ypcm
comma
r_int
id|voices
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_ne
l_int|NULL
op_logical_and
id|voices
OL
l_int|2
)paren
(brace
id|ymfpci_voice_free
c_func
(paren
id|ypcm-&gt;codec
comma
id|ypcm-&gt;voices
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|voices
op_eq
l_int|1
op_logical_and
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_ne
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* already allocated */
r_if
c_cond
(paren
id|voices
op_eq
l_int|2
op_logical_and
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_ne
l_int|NULL
op_logical_and
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_ne
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* already allocated */
r_if
c_cond
(paren
id|voices
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_ne
l_int|NULL
op_logical_and
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_eq
l_int|NULL
)paren
(brace
id|ymfpci_voice_free
c_func
(paren
id|ypcm-&gt;codec
comma
id|ypcm-&gt;voices
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|err
op_assign
id|ymfpci_voice_alloc
c_func
(paren
id|ypcm-&gt;codec
comma
id|YMFPCI_PCM
comma
id|voices
OG
l_int|1
comma
op_amp
id|ypcm-&gt;voices
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_member_access_from_pointer
id|ypcm
op_assign
id|ypcm
suffix:semicolon
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_member_access_from_pointer
id|interrupt
op_assign
id|ymf_pcm_interrupt
suffix:semicolon
r_if
c_cond
(paren
id|voices
OG
l_int|1
)paren
(brace
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_assign
op_amp
id|ypcm-&gt;codec-&gt;voices
(braket
id|ypcm-&gt;voices
(braket
l_int|0
)braket
op_member_access_from_pointer
id|number
op_plus
l_int|1
)braket
suffix:semicolon
id|ypcm-&gt;voices
(braket
l_int|1
)braket
op_member_access_from_pointer
id|ypcm
op_assign
id|ypcm
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ymf_pcm_init_voice
r_static
r_void
id|ymf_pcm_init_voice
c_func
(paren
id|ymfpci_voice_t
op_star
id|voice
comma
r_int
id|stereo
comma
r_int
id|rate
comma
r_int
id|w_16
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
id|spdif
)paren
(brace
id|u32
id|format
suffix:semicolon
id|u32
id|delta
op_assign
id|ymfpci_calc_delta
c_func
(paren
id|rate
)paren
suffix:semicolon
id|u32
id|lpfQ
op_assign
id|ymfpci_calc_lpfQ
c_func
(paren
id|rate
)paren
suffix:semicolon
id|u32
id|lpfK
op_assign
id|ymfpci_calc_lpfK
c_func
(paren
id|rate
)paren
suffix:semicolon
id|ymfpci_playback_bank_t
op_star
id|bank
suffix:semicolon
r_int
id|nbank
suffix:semicolon
id|format
op_assign
(paren
id|stereo
ques
c_cond
l_int|0x00010000
suffix:colon
l_int|0
)paren
op_or
(paren
id|w_16
ques
c_cond
l_int|0
suffix:colon
l_int|0x80000000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stereo
)paren
id|end
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|w_16
)paren
id|end
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* P3 */
singleline_comment|// printk(&quot;ymf_pcm_init_voice: %d: Rate %d Format 0x%08x Delta 0x%x End 0x%x&bslash;n&quot;,
singleline_comment|//  voice-&gt;number, rate, format, delta, end);
r_for
c_loop
(paren
id|nbank
op_assign
l_int|0
suffix:semicolon
id|nbank
OL
l_int|2
suffix:semicolon
id|nbank
op_increment
)paren
(brace
id|bank
op_assign
op_amp
id|voice-&gt;bank
(braket
id|nbank
)braket
suffix:semicolon
id|bank-&gt;format
op_assign
id|format
suffix:semicolon
id|bank-&gt;loop_default
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0-loops forever, otherwise count */
id|bank-&gt;base
op_assign
id|addr
suffix:semicolon
id|bank-&gt;loop_start
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;loop_end
op_assign
id|end
suffix:semicolon
id|bank-&gt;loop_frac
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;eg_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
id|bank-&gt;lpfQ
op_assign
id|lpfQ
suffix:semicolon
id|bank-&gt;status
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;num_of_frames
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;loop_count
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;start
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;start_frac
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;delta
op_assign
id|bank-&gt;delta_end
op_assign
id|delta
suffix:semicolon
id|bank-&gt;lpfK
op_assign
id|bank-&gt;lpfK_end
op_assign
id|lpfK
suffix:semicolon
id|bank-&gt;eg_gain
op_assign
l_int|0x40000000
suffix:semicolon
id|bank-&gt;lpfD1
op_assign
id|bank-&gt;lpfD2
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;left_gain
op_assign
id|bank-&gt;right_gain
op_assign
id|bank-&gt;left_gain_end
op_assign
id|bank-&gt;right_gain_end
op_assign
id|bank-&gt;eff1_gain
op_assign
id|bank-&gt;eff2_gain
op_assign
id|bank-&gt;eff3_gain
op_assign
id|bank-&gt;eff1_gain_end
op_assign
id|bank-&gt;eff2_gain_end
op_assign
id|bank-&gt;eff3_gain_end
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stereo
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|spdif
)paren
(brace
id|bank-&gt;left_gain
op_assign
id|bank-&gt;right_gain
op_assign
id|bank-&gt;left_gain_end
op_assign
id|bank-&gt;right_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
)brace
r_else
(brace
id|bank-&gt;eff2_gain
op_assign
id|bank-&gt;eff2_gain_end
op_assign
id|bank-&gt;eff3_gain
op_assign
id|bank-&gt;eff3_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|spdif
)paren
(brace
r_if
c_cond
(paren
(paren
id|voice-&gt;number
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|bank-&gt;format
op_or_assign
l_int|1
suffix:semicolon
id|bank-&gt;left_gain
op_assign
id|bank-&gt;left_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
)brace
r_else
(brace
id|bank-&gt;right_gain
op_assign
id|bank-&gt;right_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|voice-&gt;number
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|bank-&gt;format
op_or_assign
l_int|1
suffix:semicolon
id|bank-&gt;eff2_gain
op_assign
id|bank-&gt;eff2_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
)brace
r_else
(brace
id|bank-&gt;eff3_gain
op_assign
id|bank-&gt;eff3_gain_end
op_assign
l_int|0x40000000
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * XXX Use new cache coherent PCI DMA routines instead of virt_to_bus.&n; */
DECL|function|ymf_playback_prepare
r_static
r_int
id|ymf_playback_prepare
c_func
(paren
id|ymfpci_t
op_star
id|codec
comma
r_struct
id|ymf_state
op_star
id|state
)paren
(brace
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
op_amp
id|state-&gt;ypcm
suffix:semicolon
r_int
id|err
comma
id|nvoice
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ymfpci_pcm_voice_alloc
c_func
(paren
id|ypcm
comma
id|state-&gt;format.voices
)paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Cannot be unless we leak voices in ymf_release! */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci%d: cannot allocate voice!&bslash;n&quot;
comma
id|codec-&gt;dev_audio
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_for
c_loop
(paren
id|nvoice
op_assign
l_int|0
suffix:semicolon
id|nvoice
OL
id|state-&gt;format.voices
suffix:semicolon
id|nvoice
op_increment
)paren
(brace
id|ymf_pcm_init_voice
c_func
(paren
id|ypcm-&gt;voices
(braket
id|nvoice
)braket
comma
id|state-&gt;format.voices
op_eq
l_int|2
comma
id|state-&gt;format.rate
comma
id|ymf_pcm_format_width
c_func
(paren
id|state-&gt;format.format
)paren
op_eq
l_int|16
comma
id|virt_to_bus
c_func
(paren
id|state-&gt;dmabuf.rawbuf
)paren
comma
id|state-&gt;dmabuf.dmasize
comma
id|ypcm-&gt;spdif
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0  /* old */
r_static
r_int
id|ymfpci_capture_prepare
c_func
(paren
r_void
op_star
id|private_data
comma
id|snd_pcm_subchn_t
op_star
id|substream
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_t
comma
id|private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_pcm_t
comma
id|runtime-&gt;private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|ymfpci_capture_bank_t
op_star
id|bank
suffix:semicolon
r_int
id|nbank
suffix:semicolon
id|u32
id|rate
comma
id|format
suffix:semicolon
id|ypcm-&gt;frag_size
op_assign
id|snd_pcm_lib_transfer_fragment
c_func
(paren
id|substream
)paren
suffix:semicolon
id|ypcm-&gt;buffer_size
op_assign
id|snd_pcm_lib_transfer_size
c_func
(paren
id|substream
)paren
suffix:semicolon
id|ypcm-&gt;frag_pos
op_assign
l_int|0
suffix:semicolon
id|ypcm-&gt;last_pos
op_assign
l_int|0
suffix:semicolon
id|ypcm-&gt;shift_offset
op_assign
l_int|0
suffix:semicolon
id|rate
op_assign
(paren
(paren
l_int|48000
op_star
l_int|4096
)paren
op_div
id|runtime-&gt;format.rate
)paren
op_minus
l_int|1
suffix:semicolon
id|format
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;format.voices
op_eq
l_int|2
)paren
id|format
op_or_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|snd_pcm_format_width
c_func
(paren
id|runtime-&gt;format.format
)paren
op_eq
l_int|8
)paren
id|format
op_or_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|ypcm-&gt;capture_bank_number
)paren
(brace
r_case
l_int|0
suffix:colon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_RECFORMAT
comma
id|format
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_RECSLOTSR
comma
id|rate
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_ADCFORMAT
comma
id|format
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_ADCSLOTSR
comma
id|rate
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|nbank
op_assign
l_int|0
suffix:semicolon
id|nbank
OL
l_int|2
suffix:semicolon
id|nbank
op_increment
)paren
(brace
id|bank
op_assign
id|codec-&gt;bank_capture
(braket
id|ypcm-&gt;capture_bank_number
)braket
(braket
id|nbank
)braket
suffix:semicolon
id|bank-&gt;base
op_assign
id|virt_to_bus
c_func
(paren
id|runtime-&gt;dma_area-&gt;buf
)paren
suffix:semicolon
id|bank-&gt;loop_end
op_assign
id|ypcm-&gt;buffer_size
suffix:semicolon
id|bank-&gt;start
op_assign
l_int|0
suffix:semicolon
id|bank-&gt;num_of_loops
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runtime-&gt;digital.dig_valid
)paren
multiline_comment|/*runtime-&gt;digital.type == SND_PCM_DIG_AES_IEC958*/
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_SPDIFOUTSTATUS
comma
id|runtime-&gt;digital.dig_status
(braket
l_int|0
)braket
op_or
(paren
id|runtime-&gt;digital.dig_status
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
r_int
id|ymfpci_playback_pointer
c_func
(paren
r_void
op_star
id|private_data
comma
id|snd_pcm_subchn_t
op_star
id|substream
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_t
comma
id|private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_pcm_t
comma
id|runtime-&gt;private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|ymfpci_voice_t
op_star
id|voice
op_assign
id|ypcm-&gt;voices
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;running
op_logical_and
id|voice
)paren
id|result
op_assign
id|voice-&gt;bank
(braket
id|codec-&gt;active_bank
)braket
dot
id|start
op_lshift
id|ypcm-&gt;shift_offset
suffix:semicolon
r_else
id|result
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
r_int
id|ymfpci_capture_pointer
c_func
(paren
r_void
op_star
id|private_data
comma
id|snd_pcm_subchn_t
op_star
id|substream
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_t
comma
id|private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_pcm_t
comma
id|runtime-&gt;private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;running
)paren
id|result
op_assign
id|codec-&gt;bank_capture
(braket
id|ypcm-&gt;capture_bank_number
)braket
(braket
id|codec-&gt;active_bank
)braket
op_member_access_from_pointer
id|start
op_lshift
id|ypcm-&gt;shift_offset
suffix:semicolon
r_else
id|result
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|codec-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif /* old */
DECL|function|ymf_interrupt
r_void
id|ymf_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|dev_id
suffix:semicolon
id|u32
id|status
comma
id|nvoice
comma
id|mode
suffix:semicolon
id|ymfpci_voice_t
op_star
id|voice
suffix:semicolon
id|status
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80000000
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_STATUS
comma
l_int|0x80000000
)paren
suffix:semicolon
id|mode
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_MODE
)paren
op_or
l_int|2
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MODE
comma
id|mode
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
id|codec-&gt;active_bank
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_CTRLSELECT
)paren
op_amp
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|codec-&gt;voice_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nvoice
op_assign
l_int|0
suffix:semicolon
id|nvoice
OL
l_int|64
suffix:semicolon
id|nvoice
op_increment
)paren
(brace
id|voice
op_assign
op_amp
id|codec-&gt;voices
(braket
id|nvoice
)braket
suffix:semicolon
r_if
c_cond
(paren
id|voice-&gt;interrupt
)paren
id|voice
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|codec
comma
id|voice
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|codec-&gt;voice_lock
)paren
suffix:semicolon
)brace
id|status
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_INTFLAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* timer handler */
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_INTFLAG
comma
op_complement
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|ymf_pcm_free_substream
r_static
r_void
id|ymf_pcm_free_substream
c_func
(paren
id|ymfpci_pcm_t
op_star
id|ypcm
)paren
(brace
id|ymfpci_t
op_star
id|codec
suffix:semicolon
r_if
c_cond
(paren
id|ypcm
)paren
(brace
id|codec
op_assign
id|ypcm-&gt;codec
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|1
)braket
)paren
id|ymfpci_voice_free
c_func
(paren
id|codec
comma
id|ypcm-&gt;voices
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm-&gt;voices
(braket
l_int|0
)braket
)paren
id|ymfpci_voice_free
c_func
(paren
id|codec
comma
id|ypcm-&gt;voices
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|ymf_state_alloc
r_static
r_int
id|ymf_state_alloc
c_func
(paren
id|ymfpci_t
op_star
id|unit
comma
r_int
id|nvirt
)paren
(brace
id|ymfpci_pcm_t
op_star
id|ypcm
suffix:semicolon
r_struct
id|ymf_state
op_star
id|state
suffix:semicolon
r_if
c_cond
(paren
(paren
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ymf_state
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ymf_state
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
)paren
suffix:semicolon
id|ypcm
op_assign
op_amp
id|state-&gt;ypcm
suffix:semicolon
id|ypcm-&gt;state
op_assign
id|state
suffix:semicolon
id|ypcm-&gt;codec
op_assign
id|unit
suffix:semicolon
id|ypcm-&gt;type
op_assign
id|PLAYBACK_VOICE
suffix:semicolon
id|state-&gt;unit
op_assign
id|unit
suffix:semicolon
id|state-&gt;virt
op_assign
id|nvirt
suffix:semicolon
id|state-&gt;format.format
op_assign
id|AFMT_U8
suffix:semicolon
id|state-&gt;format.rate
op_assign
l_int|8000
suffix:semicolon
id|state-&gt;format.voices
op_assign
l_int|1
suffix:semicolon
id|ymf_pcm_update_shift
c_func
(paren
op_amp
id|state-&gt;format
)paren
suffix:semicolon
id|unit-&gt;states
(braket
id|nvirt
)braket
op_assign
id|state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out0
suffix:colon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
DECL|function|ymfpci_capture_open
r_static
r_int
id|ymfpci_capture_open
c_func
(paren
r_void
op_star
id|private_data
comma
id|snd_pcm_subchn_t
op_star
id|substream
comma
id|u32
id|capture_bank_number
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_t
comma
id|private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_dma_alloc
c_func
(paren
id|substream
comma
op_logical_neg
id|capture_bank_number
ques
c_cond
id|codec-&gt;dma2ptr
suffix:colon
id|codec-&gt;dma3ptr
comma
l_string|&quot;YMFPCI - ADC&quot;
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|ypcm
op_assign
id|snd_magic_kcalloc
c_func
(paren
id|ymfpci_pcm_t
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm
op_eq
l_int|NULL
)paren
(brace
id|snd_pcm_dma_free
c_func
(paren
id|substream
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ypcm-&gt;codec
op_assign
id|codec
suffix:semicolon
id|ypcm-&gt;type
op_assign
id|capture_bank_number
op_plus
id|CAPTURE_REC
suffix:semicolon
id|ypcm-&gt;substream
op_assign
id|substream
suffix:semicolon
id|ypcm-&gt;capture_bank_number
op_assign
id|capture_bank_number
suffix:semicolon
id|codec-&gt;capture_substream
(braket
id|capture_bank_number
)braket
op_assign
id|substream
suffix:semicolon
id|runtime-&gt;hw
op_assign
op_amp
id|ymfpci_capture
suffix:semicolon
id|snd_pcm_set_mixer
c_func
(paren
id|substream
comma
id|codec-&gt;mixer-&gt;device
comma
id|codec-&gt;ac97-&gt;me_capture
)paren
suffix:semicolon
id|runtime-&gt;private_data
op_assign
id|ypcm
suffix:semicolon
id|runtime-&gt;private_free
op_assign
id|ymfpci_pcm_free_substream
suffix:semicolon
id|ymfpci_hw_start
c_func
(paren
id|codec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif  /* old */
multiline_comment|/* AES/IEC958 channel status bits */
DECL|macro|SND_PCM_AES0_PROFESSIONAL
mdefine_line|#define SND_PCM_AES0_PROFESSIONAL&t;(1&lt;&lt;0)&t;/* 0 = consumer, 1 = professional */
DECL|macro|SND_PCM_AES0_NONAUDIO
mdefine_line|#define SND_PCM_AES0_NONAUDIO&t;&t;(1&lt;&lt;1)&t;/* 0 = audio, 1 = non-audio */
DECL|macro|SND_PCM_AES0_PRO_EMPHASIS
mdefine_line|#define SND_PCM_AES0_PRO_EMPHASIS&t;(7&lt;&lt;2)&t;/* mask - emphasis */
DECL|macro|SND_PCM_AES0_PRO_EMPHASIS_NOTID
mdefine_line|#define SND_PCM_AES0_PRO_EMPHASIS_NOTID&t;(0&lt;&lt;2)&t;/* emphasis not indicated */
DECL|macro|SND_PCM_AES0_PRO_EMPHASIS_NONE
mdefine_line|#define SND_PCM_AES0_PRO_EMPHASIS_NONE&t;(1&lt;&lt;2)&t;/* none emphasis */
DECL|macro|SND_PCM_AES0_PRO_EMPHASIS_5015
mdefine_line|#define SND_PCM_AES0_PRO_EMPHASIS_5015&t;(3&lt;&lt;2)&t;/* 50/15us emphasis */
DECL|macro|SND_PCM_AES0_PRO_EMPHASIS_CCITT
mdefine_line|#define SND_PCM_AES0_PRO_EMPHASIS_CCITT&t;(7&lt;&lt;2)&t;/* CCITT J.17 emphasis */
DECL|macro|SND_PCM_AES0_PRO_FREQ_UNLOCKED
mdefine_line|#define SND_PCM_AES0_PRO_FREQ_UNLOCKED&t;(1&lt;&lt;5)&t;/* source sample frequency: 0 = locked, 1 = unlocked */
DECL|macro|SND_PCM_AES0_PRO_FS
mdefine_line|#define SND_PCM_AES0_PRO_FS&t;&t;(3&lt;&lt;6)&t;/* mask - sample frequency */
DECL|macro|SND_PCM_AES0_PRO_FS_NOTID
mdefine_line|#define SND_PCM_AES0_PRO_FS_NOTID&t;(0&lt;&lt;6)&t;/* fs not indicated */
DECL|macro|SND_PCM_AES0_PRO_FS_44100
mdefine_line|#define SND_PCM_AES0_PRO_FS_44100&t;(1&lt;&lt;6)&t;/* 44.1kHz */
DECL|macro|SND_PCM_AES0_PRO_FS_48000
mdefine_line|#define SND_PCM_AES0_PRO_FS_48000&t;(2&lt;&lt;6)&t;/* 48kHz */
DECL|macro|SND_PCM_AES0_PRO_FS_32000
mdefine_line|#define SND_PCM_AES0_PRO_FS_32000&t;(3&lt;&lt;6)&t;/* 32kHz */
DECL|macro|SND_PCM_AES0_CON_NOT_COPYRIGHT
mdefine_line|#define SND_PCM_AES0_CON_NOT_COPYRIGHT&t;(1&lt;&lt;2)&t;/* 0 = copyright, 1 = not copyright */
DECL|macro|SND_PCM_AES0_CON_EMPHASIS
mdefine_line|#define SND_PCM_AES0_CON_EMPHASIS&t;(7&lt;&lt;3)&t;/* mask - emphasis */
DECL|macro|SND_PCM_AES0_CON_EMPHASIS_NONE
mdefine_line|#define SND_PCM_AES0_CON_EMPHASIS_NONE&t;(0&lt;&lt;3)&t;/* none emphasis */
DECL|macro|SND_PCM_AES0_CON_EMPHASIS_5015
mdefine_line|#define SND_PCM_AES0_CON_EMPHASIS_5015&t;(1&lt;&lt;3)&t;/* 50/15us emphasis */
DECL|macro|SND_PCM_AES0_CON_MODE
mdefine_line|#define SND_PCM_AES0_CON_MODE&t;&t;(3&lt;&lt;6)&t;/* mask - mode */
DECL|macro|SND_PCM_AES1_PRO_MODE
mdefine_line|#define SND_PCM_AES1_PRO_MODE&t;&t;(15&lt;&lt;0)&t;/* mask - channel mode */
DECL|macro|SND_PCM_AES1_PRO_MODE_NOTID
mdefine_line|#define SND_PCM_AES1_PRO_MODE_NOTID&t;(0&lt;&lt;0)&t;/* not indicated */
DECL|macro|SND_PCM_AES1_PRO_MODE_STEREOPHONIC
mdefine_line|#define SND_PCM_AES1_PRO_MODE_STEREOPHONIC (2&lt;&lt;0) /* stereophonic - ch A is left */
DECL|macro|SND_PCM_AES1_PRO_MODE_SINGLE
mdefine_line|#define SND_PCM_AES1_PRO_MODE_SINGLE&t;(4&lt;&lt;0)&t;/* single channel */
DECL|macro|SND_PCM_AES1_PRO_MODE_TWO
mdefine_line|#define SND_PCM_AES1_PRO_MODE_TWO&t;(8&lt;&lt;0)&t;/* two channels */
DECL|macro|SND_PCM_AES1_PRO_MODE_PRIMARY
mdefine_line|#define SND_PCM_AES1_PRO_MODE_PRIMARY&t;(12&lt;&lt;0)&t;/* primary/secondary */
DECL|macro|SND_PCM_AES1_PRO_MODE_BYTE3
mdefine_line|#define SND_PCM_AES1_PRO_MODE_BYTE3&t;(15&lt;&lt;0)&t;/* vector to byte 3 */
DECL|macro|SND_PCM_AES1_PRO_USERBITS
mdefine_line|#define SND_PCM_AES1_PRO_USERBITS&t;(15&lt;&lt;4)&t;/* mask - user bits */
DECL|macro|SND_PCM_AES1_PRO_USERBITS_NOTID
mdefine_line|#define SND_PCM_AES1_PRO_USERBITS_NOTID&t;(0&lt;&lt;4)&t;/* not indicated */
DECL|macro|SND_PCM_AES1_PRO_USERBITS_192
mdefine_line|#define SND_PCM_AES1_PRO_USERBITS_192&t;(8&lt;&lt;4)&t;/* 192-bit structure */
DECL|macro|SND_PCM_AES1_PRO_USERBITS_UDEF
mdefine_line|#define SND_PCM_AES1_PRO_USERBITS_UDEF&t;(12&lt;&lt;4)&t;/* user defined application */
DECL|macro|SND_PCM_AES1_CON_CATEGORY
mdefine_line|#define SND_PCM_AES1_CON_CATEGORY&t;0x7f
DECL|macro|SND_PCM_AES1_CON_GENERAL
mdefine_line|#define SND_PCM_AES1_CON_GENERAL&t;0x00
DECL|macro|SND_PCM_AES1_CON_EXPERIMENTAL
mdefine_line|#define SND_PCM_AES1_CON_EXPERIMENTAL&t;0x40
DECL|macro|SND_PCM_AES1_CON_SOLIDMEM_MASK
mdefine_line|#define SND_PCM_AES1_CON_SOLIDMEM_MASK&t;0x0f
DECL|macro|SND_PCM_AES1_CON_SOLIDMEM_ID
mdefine_line|#define SND_PCM_AES1_CON_SOLIDMEM_ID&t;0x08
DECL|macro|SND_PCM_AES1_CON_BROADCAST1_MASK
mdefine_line|#define SND_PCM_AES1_CON_BROADCAST1_MASK 0x07
DECL|macro|SND_PCM_AES1_CON_BROADCAST1_ID
mdefine_line|#define SND_PCM_AES1_CON_BROADCAST1_ID&t;0x04
DECL|macro|SND_PCM_AES1_CON_DIGDIGCONV_MASK
mdefine_line|#define SND_PCM_AES1_CON_DIGDIGCONV_MASK 0x07
DECL|macro|SND_PCM_AES1_CON_DIGDIGCONV_ID
mdefine_line|#define SND_PCM_AES1_CON_DIGDIGCONV_ID&t;0x02
DECL|macro|SND_PCM_AES1_CON_ADC_COPYRIGHT_MASK
mdefine_line|#define SND_PCM_AES1_CON_ADC_COPYRIGHT_MASK 0x1f
DECL|macro|SND_PCM_AES1_CON_ADC_COPYRIGHT_ID
mdefine_line|#define SND_PCM_AES1_CON_ADC_COPYRIGHT_ID 0x06
DECL|macro|SND_PCM_AES1_CON_ADC_MASK
mdefine_line|#define SND_PCM_AES1_CON_ADC_MASK&t;0x1f
DECL|macro|SND_PCM_AES1_CON_ADC_ID
mdefine_line|#define SND_PCM_AES1_CON_ADC_ID&t;&t;0x16
DECL|macro|SND_PCM_AES1_CON_BROADCAST2_MASK
mdefine_line|#define SND_PCM_AES1_CON_BROADCAST2_MASK 0x0f
DECL|macro|SND_PCM_AES1_CON_BROADCAST2_ID
mdefine_line|#define SND_PCM_AES1_CON_BROADCAST2_ID&t;0x0e
DECL|macro|SND_PCM_AES1_CON_LASEROPT_MASK
mdefine_line|#define SND_PCM_AES1_CON_LASEROPT_MASK&t;0x07
DECL|macro|SND_PCM_AES1_CON_LASEROPT_ID
mdefine_line|#define SND_PCM_AES1_CON_LASEROPT_ID&t;0x01
DECL|macro|SND_PCM_AES1_CON_MUSICAL_MASK
mdefine_line|#define SND_PCM_AES1_CON_MUSICAL_MASK&t;0x07
DECL|macro|SND_PCM_AES1_CON_MUSICAL_ID
mdefine_line|#define SND_PCM_AES1_CON_MUSICAL_ID&t;0x05
DECL|macro|SND_PCM_AES1_CON_MAGNETIC_MASK
mdefine_line|#define SND_PCM_AES1_CON_MAGNETIC_MASK&t;0x07
DECL|macro|SND_PCM_AES1_CON_MAGNETIC_ID
mdefine_line|#define SND_PCM_AES1_CON_MAGNETIC_ID&t;0x03
DECL|macro|SND_PCM_AES1_CON_IEC908_CD
mdefine_line|#define SND_PCM_AES1_CON_IEC908_CD&t;(SND_PCM_AES1_CON_LASEROPT_ID|0x00)
DECL|macro|SND_PCM_AES1_CON_NON_IEC908_CD
mdefine_line|#define SND_PCM_AES1_CON_NON_IEC908_CD&t;(SND_PCM_AES1_CON_LASEROPT_ID|0x08)
DECL|macro|SND_PCM_AES1_CON_PCM_CODER
mdefine_line|#define SND_PCM_AES1_CON_PCM_CODER&t;(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x00)
DECL|macro|SND_PCM_AES1_CON_SAMPLER
mdefine_line|#define SND_PCM_AES1_CON_SAMPLER&t;(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x20)
DECL|macro|SND_PCM_AES1_CON_MIXER
mdefine_line|#define SND_PCM_AES1_CON_MIXER&t;&t;(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x10)
DECL|macro|SND_PCM_AES1_CON_RATE_CONVERTER
mdefine_line|#define SND_PCM_AES1_CON_RATE_CONVERTER&t;(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x18)
DECL|macro|SND_PCM_AES1_CON_SYNTHESIZER
mdefine_line|#define SND_PCM_AES1_CON_SYNTHESIZER&t;(SND_PCM_AES1_CON_MUSICAL_ID|0x00)
DECL|macro|SND_PCM_AES1_CON_MICROPHONE
mdefine_line|#define SND_PCM_AES1_CON_MICROPHONE&t;(SND_PCM_AES1_CON_MUSICAL_ID|0x08)
DECL|macro|SND_PCM_AES1_CON_DAT
mdefine_line|#define SND_PCM_AES1_CON_DAT&t;&t;(SND_PCM_AES1_CON_MAGNETIC_ID|0x00)
DECL|macro|SND_PCM_AES1_CON_VCR
mdefine_line|#define SND_PCM_AES1_CON_VCR&t;&t;(SND_PCM_AES1_CON_MAGNETIC_ID|0x08)
DECL|macro|SND_PCM_AES1_CON_ORIGINAL
mdefine_line|#define SND_PCM_AES1_CON_ORIGINAL&t;(1&lt;&lt;7)&t;/* this bits depends on the category code */
DECL|macro|SND_PCM_AES2_PRO_SBITS
mdefine_line|#define SND_PCM_AES2_PRO_SBITS&t;&t;(7&lt;&lt;0)&t;/* mask - sample bits */
DECL|macro|SND_PCM_AES2_PRO_SBITS_20
mdefine_line|#define SND_PCM_AES2_PRO_SBITS_20&t;(2&lt;&lt;0)&t;/* 20-bit - coordination */
DECL|macro|SND_PCM_AES2_PRO_SBITS_24
mdefine_line|#define SND_PCM_AES2_PRO_SBITS_24&t;(4&lt;&lt;0)&t;/* 24-bit - main audio */
DECL|macro|SND_PCM_AES2_PRO_SBITS_UDEF
mdefine_line|#define SND_PCM_AES2_PRO_SBITS_UDEF&t;(6&lt;&lt;0)&t;/* user defined application */
DECL|macro|SND_PCM_AES2_PRO_WORDLEN
mdefine_line|#define SND_PCM_AES2_PRO_WORDLEN&t;(7&lt;&lt;3)&t;/* mask - source word length */
DECL|macro|SND_PCM_AES2_PRO_WORDLEN_NOTID
mdefine_line|#define SND_PCM_AES2_PRO_WORDLEN_NOTID&t;(0&lt;&lt;3)&t;/* not indicated */
DECL|macro|SND_PCM_AES2_PRO_WORDLEN_22_18
mdefine_line|#define SND_PCM_AES2_PRO_WORDLEN_22_18&t;(2&lt;&lt;3)&t;/* 22-bit or 18-bit */
DECL|macro|SND_PCM_AES2_PRO_WORDLEN_23_19
mdefine_line|#define SND_PCM_AES2_PRO_WORDLEN_23_19&t;(4&lt;&lt;3)&t;/* 23-bit or 19-bit */
DECL|macro|SND_PCM_AES2_PRO_WORDLEN_24_20
mdefine_line|#define SND_PCM_AES2_PRO_WORDLEN_24_20&t;(5&lt;&lt;3)&t;/* 24-bit or 20-bit */
DECL|macro|SND_PCM_AES2_PRO_WORDLEN_20_16
mdefine_line|#define SND_PCM_AES2_PRO_WORDLEN_20_16&t;(6&lt;&lt;3)&t;/* 20-bit or 16-bit */
DECL|macro|SND_PCM_AES2_CON_SOURCE
mdefine_line|#define SND_PCM_AES2_CON_SOURCE&t;&t;(15&lt;&lt;0)&t;/* mask - source number */
DECL|macro|SND_PCM_AES2_CON_SOURCE_UNSPEC
mdefine_line|#define SND_PCM_AES2_CON_SOURCE_UNSPEC&t;(0&lt;&lt;0)&t;/* unspecified */
DECL|macro|SND_PCM_AES2_CON_CHANNEL
mdefine_line|#define SND_PCM_AES2_CON_CHANNEL&t;(15&lt;&lt;4)&t;/* mask - channel number */
DECL|macro|SND_PCM_AES2_CON_CHANNEL_UNSPEC
mdefine_line|#define SND_PCM_AES2_CON_CHANNEL_UNSPEC&t;(0&lt;&lt;4)&t;/* unspecified */
DECL|macro|SND_PCM_AES3_CON_FS
mdefine_line|#define SND_PCM_AES3_CON_FS&t;&t;(15&lt;&lt;0)&t;/* mask - sample frequency */
DECL|macro|SND_PCM_AES3_CON_FS_44100
mdefine_line|#define SND_PCM_AES3_CON_FS_44100&t;(0&lt;&lt;0)&t;/* 44.1kHz */
DECL|macro|SND_PCM_AES3_CON_FS_48000
mdefine_line|#define SND_PCM_AES3_CON_FS_48000&t;(2&lt;&lt;0)&t;/* 48kHz */
DECL|macro|SND_PCM_AES3_CON_FS_32000
mdefine_line|#define SND_PCM_AES3_CON_FS_32000&t;(3&lt;&lt;0)&t;/* 32kHz */
DECL|macro|SND_PCM_AES3_CON_CLOCK
mdefine_line|#define SND_PCM_AES3_CON_CLOCK&t;&t;(3&lt;&lt;4)&t;/* mask - clock accuracy */
DECL|macro|SND_PCM_AES3_CON_CLOCK_1000PPM
mdefine_line|#define SND_PCM_AES3_CON_CLOCK_1000PPM&t;(0&lt;&lt;4)&t;/* 1000 ppm */
DECL|macro|SND_PCM_AES3_CON_CLOCK_50PPM
mdefine_line|#define SND_PCM_AES3_CON_CLOCK_50PPM&t;(1&lt;&lt;4)&t;/* 50 ppm */
DECL|macro|SND_PCM_AES3_CON_CLOCK_VARIABLE
mdefine_line|#define SND_PCM_AES3_CON_CLOCK_VARIABLE&t;(2&lt;&lt;4)&t;/* variable pitch */
macro_line|#if HAVE_RECORD  /* old */
DECL|function|ymfpci_capture_close
r_static
r_int
id|ymfpci_capture_close
c_func
(paren
r_void
op_star
id|private_data
comma
id|snd_pcm_subchn_t
op_star
id|substream
)paren
(brace
id|ymfpci_t
op_star
id|codec
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_t
comma
id|private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|ymfpci_pcm_t
op_star
id|ypcm
op_assign
id|snd_magic_cast
c_func
(paren
id|ymfpci_pcm_t
comma
id|runtime-&gt;private_data
comma
op_minus
id|ENXIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ypcm
op_ne
l_int|NULL
)paren
(brace
id|codec-&gt;capture_substream
(braket
id|ypcm-&gt;capture_bank_number
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ymfpci_hw_stop
c_func
(paren
id|codec
)paren
suffix:semicolon
)brace
id|snd_pcm_dma_free
c_func
(paren
id|substream
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * User interface&n; */
DECL|function|ymf_llseek
r_static
id|loff_t
id|ymf_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be copied to&n;   the user&squot;s buffer.  it is filled by the dma machine and drained by this loop. */
DECL|function|ymf_read
r_static
id|ssize_t
id|ymf_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
macro_line|#if HAVE_RECORD
r_struct
id|cs_state
op_star
id|state
op_assign
(paren
r_struct
id|cs_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;cs461x: cs_read called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer overrun, we are recovering from sleep_on_timeout,&n;&t;&t;&t;   resync hwptr and swptr, make process flush the buffer */
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|cnt
)paren
id|cnt
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
multiline_comment|/* buffer is empty, start the dma machine and wait for data to be&n;&t;&t;&t;   recorded */
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This isnt strictly right for the 810  but it&squot;ll do */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|2
)paren
suffix:semicolon
id|tmo
op_rshift_assign
id|sample_shift
(braket
id|dmabuf-&gt;fmt
)braket
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer overrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
id|tmo
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs461x: recording schedule timeout, &quot;
l_string|&quot;dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;count
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;swptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* a buffer overrun, we delay the recovery untill next time the&n;&t;&t;&t;&t;   while loop begin and we REALLY have space to record */
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
DECL|function|ymf_write
r_static
id|ssize_t
id|ymf_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ymf_state
op_star
id|state
op_assign
(paren
r_struct
id|ymf_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
multiline_comment|/* This many to go in this revolution */
r_int
id|redzone
suffix:semicolon
r_int
id|delay
suffix:semicolon
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;ymf_write: count %d&bslash;n&quot;, count); */
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Alan&squot;s cs46xx works without a red zone - marvel of ingenuity.&n;&t; * We are not so brilliant... Red zone does two things:&n;&t; *  1. allows for safe start after a pause as we have no way&n;&t; *     to know what the actual, relentlessly advancing, hwptr is.&n;&t; *  2. makes computations in ymf_pcm_interrupt simpler.&n;&t; */
id|redzone
op_assign
id|ymf_calc_lend
c_func
(paren
id|state-&gt;format.rate
)paren
op_lshift
id|state-&gt;format.shift
suffix:semicolon
id|redzone
op_mul_assign
l_int|3
suffix:semicolon
multiline_comment|/* 2 redzone + 1 possible uncertainty reserve. */
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymf_write: count %d, was legal in cs46xx&bslash;n&quot;
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_eq
l_int|0
)paren
(brace
id|swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;ypcm.running
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Add uncertainty reserve.&n;&t;&t;&t;&t; */
id|cnt
op_assign
id|ymf_calc_lend
c_func
(paren
id|state-&gt;format.rate
)paren
suffix:semicolon
id|cnt
op_lshift_assign
id|state-&gt;format.shift
suffix:semicolon
r_if
c_cond
(paren
(paren
id|swptr
op_add_assign
id|cnt
)paren
op_ge
id|dmabuf-&gt;dmasize
)paren
(brace
id|swptr
op_sub_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
)brace
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX This is not right if dmabuf-&gt;count is small -&n;&t;&t;&t; * about 2*x frame size or less. We cannot count on&n;&t;&t;&t; * on appending and not causing an artefact.&n;&t;&t;&t; * Should use a variation of the count==0 case above.&n;&t;&t;&t; */
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
)brace
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_plus
id|cnt
OG
id|dmabuf-&gt;dmasize
op_minus
id|redzone
)paren
id|cnt
op_assign
(paren
id|dmabuf-&gt;dmasize
op_minus
id|redzone
)paren
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;ymf_write: full, count %d swptr %d&bslash;n&quot;,&n;  dmabuf-&gt;count, dmabuf-&gt;swptr); */
multiline_comment|/*&n;&t;&t;&t; * buffer is full, start the dma machine and&n;&t;&t;&t; * wait for data to be played&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;ypcm.running
)paren
(brace
id|ymf_playback_trigger
c_func
(paren
id|state-&gt;unit
comma
op_amp
id|state-&gt;ypcm
comma
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|swptr
op_add_assign
id|cnt
)paren
op_ge
id|dmabuf-&gt;dmasize
)paren
(brace
id|swptr
op_sub_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|cnt
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Start here is a bad idea - may cause startup click&n;&t;&t; * in /bin/play when dmabuf is not full yet.&n;&t;&t; * However, some broken applications do not make&n;&t;&t; * any use of SNDCTL_DSP_SYNC (Doom is the worst).&n;&t;&t; * One frame is about 5.3ms, Doom write size is 46ms.&n;&t;&t; */
id|delay
op_assign
id|state-&gt;format.rate
op_div
l_int|20
suffix:semicolon
multiline_comment|/* 50ms */
id|delay
op_lshift_assign
id|state-&gt;format.shift
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
id|delay
op_logical_and
op_logical_neg
id|state-&gt;ypcm.running
)paren
(brace
id|ymf_playback_trigger
c_func
(paren
id|state-&gt;unit
comma
op_amp
id|state-&gt;ypcm
comma
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;ymf_write: dmabuf.count %d&bslash;n&quot;, dmabuf-&gt;count); */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ymf_poll
r_static
r_int
r_int
id|ymf_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|ymf_state
op_star
id|state
op_assign
(paren
r_struct
id|ymf_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_WRITE
op_or
id|FMODE_READ
)paren
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_ge
id|dmabuf-&gt;count
op_plus
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|ymf_mmap
r_static
r_int
id|ymf_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|ymf_state
op_star
id|state
op_assign
(paren
r_struct
id|ymf_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ymf_ioctl
r_static
r_int
id|ymf_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ymf_state
op_star
id|state
op_assign
(paren
r_struct
id|ymf_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ymf_dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ne
l_int|0
op_logical_and
op_logical_neg
id|state-&gt;ypcm.running
)paren
(brace
id|ymf_start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* set smaple rate */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|8000
op_logical_and
id|val
op_le
l_int|48000
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|state-&gt;format.rate
op_assign
id|val
suffix:semicolon
id|ymf_pcm_update_shift
c_func
(paren
op_amp
id|state-&gt;format
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|state-&gt;format.rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OSS manual does not mention SNDCTL_DSP_STEREO at all.&n;&t; * All channels are mono and if you want stereo, you&n;&t; * play into two channels with SNDCTL_DSP_CHANNELS.&n;&t; * However, mpg123 uses it. I wonder, why Michael Hipp uses it.&n;&t; */
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* set stereo or mono channel */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|state-&gt;format.voices
op_assign
id|val
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
id|ymf_pcm_update_shift
c_func
(paren
op_amp
id|state-&gt;format
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
multiline_comment|/* stop_adc(state); */
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|dmabuf-&gt;fmt
op_or_assign
id|CS_FMT_STEREO
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;fmt
op_and_assign
op_complement
id|CS_FMT_STEREO
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask of supported sample format*/
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Select sample format */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|AFMT_S16_LE
op_logical_or
id|val
op_eq
id|AFMT_U8
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
macro_line|#if HAVE_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|state-&gt;format.format
op_assign
id|val
suffix:semicolon
id|ymf_pcm_update_shift
c_func
(paren
op_amp
id|state-&gt;format
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|state-&gt;format.format
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;ymfpci: ioctl SNDCTL_DSP_CHANNELS 0x%x&bslash;n&quot;, val); */
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|1
op_logical_or
id|val
op_eq
l_int|2
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|state-&gt;format.voices
op_assign
id|val
suffix:semicolon
id|ymf_pcm_update_shift
c_func
(paren
op_amp
id|state-&gt;format
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
macro_line|#if HAVE_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_return
id|put_user
c_func
(paren
id|state-&gt;format.voices
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/*&n;&t;&t; * Quoting OSS PG:&n;&t;&t; *    The ioctl SNDCTL_DSP_POST is a lightweight version of&n;&t;&t; *    SNDCTL_DSP_SYNC. It just tells to the driver that there&n;&t;&t; *    is likely to be a pause in the output. This makes it&n;&t;&t; *    possible for the device to handle the pause more&n;&t;&t; *    intelligently. This ioctl doesn&squot;t block the application.&n;&t;&t; *&n;&t;&t; * The paragraph above is a clumsy way to say &quot;flush ioctl&quot;.&n;&t;&t; * This ioctl is used by mpg123.&n;&t;&t; */
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;ymfpci: ioctl SNDCTL_DSP_POST&bslash;n&quot;); */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ne
l_int|0
op_logical_and
op_logical_neg
id|state-&gt;ypcm.running
)paren
(brace
id|ymf_start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* P3: these frags are for Doom. Amasingly, it sets [2,2**11]. */
multiline_comment|/* P3 */
singleline_comment|// printk(&quot;ymfpci: ioctl SNDCTL_DSP_SETFRAGMENT 0x%x&bslash;n&quot;, val);
id|dmabuf-&gt;ossfragshift
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_switch
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
)paren
(brace
r_case
l_int|1
suffix:colon
id|dmabuf-&gt;ossfragshift
op_assign
l_int|12
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Fragments must be 2K long */
id|dmabuf-&gt;ossfragshift
op_assign
l_int|11
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* cs_update_ptr(state); */
multiline_comment|/* XXX Always up to date? */
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
macro_line|#if HAVE_RECORD
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
multiline_comment|/* return put_user(DSP_CAP_REALTIME|DSP_CAP_TRIGGER|DSP_CAP_MMAP,&n;&t;&t;&t;    (int *)arg); */
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#if 0 /* old */
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|dmabuf-&gt;enable
)paren
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dmabuf-&gt;enable
)paren
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
singleline_comment|// sure?
)brace
r_else
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if HAVE_RECORD
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
macro_line|#endif
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* cs_update_ptr(state); */
multiline_comment|/* Always up to date */
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_rshift
id|dmabuf-&gt;fragshift
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|dmabuf-&gt;count
op_and_assign
id|dmabuf-&gt;fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
multiline_comment|/* XXX TODO */
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if 0 /* old */
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;unit-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|cs_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_return
id|put_user
c_func
(paren
id|state-&gt;format.rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_return
id|put_user
c_func
(paren
id|state-&gt;format.voices
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_MAPINBUF
suffix:colon
r_case
id|SNDCTL_DSP_MAPOUTBUF
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * Some programs mix up audio devices and ioctls&n;&t;&t; * or perhaps they expect &quot;universal&quot; ioctls,&n;&t;&t; * for instance we get SNDCTL_TMR_CONTINUE here.&n;&t;&t; * XXX Is there sound_generic_ioctl() around?&n;&t;&t; */
)brace
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
DECL|function|ymf_open
r_static
r_int
id|ymf_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|ymfpci_t
op_star
id|unit
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_struct
id|ymf_state
op_star
id|state
suffix:semicolon
r_int
id|nvirt
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * This is how we do it currently: only one channel is used&n;&t; * in every board, so that we could use several boards in one machine.&n;&t; * We waste 63 out of 64 playback slots, but so what.&n;&t; * OSS model is constructed for devices with single playback channel.&n;&t; */
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0x0F
)paren
op_eq
l_int|3
)paren
(brace
multiline_comment|/* /dev/dspN */
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|nvirt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Such is the partitioning of minor */
r_for
c_loop
(paren
id|list
op_assign
id|ymf_devs.next
suffix:semicolon
id|list
op_ne
op_amp
id|ymf_devs
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
id|unit
op_assign
id|list_entry
c_func
(paren
id|list
comma
id|ymfpci_t
comma
id|ymf_devs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|unit-&gt;dev_audio
op_xor
id|minor
)paren
op_amp
op_complement
l_int|0x0F
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|ymf_devs
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|down
c_func
(paren
op_amp
id|unit-&gt;open_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit-&gt;states
(braket
id|nvirt
)braket
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
op_amp
id|unit-&gt;open_sem
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ymf_state_alloc
c_func
(paren
id|unit
comma
id|nvirt
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|unit-&gt;open_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|state
op_assign
id|unit-&gt;states
(braket
id|nvirt
)braket
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
multiline_comment|/*&n;&t; * XXX This ymf_playback_prepare is totally unneeded here.&n;&t; * The question is if we want to allow write to fail if&n;&t; * prog_dmabuf fails... Say, no memory in DMA zone?&n;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ymf_playback_prepare
c_func
(paren
id|unit
comma
id|state
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* XXX This recovery is ugly as hell. */
id|ymf_pcm_free_substream
c_func
(paren
op_amp
id|state-&gt;ypcm
)paren
suffix:semicolon
id|unit-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|unit-&gt;open_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#if 0 /* test if interrupts work */
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_TIMERCOUNT
comma
l_int|0xfffe
)paren
suffix:semicolon
multiline_comment|/* ~ 680ms */
id|ymfpci_writeb
c_func
(paren
id|codec
comma
id|YDSXGR_TIMERCTRL
comma
(paren
id|YDSXGR_TIMERCTRL_TEN
op_or
id|YDSXGR_TIMERCTRL_TIEN
)paren
)paren
suffix:semicolon
macro_line|#endif
id|up
c_func
(paren
op_amp
id|unit-&gt;open_sem
)paren
suffix:semicolon
multiline_comment|/* XXX Is it correct to have MOD_INC_USE_COUNT outside of sem.? */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ymf_release
r_static
r_int
id|ymf_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|ymf_state
op_star
id|state
op_assign
(paren
r_struct
id|ymf_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ymfpci_t
op_star
id|codec
op_assign
id|state-&gt;unit
suffix:semicolon
macro_line|#if 0 /* test if interrupts work */
id|ymfpci_writeb
c_func
(paren
id|codec
comma
id|YDSXGR_TIMERCTRL
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|state
op_ne
id|codec-&gt;states
(braket
id|state-&gt;virt
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci%d.%d: state mismatch&bslash;n&quot;
comma
id|state-&gt;unit-&gt;dev_audio
comma
id|state-&gt;virt
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|codec-&gt;open_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Solve the case of O_NONBLOCK close - don&squot;t deallocate here.&n;&t; * Deallocate when unloading the driver and we can wait.&n;&t; */
id|ymf_wait_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|ymf_pcm_free_substream
c_func
(paren
op_amp
id|state-&gt;ypcm
)paren
suffix:semicolon
id|codec-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|codec-&gt;open_sem
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Mixer operations are based on cs46xx.&n; */
DECL|function|ymf_open_mixdev
r_static
r_int
id|ymf_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|ymfpci_t
op_star
id|unit
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|ymf_devs.next
suffix:semicolon
id|list
op_ne
op_amp
id|ymf_devs
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
id|unit
op_assign
id|list_entry
c_func
(paren
id|list
comma
id|ymfpci_t
comma
id|ymf_devs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unit-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|unit-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
(brace
r_goto
id|match
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|file-&gt;private_data
op_assign
id|unit-&gt;ac97_codec
(braket
id|i
)braket
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ymf_ioctl_mixdev
r_static
r_int
id|ymf_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
(paren
r_struct
id|ac97_codec
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|codec
op_member_access_from_pointer
id|mixer_ioctl
c_func
(paren
id|codec
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|ymf_release_mixdev
r_static
r_int
id|ymf_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ymf_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|ymf_fops
op_assign
(brace
id|llseek
suffix:colon
id|ymf_llseek
comma
id|read
suffix:colon
id|ymf_read
comma
id|write
suffix:colon
id|ymf_write
comma
id|poll
suffix:colon
id|ymf_poll
comma
id|ioctl
suffix:colon
id|ymf_ioctl
comma
id|mmap
suffix:colon
id|ymf_mmap
comma
id|open
suffix:colon
id|ymf_open
comma
id|release
suffix:colon
id|ymf_release
comma
)brace
suffix:semicolon
DECL|variable|ymf_mixer_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|ymf_mixer_fops
op_assign
(brace
id|llseek
suffix:colon
id|ymf_llseek
comma
id|ioctl
suffix:colon
id|ymf_ioctl_mixdev
comma
id|open
suffix:colon
id|ymf_open_mixdev
comma
id|release
suffix:colon
id|ymf_release_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *  initialization routines&n; */
DECL|function|ymfpci_aclink_reset
r_static
r_void
id|ymfpci_aclink_reset
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci
)paren
(brace
id|u8
id|cmd
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pci
comma
id|PCIR_DSXGCTRL
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x03
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|pci
comma
id|PCIR_DSXGCTRL
comma
id|cmd
op_amp
l_int|0xfc
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pci
comma
id|PCIR_DSXGCTRL
comma
id|cmd
op_or
l_int|0x03
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pci
comma
id|PCIR_DSXGCTRL
comma
id|cmd
op_amp
l_int|0xfc
)paren
suffix:semicolon
)brace
)brace
DECL|function|ymfpci_enable_dsp
r_static
r_void
id|ymfpci_enable_dsp
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_CONFIG
comma
l_int|0x00000001
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_disable_dsp
r_static
r_void
id|ymfpci_disable_dsp
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
id|u32
id|val
suffix:semicolon
r_int
id|timeout
op_assign
l_int|1000
suffix:semicolon
id|val
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_CONFIG
comma
l_int|0x00000000
)paren
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_decrement
OG
l_int|0
)paren
(brace
id|val
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_amp
l_int|0x00000002
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#include &quot;ymfpci_image.h&quot;
DECL|function|ymfpci_download_image
r_static
r_void
id|ymfpci_download_image
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
r_int
id|i
comma
id|ver_1e
suffix:semicolon
id|u16
id|ctrl
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_NATIVEDACOUTVOL
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ymfpci_disable_dsp
c_func
(paren
id|codec
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MODE
comma
l_int|0x00010000
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MODE
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MAPOFREC
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_MAPOFEFFECT
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_PLAYCTRLBASE
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_RECCTRLBASE
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_EFFCTRLBASE
comma
l_int|0x00000000
)paren
suffix:semicolon
id|ctrl
op_assign
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|YDSXGR_GLOBALCTRL
)paren
suffix:semicolon
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_GLOBALCTRL
comma
id|ctrl
op_amp
op_complement
l_int|0x0007
)paren
suffix:semicolon
multiline_comment|/* setup DSP instruction code */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|YDSXG_DSPLENGTH
suffix:semicolon
id|i
op_increment
)paren
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_DSPINSTRAM
op_plus
id|i
comma
id|DspInst
(braket
id|i
op_rshift
l_int|2
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|codec-&gt;pci-&gt;device
)paren
(brace
r_case
id|PCI_DEVICE_ID_YAMAHA_724F
suffix:colon
r_case
id|PCI_DEVICE_ID_YAMAHA_740C
suffix:colon
r_case
id|PCI_DEVICE_ID_YAMAHA_744
suffix:colon
r_case
id|PCI_DEVICE_ID_YAMAHA_754
suffix:colon
id|ver_1e
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ver_1e
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ver_1e
)paren
(brace
multiline_comment|/* setup control instruction code */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|YDSXG_CTRLLENGTH
suffix:semicolon
id|i
op_increment
)paren
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_CTRLINSTRAM
op_plus
id|i
comma
id|CntrlInst1E
(braket
id|i
op_rshift
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|YDSXG_CTRLLENGTH
suffix:semicolon
id|i
op_increment
)paren
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_CTRLINSTRAM
op_plus
id|i
comma
id|CntrlInst
(braket
id|i
op_rshift
l_int|2
)braket
)paren
suffix:semicolon
)brace
id|ymfpci_enable_dsp
c_func
(paren
id|codec
)paren
suffix:semicolon
)brace
DECL|function|ymfpci_memalloc
r_static
r_int
id|ymfpci_memalloc
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
r_int
id|size
comma
id|playback_ctrl_size
suffix:semicolon
r_int
id|voice
comma
id|bank
suffix:semicolon
id|u8
op_star
id|ptr
suffix:semicolon
id|playback_ctrl_size
op_assign
l_int|4
op_plus
l_int|4
op_star
id|YDSXG_PLAYBACK_VOICES
suffix:semicolon
id|codec-&gt;bank_size_playback
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_PLAYCTRLSIZE
)paren
op_lshift
l_int|2
suffix:semicolon
id|codec-&gt;bank_size_capture
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_RECCTRLSIZE
)paren
op_lshift
l_int|2
suffix:semicolon
id|codec-&gt;bank_size_effect
op_assign
id|ymfpci_readl
c_func
(paren
id|codec
comma
id|YDSXGR_EFFCTRLSIZE
)paren
op_lshift
l_int|2
suffix:semicolon
id|codec-&gt;work_size
op_assign
id|YDSXG_DEFAULT_WORK_SIZE
suffix:semicolon
id|size
op_assign
(paren
(paren
id|playback_ctrl_size
op_plus
l_int|0x00ff
)paren
op_amp
op_complement
l_int|0x00ff
)paren
op_plus
(paren
(paren
id|codec-&gt;bank_size_playback
op_star
l_int|2
op_star
id|YDSXG_PLAYBACK_VOICES
op_plus
l_int|0xff
)paren
op_amp
op_complement
l_int|0xff
)paren
op_plus
(paren
(paren
id|codec-&gt;bank_size_capture
op_star
l_int|2
op_star
id|YDSXG_CAPTURE_VOICES
op_plus
l_int|0xff
)paren
op_amp
op_complement
l_int|0xff
)paren
op_plus
(paren
(paren
id|codec-&gt;bank_size_effect
op_star
l_int|2
op_star
id|YDSXG_EFFECT_VOICES
op_plus
l_int|0xff
)paren
op_amp
op_complement
l_int|0xff
)paren
op_plus
id|codec-&gt;work_size
suffix:semicolon
id|ptr
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|size
op_plus
l_int|0x00ff
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|codec-&gt;work_ptr
op_assign
id|ptr
suffix:semicolon
id|ptr
op_add_assign
l_int|0x00ff
suffix:semicolon
(paren
r_int
)paren
id|ptr
op_and_assign
op_complement
l_int|0x00ff
suffix:semicolon
id|codec-&gt;bank_base_playback
op_assign
id|ptr
suffix:semicolon
id|codec-&gt;ctrl_playback
op_assign
(paren
id|u32
op_star
)paren
id|ptr
suffix:semicolon
id|codec-&gt;ctrl_playback
(braket
l_int|0
)braket
op_assign
id|YDSXG_PLAYBACK_VOICES
suffix:semicolon
id|ptr
op_add_assign
(paren
id|playback_ctrl_size
op_plus
l_int|0x00ff
)paren
op_amp
op_complement
l_int|0x00ff
suffix:semicolon
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|YDSXG_PLAYBACK_VOICES
suffix:semicolon
id|voice
op_increment
)paren
(brace
r_for
c_loop
(paren
id|bank
op_assign
l_int|0
suffix:semicolon
id|bank
OL
l_int|2
suffix:semicolon
id|bank
op_increment
)paren
(brace
id|codec-&gt;bank_playback
(braket
id|voice
)braket
(braket
id|bank
)braket
op_assign
(paren
id|ymfpci_playback_bank_t
op_star
)paren
id|ptr
suffix:semicolon
id|ptr
op_add_assign
id|codec-&gt;bank_size_playback
suffix:semicolon
)brace
id|codec-&gt;voices
(braket
id|voice
)braket
dot
id|number
op_assign
id|voice
suffix:semicolon
id|codec-&gt;voices
(braket
id|voice
)braket
dot
id|bank
op_assign
id|codec-&gt;bank_playback
(braket
id|voice
)braket
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|ptr
op_add_assign
(paren
id|codec-&gt;bank_size_playback
op_plus
l_int|0x00ff
)paren
op_amp
op_complement
l_int|0x00ff
suffix:semicolon
id|codec-&gt;bank_base_capture
op_assign
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|YDSXG_CAPTURE_VOICES
suffix:semicolon
id|voice
op_increment
)paren
r_for
c_loop
(paren
id|bank
op_assign
l_int|0
suffix:semicolon
id|bank
OL
l_int|2
suffix:semicolon
id|bank
op_increment
)paren
(brace
id|codec-&gt;bank_capture
(braket
id|voice
)braket
(braket
id|bank
)braket
op_assign
(paren
id|ymfpci_capture_bank_t
op_star
)paren
id|ptr
suffix:semicolon
id|ptr
op_add_assign
id|codec-&gt;bank_size_capture
suffix:semicolon
)brace
id|ptr
op_add_assign
(paren
id|codec-&gt;bank_size_capture
op_plus
l_int|0x00ff
)paren
op_amp
op_complement
l_int|0x00ff
suffix:semicolon
id|codec-&gt;bank_base_effect
op_assign
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|YDSXG_EFFECT_VOICES
suffix:semicolon
id|voice
op_increment
)paren
r_for
c_loop
(paren
id|bank
op_assign
l_int|0
suffix:semicolon
id|bank
OL
l_int|2
suffix:semicolon
id|bank
op_increment
)paren
(brace
id|codec-&gt;bank_effect
(braket
id|voice
)braket
(braket
id|bank
)braket
op_assign
(paren
id|ymfpci_effect_bank_t
op_star
)paren
id|ptr
suffix:semicolon
id|ptr
op_add_assign
id|codec-&gt;bank_size_effect
suffix:semicolon
)brace
id|ptr
op_add_assign
(paren
id|codec-&gt;bank_size_effect
op_plus
l_int|0x00ff
)paren
op_amp
op_complement
l_int|0x00ff
suffix:semicolon
id|codec-&gt;work_base
op_assign
id|ptr
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_PLAYCTRLBASE
comma
id|virt_to_bus
c_func
(paren
id|codec-&gt;bank_base_playback
)paren
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_RECCTRLBASE
comma
id|virt_to_bus
c_func
(paren
id|codec-&gt;bank_base_capture
)paren
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_EFFCTRLBASE
comma
id|virt_to_bus
c_func
(paren
id|codec-&gt;bank_base_effect
)paren
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_WORKBASE
comma
id|virt_to_bus
c_func
(paren
id|codec-&gt;work_base
)paren
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_WORKSIZE
comma
id|codec-&gt;work_size
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* S/PDIF output initialization */
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_SPDIFOUTCTRL
comma
l_int|0
)paren
suffix:semicolon
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_SPDIFOUTSTATUS
comma
id|SND_PCM_AES0_CON_EMPHASIS_NONE
op_or
(paren
id|SND_PCM_AES1_CON_ORIGINAL
op_lshift
l_int|8
)paren
op_or
(paren
id|SND_PCM_AES1_CON_PCM_CODER
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* S/PDIF input initialization */
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_SPDIFINCTRL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* move this volume setup to mixer */
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_NATIVEDACOUTVOL
comma
l_int|0x3fff3fff
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_BUF441OUTVOL
comma
l_int|0x3fff3fff
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_NATIVEADCINVOL
comma
l_int|0x3fff3fff
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_NATIVEDACINVOL
comma
l_int|0x3fff3fff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ymfpci_memfree
r_static
r_void
id|ymfpci_memfree
c_func
(paren
id|ymfpci_t
op_star
id|codec
)paren
(brace
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_PLAYCTRLBASE
comma
l_int|0
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_RECCTRLBASE
comma
l_int|0
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_EFFCTRLBASE
comma
l_int|0
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_WORKBASE
comma
l_int|0
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_WORKSIZE
comma
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec-&gt;work_ptr
)paren
suffix:semicolon
)brace
DECL|function|ymf_ac97_init
r_static
r_int
id|ymf_ac97_init
c_func
(paren
id|ymfpci_t
op_star
id|card
comma
r_int
id|num_ac97
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
suffix:semicolon
id|u16
id|eid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|codec
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some basic codec information, other fields will be filled&n;&t;   in ac97_probe_codec */
id|codec-&gt;private_data
op_assign
id|card
suffix:semicolon
id|codec-&gt;id
op_assign
id|num_ac97
suffix:semicolon
id|codec-&gt;codec_read
op_assign
id|ymfpci_codec_read
suffix:semicolon
id|codec-&gt;codec_write
op_assign
id|ymfpci_codec_write
suffix:semicolon
r_if
c_cond
(paren
id|ac97_probe_codec
c_func
(paren
id|codec
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ymfpci: ac97_probe_codec failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_kfree
suffix:semicolon
)brace
id|eid
op_assign
id|ymfpci_codec_read
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
l_int|0xFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ymfpci: no codec attached ?&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_kfree
suffix:semicolon
)brace
id|card-&gt;ac97_features
op_assign
id|eid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|ymf_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_kfree
suffix:semicolon
)brace
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
id|codec
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_kfree
suffix:colon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|ymf_probe_one
r_static
r_int
id|__devinit
id|ymf_probe_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcidev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
id|u16
id|ctrl
suffix:semicolon
id|ymfpci_t
op_star
id|codec
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pcidev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci: pci_enable_device failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ymfpci_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci: no core&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|codec
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|codec
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|codec-&gt;reg_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|codec-&gt;voice_lock
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|codec-&gt;open_sem
)paren
suffix:semicolon
id|codec-&gt;pci
op_assign
id|pcidev
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pcidev
comma
id|PCI_REVISION_ID
comma
op_amp
id|codec-&gt;rev
)paren
suffix:semicolon
id|codec-&gt;reg_area_virt
op_assign
id|ioremap
c_func
(paren
id|pci_resource_start
c_func
(paren
id|pcidev
comma
l_int|0
)paren
comma
l_int|0x8000
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ymfpci: %s at 0x%lx IRQ %d&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|ent-&gt;driver_data
comma
id|pci_resource_start
c_func
(paren
id|pcidev
comma
l_int|0
)paren
comma
id|pcidev-&gt;irq
)paren
suffix:semicolon
id|ymfpci_aclink_reset
c_func
(paren
id|pcidev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ymfpci_codec_ready
c_func
(paren
id|codec
comma
l_int|0
comma
l_int|1
)paren
OL
l_int|0
)paren
r_goto
id|out_unmap
suffix:semicolon
id|ymfpci_download_image
c_func
(paren
id|codec
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* seems we need some delay after downloading image.. */
r_if
c_cond
(paren
id|ymfpci_memalloc
c_func
(paren
id|codec
)paren
OL
l_int|0
)paren
r_goto
id|out_disable_dsp
suffix:semicolon
multiline_comment|/* ymfpci_proc_init(card, codec); */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|pcidev-&gt;irq
comma
id|ymf_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;ymfpci&quot;
comma
id|codec
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci%d: unable to request IRQ %d&bslash;n&quot;
comma
id|codec-&gt;dev_audio
comma
id|pcidev-&gt;irq
)paren
suffix:semicolon
r_goto
id|out_memfree
suffix:semicolon
)brace
multiline_comment|/* register /dev/dsp */
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|ymf_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ymfpci%d: unable to register dsp&bslash;n&quot;
comma
id|codec-&gt;dev_audio
)paren
suffix:semicolon
r_goto
id|out_free_irq
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Poke just the primary for the moment.&n;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ymf_ac97_init
c_func
(paren
id|codec
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out_unregister_sound_dsp
suffix:semicolon
multiline_comment|/* put it into driver list */
id|list_add_tail
c_func
(paren
op_amp
id|codec-&gt;ymf_devs
comma
op_amp
id|ymf_devs
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pcidev
comma
id|codec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_unregister_sound_dsp
suffix:colon
id|unregister_sound_dsp
c_func
(paren
id|codec-&gt;dev_audio
)paren
suffix:semicolon
id|out_free_irq
suffix:colon
id|free_irq
c_func
(paren
id|pcidev-&gt;irq
comma
id|codec
)paren
suffix:semicolon
id|out_memfree
suffix:colon
id|ymfpci_memfree
c_func
(paren
id|codec
)paren
suffix:semicolon
id|out_disable_dsp
suffix:colon
id|ymfpci_disable_dsp
c_func
(paren
id|codec
)paren
suffix:semicolon
id|ctrl
op_assign
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|YDSXGR_GLOBALCTRL
)paren
suffix:semicolon
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_GLOBALCTRL
comma
id|ctrl
op_amp
op_complement
l_int|0x0007
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_STATUS
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|out_unmap
suffix:colon
id|iounmap
c_func
(paren
id|codec-&gt;reg_area_virt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|ymf_remove_one
r_static
r_void
id|__devexit
id|ymf_remove_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
id|__u16
id|ctrl
suffix:semicolon
id|ymfpci_t
op_star
id|codec
op_assign
id|pci_get_drvdata
c_func
(paren
id|pcidev
)paren
suffix:semicolon
multiline_comment|/* remove from list of devices */
id|list_del
c_func
(paren
op_amp
id|codec-&gt;ymf_devs
)paren
suffix:semicolon
id|unregister_sound_mixer
c_func
(paren
id|codec-&gt;ac97_codec
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec-&gt;ac97_codec
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|unregister_sound_dsp
c_func
(paren
id|codec-&gt;dev_audio
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|pcidev-&gt;irq
comma
id|codec
)paren
suffix:semicolon
id|ymfpci_memfree
c_func
(paren
id|codec
)paren
suffix:semicolon
id|ymfpci_writel
c_func
(paren
id|codec
comma
id|YDSXGR_STATUS
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|ymfpci_disable_dsp
c_func
(paren
id|codec
)paren
suffix:semicolon
id|ctrl
op_assign
id|ymfpci_readw
c_func
(paren
id|codec
comma
id|YDSXGR_GLOBALCTRL
)paren
suffix:semicolon
id|ymfpci_writew
c_func
(paren
id|codec
comma
id|YDSXGR_GLOBALCTRL
comma
id|ctrl
op_amp
op_complement
l_int|0x0007
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|codec-&gt;reg_area_virt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jaroslav Kysela&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Yamaha YMF7xx PCI Audio&quot;
)paren
suffix:semicolon
DECL|variable|ymfpci_driver
r_static
r_struct
id|pci_driver
id|ymfpci_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;ymfpci&quot;
comma
id|id_table
suffix:colon
id|ymf_id_tbl
comma
id|probe
suffix:colon
id|ymf_probe_one
comma
id|remove
suffix:colon
id|ymf_remove_one
comma
)brace
suffix:semicolon
DECL|function|ymf_init_module
r_static
r_int
id|__init
id|ymf_init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|pci_module_init
c_func
(paren
op_amp
id|ymfpci_driver
)paren
suffix:semicolon
)brace
DECL|function|ymf_cleanup_module
r_static
r_void
id|__exit
id|ymf_cleanup_module
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|ymfpci_driver
)paren
suffix:semicolon
)brace
DECL|variable|ymf_init_module
id|module_init
c_func
(paren
id|ymf_init_module
)paren
suffix:semicolon
DECL|variable|ymf_cleanup_module
id|module_exit
c_func
(paren
id|ymf_cleanup_module
)paren
suffix:semicolon
eof
