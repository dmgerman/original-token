DECL|macro|FKS_LOGGING
macro_line|#undef FKS_LOGGING
DECL|macro|FKS_TEST
macro_line|#undef FKS_TEST
multiline_comment|/*&n; * tabs should be 4 spaces, in vi(m): set tabstop=4&n; *&n; * TODO: &t;consistency speed calculations!!&n; *&t;&t;&t;cleanup!&n; * ????:&t;Did I break MIDI support?&n; *&n; * History:&n; *&n; * Rolf Fokkens&t; (Dec 20 1998):&t;ES188x recording level support on a per&n; * fokkensr@vertis.nl&t;&t;&t;input basis.&n; *&t;&t;&t;&t; (Dec 24 1998):&t;Recognition of ES1788, ES1887, ES1888,&n; *&t;&t;&t;&t;&t;&t;&t;&t;ES1868, ES1869 and ES1878. Could be used for&n; *&t;&t;&t;&t;&t;&t;&t;&t;specific handling in the future. All except&n; *&t;&t;&t;&t;&t;&t;&t;&t;ES1887 and ES1888 and ES688 are handled like&n; *&t;&t;&t;&t;&t;&t;&t;&t;ES1688.&n; *&t;&t;&t;&t; (Dec 27 1998):&t;RECLEV for all (?) ES1688+ chips. ES188x now&n; *&t;&t;&t;&t;&t;&t;&t;&t;have the &quot;Dec 20&quot; support + RECLEV&n; *&t;&t;&t;&t; (Jan  2 1999):&t;Preparation for Full Duplex. This means&n; *&t;&t;&t;&t;&t;&t;&t;&t;Audio 2 is now used for playback when dma16&n; *&t;&t;&t;&t;&t;&t;&t;&t;is specified. The next step would be to use&n; *&t;&t;&t;&t;&t;&t;&t;&t;Audio 1 and Audio 2 at the same time.&n; *&t;&t;&t;&t; (Jan  9 1999):&t;Put all ESS stuff into sb_ess.[ch], this&n; *&t;&t;&t;&t;&t;&t;&t;&t;includes both the ESS stuff that has been in&n; *&t;&t;&t;&t;&t;&t;&t;&t;sb_*[ch] before I touched it and the ESS support&n; *&t;&t;&t;&t;&t;&t;&t;&t;I added later&n; *&t;&t;&t;&t; (Jan 23 1999):&t;Full Duplex seems to work. I wrote a small&n; *&t;&t;&t;&t;&t;&t;&t;&t;test proggy which works OK. Haven&squot;t found&n; *&t;&t;&t;&t;&t;&t;&t;&t;any applications to test it though. So why did&n; *&t;&t;&t;&t;&t;&t;&t;&t;I bother to create it anyway?? :) Just for&n; *&t;&t;&t;&t;&t;&t;&t;&t;fun.&n; *&t;&t;&t;&t; (May  2 1999):&t;I tried to be too smart by &quot;introducing&quot;&n; *&t;&t;&t;&t;&t;&t;&t;&t;ess_calc_best_speed (). The idea was that two&n; *&t;&t;&t;&t;&t;&t;&t;&t;dividers could be used to setup a samplerate,&n; *&t;&t;&t;&t;&t;&t;&t;&t;ess_calc_best_speed () would choose the best.&n; *&t;&t;&t;&t;&t;&t;&t;&t;This works for playback, but results in&n; *&t;&t;&t;&t;&t;&t;&t;&t;recording problems for high samplerates. I&n; *&t;&t;&t;&t;&t;&t;&t;&t;fixed this by removing ess_calc_best_speed ()&n; *&t;&t;&t;&t;&t;&t;&t;&t;and just doing what the documentation says. &n; * Andy Sloane   (Jun  4 1999): Stole some code from ALSA to fix the playback&n; * andy@guildsoftware.com&t;&t;speed on ES1869, ES1879, ES1887, and ES1888.&n; * &t;&t;&t;&t;&t;&t;&t;&t;1879&squot;s were previously ignored by this driver;&n; * &t;&t;&t;&t;&t;&t;&t;&t;added (untested) support for those.&n; * Cvetan Ivanov (Oct 27 1999): Fixed ess_dsp_init to call ess_set_dma_hw for&n; * zezo@inet.bg&t;&t;&t;&t;&t;_ALL_ ESS models, not only ES1887&n; *&n; * This files contains ESS chip specifics. It&squot;s based on the existing ESS&n; * handling as it resided in sb_common.c, sb_mixer.c and sb_audio.c. This&n; * file adds features like:&n; * - Chip Identification (as shown in /proc/sound)&n; * - RECLEV support for ES1688 and later&n; * - 6 bits playback level support chips later than ES1688&n; * - Recording level support on a per-device basis for ES1887&n; * - Full-Duplex for ES1887&n; *&n; * Full duplex is enabled by specifying dma16. While the normal dma must&n; * be one of 0, 1 or 3, dma16 can be one of 0, 1, 3 or 5. DMA 5 is a 16 bit&n; * DMA channel, while the others are 8 bit..&n; *&n; * ESS detection isn&squot;t full proof (yet). If it fails an additional module&n; * parameter esstype can be specified to be one of the following:&n; * -1, 0, 688, 1688, 1868, 1869, 1788, 1887, 1888&n; * -1 means: mimic 2.0 behaviour, &n; *  0 means: auto detect.&n; *   others: explicitly specify chip&n; * -1 is default, cause auto detect still doesn&squot;t work.&n; */
multiline_comment|/*&n; * About the documentation&n; *&n; * I don&squot;t know if the chips all are OK, but the documentation is buggy. &squot;cause&n; * I don&squot;t have all the cips myself, there&squot;s a lot I cannot verify. I&squot;ll try to&n; * keep track of my latest insights about his here. If you have additional info,&n; * please enlighten me (fokkensr@vertis.nl)!&n; *&n; * I had the impression that ES1688 also has 6 bit master volume control. The&n; * documentation about ES1888 (rev C, october &squot;95) claims that ES1888 has&n; * the following features ES1688 doesn&squot;t have:&n; * - 6 bit master volume&n; * - Full Duplex&n; * So ES1688 apparently doesn&squot;t have 6 bit master volume control, but the&n; * ES1688 does have RECLEV control. Makes me wonder: does ES688 have it too?&n; * Without RECLEV ES688 won&squot;t be much fun I guess.&n; *&n; * From the ES1888 (rev C, october &squot;95) documentation I got the impression&n; * that registers 0x68 to 0x6e don&squot;t exist which means: no recording volume&n; * controls. To my surprise the ES888 documentation (1/14/96) claims that&n; * ES888 does have these record mixer registers, but that ES1888 doesn&squot;t have&n; * 0x69 and 0x6b. So the rest should be there.&n; *&n; * I&squot;m trying to get ES1887 Full Duplex. Audio 2 is playback only, while Audio 2&n; * is both record and playback. I think I should use Audio 2 for all playback.&n; *&n; * The documentation is an adventure: it&squot;s close but not fully accurate. I&n; * found out that after a reset some registers are *NOT* reset, though the&n; * docs say the would be. Interresting ones are 0x7f, 0x7d and 0x7a. They are&n; * related to the Audio 2 channel. I also was suprised about the consequenses&n; * of writing 0x00 to 0x7f (which should be done by reset): The ES1887 moves&n; * into ES1888 mode. This means that it claims IRQ 11, which happens to be my&n; * ISDN adapter. Needless to say it no longer worked. I now understand why&n; * after rebooting 0x7f already was 0x05, the value of my choice: the BIOS&n; * did it.&n; *&n; * Oh, and this is another trap: in ES1887 docs mixer register 0x70 is decribed&n; * as if it&squot;s exactly the same as register 0xa1. This is *NOT* true. The&n; * description of 0x70 in ES1869 docs is accurate however.&n; * Well, the assumption about ES1869 was wrong: register 0x70 is very much&n; * like register 0xa1, except that bit 7 is allways 1, whatever you want&n; * it to be.&n; *&n; * When using audio 2 mixer register 0x72 seems te be meaningless. Only 0xa2&n; * has effect.&n; *&n; * Software reset not being able to reset all registers is great! Especially&n; * the fact that register 0x78 isn&squot;t reset is great when you wanna change back&n; * to single dma operation (simplex): audio 2 is still operation, and uses the&n; * same dma as audio 1: your ess changes into a funny echo machine.&n; *&n; * Received the new that ES1688 is detected as a ES1788. Did some thinking:&n; * the ES1887 detection scheme suggests in step 2 to try if bit 3 of register&n; * 0x64 can be changed. This is inaccurate, first I inverted the * check: &quot;If&n; * can be modified, it&squot;s a 1688&quot;, which lead to a correct detection&n; * of my ES1887. It resulted however in bad detection of 1688 (reported by mail)&n; * and 1868 (if no PnP detection first): they result in a 1788 being detected.&n; * I don&squot;t have docs on 1688, but I do have docs on 1868: The documentation is&n; * probably inaccurate in the fact that I should check bit 2, not bit 3. This&n; * is what I do now.&n; */
multiline_comment|/*&n; * About recognition of ESS chips&n; *&n; * The distinction of ES688, ES1688, ES1788, ES1887 and ES1888 is described in&n; * a (preliminary ??) datasheet on ES1887. It&squot;s aim is to identify ES1887, but&n; * during detection the text claims that &quot;this chip may be ...&quot; when a step&n; * fails. This scheme is used to distinct between the above chips.&n; * It appears however that some PnP chips like ES1868 are recognized as ES1788&n; * by the ES1887 detection scheme. These PnP chips can be detected in another&n; * way however: ES1868, ES1869 and ES1878 can be recognized (full proof I think)&n; * by repeatedly reading mixer register 0x40. This is done by ess_identify in&n; * sb_common.c.&n; * This results in the following detection steps:&n; * - distinct between ES688 and ES1688+ (as always done in this driver)&n; *   if ES688 we&squot;re ready&n; * - try to detect ES1868, ES1869 or ES1878&n; *   if successful we&squot;re ready&n; * - try to detect ES1888, ES1887 or ES1788&n; *   if successful we&squot;re ready&n; * - Dunno. Must be 1688. Will do in general&n; *&n; * About RECLEV support:&n; *&n; * The existing ES1688 support didn&squot;t take care of the ES1688+ recording&n; * levels very well. Whenever a device was selected (recmask) for recording&n; * it&squot;s recording level was loud, and it couldn&squot;t be changed. The fact that&n; * internal register 0xb4 could take care of RECLEV, didn&squot;t work meaning until&n; * it&squot;s value was restored every time the chip was reset; this reset the&n; * value of 0xb4 too. I guess that&squot;s what 4front also had (have?) trouble with.&n; *&n; * About ES1887 support:&n; *&n; * The ES1887 has separate registers to control the recording levels, for all&n; * inputs. The ES1887 specific software makes these levels the same as their&n; * corresponding playback levels, unless recmask says they aren&squot;t recorded. In&n; * the latter case the recording volumes are 0.&n; * Now recording levels of inputs can be controlled, by changing the playback&n; * levels. Futhermore several devices can be recorded together (which is not&n; * possible with the ES1688.&n; * Besides the separate recording level control for each input, the common&n; * recordig level can also be controlled by RECLEV as described above.&n; *&n; * Not only ES1887 have this recording mixer. I know the following from the&n; * documentation:&n; * ES688&t;no&n; * ES1688&t;no&n; * ES1868&t;no&n; * ES1869&t;yes&n; * ES1878&t;no&n; * ES1879&t;yes&n; * ES1888&t;no/yes&t;Contradicting documentation; most recent: yes&n; * ES1946&t;yes&t;&t;This is a PCI chip; not handled by this driver&n; */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &quot;sound_config.h&quot;
macro_line|#include &quot;sb_mixer.h&quot;
macro_line|#include &quot;sb.h&quot;
macro_line|#include &quot;sb_ess.h&quot;
DECL|macro|ESSTYPE_LIKE20
mdefine_line|#define ESSTYPE_LIKE20&t;-1&t;&t;/* Mimic 2.0 behaviour&t;&t;&t;&t;&t;*/
DECL|macro|ESSTYPE_DETECT
mdefine_line|#define ESSTYPE_DETECT&t;0&t;&t;/* Mimic 2.0 behaviour&t;&t;&t;&t;&t;*/
DECL|macro|SUBMDL_ES1788
mdefine_line|#define SUBMDL_ES1788&t;0x10&t;/* Subtype ES1788 for specific handling */
DECL|macro|SUBMDL_ES1868
mdefine_line|#define SUBMDL_ES1868&t;0x11&t;/* Subtype ES1868 for specific handling */
DECL|macro|SUBMDL_ES1869
mdefine_line|#define SUBMDL_ES1869&t;0x12&t;/* Subtype ES1869 for specific handling */
DECL|macro|SUBMDL_ES1878
mdefine_line|#define SUBMDL_ES1878&t;0x13&t;/* Subtype ES1878 for specific handling */
DECL|macro|SUBMDL_ES1879
mdefine_line|#define SUBMDL_ES1879&t;0x16    /* ES1879 was initially forgotten */
DECL|macro|SUBMDL_ES1887
mdefine_line|#define SUBMDL_ES1887&t;0x14&t;/* Subtype ES1887 for specific handling */
DECL|macro|SUBMDL_ES1888
mdefine_line|#define SUBMDL_ES1888&t;0x15&t;/* Subtype ES1888 for specific handling */
DECL|macro|SB_CAP_ES18XX_RATE
mdefine_line|#define SB_CAP_ES18XX_RATE 0x100
DECL|macro|ES1688_CLOCK1
mdefine_line|#define ES1688_CLOCK1 795444 /* 128 - div */
DECL|macro|ES1688_CLOCK2
mdefine_line|#define ES1688_CLOCK2 397722 /* 256 - div */
DECL|macro|ES18XX_CLOCK1
mdefine_line|#define ES18XX_CLOCK1 793800 /* 128 - div */
DECL|macro|ES18XX_CLOCK2
mdefine_line|#define ES18XX_CLOCK2 768000 /* 256 - div */
macro_line|#ifdef FKS_LOGGING
r_static
r_void
id|ess_show_mixerregs
(paren
id|sb_devc
op_star
id|devc
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ess_read
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_char
id|reg
)paren
suffix:semicolon
r_static
r_int
id|ess_write
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|data
)paren
suffix:semicolon
r_static
r_void
id|ess_chgmixer
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|val
)paren
suffix:semicolon
multiline_comment|/****************************************************************************&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;ESS audio&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; ****************************************************************************/
DECL|struct|ess_command
DECL|member|cmd
DECL|member|data
r_struct
id|ess_command
(brace
r_int
id|cmd
suffix:semicolon
r_int
id|data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Commands for initializing Audio 1 for input (record)&n; */
DECL|variable|ess_i08m
r_static
r_struct
id|ess_command
id|ess_i08m
(braket
)braket
op_assign
multiline_comment|/* input 8 bit mono */
(brace
(brace
l_int|0xb7
comma
l_int|0x51
)brace
comma
(brace
l_int|0xb7
comma
l_int|0xd0
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_i16m
r_static
r_struct
id|ess_command
id|ess_i16m
(braket
)braket
op_assign
multiline_comment|/* input 16 bit mono */
(brace
(brace
l_int|0xb7
comma
l_int|0x71
)brace
comma
(brace
l_int|0xb7
comma
l_int|0xf4
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_i08s
r_static
r_struct
id|ess_command
id|ess_i08s
(braket
)braket
op_assign
multiline_comment|/* input 8 bit stereo */
(brace
(brace
l_int|0xb7
comma
l_int|0x51
)brace
comma
(brace
l_int|0xb7
comma
l_int|0x98
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_i16s
r_static
r_struct
id|ess_command
id|ess_i16s
(braket
)braket
op_assign
multiline_comment|/* input 16 bit stereo */
(brace
(brace
l_int|0xb7
comma
l_int|0x71
)brace
comma
(brace
l_int|0xb7
comma
l_int|0xbc
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_inp_cmds
r_static
r_struct
id|ess_command
op_star
id|ess_inp_cmds
(braket
)braket
op_assign
(brace
id|ess_i08m
comma
id|ess_i16m
comma
id|ess_i08s
comma
id|ess_i16s
)brace
suffix:semicolon
multiline_comment|/*&n; * Commands for initializing Audio 1 for output (playback)&n; */
DECL|variable|ess_o08m
r_static
r_struct
id|ess_command
id|ess_o08m
(braket
)braket
op_assign
multiline_comment|/* output 8 bit mono */
(brace
(brace
l_int|0xb6
comma
l_int|0x80
)brace
comma
(brace
l_int|0xb7
comma
l_int|0x51
)brace
comma
(brace
l_int|0xb7
comma
l_int|0xd0
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_o16m
r_static
r_struct
id|ess_command
id|ess_o16m
(braket
)braket
op_assign
multiline_comment|/* output 16 bit mono */
(brace
(brace
l_int|0xb6
comma
l_int|0x00
)brace
comma
(brace
l_int|0xb7
comma
l_int|0x71
)brace
comma
(brace
l_int|0xb7
comma
l_int|0xf4
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_o08s
r_static
r_struct
id|ess_command
id|ess_o08s
(braket
)braket
op_assign
multiline_comment|/* output 8 bit stereo */
(brace
(brace
l_int|0xb6
comma
l_int|0x80
)brace
comma
(brace
l_int|0xb7
comma
l_int|0x51
)brace
comma
(brace
l_int|0xb7
comma
l_int|0x98
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_o16s
r_static
r_struct
id|ess_command
id|ess_o16s
(braket
)braket
op_assign
multiline_comment|/* output 16 bit stereo */
(brace
(brace
l_int|0xb6
comma
l_int|0x00
)brace
comma
(brace
l_int|0xb7
comma
l_int|0x71
)brace
comma
(brace
l_int|0xb7
comma
l_int|0xbc
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ess_out_cmds
r_static
r_struct
id|ess_command
op_star
id|ess_out_cmds
(braket
)braket
op_assign
(brace
id|ess_o08m
comma
id|ess_o16m
comma
id|ess_o08s
comma
id|ess_o16s
)brace
suffix:semicolon
DECL|function|ess_exec_commands
r_static
r_void
id|ess_exec_commands
(paren
id|sb_devc
op_star
id|devc
comma
r_struct
id|ess_command
op_star
id|cmdtab
(braket
)braket
)paren
(brace
r_struct
id|ess_command
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|cmdtab
(braket
(paren
(paren
id|devc-&gt;channels
op_ne
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
(paren
id|devc-&gt;bits
op_ne
id|AFMT_U8
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cmd-&gt;cmd
op_ne
op_minus
l_int|1
)paren
(brace
id|ess_write
(paren
id|devc
comma
id|cmd-&gt;cmd
comma
id|cmd-&gt;data
)paren
suffix:semicolon
id|cmd
op_increment
suffix:semicolon
)brace
)brace
DECL|function|ess_change
r_static
r_void
id|ess_change
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|val
)paren
(brace
r_int
id|value
suffix:semicolon
id|value
op_assign
id|ess_read
(paren
id|devc
comma
id|reg
)paren
suffix:semicolon
id|value
op_assign
(paren
id|value
op_amp
op_complement
id|mask
)paren
op_or
(paren
id|val
op_amp
id|mask
)paren
suffix:semicolon
id|ess_write
(paren
id|devc
comma
id|reg
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|ess_set_output_parms
r_static
r_void
id|ess_set_output_parms
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|nr_bytes
comma
r_int
id|intrflag
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
id|devc-&gt;trg_buf_16
op_assign
id|buf
suffix:semicolon
id|devc-&gt;trg_bytes_16
op_assign
id|nr_bytes
suffix:semicolon
id|devc-&gt;trg_intrflag_16
op_assign
id|intrflag
suffix:semicolon
id|devc-&gt;irq_mode_16
op_assign
id|IMODE_OUTPUT
suffix:semicolon
)brace
r_else
(brace
id|devc-&gt;trg_buf
op_assign
id|buf
suffix:semicolon
id|devc-&gt;trg_bytes
op_assign
id|nr_bytes
suffix:semicolon
id|devc-&gt;trg_intrflag
op_assign
id|intrflag
suffix:semicolon
id|devc-&gt;irq_mode
op_assign
id|IMODE_OUTPUT
suffix:semicolon
)brace
)brace
DECL|function|ess_set_input_parms
r_static
r_void
id|ess_set_input_parms
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|count
comma
r_int
id|intrflag
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|devc-&gt;trg_buf
op_assign
id|buf
suffix:semicolon
id|devc-&gt;trg_bytes
op_assign
id|count
suffix:semicolon
id|devc-&gt;trg_intrflag
op_assign
id|intrflag
suffix:semicolon
id|devc-&gt;irq_mode
op_assign
id|IMODE_INPUT
suffix:semicolon
)brace
DECL|function|ess_calc_div
r_static
r_int
id|ess_calc_div
(paren
r_int
id|clock
comma
r_int
id|revert
comma
r_int
op_star
id|speedp
comma
r_int
op_star
id|diffp
)paren
(brace
r_int
id|divider
suffix:semicolon
r_int
id|speed
comma
id|diff
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|speed
op_assign
op_star
id|speedp
suffix:semicolon
id|divider
op_assign
(paren
id|clock
op_plus
id|speed
op_div
l_int|2
)paren
op_div
id|speed
suffix:semicolon
id|retval
op_assign
id|revert
op_minus
id|divider
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
id|revert
op_minus
l_int|1
)paren
(brace
id|retval
op_assign
id|revert
op_minus
l_int|1
suffix:semicolon
id|divider
op_assign
id|revert
op_minus
id|retval
suffix:semicolon
)brace
multiline_comment|/* This line is suggested. Must be wrong I think&n;&t;*speedp = (clock + divider / 2) / divider;&n;&t;So I chose the next one */
op_star
id|speedp
op_assign
id|clock
op_div
id|divider
suffix:semicolon
id|diff
op_assign
id|speed
op_minus
op_star
id|speedp
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
id|diff
op_assign
op_minus
id|diff
suffix:semicolon
op_star
id|diffp
op_assign
id|diff
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|ess_calc_best_speed
r_static
r_int
id|ess_calc_best_speed
(paren
r_int
id|clock1
comma
r_int
id|rev1
comma
r_int
id|clock2
comma
r_int
id|rev2
comma
r_int
op_star
id|divp
comma
r_int
op_star
id|speedp
)paren
(brace
r_int
id|speed1
op_assign
op_star
id|speedp
comma
id|speed2
op_assign
op_star
id|speedp
suffix:semicolon
r_int
id|div1
comma
id|div2
suffix:semicolon
r_int
id|diff1
comma
id|diff2
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|div1
op_assign
id|ess_calc_div
(paren
id|clock1
comma
id|rev1
comma
op_amp
id|speed1
comma
op_amp
id|diff1
)paren
suffix:semicolon
id|div2
op_assign
id|ess_calc_div
(paren
id|clock2
comma
id|rev2
comma
op_amp
id|speed2
comma
op_amp
id|diff2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff1
OL
id|diff2
)paren
(brace
op_star
id|divp
op_assign
id|div1
suffix:semicolon
op_star
id|speedp
op_assign
id|speed1
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|divp
op_assign
id|div2
suffix:semicolon
op_star
id|speedp
op_assign
id|speed2
suffix:semicolon
id|retval
op_assign
l_int|2
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Depending on the audiochannel ESS devices can&n; * have different clock settings. These are made consistent for duplex&n; * however.&n; * callers of ess_speed only do an audionum suggestion, which means&n; * input suggests 1, output suggests 2. This suggestion is only true&n; * however when doing duplex.&n; */
DECL|function|ess_common_speed
r_static
r_void
id|ess_common_speed
(paren
id|sb_devc
op_star
id|devc
comma
r_int
op_star
id|speedp
comma
r_int
op_star
id|divp
)paren
(brace
r_int
id|diff
op_assign
l_int|0
comma
id|div
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
multiline_comment|/*&n;&t;&t; * The 0x80 is important for the first audio channel&n;&t;&t; */
id|div
op_assign
l_int|0x80
op_or
id|ess_calc_div
(paren
l_int|795500
comma
l_int|128
comma
id|speedp
comma
op_amp
id|diff
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|devc-&gt;caps
op_amp
id|SB_CAP_ES18XX_RATE
)paren
(brace
id|ess_calc_best_speed
c_func
(paren
id|ES18XX_CLOCK1
comma
l_int|128
comma
id|ES18XX_CLOCK2
comma
l_int|256
comma
op_amp
id|div
comma
id|speedp
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|speedp
OG
l_int|22000
)paren
(brace
id|div
op_assign
l_int|0x80
op_or
id|ess_calc_div
(paren
id|ES1688_CLOCK1
comma
l_int|256
comma
id|speedp
comma
op_amp
id|diff
)paren
suffix:semicolon
)brace
r_else
(brace
id|div
op_assign
l_int|0x00
op_or
id|ess_calc_div
(paren
id|ES1688_CLOCK2
comma
l_int|128
comma
id|speedp
comma
op_amp
id|diff
)paren
suffix:semicolon
)brace
)brace
op_star
id|divp
op_assign
id|div
suffix:semicolon
)brace
DECL|function|ess_speed
r_static
r_void
id|ess_speed
(paren
id|sb_devc
op_star
id|devc
comma
r_int
id|audionum
)paren
(brace
r_int
id|speed
suffix:semicolon
r_int
id|div
comma
id|div2
suffix:semicolon
id|ess_common_speed
(paren
id|devc
comma
op_amp
(paren
id|devc-&gt;speed
)paren
comma
op_amp
id|div
)paren
suffix:semicolon
macro_line|#ifdef FKS_REG_LOGGING
id|printk
(paren
id|KERN_INFO
l_string|&quot;FKS: ess_speed (%d) b speed = %d, div=%x&bslash;n&quot;
comma
id|audionum
comma
id|devc-&gt;speed
comma
id|div
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set filter roll-off to 90% of speed/2 */
id|speed
op_assign
(paren
id|devc-&gt;speed
op_star
l_int|9
)paren
op_div
l_int|20
suffix:semicolon
id|div2
op_assign
l_int|256
op_minus
l_int|7160000
op_div
(paren
id|speed
op_star
l_int|82
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devc-&gt;duplex
)paren
id|audionum
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|audionum
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Change behaviour of register A1 *&n;&t;&t;sb_chg_mixer(devc, 0x71, 0x20, 0x20)&n;&t;&t;* For ES1869 only??? */
id|ess_write
(paren
id|devc
comma
l_int|0xa1
comma
id|div
)paren
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xa2
comma
id|div2
)paren
suffix:semicolon
)brace
r_else
(brace
id|ess_setmixer
(paren
id|devc
comma
l_int|0x70
comma
id|div
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FKS: fascinating: 0x72 doesn&squot;t seem to work.&n;&t;&t; */
id|ess_write
(paren
id|devc
comma
l_int|0xa2
comma
id|div2
)paren
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x72
comma
id|div2
)paren
suffix:semicolon
)brace
)brace
DECL|function|ess_audio_prepare_for_input
r_static
r_int
id|ess_audio_prepare_for_input
c_func
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|ess_speed
c_func
(paren
id|devc
comma
l_int|1
)paren
suffix:semicolon
id|sb_dsp_command
c_func
(paren
id|devc
comma
id|DSP_CMD_SPKOFF
)paren
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xb8
comma
l_int|0x0e
)paren
suffix:semicolon
multiline_comment|/* Auto init DMA mode */
id|ess_change
(paren
id|devc
comma
l_int|0xa8
comma
l_int|0x03
comma
l_int|3
op_minus
id|devc-&gt;channels
)paren
suffix:semicolon
multiline_comment|/* Mono/stereo */
id|ess_write
(paren
id|devc
comma
l_int|0xb9
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Demand mode (4 bytes/DMA request) */
id|ess_exec_commands
(paren
id|devc
comma
id|ess_inp_cmds
)paren
suffix:semicolon
id|ess_change
(paren
id|devc
comma
l_int|0xb1
comma
l_int|0xf0
comma
l_int|0x50
)paren
suffix:semicolon
id|ess_change
(paren
id|devc
comma
l_int|0xb2
comma
l_int|0xf0
comma
l_int|0x50
)paren
suffix:semicolon
id|devc-&gt;trigger_bits
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ess_audio_prepare_for_output_audio1
r_static
r_int
id|ess_audio_prepare_for_output_audio1
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|sb_dsp_reset
c_func
(paren
id|devc
)paren
suffix:semicolon
id|ess_speed
c_func
(paren
id|devc
comma
l_int|1
)paren
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xb8
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Auto init DMA mode */
id|ess_change
(paren
id|devc
comma
l_int|0xa8
comma
l_int|0x03
comma
l_int|3
op_minus
id|devc-&gt;channels
)paren
suffix:semicolon
multiline_comment|/* Mono/stereo */
id|ess_write
(paren
id|devc
comma
l_int|0xb9
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Demand mode (4 bytes/request) */
id|ess_exec_commands
(paren
id|devc
comma
id|ess_out_cmds
)paren
suffix:semicolon
id|ess_change
(paren
id|devc
comma
l_int|0xb1
comma
l_int|0xf0
comma
l_int|0x50
)paren
suffix:semicolon
multiline_comment|/* Enable DMA */
id|ess_change
(paren
id|devc
comma
l_int|0xb2
comma
l_int|0xf0
comma
l_int|0x50
)paren
suffix:semicolon
multiline_comment|/* Enable IRQ */
id|sb_dsp_command
c_func
(paren
id|devc
comma
id|DSP_CMD_SPKON
)paren
suffix:semicolon
multiline_comment|/* There be sound! */
id|devc-&gt;trigger_bits
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ess_audio_prepare_for_output_audio2
r_static
r_int
id|ess_audio_prepare_for_output_audio2
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_int
r_char
id|bits
suffix:semicolon
multiline_comment|/* FKS: qqq&n;&t;sb_dsp_reset(devc);&n;*/
multiline_comment|/*&n;&t; * Auto-Initialize:&n;&t; * DMA mode + demand mode (8 bytes/request, yes I want it all!)&n;&t; * But leave 16-bit DMA bit untouched!&n;&t; */
id|ess_chgmixer
(paren
id|devc
comma
l_int|0x78
comma
l_int|0xd0
comma
l_int|0xd0
)paren
suffix:semicolon
id|ess_speed
c_func
(paren
id|devc
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* bits 4:3 on ES1887 represent recording source. Keep them! */
id|bits
op_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x7a
)paren
op_amp
l_int|0x18
suffix:semicolon
multiline_comment|/* Set stereo/mono */
r_if
c_cond
(paren
id|devc-&gt;channels
op_ne
l_int|1
)paren
id|bits
op_or_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* Init DACs; UNSIGNED mode for 8 bit; SIGNED mode for 16 bit */
r_if
c_cond
(paren
id|devc-&gt;bits
op_ne
id|AFMT_U8
)paren
id|bits
op_or_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* 16 bit */
multiline_comment|/* Enable DMA, IRQ will be shared (hopefully)*/
id|bits
op_or_assign
l_int|0x60
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x7a
comma
id|bits
)paren
suffix:semicolon
id|ess_mixer_reload
(paren
id|devc
comma
id|SOUND_MIXER_PCM
)paren
suffix:semicolon
multiline_comment|/* There be sound! */
id|devc-&gt;trigger_bits
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ess_audio_prepare_for_output
r_static
r_int
id|ess_audio_prepare_for_output
c_func
(paren
r_int
id|dev
comma
r_int
id|bsize
comma
r_int
id|bcount
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
macro_line|#ifdef FKS_REG_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ess_audio_prepare_for_output: dma_out=%d,dma_in=%d&bslash;n&quot;
comma
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
comma
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_in-&gt;dma
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
r_return
id|ess_audio_prepare_for_output_audio2
(paren
id|dev
comma
id|bsize
comma
id|bcount
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|ess_audio_prepare_for_output_audio1
(paren
id|dev
comma
id|bsize
comma
id|bcount
)paren
suffix:semicolon
)brace
)brace
DECL|function|ess_audio_halt_xfer
r_static
r_void
id|ess_audio_halt_xfer
c_func
(paren
r_int
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sb_dsp_reset
c_func
(paren
id|devc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Audio 2 may still be operational! Creates awful sounds!&n;&t; */
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
id|ess_chgmixer
c_func
(paren
id|devc
comma
l_int|0x78
comma
l_int|0x03
comma
l_int|0x00
)paren
suffix:semicolon
)brace
DECL|function|ess_audio_start_input
r_static
r_void
id|ess_audio_start_input
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|nr_bytes
comma
r_int
id|intrflag
)paren
(brace
r_int
id|count
op_assign
id|nr_bytes
suffix:semicolon
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_int
id|c
op_assign
op_minus
id|nr_bytes
suffix:semicolon
multiline_comment|/*&n;&t; * Start a DMA input to the buffer pointed by dmaqtail&n;&t; */
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_in-&gt;dma
OG
l_int|3
)paren
id|count
op_rshift_assign
l_int|1
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|devc-&gt;irq_mode
op_assign
id|IMODE_INPUT
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xa4
comma
(paren
r_int
r_char
)paren
(paren
(paren
r_int
r_int
)paren
id|c
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xa5
comma
(paren
r_int
r_char
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|c
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ess_change
(paren
id|devc
comma
l_int|0xb8
comma
l_int|0x0f
comma
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* Go */
id|devc-&gt;intr_active
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|ess_audio_output_block_audio1
r_static
r_void
id|ess_audio_output_block_audio1
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|nr_bytes
comma
r_int
id|intrflag
)paren
(brace
r_int
id|count
op_assign
id|nr_bytes
suffix:semicolon
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_int
id|c
op_assign
op_minus
id|nr_bytes
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
OG
l_int|3
)paren
id|count
op_rshift_assign
l_int|1
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|devc-&gt;irq_mode
op_assign
id|IMODE_OUTPUT
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xa4
comma
(paren
r_int
r_char
)paren
(paren
(paren
r_int
r_int
)paren
id|c
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ess_write
(paren
id|devc
comma
l_int|0xa5
comma
(paren
r_int
r_char
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|c
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ess_change
(paren
id|devc
comma
l_int|0xb8
comma
l_int|0x05
comma
l_int|0x05
)paren
suffix:semicolon
multiline_comment|/* Go */
id|devc-&gt;intr_active
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|ess_audio_output_block_audio2
r_static
r_void
id|ess_audio_output_block_audio2
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|nr_bytes
comma
r_int
id|intrflag
)paren
(brace
r_int
id|count
op_assign
id|nr_bytes
suffix:semicolon
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_int
id|c
op_assign
op_minus
id|nr_bytes
suffix:semicolon
r_if
c_cond
(paren
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|dmap_out-&gt;dma
OG
l_int|3
)paren
id|count
op_rshift_assign
l_int|1
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x74
comma
(paren
r_int
r_char
)paren
(paren
(paren
r_int
r_int
)paren
id|c
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x76
comma
(paren
r_int
r_char
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|c
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ess_chgmixer
(paren
id|devc
comma
l_int|0x78
comma
l_int|0x03
comma
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Go */
id|devc-&gt;irq_mode_16
op_assign
id|IMODE_OUTPUT
suffix:semicolon
id|devc-&gt;intr_active_16
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|ess_audio_output_block
r_static
r_void
id|ess_audio_output_block
(paren
r_int
id|dev
comma
r_int
r_int
id|buf
comma
r_int
id|nr_bytes
comma
r_int
id|intrflag
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
id|ess_audio_output_block_audio2
(paren
id|dev
comma
id|buf
comma
id|nr_bytes
comma
id|intrflag
)paren
suffix:semicolon
)brace
r_else
(brace
id|ess_audio_output_block_audio1
(paren
id|dev
comma
id|buf
comma
id|nr_bytes
comma
id|intrflag
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * FKS: the if-statements for both bits and bits_16 are quite alike.&n; * Combine this...&n; */
DECL|function|ess_audio_trigger
r_static
r_void
id|ess_audio_trigger
c_func
(paren
r_int
id|dev
comma
r_int
id|bits
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_int
id|bits_16
op_assign
id|bits
op_amp
id|devc-&gt;irq_mode_16
suffix:semicolon
id|bits
op_and_assign
id|devc-&gt;irq_mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bits
op_logical_and
op_logical_neg
id|bits_16
)paren
(brace
multiline_comment|/* FKS oh oh.... wrong?? for dma 16? */
id|sb_dsp_command
c_func
(paren
id|devc
comma
l_int|0xd0
)paren
suffix:semicolon
multiline_comment|/* Halt DMA */
)brace
r_if
c_cond
(paren
id|bits
)paren
(brace
r_switch
c_cond
(paren
id|devc-&gt;irq_mode
)paren
(brace
r_case
id|IMODE_INPUT
suffix:colon
id|ess_audio_start_input
c_func
(paren
id|dev
comma
id|devc-&gt;trg_buf
comma
id|devc-&gt;trg_bytes
comma
id|devc-&gt;trg_intrflag
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMODE_OUTPUT
suffix:colon
id|ess_audio_output_block
c_func
(paren
id|dev
comma
id|devc-&gt;trg_buf
comma
id|devc-&gt;trg_bytes
comma
id|devc-&gt;trg_intrflag
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bits_16
)paren
(brace
r_switch
c_cond
(paren
id|devc-&gt;irq_mode_16
)paren
(brace
r_case
id|IMODE_INPUT
suffix:colon
id|ess_audio_start_input
c_func
(paren
id|dev
comma
id|devc-&gt;trg_buf_16
comma
id|devc-&gt;trg_bytes_16
comma
id|devc-&gt;trg_intrflag_16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMODE_OUTPUT
suffix:colon
id|ess_audio_output_block
c_func
(paren
id|dev
comma
id|devc-&gt;trg_buf_16
comma
id|devc-&gt;trg_bytes_16
comma
id|devc-&gt;trg_intrflag_16
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|devc-&gt;trigger_bits
op_assign
id|bits
op_or
id|bits_16
suffix:semicolon
)brace
DECL|function|ess_audio_set_speed
r_static
r_int
id|ess_audio_set_speed
c_func
(paren
r_int
id|dev
comma
r_int
id|speed
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_int
id|minspeed
comma
id|maxspeed
comma
id|dummydiv
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
l_int|0
)paren
(brace
id|minspeed
op_assign
(paren
id|devc-&gt;duplex
ques
c_cond
l_int|6215
suffix:colon
l_int|5000
)paren
suffix:semicolon
id|maxspeed
op_assign
(paren
id|devc-&gt;duplex
ques
c_cond
l_int|44100
suffix:colon
l_int|48000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|speed
OL
id|minspeed
)paren
id|speed
op_assign
id|minspeed
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
id|maxspeed
)paren
id|speed
op_assign
id|maxspeed
suffix:semicolon
id|ess_common_speed
(paren
id|devc
comma
op_amp
id|speed
comma
op_amp
id|dummydiv
)paren
suffix:semicolon
id|devc-&gt;speed
op_assign
id|speed
suffix:semicolon
)brace
r_return
id|devc-&gt;speed
suffix:semicolon
)brace
multiline_comment|/*&n; * FKS: This is a one-on-one copy of sb1_audio_set_bits&n; */
DECL|function|ess_audio_set_bits
r_static
r_int
r_int
id|ess_audio_set_bits
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|bits
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bits
op_eq
id|AFMT_U8
op_logical_or
id|bits
op_eq
id|AFMT_S16_LE
)paren
(brace
id|devc-&gt;bits
op_assign
id|bits
suffix:semicolon
)brace
r_else
(brace
id|devc-&gt;bits
op_assign
id|AFMT_U8
suffix:semicolon
)brace
)brace
r_return
id|devc-&gt;bits
suffix:semicolon
)brace
multiline_comment|/*&n; * FKS: This is a one-on-one copy of sbpro_audio_set_channels&n; * (*) Modified it!!&n; */
DECL|function|ess_audio_set_channels
r_static
r_int
id|ess_audio_set_channels
c_func
(paren
r_int
id|dev
comma
r_int
id|channels
)paren
(brace
id|sb_devc
op_star
id|devc
op_assign
id|audio_devs
(braket
id|dev
)braket
op_member_access_from_pointer
id|devc
suffix:semicolon
r_if
c_cond
(paren
id|channels
op_eq
l_int|1
op_logical_or
id|channels
op_eq
l_int|2
)paren
id|devc-&gt;channels
op_assign
id|channels
suffix:semicolon
r_return
id|devc-&gt;channels
suffix:semicolon
)brace
DECL|variable|ess_audio_driver
r_static
r_struct
id|audio_driver
id|ess_audio_driver
op_assign
multiline_comment|/* ESS ES688/1688 */
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|sb_audio_open
comma
id|close
suffix:colon
id|sb_audio_close
comma
id|output_block
suffix:colon
id|ess_set_output_parms
comma
id|start_input
suffix:colon
id|ess_set_input_parms
comma
id|prepare_for_input
suffix:colon
id|ess_audio_prepare_for_input
comma
id|prepare_for_output
suffix:colon
id|ess_audio_prepare_for_output
comma
id|halt_io
suffix:colon
id|ess_audio_halt_xfer
comma
id|trigger
suffix:colon
id|ess_audio_trigger
comma
id|set_speed
suffix:colon
id|ess_audio_set_speed
comma
id|set_bits
suffix:colon
id|ess_audio_set_bits
comma
id|set_channels
suffix:colon
id|ess_audio_set_channels
)brace
suffix:semicolon
multiline_comment|/*&n; * ess_audio_init must be called from sb_audio_init&n; */
DECL|function|ess_audio_init
r_struct
id|audio_driver
op_star
id|ess_audio_init
(paren
id|sb_devc
op_star
id|devc
comma
r_int
op_star
id|audio_flags
comma
r_int
op_star
id|format_mask
)paren
(brace
op_star
id|audio_flags
op_assign
id|DMA_AUTOMODE
suffix:semicolon
op_star
id|format_mask
op_or_assign
id|AFMT_S16_LE
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
r_int
id|tmp_dma
suffix:semicolon
multiline_comment|/*&n;&t;&t; * sb_audio_init thinks dma8 is for playback and&n;&t;&t; * dma16 is for record. Not now! So swap them.&n;&t;&t; */
id|tmp_dma
op_assign
id|devc-&gt;dma16
suffix:semicolon
id|devc-&gt;dma16
op_assign
id|devc-&gt;dma8
suffix:semicolon
id|devc-&gt;dma8
op_assign
id|tmp_dma
suffix:semicolon
op_star
id|audio_flags
op_or_assign
id|DMA_DUPLEX
suffix:semicolon
)brace
r_return
op_amp
id|ess_audio_driver
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;ESS common&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; ****************************************************************************/
DECL|function|ess_handle_channel
r_static
r_void
id|ess_handle_channel
(paren
r_char
op_star
id|channel
comma
r_int
id|dev
comma
r_int
id|intr_active
comma
r_int
r_char
id|flag
comma
r_int
id|irq_mode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|intr_active
op_logical_or
op_logical_neg
id|flag
)paren
r_return
suffix:semicolon
macro_line|#ifdef FKS_REG_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FKS: ess_handle_channel %s irq_mode=%d&bslash;n&quot;
comma
id|channel
comma
id|irq_mode
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|irq_mode
)paren
(brace
r_case
id|IMODE_OUTPUT
suffix:colon
id|DMAbuf_outputintr
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMODE_INPUT
suffix:colon
id|DMAbuf_inputintr
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMODE_INIT
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
multiline_comment|/* printk(KERN_WARN &quot;ESS: Unexpected interrupt&bslash;n&quot;); */
)brace
)brace
multiline_comment|/*&n; * FKS: TODO!!! Finish this!&n; *&n; * I think midi stuff uses uart401, without interrupts.&n; * So IMODE_MIDI isn&squot;t a value for devc-&gt;irq_mode.&n; */
DECL|function|ess_intr
r_void
id|ess_intr
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_char
id|src
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;submodel
op_eq
id|SUBMDL_ES1887
)paren
(brace
id|src
op_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x7f
)paren
op_rshift
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|src
op_assign
l_int|0xff
suffix:semicolon
)brace
macro_line|#ifdef FKS_REG_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FKS: sbintr src=%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|src
)paren
suffix:semicolon
macro_line|#endif
id|ess_handle_channel
(paren
l_string|&quot;Audio 1&quot;
comma
id|devc-&gt;dev
comma
id|devc-&gt;intr_active
comma
id|src
op_amp
l_int|0x01
comma
id|devc-&gt;irq_mode
)paren
suffix:semicolon
id|ess_handle_channel
(paren
l_string|&quot;Audio 2&quot;
comma
id|devc-&gt;dev
comma
id|devc-&gt;intr_active_16
comma
id|src
op_amp
l_int|0x02
comma
id|devc-&gt;irq_mode_16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Acknowledge interrupts&n;&t; */
r_if
c_cond
(paren
id|devc-&gt;submodel
op_eq
id|SUBMDL_ES1887
op_logical_and
(paren
id|src
op_amp
l_int|0x02
)paren
)paren
(brace
id|ess_chgmixer
(paren
id|devc
comma
l_int|0x7a
comma
l_int|0x80
comma
l_int|0x00
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src
op_amp
l_int|0x01
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|DSP_DATA_AVAIL
)paren
suffix:semicolon
)brace
)brace
DECL|function|ess_extended
r_static
r_void
id|ess_extended
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
multiline_comment|/* Enable extended mode */
id|sb_dsp_command
c_func
(paren
id|devc
comma
l_int|0xc6
)paren
suffix:semicolon
)brace
DECL|function|ess_write
r_static
r_int
id|ess_write
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|data
)paren
(brace
macro_line|#ifdef FKS_REG_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FKS: write reg %x: %x&bslash;n&quot;
comma
id|reg
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Write a byte to an extended mode register of ES1688 */
r_if
c_cond
(paren
op_logical_neg
id|sb_dsp_command
c_func
(paren
id|devc
comma
id|reg
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|sb_dsp_command
c_func
(paren
id|devc
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|ess_read
r_static
r_int
id|ess_read
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_char
id|reg
)paren
(brace
multiline_comment|/* Read a byte from an extended mode register of ES1688 */
multiline_comment|/* Read register command */
r_if
c_cond
(paren
op_logical_neg
id|sb_dsp_command
c_func
(paren
id|devc
comma
l_int|0xc0
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_dsp_command
c_func
(paren
id|devc
comma
id|reg
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|sb_dsp_get_byte
c_func
(paren
id|devc
)paren
suffix:semicolon
)brace
DECL|function|ess_dsp_reset
r_int
id|ess_dsp_reset
c_func
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
id|loopc
suffix:semicolon
macro_line|#ifdef FKS_REG_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FKS: ess_dsp_reset 1&bslash;n&quot;
)paren
suffix:semicolon
id|ess_show_mixerregs
(paren
id|devc
)paren
suffix:semicolon
macro_line|#endif
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Entered ess_dsp_reset()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|DSP_RESET
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO too */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|DSP_RESET
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loopc
op_assign
l_int|0
suffix:semicolon
id|loopc
OL
l_int|1000
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|DSP_DATA_AVAIL
)paren
op_amp
l_int|0x80
)paren
suffix:semicolon
id|loopc
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DSP_READ
)paren
op_ne
l_int|0xAA
)paren
(brace
id|DDB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;sb: No response to RESET&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Sorry */
)brace
id|ess_extended
(paren
id|devc
)paren
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;sb_dsp_reset() OK&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#ifdef FKS_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FKS: dsp_reset 2&bslash;n&quot;
)paren
suffix:semicolon
id|ess_show_mixerregs
(paren
id|devc
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ess_irq_bits
r_static
r_int
id|ess_irq_bits
(paren
r_int
id|irq
)paren
(brace
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|2
suffix:colon
r_case
l_int|9
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
l_int|5
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
l_int|7
suffix:colon
r_return
l_int|2
suffix:semicolon
r_case
l_int|10
suffix:colon
r_return
l_int|3
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ESS1688: Invalid IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Set IRQ configuration register for all ESS models&n; */
DECL|function|ess_common_set_irq_hw
r_static
r_int
id|ess_common_set_irq_hw
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
id|irq_bits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq_bits
op_assign
id|ess_irq_bits
(paren
id|devc-&gt;irq
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ess_write
(paren
id|devc
comma
l_int|0xb1
comma
l_int|0x50
op_or
(paren
id|irq_bits
op_lshift
l_int|2
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ES1688: Failed to write to IRQ config register&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * I wanna use modern ES1887 mixer irq handling. Funny is the&n; * fact that my BIOS wants the same. But suppose someone&squot;s BIOS&n; * doesn&squot;t do this!&n; * This is independent of duplex. If there&squot;s a 1887 this will&n; * prevent it from going into 1888 mode.&n; */
DECL|function|ess_es1887_set_irq_hw
r_static
r_void
id|ess_es1887_set_irq_hw
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
id|irq_bits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq_bits
op_assign
id|ess_irq_bits
(paren
id|devc-&gt;irq
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|ess_chgmixer
(paren
id|devc
comma
l_int|0x7f
comma
l_int|0x0f
comma
l_int|0x01
op_or
(paren
(paren
id|irq_bits
op_plus
l_int|1
)paren
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
)brace
DECL|function|ess_set_irq_hw
r_static
r_int
id|ess_set_irq_hw
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_if
c_cond
(paren
id|devc-&gt;submodel
op_eq
id|SUBMDL_ES1887
)paren
id|ess_es1887_set_irq_hw
(paren
id|devc
)paren
suffix:semicolon
r_return
id|ess_common_set_irq_hw
(paren
id|devc
)paren
suffix:semicolon
)brace
macro_line|#ifdef FKS_TEST
multiline_comment|/*&n; * FKS_test:&n; *&t;for ES1887: 00, 18, non wr bits: 0001 1000&n; *&t;for ES1868: 00, b8, non wr bits: 1011 1000&n; *&t;for ES1888: 00, f8, non wr bits: 1111 1000&n; *&t;for ES1688: 00, f8, non wr bits: 1111 1000&n; *&t;+   ES968&n; */
DECL|function|FKS_test
r_static
r_void
id|FKS_test
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
id|val1
comma
id|val2
suffix:semicolon
id|val1
op_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x64
)paren
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x64
comma
op_complement
id|val1
)paren
suffix:semicolon
id|val2
op_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x64
)paren
op_xor
op_complement
id|val1
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x64
comma
id|val1
)paren
suffix:semicolon
id|val1
op_xor_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x64
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;FKS: FKS_test %02x, %02x&bslash;n&quot;
comma
(paren
id|val1
op_amp
l_int|0x0ff
)paren
comma
(paren
id|val2
op_amp
l_int|0x0ff
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
DECL|function|ess_identify
r_static
r_int
r_int
id|ess_identify
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
r_int
r_char
)paren
(paren
l_int|0x40
op_amp
l_int|0xff
)paren
)paren
comma
id|MIXER_ADDR
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|MIXER_DATA
)paren
op_lshift
l_int|8
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|val
op_or_assign
id|inb
c_func
(paren
id|MIXER_DATA
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * ESS technology describes a detection scheme in their docs. It involves&n; * fiddling with the bits in certain mixer registers. ess_probe is supposed&n; * to help.&n; *&n; * FKS: tracing shows ess_probe writes wrong value to 0x64. Bit 3 reads 1, but&n; * should be written 0 only. Check this.&n; */
DECL|function|ess_probe
r_static
r_int
id|ess_probe
(paren
id|sb_devc
op_star
id|devc
comma
r_int
id|reg
comma
r_int
id|xorval
)paren
(brace
r_int
id|val1
comma
id|val2
comma
id|val3
suffix:semicolon
id|val1
op_assign
id|ess_getmixer
(paren
id|devc
comma
id|reg
)paren
suffix:semicolon
id|val2
op_assign
id|val1
op_xor
id|xorval
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
id|reg
comma
id|val2
)paren
suffix:semicolon
id|val3
op_assign
id|ess_getmixer
(paren
id|devc
comma
id|reg
)paren
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
id|reg
comma
id|val1
)paren
suffix:semicolon
r_return
(paren
id|val2
op_eq
id|val3
)paren
suffix:semicolon
)brace
DECL|function|ess_init
r_int
id|ess_init
c_func
(paren
id|sb_devc
op_star
id|devc
comma
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
r_char
id|cfg
suffix:semicolon
r_int
id|ess_major
op_assign
l_int|0
comma
id|ess_minor
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_static
r_char
id|name
(braket
l_int|100
)braket
comma
id|modelname
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Try to detect ESS chips.&n;&t; */
id|sb_dsp_command
c_func
(paren
id|devc
comma
l_int|0xe7
)paren
suffix:semicolon
multiline_comment|/* Return identification */
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DSP_DATA_AVAIL
)paren
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|ess_major
op_eq
l_int|0
)paren
(brace
id|ess_major
op_assign
id|inb
c_func
(paren
id|DSP_READ
)paren
suffix:semicolon
)brace
r_else
(brace
id|ess_minor
op_assign
id|inb
c_func
(paren
id|DSP_READ
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ess_major
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ess_major
op_eq
l_int|0x48
op_logical_and
(paren
id|ess_minor
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x80
)paren
(brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;ESS ES488 AudioDrive (rev %d)&quot;
comma
id|ess_minor
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|hw_config-&gt;name
op_assign
id|name
suffix:semicolon
id|devc-&gt;model
op_assign
id|MDL_SBPRO
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This the detection heuristic of ESS technology, though somewhat&n;&t; * changed to actually make it work.&n;&t; * This results in the following detection steps:&n;&t; * - distinct between ES688 and ES1688+ (as always done in this driver)&n;&t; *   if ES688 we&squot;re ready&n;&t; * - try to detect ES1868, ES1869 or ES1878 (ess_identify)&n;&t; *   if successful we&squot;re ready&n;&t; * - try to detect ES1888, ES1887 or ES1788 (aim: detect ES1887)&n;&t; *   if successful we&squot;re ready&n;&t; * - Dunno. Must be 1688. Will do in general&n;&t; *&n;&t; * This is the most BETA part of the software: Will the detection&n;&t; * always work?&n;&t; */
id|devc-&gt;model
op_assign
id|MDL_ESS
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|ess_minor
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|ess_major
op_eq
l_int|0x68
op_logical_and
(paren
id|ess_minor
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x80
)paren
(brace
r_char
op_star
id|chip
op_assign
l_int|NULL
suffix:semicolon
r_int
id|submodel
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|devc-&gt;sbmo.esstype
)paren
(brace
r_case
id|ESSTYPE_DETECT
suffix:colon
r_case
id|ESSTYPE_LIKE20
suffix:colon
r_break
suffix:semicolon
r_case
l_int|688
suffix:colon
id|submodel
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1688
suffix:colon
id|submodel
op_assign
l_int|0x08
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1868
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1868
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1869
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1869
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1788
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1788
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1878
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1878
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1879
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1879
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1887
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1887
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1888
suffix:colon
id|submodel
op_assign
id|SUBMDL_ES1888
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_ERR
l_string|&quot;Invalid esstype=%d specified&bslash;n&quot;
comma
id|devc-&gt;sbmo.esstype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|submodel
op_ne
op_minus
l_int|1
)paren
(brace
id|devc-&gt;submodel
op_assign
id|submodel
suffix:semicolon
id|sprintf
(paren
id|modelname
comma
l_string|&quot;ES%d&quot;
comma
id|devc-&gt;sbmo.esstype
)paren
suffix:semicolon
id|chip
op_assign
id|modelname
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
op_logical_and
(paren
id|ess_minor
op_amp
l_int|0x0f
)paren
OL
l_int|8
)paren
(brace
id|chip
op_assign
l_string|&quot;ES688&quot;
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef FKS_TEST
id|FKS_test
(paren
id|devc
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * If Nothing detected yet, and we want 2.0 behaviour...&n;&t;&t; * Then let&squot;s assume it&squot;s ES1688.&n;&t;&t; */
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
op_logical_and
id|devc-&gt;sbmo.esstype
op_eq
id|ESSTYPE_LIKE20
)paren
(brace
id|chip
op_assign
l_string|&quot;ES1688&quot;
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
)paren
(brace
r_int
id|type
suffix:semicolon
id|type
op_assign
id|ess_identify
(paren
id|devc
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0x1868
suffix:colon
id|chip
op_assign
l_string|&quot;ES1868&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1868
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1869
suffix:colon
id|chip
op_assign
l_string|&quot;ES1869&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1869
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1878
suffix:colon
id|chip
op_assign
l_string|&quot;ES1878&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1878
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1879
suffix:colon
id|chip
op_assign
l_string|&quot;ES1879&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1879
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|type
op_amp
l_int|0x00ff
)paren
op_ne
(paren
(paren
id|type
op_rshift
l_int|8
)paren
op_amp
l_int|0x00ff
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ess_init: Unrecognized %04x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t; * this one failed:&n;&t;&t; * the probing of bit 4 is another thought: from ES1788 and up, all&n;&t;&t; * chips seem to have hardware volume control. Bit 4 is readonly to&n;&t;&t; * check if a hardware volume interrupt has fired.&n;&t;&t; * Cause ES688/ES1688 don&squot;t have this feature, bit 4 might be writeable&n;&t;&t; * for these chips.&n;&t;&t; */
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
op_logical_and
op_logical_neg
id|ess_probe
c_func
(paren
id|devc
comma
l_int|0x64
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
)paren
(brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * the probing of bit 2 is my idea. The ES1887 docs want me to probe&n;&t;&t; * bit 3. This results in ES1688 being detected as ES1788.&n;&t;&t; * Bit 2 is for &quot;Enable HWV IRQE&quot;, but as ES(1)688 chips don&squot;t have&n;&t;&t; * HardWare Volume, I think they don&squot;t have this IRQE.&n;&t;&t; */
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
op_logical_and
id|ess_probe
c_func
(paren
id|devc
comma
l_int|0x64
comma
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ess_probe
(paren
id|devc
comma
l_int|0x70
comma
l_int|0x7f
)paren
)paren
(brace
r_if
c_cond
(paren
id|ess_probe
(paren
id|devc
comma
l_int|0x64
comma
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
)paren
(brace
id|chip
op_assign
l_string|&quot;ES1887&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1887
suffix:semicolon
)brace
r_else
(brace
id|chip
op_assign
l_string|&quot;ES1888&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1888
suffix:semicolon
)brace
)brace
r_else
(brace
id|chip
op_assign
l_string|&quot;ES1788&quot;
suffix:semicolon
id|devc-&gt;submodel
op_assign
id|SUBMDL_ES1788
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
)paren
(brace
id|chip
op_assign
l_string|&quot;ES1688&quot;
suffix:semicolon
)brace
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;ESS chip %s %s%s&bslash;n&quot;
comma
id|chip
comma
(paren
id|devc-&gt;sbmo.esstype
op_eq
id|ESSTYPE_DETECT
op_logical_or
id|devc-&gt;sbmo.esstype
op_eq
id|ESSTYPE_LIKE20
ques
c_cond
l_string|&quot;detected&quot;
suffix:colon
l_string|&quot;specified&quot;
)paren
comma
(paren
id|devc-&gt;sbmo.esstype
op_eq
id|ESSTYPE_LIKE20
ques
c_cond
l_string|&quot; (kernel 2.0 compatible)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;ESS %s AudioDrive (rev %d)&quot;
comma
id|chip
comma
id|ess_minor
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_else
(brace
id|strcpy
c_func
(paren
id|name
comma
l_string|&quot;Jazz16&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* AAS: info stolen from ALSA: these boards have different clocks */
r_switch
c_cond
(paren
id|devc-&gt;submodel
)paren
(brace
multiline_comment|/* APPARENTLY NOT 1869 AND 1887&n;&t;&t;case SUBMDL_ES1869:&n;&t;&t;case SUBMDL_ES1887:&n;*/
r_case
id|SUBMDL_ES1888
suffix:colon
id|devc-&gt;caps
op_or_assign
id|SB_CAP_ES18XX_RATE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hw_config-&gt;name
op_assign
id|name
suffix:semicolon
multiline_comment|/* FKS: sb_dsp_reset to enable extended mode???? */
id|sb_dsp_reset
c_func
(paren
id|devc
)paren
suffix:semicolon
multiline_comment|/* Turn on extended mode */
multiline_comment|/*&n;&t; *  Enable joystick and OPL3&n;&t; */
id|cfg
op_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x40
)paren
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x40
comma
id|cfg
op_or
l_int|0x03
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;submodel
op_ge
l_int|8
)paren
(brace
multiline_comment|/* ES1688 */
id|devc-&gt;caps
op_or_assign
id|SB_NO_MIDI
suffix:semicolon
multiline_comment|/* ES1688 uses MPU401 MIDI mode */
)brace
id|sb_dsp_reset
(paren
id|devc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is important! If it&squot;s not done, the IRQ probe in sb_dsp_init&n;&t; * may fail.&n;&t; */
r_return
id|ess_set_irq_hw
(paren
id|devc
)paren
suffix:semicolon
)brace
DECL|function|ess_set_dma_hw
r_static
r_int
id|ess_set_dma_hw
c_func
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
r_char
id|cfg
comma
id|dma_bits
op_assign
l_int|0
comma
id|dma16_bits
suffix:semicolon
r_int
id|dma
suffix:semicolon
macro_line|#ifdef FKS_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ess_set_dma_hw: dma8=%d,dma16=%d,dup=%d&bslash;n&quot;
comma
id|devc-&gt;dma8
comma
id|devc-&gt;dma16
comma
id|devc-&gt;duplex
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * FKS: It seems as if this duplex flag isn&squot;t set yet. Check it.&n;&t; */
id|dma
op_assign
id|devc-&gt;dma8
suffix:semicolon
r_if
c_cond
(paren
id|dma
OG
l_int|3
op_logical_or
id|dma
OL
l_int|0
op_logical_or
id|dma
op_eq
l_int|2
)paren
(brace
id|dma_bits
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ESS1688: Invalid DMA8 %d&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Extended mode DMA enable */
id|cfg
op_assign
l_int|0x50
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_eq
l_int|3
)paren
(brace
id|dma_bits
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|dma_bits
op_assign
id|dma
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ess_write
(paren
id|devc
comma
l_int|0xb2
comma
id|cfg
op_or
(paren
id|dma_bits
op_lshift
l_int|2
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ESS1688: Failed to write to DMA config register&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
id|dma
op_assign
id|devc-&gt;dma16
suffix:semicolon
id|dma16_bits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_ge
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|dma
)paren
(brace
r_case
l_int|0
suffix:colon
id|dma_bits
op_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dma_bits
op_assign
l_int|0x05
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|dma_bits
op_assign
l_int|0x06
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|dma_bits
op_assign
l_int|0x07
suffix:semicolon
id|dma16_bits
op_assign
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ESS1887: Invalid DMA16 %d&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|ess_chgmixer
(paren
id|devc
comma
l_int|0x78
comma
l_int|0x20
comma
id|dma16_bits
)paren
suffix:semicolon
id|ess_chgmixer
(paren
id|devc
comma
l_int|0x7d
comma
l_int|0x07
comma
id|dma_bits
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This one is called from sb_dsp_init.&n; *&n; * Return values:&n; *  0: Failed&n; *  1: Succeeded or doesn&squot;t apply (not SUBMDL_ES1887)&n; */
DECL|function|ess_dsp_init
r_int
id|ess_dsp_init
(paren
id|sb_devc
op_star
id|devc
comma
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
multiline_comment|/*&n;&t; * Caller also checks this, but anyway&n;&t; */
r_if
c_cond
(paren
id|devc-&gt;model
op_ne
id|MDL_ESS
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;ess_dsp_init for non ESS chip&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This for ES1887 to run Full Duplex. Actually ES1888&n;&t; * is allowed to do so too. I have no idea yet if this&n;&t; * will work for ES1888 however.&n;&t; *&n;&t; * For SB16 having both dma8 and dma16 means enable&n;&t; * Full Duplex. Let&squot;s try this for ES1887 too&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|devc-&gt;submodel
op_eq
id|SUBMDL_ES1887
)paren
(brace
r_if
c_cond
(paren
id|hw_config-&gt;dma2
op_ne
op_minus
l_int|1
)paren
(brace
id|devc-&gt;dma16
op_assign
id|hw_config-&gt;dma2
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * devc-&gt;duplex initialization is put here, cause&n;&t;&t; * ess_set_dma_hw needs it.&n;&t;&t; */
r_if
c_cond
(paren
id|devc-&gt;dma8
op_ne
id|devc-&gt;dma16
op_logical_and
id|devc-&gt;dma16
op_ne
op_minus
l_int|1
)paren
(brace
id|devc-&gt;duplex
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ess_set_dma_hw
(paren
id|devc
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|devc-&gt;irq
comma
id|devc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;ESS mixer&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; ****************************************************************************/
DECL|macro|ES688_RECORDING_DEVICES
mdefine_line|#define ES688_RECORDING_DEVICES&t;&bslash;&n;&t;&t;&t;( SOUND_MASK_LINE&t;| SOUND_MASK_MIC&t;| SOUND_MASK_CD&t;&t;)
DECL|macro|ES688_MIXER_DEVICES
mdefine_line|#define ES688_MIXER_DEVICES&t;&t;&bslash;&n;&t;&t;&t;( SOUND_MASK_SYNTH&t;| SOUND_MASK_PCM&t;| SOUND_MASK_LINE&t;&bslash;&n;&t;&t;&t;| SOUND_MASK_MIC&t;| SOUND_MASK_CD&t;&t;| SOUND_MASK_VOLUME&t;&bslash;&n;&t;&t;&t;| SOUND_MASK_LINE2&t;| SOUND_MASK_SPEAKER&t;&t;&t;&t;&t;)
DECL|macro|ES1688_RECORDING_DEVICES
mdefine_line|#define ES1688_RECORDING_DEVICES&t;&bslash;&n;&t;&t;&t;( ES688_RECORDING_DEVICES&t;&t;&t;&t;&t;)
DECL|macro|ES1688_MIXER_DEVICES
mdefine_line|#define ES1688_MIXER_DEVICES&t;&t;&bslash;&n;&t;&t;&t;( ES688_MIXER_DEVICES | SOUND_MASK_RECLEV&t;)
DECL|macro|ES1887_RECORDING_DEVICES
mdefine_line|#define ES1887_RECORDING_DEVICES&t;&bslash;&n;&t;&t;&t;( ES1688_RECORDING_DEVICES | SOUND_MASK_LINE2 | SOUND_MASK_SYNTH)
DECL|macro|ES1887_MIXER_DEVICES
mdefine_line|#define ES1887_MIXER_DEVICES&t;&t;&bslash;&n;&t;&t;&t;( ES1688_MIXER_DEVICES&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;)
multiline_comment|/*&n; * Mixer registers of ES1887&n; *&n; * These registers specifically take care of recording levels. To make the&n; * mapping from playback devices to recording devices every recording&n; * devices = playback device + ES_REC_MIXER_RECDIFF&n; */
DECL|macro|ES_REC_MIXER_RECBASE
mdefine_line|#define ES_REC_MIXER_RECBASE&t;(SOUND_MIXER_LINE3 + 1)
DECL|macro|ES_REC_MIXER_RECDIFF
mdefine_line|#define ES_REC_MIXER_RECDIFF&t;(ES_REC_MIXER_RECBASE - SOUND_MIXER_SYNTH)
DECL|macro|ES_REC_MIXER_RECSYNTH
mdefine_line|#define ES_REC_MIXER_RECSYNTH&t;(SOUND_MIXER_SYNTH&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECPCM
mdefine_line|#define ES_REC_MIXER_RECPCM&t;&t;(SOUND_MIXER_PCM&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECSPEAKER
mdefine_line|#define ES_REC_MIXER_RECSPEAKER&t;(SOUND_MIXER_SPEAKER + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECLINE
mdefine_line|#define ES_REC_MIXER_RECLINE&t;(SOUND_MIXER_LINE&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECMIC
mdefine_line|#define ES_REC_MIXER_RECMIC&t;&t;(SOUND_MIXER_MIC&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECCD
mdefine_line|#define ES_REC_MIXER_RECCD&t;&t;(SOUND_MIXER_CD&t;&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECIMIX
mdefine_line|#define ES_REC_MIXER_RECIMIX&t;(SOUND_MIXER_IMIX&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECALTPCM
mdefine_line|#define ES_REC_MIXER_RECALTPCM&t;(SOUND_MIXER_ALTPCM&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECRECLEV
mdefine_line|#define ES_REC_MIXER_RECRECLEV&t;(SOUND_MIXER_RECLEV&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECIGAIN
mdefine_line|#define ES_REC_MIXER_RECIGAIN&t;(SOUND_MIXER_IGAIN&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECOGAIN
mdefine_line|#define ES_REC_MIXER_RECOGAIN&t;(SOUND_MIXER_OGAIN&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECLINE1
mdefine_line|#define ES_REC_MIXER_RECLINE1&t;(SOUND_MIXER_LINE1&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECLINE2
mdefine_line|#define ES_REC_MIXER_RECLINE2&t;(SOUND_MIXER_LINE2&t; + ES_REC_MIXER_RECDIFF)
DECL|macro|ES_REC_MIXER_RECLINE3
mdefine_line|#define ES_REC_MIXER_RECLINE3&t;(SOUND_MIXER_LINE3&t; + ES_REC_MIXER_RECDIFF)
DECL|variable|es688_mix
r_static
id|mixer_tab
id|es688_mix
op_assign
(brace
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_VOLUME
comma
l_int|0x32
comma
l_int|7
comma
l_int|4
comma
l_int|0x32
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_BASS
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_TREBLE
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SYNTH
comma
l_int|0x36
comma
l_int|7
comma
l_int|4
comma
l_int|0x36
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_PCM
comma
l_int|0x14
comma
l_int|7
comma
l_int|4
comma
l_int|0x14
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SPEAKER
comma
l_int|0x3c
comma
l_int|2
comma
l_int|3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE
comma
l_int|0x3e
comma
l_int|7
comma
l_int|4
comma
l_int|0x3e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_MIC
comma
l_int|0x1a
comma
l_int|7
comma
l_int|4
comma
l_int|0x1a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_CD
comma
l_int|0x38
comma
l_int|7
comma
l_int|4
comma
l_int|0x38
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_ALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_RECLEV
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_OGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE2
comma
l_int|0x3a
comma
l_int|7
comma
l_int|4
comma
l_int|0x3a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
)brace
suffix:semicolon
multiline_comment|/*&n; * The ES1688 specifics... hopefully correct...&n; * - 6 bit master volume&n; *   I was wrong, ES1888 docs say ES1688 didn&squot;t have it.&n; * - RECLEV control&n; * These may apply to ES688 too. I have no idea.&n; */
DECL|variable|es1688_mix
r_static
id|mixer_tab
id|es1688_mix
op_assign
(brace
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_VOLUME
comma
l_int|0x32
comma
l_int|7
comma
l_int|4
comma
l_int|0x32
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_BASS
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_TREBLE
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SYNTH
comma
l_int|0x36
comma
l_int|7
comma
l_int|4
comma
l_int|0x36
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_PCM
comma
l_int|0x14
comma
l_int|7
comma
l_int|4
comma
l_int|0x14
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SPEAKER
comma
l_int|0x3c
comma
l_int|2
comma
l_int|3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE
comma
l_int|0x3e
comma
l_int|7
comma
l_int|4
comma
l_int|0x3e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_MIC
comma
l_int|0x1a
comma
l_int|7
comma
l_int|4
comma
l_int|0x1a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_CD
comma
l_int|0x38
comma
l_int|7
comma
l_int|4
comma
l_int|0x38
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_ALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_RECLEV
comma
l_int|0xb4
comma
l_int|7
comma
l_int|4
comma
l_int|0xb4
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_OGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE2
comma
l_int|0x3a
comma
l_int|7
comma
l_int|4
comma
l_int|0x3a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
)brace
suffix:semicolon
DECL|variable|es1688later_mix
r_static
id|mixer_tab
id|es1688later_mix
op_assign
(brace
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_VOLUME
comma
l_int|0x60
comma
l_int|5
comma
l_int|6
comma
l_int|0x62
comma
l_int|5
comma
l_int|6
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_BASS
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_TREBLE
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SYNTH
comma
l_int|0x36
comma
l_int|7
comma
l_int|4
comma
l_int|0x36
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_PCM
comma
l_int|0x14
comma
l_int|7
comma
l_int|4
comma
l_int|0x14
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SPEAKER
comma
l_int|0x3c
comma
l_int|2
comma
l_int|3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE
comma
l_int|0x3e
comma
l_int|7
comma
l_int|4
comma
l_int|0x3e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_MIC
comma
l_int|0x1a
comma
l_int|7
comma
l_int|4
comma
l_int|0x1a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_CD
comma
l_int|0x38
comma
l_int|7
comma
l_int|4
comma
l_int|0x38
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_ALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_RECLEV
comma
l_int|0xb4
comma
l_int|7
comma
l_int|4
comma
l_int|0xb4
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_OGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE2
comma
l_int|0x3a
comma
l_int|7
comma
l_int|4
comma
l_int|0x3a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
)brace
suffix:semicolon
multiline_comment|/*&n; * This one is for all ESS chips with a record mixer.&n; * It&squot;s not used (yet) however&n; */
DECL|variable|es_rec_mix
r_static
id|mixer_tab
id|es_rec_mix
op_assign
(brace
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_VOLUME
comma
l_int|0x60
comma
l_int|5
comma
l_int|6
comma
l_int|0x62
comma
l_int|5
comma
l_int|6
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_BASS
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_TREBLE
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SYNTH
comma
l_int|0x36
comma
l_int|7
comma
l_int|4
comma
l_int|0x36
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_PCM
comma
l_int|0x14
comma
l_int|7
comma
l_int|4
comma
l_int|0x14
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SPEAKER
comma
l_int|0x3c
comma
l_int|2
comma
l_int|3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE
comma
l_int|0x3e
comma
l_int|7
comma
l_int|4
comma
l_int|0x3e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_MIC
comma
l_int|0x1a
comma
l_int|7
comma
l_int|4
comma
l_int|0x1a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_CD
comma
l_int|0x38
comma
l_int|7
comma
l_int|4
comma
l_int|0x38
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_ALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_RECLEV
comma
l_int|0xb4
comma
l_int|7
comma
l_int|4
comma
l_int|0xb4
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_OGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE2
comma
l_int|0x3a
comma
l_int|7
comma
l_int|4
comma
l_int|0x3a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECSYNTH
comma
l_int|0x6b
comma
l_int|7
comma
l_int|4
comma
l_int|0x6b
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECSPEAKER
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE
comma
l_int|0x6e
comma
l_int|7
comma
l_int|4
comma
l_int|0x6e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECMIC
comma
l_int|0x68
comma
l_int|7
comma
l_int|4
comma
l_int|0x68
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECCD
comma
l_int|0x6a
comma
l_int|7
comma
l_int|4
comma
l_int|0x6a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECIMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECRECLEV
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECIGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECOGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE2
comma
l_int|0x6c
comma
l_int|7
comma
l_int|4
comma
l_int|0x6c
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
)brace
suffix:semicolon
multiline_comment|/*&n; * This one is for ES1887. It&squot;s little different from es_rec_mix: it&n; * has 0x7c for PCM playback level. This is because ES1887 uses&n; * Audio 2 for playback.&n; */
DECL|variable|es1887_mix
r_static
id|mixer_tab
id|es1887_mix
op_assign
(brace
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_VOLUME
comma
l_int|0x60
comma
l_int|5
comma
l_int|6
comma
l_int|0x62
comma
l_int|5
comma
l_int|6
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_BASS
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_TREBLE
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SYNTH
comma
l_int|0x36
comma
l_int|7
comma
l_int|4
comma
l_int|0x36
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_PCM
comma
l_int|0x7c
comma
l_int|7
comma
l_int|4
comma
l_int|0x7c
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_SPEAKER
comma
l_int|0x3c
comma
l_int|2
comma
l_int|3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE
comma
l_int|0x3e
comma
l_int|7
comma
l_int|4
comma
l_int|0x3e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_MIC
comma
l_int|0x1a
comma
l_int|7
comma
l_int|4
comma
l_int|0x1a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_CD
comma
l_int|0x38
comma
l_int|7
comma
l_int|4
comma
l_int|0x38
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_ALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_RECLEV
comma
l_int|0xb4
comma
l_int|7
comma
l_int|4
comma
l_int|0xb4
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_IGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_OGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE2
comma
l_int|0x3a
comma
l_int|7
comma
l_int|4
comma
l_int|0x3a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|SOUND_MIXER_LINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECSYNTH
comma
l_int|0x6b
comma
l_int|7
comma
l_int|4
comma
l_int|0x6b
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECSPEAKER
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE
comma
l_int|0x6e
comma
l_int|7
comma
l_int|4
comma
l_int|0x6e
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECMIC
comma
l_int|0x68
comma
l_int|7
comma
l_int|4
comma
l_int|0x68
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECCD
comma
l_int|0x6a
comma
l_int|7
comma
l_int|4
comma
l_int|0x6a
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECIMIX
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECALTPCM
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECRECLEV
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECIGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECOGAIN
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE1
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE2
comma
l_int|0x6c
comma
l_int|7
comma
l_int|4
comma
l_int|0x6c
comma
l_int|3
comma
l_int|4
)paren
comma
id|MIX_ENT
c_func
(paren
id|ES_REC_MIXER_RECLINE3
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|0
)paren
)brace
suffix:semicolon
DECL|function|ess_has_rec_mixer
r_static
r_int
id|ess_has_rec_mixer
(paren
r_int
id|submodel
)paren
(brace
r_switch
c_cond
(paren
id|submodel
)paren
(brace
r_case
id|SUBMDL_ES1887
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef FKS_LOGGING
DECL|variable|ess_mixer_mon_regs
r_static
r_int
id|ess_mixer_mon_regs
(braket
)braket
op_assign
(brace
l_int|0x70
comma
l_int|0x71
comma
l_int|0x72
comma
l_int|0x74
comma
l_int|0x76
comma
l_int|0x78
comma
l_int|0x7a
comma
l_int|0x7c
comma
l_int|0x7d
comma
l_int|0x7f
comma
l_int|0xa1
comma
l_int|0xa2
comma
l_int|0xa4
comma
l_int|0xa5
comma
l_int|0xa8
comma
l_int|0xa9
comma
l_int|0xb1
comma
l_int|0xb2
comma
l_int|0xb4
comma
l_int|0xb5
comma
l_int|0xb6
comma
l_int|0xb7
comma
l_int|0xb9
comma
l_int|0x00
)brace
suffix:semicolon
DECL|function|ess_show_mixerregs
r_static
r_void
id|ess_show_mixerregs
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
r_int
op_star
id|mp
op_assign
id|ess_mixer_mon_regs
suffix:semicolon
r_return
suffix:semicolon
r_while
c_loop
(paren
op_star
id|mp
op_ne
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;res (%x)=%x&bslash;n&quot;
comma
op_star
id|mp
comma
(paren
r_int
)paren
(paren
id|ess_getmixer
(paren
id|devc
comma
op_star
id|mp
)paren
)paren
)paren
suffix:semicolon
id|mp
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|ess_setmixer
r_void
id|ess_setmixer
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_int
id|port
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef FKS_LOGGING
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FKS: write mixer %x: %x&bslash;n&quot;
comma
id|port
comma
id|value
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
op_ge
l_int|0xa0
)paren
(brace
id|ess_write
(paren
id|devc
comma
id|port
comma
id|value
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|port
op_amp
l_int|0xff
)paren
)paren
comma
id|MIXER_ADDR
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|value
op_amp
l_int|0xff
)paren
)paren
comma
id|MIXER_DATA
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ess_getmixer
r_int
r_int
id|ess_getmixer
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_int
id|port
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
op_ge
l_int|0xa0
)paren
(brace
id|val
op_assign
id|ess_read
(paren
id|devc
comma
id|port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
(paren
(paren
r_int
r_char
)paren
(paren
id|port
op_amp
l_int|0xff
)paren
)paren
comma
id|MIXER_ADDR
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|MIXER_DATA
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|ess_chgmixer
r_static
r_void
id|ess_chgmixer
(paren
id|sb_devc
op_star
id|devc
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|val
)paren
(brace
r_int
id|value
suffix:semicolon
id|value
op_assign
id|ess_getmixer
(paren
id|devc
comma
id|reg
)paren
suffix:semicolon
id|value
op_assign
(paren
id|value
op_amp
op_complement
id|mask
)paren
op_or
(paren
id|val
op_amp
id|mask
)paren
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
id|reg
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ess_mixer_init must be called from sb_mixer_init&n; */
DECL|function|ess_mixer_init
r_void
id|ess_mixer_init
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
id|devc-&gt;mixer_caps
op_assign
id|SOUND_CAP_EXCL_INPUT
suffix:semicolon
multiline_comment|/*&n;&t;* Take care of ES1887 specifics...&n;&t;*/
r_switch
c_cond
(paren
id|devc-&gt;submodel
)paren
(brace
r_case
id|SUBMDL_ES1887
suffix:colon
id|devc-&gt;supported_devices
op_assign
id|ES1887_MIXER_DEVICES
suffix:semicolon
id|devc-&gt;supported_rec_devices
op_assign
id|ES1887_RECORDING_DEVICES
suffix:semicolon
macro_line|#ifdef FKS_LOGGING
id|printk
(paren
id|KERN_INFO
l_string|&quot;FKS: ess_mixer_init dup = %d&bslash;n&quot;
comma
id|devc-&gt;duplex
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|devc-&gt;duplex
)paren
(brace
id|devc-&gt;iomap
op_assign
op_amp
id|es1887_mix
suffix:semicolon
)brace
r_else
(brace
id|devc-&gt;iomap
op_assign
op_amp
id|es_rec_mix
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|devc-&gt;submodel
OL
l_int|8
)paren
(brace
id|devc-&gt;supported_devices
op_assign
id|ES688_MIXER_DEVICES
suffix:semicolon
id|devc-&gt;supported_rec_devices
op_assign
id|ES688_RECORDING_DEVICES
suffix:semicolon
id|devc-&gt;iomap
op_assign
op_amp
id|es688_mix
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * es1688 has 4 bits master vol.&n;&t;&t;&t; * later chips have 6 bits (?)&n;&t;&t;&t; */
id|devc-&gt;supported_devices
op_assign
id|ES1688_MIXER_DEVICES
suffix:semicolon
id|devc-&gt;supported_rec_devices
op_assign
id|ES1688_RECORDING_DEVICES
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;submodel
OL
l_int|0x10
)paren
(brace
id|devc-&gt;iomap
op_assign
op_amp
id|es1688_mix
suffix:semicolon
)brace
r_else
(brace
id|devc-&gt;iomap
op_assign
op_amp
id|es1688later_mix
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Changing playback levels at an ESS chip with record mixer means having to&n; * take care of recording levels of recorded inputs (devc-&gt;recmask) too!&n; */
DECL|function|ess_mixer_set
r_int
id|ess_mixer_set
c_func
(paren
id|sb_devc
op_star
id|devc
comma
r_int
id|dev
comma
r_int
id|left
comma
r_int
id|right
)paren
(brace
r_if
c_cond
(paren
id|ess_has_rec_mixer
(paren
id|devc-&gt;submodel
)paren
op_logical_and
(paren
id|devc-&gt;recmask
op_amp
(paren
l_int|1
op_lshift
id|dev
)paren
)paren
)paren
(brace
id|sb_common_mixer_set
(paren
id|devc
comma
id|dev
op_plus
id|ES_REC_MIXER_RECDIFF
comma
id|left
comma
id|right
)paren
suffix:semicolon
)brace
r_return
id|sb_common_mixer_set
(paren
id|devc
comma
id|dev
comma
id|left
comma
id|right
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * After a sb_dsp_reset extended register 0xb4 (RECLEV) is reset too. After&n; * sb_dsp_reset RECLEV has to be restored. This is where ess_mixer_reload&n; * helps.&n; */
DECL|function|ess_mixer_reload
r_void
id|ess_mixer_reload
(paren
id|sb_devc
op_star
id|devc
comma
r_int
id|dev
)paren
(brace
r_int
id|left
comma
id|right
comma
id|value
suffix:semicolon
id|value
op_assign
id|devc-&gt;levels
(braket
id|dev
)braket
suffix:semicolon
id|left
op_assign
id|value
op_amp
l_int|0x000000ff
suffix:semicolon
id|right
op_assign
(paren
id|value
op_amp
l_int|0x0000ff00
)paren
op_rshift
l_int|8
suffix:semicolon
id|sb_common_mixer_set
c_func
(paren
id|devc
comma
id|dev
comma
id|left
comma
id|right
)paren
suffix:semicolon
)brace
DECL|function|es_rec_set_recmask
r_int
id|es_rec_set_recmask
c_func
(paren
id|sb_devc
op_star
id|devc
comma
r_int
id|mask
)paren
(brace
r_int
id|i
comma
id|i_mask
comma
id|cur_mask
comma
id|diff_mask
suffix:semicolon
r_int
id|value
comma
id|left
comma
id|right
suffix:semicolon
macro_line|#ifdef FKS_LOGGING
id|printk
(paren
id|KERN_INFO
l_string|&quot;FKS: es_rec_set_recmask mask = %x&bslash;n&quot;
comma
id|mask
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Changing the recmask on an ESS chip with recording mixer means:&n;&t; * (1) Find the differences&n;&t; * (2) For &quot;turned-on&quot;  inputs: make the recording level the playback level&n;&t; * (3) For &quot;turned-off&quot; inputs: make the recording level zero&n;&t; */
id|cur_mask
op_assign
id|devc-&gt;recmask
suffix:semicolon
id|diff_mask
op_assign
(paren
id|cur_mask
op_xor
id|mask
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i_mask
op_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_mask
op_amp
id|i_mask
)paren
(brace
multiline_comment|/* Difference? (1)  */
r_if
c_cond
(paren
id|mask
op_amp
id|i_mask
)paren
(brace
multiline_comment|/* Turn it on  (2)  */
id|value
op_assign
id|devc-&gt;levels
(braket
id|i
)braket
suffix:semicolon
id|left
op_assign
id|value
op_amp
l_int|0x000000ff
suffix:semicolon
id|right
op_assign
(paren
id|value
op_amp
l_int|0x0000ff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Turn it off (3)  */
id|left
op_assign
l_int|0
suffix:semicolon
id|left
op_assign
l_int|0
suffix:semicolon
id|right
op_assign
l_int|0
suffix:semicolon
)brace
id|sb_common_mixer_set
c_func
(paren
id|devc
comma
id|i
op_plus
id|ES_REC_MIXER_RECDIFF
comma
id|left
comma
id|right
)paren
suffix:semicolon
)brace
)brace
r_return
id|mask
suffix:semicolon
)brace
DECL|function|ess_set_recmask
r_int
id|ess_set_recmask
c_func
(paren
id|sb_devc
op_star
id|devc
comma
r_int
op_star
id|mask
)paren
(brace
multiline_comment|/* This applies to ESS chips with record mixers only! */
r_if
c_cond
(paren
id|ess_has_rec_mixer
(paren
id|devc-&gt;submodel
)paren
)paren
(brace
op_star
id|mask
op_assign
id|es_rec_set_recmask
(paren
id|devc
comma
op_star
id|mask
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Applied&t;&t;*/
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Not applied&t;*/
)brace
)brace
multiline_comment|/*&n; * ess_mixer_reset must be called from sb_mixer_reset&n; */
DECL|function|ess_mixer_reset
r_int
id|ess_mixer_reset
(paren
id|sb_devc
op_star
id|devc
)paren
(brace
multiline_comment|/*&n;&t; * Separate actions for ESS chips with a record mixer:&n;&t; */
r_if
c_cond
(paren
id|ess_has_rec_mixer
(paren
id|devc-&gt;submodel
)paren
)paren
(brace
r_switch
c_cond
(paren
id|devc-&gt;submodel
)paren
(brace
r_case
id|SUBMDL_ES1887
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Separate actions for ES1887:&n;&t;&t;&t; * Change registers 7a and 1c to make the record mixer the&n;&t;&t;&t; * actual recording source.&n;&t;&t;&t; */
id|ess_chgmixer
c_func
(paren
id|devc
comma
l_int|0x7a
comma
l_int|0x18
comma
l_int|0x08
)paren
suffix:semicolon
id|ess_chgmixer
c_func
(paren
id|devc
comma
l_int|0x1c
comma
l_int|0x07
comma
l_int|0x07
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Call set_recmask for proper initialization&n;&t;&t; */
id|devc-&gt;recmask
op_assign
id|devc-&gt;supported_rec_devices
suffix:semicolon
id|es_rec_set_recmask
c_func
(paren
id|devc
comma
l_int|0
)paren
suffix:semicolon
id|devc-&gt;recmask
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We took care of recmask.&t;&t;&t;&t;*/
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We didn&squot;t take care; caller do it&t;*/
)brace
)brace
multiline_comment|/****************************************************************************&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;ESS midi&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; *&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;*&n; ****************************************************************************/
multiline_comment|/*&n; * FKS: IRQ may be shared. Hm. And if so? Then What?&n; */
DECL|function|ess_midi_init
r_int
id|ess_midi_init
c_func
(paren
id|sb_devc
op_star
id|devc
comma
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_int
r_char
id|cfg
comma
id|tmp
suffix:semicolon
id|cfg
op_assign
id|ess_getmixer
(paren
id|devc
comma
l_int|0x40
)paren
op_amp
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|devc-&gt;submodel
OL
l_int|8
)paren
(brace
id|ess_setmixer
(paren
id|devc
comma
l_int|0x40
comma
id|cfg
op_or
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Enable OPL3 &amp; joystick */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ES688 doesn&squot;t support MPU401 mode */
)brace
id|tmp
op_assign
(paren
id|hw_config-&gt;io_base
op_amp
l_int|0x0f0
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
l_int|3
)paren
(brace
id|ess_setmixer
(paren
id|devc
comma
l_int|0x40
comma
id|cfg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cfg
op_or_assign
id|tmp
op_lshift
l_int|3
suffix:semicolon
id|tmp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* MPU enabled without interrupts */
multiline_comment|/* May be shared: if so the value is -ve */
r_switch
c_cond
(paren
id|abs
c_func
(paren
id|hw_config-&gt;irq
)paren
)paren
(brace
r_case
l_int|9
suffix:colon
id|tmp
op_assign
l_int|0x4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|tmp
op_assign
l_int|0x5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|tmp
op_assign
l_int|0x6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|tmp
op_assign
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|cfg
op_or_assign
id|tmp
op_lshift
l_int|5
suffix:semicolon
id|ess_setmixer
(paren
id|devc
comma
l_int|0x40
comma
id|cfg
op_or
l_int|0x03
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
