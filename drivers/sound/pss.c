multiline_comment|/* Marc.Hoffman@analog.com&n;&n;   This is a pss driver.&n;&n;   it is based on Greg.Yukna@analog.com @file{host} for DOG&n;&n;   Unfortunately I can&squot;t distribute the ld file needed to&n;   make the pss card to emulate the SB stuff.&n;&n;   I have provided a simple interface to the PSS unlike the&n;   DOG version.  to download a new algorithm just cat it to&n;   /dev/pss 14,9.&n;&n;   You really need to rebuild this with the synth.ld file&n;&n;   get the &lt;synth&gt;.ld from your dos directory maybe&n;   voyetra&bslash;dsp001.ld&n;&n;   ld2inc &lt; synth.ld &gt; synth-ld.h&n;   (make config does the same).&n;&n;   rebuild&n;&n;   Okay if you blow things away no problem just&n;&n;   main(){ioctl(open(&quot;/dev/pss&quot;),SNDCTL_PSS_RESET)};&n;&n;   and everything will be okay.&n;&n;   At first I was going to worry about applications that were using&n;   the sound stuff and disallow the use of /dev/pss.  But for&n;   now I figured it doesn&squot;t matter.&n;&n;   And if you change algos all the other applications running die off&n;   due to DMA problems.  Yeah just pull the plug and watch em die.&n;&n;   If the registers get hosed&n;   main(){ioctl(open(&quot;/dev/pss&quot;),SNDCTL_PSS_SETUP_REGISTERS)};&n;&n;   Probably everything else can be done via mmap&n;&n;   Oh if you want to develop code for the ADSP-21xx or Program the&n;   1848 just send me mail and I will hook you up.&n;&n;               marc.hoffman@analog.com&n;&n;   */
macro_line|#include &quot;sound_config.h&quot;
macro_line|#if defined(CONFIGURE_SOUNDCARD) &amp;&amp; !defined(EXCLUDE_PSS)
macro_line|#ifndef PSS_MSS_BASE
DECL|macro|PSS_MSS_BASE
mdefine_line|#define PSS_MSS_BASE 0
macro_line|#endif
macro_line|#ifndef PSS_MPU_BASE
DECL|macro|PSS_MPU_BASE
mdefine_line|#define PSS_MPU_BASE 0
macro_line|#endif
macro_line|#ifndef PSS_MPU_IRQ
DECL|macro|PSS_MPU_IRQ
mdefine_line|#define PSS_MPU_IRQ 0
macro_line|#endif
DECL|macro|DEB
macro_line|#undef DEB
DECL|macro|DEB
mdefine_line|#define DEB(x) x
macro_line|#include &quot;pss.h&quot;
DECL|variable|pss_ok
r_static
r_int
id|pss_ok
op_assign
l_int|0
suffix:semicolon
DECL|variable|sb_ok
r_static
r_int
id|sb_ok
op_assign
l_int|0
suffix:semicolon
DECL|variable|pss_base
r_static
r_int
id|pss_base
suffix:semicolon
DECL|variable|pss_irq
r_static
r_int
id|pss_irq
suffix:semicolon
DECL|variable|pss_dma
r_static
r_int
id|pss_dma
suffix:semicolon
DECL|variable|gamePort
r_static
r_int
id|gamePort
op_assign
l_int|0
suffix:semicolon
DECL|variable|sbInt
r_static
r_int
id|sbInt
suffix:semicolon
DECL|variable|cdPol
r_static
r_int
id|cdPol
suffix:semicolon
DECL|variable|cdAddr
r_static
r_int
id|cdAddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0x340;&t;*/
DECL|variable|cdInt
r_static
r_int
id|cdInt
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Define these by hand in local.h */
DECL|variable|wssAddr
r_static
r_int
id|wssAddr
op_assign
id|PSS_MSS_BASE
suffix:semicolon
DECL|variable|midiAddr
r_static
r_int
id|midiAddr
op_assign
id|PSS_MPU_BASE
suffix:semicolon
DECL|variable|midiInt
r_static
r_int
id|midiInt
op_assign
id|PSS_MPU_IRQ
suffix:semicolon
DECL|variable|SoundPortAddress
r_static
r_int
id|SoundPortAddress
suffix:semicolon
DECL|variable|SoundPortData
r_static
r_int
id|SoundPortData
suffix:semicolon
DECL|variable|speaker
r_static
r_int
id|speaker
op_assign
l_int|1
suffix:semicolon
DECL|variable|default_speaker
r_static
r_struct
id|pss_speaker
id|default_speaker
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|PSS_STEREO
)brace
suffix:semicolon
id|DEFINE_WAIT_QUEUE
(paren
id|pss_sleeper
comma
id|pss_sleep_flag
)paren
suffix:semicolon
macro_line|#include &quot;synth-ld.h&quot;
r_static
r_int
id|pss_download_boot
(paren
r_int
r_char
op_star
id|block
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|pss_reset_dsp
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|pss_outpw
id|pss_outpw
(paren
r_int
r_int
id|port
comma
r_int
r_int
id|value
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;outw %w0, %w1&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;a&quot;
(paren
id|value
)paren
comma
l_string|&quot;d&quot;
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pss_inpw
id|pss_inpw
(paren
r_int
r_int
id|port
)paren
(brace
r_int
r_int
id|_v
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;inw %w1,%w0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|_v
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|port
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|_v
suffix:semicolon
)brace
r_static
r_void
DECL|function|PSS_write
id|PSS_write
(paren
r_int
id|data
)paren
(brace
r_int
id|i
comma
id|limit
suffix:semicolon
id|limit
op_assign
id|GET_TIME
(paren
)paren
op_plus
l_int|10
suffix:semicolon
multiline_comment|/* The timeout is 0.1 seconds */
multiline_comment|/*&n;   * Note! the i&lt;5000000 is an emergency exit. The dsp_command() is sometimes&n;   * called while interrupts are disabled. This means that the timer is&n;   * disabled also. However the timeout situation is a abnormal condition.&n;   * Normally the DSP should be ready to accept commands after just couple of&n;   * loops.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000000
op_logical_and
id|GET_TIME
(paren
)paren
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
)paren
op_amp
id|PSS_WRITE_EMPTY
)paren
(brace
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_DATA
comma
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;PSS: DSP Command (%04x) Timeout.&bslash;n&quot;
comma
id|data
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;IRQ conflict???&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pss_setaddr
id|pss_setaddr
(paren
r_int
id|addr
comma
r_int
id|configAddr
)paren
(brace
r_int
id|val
suffix:semicolon
id|val
op_assign
id|pss_inpw
(paren
id|configAddr
)paren
suffix:semicolon
id|val
op_and_assign
id|ADDR_MASK
suffix:semicolon
id|val
op_or_assign
(paren
id|addr
op_lshift
l_int|4
)paren
suffix:semicolon
id|pss_outpw
(paren
id|configAddr
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*_____ pss_checkint&n;         This function tests an interrupt number to see if&n;&t; it is available. It takes the interrupt button&n;&t; as it&squot;s argument and returns TRUE if the interrupt&n;&t; is ok.&n;*/
r_static
r_int
DECL|function|pss_checkint
id|pss_checkint
(paren
r_int
id|intNum
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*_____ Set the interrupt bits */
r_switch
c_cond
(paren
id|intNum
)paren
(brace
r_case
l_int|3
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_3_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_5_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_7_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_9_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_10_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_11_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_12_BITS
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;unknown interrupt selected. %d&bslash;n&quot;
comma
id|intNum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*_____ Set the interrupt test bit */
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_or_assign
id|INT_TEST_BIT
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
multiline_comment|/*_____ Check if the interrupt is in use */
multiline_comment|/*_____ Do it a few times in case there is a delay */
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|INT_TEST_PASS
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*_____ Clear the Test bit and the interrupt bits */
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_TEST_BIT_MASK
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONFIG
comma
id|val
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*____ pss_setint&n;        This function sets the correct bits in the&n;&t;configuration register to&n;&t;enable the chosen interrupt.&n;*/
r_static
r_void
DECL|function|pss_setint
id|pss_setint
(paren
r_int
id|intNum
comma
r_int
id|configAddress
)paren
(brace
r_int
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|intNum
)paren
(brace
r_case
l_int|0
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_3_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_5_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_7_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_9_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_10_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_11_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|configAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_12_BITS
suffix:semicolon
id|pss_outpw
(paren
id|configAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;pss_setint unknown int&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*____ pss_setsbint&n;        This function sets the correct bits in the&n;&t;SoundBlaster configuration PSS register to&n;&t;enable the chosen interrupt.&n;&t;It takes a interrupt button as its argument.&n;*/
r_static
r_void
DECL|function|pss_setsbint
id|pss_setsbint
(paren
r_int
id|intNum
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|sbConfigAddress
suffix:semicolon
id|sbConfigAddress
op_assign
id|pss_base
op_plus
id|SB_CONFIG
suffix:semicolon
r_switch
c_cond
(paren
id|intNum
)paren
(brace
r_case
l_int|3
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|sbConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_3_BITS
suffix:semicolon
id|pss_outpw
(paren
id|sbConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|sbConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_5_BITS
suffix:semicolon
id|pss_outpw
(paren
id|sbConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|sbConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|INT_MASK
suffix:semicolon
id|val
op_or_assign
id|INT_7_BITS
suffix:semicolon
id|pss_outpw
(paren
id|sbConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;pss_setsbint: unknown_int&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*____ pss_setsbdma&n;        This function sets the correct bits in the&n;&t;SoundBlaster configuration PSS register to&n;&t;enable the chosen DMA channel.&n;&t;It takes a DMA button as its argument.&n;*/
r_static
r_void
DECL|function|pss_setsbdma
id|pss_setsbdma
(paren
r_int
id|dmaNum
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|sbConfigAddress
suffix:semicolon
id|sbConfigAddress
op_assign
id|pss_base
op_plus
id|SB_CONFIG
suffix:semicolon
r_switch
c_cond
(paren
id|dmaNum
)paren
(brace
r_case
l_int|1
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|sbConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|DMA_MASK
suffix:semicolon
id|val
op_or_assign
id|DMA_1_BITS
suffix:semicolon
id|pss_outpw
(paren
id|sbConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Personal Sound System ERROR! pss_setsbdma: unknown_dma&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*____ pss_setwssdma&n;        This function sets the correct bits in the&n;&t;WSS configuration PSS register to&n;&t;enable the chosen DMA channel.&n;&t;It takes a DMA button as its argument.&n;*/
r_static
r_void
DECL|function|pss_setwssdma
id|pss_setwssdma
(paren
r_int
id|dmaNum
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|wssConfigAddress
suffix:semicolon
id|wssConfigAddress
op_assign
id|pss_base
op_plus
id|PSS_WSS_CONFIG
suffix:semicolon
r_switch
c_cond
(paren
id|dmaNum
)paren
(brace
r_case
l_int|0
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|wssConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|DMA_MASK
suffix:semicolon
id|val
op_or_assign
id|DMA_0_BITS
suffix:semicolon
id|pss_outpw
(paren
id|wssConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|wssConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|DMA_MASK
suffix:semicolon
id|val
op_or_assign
id|DMA_1_BITS
suffix:semicolon
id|pss_outpw
(paren
id|wssConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|val
op_assign
id|pss_inpw
(paren
id|wssConfigAddress
)paren
suffix:semicolon
id|val
op_and_assign
id|DMA_MASK
suffix:semicolon
id|val
op_or_assign
id|DMA_3_BITS
suffix:semicolon
id|pss_outpw
(paren
id|wssConfigAddress
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Personal Sound System ERROR! pss_setwssdma: unknown_dma&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*_____ SetSpeakerOut&n;         This function sets the Volume, Bass, Treble and Mode of&n;&t; the speaker out channel.&n;&t; */
r_void
DECL|function|pss_setspeaker
id|pss_setspeaker
(paren
r_struct
id|pss_speaker
op_star
id|spk
)paren
(brace
id|PSS_write
(paren
id|SET_MASTER_COMMAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spk-&gt;volume
OG
id|PHILLIPS_VOL_MAX
)paren
id|spk-&gt;volume
op_assign
id|PHILLIPS_VOL_MAX
suffix:semicolon
r_if
c_cond
(paren
id|spk-&gt;volume
OL
id|PHILLIPS_VOL_MIN
)paren
id|spk-&gt;volume
op_assign
id|PHILLIPS_VOL_MIN
suffix:semicolon
id|PSS_write
(paren
id|MASTER_VOLUME_LEFT
op_or
(paren
id|PHILLIPS_VOL_CONSTANT
op_plus
id|spk-&gt;volume
op_div
id|PHILLIPS_VOL_STEP
)paren
)paren
suffix:semicolon
id|PSS_write
(paren
id|SET_MASTER_COMMAND
)paren
suffix:semicolon
id|PSS_write
(paren
id|MASTER_VOLUME_RIGHT
op_or
(paren
id|PHILLIPS_VOL_CONSTANT
op_plus
id|spk-&gt;volume
op_div
id|PHILLIPS_VOL_STEP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spk-&gt;bass
OG
id|PHILLIPS_BASS_MAX
)paren
id|spk-&gt;bass
op_assign
id|PHILLIPS_BASS_MAX
suffix:semicolon
r_if
c_cond
(paren
id|spk-&gt;bass
OL
id|PHILLIPS_BASS_MIN
)paren
id|spk-&gt;bass
op_assign
id|PHILLIPS_BASS_MIN
suffix:semicolon
id|PSS_write
(paren
id|SET_MASTER_COMMAND
)paren
suffix:semicolon
id|PSS_write
(paren
id|MASTER_BASS
op_or
(paren
id|PHILLIPS_BASS_CONSTANT
op_plus
id|spk-&gt;bass
op_div
id|PHILLIPS_BASS_STEP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spk-&gt;treb
OG
id|PHILLIPS_TREBLE_MAX
)paren
id|spk-&gt;treb
op_assign
id|PHILLIPS_TREBLE_MAX
suffix:semicolon
r_if
c_cond
(paren
id|spk-&gt;treb
OL
id|PHILLIPS_TREBLE_MIN
)paren
id|spk-&gt;treb
op_assign
id|PHILLIPS_TREBLE_MIN
suffix:semicolon
id|PSS_write
(paren
id|SET_MASTER_COMMAND
)paren
suffix:semicolon
id|PSS_write
(paren
id|MASTER_TREBLE
op_or
(paren
id|PHILLIPS_TREBLE_CONSTANT
op_plus
id|spk-&gt;treb
op_div
id|PHILLIPS_TREBLE_STEP
)paren
)paren
suffix:semicolon
id|PSS_write
(paren
id|SET_MASTER_COMMAND
)paren
suffix:semicolon
id|PSS_write
(paren
id|MASTER_SWITCH
op_or
id|spk-&gt;mode
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pss_init1848
id|pss_init1848
(paren
r_void
)paren
(brace
multiline_comment|/*_____ Wait for 1848 to init */
r_while
c_loop
(paren
id|INB
(paren
id|SoundPortAddress
)paren
op_amp
id|SP_IN_INIT
)paren
suffix:semicolon
multiline_comment|/*_____ Wait for 1848 to autocal */
id|OUTB
(paren
id|SoundPortAddress
comma
id|SP_TEST_AND_INIT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|INB
(paren
id|SoundPortData
)paren
op_amp
id|AUTO_CAL_IN_PROG
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pss_configure_registers_to_look_like_sb
id|pss_configure_registers_to_look_like_sb
(paren
r_void
)paren
(brace
id|pss_setaddr
(paren
id|wssAddr
comma
id|pss_base
op_plus
id|PSS_WSS_CONFIG
)paren
suffix:semicolon
id|SoundPortAddress
op_assign
id|wssAddr
op_plus
l_int|4
suffix:semicolon
id|SoundPortData
op_assign
id|wssAddr
op_plus
l_int|5
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;Turning Game Port %s.&bslash;n&quot;
comma
id|gamePort
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*_____ Turn on the Game port */
r_if
c_cond
(paren
id|gamePort
)paren
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
comma
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
)paren
op_or
id|GAME_BIT
)paren
suffix:semicolon
r_else
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
comma
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
)paren
op_amp
id|GAME_BIT_MASK
)paren
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;PSS attaching base %x irq %d dma %d&bslash;n&quot;
comma
id|pss_base
comma
id|pss_irq
comma
id|pss_dma
)paren
)paren
suffix:semicolon
multiline_comment|/* Check if sb is enabled if it is check the interrupt */
id|pss_outpw
(paren
id|pss_base
op_plus
id|SB_CONFIG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_irq
op_ne
l_int|0
)paren
(brace
id|DEB
(paren
id|printk
(paren
l_string|&quot;PSS Emulating Sound Blaster ADDR %04x&bslash;n&quot;
comma
id|pss_base
)paren
)paren
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;PSS SBC: attaching base %x irq %d dma %d&bslash;n&quot;
comma
id|SBC_BASE
comma
id|SBC_IRQ
comma
id|SBC_DMA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_checkint
(paren
id|SBC_IRQ
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;PSS! attach: int_error&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pss_setsbint
(paren
id|SBC_IRQ
)paren
suffix:semicolon
id|pss_setsbdma
(paren
id|SBC_DMA
)paren
suffix:semicolon
id|sb_ok
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|sb_ok
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;PSS: sound blaster error init&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if cd is enabled if it is check the interrupt */
id|pss_outpw
(paren
id|pss_base
op_plus
id|CD_CONFIG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdAddr
op_ne
l_int|0
)paren
(brace
id|DEB
(paren
id|printk
(paren
l_string|&quot;PSS:CD drive %x irq: %d&quot;
comma
id|cdAddr
comma
id|cdInt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdInt
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pss_checkint
(paren
id|cdInt
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;Can&squot;t allocate cdInt %d&bslash;n&quot;
comma
id|cdInt
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|val
suffix:semicolon
id|printk
(paren
l_string|&quot;CD poll &quot;
)paren
suffix:semicolon
id|pss_setaddr
(paren
id|cdAddr
comma
id|pss_base
op_plus
id|CD_CONFIG
)paren
suffix:semicolon
id|pss_setint
(paren
id|cdInt
comma
id|pss_base
op_plus
id|CD_CONFIG
)paren
suffix:semicolon
multiline_comment|/* set the correct bit in the&n;&t;&t; configuration register to&n;&t;&t; set the irq polarity for the CD-Rom.&n;&t;&t; NOTE: This bit is in the address config&n;&t;&t; field, It must be configured after setting&n;&t;&t; the CD-ROM ADDRESS!!! */
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|CD_CONFIG
)paren
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|CD_CONFIG
comma
l_int|0
)paren
suffix:semicolon
id|val
op_and_assign
id|CD_POL_MASK
suffix:semicolon
r_if
c_cond
(paren
id|cdPol
)paren
id|val
op_or_assign
id|CD_POL_BIT
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|CD_CONFIG
comma
id|val
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Check if midi is enabled if it is check the interrupt */
id|pss_outpw
(paren
id|pss_base
op_plus
id|MIDI_CONFIG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|midiAddr
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;midi init %x %d&bslash;n&quot;
comma
id|midiAddr
comma
id|midiInt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_checkint
(paren
id|midiInt
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;midi init int error %x %d&bslash;n&quot;
comma
id|midiAddr
comma
id|midiInt
)paren
suffix:semicolon
)brace
r_else
(brace
id|pss_setaddr
(paren
id|midiAddr
comma
id|pss_base
op_plus
id|MIDI_CONFIG
)paren
suffix:semicolon
id|pss_setint
(paren
id|midiInt
comma
id|pss_base
op_plus
id|MIDI_CONFIG
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|attach_pss
id|attach_pss
(paren
r_int
id|mem_start
comma
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
r_if
c_cond
(paren
id|pss_ok
)paren
(brace
r_if
c_cond
(paren
id|hw_config
)paren
(brace
id|printk
(paren
l_string|&quot; &lt;PSS-ESC614&gt;&quot;
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
id|pss_ok
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pss_configure_registers_to_look_like_sb
(paren
)paren
op_eq
l_int|0
)paren
r_return
id|mem_start
suffix:semicolon
r_if
c_cond
(paren
id|sb_ok
)paren
r_if
c_cond
(paren
id|pss_synthLen
op_logical_and
id|pss_download_boot
(paren
id|pss_synth
comma
id|pss_synthLen
)paren
)paren
(brace
r_if
c_cond
(paren
id|speaker
)paren
id|pss_setspeaker
(paren
op_amp
id|default_speaker
)paren
suffix:semicolon
id|pss_ok
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|pss_reset_dsp
(paren
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
r_int
DECL|function|probe_pss
id|probe_pss
(paren
r_struct
id|address_info
op_star
id|hw_config
)paren
(brace
id|pss_base
op_assign
id|hw_config-&gt;io_base
suffix:semicolon
id|pss_irq
op_assign
id|hw_config-&gt;irq
suffix:semicolon
id|pss_dma
op_assign
id|hw_config-&gt;dma
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pss_inpw
(paren
id|pss_base
op_plus
l_int|4
)paren
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x4500
)paren
(brace
id|attach_pss
(paren
l_int|0
comma
id|hw_config
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; fail base %x irq %d dma %d&bslash;n&quot;
comma
id|pss_base
comma
id|pss_irq
comma
id|pss_dma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pss_reattach
id|pss_reattach
(paren
r_void
)paren
(brace
id|pss_ok
op_assign
l_int|0
suffix:semicolon
id|attach_pss
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|pss_reset_dsp
id|pss_reset_dsp
(paren
)paren
(brace
r_int
r_int
id|i
comma
id|limit
op_assign
id|GET_TIME
(paren
)paren
op_plus
l_int|10
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONTROL
comma
l_int|0x2000
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32768
op_logical_and
id|GET_TIME
(paren
)paren
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_CONTROL
)paren
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_CONTROL
comma
l_int|0x0000
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|pss_download_boot
id|pss_download_boot
(paren
r_int
r_char
op_star
id|block
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|limit
comma
id|val
comma
id|count
suffix:semicolon
id|printk
(paren
l_string|&quot;PSS: downloading boot code synth.ld... &quot;
)paren
suffix:semicolon
multiline_comment|/*_____ Warn DSP software that a boot is coming */
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_DATA
comma
l_int|0x00fe
)paren
suffix:semicolon
id|limit
op_assign
id|GET_TIME
(paren
)paren
op_plus
l_int|10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32768
op_logical_and
id|GET_TIME
(paren
)paren
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_DATA
)paren
op_eq
l_int|0x5500
)paren
r_break
suffix:semicolon
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_DATA
comma
op_star
id|block
op_increment
)paren
suffix:semicolon
id|pss_reset_dsp
(paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;start &quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|327670
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/*_____ Wait for BG to appear */
r_if
c_cond
(paren
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
)paren
op_amp
id|PSS_FLAG3
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
l_int|327670
)paren
(brace
multiline_comment|/* It&squot;s ok we timed out when the file was empty */
r_if
c_cond
(paren
id|count
op_ge
id|size
)paren
r_break
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;&bslash;nPSS: DownLoad timeout problems, byte %d=%d&bslash;n&quot;
comma
id|count
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*_____ Send the next byte */
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_DATA
comma
op_star
id|block
op_increment
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
multiline_comment|/*_____ Why */
id|pss_outpw
(paren
id|pss_base
op_plus
id|PSS_DATA
comma
l_int|0
)paren
suffix:semicolon
id|limit
op_assign
id|GET_TIME
(paren
)paren
op_plus
l_int|10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32768
op_logical_and
id|GET_TIME
(paren
)paren
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;downloaded&bslash;n&quot;
)paren
suffix:semicolon
id|limit
op_assign
id|GET_TIME
(paren
)paren
op_plus
l_int|10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32768
op_logical_and
id|GET_TIME
(paren
)paren
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x4000
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* now read the version */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|PSS_READ_FULL
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|32000
)paren
r_return
l_int|0
suffix:semicolon
id|val
op_assign
id|pss_inpw
(paren
id|pss_base
op_plus
id|PSS_DATA_REG
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* The following is a simple device driver for the pss.&n;   All I really care about is communication to and from the pss.&n;&n;   The ability to reinitialize the &lt;synth.ld&gt;  This will be&n;   default when release is chosen.&n;&n;   SNDCTL_PSS_DOWNLOAD:&n;&n;   Okay we need to creat new minor numbers for the&n;   DOWNLOAD functionality.&n;&n;   14,0x19 -- /dev/pssld where a read operation would output the&n;                         current ld to user space&n;                         where a write operation would effectively&n;&t;&t;&t; download a new ld.&n;&n;   14,0x09 -- /dev/psecho  would open up a communication path to the&n;                         esc614 asic.  Given the ability to send&n;&t;&t;&t; messages to the asic and receive messages too.&n;&n;&t;&t;&t; All messages would get read and written in the&n;&t;&t;&t; same manner.  It would be up to the application&n;&t;&t;&t; and the ld to maintain a relationship&n;&t;&t;&t; of what the messages mean.&n;&t;&t;&t;&n;&t;&t;&t; for this device we need to implement select. */
DECL|macro|CODE_BUFFER_LEN
mdefine_line|#define CODE_BUFFER_LEN (64*1024)
DECL|variable|code_buffer
r_static
r_char
op_star
id|code_buffer
suffix:semicolon
DECL|variable|code_length
r_static
r_int
id|code_length
suffix:semicolon
DECL|variable|lock_pss
r_static
r_int
id|lock_pss
op_assign
l_int|0
suffix:semicolon
r_int
DECL|function|pss_open
id|pss_open
(paren
r_int
id|dev
comma
r_struct
id|fileinfo
op_star
id|file
)paren
(brace
r_int
id|mode
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;pss_open&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
op_eq
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_pss
)paren
r_return
l_int|0
suffix:semicolon
id|lock_pss
op_assign
l_int|1
suffix:semicolon
id|dev
op_assign
id|dev
op_rshift
l_int|4
suffix:semicolon
id|mode
op_assign
id|file-&gt;mode
op_amp
id|O_ACCMODE
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|O_WRONLY
)paren
(brace
id|printk
(paren
l_string|&quot;pss-open for WRONLY&bslash;n&quot;
)paren
suffix:semicolon
id|code_length
op_assign
l_int|0
suffix:semicolon
)brace
id|RESET_WAIT_QUEUE
(paren
id|pss_sleeper
comma
id|pss_sleep_flag
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|pss_release
id|pss_release
(paren
r_int
id|dev
comma
r_struct
id|fileinfo
op_star
id|file
)paren
(brace
r_int
id|mode
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;pss_release&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
op_eq
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
id|dev
op_assign
id|dev
op_rshift
l_int|4
suffix:semicolon
id|mode
op_assign
id|file-&gt;mode
op_amp
id|O_ACCMODE
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|O_WRONLY
op_logical_and
id|code_length
OG
l_int|0
)paren
(brace
macro_line|#ifdef linux
multiline_comment|/* This just allows interrupts while the conversion is running */
id|__asm__
(paren
l_string|&quot;sti&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pss_download_boot
(paren
id|code_buffer
comma
id|code_length
)paren
)paren
(brace
id|pss_reattach
(paren
)paren
suffix:semicolon
)brace
)brace
id|lock_pss
op_assign
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pss_read
id|pss_read
(paren
r_int
id|dev
comma
r_struct
id|fileinfo
op_star
id|file
comma
id|snd_rw_buf
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
comma
id|p
suffix:semicolon
id|DEB
(paren
id|printk
(paren
l_string|&quot;pss_read&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
op_eq
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
id|dev
op_assign
id|dev
op_rshift
l_int|4
suffix:semicolon
id|p
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|count
suffix:semicolon
r_return
id|count
op_minus
id|c
suffix:semicolon
)brace
r_int
DECL|function|pss_write
id|pss_write
(paren
r_int
id|dev
comma
r_struct
id|fileinfo
op_star
id|file
comma
id|snd_rw_buf
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|DEB
(paren
id|printk
(paren
l_string|&quot;pss_write&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
op_eq
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
id|dev
op_assign
id|dev
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
multiline_comment|/* Flush output */
(brace
id|COPY_FROM_USER
(paren
op_amp
id|code_buffer
(braket
id|code_length
)braket
comma
id|buf
comma
l_int|0
comma
id|count
)paren
suffix:semicolon
id|code_length
op_add_assign
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
r_int
DECL|function|pss_ioctl
id|pss_ioctl
(paren
r_int
id|dev
comma
r_struct
id|fileinfo
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|DEB
(paren
id|printk
(paren
l_string|&quot;pss_ioctl dev=%d cmd=%x&bslash;n&quot;
comma
id|dev
comma
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
op_eq
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
id|dev
op_assign
id|dev
op_rshift
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDCTL_PSS_RESET
suffix:colon
id|pss_reattach
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|SNDCTL_PSS_SETUP_REGISTERS
suffix:colon
id|pss_configure_registers_to_look_like_sb
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|SNDCTL_PSS_SPEAKER
suffix:colon
(brace
r_struct
id|pss_speaker
id|params
suffix:semicolon
id|COPY_FROM_USER
(paren
op_amp
id|params
comma
(paren
r_char
op_star
)paren
id|arg
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pss_speaker
)paren
)paren
suffix:semicolon
id|pss_setspeaker
(paren
op_amp
id|params
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This is going to be used to implement&n;   waiting on messages sent from the DSP and to the&n;   DSP when communication is used via the pss directly.&n;&n;   We need to find out if the pss can generate a different&n;   interrupt other than the one it has been setup for.&n;&n;   This way we can carry on a conversation with the pss&n;   on a separate channel.  This would be useful for debugging. */
DECL|function|pss_select
id|pss_select
(paren
r_int
id|dev
comma
r_struct
id|fileinfo
op_star
id|file
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
op_eq
l_int|0
)paren
r_return
id|RET_ERROR
(paren
id|EIO
)paren
suffix:semicolon
id|dev
op_assign
id|dev
op_rshift
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
id|select_wait
(paren
op_amp
id|pss_sleeper
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
id|select_wait
(paren
op_amp
id|pss_sleeper
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|pss_init
id|pss_init
(paren
r_int
id|mem_start
)paren
(brace
id|DEB
(paren
id|printk
(paren
l_string|&quot;pss_init&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pss_ok
)paren
(brace
id|code_buffer
op_assign
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
id|CODE_BUFFER_LEN
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
macro_line|#endif
eof
