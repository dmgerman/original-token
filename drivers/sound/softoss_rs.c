multiline_comment|/*&n; * sound/softoss_rs.c&n; *&n; * Software based MIDI synthsesizer driver, the actual mixing loop.&n; * Keep the loop as simple as possible to make it easier to rewrite this &n; * routine in assembly.&n; */
multiline_comment|/*&n; * Copyright (C) by Hannu Savolainen 1993-1997&n; *&n; * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)&n; * Version 2 (June 1991). See the &quot;COPYING&quot; file distributed with this software&n; * for more info.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &quot;sound_config.h&quot;
macro_line|#ifdef CONFIG_SOFTOSS
macro_line|#include &quot;softoss.h&quot;
r_void
DECL|function|softsynth_resample_loop
id|softsynth_resample_loop
(paren
r_int
op_star
id|buf
comma
r_int
id|loops
)paren
(brace
r_int
id|iloop
comma
id|voice
suffix:semicolon
r_volatile
id|voice_info
op_star
id|v
suffix:semicolon
macro_line|#ifdef OSS_BIG_ENDIAN
r_int
r_char
op_star
id|cbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|iloop
op_assign
l_int|0
suffix:semicolon
id|iloop
OL
id|loops
suffix:semicolon
id|iloop
op_increment
)paren
(brace
multiline_comment|/* Mix one sample */
r_int
id|accum
comma
id|left
op_assign
l_int|0
comma
id|right
op_assign
l_int|0
suffix:semicolon
r_int
id|ix
comma
id|position
suffix:semicolon
r_for
c_loop
(paren
id|voice
op_assign
l_int|0
suffix:semicolon
id|voice
OL
id|devc-&gt;maxvoice
suffix:semicolon
id|voice
op_increment
)paren
r_if
c_cond
(paren
id|voice_active
(braket
id|voice
)braket
)paren
(brace
multiline_comment|/* Compute voice */
id|v
op_assign
op_amp
id|softoss_voices
(braket
id|voice
)braket
suffix:semicolon
macro_line|#ifdef SOFTOSS_TEST
id|ix
op_assign
id|iloop
op_lshift
l_int|3
suffix:semicolon
id|position
op_assign
id|v-&gt;ptr
suffix:semicolon
macro_line|#else
id|ix
op_assign
(paren
id|position
op_assign
id|v-&gt;ptr
)paren
op_rshift
l_int|9
suffix:semicolon
macro_line|#endif
multiline_comment|/* Interpolation (resolution of 512 steps) */
(brace
r_int
id|fract
op_assign
id|v-&gt;ptr
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* 9 bits */
multiline_comment|/* This method works with less arithmetic operations */
r_register
r_int
id|v1
op_assign
id|v-&gt;wave
(braket
id|ix
)braket
suffix:semicolon
id|accum
op_assign
id|v1
op_plus
(paren
(paren
(paren
(paren
id|v-&gt;wave
(braket
id|ix
op_plus
l_int|1
)braket
op_minus
id|v1
)paren
)paren
op_star
(paren
id|fract
)paren
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
id|left
op_add_assign
(paren
id|accum
op_star
id|v-&gt;leftvol
)paren
suffix:semicolon
id|right
op_add_assign
(paren
id|accum
op_star
id|v-&gt;rightvol
)paren
suffix:semicolon
multiline_comment|/* Update sample pointer */
id|position
op_add_assign
id|v-&gt;step
suffix:semicolon
r_if
c_cond
(paren
id|position
op_le
id|v-&gt;endloop
)paren
id|v-&gt;ptr
op_assign
id|position
suffix:semicolon
r_else
r_if
c_cond
(paren
id|v-&gt;mode
op_amp
id|WAVE_LOOPING
)paren
(brace
r_if
c_cond
(paren
id|v-&gt;mode
op_amp
id|WAVE_BIDIR_LOOP
)paren
(brace
id|v-&gt;mode
op_xor_assign
id|WAVE_LOOP_BACK
suffix:semicolon
multiline_comment|/* Turn around */
id|v-&gt;step
op_mul_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|position
op_sub_assign
id|v-&gt;looplen
suffix:semicolon
id|v-&gt;ptr
op_assign
id|position
suffix:semicolon
)brace
)brace
multiline_comment|/*  else leave the voice looping the current sample */
r_if
c_cond
(paren
id|v-&gt;mode
op_amp
id|WAVE_LOOP_BACK
op_logical_and
id|position
OL
id|v-&gt;startloop
)paren
(brace
r_if
c_cond
(paren
id|v-&gt;mode
op_amp
id|WAVE_BIDIR_LOOP
)paren
(brace
id|v-&gt;mode
op_xor_assign
id|WAVE_LOOP_BACK
suffix:semicolon
multiline_comment|/* Turn around */
id|v-&gt;step
op_mul_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|position
op_add_assign
id|v-&gt;looplen
suffix:semicolon
id|v-&gt;ptr
op_assign
id|position
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Compute voice */
macro_line|#if 1&t;&t;&t;&t;/* Delay */
id|left
op_add_assign
id|left_delay
(braket
id|delayp
)braket
suffix:semicolon
id|right
op_add_assign
id|right_delay
(braket
id|delayp
)braket
suffix:semicolon
id|left_delay
(braket
id|delayp
)braket
op_assign
id|right
op_rshift
l_int|2
suffix:semicolon
id|right_delay
(braket
id|delayp
)braket
op_assign
id|left
op_rshift
l_int|2
suffix:semicolon
id|delayp
op_assign
(paren
id|delayp
op_plus
l_int|1
)paren
op_mod
id|devc-&gt;delay_size
suffix:semicolon
macro_line|#endif
DECL|macro|AFTERSCALE
mdefine_line|#define AFTERSCALE devc-&gt;afterscale;
id|left
op_rshift_assign
id|AFTERSCALE
suffix:semicolon
id|right
op_rshift_assign
id|AFTERSCALE
suffix:semicolon
r_if
c_cond
(paren
id|left
OG
l_int|32767
)paren
id|left
op_assign
l_int|32767
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
op_minus
l_int|32768
)paren
id|left
op_assign
op_minus
l_int|32768
suffix:semicolon
r_if
c_cond
(paren
id|right
OG
l_int|32767
)paren
id|right
op_assign
l_int|32767
suffix:semicolon
r_if
c_cond
(paren
id|right
OL
op_minus
l_int|32768
)paren
id|right
op_assign
op_minus
l_int|32768
suffix:semicolon
macro_line|#ifdef OSS_BIG_ENDIAN
op_star
id|cbuf
op_increment
op_assign
id|left
op_amp
l_int|0xff
suffix:semicolon
op_star
id|cbuf
op_increment
op_assign
(paren
id|left
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
op_star
id|cbuf
op_increment
op_assign
id|right
op_amp
l_int|0xff
suffix:semicolon
op_star
id|cbuf
op_increment
op_assign
(paren
id|right
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
macro_line|#else
op_star
id|buf
op_increment
op_assign
id|left
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|right
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|devc-&gt;control_counter
op_increment
op_ge
id|devc-&gt;control_rate
)paren
(brace
id|devc-&gt;control_counter
op_assign
l_int|0
suffix:semicolon
id|softsyn_control_loop
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Mix one sample */
)brace
macro_line|#endif
eof
