multiline_comment|/*&n; *&t;drivers/pci/setup.c&n; *&n; * Extruded from code written by&n; *      Dave Rusling (david.rusling@reo.mts.dec.com)&n; *      David Mosberger (davidm@cs.arizona.edu)&n; *&t;David Miller (davem@redhat.com)&n; *&n; * Support routines for initializing a PCI subsystem.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
DECL|macro|DEBUG_CONFIG
mdefine_line|#define DEBUG_CONFIG 0
macro_line|#if DEBUG_CONFIG
DECL|macro|DBGC
macro_line|# define DBGC(args)     printk args
macro_line|#else
DECL|macro|DBGC
macro_line|# define DBGC(args)
macro_line|#endif
r_int
id|__init
DECL|function|pci_claim_resource
id|pci_claim_resource
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|resource
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|dev-&gt;resource
(braket
id|resource
)braket
suffix:semicolon
r_struct
id|resource
op_star
id|root
op_assign
id|pci_find_parent_resource
c_func
(paren
id|dev
comma
id|res
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|root
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If `dev&squot; is on a secondary pci bus, `root&squot; may not be&n;&t;&t;   at the origin.  In that case, adjust the resource into&n;&t;&t;   range.  */
id|res-&gt;start
op_add_assign
id|root-&gt;start
suffix:semicolon
id|res-&gt;end
op_add_assign
id|root-&gt;start
suffix:semicolon
id|err
op_assign
id|request_resource
c_func
(paren
id|root
comma
id|res
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: Address space collision on region %d &quot;
l_string|&quot;of device %s&bslash;n&quot;
comma
id|resource
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_static
r_void
DECL|function|pdev_assign_unassigned_resources
id|pdev_assign_unassigned_resources
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u32
id|min_io
comma
id|u32
id|min_mem
)paren
(brace
id|u32
id|reg
suffix:semicolon
id|u16
id|cmd
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBGC
c_func
(paren
(paren
l_string|&quot;PCI assign unassigned: (%s)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_NUM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|root
comma
op_star
id|res
suffix:semicolon
r_int
r_int
id|size
comma
id|min
suffix:semicolon
id|res
op_assign
op_amp
id|dev-&gt;resource
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
multiline_comment|/* If it is already assigned or the resource does&n;&t;&t;   not exist, there is nothing to do.  */
r_if
c_cond
(paren
id|res-&gt;parent
op_ne
l_int|NULL
op_logical_or
id|res-&gt;flags
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Determine the root we allocate from.  */
id|root
op_assign
id|pci_find_parent_resource
c_func
(paren
id|dev
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|min
op_assign
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
ques
c_cond
id|min_io
suffix:colon
id|min_mem
)paren
suffix:semicolon
id|min
op_add_assign
id|root-&gt;start
suffix:semicolon
id|size
op_assign
id|res-&gt;end
op_minus
id|res-&gt;start
op_plus
l_int|1
suffix:semicolon
id|DBGC
c_func
(paren
(paren
l_string|&quot;  for root[%lx:%lx] min[%lx] size[%lx]&bslash;n&quot;
comma
id|root-&gt;start
comma
id|root-&gt;end
comma
id|min
comma
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allocate_resource
c_func
(paren
id|root
comma
id|res
comma
id|size
comma
id|min
comma
op_minus
l_int|1
comma
id|size
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: Failed to allocate resource %d for %s&bslash;n&quot;
comma
id|i
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|DBGC
c_func
(paren
(paren
l_string|&quot;  got res[%lx:%lx] for resource %d&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Update PCI config space.  */
id|pcibios_update_resource
c_func
(paren
id|dev
comma
id|root
comma
id|res
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Special case, disable the ROM.  Several devices act funny&n;&t;   (ie. do not respond to memory space writes) when it is left&n;&t;   enabled.  A good example are QlogicISP adapters.  */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_ROM_ADDRESS
comma
op_amp
id|reg
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
id|PCI_ROM_ADDRESS_ENABLE
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PCI_ROM_ADDRESS
comma
id|reg
)paren
suffix:semicolon
multiline_comment|/* All of these (may) have I/O scattered all around and may not&n;&t;   use I/O base address registers at all.  So we just have to&n;&t;   always enable IO to these devices.  */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_NOT_DEFINED
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_NOT_DEFINED_VGA
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
)brace
multiline_comment|/* ??? Always turn on bus mastering.  If the device doesn&squot;t support&n;&t;   it, the bit will go into the bucket. */
id|cmd
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
multiline_comment|/* Enable the appropriate bits in the PCI command register.  */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
id|DBGC
c_func
(paren
(paren
l_string|&quot;  cmd reg 0x%x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/* If this is a PCI bridge, set the cache line correctly.  */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_CACHE_LINE_SIZE
comma
(paren
id|L1_CACHE_BYTES
op_div
r_sizeof
(paren
id|u32
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
r_void
id|__init
DECL|function|pci_assign_unassigned_resources
id|pci_assign_unassigned_resources
c_func
(paren
id|u32
id|min_io
comma
id|u32
id|min_mem
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
id|pdev_assign_unassigned_resources
c_func
(paren
id|dev
comma
id|min_io
comma
id|min_mem
)paren
suffix:semicolon
)brace
DECL|struct|pbus_set_ranges_data
r_struct
id|pbus_set_ranges_data
(brace
DECL|member|found_vga
r_int
id|found_vga
suffix:semicolon
DECL|member|io_start
DECL|member|io_end
r_int
r_int
id|io_start
comma
id|io_end
suffix:semicolon
DECL|member|mem_start
DECL|member|mem_end
r_int
r_int
id|mem_start
comma
id|mem_end
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x, a)&t;&t;(((x) + (a) - 1) &amp; ~((a) - 1))
DECL|macro|ROUND_DOWN
mdefine_line|#define ROUND_DOWN(x, a)&t;((x) &amp; ~((a) - 1))
r_static
r_void
id|__init
DECL|function|pbus_set_ranges
id|pbus_set_ranges
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_struct
id|pbus_set_ranges_data
op_star
id|outer
)paren
(brace
r_struct
id|pbus_set_ranges_data
id|inner
suffix:semicolon
r_struct
id|pci_bus
op_star
id|child
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|inner.found_vga
op_assign
l_int|0
suffix:semicolon
id|inner.mem_start
op_assign
id|inner.io_start
op_assign
op_complement
l_int|0
suffix:semicolon
id|inner.mem_end
op_assign
id|inner.io_end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Collect information about how our direct children are layed out. */
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_NUM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|dev-&gt;resource
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;start
OL
id|inner.io_start
)paren
id|inner.io_start
op_assign
id|res-&gt;start
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;end
OG
id|inner.io_end
)paren
id|inner.io_end
op_assign
id|res-&gt;end
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;start
OL
id|inner.mem_start
)paren
id|inner.mem_start
op_assign
id|res-&gt;start
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;end
OG
id|inner.mem_end
)paren
id|inner.mem_end
op_assign
id|res-&gt;end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_DISPLAY_VGA
)paren
id|inner.found_vga
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* And for all of the sub-busses.  */
r_for
c_loop
(paren
id|child
op_assign
id|bus-&gt;children
suffix:semicolon
id|child
suffix:semicolon
id|child
op_assign
id|child-&gt;next
)paren
id|pbus_set_ranges
c_func
(paren
id|child
comma
op_amp
id|inner
)paren
suffix:semicolon
multiline_comment|/* Align the values.  */
id|inner.io_start
op_assign
id|ROUND_DOWN
c_func
(paren
id|inner.io_start
comma
l_int|4
op_star
l_int|1024
)paren
suffix:semicolon
id|inner.io_end
op_assign
id|ROUND_UP
c_func
(paren
id|inner.io_end
comma
l_int|4
op_star
l_int|1024
)paren
suffix:semicolon
id|inner.mem_start
op_assign
id|ROUND_DOWN
c_func
(paren
id|inner.mem_start
comma
l_int|1
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|inner.mem_end
op_assign
id|ROUND_UP
c_func
(paren
id|inner.mem_end
comma
l_int|1
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* Configure the bridge, if possible.  */
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
r_struct
id|pci_dev
op_star
id|bridge
op_assign
id|bus-&gt;self
suffix:semicolon
id|u32
id|l
suffix:semicolon
multiline_comment|/* Set up the top and bottom of the PCI I/O segment&n;                   for this bus.  */
id|pci_read_config_dword
c_func
(paren
id|bridge
comma
id|PCI_IO_BASE
comma
op_amp
id|l
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xffff0000
suffix:semicolon
id|l
op_or_assign
(paren
id|inner.io_start
op_rshift
l_int|8
)paren
op_amp
l_int|0x00f0
suffix:semicolon
id|l
op_or_assign
(paren
id|inner.io_end
op_minus
l_int|1
)paren
op_amp
l_int|0xf000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_IO_BASE
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Clear out the upper 16 bits of IO base/limit.&n;                 * Clear out the upper 32 bits of PREF base/limit.&n;                 */
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_IO_BASE_UPPER16
comma
l_int|0
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_PREF_BASE_UPPER32
comma
l_int|0
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_PREF_LIMIT_UPPER32
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set up the top and bottom of the PCI Memory segment&n;                   for this bus.  */
id|l
op_assign
(paren
id|inner.mem_start
op_amp
l_int|0xfff00000
)paren
op_rshift
l_int|16
suffix:semicolon
id|l
op_or_assign
(paren
id|inner.mem_end
op_minus
l_int|1
)paren
op_amp
l_int|0xfff00000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_MEMORY_BASE
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Turn off downstream PF memory address range, unless&n;                 * there is a VGA behind this bridge, in which case, we&n;                 * enable the PREFETCH range to include BIOS ROM at C0000.&n;                 *&n;                 * NOTE: this is a bit of a hack, done with PREFETCH for&n;                 * simplicity, rather than having to add it into the above&n;                 * non-PREFETCH range, which could then be bigger than we want.&n;                 * We might assume that we could relocate the BIOS ROM, but&n;                 * that would depend on having it found by those who need it&n;                 * (the DEC BIOS emulator would find it, but I do not know&n;                 * about the Xservers). So, we do it this way for now... ;-)&n;                 */
id|l
op_assign
(paren
id|inner.found_vga
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x0000ffff
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_PREF_MEMORY_BASE
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Tell bridge that there is an ISA bus in the system,&n;                 * and (possibly) a VGA as well.&n;                 */
id|l
op_assign
(paren
id|inner.found_vga
)paren
ques
c_cond
l_int|0x0c
suffix:colon
l_int|0x04
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|bridge
comma
id|PCI_BRIDGE_CONTROL
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Clear status bits,&n;                 * turn on I/O    enable (for downstream I/O),&n;                 * turn on memory enable (for downstream memory),&n;                 * turn on master enable (for upstream memory and I/O).&n;                 */
id|pci_write_config_dword
c_func
(paren
id|bridge
comma
id|PCI_COMMAND
comma
l_int|0xffff0007
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|outer
)paren
(brace
id|outer-&gt;found_vga
op_or_assign
id|inner.found_vga
suffix:semicolon
r_if
c_cond
(paren
id|inner.io_start
OL
id|outer-&gt;io_start
)paren
id|outer-&gt;io_start
op_assign
id|inner.io_start
suffix:semicolon
r_if
c_cond
(paren
id|inner.io_end
OG
id|outer-&gt;io_end
)paren
id|outer-&gt;io_end
op_assign
id|inner.io_end
suffix:semicolon
r_if
c_cond
(paren
id|inner.mem_start
OL
id|outer-&gt;mem_start
)paren
id|outer-&gt;mem_start
op_assign
id|inner.mem_start
suffix:semicolon
r_if
c_cond
(paren
id|inner.mem_end
OG
id|outer-&gt;mem_end
)paren
id|outer-&gt;mem_end
op_assign
id|inner.mem_end
suffix:semicolon
)brace
)brace
r_void
id|__init
DECL|function|pci_set_bus_ranges
id|pci_set_bus_ranges
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_for
c_loop
(paren
id|bus
op_assign
id|pci_root
suffix:semicolon
id|bus
suffix:semicolon
id|bus
op_assign
id|bus-&gt;next
)paren
id|pbus_set_ranges
c_func
(paren
id|bus
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pdev_fixup_irq
id|pdev_fixup_irq
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u8
(paren
op_star
id|swizzle
)paren
(paren
r_struct
id|pci_dev
op_star
comma
id|u8
op_star
)paren
comma
r_int
(paren
op_star
id|map_irq
)paren
(paren
r_struct
id|pci_dev
op_star
comma
id|u8
comma
id|u8
)paren
)paren
(brace
id|u8
id|pin
comma
id|slot
suffix:semicolon
r_int
id|irq
suffix:semicolon
multiline_comment|/* If this device is not on the primary bus, we need to figure out&n;&t;   which interrupt pin it will come in on.   We know which slot it&n;&t;   will come in on &squot;cos that slot is where the bridge is.   Each&n;&t;   time the interrupt line passes through a PCI-PCI bridge we must&n;&t;   apply the swizzle function.  */
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
multiline_comment|/* Cope with 0 and illegal. */
r_if
c_cond
(paren
id|pin
op_eq
l_int|0
op_logical_or
id|pin
OG
l_int|4
)paren
id|pin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Follow the chain of bridges, swizzling as we go.  */
id|slot
op_assign
(paren
op_star
id|swizzle
)paren
(paren
id|dev
comma
op_amp
id|pin
)paren
suffix:semicolon
id|irq
op_assign
(paren
op_star
id|map_irq
)paren
(paren
id|dev
comma
id|slot
comma
id|pin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
op_minus
l_int|1
)paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|DBGC
c_func
(paren
(paren
l_string|&quot;PCI fixup irq: (%s) got %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
)paren
suffix:semicolon
multiline_comment|/* Always tell the device, so the driver knows what is&n;&t;   the real IRQ to use; the device does not use it. */
id|pcibios_update_irq
c_func
(paren
id|dev
comma
id|irq
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|pci_fixup_irqs
id|pci_fixup_irqs
c_func
(paren
id|u8
(paren
op_star
id|swizzle
)paren
(paren
r_struct
id|pci_dev
op_star
comma
id|u8
op_star
)paren
comma
r_int
(paren
op_star
id|map_irq
)paren
(paren
r_struct
id|pci_dev
op_star
comma
id|u8
comma
id|u8
)paren
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
id|pdev_fixup_irq
c_func
(paren
id|dev
comma
id|swizzle
comma
id|map_irq
)paren
suffix:semicolon
)brace
eof
