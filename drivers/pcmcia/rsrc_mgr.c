multiline_comment|/*======================================================================&n;&n;    Resource management routines&n;&n;    rsrc_mgr.c 1.79 2000/08/30 20:23:58&n;&n;    The contents of this file are subject to the Mozilla Public&n;    License Version 1.1 (the &quot;License&quot;); you may not use this file&n;    except in compliance with the License. You may obtain a copy of&n;    the License at http://www.mozilla.org/MPL/&n;&n;    Software distributed under the License is distributed on an &quot;AS&n;    IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or&n;    implied. See the License for the specific language governing&n;    rights and limitations under the License.&n;&n;    The initial developer of the original code is David A. Hinds&n;    &lt;dahinds@users.sourceforge.net&gt;.  Portions created by David A. Hinds&n;    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.&n;&n;    Alternatively, the contents of this file may be used under the&n;    terms of the GNU Public License version 2 (the &quot;GPL&quot;), in which&n;    case the provisions of the GPL are applicable instead of the&n;    above.  If you wish to allow the use of your version of this file&n;    only under the terms of the GPL and not to allow others to use&n;    your version of this file under the MPL, indicate your decision&n;    by deleting the provisions above and replace them with the notice&n;    and other provisions required by the GPL.  If you do not delete&n;    the provisions above, a recipient may use your version of this&n;    file under either the MPL or the GPL.&n;    &n;======================================================================*/
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;pcmcia/cs_types.h&gt;
macro_line|#include &lt;pcmcia/ss.h&gt;
macro_line|#include &lt;pcmcia/cs.h&gt;
macro_line|#include &lt;pcmcia/bulkmem.h&gt;
macro_line|#include &lt;pcmcia/cistpl.h&gt;
macro_line|#include &quot;cs_internal.h&quot;
macro_line|#include &quot;rsrc_mgr.h&quot;
multiline_comment|/*====================================================================*/
multiline_comment|/* Parameters that can be set with &squot;insmod&squot; */
DECL|macro|INT_MODULE_PARM
mdefine_line|#define INT_MODULE_PARM(n, v) static int n = v; MODULE_PARM(n, &quot;i&quot;)
id|INT_MODULE_PARM
c_func
(paren
id|probe_mem
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* memory probe? */
macro_line|#ifdef CONFIG_ISA
id|INT_MODULE_PARM
c_func
(paren
id|probe_io
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* IO port probe? */
id|INT_MODULE_PARM
c_func
(paren
id|mem_limit
comma
l_int|0x10000
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    The resource_map_t structures are used to track what resources are&n;    available for allocation for PC Card devices.&n;&n;======================================================================*/
DECL|struct|resource_map_t
r_typedef
r_struct
id|resource_map_t
(brace
DECL|member|base
DECL|member|num
id|u_long
id|base
comma
id|num
suffix:semicolon
DECL|member|next
r_struct
id|resource_map_t
op_star
id|next
suffix:semicolon
DECL|typedef|resource_map_t
)brace
id|resource_map_t
suffix:semicolon
multiline_comment|/* Memory resource database */
DECL|variable|mem_db
r_static
id|resource_map_t
id|mem_db
op_assign
(brace
l_int|0
comma
l_int|0
comma
op_amp
id|mem_db
)brace
suffix:semicolon
multiline_comment|/* IO port resource database */
DECL|variable|io_db
r_static
id|resource_map_t
id|io_db
op_assign
(brace
l_int|0
comma
l_int|0
comma
op_amp
id|io_db
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_ISA
DECL|struct|irq_info_t
r_typedef
r_struct
id|irq_info_t
(brace
DECL|member|Attributes
id|u_int
id|Attributes
suffix:semicolon
DECL|member|time_share
DECL|member|dyn_share
r_int
id|time_share
comma
id|dyn_share
suffix:semicolon
DECL|member|Socket
r_struct
id|socket_info_t
op_star
id|Socket
suffix:semicolon
DECL|typedef|irq_info_t
)brace
id|irq_info_t
suffix:semicolon
multiline_comment|/* Table of IRQ assignments */
DECL|variable|irq_table
r_static
id|irq_info_t
id|irq_table
(braket
id|NR_IRQS
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* etc */
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    Linux resource management extensions&n;&n;======================================================================*/
DECL|macro|check_io_resource
mdefine_line|#define check_io_resource(b,n)&t;check_resource(&amp;ioport_resource, (b), (n))
DECL|macro|check_mem_resource
mdefine_line|#define check_mem_resource(b,n)&t;check_resource(&amp;iomem_resource, (b), (n))
multiline_comment|/*======================================================================&n;&n;    These manage the internal databases of available resources.&n;    &n;======================================================================*/
DECL|function|add_interval
r_static
r_int
id|add_interval
c_func
(paren
id|resource_map_t
op_star
id|map
comma
id|u_long
id|base
comma
id|u_long
id|num
)paren
(brace
id|resource_map_t
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|map
suffix:semicolon
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_ne
id|map
)paren
op_logical_and
(paren
id|p-&gt;base
op_plus
id|p-&gt;num
op_minus
l_int|1
op_ge
id|base
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;next
op_eq
id|map
)paren
op_logical_or
(paren
id|p-&gt;next-&gt;base
OG
id|base
op_plus
id|num
op_minus
l_int|1
)paren
)paren
r_break
suffix:semicolon
)brace
id|q
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|resource_map_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
id|CS_OUT_OF_RESOURCE
suffix:semicolon
id|q-&gt;base
op_assign
id|base
suffix:semicolon
id|q-&gt;num
op_assign
id|num
suffix:semicolon
id|q-&gt;next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
id|q
suffix:semicolon
r_return
id|CS_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|sub_interval
r_static
r_int
id|sub_interval
c_func
(paren
id|resource_map_t
op_star
id|map
comma
id|u_long
id|base
comma
id|u_long
id|num
)paren
(brace
id|resource_map_t
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|map
suffix:semicolon
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
id|map
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q-&gt;base
op_plus
id|q-&gt;num
OG
id|base
)paren
op_logical_and
(paren
id|base
op_plus
id|num
OG
id|q-&gt;base
)paren
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;base
op_ge
id|base
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;base
op_plus
id|q-&gt;num
op_le
id|base
op_plus
id|num
)paren
(brace
multiline_comment|/* Delete whole block */
id|p-&gt;next
op_assign
id|q-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* don&squot;t advance the pointer yet */
id|q
op_assign
id|p
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Cut off bit from the front */
id|q-&gt;num
op_assign
id|q-&gt;base
op_plus
id|q-&gt;num
op_minus
id|base
op_minus
id|num
suffix:semicolon
id|q-&gt;base
op_assign
id|base
op_plus
id|num
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|q-&gt;base
op_plus
id|q-&gt;num
op_le
id|base
op_plus
id|num
)paren
(brace
multiline_comment|/* Cut off bit from the end */
id|q-&gt;num
op_assign
id|base
op_minus
id|q-&gt;base
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Split the block into two pieces */
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|resource_map_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
id|CS_OUT_OF_RESOURCE
suffix:semicolon
id|p-&gt;base
op_assign
id|base
op_plus
id|num
suffix:semicolon
id|p-&gt;num
op_assign
id|q-&gt;base
op_plus
id|q-&gt;num
op_minus
id|p-&gt;base
suffix:semicolon
id|q-&gt;num
op_assign
id|base
op_minus
id|q-&gt;base
suffix:semicolon
id|p-&gt;next
op_assign
id|q-&gt;next
suffix:semicolon
id|q-&gt;next
op_assign
id|p
suffix:semicolon
)brace
)brace
)brace
r_return
id|CS_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    These routines examine a region of IO or memory addresses to&n;    determine what ranges might be genuinely available.&n;    &n;======================================================================*/
macro_line|#ifdef CONFIG_ISA
DECL|function|do_io_probe
r_static
r_void
id|do_io_probe
c_func
(paren
id|ioaddr_t
id|base
comma
id|ioaddr_t
id|num
)paren
(brace
id|ioaddr_t
id|i
comma
id|j
comma
id|bad
comma
id|any
suffix:semicolon
id|u_char
op_star
id|b
comma
id|hole
comma
id|most
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs: IO port probe 0x%04x-0x%04x:&quot;
comma
id|base
comma
id|base
op_plus
id|num
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* First, what does a floating port look like? */
id|b
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|b
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|base
comma
id|most
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base
op_plus
id|num
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|check_io_resource
c_func
(paren
id|i
comma
l_int|8
)paren
)paren
r_continue
suffix:semicolon
id|hole
op_assign
id|inb
c_func
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|inb
c_func
(paren
id|i
op_plus
id|j
)paren
op_ne
id|hole
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_eq
l_int|8
)paren
op_logical_and
(paren
op_increment
id|b
(braket
id|hole
)braket
OG
id|b
(braket
id|most
)braket
)paren
)paren
id|most
op_assign
id|hole
suffix:semicolon
r_if
c_cond
(paren
id|b
(braket
id|most
)braket
op_eq
l_int|127
)paren
r_break
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|b
)paren
suffix:semicolon
id|bad
op_assign
id|any
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|base
suffix:semicolon
id|i
OL
id|base
op_plus
id|num
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|check_io_resource
c_func
(paren
id|i
comma
l_int|8
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|inb
c_func
(paren
id|i
op_plus
id|j
)paren
op_ne
id|most
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|any
)paren
id|printk
c_func
(paren
l_string|&quot; excluding&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bad
)paren
id|bad
op_assign
id|any
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|bad
)paren
(brace
id|sub_interval
c_func
(paren
op_amp
id|io_db
comma
id|bad
comma
id|i
op_minus
id|bad
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %#04x-%#04x&quot;
comma
id|bad
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bad
)paren
(brace
r_if
c_cond
(paren
(paren
id|num
OG
l_int|16
)paren
op_logical_and
(paren
id|bad
op_eq
id|base
)paren
op_logical_and
(paren
id|i
op_eq
id|base
op_plus
id|num
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; nothing: probe failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|sub_interval
c_func
(paren
op_amp
id|io_db
comma
id|bad
comma
id|i
op_minus
id|bad
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %#04x-%#04x&quot;
comma
id|bad
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|any
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot; clean.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    The memory probe.  If the memory list includes a 64K-aligned block&n;    below 1MB, we probe in 64K chunks, and as soon as we accumulate at&n;    least mem_limit free space, we quit.&n;    &n;======================================================================*/
DECL|function|do_mem_probe
r_static
r_int
id|do_mem_probe
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|num
comma
r_int
(paren
op_star
id|is_valid
)paren
(paren
id|u_long
)paren
comma
r_int
(paren
op_star
id|do_cksum
)paren
(paren
id|u_long
)paren
)paren
(brace
id|u_long
id|i
comma
id|j
comma
id|bad
comma
id|fail
comma
id|step
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs: memory probe 0x%06lx-0x%06lx:&quot;
comma
id|base
comma
id|base
op_plus
id|num
op_minus
l_int|1
)paren
suffix:semicolon
id|bad
op_assign
id|fail
op_assign
l_int|0
suffix:semicolon
id|step
op_assign
(paren
id|num
OL
l_int|0x20000
)paren
ques
c_cond
l_int|0x2000
suffix:colon
(paren
(paren
id|num
op_rshift
l_int|4
)paren
op_amp
op_complement
l_int|0x1fff
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|base
suffix:semicolon
id|i
OL
id|base
op_plus
id|num
suffix:semicolon
id|i
op_assign
id|j
op_plus
id|step
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fail
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|base
op_plus
id|num
suffix:semicolon
id|j
op_add_assign
id|step
)paren
r_if
c_cond
(paren
(paren
id|check_mem_resource
c_func
(paren
id|j
comma
id|step
)paren
op_eq
l_int|0
)paren
op_logical_and
id|is_valid
c_func
(paren
id|j
)paren
)paren
r_break
suffix:semicolon
id|fail
op_assign
(paren
(paren
id|i
op_eq
id|base
)paren
op_logical_and
(paren
id|j
op_eq
id|base
op_plus
id|num
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fail
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|base
op_plus
id|num
suffix:semicolon
id|j
op_add_assign
l_int|2
op_star
id|step
)paren
r_if
c_cond
(paren
(paren
id|check_mem_resource
c_func
(paren
id|j
comma
l_int|2
op_star
id|step
)paren
op_eq
l_int|0
)paren
op_logical_and
id|do_cksum
c_func
(paren
id|j
)paren
op_logical_and
id|do_cksum
c_func
(paren
id|j
op_plus
id|step
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bad
)paren
id|printk
c_func
(paren
l_string|&quot; excluding&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %#05lx-%#05lx&quot;
comma
id|i
comma
id|j
op_minus
l_int|1
)paren
suffix:semicolon
id|sub_interval
c_func
(paren
op_amp
id|mem_db
comma
id|i
comma
id|j
op_minus
id|i
)paren
suffix:semicolon
id|bad
op_add_assign
id|j
op_minus
id|i
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|bad
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot; clean.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|num
op_minus
id|bad
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ISA
DECL|function|inv_probe
r_static
id|u_long
id|inv_probe
c_func
(paren
r_int
(paren
op_star
id|is_valid
)paren
(paren
id|u_long
)paren
comma
r_int
(paren
op_star
id|do_cksum
)paren
(paren
id|u_long
)paren
comma
id|resource_map_t
op_star
id|m
)paren
(brace
id|u_long
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
op_amp
id|mem_db
)paren
r_return
l_int|0
suffix:semicolon
id|ok
op_assign
id|inv_probe
c_func
(paren
id|is_valid
comma
id|do_cksum
comma
id|m-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
)paren
(brace
r_if
c_cond
(paren
id|m-&gt;base
op_ge
l_int|0x100000
)paren
id|sub_interval
c_func
(paren
op_amp
id|mem_db
comma
id|m-&gt;base
comma
id|m-&gt;num
)paren
suffix:semicolon
r_return
id|ok
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;base
OL
l_int|0x100000
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|do_mem_probe
c_func
(paren
id|m-&gt;base
comma
id|m-&gt;num
comma
id|is_valid
comma
id|do_cksum
)paren
suffix:semicolon
)brace
DECL|function|validate_mem
r_void
id|validate_mem
c_func
(paren
r_int
(paren
op_star
id|is_valid
)paren
(paren
id|u_long
)paren
comma
r_int
(paren
op_star
id|do_cksum
)paren
(paren
id|u_long
)paren
comma
r_int
id|force_low
)paren
(brace
id|resource_map_t
op_star
id|m
comma
op_star
id|n
suffix:semicolon
r_static
id|u_char
id|order
(braket
)braket
op_assign
(brace
l_int|0xd0
comma
l_int|0xe0
comma
l_int|0xc0
comma
l_int|0xf0
)brace
suffix:semicolon
r_static
r_int
id|hi
op_assign
l_int|0
comma
id|lo
op_assign
l_int|0
suffix:semicolon
id|u_long
id|b
comma
id|i
comma
id|ok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_mem
)paren
r_return
suffix:semicolon
multiline_comment|/* We do up to four passes through the list */
r_if
c_cond
(paren
op_logical_neg
id|force_low
)paren
(brace
r_if
c_cond
(paren
id|hi
op_increment
op_logical_or
(paren
id|inv_probe
c_func
(paren
id|is_valid
comma
id|do_cksum
comma
id|mem_db.next
)paren
OG
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cs: warning: no high memory space &quot;
l_string|&quot;available!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lo
op_increment
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|mem_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|mem_db
suffix:semicolon
id|m
op_assign
id|n
)paren
(brace
id|n
op_assign
id|m-&gt;next
suffix:semicolon
multiline_comment|/* Only probe &lt; 1 MB */
r_if
c_cond
(paren
id|m-&gt;base
op_ge
l_int|0x100000
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|m-&gt;base
op_or
id|m-&gt;num
)paren
op_amp
l_int|0xffff
)paren
(brace
id|ok
op_add_assign
id|do_mem_probe
c_func
(paren
id|m-&gt;base
comma
id|m-&gt;num
comma
id|is_valid
comma
id|do_cksum
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Special probe for 64K-aligned block */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
op_assign
id|order
(braket
id|i
)braket
op_lshift
l_int|12
suffix:semicolon
r_if
c_cond
(paren
(paren
id|b
op_ge
id|m-&gt;base
)paren
op_logical_and
(paren
id|b
op_plus
l_int|0x10000
op_le
id|m-&gt;base
op_plus
id|m-&gt;num
)paren
)paren
(brace
r_if
c_cond
(paren
id|ok
op_ge
id|mem_limit
)paren
id|sub_interval
c_func
(paren
op_amp
id|mem_db
comma
id|b
comma
l_int|0x10000
)paren
suffix:semicolon
r_else
id|ok
op_add_assign
id|do_mem_probe
c_func
(paren
id|b
comma
l_int|0x10000
comma
id|is_valid
comma
id|do_cksum
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#else /* CONFIG_ISA */
DECL|function|validate_mem
r_void
id|validate_mem
c_func
(paren
r_int
(paren
op_star
id|is_valid
)paren
(paren
id|u_long
)paren
comma
r_int
(paren
op_star
id|do_cksum
)paren
(paren
id|u_long
)paren
comma
r_int
id|force_low
)paren
(brace
id|resource_map_t
op_star
id|m
suffix:semicolon
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_mem
op_logical_or
id|done
op_increment
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|mem_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|mem_db
suffix:semicolon
id|m
op_assign
id|m-&gt;next
)paren
r_if
c_cond
(paren
id|do_mem_probe
c_func
(paren
id|m-&gt;base
comma
id|m-&gt;num
comma
id|is_valid
comma
id|do_cksum
)paren
)paren
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ISA */
multiline_comment|/*======================================================================&n;&n;    These find ranges of I/O ports or memory addresses that are not&n;    currently allocated by other devices.&n;&n;    The &squot;align&squot; field should reflect the number of bits of address&n;    that need to be preserved from the initial value of *base.  It&n;    should be a power of two, greater than or equal to &squot;num&squot;.  A value&n;    of 0 means that all bits of *base are significant.  *base should&n;    also be strictly less than &squot;align&squot;.&n;    &n;======================================================================*/
DECL|function|find_io_region
r_int
id|find_io_region
c_func
(paren
id|ioaddr_t
op_star
id|base
comma
id|ioaddr_t
id|num
comma
id|ioaddr_t
id|align
comma
r_char
op_star
id|name
)paren
(brace
id|ioaddr_t
r_try
suffix:semicolon
id|resource_map_t
op_star
id|m
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|io_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|io_db
suffix:semicolon
id|m
op_assign
id|m-&gt;next
)paren
(brace
r_try
op_assign
(paren
id|m-&gt;base
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
)paren
op_plus
op_star
id|base
suffix:semicolon
r_for
c_loop
(paren
r_try
op_assign
(paren
r_try
op_ge
id|m-&gt;base
)paren
ques
c_cond
r_try
suffix:colon
r_try
op_plus
id|align
suffix:semicolon
(paren
r_try
op_ge
id|m-&gt;base
)paren
op_logical_and
(paren
r_try
op_plus
id|num
op_le
id|m-&gt;base
op_plus
id|m-&gt;num
)paren
suffix:semicolon
r_try
op_add_assign
id|align
)paren
(brace
r_if
c_cond
(paren
id|check_io_resource
c_func
(paren
r_try
comma
id|num
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|base
op_assign
r_try
suffix:semicolon
id|request_region
c_func
(paren
r_try
comma
id|num
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|align
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|find_mem_region
r_int
id|find_mem_region
c_func
(paren
id|u_long
op_star
id|base
comma
id|u_long
id|num
comma
id|u_long
id|align
comma
r_int
id|force_low
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
r_try
suffix:semicolon
id|resource_map_t
op_star
id|m
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|m
op_assign
id|mem_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|mem_db
suffix:semicolon
id|m
op_assign
id|m-&gt;next
)paren
(brace
multiline_comment|/* first pass &gt;1MB, second pass &lt;1MB */
r_if
c_cond
(paren
(paren
id|force_low
op_ne
l_int|0
)paren
op_xor
(paren
id|m-&gt;base
OL
l_int|0x100000
)paren
)paren
r_continue
suffix:semicolon
r_try
op_assign
(paren
id|m-&gt;base
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
)paren
op_plus
op_star
id|base
suffix:semicolon
r_for
c_loop
(paren
r_try
op_assign
(paren
r_try
op_ge
id|m-&gt;base
)paren
ques
c_cond
r_try
suffix:colon
r_try
op_plus
id|align
suffix:semicolon
(paren
r_try
op_ge
id|m-&gt;base
)paren
op_logical_and
(paren
r_try
op_plus
id|num
op_le
id|m-&gt;base
op_plus
id|m-&gt;num
)paren
suffix:semicolon
r_try
op_add_assign
id|align
)paren
(brace
r_if
c_cond
(paren
id|check_mem_resource
c_func
(paren
r_try
comma
id|num
)paren
op_eq
l_int|0
)paren
(brace
id|request_mem_region
c_func
(paren
r_try
comma
id|num
comma
id|name
)paren
suffix:semicolon
op_star
id|base
op_assign
r_try
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|align
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|force_low
)paren
r_break
suffix:semicolon
id|force_low
op_increment
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    This checks to see if an interrupt is available, with support&n;    for interrupt sharing.  We don&squot;t support reserving interrupts&n;    yet.  If the interrupt is available, we allocate it.&n;    &n;======================================================================*/
macro_line|#ifdef CONFIG_ISA
DECL|function|fake_irq
r_static
r_void
id|fake_irq
c_func
(paren
r_int
id|i
comma
r_void
op_star
id|d
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
)brace
DECL|function|check_irq
r_static
r_inline
r_int
id|check_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|fake_irq
comma
l_int|0
comma
l_string|&quot;bogus&quot;
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_irq
r_int
id|try_irq
c_func
(paren
id|u_int
id|Attributes
comma
r_int
id|irq
comma
r_int
id|specific
)paren
(brace
id|irq_info_t
op_star
id|info
op_assign
op_amp
id|irq_table
(braket
id|irq
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_ALLOCATED
)paren
(brace
r_switch
c_cond
(paren
id|Attributes
op_amp
id|IRQ_TYPE
)paren
(brace
r_case
id|IRQ_TYPE_EXCLUSIVE
suffix:colon
r_return
id|CS_IN_USE
suffix:semicolon
r_case
id|IRQ_TYPE_TIME
suffix:colon
r_if
c_cond
(paren
(paren
id|info-&gt;Attributes
op_amp
id|RES_IRQ_TYPE
)paren
op_ne
id|RES_IRQ_TYPE_TIME
)paren
r_return
id|CS_IN_USE
suffix:semicolon
r_if
c_cond
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
r_return
id|CS_BAD_ATTRIBUTE
suffix:semicolon
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_TIME
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;time_share
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_DYNAMIC_SHARING
suffix:colon
r_if
c_cond
(paren
(paren
id|info-&gt;Attributes
op_amp
id|RES_IRQ_TYPE
)paren
op_ne
id|RES_IRQ_TYPE_DYNAMIC
)paren
r_return
id|CS_IN_USE
suffix:semicolon
r_if
c_cond
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
r_return
id|CS_BAD_ATTRIBUTE
suffix:semicolon
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_DYNAMIC
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;dyn_share
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;Attributes
op_amp
id|RES_RESERVED
)paren
op_logical_and
op_logical_neg
id|specific
)paren
r_return
id|CS_IN_USE
suffix:semicolon
r_if
c_cond
(paren
id|check_irq
c_func
(paren
id|irq
)paren
op_ne
l_int|0
)paren
r_return
id|CS_IN_USE
suffix:semicolon
r_switch
c_cond
(paren
id|Attributes
op_amp
id|IRQ_TYPE
)paren
(brace
r_case
id|IRQ_TYPE_EXCLUSIVE
suffix:colon
id|info-&gt;Attributes
op_or_assign
id|RES_ALLOCATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_TIME
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
)paren
r_return
id|CS_BAD_ATTRIBUTE
suffix:semicolon
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_TIME
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;time_share
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_DYNAMIC_SHARING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
)paren
r_return
id|CS_BAD_ATTRIBUTE
suffix:semicolon
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_DYNAMIC
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;dyn_share
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*====================================================================*/
macro_line|#ifdef CONFIG_ISA
DECL|function|undo_irq
r_void
id|undo_irq
c_func
(paren
id|u_int
id|Attributes
comma
r_int
id|irq
)paren
(brace
id|irq_info_t
op_star
id|info
suffix:semicolon
id|info
op_assign
op_amp
id|irq_table
(braket
id|irq
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|Attributes
op_amp
id|IRQ_TYPE
)paren
(brace
r_case
id|IRQ_TYPE_EXCLUSIVE
suffix:colon
id|info-&gt;Attributes
op_and_assign
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_TIME
suffix:colon
id|info-&gt;time_share
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;time_share
op_eq
l_int|0
)paren
id|info-&gt;Attributes
op_and_assign
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_DYNAMIC_SHARING
suffix:colon
id|info-&gt;dyn_share
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dyn_share
op_eq
l_int|0
)paren
id|info-&gt;Attributes
op_and_assign
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    The various adjust_* calls form the external interface to the&n;    resource database.&n;    &n;======================================================================*/
DECL|function|adjust_memory
r_static
r_int
id|adjust_memory
c_func
(paren
id|adjust_t
op_star
id|adj
)paren
(brace
id|u_long
id|base
comma
id|num
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
id|base
op_assign
id|adj-&gt;resource.memory.Base
suffix:semicolon
id|num
op_assign
id|adj-&gt;resource.memory.Size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|num
op_eq
l_int|0
)paren
op_logical_or
(paren
id|base
op_plus
id|num
op_minus
l_int|1
OL
id|base
)paren
)paren
r_return
id|CS_BAD_SIZE
suffix:semicolon
id|ret
op_assign
id|CS_SUCCESS
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Action
)paren
(brace
r_case
id|ADD_MANAGED_RESOURCE
suffix:colon
id|ret
op_assign
id|add_interval
c_func
(paren
op_amp
id|mem_db
comma
id|base
comma
id|num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REMOVE_MANAGED_RESOURCE
suffix:colon
id|ret
op_assign
id|sub_interval
c_func
(paren
op_amp
id|mem_db
comma
id|base
comma
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CS_SUCCESS
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sockets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|release_cis_mem
c_func
(paren
id|socket_table
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_CARDBUS
id|cb_release_cis_mem
c_func
(paren
id|socket_table
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|adjust_io
r_static
r_int
id|adjust_io
c_func
(paren
id|adjust_t
op_star
id|adj
)paren
(brace
r_int
id|base
comma
id|num
suffix:semicolon
id|base
op_assign
id|adj-&gt;resource.io.BasePort
suffix:semicolon
id|num
op_assign
id|adj-&gt;resource.io.NumPorts
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
OL
l_int|0
)paren
op_logical_or
(paren
id|base
OG
l_int|0xffff
)paren
)paren
r_return
id|CS_BAD_BASE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|num
op_le
l_int|0
)paren
op_logical_or
(paren
id|base
op_plus
id|num
OG
l_int|0x10000
)paren
op_logical_or
(paren
id|base
op_plus
id|num
op_le
id|base
)paren
)paren
r_return
id|CS_BAD_SIZE
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Action
)paren
(brace
r_case
id|ADD_MANAGED_RESOURCE
suffix:colon
r_if
c_cond
(paren
id|add_interval
c_func
(paren
op_amp
id|io_db
comma
id|base
comma
id|num
)paren
op_ne
l_int|0
)paren
r_return
id|CS_IN_USE
suffix:semicolon
macro_line|#ifdef CONFIG_ISA
r_if
c_cond
(paren
id|probe_io
)paren
id|do_io_probe
c_func
(paren
id|base
comma
id|num
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|REMOVE_MANAGED_RESOURCE
suffix:colon
id|sub_interval
c_func
(paren
op_amp
id|io_db
comma
id|base
comma
id|num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|CS_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|adjust_irq
r_static
r_int
id|adjust_irq
c_func
(paren
id|adjust_t
op_star
id|adj
)paren
(brace
macro_line|#ifdef CONFIG_ISA
r_int
id|irq
suffix:semicolon
id|irq_info_t
op_star
id|info
suffix:semicolon
id|irq
op_assign
id|adj-&gt;resource.irq.IRQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
OL
l_int|0
)paren
op_logical_or
(paren
id|irq
OG
l_int|15
)paren
)paren
r_return
id|CS_BAD_IRQ
suffix:semicolon
id|info
op_assign
op_amp
id|irq_table
(braket
id|irq
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Action
)paren
(brace
r_case
id|ADD_MANAGED_RESOURCE
suffix:colon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_REMOVED
)paren
id|info-&gt;Attributes
op_and_assign
op_complement
(paren
id|RES_REMOVED
op_or
id|RES_ALLOCATED
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|adj-&gt;Attributes
op_amp
id|RES_ALLOCATED
)paren
r_return
id|CS_IN_USE
suffix:semicolon
r_if
c_cond
(paren
id|adj-&gt;Attributes
op_amp
id|RES_RESERVED
)paren
id|info-&gt;Attributes
op_or_assign
id|RES_RESERVED
suffix:semicolon
r_else
id|info-&gt;Attributes
op_and_assign
op_complement
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REMOVE_MANAGED_RESOURCE
suffix:colon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_REMOVED
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_ALLOCATED
)paren
r_return
id|CS_IN_USE
suffix:semicolon
id|info-&gt;Attributes
op_or_assign
id|RES_ALLOCATED
op_or
id|RES_REMOVED
suffix:semicolon
id|info-&gt;Attributes
op_and_assign
op_complement
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_return
id|CS_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|pcmcia_adjust_resource_info
r_int
id|pcmcia_adjust_resource_info
c_func
(paren
id|client_handle_t
id|handle
comma
id|adjust_t
op_star
id|adj
)paren
(brace
r_if
c_cond
(paren
id|CHECK_HANDLE
c_func
(paren
id|handle
)paren
)paren
r_return
id|CS_BAD_HANDLE
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Resource
)paren
(brace
r_case
id|RES_MEMORY_RANGE
suffix:colon
r_return
id|adjust_memory
c_func
(paren
id|adj
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RES_IO_RANGE
suffix:colon
r_return
id|adjust_io
c_func
(paren
id|adj
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RES_IRQ
suffix:colon
r_return
id|adjust_irq
c_func
(paren
id|adj
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|release_resource_db
r_void
id|release_resource_db
c_func
(paren
r_void
)paren
(brace
id|resource_map_t
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|mem_db.next
suffix:semicolon
id|p
op_ne
op_amp
id|mem_db
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|io_db.next
suffix:semicolon
id|p
op_ne
op_amp
id|io_db
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
eof
