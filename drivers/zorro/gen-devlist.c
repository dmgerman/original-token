multiline_comment|/*&n; *&t;Generate devlist.h from the Zorro ID file.&n; *&n; *&t;(c) 2000 Geert Uytterhoeven &lt;geert@linux-m68k.org&gt;&n; *&n; *&t;Based on the PCI version:&n; *&n; *&t;(c) 1999--2000 Martin Mares &lt;mj@suse.cz&gt;&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;string.h&gt;
DECL|macro|MAX_NAME_SIZE
mdefine_line|#define MAX_NAME_SIZE 63
r_static
r_void
DECL|function|pq
id|pq
c_func
(paren
id|FILE
op_star
id|f
comma
r_const
r_char
op_star
id|c
)paren
(brace
r_while
c_loop
(paren
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
id|fprintf
c_func
(paren
id|f
comma
l_string|&quot;&bslash;&bslash;&bslash;&quot;&quot;
)paren
suffix:semicolon
r_else
id|fputc
c_func
(paren
op_star
id|c
comma
id|f
)paren
suffix:semicolon
id|c
op_increment
suffix:semicolon
)brace
)brace
r_int
DECL|function|main
id|main
c_func
(paren
r_void
)paren
(brace
r_char
id|line
(braket
l_int|1024
)braket
comma
op_star
id|c
comma
op_star
id|bra
comma
id|manuf
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|manufs
op_assign
l_int|0
suffix:semicolon
r_int
id|mode
op_assign
l_int|0
suffix:semicolon
r_int
id|lino
op_assign
l_int|0
suffix:semicolon
r_int
id|manuf_len
op_assign
l_int|0
suffix:semicolon
id|FILE
op_star
id|devf
suffix:semicolon
id|devf
op_assign
id|fopen
c_func
(paren
l_string|&quot;devlist.h&quot;
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devf
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Cannot create output file!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
op_minus
l_int|1
comma
id|stdin
)paren
)paren
(brace
id|lino
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
)paren
op_star
id|c
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line
(braket
l_int|0
)braket
op_logical_or
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;#&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|line
)paren
OG
l_int|5
op_logical_and
id|line
(braket
l_int|5
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|c
op_assign
id|line
op_plus
l_int|5
suffix:semicolon
r_while
c_loop
(paren
op_star
id|c
op_eq
l_char|&squot; &squot;
)paren
op_star
id|c
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|manuf_len
op_plus
id|strlen
c_func
(paren
id|c
)paren
op_plus
l_int|1
OG
id|MAX_NAME_SIZE
)paren
(brace
multiline_comment|/* Too long, try cutting off long description */
id|bra
op_assign
id|strchr
c_func
(paren
id|c
comma
l_char|&squot;[&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bra
op_logical_and
id|bra
OG
id|c
op_logical_and
id|bra
(braket
op_minus
l_int|1
)braket
op_eq
l_char|&squot; &squot;
)paren
id|bra
(braket
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|manuf_len
op_plus
id|strlen
c_func
(paren
id|c
)paren
op_plus
l_int|1
OG
id|MAX_NAME_SIZE
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Line %d: Product name too long&bslash;n&quot;
comma
id|lino
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|fprintf
c_func
(paren
id|devf
comma
l_string|&quot;&bslash;tPRODUCT(%s,%s,&bslash;&quot;&quot;
comma
id|manuf
comma
id|line
op_plus
l_int|1
)paren
suffix:semicolon
id|pq
c_func
(paren
id|devf
comma
id|c
)paren
suffix:semicolon
id|fputs
c_func
(paren
l_string|&quot;&bslash;&quot;)&bslash;n&quot;
comma
id|devf
)paren
suffix:semicolon
)brace
r_else
r_goto
id|err
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|err
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|line
)paren
OG
l_int|4
op_logical_and
id|line
(braket
l_int|4
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|c
op_assign
id|line
op_plus
l_int|4
suffix:semicolon
r_while
c_loop
(paren
op_star
id|c
op_eq
l_char|&squot; &squot;
)paren
op_star
id|c
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|manufs
)paren
id|fputs
c_func
(paren
l_string|&quot;ENDMANUF()&bslash;n&bslash;n&quot;
comma
id|devf
)paren
suffix:semicolon
id|manufs
op_increment
suffix:semicolon
id|strcpy
c_func
(paren
id|manuf
comma
id|line
)paren
suffix:semicolon
id|manuf_len
op_assign
id|strlen
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|manuf_len
op_plus
l_int|24
OG
id|MAX_NAME_SIZE
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Line %d: manufacturer name too long&bslash;n&quot;
comma
id|lino
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|devf
comma
l_string|&quot;MANUF(%s,&bslash;&quot;&quot;
comma
id|manuf
)paren
suffix:semicolon
id|pq
c_func
(paren
id|devf
comma
id|c
)paren
suffix:semicolon
id|fputs
c_func
(paren
l_string|&quot;&bslash;&quot;)&bslash;n&quot;
comma
id|devf
)paren
suffix:semicolon
id|mode
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|err
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Line %d: Syntax error in mode %d: %s&bslash;n&quot;
comma
id|lino
comma
id|mode
comma
id|line
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|fputs
c_func
(paren
l_string|&quot;ENDMANUF()&bslash;n&bslash;&n;&bslash;n&bslash;&n;#undef MANUF&bslash;n&bslash;&n;#undef PRODUCT&bslash;n&bslash;&n;#undef ENDMANUF&bslash;n&quot;
comma
id|devf
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|devf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
