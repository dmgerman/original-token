multiline_comment|/*&n; * I2O Random Block Storage Class OSM&n; *&n; * (C) Copyright 1999 Red Hat Software&n; *&t;&n; * Written by Alan Cox, Building Number Three Ltd&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * This is a beta test release. Most of the good code was taken&n; * from the nbd driver by Pavel Machek, who in turn took some of it&n; * from loop.c. Isn&squot;t free software great for reusability 8)&n; *&n; * Fixes/additions:&n; *&t;Steve Ralston:&t;&n; *&t;&t;Multiple device handling error fixes,&n; *&t;&t;Added a queue depth.&n; *&t;Alan Cox:&t;&n; *&t;&t;FC920 has an rmw bug. Dont or in the end marker.&n; *&t;&t;Removed queue walk, fixed for 64bitness.&n; *&t;Deepak Saxena:&n; *&t;&t;Independent queues per IOP&n; *&t;&t;Support for dynamic device creation/deletion&n; *&t;&t;Code cleanup&t;&n; *    &t;&t;Support for larger I/Os through merge* functions &n; *       &t;(taken from DAC960 driver)&n; *&t;Boji T Kannanthanam:&n; *&t;&t;Reduced the timeout during RAID 5 creation. &n; *&t;&t;This is to prevent race condition when a RAID volume&n; *&t;&t;is created and immediately deleted.&n; *&n; *&t;To do:&n; *&t;&t;Serial number scanning to find duplicates for FC multipathing&n; *&t;&t;Remove the random timeout in the code needed for RAID 5&n; *&t;&t;&t;volume creation.&n; */
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/i2o.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR I2O_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|MAX_I2OB
mdefine_line|#define MAX_I2OB&t;16
DECL|macro|MAX_I2OB_DEPTH
mdefine_line|#define MAX_I2OB_DEPTH&t;128
DECL|macro|MAX_I2OB_RETRIES
mdefine_line|#define MAX_I2OB_RETRIES 4
singleline_comment|//#define DRIVERDEBUG
macro_line|#ifdef DRIVERDEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG( s )
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG( s ) printk( s ) 
macro_line|#endif
multiline_comment|/*&n; * Events that this OSM is interested in&n; */
DECL|macro|I2OB_EVENT_MASK
mdefine_line|#define I2OB_EVENT_MASK&t;&t;(I2O_EVT_IND_BSA_VOLUME_LOAD |&t;&bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_VOLUME_UNLOAD | &bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ | &bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_CAPACITY_CHANGE)
multiline_comment|/*&n; * I2O Block Error Codes - should be in a header file really...&n; */
DECL|macro|I2O_BSA_DSC_SUCCESS
mdefine_line|#define I2O_BSA_DSC_SUCCESS             0x0000
DECL|macro|I2O_BSA_DSC_MEDIA_ERROR
mdefine_line|#define I2O_BSA_DSC_MEDIA_ERROR         0x0001
DECL|macro|I2O_BSA_DSC_ACCESS_ERROR
mdefine_line|#define I2O_BSA_DSC_ACCESS_ERROR        0x0002
DECL|macro|I2O_BSA_DSC_DEVICE_FAILURE
mdefine_line|#define I2O_BSA_DSC_DEVICE_FAILURE      0x0003
DECL|macro|I2O_BSA_DSC_DEVICE_NOT_READY
mdefine_line|#define I2O_BSA_DSC_DEVICE_NOT_READY    0x0004
DECL|macro|I2O_BSA_DSC_MEDIA_NOT_PRESENT
mdefine_line|#define I2O_BSA_DSC_MEDIA_NOT_PRESENT   0x0005
DECL|macro|I2O_BSA_DSC_MEDIA_LOCKED
mdefine_line|#define I2O_BSA_DSC_MEDIA_LOCKED        0x0006
DECL|macro|I2O_BSA_DSC_MEDIA_FAILURE
mdefine_line|#define I2O_BSA_DSC_MEDIA_FAILURE       0x0007
DECL|macro|I2O_BSA_DSC_PROTOCOL_FAILURE
mdefine_line|#define I2O_BSA_DSC_PROTOCOL_FAILURE    0x0008
DECL|macro|I2O_BSA_DSC_BUS_FAILURE
mdefine_line|#define I2O_BSA_DSC_BUS_FAILURE         0x0009
DECL|macro|I2O_BSA_DSC_ACCESS_VIOLATION
mdefine_line|#define I2O_BSA_DSC_ACCESS_VIOLATION    0x000A
DECL|macro|I2O_BSA_DSC_WRITE_PROTECTED
mdefine_line|#define I2O_BSA_DSC_WRITE_PROTECTED     0x000B
DECL|macro|I2O_BSA_DSC_DEVICE_RESET
mdefine_line|#define I2O_BSA_DSC_DEVICE_RESET        0x000C
DECL|macro|I2O_BSA_DSC_VOLUME_CHANGED
mdefine_line|#define I2O_BSA_DSC_VOLUME_CHANGED      0x000D
DECL|macro|I2O_BSA_DSC_TIMEOUT
mdefine_line|#define I2O_BSA_DSC_TIMEOUT             0x000E
multiline_comment|/*&n; *&t;Some of these can be made smaller later&n; */
DECL|variable|i2ob_blksizes
r_static
r_int
id|i2ob_blksizes
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_hardsizes
r_static
r_int
id|i2ob_hardsizes
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_sizes
r_static
r_int
id|i2ob_sizes
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_media_change_flag
r_static
r_int
id|i2ob_media_change_flag
(braket
id|MAX_I2OB
)braket
suffix:semicolon
DECL|variable|i2ob_max_sectors
r_static
id|u32
id|i2ob_max_sectors
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_context
r_static
r_int
id|i2ob_context
suffix:semicolon
multiline_comment|/*&n; * I2O Block device descriptor &n; */
DECL|struct|i2ob_device
r_struct
id|i2ob_device
(brace
DECL|member|controller
r_struct
id|i2o_controller
op_star
id|controller
suffix:semicolon
DECL|member|i2odev
r_struct
id|i2o_device
op_star
id|i2odev
suffix:semicolon
DECL|member|unit
r_int
id|unit
suffix:semicolon
DECL|member|tid
r_int
id|tid
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
DECL|member|head
DECL|member|tail
r_struct
id|request
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
DECL|member|req_queue
id|request_queue_t
op_star
id|req_queue
suffix:semicolon
DECL|member|max_segments
r_int
id|max_segments
suffix:semicolon
DECL|member|done_flag
r_int
id|done_flag
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;FIXME:&n; *&t;We should cache align these to avoid ping-ponging lines on SMP&n; *&t;boxes under heavy I/O load...&n; */
DECL|struct|i2ob_request
r_struct
id|i2ob_request
(brace
DECL|member|next
r_struct
id|i2ob_request
op_star
id|next
suffix:semicolon
DECL|member|req
r_struct
id|request
op_star
id|req
suffix:semicolon
DECL|member|num
r_int
id|num
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Per IOP requst queue information&n; *&n; * We have a separate requeust_queue_t per IOP so that a heavilly&n; * loaded I2O block device on an IOP does not starve block devices&n; * across all I2O controllers.&n; * &n; */
DECL|struct|i2ob_iop_queue
r_struct
id|i2ob_iop_queue
(brace
DECL|member|queue_depth
id|atomic_t
id|queue_depth
suffix:semicolon
DECL|member|request_queue
r_struct
id|i2ob_request
id|request_queue
(braket
id|MAX_I2OB_DEPTH
)braket
suffix:semicolon
DECL|member|i2ob_qhead
r_struct
id|i2ob_request
op_star
id|i2ob_qhead
suffix:semicolon
DECL|member|req_queue
id|request_queue_t
id|req_queue
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|i2ob_queues
r_static
r_struct
id|i2ob_iop_queue
op_star
id|i2ob_queues
(braket
id|MAX_I2O_CONTROLLERS
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Each I2O disk is one of these.&n; */
DECL|variable|i2ob_dev
r_static
r_struct
id|i2ob_device
id|i2ob_dev
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_dev_count
r_static
r_int
id|i2ob_dev_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|i2ob
r_static
r_struct
id|hd_struct
id|i2ob
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_gendisk
r_static
r_struct
id|gendisk
id|i2ob_gendisk
suffix:semicolon
multiline_comment|/* Declared later */
multiline_comment|/*&n; * Mutex and spin lock for event handling synchronization&n; * evt_msg contains the last event.&n; */
DECL|variable|i2ob_evt_sem
id|DECLARE_MUTEX
c_func
(paren
id|i2ob_evt_sem
)paren
suffix:semicolon
DECL|variable|i2ob_evt_lock
r_static
id|spinlock_t
id|i2ob_evt_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|evt_msg
r_static
r_int
r_int
id|evt_msg
(braket
id|MSG_FRAME_SIZE
op_rshift
l_int|2
)braket
suffix:semicolon
DECL|variable|i2ob_evt_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|i2ob_evt_wait
)paren
suffix:semicolon
DECL|variable|i2ob_timer
r_static
r_struct
id|timer_list
id|i2ob_timer
suffix:semicolon
DECL|variable|i2ob_timer_started
r_static
r_int
id|i2ob_timer_started
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|i2o_block_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
comma
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_message
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_new_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_del_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_reboot_event
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|i2ob_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|i2ob_end_request
c_func
(paren
r_struct
id|request
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2ob_init_iop
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
id|request_queue_t
op_star
id|i2ob_get_queue
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
r_static
r_int
id|i2ob_query_device
c_func
(paren
r_struct
id|i2ob_device
op_star
comma
r_int
comma
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|do_i2ob_revalidate
c_func
(paren
id|kdev_t
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|i2ob_evt
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|variable|evt_pid
r_static
r_int
id|evt_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|evt_running
r_static
r_int
id|evt_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * I2O OSM registration structure...keeps getting bigger and bigger :)&n; */
DECL|variable|i2o_block_handler
r_static
r_struct
id|i2o_handler
id|i2o_block_handler
op_assign
(brace
id|i2o_block_reply
comma
id|i2ob_new_device
comma
id|i2ob_del_device
comma
id|i2ob_reboot_event
comma
l_string|&quot;I2O Block OSM&quot;
comma
l_int|0
comma
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Get a message&n; */
DECL|function|i2ob_get
r_static
id|u32
id|i2ob_get
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev-&gt;controller
suffix:semicolon
r_return
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Turn a Linux block request into an I2O block read/write.&n; */
DECL|function|i2ob_send
r_static
r_int
id|i2ob_send
c_func
(paren
id|u32
id|m
comma
r_struct
id|i2ob_device
op_star
id|dev
comma
r_struct
id|i2ob_request
op_star
id|ireq
comma
id|u32
id|base
comma
r_int
id|unit
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev-&gt;controller
suffix:semicolon
r_int
id|tid
op_assign
id|dev-&gt;tid
suffix:semicolon
r_int
r_int
id|msg
suffix:semicolon
r_int
r_int
id|mptr
suffix:semicolon
id|u64
id|offset
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|ireq-&gt;req
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_int
id|count
op_assign
id|req-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_char
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
op_assign
l_int|0
suffix:semicolon
singleline_comment|// printk(KERN_INFO &quot;i2ob_send called&bslash;n&quot;);
multiline_comment|/* Map the message to a virtual address */
id|msg
op_assign
id|c-&gt;mem_offset
op_plus
id|m
suffix:semicolon
multiline_comment|/*&n;&t; * Build the message based on the request.&n;&t; */
id|__raw_writel
c_func
(paren
id|i2ob_context
op_or
(paren
id|unit
op_lshift
l_int|8
)paren
comma
id|msg
op_plus
l_int|8
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|ireq-&gt;num
comma
id|msg
op_plus
l_int|12
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|req-&gt;nr_sectors
op_lshift
l_int|9
comma
id|msg
op_plus
l_int|20
)paren
suffix:semicolon
multiline_comment|/* This can be optimised later - just want to be sure its right for&n;&t;   starters */
id|offset
op_assign
(paren
(paren
id|u64
)paren
(paren
id|req-&gt;sector
op_plus
id|base
)paren
)paren
op_lshift
l_int|9
suffix:semicolon
id|__raw_writel
c_func
(paren
id|offset
op_amp
l_int|0xFFFFFFFF
comma
id|msg
op_plus
l_int|24
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|offset
op_rshift
l_int|32
comma
id|msg
op_plus
l_int|28
)paren
suffix:semicolon
id|mptr
op_assign
id|msg
op_plus
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|READ
)paren
(brace
id|__raw_writel
c_func
(paren
id|I2O_CMD_BLOCK_READ
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t yet do cache/readahead and other magic */
id|__raw_writel
c_func
(paren
l_int|1
op_lshift
l_int|16
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_eq
id|last
)paren
(brace
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|last
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_reqnext
)paren
(brace
id|__raw_writel
c_func
(paren
l_int|0x14000000
op_or
(paren
id|size
)paren
comma
id|mptr
op_minus
l_int|8
)paren
suffix:semicolon
)brace
r_else
id|__raw_writel
c_func
(paren
l_int|0xD4000000
op_or
(paren
id|size
)paren
comma
id|mptr
op_minus
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|bh-&gt;b_reqnext
)paren
(brace
id|__raw_writel
c_func
(paren
l_int|0x10000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
)brace
r_else
id|__raw_writel
c_func
(paren
l_int|0xD0000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
comma
id|mptr
op_plus
l_int|4
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|8
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|last
op_assign
id|bh-&gt;b_data
op_plus
id|size
suffix:semicolon
)brace
id|count
op_sub_assign
id|bh-&gt;b_size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|__raw_writel
c_func
(paren
id|I2O_CMD_BLOCK_WRITE
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Allow replies to come back once data is cached in the controller&n;&t;&t; * This allows us to handle writes quickly thus giving more of the&n;&t;&t; * queue to reads.&n;&t;&t; */
id|__raw_writel
c_func
(paren
l_int|0x00000010
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_eq
id|last
)paren
(brace
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|last
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_reqnext
)paren
(brace
id|__raw_writel
c_func
(paren
l_int|0x14000000
op_or
(paren
id|size
)paren
comma
id|mptr
op_minus
l_int|8
)paren
suffix:semicolon
)brace
r_else
id|__raw_writel
c_func
(paren
l_int|0xD4000000
op_or
(paren
id|size
)paren
comma
id|mptr
op_minus
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|bh-&gt;b_reqnext
)paren
(brace
id|__raw_writel
c_func
(paren
l_int|0x14000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
)brace
r_else
id|__raw_writel
c_func
(paren
l_int|0xD4000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
comma
id|mptr
op_plus
l_int|4
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|8
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|last
op_assign
id|bh-&gt;b_data
op_plus
id|size
suffix:semicolon
)brace
id|count
op_sub_assign
id|bh-&gt;b_size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
id|__raw_writel
c_func
(paren
id|I2O_MESSAGE_SIZE
c_func
(paren
id|mptr
op_minus
id|msg
)paren
op_rshift
l_int|2
op_or
id|SGL_OFFSET_8
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;current_nr_sectors
OG
id|i2ob_max_sectors
(braket
id|unit
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Gathered sectors %ld.&bslash;n&quot;
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Request count botched by %d.&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
)brace
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a request from the _locked_ request list. We update both the&n; *&t;list chain and if this is the last item the tail pointer. Caller&n; *&t;must hold the lock.&n; */
DECL|function|i2ob_unhook_request
r_static
r_inline
r_void
id|i2ob_unhook_request
c_func
(paren
r_struct
id|i2ob_request
op_star
id|ireq
comma
r_int
r_int
id|iop
)paren
(brace
id|ireq-&gt;next
op_assign
id|i2ob_queues
(braket
id|iop
)braket
op_member_access_from_pointer
id|i2ob_qhead
suffix:semicolon
id|i2ob_queues
(braket
id|iop
)braket
op_member_access_from_pointer
id|i2ob_qhead
op_assign
id|ireq
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Request completion handler&n; */
DECL|function|i2ob_end_request
r_static
r_inline
r_void
id|i2ob_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
multiline_comment|/*&n;&t; * Loop until all of the buffers that are linked&n;&t; * to this request have been marked updated and&n;&t; * unlocked.&n;&t; */
r_while
c_loop
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
op_logical_neg
id|req-&gt;errors
comma
l_string|&quot;i2o block&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is now ok to complete the request.&n;&t; */
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Request merging functions&n; */
DECL|function|i2ob_new_segment
r_static
r_inline
r_int
id|i2ob_new_segment
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_int
id|__max_segments
)paren
(brace
r_int
id|max_segments
op_assign
id|i2ob_dev
(braket
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|max_segments
suffix:semicolon
r_if
c_cond
(paren
id|__max_segments
OL
id|max_segments
)paren
id|max_segments
op_assign
id|__max_segments
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_segments
OL
id|max_segments
)paren
(brace
id|req-&gt;nr_segments
op_increment
suffix:semicolon
id|q-&gt;elevator.nr_segments
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2ob_back_merge
r_static
r_int
id|i2ob_back_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|__max_segments
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;bhtail-&gt;b_data
op_plus
id|req-&gt;bhtail-&gt;b_size
op_eq
id|bh-&gt;b_data
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|i2ob_new_segment
c_func
(paren
id|q
comma
id|req
comma
id|__max_segments
)paren
suffix:semicolon
)brace
DECL|function|i2ob_front_merge
r_static
r_int
id|i2ob_front_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|__max_segments
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
op_eq
id|req-&gt;bh-&gt;b_data
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|i2ob_new_segment
c_func
(paren
id|q
comma
id|req
comma
id|__max_segments
)paren
suffix:semicolon
)brace
DECL|function|i2ob_merge_requests
r_static
r_int
id|i2ob_merge_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|request
op_star
id|next
comma
r_int
id|__max_segments
)paren
(brace
r_int
id|max_segments
op_assign
id|i2ob_dev
(braket
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|max_segments
suffix:semicolon
r_int
id|total_segments
op_assign
id|req-&gt;nr_segments
op_plus
id|next-&gt;nr_segments
suffix:semicolon
r_int
id|same_segment
suffix:semicolon
r_if
c_cond
(paren
id|__max_segments
OL
id|max_segments
)paren
id|max_segments
op_assign
id|__max_segments
suffix:semicolon
id|same_segment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;bhtail-&gt;b_data
op_plus
id|req-&gt;bhtail-&gt;b_size
op_eq
id|next-&gt;bh-&gt;b_data
)paren
(brace
id|total_segments
op_decrement
suffix:semicolon
id|same_segment
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|total_segments
OG
id|max_segments
)paren
r_return
l_int|0
suffix:semicolon
id|q-&gt;elevator.nr_segments
op_sub_assign
id|same_segment
suffix:semicolon
id|req-&gt;nr_segments
op_assign
id|total_segments
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;OSM reply handler. This gets all the message replies&n; */
DECL|function|i2o_block_reply
r_static
r_void
id|i2o_block_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
comma
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_message
op_star
id|msg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|i2ob_request
op_star
id|ireq
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|st
suffix:semicolon
id|u32
op_star
id|m
op_assign
(paren
id|u32
op_star
)paren
id|msg
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|m
(braket
l_int|2
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xF0
suffix:semicolon
multiline_comment|/* low 4 bits are partition */
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|unit
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * FAILed message&n;&t; */
r_if
c_cond
(paren
id|m
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * FAILed message from controller&n;&t;&t; * We increment the error count and abort it&n;&t;&t; *&n;&t;&t; * In theory this will never happen.  The I2O block class&n;&t;&t; * speficiation states that block devices never return&n;&t;&t; * FAILs but instead use the REQ status field...but&n;&t;&t; * better be on the safe side since no one really follows&n;&t;&t; * the spec to the book :)&n;&t;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now flush the message by making it a NOP */
id|m
(braket
l_int|0
)braket
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|m
(braket
l_int|0
)braket
op_or_assign
(paren
id|I2O_CMD_UTIL_NOP
)paren
op_lshift
l_int|24
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|virt_to_bus
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;function
op_eq
id|I2O_CMD_UTIL_EVT_REGISTER
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|i2ob_evt_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|evt_msg
comma
id|m
comma
id|msg-&gt;size
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i2ob_evt_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|i2ob_evt_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;i2odev
)paren
(brace
multiline_comment|/*&n;&t;&t; * This is HACK, but Intel Integrated RAID allows user&n;&t;&t; * to delete a volume that is claimed, locked, and in use &n;&t;&t; * by the OS. We have to check for a reply from a&n;&t;&t; * non-existent device and flag it as an error or the system &n;&t;&t; * goes kaput...&n;&t;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;I2O Block: Data transfer to deleted device!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Lets see what is cooking. We stuffed the&n;&t; *&t;request in the context.&n;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|st
op_assign
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
l_int|0
)paren
(brace
r_char
op_star
id|bsa_errors
(braket
)braket
op_assign
(brace
l_string|&quot;Success&quot;
comma
l_string|&quot;Media Error&quot;
comma
l_string|&quot;Failure communicating to device&quot;
comma
l_string|&quot;Device Failure&quot;
comma
l_string|&quot;Device is not ready&quot;
comma
l_string|&quot;Media not present&quot;
comma
l_string|&quot;Media is locked by another user&quot;
comma
l_string|&quot;Media has failed&quot;
comma
l_string|&quot;Failure communicating to device&quot;
comma
l_string|&quot;Device bus failure&quot;
comma
l_string|&quot;Device is locked by another user&quot;
comma
l_string|&quot;Device is write protected&quot;
comma
l_string|&quot;Device has reset&quot;
comma
l_string|&quot;Volume has changed, waiting for acknowledgement&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&bslash;n/dev/%s error: %s&quot;
comma
id|dev-&gt;i2odev-&gt;dev_name
comma
id|bsa_errors
(braket
id|m
(braket
l_int|4
)braket
op_amp
l_int|0XFFFF
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
l_int|0x00FF0000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - DDM attempted %d retries&quot;
comma
(paren
id|m
(braket
l_int|4
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0x00FF
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
)brace
r_else
id|ireq-&gt;req-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Dequeue the request. We use irqsave locks as one day we&n;&t; *&t;may be running polled controllers from a BH...&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We may be able to do more I/O&n;&t; */
id|i2ob_request
c_func
(paren
id|dev-&gt;req_queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Event handler.  Needs to be a separate thread b/c we may have&n; * to do things like scan a partition table, or query parameters&n; * which cannot be done from an interrupt or from a bottom half.&n; */
DECL|function|i2ob_evt
r_static
r_int
id|i2ob_evt
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
r_int
r_int
id|evt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_int
id|i
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;i2oblock&quot;
)paren
suffix:semicolon
id|evt_running
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#warning &quot;RACE&quot;
id|interruptible_sleep_on
c_func
(paren
op_amp
id|i2ob_evt_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|evt_running
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Doing something in i2o_block event thread&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Keep another CPU/interrupt from overwriting the &n;&t;&t; * message while we&squot;re reading it&n;&t;&t; *&n;&t;&t; * We stuffed the unit in the TxContext and grab the event mask&n;&t;&t; * None of the BSA we care about events have EventData&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i2ob_evt_lock
comma
id|flags
)paren
suffix:semicolon
id|unit
op_assign
id|evt_msg
(braket
l_int|3
)braket
suffix:semicolon
id|evt
op_assign
id|evt_msg
(braket
l_int|4
)braket
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i2ob_evt_lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|evt
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * New volume loaded on same TID, so we just re-install.&n;&t;&t;&t; * The TID/controller don&squot;t change as it is the same&n;&t;&t;&t; * I2O device.  It&squot;s just new media that we have to&n;&t;&t;&t; * rescan.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_VOLUME_LOAD
suffix:colon
(brace
id|i2ob_install_device
c_func
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;controller
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev
comma
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * No media, so set all parameters to 0 and set the media&n;&t;&t;&t; * change flag. The I2O device is still valid, just doesn&squot;t&n;&t;&t;&t; * have media, so we don&squot;t want to clear the controller or&n;&t;&t;&t; * device pointer.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_VOLUME_UNLOAD
suffix:colon
(brace
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_sizes
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i2ob_hardsizes
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i2ob
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
id|i2ob_media_change_flag
(braket
id|unit
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Attempt to eject locked media&bslash;n&quot;
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;dev_name
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The capacity has changed and we are going to be&n;&t;&t;&t; * updating the max_sectors and other information &n;&t;&t;&t; * about this disk.  We try a revalidate first. If&n;&t;&t;&t; * the block device is in use, we don&squot;t want to&n;&t;&t;&t; * do that as there may be I/Os bound for the disk&n;&t;&t;&t; * at the moment.  In that case we read the size &n;&t;&t;&t; * from the device and update the information ourselves&n;&t;&t;&t; * and the user can later force a partition table&n;&t;&t;&t; * update through an ioctl.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_CAPACITY_CHANGE
suffix:colon
(brace
id|u64
id|size
suffix:semicolon
r_if
c_cond
(paren
id|do_i2ob_revalidate
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|unit
)paren
comma
l_int|0
)paren
op_ne
op_minus
id|EBUSY
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2ob_query_device
c_func
(paren
op_amp
id|i2ob_dev
(braket
id|unit
)braket
comma
l_int|0x0004
comma
l_int|0
comma
op_amp
id|size
comma
l_int|8
)paren
op_ne
l_int|0
)paren
(brace
id|i2ob_query_device
c_func
(paren
op_amp
id|i2ob_dev
(braket
id|unit
)braket
comma
l_int|0x0000
comma
l_int|4
comma
op_amp
id|size
comma
l_int|8
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|i2ob_sizes
(braket
id|unit
)braket
op_assign
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|10
)paren
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|unit
)braket
dot
id|nr_sects
op_assign
id|size
op_rshift
l_int|9
suffix:semicolon
id|i2ob
(braket
id|unit
)braket
dot
id|nr_sects
op_assign
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|9
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * An event we didn&squot;t ask for.  Call the card manufacturer&n;&t;&t;&t; * and tell them to fix their firmware :)&n;&t;&t;&t; */
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Received event we didn&squot;t register for&bslash;n&quot;
id|KERN_INFO
l_string|&quot;   Call I2O card manufacturer&bslash;n&quot;
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;dev_name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The timer handler will attempt to restart requests &n; * that are queued to the driver.  This handler&n; * currently only gets called if the controller&n; * had no more room in its inbound fifo.  &n; */
DECL|function|i2ob_timer_handler
r_static
r_void
id|i2ob_timer_handler
c_func
(paren
r_int
r_int
id|q
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot touch the request queue or the timer&n;         * flag without holding the io_request_lock.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Clear the timer started flag so that &n;&t; * the timer can be queued again.&n;&t; */
id|i2ob_timer_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Restart any requests.&n;&t; */
id|i2ob_request
c_func
(paren
(paren
id|request_queue_t
op_star
)paren
id|q
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Free the lock.&n;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The I2O block driver is listed as one of those that pulls the&n; *&t;front entry off the queue before processing it. This is important&n; *&t;to remember here. If we drop the io lock then CURRENT will change&n; *&t;on us. We must unlink CURRENT in this routine before we return, if&n; *&t;we use it.&n; */
DECL|function|i2ob_request
r_static
r_void
id|i2ob_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|i2ob_request
op_star
id|ireq
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
id|u32
id|m
suffix:semicolon
singleline_comment|// printk(KERN_INFO &quot;i2ob_request() called with queue %p&bslash;n&quot;, q);
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;On an IRQ completion if there is an inactive&n;&t;&t; *&t;request on the queue head it means it isnt yet&n;&t;&t; *&t;ready to dispatch.&n;&t;&t; */
id|req
op_assign
id|blkdev_entry_next_request
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
suffix:semicolon
)brace
id|unit
op_assign
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|unit
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
multiline_comment|/* &n;&t;&t; *&t;Queue depths probably belong with some kind of &n;&t;&t; *&t;generic IOP commit control. Certainly its not right &n;&t;&t; *&t;its global!  &n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
op_ge
id|MAX_I2OB_DEPTH
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Get a message */
id|m
op_assign
id|i2ob_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * See if the timer has already been queued.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i2ob_timer_started
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob: starting timer&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set the timer_started flag to insure&n;&t;&t;&t;&t; * that the timer is only queued once.&n;&t;&t;&t;&t; * Queing it more than once will corrupt&n;&t;&t;&t;&t; * the timer queue.&n;&t;&t;&t;&t; */
id|i2ob_timer_started
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Set up the timer to expire in&n;&t;&t;&t;&t; * 500ms.&n;&t;&t;&t;&t; */
id|i2ob_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_rshift
l_int|1
)paren
suffix:semicolon
id|i2ob_timer.data
op_assign
(paren
r_int
r_int
)paren
id|q
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Start it.&n;&t;&t;&t;&t; */
id|add_timer
c_func
(paren
op_amp
id|i2ob_timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Everything ok, so pull from kernel queue onto our queue&n;&t;&t; */
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|req-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
id|ireq
op_assign
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|i2ob_qhead
suffix:semicolon
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|i2ob_qhead
op_assign
id|ireq-&gt;next
suffix:semicolon
id|ireq-&gt;req
op_assign
id|req
suffix:semicolon
id|i2ob_send
c_func
(paren
id|m
comma
id|dev
comma
id|ireq
comma
id|i2ob
(braket
id|unit
)braket
dot
id|start_sect
comma
(paren
id|unit
op_amp
l_int|0xF0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;SCSI-CAM for ioctl geometry mapping&n; *&t;Duplicated with SCSI - this should be moved into somewhere common&n; *&t;perhaps genhd ?&n; *&n; * LBA -&gt; CHS mapping table taken from:&n; *&n; * &quot;Incorporating the I2O Architecture into BIOS for Intel Architecture &n; *  Platforms&quot; &n; *&n; * This is an I2O document that is only available to I2O members,&n; * not developers.&n; *&n; * From my understanding, this is how all the I2O cards do this&n; *&n; * Disk Size      | Sectors | Heads | Cylinders&n; * ---------------+---------+-------+-------------------&n; * 1 &lt; X &lt;= 528M  | 63      | 16    | X/(63 * 16 * 512)&n; * 528M &lt; X &lt;= 1G | 63      | 32    | X/(63 * 32 * 512)&n; * 1 &lt; X &lt;528M    | 63      | 16    | X/(63 * 16 * 512)&n; * 1 &lt; X &lt;528M    | 63      | 16    | X/(63 * 16 * 512)&n; *&n; */
DECL|macro|BLOCK_SIZE_528M
mdefine_line|#define&t;BLOCK_SIZE_528M&t;&t;1081344
DECL|macro|BLOCK_SIZE_1G
mdefine_line|#define&t;BLOCK_SIZE_1G&t;&t;2097152
DECL|macro|BLOCK_SIZE_21G
mdefine_line|#define&t;BLOCK_SIZE_21G&t;&t;4403200
DECL|macro|BLOCK_SIZE_42G
mdefine_line|#define&t;BLOCK_SIZE_42G&t;&t;8806400
DECL|macro|BLOCK_SIZE_84G
mdefine_line|#define&t;BLOCK_SIZE_84G&t;&t;17612800
DECL|function|i2o_block_biosparam
r_static
r_void
id|i2o_block_biosparam
c_func
(paren
r_int
r_int
id|capacity
comma
r_int
r_int
op_star
id|cyls
comma
r_int
r_char
op_star
id|hds
comma
r_int
r_char
op_star
id|secs
)paren
(brace
r_int
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
id|sectors
op_assign
l_int|63L
suffix:semicolon
multiline_comment|/* Maximize sectors per track */
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_528M
)paren
(brace
id|heads
op_assign
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_1G
)paren
(brace
id|heads
op_assign
l_int|32
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_21G
)paren
(brace
id|heads
op_assign
l_int|64
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_42G
)paren
(brace
id|heads
op_assign
l_int|128
suffix:semicolon
)brace
r_else
id|heads
op_assign
l_int|255
suffix:semicolon
id|cylinders
op_assign
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
op_star
id|cyls
op_assign
(paren
r_int
r_int
)paren
id|cylinders
suffix:semicolon
multiline_comment|/* Stuff return values */
op_star
id|secs
op_assign
(paren
r_int
r_char
)paren
id|sectors
suffix:semicolon
op_star
id|hds
op_assign
(paren
r_int
r_char
)paren
id|heads
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rescan the partition tables&n; */
DECL|function|do_i2ob_revalidate
r_static
r_int
id|do_i2ob_revalidate
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxu
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|minor
op_and_assign
l_int|0xF0
suffix:semicolon
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
OG
id|maxu
op_plus
l_int|1
)paren
(brace
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|15
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|m
op_assign
id|minor
op_plus
id|i
suffix:semicolon
id|kdev_t
id|d
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|m
)paren
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|d
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
(brace
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
id|invalidate_buffers
c_func
(paren
id|d
)paren
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|m
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|m
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do a physical check and then reconfigure&n;&t; */
id|i2ob_install_device
c_func
(paren
id|i2ob_dev
(braket
id|minor
)braket
dot
id|controller
comma
id|i2ob_dev
(braket
id|minor
)braket
dot
id|i2odev
comma
id|minor
)paren
suffix:semicolon
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue device specific ioctl calls.&n; */
DECL|function|i2ob_ioctl
r_static
r_int
id|i2ob_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_int
id|minor
suffix:semicolon
multiline_comment|/* Anyone capable of this syscall can do *real bad* things */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
(paren
id|MAX_I2OB
op_lshift
l_int|4
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|minor
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
r_return
id|put_user
c_func
(paren
id|i2ob
(braket
id|minor
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|g
suffix:semicolon
r_int
id|u
op_assign
id|minor
op_amp
l_int|0xF0
suffix:semicolon
id|i2o_block_biosparam
c_func
(paren
id|i2ob_sizes
(braket
id|u
)braket
op_lshift
l_int|1
comma
op_amp
id|g.cylinders
comma
op_amp
id|g.heads
comma
op_amp
id|g.sectors
)paren
suffix:semicolon
id|g.start
op_assign
id|i2ob
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|g
comma
r_sizeof
(paren
id|g
)paren
)paren
ques
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_case
id|BLKRRPART
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_return
id|do_i2ob_revalidate
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKPG
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Close the block device down&n; */
DECL|function|i2ob_release
r_static
r_int
id|i2ob_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_int
id|minor
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
(paren
id|MAX_I2OB
op_lshift
l_int|4
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|minor
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * This is to deail with the case of an application&n;&t; * opening a device and then the device dissapears while&n;&t; * it&squot;s in use, and then the application tries to release&n;&t; * it.  ex: Unmounting a deleted RAID volume at reboot. &n;&t; * If we send messages, it will just cause FAILs since&n;&t; * the TID no longer exists.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;i2odev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Sync the device so we don&squot;t get errors */
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;i2ob_release: refcount(%d) &lt;= 0&bslash;n&quot;
comma
id|dev-&gt;refcnt
)paren
suffix:semicolon
id|dev-&gt;refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Flush the onboard cache on unmount&n;&t;&t; */
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_int
op_star
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_CFLUSH
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|60
op_lshift
l_int|16
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unlock the media&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MUNLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n; &t;&t; * Now unclaim the device.&n;&t;&t; */
r_if
c_cond
(paren
id|i2o_release_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob_release: controller rejected unclaim.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Open the block device.&n; */
DECL|function|i2ob_open
r_static
r_int
id|i2ob_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_I2OB
op_lshift
l_int|4
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|minor
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;i2odev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_increment
op_eq
l_int|0
)paren
(brace
id|u32
id|msg
(braket
l_int|6
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
)paren
)paren
(brace
id|dev-&gt;refcnt
op_decrement
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block: Could not open device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Mount the media if needed. Note that we don&squot;t use&n;&t;&t; *&t;the lock bit. Since we have to issue a lock if it&n;&t;&t; *&t;refuses a mount (quite possible) then we might as&n;&t;&t; *&t;well just send two messages out.&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MMOUNT
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|24
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Lock the media&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue a device query&n; */
DECL|function|i2ob_query_device
r_static
r_int
id|i2ob_query_device
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
comma
r_int
id|table
comma
r_int
id|field
comma
r_void
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_return
id|i2o_query_scalar
c_func
(paren
id|dev-&gt;controller
comma
id|dev-&gt;tid
comma
id|table
comma
id|field
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Install the I2O block device we found.&n; */
DECL|function|i2ob_install_device
r_static
r_int
id|i2ob_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
comma
r_int
id|unit
)paren
(brace
id|u64
id|size
suffix:semicolon
id|u32
id|blocksize
suffix:semicolon
id|u32
id|limit
suffix:semicolon
id|u8
id|type
suffix:semicolon
id|u32
id|flags
comma
id|status
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * For logging purposes...&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2ob: Installing tid %d device at unit %d&bslash;n&quot;
comma
id|d-&gt;lct_data.tid
comma
id|unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ask for the current media data. If that isn&squot;t supported&n;&t; *&t;then we ask for the device capacity data&n;&t; */
r_if
c_cond
(paren
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0004
comma
l_int|1
comma
op_amp
id|blocksize
comma
l_int|4
)paren
op_ne
l_int|0
op_logical_or
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0004
comma
l_int|0
comma
op_amp
id|size
comma
l_int|8
)paren
op_ne
l_int|0
)paren
(brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|3
comma
op_amp
id|blocksize
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|4
comma
op_amp
id|size
comma
l_int|8
)paren
suffix:semicolon
)brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|5
comma
op_amp
id|flags
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|6
comma
op_amp
id|status
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_sizes
(braket
id|unit
)braket
op_assign
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|10
)paren
suffix:semicolon
id|i2ob_hardsizes
(braket
id|unit
)braket
op_assign
id|blocksize
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|unit
)braket
dot
id|nr_sects
op_assign
id|size
op_rshift
l_int|9
suffix:semicolon
id|i2ob
(braket
id|unit
)braket
dot
id|nr_sects
op_assign
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Set limit based on inbound frame size */
id|limit
op_assign
(paren
id|d-&gt;controller-&gt;status_block-&gt;inbound_frame_size
op_minus
l_int|8
)paren
op_div
l_int|2
suffix:semicolon
id|limit
op_assign
id|limit
op_lshift
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * Max number of Scatter-Gather Elements&n;&t; */
id|i2ob_dev
(braket
id|unit
)braket
dot
id|max_segments
op_assign
(paren
id|d-&gt;controller-&gt;status_block-&gt;inbound_frame_size
op_minus
l_int|8
)paren
op_div
l_int|2
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Max Segments set to %d&bslash;n&quot;
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|max_segments
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Byte limit is %d.&bslash;n&quot;
comma
id|limit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
id|MAX_SECTORS
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|max_segments
op_assign
(paren
id|d-&gt;controller-&gt;status_block-&gt;inbound_frame_size
op_minus
l_int|8
)paren
op_div
l_int|2
suffix:semicolon
)brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|0
comma
op_amp
id|type
comma
l_int|1
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|d-&gt;dev_name
comma
l_string|&quot;%s%c&quot;
comma
id|i2ob_gendisk.major_name
comma
l_char|&squot;a&squot;
op_plus
(paren
id|unit
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|d-&gt;dev_name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Disk Storage&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;WORM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;CD-ROM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Optical device&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Type %d&quot;
comma
id|type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(RAID)&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|flags
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|flags
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; Not loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;- %dMb, %d byte sectors&quot;
comma
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|20
)paren
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|u32
id|cachesize
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0003
comma
l_int|0
comma
op_amp
id|cachesize
comma
l_int|4
)paren
suffix:semicolon
id|cachesize
op_rshift_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|cachesize
OG
l_int|4095
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, %dMb cache&quot;
comma
id|cachesize
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, %dKb cache&quot;
comma
id|cachesize
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Maximum sectors/read set to %d.&bslash;n&quot;
comma
id|d-&gt;dev_name
comma
id|i2ob_max_sectors
(braket
id|unit
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If this is the first I2O block device found on this IOP,&n;&t; * we need to initialize all the queue data structures&n;&t; * before any I/O can be performed. If it fails, this&n;&t; * device is useless.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
)paren
(brace
r_if
c_cond
(paren
id|i2ob_init_iop
c_func
(paren
id|c-&gt;unit
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * This will save one level of lookup/indirection in critical &n;&t; * code so that we can directly get the queue ptr from the&n;&t; * device instead of having to go the IOP data structure.&n;&t; */
id|dev-&gt;req_queue
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|req_queue
suffix:semicolon
id|grok_partitions
c_func
(paren
op_amp
id|i2ob_gendisk
comma
id|unit
op_rshift
l_int|4
comma
l_int|1
op_lshift
l_int|4
comma
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|9
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register for the events we&squot;re interested in and that the&n;&t; * device actually supports.&n;&t; */
id|i2o_event_register
c_func
(paren
id|c
comma
id|d-&gt;lct_data.tid
comma
id|i2ob_context
comma
id|unit
comma
(paren
id|I2OB_EVENT_MASK
op_amp
id|d-&gt;lct_data.event_capabilities
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize IOP specific queue structures.  This is called&n; * once for each IOP that has a block device sitting behind it.&n; */
DECL|function|i2ob_init_iop
r_static
r_int
id|i2ob_init_iop
c_func
(paren
r_int
r_int
id|unit
)paren
(brace
r_int
id|i
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_assign
(paren
r_struct
id|i2ob_iop_queue
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2ob_iop_queue
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i2ob_queues
(braket
id|unit
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not allocate request queue for I2O block device!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB_DEPTH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
)braket
dot
id|next
op_assign
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
)braket
dot
id|num
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Queue is MAX_I2OB + 1... */
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|i2ob_qhead
op_assign
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
l_int|0
)braket
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|queue_depth
comma
l_int|0
)paren
suffix:semicolon
id|blk_init_queue
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue
comma
id|i2ob_request
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue
comma
l_int|0
)paren
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue.back_merge_fn
op_assign
id|i2ob_back_merge
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue.front_merge_fn
op_assign
id|i2ob_front_merge
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue.merge_requests_fn
op_assign
id|i2ob_merge_requests
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue.queuedata
op_assign
op_amp
id|i2ob_queues
(braket
id|unit
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the request queue for the given device.&n; */
DECL|function|i2ob_get_queue
r_static
id|request_queue_t
op_star
id|i2ob_get_queue
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|unit
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
l_int|0xF0
suffix:semicolon
r_return
id|i2ob_dev
(braket
id|unit
)braket
dot
id|req_queue
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe the I2O subsytem for block class devices&n; */
DECL|function|i2ob_probe
r_static
r_void
id|i2ob_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|unit
op_assign
l_int|0
suffix:semicolon
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|i2o_find_controller
c_func
(paren
id|i
)paren
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|d
op_assign
id|c-&gt;devices
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;lct_data.class_id
op_ne
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;lct_data.user_tid
op_ne
l_int|0xFFF
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_block: Controller %d, TID %d&bslash;n&quot;
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;&bslash;tDevice refused claim! Skipping installation&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
OL
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the device and fill in the&n;&t;&t;&t;&t; * Tid and controller.&n;&t;&t;&t;&t; */
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
id|dev-&gt;i2odev
op_assign
id|d
suffix:semicolon
id|dev-&gt;controller
op_assign
id|c
suffix:semicolon
id|dev-&gt;unit
op_assign
id|c-&gt;unit
suffix:semicolon
id|dev-&gt;tid
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_install_device
c_func
(paren
id|c
comma
id|d
comma
id|unit
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not install I2O block device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|unit
op_add_assign
l_int|16
suffix:semicolon
id|i2ob_dev_count
op_increment
suffix:semicolon
multiline_comment|/* We want to know when device goes away */
id|i2o_device_notify_on
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_block: too many device, registering only %d.&bslash;n&quot;
comma
id|unit
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
)brace
id|i2o_release_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
)brace
id|i2o_unlock_controller
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * New device notification handler.  Called whenever a new&n; * I2O block storage device is added to the system.&n; * &n; * Should we spin lock around this to keep multiple devs from &n; * getting updated at the same time? &n; * &n; */
DECL|function|i2ob_new_device
r_void
id|i2ob_new_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_int
id|unit
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: New device detected&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;   Controller %d Tid %d&bslash;n&quot;
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
multiline_comment|/* Check for available space */
r_if
c_cond
(paren
id|i2ob_dev_count
op_ge
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: No more devices allowed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
(paren
id|MAX_I2OB
op_lshift
l_int|4
)paren
suffix:semicolon
id|unit
op_add_assign
l_int|16
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Creating a RAID 5 volume takes a little while and the UTIL_CLAIM&n;&t; * will fail if we don&squot;t give the card enough time to do it&squot;s magic, &n;&t; * so we just sleep for a little while and let it do it&squot;s thing&n;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: Unable to claim device. Installation aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
id|dev-&gt;i2odev
op_assign
id|d
suffix:semicolon
id|dev-&gt;controller
op_assign
id|c
suffix:semicolon
id|dev-&gt;tid
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_install_device
c_func
(paren
id|c
comma
id|d
comma
id|unit
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: Could not install new device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|i2ob_dev_count
op_increment
suffix:semicolon
id|i2o_device_notify_on
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
)brace
id|i2o_release_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Deleted device notification handler.  Called when a device we&n; * are talking to has been deleted by the user or some other&n; * mysterious fource outside the kernel.&n; */
DECL|function|i2ob_del_device
r_void
id|i2ob_del_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_int
id|unit
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to do this...we somtimes get two events from the IRTOS&n;&t; * in a row and that causes lots of problems.&n;&t; */
id|i2o_device_notify_off
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block Device Deleted&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_I2OB
op_lshift
l_int|4
suffix:semicolon
id|unit
op_add_assign
l_int|16
)paren
(brace
r_if
c_cond
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev
op_eq
id|d
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  /dev/%s: Controller %d Tid %d&bslash;n&quot;
comma
id|d-&gt;dev_name
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|unit
op_ge
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob_del_device called, but not in dev table!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * This will force errors when i2ob_get_queue() is called&n;&t; * by the kenrel.&n;&t; */
id|i2ob_dev
(braket
id|unit
)braket
dot
id|req_queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|i2odev
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_sizes
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i2ob_hardsizes
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i2ob
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sync the device...this will force all outstanding I/Os&n;&t; * to attempt to complete, thus causing error messages.&n;&t; * We have to do this as the user could immediatelly create&n;&t; * a new volume that gets assigned the same minor number.&n;&t; * If there are still outstanding writes to the device,&n;&t; * that could cause data corruption on the new volume!&n;&t; *&n;&t; * The truth is that deleting a volume that you are currently&n;&t; * accessing will do _bad things_ to your system.  This &n;&t; * handler will keep it from crashing, but must probably &n;&t; * you&squot;ll have to do a &squot;reboot&squot; to get the system running&n;&t; * properly.  Deleting disks you are using is dumb.  &n;&t; * Umount them first and all will be good!&n;&t; *&n;&t; * It&squot;s not this driver&squot;s job to protect the system from&n;&t; * dumb user mistakes :)&n;&t; */
r_if
c_cond
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|refcnt
)paren
(brace
id|fsync_dev
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|unit
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decrease usage count for module&n;&t; */
r_while
c_loop
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|refcnt
op_decrement
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|i2ob_dev
(braket
id|unit
)braket
dot
id|refcnt
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Do we need this?&n;&t; * The media didn&squot;t really change...the device is just gone&n;&t; */
id|i2ob_media_change_flag
(braket
id|unit
)braket
op_assign
l_int|1
suffix:semicolon
id|i2ob_dev_count
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Have we seen a media change ?&n; */
DECL|function|i2ob_media_change
r_static
r_int
id|i2ob_media_change
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|i
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|i
op_rshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_media_change_flag
(braket
id|i
)braket
)paren
(brace
id|i2ob_media_change_flag
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2ob_revalidate
r_static
r_int
id|i2ob_revalidate
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_return
id|do_i2ob_revalidate
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reboot notifier.  This is called by i2o_core when the system&n; * shuts down.&n; */
DECL|function|i2ob_reboot_event
r_static
r_void
id|i2ob_reboot_event
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|i
op_lshift
l_int|4
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Flush the onboard cache&n;&t;&t;&t; */
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_int
op_star
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_CFLUSH
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|60
op_lshift
l_int|16
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Unlock the media&n;&t;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MUNLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|i2ob_fops
r_static
r_struct
id|block_device_operations
id|i2ob_fops
op_assign
(brace
id|open
suffix:colon
id|i2ob_open
comma
id|release
suffix:colon
id|i2ob_release
comma
id|ioctl
suffix:colon
id|i2ob_ioctl
comma
id|check_media_change
suffix:colon
id|i2ob_media_change
comma
id|revalidate
suffix:colon
id|i2ob_revalidate
comma
)brace
suffix:semicolon
DECL|variable|i2ob_gendisk
r_static
r_struct
id|gendisk
id|i2ob_gendisk
op_assign
(brace
id|MAJOR_NR
comma
l_string|&quot;i2o/hd&quot;
comma
l_int|4
comma
l_int|1
op_lshift
l_int|4
comma
id|i2ob
comma
id|i2ob_sizes
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * And here should be modules and kernel interface &n; *  (Just smiley confuses emacs :-)&n; */
macro_line|#ifdef MODULE
DECL|macro|i2o_block_init
mdefine_line|#define i2o_block_init init_module
macro_line|#endif
DECL|function|i2o_block_init
r_int
id|i2o_block_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block Storage OSM v0.9&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;   (c) Copyright 1999, 2000 Red Hat Software.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register the block device interfaces&n;&t; */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
comma
op_amp
id|i2ob_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get major number %d for i2o_block&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: registered device at major %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Now fill in the boiler plate&n;&t; */
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_blksizes
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_hardsizes
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_sizes
suffix:semicolon
id|max_sectors
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_max_sectors
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|queue
op_assign
id|i2ob_get_queue
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|i2ob_request
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
op_lshift
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|refcnt
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|controller
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|i2odev
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tid
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|head
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tail
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_blksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Set up the queue&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_queues
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Timers&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|i2ob_timer
)paren
suffix:semicolon
id|i2ob_timer.function
op_assign
id|i2ob_timer_handler
suffix:semicolon
id|i2ob_timer.data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register the OSM handler as we will need this to probe for&n;&t; *&t;drives, geometry and other goodies.&n;&t; */
r_if
c_cond
(paren
id|i2o_install_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
OL
l_int|0
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: unable to register OSM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|i2ob_context
op_assign
id|i2o_block_handler.context
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize event handling thread&n;&t; */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|i2ob_evt_sem
)paren
suffix:semicolon
id|evt_pid
op_assign
id|kernel_thread
c_func
(paren
id|i2ob_evt
comma
l_int|NULL
comma
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evt_pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: Could not initialize event thread.  Aborting&bslash;n&quot;
)paren
suffix:semicolon
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Finally see what is actually plugged in to our controllers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
id|register_disk
c_func
(paren
op_amp
id|i2ob_gendisk
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
op_lshift
l_int|4
)paren
comma
l_int|1
op_lshift
l_int|4
comma
op_amp
id|i2ob_fops
comma
l_int|0
)paren
suffix:semicolon
id|i2ob_probe
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Red Hat Software&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;I2O Block Device OSM&quot;
)paren
suffix:semicolon
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
op_star
id|gdp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Unregister for updates from any devices..otherwise we still&n;&t; * get them and the core jumps to random memory :O&n;&t; */
r_if
c_cond
(paren
id|i2ob_dev_count
)paren
(brace
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|d
op_assign
id|i2ob_dev
(braket
id|i
op_lshift
l_int|4
)braket
dot
id|i2odev
)paren
)paren
(brace
id|i2o_device_notify_off
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
id|i2o_event_register
c_func
(paren
id|d-&gt;controller
comma
id|d-&gt;lct_data.tid
comma
id|i2ob_context
comma
id|i
op_lshift
l_int|4
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Flush the OSM&n;&t; */
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Return the block device&n;&t; */
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;i2o_block: cleanup_module failed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free request queue&n;&t; */
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evt_running
)paren
(brace
id|i
op_assign
id|kill_proc
c_func
(paren
id|evt_pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
r_int
id|count
op_assign
l_int|5
op_star
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|evt_running
op_logical_and
op_decrement
id|count
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Giving up on i2oblock thread...&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Why isnt register/unregister gendisk in the kernel ???&n;&t; */
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|i2ob_gendisk
)paren
r_break
suffix:semicolon
)brace
macro_line|#endif
eof
