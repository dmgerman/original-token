multiline_comment|/*&n; *&t;I2O block device driver. &n; *&n; *&t;(C) Copyright 1999   Red Hat Software&n; *&t;&n; *&t;Written by Alan Cox, Building Number Three Ltd&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; * &t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;This is a beta test release. Most of the good code was taken&n; *&t;from the nbd driver by Pavel Machek, who in turn took some of it&n; *&t;from loop.c. Isn&squot;t free software great for reusability 8)&n; *&n; *&t;Fixes:&n; *&t;&t;Steve Ralston:&t;Multiple device handling error fixes,&n; *&t;&t;&t;&t;Added a queue depth.&n; *&t;&t;Alan Cox:&t;FC920 has an rmw bug. Dont or in the&n; *&t;&t;&t;&t;end marker.&n; *&t;&t;&t;&t;Removed queue walk, fixed for 64bitness.&n; *&t;To do:&n; *&t;&t;Multiple majors&n; *&t;&t;Serial number scanning to find duplicates for FC multipathing&n; *&t;&t;Set the new max_sectors according to max message size&n; *&t;&t;Use scatter gather chains for bigger I/O sizes&n; */
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/i2o.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR I2O_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|MAX_I2OB
mdefine_line|#define MAX_I2OB&t;16
DECL|macro|MAX_I2OB_DEPTH
mdefine_line|#define MAX_I2OB_DEPTH&t;32                
DECL|macro|MAX_I2OB_RETRIES
mdefine_line|#define MAX_I2OB_RETRIES 4
multiline_comment|/*&n; *&t;Some of these can be made smaller later&n; */
DECL|variable|i2ob_blksizes
r_static
r_int
id|i2ob_blksizes
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_hardsizes
r_static
r_int
id|i2ob_hardsizes
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_sizes
r_static
r_int
id|i2ob_sizes
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_media_change_flag
r_static
r_int
id|i2ob_media_change_flag
(braket
id|MAX_I2OB
)braket
suffix:semicolon
DECL|variable|i2ob_max_sectors
r_static
id|u32
id|i2ob_max_sectors
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_context
r_static
r_int
id|i2ob_context
suffix:semicolon
DECL|struct|i2ob_device
r_struct
id|i2ob_device
(brace
DECL|member|controller
r_struct
id|i2o_controller
op_star
id|controller
suffix:semicolon
DECL|member|i2odev
r_struct
id|i2o_device
op_star
id|i2odev
suffix:semicolon
DECL|member|tid
r_int
id|tid
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
DECL|member|head
DECL|member|tail
r_struct
id|request
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
DECL|member|done_flag
r_int
id|done_flag
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;FIXME:&n; *&t;We should cache align these to avoid ping-ponging lines on SMP&n; *&t;boxes under heavy I/O load...&n; */
DECL|struct|i2ob_request
r_struct
id|i2ob_request
(brace
DECL|member|next
r_struct
id|i2ob_request
op_star
id|next
suffix:semicolon
DECL|member|req
r_struct
id|request
op_star
id|req
suffix:semicolon
DECL|member|num
r_int
id|num
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Each I2O disk is one of these.&n; */
DECL|variable|i2ob_dev
r_static
r_struct
id|i2ob_device
id|i2ob_dev
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_devices
r_static
r_int
id|i2ob_devices
op_assign
l_int|0
suffix:semicolon
DECL|variable|i2ob
r_static
r_struct
id|hd_struct
id|i2ob
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_gendisk
r_static
r_struct
id|gendisk
id|i2ob_gendisk
suffix:semicolon
multiline_comment|/* Declared later */
DECL|variable|queue_depth
r_static
id|atomic_t
id|queue_depth
suffix:semicolon
multiline_comment|/* For flow control later on */
DECL|variable|i2ob_queue
r_static
r_struct
id|i2ob_request
id|i2ob_queue
(braket
id|MAX_I2OB_DEPTH
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|i2ob_qhead
r_static
r_struct
id|i2ob_request
op_star
id|i2ob_qhead
suffix:semicolon
DECL|variable|i2ob_timer
r_static
r_struct
id|timer_list
id|i2ob_timer
suffix:semicolon
DECL|variable|i2ob_timer_started
r_static
r_int
id|i2ob_timer_started
op_assign
l_int|0
suffix:semicolon
DECL|macro|DEBUG
mdefine_line|#define DEBUG( s )
multiline_comment|/* #define DEBUG( s ) printk( s ) &n; */
r_static
r_int
id|i2ob_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|i2ob_end_request
c_func
(paren
r_struct
id|request
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
suffix:semicolon
multiline_comment|/*&n; * Dump messages.&n; */
DECL|function|i2ob_dump_msg
r_static
r_void
id|i2ob_dump_msg
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
comma
id|u32
op_star
id|msg
comma
r_int
id|size
)paren
(brace
r_int
id|cnt
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n&bslash;ni2o message:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|size
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;m[%d]=%x&bslash;n&quot;
comma
id|cnt
comma
id|msg
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get a message&n; */
DECL|function|i2ob_get
r_static
id|u32
id|i2ob_get
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev-&gt;controller
suffix:semicolon
r_return
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Turn a Linux block request into an I2O block read/write.&n; */
DECL|function|i2ob_send
r_static
r_int
id|i2ob_send
c_func
(paren
id|u32
id|m
comma
r_struct
id|i2ob_device
op_star
id|dev
comma
r_struct
id|i2ob_request
op_star
id|ireq
comma
id|u32
id|base
comma
r_int
id|unit
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev-&gt;controller
suffix:semicolon
r_int
id|tid
op_assign
id|dev-&gt;tid
suffix:semicolon
r_int
r_int
id|msg
suffix:semicolon
r_int
r_int
id|mptr
suffix:semicolon
id|u64
id|offset
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|ireq-&gt;req
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_int
id|count
op_assign
id|req-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
multiline_comment|/* Map the message to a virtual address */
id|msg
op_assign
id|c-&gt;mem_offset
op_plus
id|m
suffix:semicolon
multiline_comment|/*&n;         * Build the message based on the request.&n;&t; */
id|__raw_writel
c_func
(paren
id|i2ob_context
op_or
(paren
id|unit
op_lshift
l_int|8
)paren
comma
id|msg
op_plus
l_int|8
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|ireq-&gt;num
comma
id|msg
op_plus
l_int|12
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|req-&gt;nr_sectors
op_lshift
l_int|9
comma
id|msg
op_plus
l_int|20
)paren
suffix:semicolon
multiline_comment|/* This can be optimised later - just want to be sure its right for&n;&t;   starters */
id|offset
op_assign
(paren
(paren
id|u64
)paren
(paren
id|req-&gt;sector
op_plus
id|base
)paren
)paren
op_lshift
l_int|9
suffix:semicolon
id|__raw_writel
c_func
(paren
id|offset
op_amp
l_int|0xFFFFFFFF
comma
id|msg
op_plus
l_int|24
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|offset
op_rshift
l_int|32
comma
id|msg
op_plus
l_int|28
)paren
suffix:semicolon
id|mptr
op_assign
id|msg
op_plus
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|READ
)paren
(brace
id|__raw_writel
c_func
(paren
id|I2O_CMD_BLOCK_READ
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t yet do cache/readahead and other magic */
id|__raw_writel
c_func
(paren
l_int|1
op_lshift
l_int|16
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Its best to do this in one not or it in&n;&t;&t;&t; *&t;later. mptr is in PCI space so fast to write&n;&t;&t;&t; *&t;sucky to read.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bh-&gt;b_reqnext
)paren
(brace
id|__raw_writel
c_func
(paren
l_int|0x10000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
)brace
r_else
id|__raw_writel
c_func
(paren
l_int|0xD0000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
comma
id|mptr
op_plus
l_int|4
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|8
suffix:semicolon
id|count
op_sub_assign
id|bh-&gt;b_size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|__raw_writel
c_func
(paren
id|I2O_CMD_BLOCK_WRITE
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
l_int|1
op_lshift
l_int|16
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_reqnext
)paren
(brace
id|__raw_writel
c_func
(paren
l_int|0x14000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
)brace
r_else
id|__raw_writel
c_func
(paren
l_int|0xD4000000
op_or
(paren
id|bh-&gt;b_size
)paren
comma
id|mptr
)paren
suffix:semicolon
id|count
op_sub_assign
id|bh-&gt;b_size
suffix:semicolon
id|__raw_writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
comma
id|mptr
op_plus
l_int|4
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|8
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
id|__raw_writel
c_func
(paren
id|I2O_MESSAGE_SIZE
c_func
(paren
id|mptr
op_minus
id|msg
)paren
op_rshift
l_int|2
op_or
id|SGL_OFFSET_8
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;current_nr_sectors
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Gathered sectors %ld.&bslash;n&quot;
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Request count botched by %d.&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
)brace
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a request from the _locked_ request list. We update both the&n; *&t;list chain and if this is the last item the tail pointer. Caller&n; *&t;must hold the lock.&n; */
DECL|function|i2ob_unhook_request
r_static
r_inline
r_void
id|i2ob_unhook_request
c_func
(paren
r_struct
id|i2ob_request
op_star
id|ireq
)paren
(brace
id|ireq-&gt;next
op_assign
id|i2ob_qhead
suffix:semicolon
id|i2ob_qhead
op_assign
id|ireq
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Request completion handler&n; */
DECL|function|i2ob_end_request
r_static
r_void
id|i2ob_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
multiline_comment|/*&n;&t; * Loop until all of the buffers that are linked&n;&t; * to this request have been marked updated and&n;&t; * unlocked.&n;&t; */
singleline_comment|//&t;printk(&quot;ending request %p: &quot;, req);
r_while
c_loop
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
op_logical_neg
id|req-&gt;errors
comma
l_string|&quot;i2o block&quot;
)paren
)paren
(brace
singleline_comment|//&t;&t;printk(&quot; +&bslash;n&quot;);
)brace
multiline_comment|/*&n;&t; * It is now ok to complete the request.&n;&t; */
singleline_comment|//&t;printk(&quot;finishing &quot;);
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;done&bslash;n&quot;);
)brace
multiline_comment|/*&n; *&t;OSM reply handler. This gets all the message replies&n; */
DECL|function|i2o_block_reply
r_static
r_void
id|i2o_block_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
comma
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_message
op_star
id|msg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|i2ob_request
op_star
id|ireq
suffix:semicolon
id|u8
id|st
suffix:semicolon
id|u32
op_star
id|m
op_assign
(paren
id|u32
op_star
)paren
id|msg
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|m
(braket
l_int|2
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xF0
suffix:semicolon
multiline_comment|/* low 4 bits are partition */
r_if
c_cond
(paren
id|m
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IOP fail.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;From %d To %d Cmd %d.&bslash;n&quot;
comma
(paren
id|m
(braket
l_int|1
)braket
op_rshift
l_int|12
)paren
op_amp
l_int|0xFFF
comma
id|m
(braket
l_int|1
)braket
op_amp
l_int|0xFFF
comma
id|m
(braket
l_int|1
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Failure Code %d.&bslash;n&quot;
comma
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Format error.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|17
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Path error.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Path State.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Congestion.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|m
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|m
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Failing message is %p.&bslash;n&quot;
comma
id|m
)paren
suffix:semicolon
multiline_comment|/* We need to up the request failure count here and maybe&n;&t;&t;   abort it */
id|ireq
op_assign
op_amp
id|i2ob_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
multiline_comment|/* Now flush the message by making it a NOP */
id|m
(braket
l_int|0
)braket
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|m
(braket
l_int|0
)braket
op_or_assign
(paren
id|I2O_CMD_UTIL_NOP
)paren
op_lshift
l_int|24
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|virt_to_bus
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|m
(braket
l_int|2
)braket
op_amp
l_int|0x40000000
)paren
(brace
r_int
op_star
id|ptr
op_assign
(paren
r_int
op_star
)paren
id|m
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
)paren
(brace
op_star
id|ptr
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
op_star
id|ptr
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Lets see what is cooking. We stuffed the&n;&t;&t; *&t;request in the context.&n;&t;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|st
op_assign
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob: error %08X&bslash;n&quot;
comma
id|m
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ireq-&gt;req-&gt;errors
OL
id|MAX_I2OB_RETRIES
)paren
(brace
id|u32
id|retry_msg
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob: attempting retry %d for request %p&bslash;n&quot;
comma
id|ireq-&gt;req-&gt;errors
op_plus
l_int|1
comma
id|ireq-&gt;req
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Get a message for this retry.&n;&t;&t;&t;&t; */
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|unit
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
id|retry_msg
op_assign
id|i2ob_get
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * If we cannot get a message then&n;&t;&t;&t;&t; * forget the retry and fail the&n;&t;&t;&t;&t; * request.   Note that since this is&n;&t;&t;&t;&t; * being called from the interrupt &n;&t;&t;&t;&t; * handler, a request has just been &n;&t;&t;&t;&t; * completed and there will most likely &n;&t;&t;&t;&t; * be space on the inbound message&n;&t;&t;&t;&t; * fifo so this won&squot;t happen often.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|retry_msg
op_ne
l_int|0xFFFFFFFF
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;                 * Decrement the queue depth since&n;&t;&t;&t;                 * this request has completed and&n;&t;&t;&t;                 * it will be incremented again when&n;&t;&t;&t;                 * i2ob_send is called below.&n;&t;&t;&t;                 */
id|atomic_dec
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;                 * Send the request again.&n;&t;&t;&t;                 */
id|i2ob_send
c_func
(paren
id|retry_msg
comma
id|dev
comma
id|ireq
comma
id|i2ob
(braket
id|unit
)braket
dot
id|start_sect
comma
(paren
id|unit
op_amp
l_int|0xF0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Don&squot;t fall through.&n;&t;&t;&t;&t;&t; */
r_return
suffix:semicolon
)brace
)brace
)brace
r_else
id|ireq-&gt;req-&gt;errors
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Dequeue the request. We use irqsave locks as one day we&n;&t; *&t;may be running polled controllers from a BH...&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We may be able to do more I/O&n;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
id|i2ob_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|i2o_block_handler
r_static
r_struct
id|i2o_handler
id|i2o_block_handler
op_assign
(brace
id|i2o_block_reply
comma
l_string|&quot;I2O Block OSM&quot;
comma
l_int|0
comma
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
)brace
suffix:semicolon
multiline_comment|/*&n; * The timer handler will attempt to restart requests &n; * that are queued to the driver.  This handler&n; * currently only gets called if the controller&n; * had no more room in its inbound fifo.  &n; */
DECL|function|i2ob_timer_handler
r_static
r_void
id|i2ob_timer_handler
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot touch the request queue or the timer&n;         * flag without holding the io_request_lock.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Clear the timer started flag so that &n;&t; * the timer can be queued again.&n;&t; */
id|i2ob_timer_started
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Restart any requests.&n;&t; */
id|i2ob_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Free the lock.&n;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The I2O block driver is listed as one of those that pulls the&n; *&t;front entry off the queue before processing it. This is important&n; *&t;to remember here. If we drop the io lock then CURRENT will change&n; *&t;on us. We must unlink CURRENT in this routine before we return, if&n; *&t;we use it.&n; */
DECL|function|i2ob_request
r_static
r_void
id|i2ob_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|i2ob_request
op_star
id|ireq
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
id|u32
id|m
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|QUEUE_EMPTY
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;On an IRQ completion if there is an inactive&n;&t;&t; *&t;request on the queue head it means it isnt yet&n;&t;&t; *&t;ready to dispatch.&n;&t;&t; */
r_if
c_cond
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Queue depths probably belong with some kind of&n;&t;&t; *&t;generic IOP commit control. Certainly its not right&n;&t;&t; *&t;its global!&n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|queue_depth
)paren
op_ge
id|MAX_I2OB_DEPTH
)paren
(brace
r_break
suffix:semicolon
)brace
id|req
op_assign
id|CURRENT
suffix:semicolon
id|unit
op_assign
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|unit
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
multiline_comment|/* Get a message */
id|m
op_assign
id|i2ob_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * See if the timer has already been queued.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i2ob_timer_started
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob: starting timer&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set the timer_started flag to insure&n;&t;&t;&t;&t; * that the timer is only queued once.&n;&t;&t;&t;&t; * Queing it more than once will corrupt&n;&t;&t;&t;&t; * the timer queue.&n;&t;&t;&t;&t; */
id|i2ob_timer_started
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Set up the timer to expire in&n;&t;&t;&t;&t; * 500ms.&n;&t;&t;&t;&t; */
id|i2ob_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Start it.&n;&t;&t;&t;&t; */
id|add_timer
c_func
(paren
op_amp
id|i2ob_timer
)paren
suffix:semicolon
)brace
)brace
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|req-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
id|ireq
op_assign
id|i2ob_qhead
suffix:semicolon
id|i2ob_qhead
op_assign
id|ireq-&gt;next
suffix:semicolon
id|ireq-&gt;req
op_assign
id|req
suffix:semicolon
id|i2ob_send
c_func
(paren
id|m
comma
id|dev
comma
id|ireq
comma
id|i2ob
(braket
id|unit
)braket
dot
id|start_sect
comma
(paren
id|unit
op_amp
l_int|0xF0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;SCSI-CAM for ioctl geometry mapping&n; *&t;Duplicated with SCSI - this should be moved into somewhere common&n; *&t;perhaps genhd ?&n; */
DECL|function|i2o_block_biosparam
r_static
r_void
id|i2o_block_biosparam
c_func
(paren
r_int
r_int
id|capacity
comma
r_int
r_int
op_star
id|cyls
comma
r_int
r_char
op_star
id|hds
comma
r_int
r_char
op_star
id|secs
)paren
(brace
r_int
r_int
id|heads
comma
id|sectors
comma
id|cylinders
comma
id|temp
suffix:semicolon
id|cylinders
op_assign
l_int|1024L
suffix:semicolon
multiline_comment|/* Set number of cylinders to max */
id|sectors
op_assign
l_int|62L
suffix:semicolon
multiline_comment|/* Maximize sectors per track */
id|temp
op_assign
id|cylinders
op_star
id|sectors
suffix:semicolon
multiline_comment|/* Compute divisor for heads */
id|heads
op_assign
id|capacity
op_div
id|temp
suffix:semicolon
multiline_comment|/* Compute value for number of heads */
r_if
c_cond
(paren
id|capacity
op_mod
id|temp
)paren
(brace
multiline_comment|/* If no remainder, done! */
id|heads
op_increment
suffix:semicolon
multiline_comment|/* Else, increment number of heads */
id|temp
op_assign
id|cylinders
op_star
id|heads
suffix:semicolon
multiline_comment|/* Compute divisor for sectors */
id|sectors
op_assign
id|capacity
op_div
id|temp
suffix:semicolon
multiline_comment|/* Compute value for sectors per&n;&t;&t;&t;&t;&t;&t;       track */
r_if
c_cond
(paren
id|capacity
op_mod
id|temp
)paren
(brace
multiline_comment|/* If no remainder, done! */
id|sectors
op_increment
suffix:semicolon
multiline_comment|/* Else, increment number of sectors */
id|temp
op_assign
id|heads
op_star
id|sectors
suffix:semicolon
multiline_comment|/* Compute divisor for cylinders */
id|cylinders
op_assign
id|capacity
op_div
id|temp
suffix:semicolon
multiline_comment|/* Compute number of cylinders */
)brace
)brace
multiline_comment|/* if something went wrong, then apparently we have to return&n;&t;   a geometry with more than 1024 cylinders */
r_if
c_cond
(paren
id|cylinders
op_eq
l_int|0
op_logical_or
id|heads
OG
l_int|255
op_logical_or
id|sectors
OG
l_int|63
op_logical_or
id|cylinders
OG
l_int|1023
)paren
(brace
r_int
r_int
id|temp_cyl
suffix:semicolon
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|temp_cyl
op_assign
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_cyl
OG
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
)brace
id|cylinders
op_assign
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
op_star
id|cyls
op_assign
(paren
r_int
r_int
)paren
id|cylinders
suffix:semicolon
multiline_comment|/* Stuff return values */
op_star
id|secs
op_assign
(paren
r_int
r_int
)paren
id|sectors
suffix:semicolon
op_star
id|hds
op_assign
(paren
r_int
r_int
)paren
id|heads
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rescan the partition tables&n; */
DECL|function|do_i2ob_revalidate
r_static
r_int
id|do_i2ob_revalidate
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxu
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|minor
op_and_assign
l_int|0xF0
suffix:semicolon
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
OG
id|maxu
op_plus
l_int|1
)paren
(brace
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|15
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|m
op_assign
id|minor
op_plus
id|i
suffix:semicolon
id|kdev_t
id|d
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|m
)paren
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|d
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
(brace
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
id|invalidate_buffers
c_func
(paren
id|d
)paren
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|m
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|i2ob_gendisk.part
(braket
id|m
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do a physical check and then reconfigure&n;&t; */
id|i2ob_install_device
c_func
(paren
id|i2ob_dev
(braket
id|minor
)braket
dot
id|controller
comma
id|i2ob_dev
(braket
id|minor
)braket
dot
id|i2odev
comma
id|minor
)paren
suffix:semicolon
id|i2ob_dev
(braket
id|minor
)braket
dot
id|refcnt
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue device specific ioctl calls.&n; */
DECL|function|i2ob_ioctl
r_static
r_int
id|i2ob_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_int
id|minor
suffix:semicolon
multiline_comment|/* Anyone capable of this syscall can do *real bad* things */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
(paren
id|MAX_I2OB
op_lshift
l_int|4
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|minor
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
r_return
id|put_user
c_func
(paren
id|i2ob
(braket
id|minor
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|g
suffix:semicolon
r_int
id|u
op_assign
id|minor
op_amp
l_int|0xF0
suffix:semicolon
id|i2o_block_biosparam
c_func
(paren
id|i2ob_sizes
(braket
id|u
)braket
op_lshift
l_int|1
comma
op_amp
id|g.cylinders
comma
op_amp
id|g.heads
comma
op_amp
id|g.sectors
)paren
suffix:semicolon
id|g.start
op_assign
id|i2ob
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|g
comma
r_sizeof
(paren
id|g
)paren
)paren
ques
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_case
id|BLKRRPART
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_return
id|do_i2ob_revalidate
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKPG
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Close the block device down&n; */
DECL|function|i2ob_release
r_static
r_int
id|i2ob_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_int
id|minor
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
(paren
id|MAX_I2OB
op_lshift
l_int|4
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|minor
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;i2ob_release: refcount(%d) &lt;= 0&bslash;n&quot;
comma
id|dev-&gt;refcnt
)paren
suffix:semicolon
id|dev-&gt;refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Flush the onboard cache on unmount&n;&t;&t; */
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_int
op_star
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_CFLUSH
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|60
op_lshift
l_int|16
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unlock the media&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MUNLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n; &t;&t; * Now unclaim the device.&n;&t;&t; */
r_if
c_cond
(paren
id|i2o_release_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
comma
id|I2O_CLAIM_PRIMARY
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob_release: controller rejected unclaim.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Open the block device.&n; */
DECL|function|i2ob_open
r_static
r_int
id|i2ob_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_I2OB
op_lshift
l_int|4
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|minor
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;i2odev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_increment
op_eq
l_int|0
)paren
(brace
id|u32
id|msg
(braket
l_int|6
)braket
suffix:semicolon
r_int
op_star
id|query_done
suffix:semicolon
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
comma
id|I2O_CLAIM_PRIMARY
)paren
OL
l_int|0
)paren
(brace
id|dev-&gt;refcnt
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Mount the media if needed. Note that we don&squot;t use&n;&t;&t; *&t;the lock bit. Since we have to issue a lock if it&n;&t;&t; *&t;refuses a mount (quite possible) then we might as&n;&t;&t; *&t;well just send two messages out.&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MMOUNT
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|24
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Lock the media&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue a device query&n; */
DECL|function|i2ob_query_device
r_static
r_int
id|i2ob_query_device
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
comma
r_int
id|table
comma
r_int
id|field
comma
r_void
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_return
id|i2o_query_scalar
c_func
(paren
id|dev-&gt;controller
comma
id|dev-&gt;tid
comma
id|table
comma
id|field
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Install the I2O block device we found.&n; */
DECL|function|i2ob_install_device
r_static
r_int
id|i2ob_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
comma
r_int
id|unit
)paren
(brace
id|u64
id|size
suffix:semicolon
id|u32
id|blocksize
suffix:semicolon
id|u32
id|limit
suffix:semicolon
id|u8
id|type
suffix:semicolon
id|u32
id|flags
comma
id|status
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ask for the current media data. If that isn&squot;t supported&n;&t; *&t;then we ask for the device capacity data&n;&t; */
r_if
c_cond
(paren
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0004
comma
l_int|1
comma
op_amp
id|blocksize
comma
l_int|4
)paren
op_ne
l_int|0
op_logical_or
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0004
comma
l_int|0
comma
op_amp
id|size
comma
l_int|8
)paren
op_ne
l_int|0
)paren
(brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|3
comma
op_amp
id|blocksize
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|4
comma
op_amp
id|size
comma
l_int|8
)paren
suffix:semicolon
)brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|5
comma
op_amp
id|flags
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|6
comma
op_amp
id|status
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_sizes
(braket
id|unit
)braket
op_assign
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|10
)paren
suffix:semicolon
id|i2ob_hardsizes
(braket
id|unit
)braket
op_assign
id|blocksize
suffix:semicolon
id|limit
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* 8 deep scatter gather */
id|printk
c_func
(paren
l_string|&quot;Byte limit is %d.&bslash;n&quot;
comma
id|limit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
(paren
id|limit
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
id|i2ob
(braket
id|unit
)braket
dot
id|nr_sects
op_assign
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|9
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|0
comma
op_amp
id|type
comma
l_int|1
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|d-&gt;dev_name
comma
l_string|&quot;%s%c&quot;
comma
id|i2ob_gendisk.major_name
comma
l_char|&squot;a&squot;
op_plus
(paren
id|unit
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|d-&gt;dev_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAID &quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Disk Storage&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;WORM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;CD-ROM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Optical device&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Type %d&quot;
comma
id|type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|flags
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|flags
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Not loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %dMb, %d byte sectors&quot;
comma
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|20
)paren
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|u32
id|cachesize
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0003
comma
l_int|0
comma
op_amp
id|cachesize
comma
l_int|4
)paren
suffix:semicolon
id|cachesize
op_rshift_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|cachesize
OG
l_int|4095
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, %dMb cache&quot;
comma
id|cachesize
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, %dKb cache&quot;
comma
id|cachesize
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Maximum sectors/read set to %d.&bslash;n&quot;
comma
id|d-&gt;dev_name
comma
id|i2ob_max_sectors
(braket
id|unit
)braket
)paren
suffix:semicolon
id|grok_partitions
c_func
(paren
op_amp
id|i2ob_gendisk
comma
id|unit
op_rshift
l_int|4
comma
l_int|1
op_lshift
l_int|4
comma
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|9
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2ob_probe
r_static
r_void
id|i2ob_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|unit
op_assign
l_int|0
suffix:semicolon
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|i2o_find_controller
c_func
(paren
id|i
)paren
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|d
op_assign
id|c-&gt;devices
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;lct_data-&gt;class_id
op_ne
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;lct_data-&gt;user_tid
op_ne
l_int|0xFFF
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
OL
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the device and fill in the&n;&t;&t;&t;&t; * Tid and controller.&n;&t;&t;&t;&t; */
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
id|dev-&gt;i2odev
op_assign
id|d
suffix:semicolon
id|dev-&gt;controller
op_assign
id|c
suffix:semicolon
id|dev-&gt;tid
op_assign
id|d-&gt;lct_data-&gt;tid
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Insure the device can be claimed&n;&t;&t;&t;&t; * before installing it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
comma
id|I2O_CLAIM_PRIMARY
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Claimed Dev %p Tid %d Unit %d&bslash;n&quot;
comma
id|dev
comma
id|dev-&gt;tid
comma
id|unit
)paren
suffix:semicolon
id|i2ob_install_device
c_func
(paren
id|c
comma
id|d
comma
id|unit
)paren
suffix:semicolon
id|unit
op_add_assign
l_int|16
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Now that the device has been&n;&t;&t;&t;&t;&t; * installed, unclaim it so that&n;&t;&t;&t;&t;&t; * it can be claimed by either&n;&t;&t;&t;&t;&t; * the block or scsi driver.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|i2o_release_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
comma
id|I2O_CLAIM_PRIMARY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Could not unclaim Dev %p Tid %d&bslash;n&quot;
comma
id|dev
comma
id|dev-&gt;tid
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TID %d not claimed&bslash;n&quot;
comma
id|dev-&gt;tid
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;i2o_block: too many device, registering only %d.&bslash;n&quot;
comma
id|unit
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
)brace
)brace
id|i2o_unlock_controller
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|i2ob_devices
op_assign
id|unit
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Have we seen a media change ?&n; */
DECL|function|i2ob_media_change
r_static
r_int
id|i2ob_media_change
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|i
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|i
op_rshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_media_change_flag
(braket
id|i
)braket
)paren
(brace
id|i2ob_media_change_flag
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2ob_revalidate
r_static
r_int
id|i2ob_revalidate
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_return
id|do_i2ob_revalidate
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|i2ob_reboot_event
r_static
r_int
id|i2ob_reboot_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|n
comma
r_int
r_int
id|code
comma
r_void
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
id|SYS_RESTART
op_logical_and
id|code
op_ne
id|SYS_HALT
op_logical_and
id|code
op_ne
id|SYS_POWER_OFF
)paren
(brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|i
op_lshift
l_int|4
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Flush the onboard cache on power down&n;&t;&t;&t; *&t;also unlock the media&n;&t;&t;&t; */
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_int
op_star
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_CFLUSH
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|60
op_lshift
l_int|16
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Unlock the media&n;&t;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MUNLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|i2ob_reboot_notifier
r_struct
id|notifier_block
id|i2ob_reboot_notifier
op_assign
(brace
id|i2ob_reboot_event
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|i2ob_fops
r_static
r_struct
id|block_device_operations
id|i2ob_fops
op_assign
(brace
id|open
suffix:colon
id|i2ob_open
comma
id|release
suffix:colon
id|i2ob_release
comma
id|ioctl
suffix:colon
id|i2ob_ioctl
comma
id|check_media_change
suffix:colon
id|i2ob_media_change
comma
id|revalidate
suffix:colon
id|i2ob_revalidate
comma
)brace
suffix:semicolon
DECL|variable|i2ob_gendisk
r_static
r_struct
id|gendisk
id|i2ob_gendisk
op_assign
(brace
id|MAJOR_NR
comma
l_string|&quot;i2ohd&quot;
comma
l_int|4
comma
l_int|1
op_lshift
l_int|4
comma
id|i2ob
comma
id|i2ob_sizes
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * And here should be modules and kernel interface &n; *  (Just smiley confuses emacs :-)&n; */
macro_line|#ifdef MODULE
DECL|macro|i2o_block_init
mdefine_line|#define i2o_block_init init_module
macro_line|#endif
DECL|function|i2o_block_init
r_int
id|i2o_block_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block Storage OSM v0.07. (C) 1999 Red Hat Software.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register the block device interfaces&n;&t; */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
comma
op_amp
id|i2ob_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major number %d for i2o_block&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|printk
c_func
(paren
l_string|&quot;i2o_block: registered device at major %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Now fill in the boiler plate&n;&t; */
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_blksizes
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_hardsizes
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_sizes
suffix:semicolon
id|max_sectors
(braket
id|MAJOR_NR
)braket
op_assign
id|i2ob_max_sectors
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|i2ob_request
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
op_lshift
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|refcnt
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|controller
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|i2odev
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tid
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|head
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tail
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_blksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Set up the queue&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB_DEPTH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_queue
(braket
id|i
)braket
dot
id|next
op_assign
op_amp
id|i2ob_queue
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|i2ob_queue
(braket
id|i
)braket
dot
id|num
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Queue is MAX_I2OB + 1... */
id|i2ob_queue
(braket
id|i
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_qhead
op_assign
op_amp
id|i2ob_queue
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Timers&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|i2ob_timer
)paren
suffix:semicolon
id|i2ob_timer.function
op_assign
id|i2ob_timer_handler
suffix:semicolon
id|i2ob_timer.data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register the OSM handler as we will need this to probe for&n;&t; *&t;drives, geometry and other goodies.&n;&t; */
r_if
c_cond
(paren
id|i2o_install_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
OL
l_int|0
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: unable to register OSM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|i2ob_context
op_assign
id|i2o_block_handler.context
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Finally see what is actually plugged in to our controllers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
id|register_disk
c_func
(paren
op_amp
id|i2ob_gendisk
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
op_lshift
l_int|4
)paren
comma
l_int|1
op_lshift
l_int|4
comma
op_amp
id|i2ob_fops
comma
l_int|0
)paren
suffix:semicolon
id|i2ob_probe
c_func
(paren
)paren
suffix:semicolon
id|register_reboot_notifier
c_func
(paren
op_amp
id|i2ob_reboot_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Red Hat Software&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;I2O Block Device OSM&quot;
)paren
suffix:semicolon
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
op_star
id|gdp
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|i2ob_reboot_notifier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the OSM&n;&t; */
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Return the block device&n;&t; */
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;i2o_block: cleanup_module failed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Why isnt register/unregister gendisk in the kernel ???&n;&t; */
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|i2ob_gendisk
)paren
r_break
suffix:semicolon
)brace
macro_line|#endif
eof
