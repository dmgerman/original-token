multiline_comment|/* &n; * File...........: linux/drivers/s390/block/dasd.c&n; * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&n; *                : Utz Bacher &lt;utz.bacher@de.ibm.com&gt;&n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif&t;&t;&t;&t;/* MODULE */
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/ebcdic.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/dasd.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;dasd_erp.h&quot;
macro_line|#include &quot;dasd_types.h&quot;
macro_line|#include &quot;dasd_ccwstuff.h&quot;
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER DASD_NAME&quot;:&quot;
DECL|macro|CCW_READ_DEVICE_CHARACTERISTICS
mdefine_line|#define CCW_READ_DEVICE_CHARACTERISTICS  0x64
DECL|macro|DASD_SSCH_RETRIES
mdefine_line|#define DASD_SSCH_RETRIES 2
multiline_comment|/* This macro is a little tricky, but makes the code more easy to read... */
DECL|macro|MATCH
mdefine_line|#define MATCH(info,ct,cm,dt,dm) ( &bslash;&n;(( info -&gt; sid_data.cu_type  ct ) &amp;&amp; ( info -&gt; sid_data.cu_model cm )) &amp;&amp; &bslash;&n;(( info -&gt; sid_data.dev_type dt ) &amp;&amp; ( info -&gt; sid_data.dev_model dm )) )
multiline_comment|/* Prototypes for the functions called from external */
r_static
r_int
id|dasd_ioctl
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|dasd_open
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|dasd_release
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_void
id|dasd_debug
(paren
r_int
r_int
id|tag
)paren
suffix:semicolon
r_void
id|dasd_profile_add
(paren
id|cqr_t
op_star
id|cqr
)paren
suffix:semicolon
r_void
id|dasd_proc_init
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|dasd_format
c_func
(paren
r_int
comma
id|format_data_t
op_star
)paren
suffix:semicolon
DECL|variable|dasd_device_operations
r_static
r_struct
id|block_device_operations
id|dasd_device_operations
suffix:semicolon
DECL|variable|dasd_lock
id|spinlock_t
id|dasd_lock
suffix:semicolon
multiline_comment|/* general purpose lock for the dasd driver */
multiline_comment|/* All asynchronous I/O should waint on this wait_queue */
DECL|variable|dasd_waitq
id|wait_queue_head_t
id|dasd_waitq
suffix:semicolon
DECL|variable|dasd_autodetect
r_static
r_int
id|dasd_autodetect
op_assign
l_int|1
suffix:semicolon
DECL|variable|dasd_devno
r_static
r_int
id|dasd_devno
(braket
id|DASD_MAX_DEVICES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dasd_count
r_static
r_int
id|dasd_count
op_assign
l_int|0
suffix:semicolon
r_extern
id|dasd_chanq_t
op_star
id|cq_head
suffix:semicolon
r_static
r_int
DECL|function|dasd_get_hexdigit
id|dasd_get_hexdigit
(paren
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|c
op_le
l_char|&squot;9&squot;
)paren
)paren
r_return
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_ge
l_char|&squot;a&squot;
)paren
op_logical_and
(paren
id|c
op_le
l_char|&squot;f&squot;
)paren
)paren
r_return
id|c
op_plus
l_int|10
op_minus
l_char|&squot;a&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_ge
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|c
op_le
l_char|&squot;F&squot;
)paren
)paren
r_return
id|c
op_plus
l_int|10
op_minus
l_char|&squot;A&squot;
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* sets the string pointer after the next comma */
r_static
r_void
DECL|function|dasd_scan_for_next_comma
id|dasd_scan_for_next_comma
(paren
r_char
op_star
op_star
id|strptr
)paren
(brace
r_while
c_loop
(paren
(paren
(paren
op_star
op_star
id|strptr
)paren
op_ne
l_char|&squot;,&squot;
)paren
op_logical_and
(paren
(paren
op_star
op_star
id|strptr
)paren
op_increment
)paren
)paren
(paren
op_star
id|strptr
)paren
op_increment
suffix:semicolon
multiline_comment|/* set the position AFTER the comma */
r_if
c_cond
(paren
op_star
op_star
id|strptr
op_eq
l_char|&squot;,&squot;
)paren
(paren
op_star
id|strptr
)paren
op_increment
suffix:semicolon
)brace
multiline_comment|/*sets the string pointer after the next comma, if a parse error occured */
r_static
r_int
DECL|function|dasd_get_next_int
id|dasd_get_next_int
(paren
r_char
op_star
op_star
id|strptr
)paren
(brace
r_int
id|j
comma
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* for cosmetic reasons first -1, then 0 */
r_if
c_cond
(paren
id|isxdigit
(paren
op_star
op_star
id|strptr
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|isxdigit
(paren
op_star
op_star
id|strptr
)paren
suffix:semicolon
)paren
(brace
id|i
op_lshift_assign
l_int|4
suffix:semicolon
id|j
op_assign
id|dasd_get_hexdigit
(paren
op_star
op_star
id|strptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
op_minus
l_int|1
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot;no integer: skipping range.&bslash;n&quot;
)paren
suffix:semicolon
id|dasd_scan_for_next_comma
(paren
id|strptr
)paren
suffix:semicolon
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|i
op_add_assign
id|j
suffix:semicolon
(paren
op_star
id|strptr
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0xffff
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot; value too big, skipping range.&bslash;n&quot;
)paren
suffix:semicolon
id|dasd_scan_for_next_comma
(paren
id|strptr
)paren
suffix:semicolon
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|devindex_from_devno
id|devindex_from_devno
(paren
r_int
id|devno
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dasd_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dasd_devno
(braket
id|i
)braket
op_eq
id|devno
)paren
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dasd_autodetect
)paren
(brace
r_if
c_cond
(paren
id|dasd_count
OL
id|DASD_MAX_DEVICES
)paren
(brace
id|dasd_devno
(braket
id|dasd_count
)braket
op_assign
id|devno
suffix:semicolon
r_return
id|dasd_count
op_increment
suffix:semicolon
)brace
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* returns 1, if dasd_no is in the specified ranges, otherwise 0 */
r_static
r_inline
r_int
DECL|function|dasd_is_accessible
id|dasd_is_accessible
(paren
r_int
id|devno
)paren
(brace
r_return
(paren
id|devindex_from_devno
(paren
id|devno
)paren
op_ge
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* dasd_insert_range skips ranges, if the start or the end is -1 */
r_static
r_void
DECL|function|dasd_insert_range
id|dasd_insert_range
(paren
r_int
id|start
comma
r_int
id|end
)paren
(brace
r_int
id|curr
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_insert_range&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_count
op_ge
id|DASD_MAX_DEVICES
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot; too many devices specified, ignoring some.&bslash;n&quot;
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_insert_range&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|start
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|end
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot;invalid format of parameter, skipping range&bslash;n&quot;
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_insert_range&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end
OL
id|start
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot; ignoring range from %x to %x - start value &quot;
"&bslash;"
l_string|&quot;must be less than end value.&bslash;n&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_insert_range&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* concurrent execution would be critical, but will not occur here */
r_for
c_loop
(paren
id|curr
op_assign
id|start
suffix:semicolon
id|curr
op_le
id|end
suffix:semicolon
id|curr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dasd_is_accessible
(paren
id|curr
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot; %x is already in list as device %d&bslash;n&quot;
comma
id|curr
comma
id|devindex_from_devno
(paren
id|curr
)paren
)paren
suffix:semicolon
)brace
id|dasd_devno
(braket
id|dasd_count
)braket
op_assign
id|curr
suffix:semicolon
id|dasd_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|dasd_count
op_ge
id|DASD_MAX_DEVICES
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot; too many devices specified, ignoring some.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|PRINT_INFO
(paren
l_string|&quot; added dasd range from %x to %x.&bslash;n&quot;
comma
id|start
comma
id|dasd_devno
(braket
id|dasd_count
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_insert_range&quot;
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|dasd_setup
id|dasd_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|devno
comma
id|devno2
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_setup&quot;
)paren
suffix:semicolon
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|str
op_logical_and
op_star
id|str
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
(paren
op_star
id|str
)paren
)paren
(brace
id|str
op_increment
suffix:semicolon
multiline_comment|/* to avoid looping on two commas */
id|PRINT_ERR
(paren
l_string|&quot; kernel parameter in invalid format.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|devno
op_assign
id|dasd_get_next_int
(paren
op_amp
id|str
)paren
suffix:semicolon
multiline_comment|/* range was skipped? -&gt; scan for comma has been done */
r_if
c_cond
(paren
id|devno
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;,&squot;
)paren
(brace
id|str
op_increment
suffix:semicolon
id|dasd_insert_range
(paren
id|devno
comma
id|devno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|str
op_increment
suffix:semicolon
id|devno2
op_assign
id|dasd_get_next_int
(paren
op_amp
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devno2
op_eq
op_minus
l_int|1
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot; invalid character in &quot;
"&bslash;"
l_string|&quot;kernel parameters.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dasd_insert_range
(paren
id|devno
comma
id|devno2
)paren
suffix:semicolon
)brace
id|dasd_scan_for_next_comma
(paren
op_amp
id|str
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_int|0
)paren
(brace
id|dasd_insert_range
(paren
id|devno
comma
id|devno
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINT_ERR
(paren
l_string|&quot; unexpected character in kernel parameter, &quot;
"&bslash;"
l_string|&quot;skipping range.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_setup&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;dasd=&quot;
comma
id|dasd_setup
)paren
suffix:semicolon
DECL|variable|dasd_info
id|dasd_information_t
op_star
id|dasd_info
(braket
id|DASD_MAX_DEVICES
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|dd_hdstruct
r_static
r_struct
id|hd_struct
id|dd_hdstruct
(braket
id|DASD_MAX_DEVICES
op_lshift
id|PARTN_BITS
)braket
suffix:semicolon
DECL|variable|dasd_blks
r_static
r_int
id|dasd_blks
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dasd_secsize
r_static
r_int
id|dasd_secsize
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dasd_blksize
r_static
r_int
id|dasd_blksize
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dasd_maxsecs
r_static
r_int
id|dasd_maxsecs
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dd_gendisk
r_struct
id|gendisk
id|dd_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;dasd&quot;
comma
multiline_comment|/* Major name */
id|PARTN_BITS
comma
multiline_comment|/* Bits to shift to get real from partn */
l_int|1
op_lshift
id|PARTN_BITS
comma
multiline_comment|/* Number of partitions per real */
id|dd_hdstruct
comma
multiline_comment|/* hd struct */
id|dasd_blks
comma
multiline_comment|/* sizes in blocks */
id|DASD_MAX_DEVICES
comma
multiline_comment|/* number */
l_int|NULL
comma
multiline_comment|/* internal */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
DECL|variable|bh_scheduled
r_static
id|atomic_t
id|bh_scheduled
op_assign
id|ATOMIC_INIT
(paren
l_int|0
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|schedule_bh
id|schedule_bh
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
)paren
)paren
(brace
r_static
r_struct
id|tq_struct
id|dasd_tq
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* Protect against rescheduling, when already running */
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
l_int|0
comma
l_int|1
comma
op_amp
id|bh_scheduled
)paren
)paren
r_return
suffix:semicolon
id|dasd_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|func
suffix:semicolon
id|queue_task
(paren
op_amp
id|dasd_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|sleep_done
id|sleep_done
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_if
c_cond
(paren
id|sem
op_ne
l_int|NULL
)paren
(brace
id|up
(paren
id|sem
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|sleep
id|sleep
(paren
r_int
id|timeout
)paren
(brace
r_struct
id|semaphore
id|sem
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
id|init_MUTEX_LOCKED
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|init_timer
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sem
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|sleep_done
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
id|PRINTK_HEADER
l_string|&quot;Sleeping for timer tics %d&bslash;n&quot;
comma
id|timeout
)paren
suffix:semicolon
id|add_timer
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DASD_ECKD
r_extern
id|dasd_operations_t
id|dasd_eckd_operations
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_MDSK
r_extern
id|dasd_operations_t
id|dasd_mdsk_operations
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_MDSK */
DECL|variable|dasd_disciplines
id|dasd_operations_t
op_star
id|dasd_disciplines
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_DASD_ECKD
op_amp
id|dasd_eckd_operations
comma
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_MDSK
op_amp
id|dasd_mdsk_operations
comma
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_MDSK */
macro_line|#ifdef CONFIG_DASD_CKD
op_amp
id|dasd_ckd_operations
comma
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_CKD */
l_int|NULL
)brace
suffix:semicolon
DECL|variable|dasd_name
r_char
op_star
id|dasd_name
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_DASD_ECKD
l_string|&quot;ECKD&quot;
comma
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_MDSK
l_string|&quot;MDSK&quot;
comma
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_MDSK */
macro_line|#ifdef CONFIG_DASD_CKD
l_string|&quot;CKD&quot;
comma
macro_line|#endif                          /* CONFIG_DASD_CKD */
l_string|&quot;END&quot;
)brace
suffix:semicolon
r_static
r_inline
r_int
DECL|function|do_dasd_ioctl
id|do_dasd_ioctl
(paren
r_struct
id|inode
op_star
id|inp
comma
r_int
r_int
id|no
comma
r_int
r_int
id|data
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|di
suffix:semicolon
id|dasd_information_t
op_star
id|dev
suffix:semicolon
id|di
op_assign
id|DEVICE_NR
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dasd_info
(braket
id|di
)braket
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;No device registered as %d&bslash;n&quot;
comma
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|_IOC_DIR
(paren
id|no
)paren
op_ne
id|_IOC_NONE
)paren
op_logical_and
(paren
id|data
op_eq
l_int|0
)paren
)paren
(brace
id|PRINT_DEBUG
(paren
l_string|&quot;empty data ptr&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev
op_assign
id|dasd_info
(braket
id|di
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;No device registered as %d&bslash;n&quot;
comma
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PRINT_INFO
(paren
l_string|&quot;ioctl 0x%08x %s&squot;0x%x&squot;%d(%d) on dev %d/%d (%d) with data %8lx&bslash;n&quot;
comma
id|no
comma
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_NONE
ques
c_cond
l_string|&quot;0&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_READ
ques
c_cond
l_string|&quot;r&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_WRITE
ques
c_cond
l_string|&quot;w&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
(paren
id|_IOC_READ
op_or
id|_IOC_WRITE
)paren
ques
c_cond
l_string|&quot;rw&quot;
suffix:colon
l_string|&quot;u&quot;
comma
id|_IOC_TYPE
(paren
id|no
)paren
comma
id|_IOC_NR
(paren
id|no
)paren
comma
id|_IOC_SIZE
(paren
id|no
)paren
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|di
comma
id|data
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|no
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
(brace
multiline_comment|/* Return device size */
r_int
r_int
id|blocks
suffix:semicolon
r_if
c_cond
(paren
id|inp-&gt;i_rdev
op_amp
l_int|0x01
)paren
(brace
id|blocks
op_assign
(paren
id|dev-&gt;sizes.blocks
op_minus
l_int|3
)paren
op_lshift
id|dev-&gt;sizes.s2b_shift
suffix:semicolon
)brace
r_else
(brace
id|blocks
op_assign
id|dev-&gt;sizes.kbytes
op_lshift
id|dev-&gt;sizes.s2b_shift
suffix:semicolon
)brace
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_int
op_star
)paren
id|data
comma
op_amp
id|blocks
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BLKFLSBUF
suffix:colon
(brace
id|rc
op_assign
id|fsync_dev
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BLKRAGET
suffix:colon
(brace
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_int
op_star
)paren
id|data
comma
id|read_ahead
op_plus
id|MAJOR_NR
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BLKRASET
suffix:colon
(brace
id|rc
op_assign
id|copy_from_user
(paren
id|read_ahead
op_plus
id|MAJOR_NR
comma
(paren
r_int
op_star
)paren
id|data
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BLKRRPART
suffix:colon
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;BLKRPART not implemented%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;HDIO_GETGEO not implemented%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDRSID
suffix:colon
(brace
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|data
comma
op_amp
(paren
id|dev-&gt;info.sid_data
)paren
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDRWTB
suffix:colon
(brace
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
id|xlt
suffix:semicolon
id|rc
op_assign
id|copy_from_user
(paren
op_amp
id|xlt
comma
(paren
r_void
op_star
)paren
id|data
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|PRINT_INFO
c_func
(paren
l_string|&quot;Xlating %d to&quot;
comma
id|xlt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
op_amp
l_int|1
)paren
id|offset
op_assign
l_int|3
suffix:semicolon
id|xlt
op_add_assign
id|offset
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %d &bslash;n&quot;
comma
id|xlt
)paren
suffix:semicolon
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|data
comma
op_amp
id|xlt
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDFORMAT
suffix:colon
(brace
multiline_comment|/* fdata == NULL is a valid arg to dasd_format ! */
id|format_data_t
op_star
id|fdata
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
id|fdata
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|format_data_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdata
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rc
op_assign
id|copy_from_user
(paren
id|fdata
comma
(paren
r_void
op_star
)paren
id|data
comma
r_sizeof
(paren
id|format_data_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_break
suffix:semicolon
)brace
id|rc
op_assign
id|dasd_format
(paren
id|inp-&gt;i_rdev
comma
id|fdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdata
)paren
(brace
id|kfree
(paren
id|fdata
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_void
DECL|function|dasd_end_request
id|dasd_end_request
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_end_request&quot;
)paren
suffix:semicolon
macro_line|#if DASD_PARANOIA &gt; 2
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;end_request called with zero arg%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_end_io
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|end_that_request_first
(paren
id|req
comma
id|uptodate
comma
id|DEVICE_NAME
)paren
)paren
(brace
macro_line|#ifndef DEVICE_NO_RANDOM
id|add_blkdev_randomness
(paren
id|MAJOR
(paren
id|req-&gt;rq_dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|DEVICE_OFF
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|end_that_request_last
(paren
id|req
)paren
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_end_request&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|dasd_wakeup
id|dasd_wakeup
(paren
r_void
)paren
(brace
id|wake_up
(paren
op_amp
id|dasd_waitq
)paren
suffix:semicolon
)brace
r_int
DECL|function|dasd_unregister_dasd
id|dasd_unregister_dasd
(paren
r_int
id|irq
comma
id|dasd_type_t
id|dt
comma
id|dev_info_t
op_star
id|info
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_unregister_dasd&quot;
)paren
suffix:semicolon
id|INTERNAL_CHECK
(paren
l_string|&quot;dasd_unregister_dasd not implemented%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_unregister_dasd&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Below you find the functions already cleaned up */
r_static
id|dasd_type_t
DECL|function|check_type
id|check_type
(paren
id|dev_info_t
op_star
id|info
)paren
(brace
id|dasd_type_t
id|type
op_assign
id|dasd_none
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;check_type&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_ECKD
r_if
c_cond
(paren
id|MATCH
(paren
id|info
comma
op_eq
l_int|0x3990
comma
op_logical_or
l_int|1
comma
op_eq
l_int|0x3390
comma
op_logical_or
l_int|1
)paren
op_logical_or
id|MATCH
(paren
id|info
comma
op_eq
l_int|0x9343
comma
op_logical_or
l_int|1
comma
op_eq
l_int|0x9345
comma
op_logical_or
l_int|1
)paren
op_logical_or
id|MATCH
(paren
id|info
comma
op_eq
l_int|0x3990
comma
op_logical_or
l_int|1
comma
op_eq
l_int|0x3380
comma
op_logical_or
l_int|1
)paren
)paren
(brace
id|type
op_assign
id|dasd_eckd
suffix:semicolon
)brace
r_else
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_MDSK
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
(brace
id|type
op_assign
id|dasd_mdsk
suffix:semicolon
)brace
r_else
macro_line|#endif &t;&t;/* CONFIG_DASD_MDSK */
(brace
id|type
op_assign
id|dasd_none
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;check_type&quot;
)paren
suffix:semicolon
r_return
id|type
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_read_characteristics
id|dasd_read_characteristics
(paren
id|dasd_information_t
op_star
id|info
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
id|dev_info_t
op_star
id|di
suffix:semicolon
id|dasd_type_t
id|dt
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;read_characteristics&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|di
op_assign
op_amp
(paren
id|info-&gt;info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|di
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dt
op_assign
id|check_type
(paren
id|di
)paren
suffix:semicolon
multiline_comment|/* Some cross-checks, if the cu supports RDC */
r_if
c_cond
(paren
id|MATCH
(paren
id|di
comma
op_eq
l_int|0x2835
comma
op_logical_or
l_int|1
comma
op_logical_or
l_int|1
comma
op_logical_or
l_int|1
)paren
op_logical_or
id|MATCH
(paren
id|di
comma
op_eq
l_int|0x3830
comma
op_logical_or
l_int|1
comma
op_logical_or
l_int|1
comma
op_logical_or
l_int|1
)paren
op_logical_or
id|MATCH
(paren
id|di
comma
op_eq
l_int|0x3830
comma
op_logical_or
l_int|1
comma
op_logical_or
l_int|1
comma
op_logical_or
l_int|1
)paren
op_logical_or
id|MATCH
(paren
id|di
comma
op_eq
l_int|0x3990
comma
op_le
l_int|0x03
comma
op_eq
l_int|0x3380
comma
op_le
l_int|0x0d
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Device %d (%x/%x at %x/%x) supports no RDC&bslash;n&quot;
comma
id|info-&gt;info.irq
comma
id|di-&gt;sid_data.dev_type
comma
id|di-&gt;sid_data.dev_model
comma
id|di-&gt;sid_data.cu_type
comma
id|di-&gt;sid_data.cu_model
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dt
)paren
(brace
macro_line|#ifdef CONFIG_DASD_ECKD
r_case
id|dasd_eckd
suffix:colon
id|ct
op_assign
l_int|64
suffix:semicolon
id|rc
op_assign
id|read_dev_chars
(paren
id|info-&gt;info.irq
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|info-&gt;rdc_data
)paren
comma
id|ct
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_MDSK
r_case
id|dasd_mdsk
suffix:colon
id|ct
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  CONFIG_DASD_MDSK */
r_default
suffix:colon
id|INTERNAL_ERROR
(paren
l_string|&quot;don&squot;t know dasd type %d&bslash;n&quot;
comma
id|dt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;RDC resulted in rc=%d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;read_characteristics&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* How many sectors must be in a request to dequeue it ? */
DECL|macro|QUEUE_BLOCKS
mdefine_line|#define QUEUE_BLOCKS 25
DECL|macro|QUEUE_SECTORS
mdefine_line|#define QUEUE_SECTORS (QUEUE_BLOCKS &lt;&lt; dasd_info[di]-&gt;sizes.s2b_shift)
multiline_comment|/* How often to retry an I/O before raising an error */
DECL|macro|DASD_MAX_RETRIES
mdefine_line|#define DASD_MAX_RETRIES 5
r_static
r_inline
id|cqr_t
op_star
DECL|function|dasd_cqr_from_req
id|dasd_cqr_from_req
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
id|cqr_t
op_star
id|cqr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|di
suffix:semicolon
id|dasd_information_t
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot;No request passed!&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|di
op_assign
id|DEVICE_NR
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|info
op_assign
id|dasd_info
(braket
id|di
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* if applicable relocate block */
r_if
c_cond
(paren
id|MINOR
(paren
id|req-&gt;rq_dev
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|req-&gt;sector
op_add_assign
id|dd_gendisk.part
(braket
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
)brace
multiline_comment|/* Now check for consistency */
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;nr_sectors
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;req: %p dev: %08x sector: %ld nr_sectors: %ld bh: %p&bslash;n&quot;
comma
id|req
comma
id|req-&gt;rq_dev
comma
id|req-&gt;sector
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|req-&gt;sector
op_plus
id|req-&gt;nr_sectors
)paren
op_rshift
l_int|1
)paren
OG
id|info-&gt;sizes.kbytes
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PRINTK_HEADER
l_string|&quot;Requesting I/O past end of device %d&bslash;n&quot;
comma
id|di
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|cqr
op_assign
id|dasd_disciplines
(braket
id|info-&gt;type
)braket
op_member_access_from_pointer
id|get_req_ccw
(paren
id|di
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cqr
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;empty CQR generated&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|cqr-&gt;req
op_assign
id|req
suffix:semicolon
id|cqr-&gt;int4cqr
op_assign
id|cqr
suffix:semicolon
id|cqr-&gt;devindex
op_assign
id|di
suffix:semicolon
macro_line|#ifdef DASD_PROFILE
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cqr-&gt;buildclk
)paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DASD_PROFILE */
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|CQR_STATUS_EMPTY
comma
id|CQR_STATUS_FILLED
comma
op_amp
id|cqr-&gt;status
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;cqr from req stat changed %d&bslash;n&quot;
comma
id|atomic_read
(paren
op_amp
id|cqr-&gt;status
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|cqr
suffix:semicolon
)brace
r_int
DECL|function|dasd_start_IO
id|dasd_start_IO
(paren
id|cqr_t
op_star
id|cqr
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|retries
op_assign
id|DASD_SSCH_RETRIES
suffix:semicolon
r_int
id|di
comma
id|irq
suffix:semicolon
id|dasd_debug
(paren
(paren
r_int
r_int
)paren
id|cqr
)paren
suffix:semicolon
multiline_comment|/* cqr */
r_if
c_cond
(paren
op_logical_neg
id|cqr
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;(start_IO) no cqr passed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cqr-&gt;magic
op_ne
id|DASD_MAGIC
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;(start_IO) magic number mismatch&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|CQR_STATUS_QUEUED
comma
id|CQR_STATUS_IN_IO
comma
op_amp
id|cqr-&gt;status
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;start_IO: status changed %d&bslash;n&quot;
comma
id|atomic_read
(paren
op_amp
id|cqr-&gt;status
)paren
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_ERROR
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|di
op_assign
id|cqr-&gt;devindex
suffix:semicolon
id|irq
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.irq
suffix:semicolon
r_do
(brace
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cqr-&gt;startclk
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|do_IO
(paren
id|irq
comma
id|cqr-&gt;cpaddr
comma
(paren
r_int
)paren
id|cqr
comma
l_int|0x00
comma
id|cqr-&gt;options
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cqr-&gt;options
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
)paren
id|atomic_set_mask
(paren
id|DASD_CHANQ_BUSY
comma
op_amp
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|queue.flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|PRINT_WARN
(paren
l_string|&quot;cqr %p: 0x%04x error, %d retries left&bslash;n&quot;
comma
id|cqr
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.devno
comma
id|retries
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|PRINT_WARN
(paren
l_string|&quot;cqr %p: 0x%04x I/O, %d retries left&bslash;n&quot;
comma
id|cqr
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.devno
comma
id|retries
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
multiline_comment|/* set up timer, try later */
id|PRINT_WARN
(paren
l_string|&quot;cqr %p: 0x%04x busy, %d retries left&bslash;n&quot;
comma
id|cqr
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.devno
comma
id|retries
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINT_WARN
(paren
l_string|&quot;cqr %p: 0x%04x %d, %d retries left&bslash;n&quot;
comma
id|cqr
comma
id|rc
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.devno
comma
id|retries
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|rc
op_logical_and
op_decrement
id|retries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|CQR_STATUS_IN_IO
comma
id|CQR_STATUS_ERROR
comma
op_amp
id|cqr-&gt;status
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;start_IO:(done) status changed %d&bslash;n&quot;
comma
id|atomic_read
(paren
op_amp
id|cqr-&gt;status
)paren
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_ERROR
)paren
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|dasd_end_cqr
id|dasd_end_cqr
(paren
id|cqr_t
op_star
id|cqr
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cqr-&gt;req
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cqr-&gt;endclk
)paren
)paren
suffix:semicolon
macro_line|#ifdef DASD_PROFILE
id|dasd_profile_add
(paren
id|cqr
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DASD_PROFILE */
id|dasd_chanq_deq
(paren
op_amp
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|queue
comma
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|dasd_end_request
(paren
id|req
comma
id|uptodate
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|dasd_dump_sense
id|dasd_dump_sense
(paren
id|devstat_t
op_star
id|stat
)paren
(brace
r_int
id|sl
comma
id|sct
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat-&gt;flag
op_or
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
id|PRINT_INFO
c_func
(paren
l_string|&quot;I/O status w/o sense data&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;-------------------I/O result:-----------&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sl
op_assign
l_int|0
suffix:semicolon
id|sl
OL
l_int|4
suffix:semicolon
id|sl
op_increment
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Sense:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sct
op_assign
l_int|0
suffix:semicolon
id|sct
OL
l_int|8
suffix:semicolon
id|sct
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot; %2d:0x%02X&quot;
comma
l_int|8
op_star
id|sl
op_plus
id|sct
comma
id|stat-&gt;ii.sense.data
(braket
l_int|8
op_star
id|sl
op_plus
id|sct
)braket
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|register_dasd_last
id|register_dasd_last
(paren
r_int
id|di
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|rc
op_assign
id|dasd_disciplines
(braket
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|type
)braket
op_member_access_from_pointer
id|fill_sizes_last
(paren
id|di
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
op_minus
id|EMEDIUMTYPE
suffix:colon
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|DASD_INFO_FLAGS_NOT_FORMATTED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINT_INFO
(paren
l_string|&quot;%ld kB &lt;- &squot;soft&squot;-block: %d, hardsect %d Bytes&bslash;n&quot;
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.kbytes
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.bp_block
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.bp_sector
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|type
)paren
(brace
macro_line|#ifdef CONFIG_DASD_ECKD
r_case
id|dasd_eckd
suffix:colon
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.label_block
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_MDSK
r_case
id|dasd_mdsk
suffix:colon
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.label_block
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
r_default
suffix:colon
id|INTERNAL_CHECK
(paren
l_string|&quot;Unknown dasd type %d&bslash;n&quot;
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|type
)paren
suffix:semicolon
)brace
id|minor
op_assign
id|di
op_lshift
id|PARTN_BITS
suffix:semicolon
id|dasd_blks
(braket
id|minor
)braket
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.kbytes
suffix:semicolon
id|dasd_secsize
(braket
id|minor
)braket
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.bp_sector
suffix:semicolon
id|dasd_blksize
(braket
id|minor
)braket
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.bp_block
suffix:semicolon
id|dasd_maxsecs
(braket
id|minor
)braket
op_assign
l_int|252
op_lshift
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.s2b_shift
suffix:semicolon
id|dasd_secsize
(braket
id|minor
op_plus
l_int|1
)braket
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.bp_sector
suffix:semicolon
id|dasd_blksize
(braket
id|minor
op_plus
l_int|1
)braket
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.bp_block
suffix:semicolon
id|dasd_maxsecs
(braket
id|minor
op_plus
l_int|1
)braket
op_assign
l_int|252
op_lshift
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.s2b_shift
suffix:semicolon
(brace
DECL|macro|DASD_NAME_PREFIX
mdefine_line|#define DASD_NAME_PREFIX &quot;dasd_&quot;
r_char
op_star
id|name
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
l_int|1
op_plus
id|strlen
(paren
id|DASD_NAME_PREFIX
)paren
op_plus
l_int|2
multiline_comment|/* 0x */
op_plus
l_int|4
multiline_comment|/* devno */
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sprintf
(paren
id|name
comma
id|DASD_NAME_PREFIX
l_string|&quot;%04x%c&quot;
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.devno
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|devfs_entry
op_assign
id|devfs_register
(paren
l_int|NULL
multiline_comment|/* dir */
comma
id|name
comma
id|DEVFS_FL_DEFAULT
multiline_comment|/* flags */
comma
id|DASD_MAJOR
comma
id|minor
comma
l_int|0755
multiline_comment|/* mode */
comma
op_amp
id|dasd_device_operations
comma
(paren
r_void
op_star
)paren
id|dasd_info
(braket
id|di
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* end of that stuff */
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|dasd_partn_detect
id|dasd_partn_detect
(paren
r_int
id|di
)paren
(brace
r_int
id|minor
op_assign
id|di
op_lshift
id|PARTN_BITS
suffix:semicolon
id|LOOP_CONTROL
(paren
l_string|&quot;Setting partitions of DASD %d&bslash;n&quot;
comma
id|di
)paren
suffix:semicolon
id|register_disk
(paren
op_amp
id|dd_gendisk
comma
id|MKDEV
c_func
(paren
id|DASD_MAJOR
comma
id|minor
)paren
comma
l_int|1
op_lshift
id|PARTN_BITS
comma
op_amp
id|dasd_device_operations
comma
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sizes.kbytes
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_do_chanq
id|dasd_do_chanq
(paren
r_void
)paren
(brace
id|dasd_chanq_t
op_star
id|qp
op_assign
l_int|NULL
suffix:semicolon
id|cqr_t
op_star
id|cqr
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|tasks
suffix:semicolon
id|atomic_set
(paren
op_amp
id|bh_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4c40000
)paren
suffix:semicolon
multiline_comment|/* DD */
r_while
c_loop
(paren
(paren
id|tasks
op_assign
id|atomic_read
c_func
(paren
op_amp
id|chanq_tasks
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* initialization and wraparound */
r_if
c_cond
(paren
id|qp
op_eq
l_int|NULL
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c46df0
)paren
suffix:semicolon
multiline_comment|/* DD_0 */
id|qp
op_assign
id|cq_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c46ff1
)paren
suffix:semicolon
multiline_comment|/* DD?1 */
id|dasd_debug
(paren
id|tasks
)paren
suffix:semicolon
id|PRINT_ERR
c_func
(paren
l_string|&quot;Mismatch of NULL queue pointer and &quot;
l_string|&quot;still %d chanq_tasks to do!!&bslash;n&quot;
l_string|&quot;Please send output of /proc/dasd/debug &quot;
l_string|&quot;to Linux390@de.ibm.com&bslash;n&quot;
comma
id|tasks
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chanq_tasks
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Get first request */
id|dasd_debug
(paren
(paren
r_int
r_int
)paren
id|qp
)paren
suffix:semicolon
id|cqr
op_assign
(paren
id|cqr_t
op_star
)paren
(paren
id|qp-&gt;head
)paren
suffix:semicolon
multiline_comment|/* empty queue -&gt; dequeue and proceed */
r_if
c_cond
(paren
op_logical_neg
id|cqr
)paren
(brace
id|dasd_chanq_t
op_star
id|nqp
op_assign
id|qp-&gt;next_q
suffix:semicolon
id|cql_deq
(paren
id|qp
)paren
suffix:semicolon
id|qp
op_assign
id|nqp
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* process all requests on that queue */
r_do
(brace
id|cqr_t
op_star
id|next
suffix:semicolon
id|dasd_debug
(paren
(paren
r_int
r_int
)paren
id|cqr
)paren
suffix:semicolon
multiline_comment|/* cqr */
r_if
c_cond
(paren
id|cqr-&gt;magic
op_ne
id|DASD_MAGIC
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c46ff2
)paren
suffix:semicolon
multiline_comment|/* DD?2 */
id|panic
(paren
id|PRINTK_HEADER
l_string|&quot;do_cq:&quot;
l_string|&quot;magic mismatch %p -&gt; %x&bslash;n&quot;
comma
id|cqr
comma
id|cqr
op_member_access_from_pointer
id|magic
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|irq
op_assign
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|info.irq
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|atomic_read
(paren
op_amp
id|cqr-&gt;status
)paren
)paren
(brace
r_case
id|CQR_STATUS_IN_IO
suffix:colon
id|dasd_debug
(paren
l_int|0xc4c4c9d6
)paren
suffix:semicolon
multiline_comment|/* DDIO */
id|cqr
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CQR_STATUS_QUEUED
suffix:colon
id|dasd_debug
(paren
l_int|0xc4c4e2e3
)paren
suffix:semicolon
multiline_comment|/* DDST */
r_if
c_cond
(paren
id|dasd_start_IO
(paren
id|cqr
)paren
op_eq
l_int|0
)paren
(brace
id|atomic_dec
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
id|cqr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CQR_STATUS_ERROR
suffix:colon
id|dasd_debug
(paren
l_int|0xc4c4c5d9
)paren
suffix:semicolon
multiline_comment|/* DDER */
id|dasd_dump_sense
(paren
id|cqr-&gt;dstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|cqr-&gt;retries
OL
l_int|2
)paren
(brace
id|atomic_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_QUEUED
)paren
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4c4e2e3
)paren
suffix:semicolon
multiline_comment|/* DDST */
r_if
c_cond
(paren
id|dasd_start_IO
(paren
id|cqr
)paren
op_eq
l_int|0
)paren
(brace
id|atomic_dec
(paren
op_amp
id|qp
op_member_access_from_pointer
id|dirty_requests
)paren
suffix:semicolon
id|atomic_dec
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
id|cqr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|atomic_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CQR_STATUS_DONE
suffix:colon
id|next
op_assign
id|cqr-&gt;next
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4c49692
)paren
suffix:semicolon
multiline_comment|/* DDok */
id|dasd_end_cqr
(paren
id|cqr
comma
l_int|1
)paren
suffix:semicolon
id|atomic_dec
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
id|cqr
op_assign
id|next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CQR_STATUS_FAILED
suffix:colon
id|next
op_assign
id|cqr-&gt;next
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4c47a7a
)paren
suffix:semicolon
multiline_comment|/* DD:: */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|flags
op_amp
id|DASD_INFO_FLAGS_INITIALIZED
)paren
)paren
(brace
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|DASD_INFO_FLAGS_INITIALIZED
op_or
id|DASD_INFO_FLAGS_NOT_FORMATTED
suffix:semicolon
)brace
id|dasd_end_cqr
(paren
id|cqr
comma
l_int|0
)paren
suffix:semicolon
id|atomic_dec
(paren
op_amp
id|qp
op_member_access_from_pointer
id|dirty_requests
)paren
suffix:semicolon
id|atomic_dec
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
id|cqr
op_assign
id|next
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINT_WARN
(paren
l_string|&quot;unknown cqrstatus&bslash;n&quot;
)paren
suffix:semicolon
id|cqr
op_assign
l_int|NULL
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cqr
)paren
suffix:semicolon
id|qp
op_assign
id|qp-&gt;next_q
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|do_dasd_request
(paren
op_amp
id|blk_dev
(braket
id|DASD_MAJOR
)braket
dot
id|request_queue
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4c46d6d
)paren
suffix:semicolon
multiline_comment|/* DD__ */
)brace
multiline_comment|/* &n;   The request_fn is called from ll_rw_blk for any new request.&n;   We use it to feed the chanqs.&n;   This implementation assumes we are serialized by the io_request_lock.&n; */
DECL|macro|QUEUE_THRESHOLD
mdefine_line|#define QUEUE_THRESHOLD 5
r_void
DECL|function|do_dasd_request
id|do_dasd_request
(paren
id|request_queue_t
op_star
id|queue
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|cqr_t
op_star
id|cqr
suffix:semicolon
id|dasd_chanq_t
op_star
id|q
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|di
comma
id|irq
comma
id|go
suffix:semicolon
r_int
id|broken
comma
id|busy
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4d90000
)paren
suffix:semicolon
multiline_comment|/* DR */
id|dasd_debug
(paren
(paren
r_int
r_int
)paren
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|go
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|go
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|queue-&gt;queue_head
)paren
)paren
(brace
id|req
op_assign
id|blkdev_entry_next_request
c_func
(paren
op_amp
id|queue-&gt;queue_head
)paren
suffix:semicolon
id|req
op_assign
id|blkdev_entry_next_request
c_func
(paren
op_amp
id|queue-&gt;queue_head
)paren
suffix:semicolon
id|di
op_assign
id|DEVICE_NR
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|dasd_debug
(paren
(paren
r_int
r_int
)paren
id|req
)paren
suffix:semicolon
multiline_comment|/* req */
id|dasd_debug
(paren
l_int|0xc4d90000
op_plus
multiline_comment|/* DR## */
(paren
(paren
(paren
(paren
id|di
op_div
l_int|16
)paren
OL
l_int|9
ques
c_cond
(paren
id|di
op_div
l_int|16
)paren
op_plus
l_int|0xf0
suffix:colon
(paren
id|di
op_div
l_int|16
)paren
op_plus
l_int|0xc1
)paren
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
(paren
(paren
id|di
op_mod
l_int|16
)paren
OL
l_int|9
ques
c_cond
(paren
id|di
op_mod
l_int|16
)paren
op_plus
l_int|0xf0
suffix:colon
(paren
id|di
op_mod
l_int|16
)paren
op_plus
l_int|0xc1
)paren
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.irq
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|q
op_assign
op_amp
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|queue
suffix:semicolon
id|busy
op_assign
id|atomic_read
c_func
(paren
op_amp
id|q-&gt;flags
)paren
op_amp
id|DASD_CHANQ_BUSY
suffix:semicolon
id|broken
op_assign
id|atomic_read
c_func
(paren
op_amp
id|q-&gt;flags
)paren
op_amp
id|DASD_REQUEST_Q_BROKEN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|busy
op_logical_or
(paren
op_logical_neg
id|broken
op_logical_and
(paren
id|req-&gt;nr_sectors
op_ge
id|QUEUE_SECTORS
)paren
)paren
)paren
(brace
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/*&n;                          printk ( KERN_INFO &quot;0x%04x %c %d %d&bslash;n&quot;,&n;                          req-&gt;rq_dev,req-&gt;cmd ?&squot;w&squot;:&squot;r&squot;,&n;                          req-&gt;sector,req-&gt;nr_sectors);&n;                        */
id|cqr
op_assign
id|dasd_cqr_from_req
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cqr
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4d96ff1
)paren
suffix:semicolon
multiline_comment|/* DR?1 */
id|dasd_end_request
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|cont
suffix:semicolon
)brace
id|dasd_debug
(paren
(paren
r_int
r_int
)paren
id|cqr
)paren
suffix:semicolon
multiline_comment|/* cqr */
id|dasd_chanq_enq
(paren
id|q
comma
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|atomic_read
(paren
op_amp
id|q-&gt;flags
)paren
op_amp
id|DASD_CHANQ_ACTIVE
)paren
)paren
(brace
id|cql_enq_head
(paren
id|q
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|busy
)paren
(brace
id|atomic_clear_mask
(paren
id|DASD_REQUEST_Q_BROKEN
comma
op_amp
id|q-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|q-&gt;dirty_requests
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dasd_start_IO
(paren
id|cqr
)paren
op_eq
l_int|0
)paren
(brace
)brace
r_else
(brace
id|atomic_inc
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
id|schedule_bh
(paren
id|dasd_do_chanq
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|dasd_debug
(paren
l_int|0xc4d9c2d9
)paren
suffix:semicolon
multiline_comment|/* DRBR */
id|atomic_set_mask
(paren
id|DASD_REQUEST_Q_BROKEN
comma
op_amp
id|q-&gt;flags
)paren
suffix:semicolon
id|go
op_assign
l_int|0
suffix:semicolon
)brace
id|cont
suffix:colon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
id|dasd_debug
(paren
l_int|0xc4d96d6d
)paren
suffix:semicolon
multiline_comment|/* DR__ */
)brace
r_void
DECL|function|dasd_handler
id|dasd_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|ds
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|devstat_t
op_star
id|stat
op_assign
(paren
id|devstat_t
op_star
)paren
id|ds
suffix:semicolon
r_int
id|ip
suffix:semicolon
id|cqr_t
op_star
id|cqr
suffix:semicolon
r_int
id|done_fast_io
op_assign
l_int|0
suffix:semicolon
id|dasd_debug
(paren
l_int|0xc4c80000
)paren
suffix:semicolon
multiline_comment|/* DH */
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
id|PRINT_ERR
(paren
l_string|&quot;handler called without devstat&quot;
)paren
suffix:semicolon
id|ip
op_assign
id|stat-&gt;intparm
suffix:semicolon
id|dasd_debug
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/* intparm */
r_switch
c_cond
(paren
id|ip
)paren
(brace
multiline_comment|/* filter special intparms... */
r_case
l_int|0x00000000
suffix:colon
multiline_comment|/* no intparm: unsolicited interrupt */
id|dasd_debug
(paren
l_int|0xc4c8a489
)paren
suffix:semicolon
multiline_comment|/* DHui */
id|PRINT_INFO
(paren
l_string|&quot;Unsolicited interrupt on device %04X&bslash;n&quot;
comma
id|stat-&gt;devno
)paren
suffix:semicolon
id|dasd_dump_sense
(paren
id|stat
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ip
op_amp
l_int|0x80000001
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c8a489
)paren
suffix:semicolon
multiline_comment|/* DHui */
id|PRINT_INFO
(paren
l_string|&quot;Spurious interrupt %08x on device %04X&bslash;n&quot;
comma
id|ip
comma
id|stat-&gt;devno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cqr
op_assign
(paren
id|cqr_t
op_star
)paren
id|ip
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;magic
op_ne
id|DASD_MAGIC
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c86ff1
)paren
suffix:semicolon
multiline_comment|/* DH?1 */
id|PRINT_ERR
(paren
l_string|&quot;handler:magic mismatch on %p %08x&bslash;n&quot;
comma
id|cqr
comma
id|cqr-&gt;magic
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cqr-&gt;stopclk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat-&gt;cstat
op_eq
l_int|0x00
op_logical_and
id|stat-&gt;dstat
op_eq
(paren
id|DEV_STAT_CHN_END
op_or
id|DEV_STAT_DEV_END
)paren
)paren
op_logical_or
id|dasd_erp_examine
(paren
id|cqr
)paren
op_eq
id|dasd_era_none
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c89692
)paren
suffix:semicolon
multiline_comment|/* DHok */
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|CQR_STATUS_IN_IO
comma
id|CQR_STATUS_DONE
comma
op_amp
id|cqr-&gt;status
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;handler: cqrstat changed%d&bslash;n&quot;
comma
id|atomic_read
(paren
op_amp
id|cqr-&gt;status
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_DONE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|flags
op_amp
id|DASD_INFO_FLAGS_INITIALIZED
)paren
)paren
(brace
r_int
id|rc
op_assign
id|register_dasd_last
(paren
id|cqr-&gt;devindex
)paren
suffix:semicolon
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|DASD_INFO_FLAGS_INITIALIZED
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|flags
op_and_assign
op_complement
id|DASD_INFO_FLAGS_NOT_FORMATTED
suffix:semicolon
)brace
r_else
(brace
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|DASD_INFO_FLAGS_NOT_FORMATTED
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cqr-&gt;next
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c8e2e3
)paren
suffix:semicolon
multiline_comment|/* DHST */
r_if
c_cond
(paren
id|dasd_start_IO
(paren
id|cqr-&gt;next
)paren
op_eq
l_int|0
)paren
(brace
id|done_fast_io
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|atomic_inc
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* only visited in case of error ! */
id|dasd_debug
(paren
l_int|0xc4c8c5d9
)paren
suffix:semicolon
multiline_comment|/* DHER */
r_if
c_cond
(paren
op_logical_neg
id|cqr-&gt;dstat
)paren
id|cqr-&gt;dstat
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|devstat_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;dstat
)paren
(brace
id|memcpy
(paren
id|cqr-&gt;dstat
comma
id|stat
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_ERR
(paren
l_string|&quot;no memory for dstat&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* errorprocessing */
id|atomic_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_ERROR
)paren
suffix:semicolon
id|atomic_inc
(paren
op_amp
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|queue.dirty_requests
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done_fast_io
op_eq
l_int|0
)paren
id|atomic_clear_mask
(paren
id|DASD_CHANQ_BUSY
comma
op_amp
id|dasd_info
(braket
id|cqr-&gt;devindex
)braket
op_member_access_from_pointer
id|queue.flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;flags
op_amp
id|DASD_DO_IO_SLEEP
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c8a6a4
)paren
suffix:semicolon
multiline_comment|/* DHwu */
id|dasd_wakeup
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|cqr-&gt;options
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
)paren
(brace
id|dasd_debug
(paren
l_int|0xc4c8a293
)paren
suffix:semicolon
multiline_comment|/* DHsl */
id|atomic_inc
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
id|schedule_bh
(paren
id|dasd_do_chanq
)paren
suffix:semicolon
)brace
r_else
(brace
id|dasd_debug
(paren
l_int|0x64686f6f
)paren
suffix:semicolon
multiline_comment|/* DH_g */
id|dasd_debug
(paren
id|cqr-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* DH_g */
)brace
id|dasd_debug
(paren
l_int|0xc4c86d6d
)paren
suffix:semicolon
multiline_comment|/* DHwu */
)brace
r_static
r_int
DECL|function|dasd_format
id|dasd_format
(paren
r_int
id|dev
comma
id|format_data_t
op_star
id|fdata
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|devindex
op_assign
id|DEVICE_NR
(paren
id|dev
)paren
suffix:semicolon
id|dasd_chanq_t
op_star
id|q
suffix:semicolon
id|cqr_t
op_star
id|cqr
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;Format called with devno %x&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
(paren
id|dev
)paren
op_amp
(paren
l_int|0xff
op_rshift
(paren
l_int|8
op_minus
id|PARTN_BITS
)paren
)paren
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Can&squot;t format partition! minor %x %x&bslash;n&quot;
comma
id|MINOR
(paren
id|dev
)paren
comma
l_int|0xff
op_rshift
(paren
l_int|8
op_minus
id|PARTN_BITS
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|down
(paren
op_amp
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|open_count
op_eq
l_int|1
)paren
(brace
id|rc
op_assign
id|dasd_disciplines
(braket
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|type
)braket
op_member_access_from_pointer
id|dasd_format
(paren
id|devindex
comma
id|fdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Formatting failed rc=%d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|PRINT_WARN
(paren
l_string|&quot;device is open! %d&bslash;n&quot;
comma
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|open_count
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
macro_line|#if DASD_PARANOIA &gt; 1
r_if
c_cond
(paren
op_logical_neg
id|dasd_disciplines
(braket
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|type
)braket
op_member_access_from_pointer
id|fill_sizes_first
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;No fill_sizes for dt=%d&bslash;n&quot;
comma
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|type
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
(brace
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|flags
op_and_assign
op_complement
id|DASD_INFO_FLAGS_INITIALIZED
suffix:semicolon
id|irq
op_assign
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|info.irq
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;Trying to access DASD %x, irq %x, index %d&bslash;n&quot;
comma
id|get_devno_by_irq
c_func
(paren
id|irq
)paren
comma
id|irq
comma
id|devindex
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|q
op_assign
op_amp
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|queue
suffix:semicolon
id|cqr
op_assign
id|dasd_disciplines
(braket
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|type
)braket
op_member_access_from_pointer
id|fill_sizes_first
(paren
id|devindex
)paren
suffix:semicolon
id|dasd_chanq_enq
(paren
id|q
comma
id|cqr
)paren
suffix:semicolon
id|schedule_bh
c_func
(paren
id|dasd_do_chanq
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
id|up
(paren
op_amp
id|dasd_info
(braket
id|devindex
)braket
op_member_access_from_pointer
id|sem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|register_dasd
id|register_dasd
(paren
r_int
id|irq
comma
id|dasd_type_t
id|dt
comma
id|dev_info_t
op_star
id|info
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|di
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dasd_chanq_t
op_star
id|q
suffix:semicolon
id|cqr_t
op_star
id|cqr
suffix:semicolon
r_static
id|spinlock_t
id|register_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|spin_lock
(paren
op_amp
id|register_lock
)paren
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;register_dasd&quot;
)paren
suffix:semicolon
id|di
op_assign
id|devindex_from_devno
(paren
id|info-&gt;devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|di
OL
l_int|0
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;Can&squot;t get index for devno %d&bslash;n&quot;
comma
id|info-&gt;devno
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dasd_info
(braket
id|di
)braket
)paren
(brace
multiline_comment|/* devindex is not free */
id|INTERNAL_CHECK
(paren
l_string|&quot;reusing allocated deviceindex %d&bslash;n&quot;
comma
id|di
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dasd_info
(braket
id|di
)braket
op_assign
(paren
id|dasd_information_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|dasd_information_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_info
(braket
id|di
)braket
op_eq
l_int|NULL
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;No memory for dasd_info_t on irq %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|dasd_info
(braket
id|di
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_information_t
)paren
)paren
suffix:semicolon
id|memcpy
(paren
op_amp
(paren
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info
)paren
comma
id|info
comma
r_sizeof
(paren
id|dev_info_t
)paren
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|queue.f_lock
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|queue.q_lock
)paren
suffix:semicolon
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|type
op_assign
id|dt
suffix:semicolon
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|sem
)paren
suffix:semicolon
id|rc
op_assign
id|dasd_read_characteristics
(paren
id|dasd_info
(braket
id|di
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;RDC returned error %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|unalloc
suffix:semicolon
)brace
macro_line|#if DASD_PARANOIA &gt; 1
r_if
c_cond
(paren
id|dasd_disciplines
(braket
id|dt
)braket
op_member_access_from_pointer
id|ck_characteristics
)paren
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|rc
op_assign
id|dasd_disciplines
(braket
id|dt
)braket
op_member_access_from_pointer
id|ck_characteristics
(paren
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|rdc_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;Discipline returned non-zero when&quot;
l_string|&quot;checking device characteristics%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|unalloc
suffix:semicolon
)brace
id|rc
op_assign
id|request_irq
(paren
id|irq
comma
id|dasd_handler
comma
l_int|0
comma
l_string|&quot;dasd&quot;
comma
op_amp
(paren
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|dev_status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
macro_line|#if DASD_PARANOIA &gt; 0
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Cannot register irq %d, rc=%d&bslash;n&quot;
comma
id|irq
comma
id|rc
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|unalloc
suffix:semicolon
)brace
macro_line|#if DASD_PARANOIA &gt; 1
r_if
c_cond
(paren
op_logical_neg
id|dasd_disciplines
(braket
id|dt
)braket
op_member_access_from_pointer
id|fill_sizes_first
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;No fill_sizes for dt=%d&bslash;n&quot;
comma
id|dt
)paren
suffix:semicolon
r_goto
id|unregister
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|irq
op_assign
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|info.irq
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;Trying to access DASD %x, irq %x, index %d&bslash;n&quot;
comma
id|get_devno_by_irq
c_func
(paren
id|irq
)paren
comma
id|irq
comma
id|di
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|q
op_assign
op_amp
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|queue
suffix:semicolon
id|cqr
op_assign
id|dasd_disciplines
(braket
id|dt
)braket
op_member_access_from_pointer
id|fill_sizes_first
(paren
id|di
)paren
suffix:semicolon
id|dasd_chanq_enq
(paren
id|q
comma
id|cqr
)paren
suffix:semicolon
id|cql_enq_head
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_start_IO
c_func
(paren
id|cqr
)paren
op_ne
l_int|0
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|chanq_tasks
)paren
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
id|unregister
suffix:colon
id|free_irq
(paren
id|irq
comma
op_amp
(paren
id|dasd_info
(braket
id|di
)braket
op_member_access_from_pointer
id|dev_status
)paren
)paren
suffix:semicolon
id|unalloc
suffix:colon
id|kfree
(paren
id|dasd_info
(braket
id|di
)braket
)paren
suffix:semicolon
m_exit
suffix:colon
id|spin_unlock
(paren
op_amp
id|register_lock
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;register_dasd&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|probe_for_dasd
id|probe_for_dasd
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
suffix:semicolon
id|dev_info_t
id|info
suffix:semicolon
id|dasd_type_t
id|dt
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;probe_for_dasd&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|get_dev_info_by_irq
(paren
id|irq
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENODEV
)paren
(brace
multiline_comment|/* end of device list */
r_return
id|rc
suffix:semicolon
)brace
macro_line|#if DASD_PARANOIA &gt; 2
r_if
c_cond
(paren
id|rc
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;unknown rc %d of get_dev_info&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
r_if
c_cond
(paren
(paren
id|info.status
op_amp
id|DEVSTAT_NOT_OPER
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dt
op_assign
id|check_type
(paren
op_amp
id|info
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dt
)paren
(brace
macro_line|#ifdef CONFIG_DASD_ECKD
r_case
id|dasd_eckd
suffix:colon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
id|FUNCTION_CONTROL
(paren
l_string|&quot;Probing devno %d...&bslash;n&quot;
comma
id|info.devno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dasd_is_accessible
(paren
id|info.devno
)paren
)paren
(brace
id|FUNCTION_CONTROL
(paren
l_string|&quot;out of range...skip%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dasd_disciplines
(braket
id|dt
)braket
op_member_access_from_pointer
id|ck_devinfo
)paren
(brace
id|rc
op_assign
id|dasd_disciplines
(braket
id|dt
)braket
op_member_access_from_pointer
id|ck_devinfo
(paren
op_amp
id|info
)paren
suffix:semicolon
)brace
macro_line|#if DASD_PARANOIA &gt; 1
r_else
(brace
id|INTERNAL_ERROR
(paren
l_string|&quot;no ck_devinfo function%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENODEV
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
macro_line|#if DASD_PARANOIA &gt; 2
r_if
c_cond
(paren
id|rc
)paren
(brace
id|INTERNAL_CHECK
(paren
l_string|&quot;unknown error rc=%d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|rc
op_assign
id|register_dasd
(paren
id|irq
comma
id|dt
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_INFO
(paren
l_string|&quot;devno %x not enabled as minor %d  due to errors&bslash;n&quot;
comma
id|info.devno
comma
id|devindex_from_devno
(paren
id|info.devno
)paren
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_INFO
(paren
l_string|&quot;devno %x added as minor %d (%s)&bslash;n&quot;
comma
id|info.devno
comma
id|devindex_from_devno
(paren
id|info.devno
)paren
op_lshift
id|PARTN_BITS
comma
id|dasd_name
(braket
id|dt
)braket
)paren
suffix:semicolon
)brace
r_case
id|dasd_none
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINT_DEBUG
(paren
l_string|&quot;unknown device type&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;probe_for_dasd&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|register_major
id|register_major
(paren
r_int
id|major
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;register_major&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|devfs_register_blkdev
(paren
id|major
comma
id|DASD_NAME
comma
op_amp
id|dasd_device_operations
)paren
suffix:semicolon
macro_line|#if DASD_PARANOIA &gt; 1
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;registering major -&gt; rc=%d aborting... &bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|q
op_assign
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|major
)paren
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|q
comma
id|do_dasd_request
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|major
)paren
comma
l_int|0
)paren
suffix:semicolon
id|FUNCTION_CONTROL
(paren
l_string|&quot;successfully registered major: %d&bslash;n&quot;
comma
id|major
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;register_major&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* &n;   Below you find functions which are called from outside. Some of them may be&n;   static, because they are called by their function pointers only. Thus static&n;   modifier is to make sure, that they are only called via the kernel&squot;s methods&n; */
r_static
r_int
DECL|function|dasd_ioctl
id|dasd_ioctl
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|no
comma
r_int
r_int
id|data
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_ioctl&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
op_logical_neg
(paren
id|inp-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rc
op_assign
id|do_dasd_ioctl
(paren
id|inp
comma
id|no
comma
id|data
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_ioctl&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_open
id|dasd_open
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_information_t
op_star
id|dev
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_open&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
op_logical_neg
(paren
id|inp-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev
op_assign
id|dasd_info
(braket
id|DEVICE_NR
(paren
id|inp-&gt;i_rdev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|PRINT_DEBUG
(paren
l_string|&quot;No device registered as %d (%d)&bslash;n&quot;
comma
id|inp-&gt;i_rdev
comma
id|DEVICE_NR
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|down
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
macro_line|#if DASD_PARANOIA &gt; 2
r_if
c_cond
(paren
id|dev-&gt;open_count
OL
l_int|0
)paren
(brace
id|INTERNAL_ERROR
(paren
l_string|&quot;open count cannot be less than 0: %d&quot;
comma
id|dev-&gt;open_count
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|dev-&gt;open_count
op_increment
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_open&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_release
id|dasd_release
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_information_t
op_star
id|dev
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_release&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
op_logical_neg
(paren
id|inp-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev
op_assign
id|dasd_info
(braket
id|DEVICE_NR
(paren
id|inp-&gt;i_rdev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;No device registered as %d&bslash;n&quot;
comma
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
macro_line|#if DASD_PARANOIA &gt; 2
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;open_count
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;device %d has not been opened before:&bslash;n&quot;
comma
id|inp-&gt;i_rdev
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|dev-&gt;open_count
op_decrement
suffix:semicolon
macro_line|#if DASD_PARANOIA &gt; 2
r_if
c_cond
(paren
id|dev-&gt;open_count
OL
l_int|0
)paren
(brace
id|INTERNAL_ERROR
(paren
l_string|&quot;open count cannot be less than 0: %d&quot;
comma
id|dev-&gt;open_count
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DASD_PARANOIA */
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_release&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_struct
DECL|variable|dasd_device_operations
id|block_device_operations
id|dasd_device_operations
op_assign
(brace
id|ioctl
suffix:colon
id|dasd_ioctl
comma
id|open
suffix:colon
id|dasd_open
comma
id|release
suffix:colon
id|dasd_release
comma
)brace
suffix:semicolon
r_int
DECL|function|dasd_init
id|dasd_init
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;dasd_init&quot;
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;initializing...&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|chanq_tasks
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|bh_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dasd_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dasd_waitq
)paren
suffix:semicolon
multiline_comment|/* First register to the major number */
id|rc
op_assign
id|register_major
(paren
id|MAJOR_NR
)paren
suffix:semicolon
macro_line|#if DASD_PARANOIA &gt; 1
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;registering major_nr returned rc=%d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif&t;/* DASD_PARANOIA */ 
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|dasd_blks
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|dasd_secsize
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|dasd_blksize
suffix:semicolon
id|max_sectors
(braket
id|MAJOR_NR
)braket
op_assign
id|dasd_maxsecs
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|dasd_proc_init
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PROC_FS */
multiline_comment|/* Now scan the device list for DASDs */
id|FUNCTION_CONTROL
(paren
l_string|&quot;entering detection loop%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|irc
suffix:semicolon
multiline_comment|/* Internal return code */
id|LOOP_CONTROL
(paren
l_string|&quot;Probing irq %d...&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|irc
op_assign
id|probe_for_dasd
(paren
id|i
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|irc
)paren
(brace
r_case
l_int|0
suffix:colon
id|LOOP_CONTROL
(paren
l_string|&quot;Added DASD%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|LOOP_CONTROL
(paren
l_string|&quot;No DASD%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EMEDIUMTYPE
suffix:colon
id|PRINT_WARN
(paren
l_string|&quot;DASD not formatted%s&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_CHECK
(paren
l_string|&quot;probe_for_dasd: unknown rc=%d&quot;
comma
id|irc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|FUNCTION_CONTROL
(paren
l_string|&quot;detection loop completed %s partn check...&bslash;n&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* Finally do the genhd stuff */
id|dd_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|dd_gendisk
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dasd_info
(braket
id|i
)braket
)paren
id|dasd_partn_detect
(paren
id|i
)paren
suffix:semicolon
id|FUNCTION_EXIT
(paren
l_string|&quot;dasd_init&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;init_module&quot;
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;trying to load module&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|dasd_init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|PRINT_INFO
(paren
l_string|&quot;module loaded successfully&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_WARN
(paren
l_string|&quot;warning: Module load returned rc=%d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;init_module&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_ENTRY
(paren
l_string|&quot;cleanup_module&quot;
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;trying to unload module &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: replace by proper unload functionality */
id|INTERNAL_ERROR
(paren
l_string|&quot;Modules not yet implemented %s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|PRINT_INFO
(paren
l_string|&quot;module unloaded successfully&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_WARN
(paren
l_string|&quot;module unloaded with errors&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|FUNCTION_EXIT
(paren
l_string|&quot;cleanup_module&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4 &n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
