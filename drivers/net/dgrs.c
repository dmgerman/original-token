multiline_comment|/*&n; *&t;Digi RightSwitch SE-X loadable device driver for Linux&n; *&n; *&t;The RightSwitch is a 4 (EISA) or 6 (PCI) port etherswitch and&n; *&t;a NIC on an internal board.&n; *&n; *&t;Author: Rick Richardson, rick@remotepoint.com&n; *&t;Derived from the SVR4.2 (UnixWare) driver for the same card.&n; *&n; *&t;Copyright 1995-1996 Digi International Inc.&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU General Public License, incorporated herein by reference.&n; *&n; *&t;For information on purchasing a RightSwitch SE-4 or SE-6&n; *&t;board, please contact Digi&squot;s sales department at 1-612-912-3444&n; *&t;or 1-800-DIGIBRD.  Outside the U.S., please check our Web page&n; *&t;at http://www.dgii.com for sales offices worldwide.&n; *&n; *&t;OPERATION:&n; *&t;When compiled as a loadable module, this driver can operate&n; *&t;the board as either a 4/6 port switch with a 5th or 7th port&n; *&t;that is a conventional NIC interface as far as the host is&n; *&t;concerned, OR as 4/6 independent NICs.  To select multi-NIC&n; *&t;mode, add &quot;nicmode=1&quot; on the insmod load line for the driver.&n; *&n; *&t;This driver uses the &quot;dev&quot; common ethernet device structure&n; *&t;and a private &quot;priv&quot; (dev-&gt;priv) structure that contains&n; *&t;mostly DGRS-specific information and statistics.  To keep&n; *&t;the code for both the switch mode and the multi-NIC mode&n; *&t;as similar as possible, I have introduced the concept of&n; *&t;&quot;dev0&quot;/&quot;priv0&quot; and &quot;devN&quot;/&quot;privN&quot;  pointer pairs in subroutines&n; *&t;where needed.  The first pair of pointers points to the&n; *&t;&quot;dev&quot; and &quot;priv&quot; structures of the zeroth (0th) device&n; *&t;interface associated with a board.  The second pair of&n; *&t;pointers points to the current (Nth) device interface&n; *&t;for the board: the one for which we are processing data.&n; *&n; *&t;In switch mode, the pairs of pointers are always the same,&n; *&t;that is, dev0 == devN and priv0 == privN.  This is just&n; *&t;like previous releases of this driver which did not support&n; *&t;NIC mode.&n; *&n; *&t;In multi-NIC mode, the pairs of pointers may be different.&n; *&t;We use the devN and privN pointers to reference just the&n; *&t;name, port number, and statistics for the current interface.&n; *&t;We use the dev0 and priv0 pointers to access the variables&n; *&t;that control access to the board, such as board address&n; *&t;and simulated 82596 variables.  This is because there is&n; *&t;only one &quot;fake&quot; 82596 that serves as the interface to&n; *&t;the board.  We do not want to try to keep the variables&n; *&t;associated with this 82596 in sync across all devices.&n; *&n; *&t;This scheme works well.  As you will see, except for&n; *&t;initialization, there is very little difference between&n; *&t;the two modes as far as this driver is concerned.  On the&n; *&t;receive side in NIC mode, the interrupt *always* comes in on&n; *&t;the 0th interface (dev0/priv0).  We then figure out which&n; *&t;real 82596 port it came in on from looking at the &quot;chan&quot;&n; *&t;member that the board firmware adds at the end of each&n; *&t;RBD (a.k.a. TBD). We get the channel number like this:&n; *&t;&t;int chan = ((I596_RBD *) S2H(cbp-&gt;xmit.tbdp))-&gt;chan;&n; *&n; *&t;On the transmit side in multi-NIC mode, we specify the&n; *&t;output 82596 port by setting the new &quot;dstchan&quot; structure&n; *&t;member that is at the end of the RFD, like this:&n; *&t;&t;priv0-&gt;rfdp-&gt;dstchan = privN-&gt;chan;&n; *&n; *&t;TODO:&n; *&t;- Multi-NIC mode is not yet supported when the driver is linked&n; *&t;  into the kernel.&n; *&t;- Better handling of multicast addresses.&n; *&n; */
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;$Id: dgrs.c,v 1.13 2000/06/06 04:07:00 rick Exp $&quot;
suffix:semicolon
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n; *&t;API changed at linux version 2.1.0&n; */
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20100
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|IOREMAP
mdefine_line|#define IOREMAP(ADDR, LEN)&t;&t;ioremap(ADDR, LEN)
DECL|macro|IOUNMAP
mdefine_line|#define IOUNMAP(ADDR)&t;&t;&t;iounmap(ADDR)
DECL|macro|COPY_FROM_USER
mdefine_line|#define COPY_FROM_USER(DST,SRC,LEN)&t;copy_from_user(DST,SRC,LEN)
DECL|macro|COPY_TO_USER
mdefine_line|#define COPY_TO_USER(DST,SRC,LEN)&t;copy_to_user(DST,SRC,LEN)
macro_line|#else
macro_line|#include &lt;linux/bios32.h&gt;
DECL|macro|IOREMAP
mdefine_line|#define IOREMAP(ADDR, LEN)&t;&t;vremap(ADDR, LEN)
DECL|macro|IOUNMAP
mdefine_line|#define IOUNMAP(ADDR)&t;&t;&t;vfree(ADDR)
DECL|macro|COPY_FROM_USER
mdefine_line|#define COPY_FROM_USER(DST,SRC,LEN)&t;memcpy_fromfs(DST,SRC,LEN)
DECL|macro|COPY_TO_USER
mdefine_line|#define COPY_TO_USER(DST,SRC,LEN)&t;memcpy_tofs(DST,SRC,LEN)
macro_line|#endif
multiline_comment|/*&n; *&t;DGRS include files&n; */
DECL|typedef|uchar
r_typedef
r_int
r_char
id|uchar
suffix:semicolon
DECL|typedef|bool
r_typedef
r_int
r_int
r_bool
suffix:semicolon
DECL|macro|vol
mdefine_line|#define vol volatile
macro_line|#include &quot;dgrs.h&quot;
macro_line|#include &quot;dgrs_es4h.h&quot;
macro_line|#include &quot;dgrs_plx9060.h&quot;
macro_line|#include &quot;dgrs_i82596.h&quot;
macro_line|#include &quot;dgrs_ether.h&quot;
macro_line|#include &quot;dgrs_asstruct.h&quot;
macro_line|#include &quot;dgrs_bcomm.h&quot;
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20400
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|dgrs_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|SE6_PCI_VENDOR_ID
comma
id|SE6_PCI_DEVICE_ID
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|dgrs_pci_tbl
)paren
suffix:semicolon
macro_line|#endif /* LINUX_VERSION_CODE &gt;= 0x20400 */
multiline_comment|/*&n; *&t;Firmware.  Compiled separately for local compilation,&n; *&t;but #included for Linux distribution.&n; */
macro_line|#ifndef NOFW
macro_line|#include &quot;dgrs_firmware.c&quot;
macro_line|#else
r_extern
r_int
id|dgrs_firmnum
suffix:semicolon
r_extern
r_char
id|dgrs_firmver
(braket
)braket
suffix:semicolon
r_extern
r_char
id|dgrs_firmdate
(braket
)braket
suffix:semicolon
r_extern
id|uchar
id|dgrs_code
(braket
)braket
suffix:semicolon
r_extern
r_int
id|dgrs_ncode
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Linux out*() is backwards from all other operating systems&n; */
DECL|macro|OUTB
mdefine_line|#define&t;OUTB(ADDR, VAL)&t;outb(VAL, ADDR)
DECL|macro|OUTW
mdefine_line|#define&t;OUTW(ADDR, VAL)&t;outw(VAL, ADDR)
DECL|macro|OUTL
mdefine_line|#define&t;OUTL(ADDR, VAL)&t;outl(VAL, ADDR)
multiline_comment|/*&n; *&t;Macros to convert switch to host and host to switch addresses&n; *&t;(assumes a local variable priv points to board dependent struct)&n; */
DECL|macro|S2H
mdefine_line|#define&t;S2H(A)&t;( ((unsigned long)(A)&amp;0x00ffffff) + priv0-&gt;vmem )
DECL|macro|S2HN
mdefine_line|#define&t;S2HN(A)&t;( ((unsigned long)(A)&amp;0x00ffffff) + privN-&gt;vmem )
DECL|macro|H2S
mdefine_line|#define&t;H2S(A)&t;( ((char *) (A) - priv0-&gt;vmem) + 0xA3000000 )
multiline_comment|/*&n; *&t;Convert a switch address to a &quot;safe&quot; address for use with the&n; *&t;PLX 9060 DMA registers and the associated HW kludge that allows&n; *&t;for host access of the DMA registers.&n; */
DECL|macro|S2DMA
mdefine_line|#define&t;S2DMA(A)&t;( (unsigned long)(A) &amp; 0x00ffffff)
multiline_comment|/*&n; *&t;&quot;Space.c&quot; variables, now settable from module interface&n; *&t;Use the name below, minus the &quot;dgrs_&quot; prefix.  See init_module().&n; */
DECL|variable|dgrs_debug
r_int
id|dgrs_debug
op_assign
l_int|1
suffix:semicolon
DECL|variable|dgrs_dma
r_int
id|dgrs_dma
op_assign
l_int|1
suffix:semicolon
DECL|variable|dgrs_spantree
r_int
id|dgrs_spantree
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|dgrs_hashexpire
r_int
id|dgrs_hashexpire
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|dgrs_ipaddr
id|uchar
id|dgrs_ipaddr
(braket
l_int|4
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
DECL|variable|dgrs_iptrap
id|uchar
id|dgrs_iptrap
(braket
l_int|4
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
DECL|variable|dgrs_ipxnet
id|__u32
id|dgrs_ipxnet
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|dgrs_nicmode
r_int
id|dgrs_nicmode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Chain of device structures&n; */
DECL|variable|dgrs_root_dev
r_static
r_struct
id|net_device
op_star
id|dgrs_root_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Private per-board data structure (dev-&gt;priv)&n; */
r_typedef
r_struct
(brace
multiline_comment|/*&n;&t; *&t;Stuff for generic ethercard I/F&n;&t; */
DECL|member|next_dev
r_struct
id|net_device
op_star
id|next_dev
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/*&n;&t; *&t;DGRS specific data&n;&t; */
DECL|member|vmem
r_char
op_star
id|vmem
suffix:semicolon
DECL|member|bcomm
r_struct
id|bios_comm
op_star
id|bcomm
suffix:semicolon
multiline_comment|/* Firmware BIOS comm structure */
DECL|member|port
id|PORT
op_star
id|port
suffix:semicolon
multiline_comment|/* Ptr to PORT[0] struct in VM */
DECL|member|scbp
id|I596_SCB
op_star
id|scbp
suffix:semicolon
multiline_comment|/* Ptr to SCB struct in VM */
DECL|member|rfdp
id|I596_RFD
op_star
id|rfdp
suffix:semicolon
multiline_comment|/* Current RFD list */
DECL|member|rbdp
id|I596_RBD
op_star
id|rbdp
suffix:semicolon
multiline_comment|/* Current RBD list */
DECL|member|intrcnt
r_volatile
r_int
id|intrcnt
suffix:semicolon
multiline_comment|/* Count of interrupts */
multiline_comment|/*&n;         *      SE-4 (EISA) board variables&n;         */
DECL|member|is_reg
id|uchar
id|is_reg
suffix:semicolon
multiline_comment|/* EISA: Value for ES4H_IS reg */
multiline_comment|/*&n;         *      SE-6 (PCI) board variables&n;         *&n;         *      The PLX &quot;expansion rom&quot; space is used for DMA register&n;         *      access from the host on the SE-6.  These are the physical&n;         *      and virtual addresses of that space.&n;         */
DECL|member|plxreg
id|ulong
id|plxreg
suffix:semicolon
multiline_comment|/* Phys address of PLX chip */
DECL|member|vplxreg
r_char
op_star
id|vplxreg
suffix:semicolon
multiline_comment|/* Virtual address of PLX chip */
DECL|member|plxdma
id|ulong
id|plxdma
suffix:semicolon
multiline_comment|/* Phys addr of PLX &quot;expansion rom&quot; */
DECL|member|vplxdma
id|ulong
r_volatile
op_star
id|vplxdma
suffix:semicolon
multiline_comment|/* Virtual addr of &quot;expansion rom&quot; */
DECL|member|use_dma
r_int
id|use_dma
suffix:semicolon
multiline_comment|/* Flag: use DMA */
DECL|member|dmadesc_s
id|DMACHAIN
op_star
id|dmadesc_s
suffix:semicolon
multiline_comment|/* area for DMA chains (SW addr.) */
DECL|member|dmadesc_h
id|DMACHAIN
op_star
id|dmadesc_h
suffix:semicolon
multiline_comment|/* area for DMA chains (Host Virtual) */
multiline_comment|/*&n;&t; *&t;Multi-NIC mode variables&n;&t; *&n;&t; *&t;All entries of the devtbl[] array are valid for the 0th&n;&t; *&t;device (i.e. eth0, but not eth1...eth5).  devtbl[0] is&n;&t; *&t;valid for all devices (i.e. eth0, eth1, ..., eth5).&n;&t; */
DECL|member|nports
r_int
id|nports
suffix:semicolon
multiline_comment|/* Number of physical ports (4 or 6) */
DECL|member|chan
r_int
id|chan
suffix:semicolon
multiline_comment|/* Channel # (1-6) for this device */
DECL|member|devtbl
r_struct
id|net_device
op_star
id|devtbl
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Ptrs to N device structs */
DECL|typedef|DGRS_PRIV
)brace
id|DGRS_PRIV
suffix:semicolon
multiline_comment|/*&n; *&t;reset or un-reset the IDT processor&n; */
r_static
r_void
DECL|function|proc_reset
id|proc_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev0
comma
r_int
id|reset
)paren
(brace
id|DGRS_PRIV
op_star
id|priv0
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev0-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|priv0-&gt;plxreg
)paren
(brace
id|ulong
id|val
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_MISC_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|val
op_or_assign
id|SE6_RESET
suffix:semicolon
r_else
id|val
op_and_assign
op_complement
id|SE6_RESET
suffix:semicolon
id|OUTL
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_MISC_CSR
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_PC
comma
id|reset
ques
c_cond
id|ES4H_PC_RESET
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;See if the board supports bus master DMA&n; */
r_static
r_int
DECL|function|check_board_dma
id|check_board_dma
c_func
(paren
r_struct
id|net_device
op_star
id|dev0
)paren
(brace
id|DGRS_PRIV
op_star
id|priv0
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev0-&gt;priv
suffix:semicolon
id|ulong
id|x
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If Space.c says not to use DMA, or if its not a PLX based&n;&t; *&t;PCI board, or if the expansion ROM space is not PCI&n;&t; *&t;configured, then return false.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dgrs_dma
op_logical_or
op_logical_neg
id|priv0-&gt;plxreg
op_logical_or
op_logical_neg
id|priv0-&gt;plxdma
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the local address remap register of the &quot;expansion rom&quot;&n;&t; *&t;area to 0x80000000 so that we can use it to access the DMA&n;&t; *&t;registers from the host side.&n;&t; */
id|OUTL
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_ROM_BASE_ADDR
comma
l_int|0x80000000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the PCI region descriptor to:&n;&t; *      Space 0:&n;&t; *              disable read-prefetch&n;&t; *              enable READY&n;&t; *              enable BURST&n;&t; *              0 internal wait states&n;&t; *      Expansion ROM: (used for host DMA register access)&n;&t; *              disable read-prefetch&n;&t; *              enable READY&n;&t; *              disable BURST&n;&t; *              0 internal wait states&n;&t; */
id|OUTL
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_BUS_REGION
comma
l_int|0x49430343
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now map the DMA registers into our virtual space&n;&t; */
id|priv0-&gt;vplxdma
op_assign
(paren
id|ulong
op_star
)paren
id|IOREMAP
(paren
id|priv0-&gt;plxdma
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv0-&gt;vplxdma
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: can&squot;t *remap() the DMA regs&bslash;n&quot;
comma
id|dev0-&gt;name
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now test to see if we can access the DMA registers&n;&t; *&t;If we write -1 and get back 1FFF, then we accessed the&n;&t; *&t;DMA register.  Otherwise, we probably have an old board&n;&t; *&t;and wrote into regular RAM.&n;&t; */
id|priv0-&gt;vplxdma
(braket
id|PLX_DMA0_MODE
op_div
l_int|4
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|x
op_assign
id|priv0-&gt;vplxdma
(braket
id|PLX_DMA0_MODE
op_div
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ne
l_int|0x00001FFF
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Initiate DMA using PLX part on PCI board.  Spin the&n; *&t;processor until completed.  All addresses are physical!&n; *&n; *&t;If pciaddr is NULL, then its a chaining DMA, and lcladdr is&n; *&t;the address of the first DMA descriptor in the chain.&n; *&n; *&t;If pciaddr is not NULL, then its a single DMA.&n; *&n; *&t;In either case, &quot;lcladdr&quot; must have been fixed up to make&n; *&t;sure the MSB isn&squot;t set using the S2DMA macro before passing&n; *&t;the address to this routine.&n; */
r_static
r_int
DECL|function|do_plx_dma
id|do_plx_dma
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|ulong
id|pciaddr
comma
id|ulong
id|lcladdr
comma
r_int
id|len
comma
r_int
id|to_host
)paren
(brace
r_int
id|i
suffix:semicolon
id|ulong
id|csr
op_assign
l_int|0
suffix:semicolon
id|DGRS_PRIV
op_star
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pciaddr
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Do a single, non-chain DMA&n;&t;&t; */
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_PCI_ADDR
op_div
l_int|4
)braket
op_assign
id|pciaddr
suffix:semicolon
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_LCL_ADDR
op_div
l_int|4
)braket
op_assign
id|lcladdr
suffix:semicolon
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_SIZE
op_div
l_int|4
)braket
op_assign
id|len
suffix:semicolon
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_DESCRIPTOR
op_div
l_int|4
)braket
op_assign
id|to_host
ques
c_cond
id|PLX_DMA_DESC_TO_HOST
suffix:colon
id|PLX_DMA_DESC_TO_BOARD
suffix:semicolon
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_MODE
op_div
l_int|4
)braket
op_assign
id|PLX_DMA_MODE_WIDTH32
op_or
id|PLX_DMA_MODE_WAITSTATES
c_func
(paren
l_int|0
)paren
op_or
id|PLX_DMA_MODE_READY
op_or
id|PLX_DMA_MODE_NOBTERM
op_or
id|PLX_DMA_MODE_BURST
op_or
id|PLX_DMA_MODE_NOCHAIN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;Do a chaining DMA&n;&t;&t; */
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_MODE
op_div
l_int|4
)braket
op_assign
id|PLX_DMA_MODE_WIDTH32
op_or
id|PLX_DMA_MODE_WAITSTATES
c_func
(paren
l_int|0
)paren
op_or
id|PLX_DMA_MODE_READY
op_or
id|PLX_DMA_MODE_NOBTERM
op_or
id|PLX_DMA_MODE_BURST
op_or
id|PLX_DMA_MODE_CHAIN
suffix:semicolon
id|priv-&gt;vplxdma
(braket
id|PLX_DMA0_DESCRIPTOR
op_div
l_int|4
)braket
op_assign
id|lcladdr
suffix:semicolon
)brace
id|priv-&gt;vplxdma
(braket
id|PLX_DMA_CSR
op_div
l_int|4
)braket
op_assign
id|PLX_DMA_CSR_0_ENABLE
op_or
id|PLX_DMA_CSR_0_START
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait for DMA to complete&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000000
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Spin the host CPU for 1 usec, so we don&squot;t thrash&n;&t;&t; *&t;the PCI bus while the PLX 9060 is doing DMA.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|csr
op_assign
(paren
r_volatile
r_int
r_int
)paren
id|priv-&gt;vplxdma
(braket
id|PLX_DMA_CSR
op_div
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|PLX_DMA_CSR_0_DONE
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|csr
op_amp
id|PLX_DMA_CSR_0_DONE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA done never occurred. DMA disabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;use_dma
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dgrs_rcv_frame()&n; *&n; *&t;Process a received frame.  This is called from the interrupt&n; *&t;routine, and works for both switch mode and multi-NIC mode.&n; *&n; *&t;Note that when in multi-NIC mode, we want to always access the&n; *&t;hardware using the dev and priv structures of the first port,&n; *&t;so that we are using only one set of variables to maintain&n; *&t;the board interface status, but we want to use the Nth port&n; *&t;dev and priv structures to maintain statistics and to pass&n; *&t;the packet up.&n; *&n; *&t;Only the first device structure is attached to the interrupt.&n; *&t;We use the special &quot;chan&quot; variable at the end of the first RBD&n; *&t;to select the Nth device in multi-NIC mode.&n; *&n; *&t;We currently do chained DMA on a per-packet basis when the&n; *&t;packet is &quot;long&quot;, and we spin the CPU a short time polling&n; *&t;for DMA completion.  This avoids a second interrupt overhead,&n; *&t;and gives the best performance for light traffic to the host.&n; *&n; *&t;However, a better scheme that could be implemented would be&n; *&t;to see how many packets are outstanding for the host, and if&n; *&t;the number is &quot;large&quot;, create a long chain to DMA several&n; *&t;packets into the host in one go.  In this case, we would set&n; *&t;up some state variables to let the host CPU continue doing&n; *&t;other things until a DMA completion interrupt comes along.&n; */
r_void
DECL|function|dgrs_rcv_frame
id|dgrs_rcv_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev0
comma
id|DGRS_PRIV
op_star
id|priv0
comma
id|I596_CB
op_star
id|cbp
)paren
(brace
r_int
id|len
suffix:semicolon
id|I596_TBD
op_star
id|tbdp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|uchar
op_star
id|putp
suffix:semicolon
id|uchar
op_star
id|p
suffix:semicolon
r_struct
id|net_device
op_star
id|devN
suffix:semicolon
id|DGRS_PRIV
op_star
id|privN
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Determine Nth priv and dev structure pointers&n;&t; */
r_if
c_cond
(paren
id|dgrs_nicmode
)paren
(brace
multiline_comment|/* Multi-NIC mode */
r_int
id|chan
op_assign
(paren
(paren
id|I596_RBD
op_star
)paren
id|S2H
c_func
(paren
id|cbp-&gt;xmit.tbdp
)paren
)paren
op_member_access_from_pointer
id|chan
suffix:semicolon
id|devN
op_assign
id|priv0-&gt;devtbl
(braket
id|chan
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If devN is null, we got an interrupt before the I/F&n;&t;&t; * has been initialized.  Pitch the packet.&n;&t;&t; */
r_if
c_cond
(paren
id|devN
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|privN
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|devN-&gt;priv
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Switch mode */
id|devN
op_assign
id|dev0
suffix:semicolon
id|privN
op_assign
id|priv0
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: rcv len=%ld&bslash;n&quot;
comma
id|devN-&gt;name
comma
id|cbp-&gt;xmit.count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate a message block big enough to hold the whole frame&n;&t; */
id|len
op_assign
id|cbp-&gt;xmit.count
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
l_int|5
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: dev_alloc_skb failed for rcv buffer&bslash;n&quot;
comma
id|devN-&gt;name
)paren
suffix:semicolon
op_increment
id|privN-&gt;stats.rx_dropped
suffix:semicolon
multiline_comment|/* discarding the frame */
r_goto
id|out
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|devN
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align IP header */
id|again
suffix:colon
id|putp
op_assign
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;There are three modes here for doing the packet copy.&n;&t; *&t;If we have DMA, and the packet is &quot;long&quot;, we use the&n;&t; *&t;chaining mode of DMA.  If it&squot;s shorter, we use single&n;&t; *&t;DMA&squot;s.  Otherwise, we use memcpy().&n;&t; */
r_if
c_cond
(paren
id|priv0-&gt;use_dma
op_logical_and
id|priv0-&gt;dmadesc_h
op_logical_and
id|len
OG
l_int|64
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;If we can use DMA and its a long frame, copy it using&n;&t;&t; *&t;DMA chaining.&n;&t;&t; */
id|DMACHAIN
op_star
id|ddp_h
suffix:semicolon
multiline_comment|/* Host virtual DMA desc. pointer */
id|DMACHAIN
op_star
id|ddp_s
suffix:semicolon
multiline_comment|/* Switch physical DMA desc. pointer */
id|uchar
op_star
id|phys_p
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Get the physical address of the STREAMS buffer.&n;&t;&t; *&t;NOTE: allocb() guarantees that the whole buffer&n;&t;&t; *&t;is in a single page if the length &lt; 4096.&n;&t;&t; */
id|phys_p
op_assign
(paren
id|uchar
op_star
)paren
id|virt_to_phys
c_func
(paren
id|putp
)paren
suffix:semicolon
id|ddp_h
op_assign
id|priv0-&gt;dmadesc_h
suffix:semicolon
id|ddp_s
op_assign
id|priv0-&gt;dmadesc_s
suffix:semicolon
id|tbdp
op_assign
(paren
id|I596_TBD
op_star
)paren
id|S2H
c_func
(paren
id|cbp-&gt;xmit.tbdp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
id|amt
suffix:semicolon
id|count
op_assign
id|tbdp-&gt;count
suffix:semicolon
id|amt
op_assign
id|count
op_amp
l_int|0x3fff
suffix:semicolon
r_if
c_cond
(paren
id|amt
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* For safety */
r_if
c_cond
(paren
(paren
id|p
op_minus
id|putp
)paren
op_ge
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cbp = %x&bslash;n&quot;
comma
id|devN-&gt;name
comma
id|H2S
c_func
(paren
id|cbp
)paren
)paren
suffix:semicolon
id|proc_reset
c_func
(paren
id|dev0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Freeze IDT */
r_break
suffix:semicolon
multiline_comment|/* For Safety */
)brace
id|ddp_h-&gt;pciaddr
op_assign
(paren
id|ulong
)paren
id|phys_p
suffix:semicolon
id|ddp_h-&gt;lcladdr
op_assign
id|S2DMA
c_func
(paren
id|tbdp-&gt;buf
)paren
suffix:semicolon
id|ddp_h-&gt;len
op_assign
id|amt
suffix:semicolon
id|phys_p
op_add_assign
id|amt
suffix:semicolon
id|p
op_add_assign
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|count
op_amp
id|I596_TBD_EOF
)paren
(brace
id|ddp_h-&gt;next
op_assign
id|PLX_DMA_DESC_TO_HOST
op_or
id|PLX_DMA_DESC_EOC
suffix:semicolon
op_increment
id|ddp_h
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
op_increment
id|ddp_s
suffix:semicolon
id|ddp_h-&gt;next
op_assign
id|PLX_DMA_DESC_TO_HOST
op_or
(paren
id|ulong
)paren
id|ddp_s
suffix:semicolon
id|tbdp
op_assign
(paren
id|I596_TBD
op_star
)paren
id|S2H
c_func
(paren
id|tbdp-&gt;next
)paren
suffix:semicolon
op_increment
id|ddp_h
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ddp_h
op_minus
id|priv0-&gt;dmadesc_h
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|do_plx_dma
c_func
(paren
id|dev0
comma
l_int|0
comma
(paren
id|ulong
)paren
id|priv0-&gt;dmadesc_s
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Chained DMA failure&bslash;n&quot;
comma
id|devN-&gt;name
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|priv0-&gt;use_dma
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;If we can use DMA and its a shorter frame, copy it&n;&t;&t; *&t;using single DMA transfers.&n;&t;&t; */
id|uchar
op_star
id|phys_p
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Get the physical address of the STREAMS buffer.&n;&t;&t; *&t;NOTE: allocb() guarantees that the whole buffer&n;&t;&t; *&t;is in a single page if the length &lt; 4096.&n;&t;&t; */
id|phys_p
op_assign
(paren
id|uchar
op_star
)paren
id|virt_to_phys
c_func
(paren
id|putp
)paren
suffix:semicolon
id|tbdp
op_assign
(paren
id|I596_TBD
op_star
)paren
id|S2H
c_func
(paren
id|cbp-&gt;xmit.tbdp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
id|amt
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|count
op_assign
id|tbdp-&gt;count
suffix:semicolon
id|amt
op_assign
id|count
op_amp
l_int|0x3fff
suffix:semicolon
r_if
c_cond
(paren
id|amt
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* For safety */
r_if
c_cond
(paren
(paren
id|p
op_minus
id|putp
)paren
op_ge
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cbp = %x&bslash;n&quot;
comma
id|devN-&gt;name
comma
id|H2S
c_func
(paren
id|cbp
)paren
)paren
suffix:semicolon
id|proc_reset
c_func
(paren
id|dev0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Freeze IDT */
r_break
suffix:semicolon
multiline_comment|/* For Safety */
)brace
id|rc
op_assign
id|do_plx_dma
c_func
(paren
id|dev0
comma
(paren
id|ulong
)paren
id|phys_p
comma
id|S2DMA
c_func
(paren
id|tbdp-&gt;buf
)paren
comma
id|amt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|memcpy
c_func
(paren
id|p
comma
id|S2H
c_func
(paren
id|tbdp-&gt;buf
)paren
comma
id|amt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Single DMA failed&bslash;n&quot;
comma
id|devN-&gt;name
)paren
suffix:semicolon
)brace
id|phys_p
op_add_assign
id|amt
suffix:semicolon
id|p
op_add_assign
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|count
op_amp
id|I596_TBD_EOF
)paren
r_break
suffix:semicolon
id|tbdp
op_assign
(paren
id|I596_TBD
op_star
)paren
id|S2H
c_func
(paren
id|tbdp-&gt;next
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;Otherwise, copy it piece by piece using memcpy()&n;&t;&t; */
id|tbdp
op_assign
(paren
id|I596_TBD
op_star
)paren
id|S2H
c_func
(paren
id|cbp-&gt;xmit.tbdp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
id|amt
suffix:semicolon
id|count
op_assign
id|tbdp-&gt;count
suffix:semicolon
id|amt
op_assign
id|count
op_amp
l_int|0x3fff
suffix:semicolon
r_if
c_cond
(paren
id|amt
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* For safety */
r_if
c_cond
(paren
(paren
id|p
op_minus
id|putp
)paren
op_ge
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cbp = %x&bslash;n&quot;
comma
id|devN-&gt;name
comma
id|H2S
c_func
(paren
id|cbp
)paren
)paren
suffix:semicolon
id|proc_reset
c_func
(paren
id|dev0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Freeze IDT */
r_break
suffix:semicolon
multiline_comment|/* For Safety */
)brace
id|memcpy
c_func
(paren
id|p
comma
id|S2H
c_func
(paren
id|tbdp-&gt;buf
)paren
comma
id|amt
)paren
suffix:semicolon
id|p
op_add_assign
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|count
op_amp
id|I596_TBD_EOF
)paren
r_break
suffix:semicolon
id|tbdp
op_assign
(paren
id|I596_TBD
op_star
)paren
id|S2H
c_func
(paren
id|tbdp-&gt;next
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Pass the frame to upper half&n;&t; */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|devN
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
op_increment
id|privN-&gt;stats.rx_packets
suffix:semicolon
id|out
suffix:colon
id|cbp-&gt;xmit.status
op_assign
id|I596_CB_STATUS_C
op_or
id|I596_CB_STATUS_OK
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Start transmission of a frame&n; *&n; *&t;The interface to the board is simple: we pretend that we are&n; *&t;a fifth 82596 ethernet controller &squot;receiving&squot; data, and copy the&n; *&t;data into the same structures that a real 82596 would.  This way,&n; *&t;the board firmware handles the host &squot;port&squot; the same as any other.&n; *&n; *&t;NOTE: we do not use Bus master DMA for this routine.  Turns out&n; *&t;that it is not needed.  Slave writes over the PCI bus are about&n; *&t;as fast as DMA, due to the fact that the PLX part can do burst&n; *&t;writes.  The same is not true for data being read from the board.&n; *&n; *&t;For multi-NIC mode, we tell the firmware the desired 82596&n; *&t;output port by setting the special &quot;dstchan&quot; member at the&n; *&t;end of the traditional 82596 RFD structure.&n; */
DECL|function|dgrs_start_xmit
r_static
r_int
id|dgrs_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|devN
)paren
(brace
id|DGRS_PRIV
op_star
id|privN
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|devN-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|dev0
suffix:semicolon
id|DGRS_PRIV
op_star
id|priv0
suffix:semicolon
id|I596_RBD
op_star
id|rbdp
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|amt
suffix:semicolon
DECL|macro|mymin
macro_line|#&t;define&t;&t;mymin(A,B)&t;( (A) &lt; (B) ? (A) : (B) )
multiline_comment|/*&n;&t; *&t;Determine 0th priv and dev structure pointers&n;&t; */
r_if
c_cond
(paren
id|dgrs_nicmode
)paren
(brace
id|dev0
op_assign
id|privN-&gt;devtbl
(braket
l_int|0
)braket
suffix:semicolon
id|priv0
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev0-&gt;priv
suffix:semicolon
)brace
r_else
(brace
id|dev0
op_assign
id|devN
suffix:semicolon
id|priv0
op_assign
id|privN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dgrs_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: xmit len=%d&bslash;n&quot;
comma
id|devN-&gt;name
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
id|devN-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|devN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv0-&gt;rfdp-&gt;cmd
op_amp
id|I596_RFD_EL
)paren
(brace
multiline_comment|/* Out of RFD&squot;s */
r_if
c_cond
(paren
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: NO RFD&squot;s&bslash;n&quot;
comma
id|devN-&gt;name
)paren
suffix:semicolon
r_goto
id|no_resources
suffix:semicolon
)brace
id|rbdp
op_assign
id|priv0-&gt;rbdp
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|priv0-&gt;rfdp-&gt;rbdp
op_assign
(paren
id|I596_RBD
op_star
)paren
id|H2S
c_func
(paren
id|rbdp
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|rbdp-&gt;size
op_amp
id|I596_RBD_EL
)paren
(brace
multiline_comment|/* Out of RBD&squot;s */
r_if
c_cond
(paren
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: NO RBD&squot;s&bslash;n&quot;
comma
id|devN-&gt;name
)paren
suffix:semicolon
r_goto
id|no_resources
suffix:semicolon
)brace
id|amt
op_assign
id|mymin
c_func
(paren
id|len
comma
id|rbdp-&gt;size
op_minus
id|count
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|S2H
c_func
(paren
id|rbdp-&gt;buf
)paren
op_plus
id|count
comma
id|skb-&gt;data
op_plus
id|i
comma
id|amt
)paren
suffix:semicolon
id|i
op_add_assign
id|amt
suffix:semicolon
id|count
op_add_assign
id|amt
suffix:semicolon
id|len
op_sub_assign
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|60
)paren
id|rbdp-&gt;count
op_assign
l_int|60
op_or
id|I596_RBD_EOF
suffix:semicolon
r_else
id|rbdp-&gt;count
op_assign
id|count
op_or
id|I596_RBD_EOF
suffix:semicolon
id|rbdp
op_assign
(paren
id|I596_RBD
op_star
)paren
id|S2H
c_func
(paren
id|rbdp-&gt;next
)paren
suffix:semicolon
r_goto
id|frame_done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OL
l_int|32
)paren
(brace
multiline_comment|/* More data to come, but we used less than 32&n;&t;&t;&t; * bytes of this RBD.  Keep filling this RBD.&n;&t;&t;&t; */
(brace
)brace
multiline_comment|/* Yes, we do nothing here */
)brace
r_else
(brace
id|rbdp-&gt;count
op_assign
id|count
suffix:semicolon
id|rbdp
op_assign
(paren
id|I596_RBD
op_star
)paren
id|S2H
c_func
(paren
id|rbdp-&gt;next
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|frame_done
suffix:colon
id|priv0-&gt;rbdp
op_assign
id|rbdp
suffix:semicolon
r_if
c_cond
(paren
id|dgrs_nicmode
)paren
id|priv0-&gt;rfdp-&gt;dstchan
op_assign
id|privN-&gt;chan
suffix:semicolon
id|priv0-&gt;rfdp-&gt;status
op_assign
id|I596_RFD_C
op_or
id|I596_RFD_OK
suffix:semicolon
id|priv0-&gt;rfdp
op_assign
(paren
id|I596_RFD
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;rfdp-&gt;next
)paren
suffix:semicolon
op_increment
id|privN-&gt;stats.tx_packets
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|no_resources
suffix:colon
id|priv0-&gt;scbp-&gt;status
op_or_assign
id|I596_SCB_RNR
suffix:semicolon
multiline_comment|/* simulate I82596 */
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Open the interface&n; */
r_static
r_int
DECL|function|dgrs_open
id|dgrs_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Close the interface&n; */
DECL|function|dgrs_close
r_static
r_int
id|dgrs_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get statistics&n; */
DECL|function|dgrs_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|dgrs_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DGRS_PRIV
op_star
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
(paren
op_amp
id|priv-&gt;stats
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set multicast list and/or promiscuous mode&n; */
DECL|function|dgrs_set_multicast_list
r_static
r_void
id|dgrs_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DGRS_PRIV
op_star
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|priv-&gt;port-&gt;is_promisc
op_assign
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Unique ioctl&squot;s&n; */
DECL|function|dgrs_ioctl
r_static
r_int
id|dgrs_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|devN
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
id|DGRS_PRIV
op_star
id|privN
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|devN-&gt;priv
suffix:semicolon
id|DGRS_IOCTL
id|ioc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|DGRSIOCTL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|COPY_FROM_USER
c_func
(paren
op_amp
id|ioc
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|DGRS_IOCTL
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ioc.cmd
)paren
(brace
r_case
id|DGRS_GETMEM
suffix:colon
r_if
c_cond
(paren
id|ioc.len
op_ne
r_sizeof
(paren
id|ulong
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|COPY_TO_USER
c_func
(paren
id|ioc.data
comma
op_amp
id|devN-&gt;mem_start
comma
id|ioc.len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|DGRS_SETFILTER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|ioc.port
OG
id|privN-&gt;bcomm-&gt;bc_nports
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ioc.filter
op_ge
id|NFILTERS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ioc.len
OG
id|privN-&gt;bcomm-&gt;bc_filter_area_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Wait for old command to finish */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
r_volatile
r_int
)paren
id|privN-&gt;bcomm-&gt;bc_filter_cmd
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
l_int|1000
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|privN-&gt;bcomm-&gt;bc_filter_port
op_assign
id|ioc.port
suffix:semicolon
id|privN-&gt;bcomm-&gt;bc_filter_num
op_assign
id|ioc.filter
suffix:semicolon
id|privN-&gt;bcomm-&gt;bc_filter_len
op_assign
id|ioc.len
suffix:semicolon
r_if
c_cond
(paren
id|ioc.len
)paren
(brace
r_if
c_cond
(paren
id|COPY_FROM_USER
c_func
(paren
id|S2HN
c_func
(paren
id|privN-&gt;bcomm-&gt;bc_filter_area
)paren
comma
id|ioc.data
comma
id|ioc.len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|privN-&gt;bcomm-&gt;bc_filter_cmd
op_assign
id|BC_FILTER_SET
suffix:semicolon
)brace
r_else
id|privN-&gt;bcomm-&gt;bc_filter_cmd
op_assign
id|BC_FILTER_CLR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Process interrupts&n; *&n; *&t;dev, priv will always refer to the 0th device in Multi-NIC mode.&n; */
DECL|function|dgrs_intr
r_static
r_void
id|dgrs_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev0
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
id|DGRS_PRIV
op_star
id|priv0
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev0-&gt;priv
suffix:semicolon
id|I596_CB
op_star
id|cbp
suffix:semicolon
r_int
id|cmd
suffix:semicolon
r_int
id|i
suffix:semicolon
op_increment
id|priv0-&gt;intrcnt
suffix:semicolon
r_if
c_cond
(paren
l_int|1
)paren
op_increment
id|priv0-&gt;bcomm-&gt;bc_cnt
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
l_int|0
)paren
(brace
r_static
r_int
id|cnt
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cnt
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: interrupt: irq %d&bslash;n&quot;
comma
id|dev0-&gt;name
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Get 596 command&n;&t; */
id|cmd
op_assign
id|priv0-&gt;scbp-&gt;cmd
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See if RU has been restarted&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|I596_SCB_RUC
)paren
op_eq
id|I596_SCB_RUC_START
)paren
(brace
r_if
c_cond
(paren
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: RUC start&bslash;n&quot;
comma
id|dev0-&gt;name
)paren
suffix:semicolon
id|priv0-&gt;rfdp
op_assign
(paren
id|I596_RFD
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;scbp-&gt;rfdp
)paren
suffix:semicolon
id|priv0-&gt;rbdp
op_assign
(paren
id|I596_RBD
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;rfdp-&gt;rbdp
)paren
suffix:semicolon
id|priv0-&gt;scbp-&gt;status
op_and_assign
op_complement
(paren
id|I596_SCB_RNR
op_or
id|I596_SCB_RUS
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Tell upper half (halves)&n;&t;&t; */
r_if
c_cond
(paren
id|dgrs_nicmode
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv0-&gt;nports
suffix:semicolon
op_increment
id|i
)paren
id|netif_wake_queue
(paren
id|priv0-&gt;devtbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
id|netif_wake_queue
(paren
id|dev0
)paren
suffix:semicolon
multiline_comment|/* if (bd-&gt;flags &amp; TX_QUEUED)&n;&t;&t;&t;DL_sched(bd, bdd); */
)brace
multiline_comment|/*&n;&t; *&t;See if any CU commands to process&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|I596_SCB_CUC
)paren
op_ne
id|I596_SCB_CUC_START
)paren
(brace
id|priv0-&gt;scbp-&gt;cmd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ignore all other commands */
r_goto
id|ack_intr
suffix:semicolon
)brace
id|priv0-&gt;scbp-&gt;status
op_and_assign
op_complement
(paren
id|I596_SCB_CNA
op_or
id|I596_SCB_CUS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Process a command&n;&t; */
id|cbp
op_assign
(paren
id|I596_CB
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;scbp-&gt;cbp
)paren
suffix:semicolon
id|priv0-&gt;scbp-&gt;cmd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Safe to clear the command */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|cbp-&gt;nop.cmd
op_amp
id|I596_CB_CMD
)paren
(brace
r_case
id|I596_CB_CMD_XMIT
suffix:colon
id|dgrs_rcv_frame
c_func
(paren
id|dev0
comma
id|priv0
comma
id|cbp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cbp-&gt;nop.status
op_assign
id|I596_CB_STATUS_C
op_or
id|I596_CB_STATUS_OK
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cbp-&gt;nop.cmd
op_amp
id|I596_CB_CMD_EL
)paren
r_break
suffix:semicolon
id|cbp
op_assign
(paren
id|I596_CB
op_star
)paren
id|S2H
c_func
(paren
id|cbp-&gt;nop.next
)paren
suffix:semicolon
)brace
id|priv0-&gt;scbp-&gt;status
op_or_assign
id|I596_SCB_CNA
suffix:semicolon
multiline_comment|/*&n;&t; * Ack the interrupt&n;&t; */
id|ack_intr
suffix:colon
r_if
c_cond
(paren
id|priv0-&gt;plxreg
)paren
id|OUTL
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_LCL2PCI_DOORBELL
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Download the board firmware&n; */
r_static
r_int
id|__init
DECL|function|dgrs_download
id|dgrs_download
c_func
(paren
r_struct
id|net_device
op_star
id|dev0
)paren
(brace
id|DGRS_PRIV
op_star
id|priv0
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev0-&gt;priv
suffix:semicolon
r_int
id|is
suffix:semicolon
r_int
id|i
suffix:semicolon
r_static
r_int
id|iv2is
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|ES4H_IS_INT3
comma
l_int|0
comma
id|ES4H_IS_INT5
comma
l_int|0
comma
id|ES4H_IS_INT7
comma
l_int|0
comma
l_int|0
comma
id|ES4H_IS_INT10
comma
id|ES4H_IS_INT11
comma
id|ES4H_IS_INT12
comma
l_int|0
comma
l_int|0
comma
id|ES4H_IS_INT15
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * Map in the dual port memory&n;&t; */
id|priv0-&gt;vmem
op_assign
id|IOREMAP
c_func
(paren
id|dev0-&gt;mem_start
comma
l_int|2048
op_star
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv0-&gt;vmem
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cannot map in board memory&bslash;n&quot;
comma
id|dev0-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Hold the processor and configure the board addresses&n;&t; */
r_if
c_cond
(paren
id|priv0-&gt;plxreg
)paren
(brace
multiline_comment|/* PCI bus */
id|proc_reset
c_func
(paren
id|dev0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* EISA bus */
id|is
op_assign
id|iv2is
(braket
id|dev0-&gt;irq
op_amp
l_int|0x0f
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Illegal IRQ %d&bslash;n&quot;
comma
id|dev0-&gt;name
comma
id|dev0-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_AS_31_24
comma
(paren
id|uchar
)paren
(paren
id|dev0-&gt;mem_start
op_rshift
l_int|24
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_AS_23_16
comma
(paren
id|uchar
)paren
(paren
id|dev0-&gt;mem_start
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|priv0-&gt;is_reg
op_assign
id|ES4H_IS_LINEAR
op_or
id|is
op_or
(paren
(paren
id|uchar
)paren
(paren
id|dev0-&gt;mem_start
op_rshift
l_int|8
)paren
op_amp
id|ES4H_IS_AS15
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_IS
comma
id|priv0-&gt;is_reg
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_EC
comma
id|ES4H_EC_ENABLE
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_PC
comma
id|ES4H_PC_RESET
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|ES4H_MW
comma
id|ES4H_MW_ENABLE
op_or
l_int|0x00
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;See if we can do DMA on the SE-6&n;&t; */
id|priv0-&gt;use_dma
op_assign
id|check_board_dma
c_func
(paren
id|dev0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv0-&gt;use_dma
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Bus Master DMA is enabled.&bslash;n&quot;
comma
id|dev0-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Load and verify the code at the desired address&n;&t; */
id|memcpy
c_func
(paren
id|priv0-&gt;vmem
comma
id|dgrs_code
comma
id|dgrs_ncode
)paren
suffix:semicolon
multiline_comment|/* Load code */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|priv0-&gt;vmem
comma
id|dgrs_code
comma
id|dgrs_ncode
)paren
)paren
(brace
id|IOUNMAP
c_func
(paren
id|priv0-&gt;vmem
)paren
suffix:semicolon
id|priv0-&gt;vmem
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: download compare failed&bslash;n&quot;
comma
id|dev0-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Configurables&n;&t; */
id|priv0-&gt;bcomm
op_assign
(paren
r_struct
id|bios_comm
op_star
)paren
(paren
id|priv0-&gt;vmem
op_plus
l_int|0x0100
)paren
suffix:semicolon
id|priv0-&gt;bcomm-&gt;bc_nowait
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Tell board to make printf not wait */
id|priv0-&gt;bcomm-&gt;bc_squelch
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flag from Space.c */
id|priv0-&gt;bcomm-&gt;bc_150ohm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flag from Space.c */
id|priv0-&gt;bcomm-&gt;bc_spew
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Debug flag from Space.c */
id|priv0-&gt;bcomm-&gt;bc_maxrfd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Debug flag from Space.c */
id|priv0-&gt;bcomm-&gt;bc_maxrbd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Debug flag from Space.c */
multiline_comment|/*&n;&t; * Tell board we are operating in switch mode (1) or in&n;&t; * multi-NIC mode (2).&n;&t; */
id|priv0-&gt;bcomm-&gt;bc_host
op_assign
id|dgrs_nicmode
ques
c_cond
id|BC_MULTINIC
suffix:colon
id|BC_SWITCH
suffix:semicolon
multiline_comment|/*&n;&t; * Request memory space on board for DMA chains&n;&t; */
r_if
c_cond
(paren
id|priv0-&gt;use_dma
)paren
id|priv0-&gt;bcomm-&gt;bc_hostarea_len
op_assign
(paren
l_int|2048
op_div
l_int|64
)paren
op_star
l_int|16
suffix:semicolon
multiline_comment|/*&n;&t; * NVRAM configurables from Space.c&n;&t; */
id|priv0-&gt;bcomm-&gt;bc_spantree
op_assign
id|dgrs_spantree
suffix:semicolon
id|priv0-&gt;bcomm-&gt;bc_hashexpire
op_assign
id|dgrs_hashexpire
suffix:semicolon
id|memcpy
c_func
(paren
id|priv0-&gt;bcomm-&gt;bc_ipaddr
comma
id|dgrs_ipaddr
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|priv0-&gt;bcomm-&gt;bc_iptrap
comma
id|dgrs_iptrap
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|priv0-&gt;bcomm-&gt;bc_ipxnet
comma
op_amp
id|dgrs_ipxnet
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Release processor, wait 8 seconds for board to initialize&n;&t; */
id|proc_reset
c_func
(paren
id|dev0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|jiffies
op_plus
l_int|8
op_star
id|HZ
suffix:semicolon
id|time_after
c_func
(paren
id|i
comma
id|jiffies
)paren
suffix:semicolon
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Gcc 2.95 needs this */
r_if
c_cond
(paren
id|priv0-&gt;bcomm-&gt;bc_status
op_ge
id|BC_RUN
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priv0-&gt;bcomm-&gt;bc_status
OL
id|BC_RUN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: board not operating&bslash;n&quot;
comma
id|dev0-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|priv0-&gt;port
op_assign
(paren
id|PORT
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;bcomm-&gt;bc_port
)paren
suffix:semicolon
id|priv0-&gt;scbp
op_assign
(paren
id|I596_SCB
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;port-&gt;scbp
)paren
suffix:semicolon
id|priv0-&gt;rfdp
op_assign
(paren
id|I596_RFD
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;scbp-&gt;rfdp
)paren
suffix:semicolon
id|priv0-&gt;rbdp
op_assign
(paren
id|I596_RBD
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;rfdp-&gt;rbdp
)paren
suffix:semicolon
id|priv0-&gt;scbp-&gt;status
op_assign
id|I596_SCB_CNA
suffix:semicolon
multiline_comment|/* CU is idle */
multiline_comment|/*&n;&t; *&t;Get switch physical and host virtual pointers to DMA&n;&t; *&t;chaining area.  NOTE: the MSB of the switch physical&n;&t; *&t;address *must* be turned off.  Otherwise, the HW kludge&n;&t; *&t;that allows host access of the PLX DMA registers will&n;&t; *&t;erroneously select the PLX registers.&n;&t; */
id|priv0-&gt;dmadesc_s
op_assign
(paren
id|DMACHAIN
op_star
)paren
id|S2DMA
c_func
(paren
id|priv0-&gt;bcomm-&gt;bc_hostarea
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv0-&gt;dmadesc_s
)paren
id|priv0-&gt;dmadesc_h
op_assign
(paren
id|DMACHAIN
op_star
)paren
id|S2H
c_func
(paren
id|priv0-&gt;dmadesc_s
)paren
suffix:semicolon
r_else
id|priv0-&gt;dmadesc_h
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Enable board interrupts&n;&t; */
r_if
c_cond
(paren
id|priv0-&gt;plxreg
)paren
(brace
multiline_comment|/* PCI bus */
id|OUTL
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_INT_CSR
comma
id|inl
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_INT_CSR
)paren
op_or
id|PLX_PCI_DOORBELL_IE
)paren
suffix:semicolon
multiline_comment|/* Enable intr to host */
id|OUTL
c_func
(paren
id|dev0-&gt;base_addr
op_plus
id|PLX_LCL2PCI_DOORBELL
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* EISA bus */
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Probe (init) a board&n; */
r_int
id|__init
DECL|function|dgrs_probe1
id|dgrs_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DGRS_PRIV
op_star
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Digi RightSwitch io=%lx mem=%lx irq=%d plx=%lx dma=%lx&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;irq
comma
id|priv-&gt;plxreg
comma
id|priv-&gt;plxdma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Download the firmware and light the processor&n;&t; */
id|rc
op_assign
id|dgrs_download
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get ether address of board&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: Ethernet address&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|priv-&gt;port-&gt;ethaddr
comma
l_int|6
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%c%2.2x&quot;
comma
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Illegal Ethernet Address&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;ACK outstanding interrupts, hook the interrupt,&n;&t; *&t;and verify that we are getting interrupts from the board.&n;&t; */
r_if
c_cond
(paren
id|priv-&gt;plxreg
)paren
id|OUTL
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PLX_LCL2PCI_DOORBELL
comma
l_int|1
)paren
suffix:semicolon
id|rc
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|dgrs_intr
comma
id|SA_SHIRQ
comma
l_string|&quot;RightSwitch&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
id|priv-&gt;intrcnt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|time_after
c_func
(paren
id|i
comma
id|jiffies
)paren
suffix:semicolon
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* gcc 2.95 needs this */
r_if
c_cond
(paren
id|priv-&gt;intrcnt
op_ge
l_int|2
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priv-&gt;intrcnt
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Not interrupting on IRQ %d (%d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|priv-&gt;intrcnt
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Register the /proc/ioports information...&n;&t; */
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|256
comma
l_string|&quot;RightSwitch&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Entry points...&n;&t; */
id|dev-&gt;open
op_assign
op_amp
id|dgrs_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|dgrs_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|dgrs_get_stats
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|dgrs_start_xmit
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|dgrs_set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|dgrs_ioctl
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
id|__init
DECL|function|dgrs_initclone
id|dgrs_initclone
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DGRS_PRIV
op_star
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Digi RightSwitch port %d &quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;chan
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%c%2.2x&quot;
comma
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|dgrs_found_device
id|dgrs_found_device
c_func
(paren
r_int
id|io
comma
id|ulong
id|mem
comma
r_int
id|irq
comma
id|ulong
id|plxreg
comma
id|ulong
id|plxdma
)paren
(brace
id|DGRS_PRIV
op_star
id|priv
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Allocate and fill new device structure. */
r_int
id|dev_size
op_assign
r_sizeof
(paren
r_struct
id|net_device
)paren
op_plus
r_sizeof
(paren
id|DGRS_PRIV
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
id|dev_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
id|dev_size
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
(paren
(paren
r_void
op_star
)paren
id|dev
)paren
op_plus
r_sizeof
(paren
r_struct
id|net_device
)paren
suffix:semicolon
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|io
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|mem
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|mem
op_plus
l_int|2048
op_star
l_int|1024
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|priv-&gt;plxreg
op_assign
id|plxreg
suffix:semicolon
id|priv-&gt;plxdma
op_assign
id|plxdma
suffix:semicolon
id|priv-&gt;vplxdma
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;chan
op_assign
l_int|1
suffix:semicolon
id|priv-&gt;devtbl
(braket
l_int|0
)braket
op_assign
id|dev
suffix:semicolon
id|dev-&gt;init
op_assign
id|dgrs_probe1
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|priv-&gt;next_dev
op_assign
id|dgrs_root_dev
suffix:semicolon
id|dgrs_root_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dgrs_nicmode
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Switch mode, we are done */
multiline_comment|/*&n;&t; * Operating card as N separate NICs&n;&t; */
id|priv-&gt;nports
op_assign
id|priv-&gt;bcomm-&gt;bc_nports
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|priv-&gt;nports
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|net_device
op_star
id|devN
suffix:semicolon
id|DGRS_PRIV
op_star
id|privN
suffix:semicolon
multiline_comment|/* Allocate new dev and priv structures */
id|devN
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
id|dev_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Make it an exact copy of dev[0]... */
id|memcpy
c_func
(paren
id|devN
comma
id|dev
comma
id|dev_size
)paren
suffix:semicolon
id|devN-&gt;priv
op_assign
(paren
(paren
r_void
op_star
)paren
id|devN
)paren
op_plus
r_sizeof
(paren
r_struct
id|net_device
)paren
suffix:semicolon
id|privN
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|devN-&gt;priv
suffix:semicolon
multiline_comment|/* ... and zero out VM areas */
id|privN-&gt;vmem
op_assign
l_int|0
suffix:semicolon
id|privN-&gt;vplxdma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ... and zero out IRQ */
id|devN-&gt;irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ... and base MAC address off address of 1st port */
id|devN-&gt;dev_addr
(braket
l_int|5
)braket
op_add_assign
id|i
suffix:semicolon
id|privN-&gt;chan
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|priv-&gt;devtbl
(braket
id|i
)braket
op_assign
id|devN
suffix:semicolon
id|devN-&gt;init
op_assign
id|dgrs_initclone
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ether_setup
c_func
(paren
id|devN
)paren
suffix:semicolon
id|privN-&gt;next_dev
op_assign
id|dgrs_root_dev
suffix:semicolon
id|dgrs_root_dev
op_assign
id|devN
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|devN
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Scan for all boards&n; */
DECL|variable|__initdata
r_static
r_int
id|is2iv
(braket
l_int|8
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
l_int|3
comma
l_int|5
comma
l_int|7
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|15
)brace
suffix:semicolon
DECL|function|dgrs_scan
r_static
r_int
id|__init
id|dgrs_scan
c_func
(paren
r_void
)paren
(brace
r_int
id|cards_found
op_assign
l_int|0
suffix:semicolon
id|uint
id|io
suffix:semicolon
id|uint
id|mem
suffix:semicolon
id|uint
id|irq
suffix:semicolon
id|uint
id|plxreg
suffix:semicolon
id|uint
id|plxdma
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First, check for PCI boards&n;&t; */
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|SE6_PCI_VENDOR_ID
comma
id|SE6_PCI_DEVICE_ID
comma
id|pdev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|plxreg
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|io
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|1
)paren
suffix:semicolon
id|mem
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|2
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
l_int|0x30
comma
op_amp
id|plxdma
)paren
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|plxdma
op_and_assign
op_complement
l_int|15
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * On some BIOSES, the PLX &quot;expansion rom&quot; (used for DMA)&n;&t;&t;&t; * address comes up as &quot;0&quot;.  This is probably because&n;&t;&t;&t; * the BIOS doesn&squot;t see a valid 55 AA ROM signature at&n;&t;&t;&t; * the &quot;ROM&quot; start and zeroes the address.  To get&n;&t;&t;&t; * around this problem the SE-6 is configured to ask&n;&t;&t;&t; * for 4 MB of space for the dual port memory.  We then&n;&t;&t;&t; * must set its range back to 2 MB, and use the upper&n;&t;&t;&t; * half for DMA register access&n;&t;&t;&t; */
id|OUTL
c_func
(paren
id|io
op_plus
id|PLX_SPACE0_RANGE
comma
l_int|0xFFE00000L
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plxdma
op_eq
l_int|0
)paren
id|plxdma
op_assign
id|mem
op_plus
(paren
l_int|2048L
op_star
l_int|1024L
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
l_int|0x30
comma
id|plxdma
op_plus
l_int|1
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
l_int|0x30
comma
op_amp
id|plxdma
)paren
suffix:semicolon
id|plxdma
op_and_assign
op_complement
l_int|15
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Get and check the bus-master and latency values.&n;&t;&t;&t; * Some PCI BIOSes fail to set the master-enable bit,&n;&t;&t;&t; * and the latency timer must be set to the maximum&n;&t;&t;&t; * value to avoid data corruption that occurs when the&n;&t;&t;&t; * timer expires during a transfer.  Yes, it&squot;s a bug.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_continue
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|dgrs_found_device
c_func
(paren
id|io
comma
id|mem
comma
id|irq
comma
id|plxreg
comma
id|plxdma
)paren
suffix:semicolon
id|cards_found
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Second, check for EISA boards&n;&t; */
r_if
c_cond
(paren
id|EISA_bus
)paren
(brace
r_for
c_loop
(paren
id|io
op_assign
l_int|0x1000
suffix:semicolon
id|io
OL
l_int|0x9000
suffix:semicolon
id|io
op_add_assign
l_int|0x1000
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_MANUFmsb
)paren
op_ne
l_int|0x10
op_logical_or
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_MANUFlsb
)paren
op_ne
l_int|0x49
op_logical_or
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_PRODUCT
)paren
op_ne
id|ES4H_PRODUCT_CODE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_EC
)paren
op_amp
id|ES4H_EC_ENABLE
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Not EISA configured */
id|mem
op_assign
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_AS_31_24
)paren
op_lshift
l_int|24
)paren
op_plus
(paren
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_AS_23_16
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|irq
op_assign
id|is2iv
(braket
id|inb
c_func
(paren
id|io
op_plus
id|ES4H_IS
)paren
op_amp
id|ES4H_IS_INTMASK
)braket
suffix:semicolon
id|dgrs_found_device
c_func
(paren
id|io
comma
id|mem
comma
id|irq
comma
l_int|0L
comma
l_int|0L
)paren
suffix:semicolon
op_increment
id|cards_found
suffix:semicolon
)brace
)brace
r_return
id|cards_found
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Variables that can be overriden from module command line&n; */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|dma
r_static
r_int
id|dma
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|hashexpire
r_static
r_int
id|hashexpire
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|spantree
r_static
r_int
id|spantree
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|ipaddr
r_static
r_int
id|ipaddr
(braket
l_int|4
)braket
op_assign
(brace
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|iptrap
r_static
r_int
id|iptrap
(braket
l_int|4
)braket
op_assign
(brace
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|ipxnet
r_static
id|__u32
id|ipxnet
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|nicmode
r_static
r_int
id|nicmode
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|hashexpire
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|spantree
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ipaddr
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|iptrap
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ipxnet
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|nicmode
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|dgrs_init_module
r_static
r_int
id|__init
id|dgrs_init_module
(paren
r_void
)paren
(brace
r_int
id|cards_found
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Command line variable overrides&n;&t; *&t;&t;debug=NNN&n;&t; *&t;&t;dma=0/1&n;&t; *&t;&t;spantree=0/1&n;&t; *&t;&t;hashexpire=NNN&n;&t; *&t;&t;ipaddr=A,B,C,D&n;&t; *&t;&t;iptrap=A,B,C,D&n;&t; *&t;&t;ipxnet=NNN&n;&t; *&t;&t;nicmode=NNN&n;&t; */
r_if
c_cond
(paren
id|debug
op_ge
l_int|0
)paren
id|dgrs_debug
op_assign
id|debug
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_ge
l_int|0
)paren
id|dgrs_dma
op_assign
id|dma
suffix:semicolon
r_if
c_cond
(paren
id|nicmode
op_ge
l_int|0
)paren
id|dgrs_nicmode
op_assign
id|nicmode
suffix:semicolon
r_if
c_cond
(paren
id|hashexpire
op_ge
l_int|0
)paren
id|dgrs_hashexpire
op_assign
id|hashexpire
suffix:semicolon
r_if
c_cond
(paren
id|spantree
op_ge
l_int|0
)paren
id|dgrs_spantree
op_assign
id|spantree
suffix:semicolon
r_if
c_cond
(paren
id|ipaddr
(braket
l_int|0
)braket
op_ne
op_minus
l_int|1
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|dgrs_ipaddr
(braket
id|i
)braket
op_assign
id|ipaddr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|iptrap
(braket
l_int|0
)braket
op_ne
op_minus
l_int|1
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|dgrs_iptrap
(braket
id|i
)braket
op_assign
id|iptrap
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ipxnet
op_ne
op_minus
l_int|1
)paren
id|dgrs_ipxnet
op_assign
id|htonl
c_func
(paren
id|ipxnet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dgrs_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dgrs: SW=%s FW=Build %d %s&bslash;n&quot;
comma
id|version
comma
id|dgrs_firmnum
comma
id|dgrs_firmdate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Find and configure all the cards&n;&t; */
id|dgrs_root_dev
op_assign
l_int|NULL
suffix:semicolon
id|cards_found
op_assign
id|dgrs_scan
c_func
(paren
)paren
suffix:semicolon
r_return
id|cards_found
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|dgrs_cleanup_module
r_static
r_void
id|__exit
id|dgrs_cleanup_module
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|dgrs_root_dev
)paren
(brace
r_struct
id|net_device
op_star
id|next_dev
suffix:semicolon
id|DGRS_PRIV
op_star
id|priv
suffix:semicolon
id|priv
op_assign
(paren
id|DGRS_PRIV
op_star
)paren
id|dgrs_root_dev-&gt;priv
suffix:semicolon
id|next_dev
op_assign
id|priv-&gt;next_dev
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dgrs_root_dev
)paren
suffix:semicolon
id|proc_reset
c_func
(paren
id|priv-&gt;devtbl
(braket
l_int|0
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;vmem
)paren
id|IOUNMAP
c_func
(paren
id|priv-&gt;vmem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;vplxdma
)paren
id|IOUNMAP
c_func
(paren
(paren
id|uchar
op_star
)paren
id|priv-&gt;vplxdma
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dgrs_root_dev-&gt;base_addr
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dgrs_root_dev-&gt;irq
)paren
id|free_irq
c_func
(paren
id|dgrs_root_dev-&gt;irq
comma
id|dgrs_root_dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dgrs_root_dev
)paren
suffix:semicolon
id|dgrs_root_dev
op_assign
id|next_dev
suffix:semicolon
)brace
)brace
DECL|variable|dgrs_init_module
id|module_init
c_func
(paren
id|dgrs_init_module
)paren
suffix:semicolon
DECL|variable|dgrs_cleanup_module
id|module_exit
c_func
(paren
id|dgrs_cleanup_module
)paren
suffix:semicolon
eof
