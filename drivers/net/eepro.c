multiline_comment|/* eepro.c: Intel EtherExpress Pro/10 device driver for Linux. */
multiline_comment|/*&n;&t;Written 1994, 1995,1996 by Bao C. Ha.&n;&n;&t;Copyright (C) 1994, 1995,1996 by Bao C. Ha.&n;&n;&t;This software may be used and distributed&n;&t;according to the terms of the GNU Public License,&n;&t;incorporated herein by reference.&n;&n;&t;The author may be reached at bao.ha@srs.gov &n;&t;or 418 Hastings Place, Martinez, GA 30907.&n;&n;&t;Things remaining to do:&n;&t;Better record keeping of errors.&n;&t;Eliminate transmit interrupt to reduce overhead.&n;&t;Implement &quot;concurrent processing&quot;. I won&squot;t be doing it!&n;&n;&t;Bugs:&n;&n;&t;If you have a problem of not detecting the 82595 during a&n;&t;reboot (warm reset), disable the FLASH memory should fix it.&n;&t;This is a compatibility hardware problem.&n;&n;&t;Versions:&n;&t;0.12b&t;misc fixes (aris, 06/26/2000)&n;&t;0.12a   port of version 0.12a of 2.2.x kernels to 2.3.x&n;&t;&t;(aris (aris@conectiva.com.br), 05/19/2000)&n;&t;0.11e   some tweaks about multiple cards support (PdP, jul/aug 1999)&n;&t;0.11d&t;added __initdata, __init stuff; call spin_lock_init&n;&t;        in eepro_probe1. Replaced &quot;eepro&quot; by dev-&gt;name. Augmented &n;&t;&t;the code protected by spin_lock in interrupt routine &n;&t;&t;(PdP, 12/12/1998)&n;&t;0.11c   minor cleanup (PdP, RMC, 09/12/1998)  &n;&t;0.11b   Pascal Dupuis (dupuis@lei.ucl.ac.be): works as a module &n;&t;        under 2.1.xx. Debug messages are flagged as KERN_DEBUG to &n;&t;&t;avoid console flooding. Added locking at critical parts. Now &n;&t;&t;the dawn thing is SMP safe.&n;&t;0.11a   Attempt to get 2.1.xx support up (RMC)&n;&t;0.11&t;Brian Candler added support for multiple cards. Tested as&n;&t;&t;a module, no idea if it works when compiled into kernel.&n;&n;&t;0.10e&t;Rick Bressler notified me that ifconfig up;ifconfig down fails&n;&t;&t;because the irq is lost somewhere. Fixed that by moving &n;&t;&t;request_irq and free_irq to eepro_open and eepro_close respectively.&n;&t;0.10d&t;Ugh! Now Wakeup works. Was seriously broken in my first attempt.&n;&t;&t;I&squot;ll need to find a way to specify an ioport other than&n;&t;&t;the default one in the PnP case. PnP definitively sucks.&n;&t;&t;And, yes, this is not the only reason.&n;&t;0.10c&t;PnP Wakeup Test for 595FX. uncomment #define PnPWakeup;&n;&t;&t;to use.&n;&t;0.10b&t;Should work now with (some) Pro/10+. At least for &n;&t;&t;me (and my two cards) it does. _No_ guarantee for &n;&t;&t;function with non-Pro/10+ cards! (don&squot;t have any)&n;&t;&t;(RMC, 9/11/96)&n;&n;&t;0.10&t;Added support for the Etherexpress Pro/10+.  The&n;&t;&t;IRQ map was changed significantly from the old&n;&t;&t;pro/10.  The new interrupt map was provided by&n;&t;&t;Rainer M. Canavan (Canavan@Zeus.cs.bonn.edu).&n;&t;&t;(BCH, 9/3/96)&n;&n;&t;0.09&t;Fixed a race condition in the transmit algorithm,&n;&t;&t;which causes crashes under heavy load with fast&n;&t;&t;pentium computers.  The performance should also&n;&t;&t;improve a bit.  The size of RX buffer, and hence&n;&t;&t;TX buffer, can also be changed via lilo or insmod.&n;&t;&t;(BCH, 7/31/96)&n;&n;&t;0.08&t;Implement 32-bit I/O for the 82595TX and 82595FX&n;&t;&t;based lan cards.  Disable full-duplex mode if TPE&n;&t;&t;is not used.  (BCH, 4/8/96)&n;&n;&t;0.07a&t;Fix a stat report which counts every packet as a&n;&t;&t;heart-beat failure. (BCH, 6/3/95)&n;&n;&t;0.07&t;Modified to support all other 82595-based lan cards.  &n;&t;&t;The IRQ vector of the EtherExpress Pro will be set&n;&t;&t;according to the value saved in the EEPROM.  For other&n;&t;&t;cards, I will do autoirq_request() to grab the next&n;&t;&t;available interrupt vector. (BCH, 3/17/95)&n;&n;&t;0.06a,b&t;Interim released.  Minor changes in the comments and&n;&t;&t;print out format. (BCH, 3/9/95 and 3/14/95)&n;&n;&t;0.06&t;First stable release that I am comfortable with. (BCH,&n;&t;&t;3/2/95)&t;&n;&n;&t;0.05&t;Complete testing of multicast. (BCH, 2/23/95)&t;&n;&n;&t;0.04&t;Adding multicast support. (BCH, 2/14/95)&t;&n;&n;&t;0.03&t;First widely alpha release for public testing. &n;&t;&t;(BCH, 2/14/95)&t;&n;&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;eepro.c: v0.12b 04/26/2000 aris@conectiva.com.br&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n;  Sources:&n;&n;&t;This driver wouldn&squot;t have been written without the availability &n;&t;of the Crynwr&squot;s Lan595 driver source code.  It helps me to &n;&t;familiarize with the 82595 chipset while waiting for the Intel &n;&t;documentation.  I also learned how to detect the 82595 using &n;&t;the packet driver&squot;s technique.&n;&n;&t;This driver is written by cutting and pasting the skeleton.c driver&n;&t;provided by Donald Becker.  I also borrowed the EEPROM routine from&n;&t;Donald Becker&squot;s 82586 driver.&n;&n;&t;Datasheet for the Intel 82595 (including the TX and FX version). It &n;&t;provides just enough info that the casual reader might think that it &n;&t;documents the i82595.&n;&n;&t;The User Manual for the 82595.  It provides a lot of the missing&n;&t;information.&n;&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|compat_dev_kfree_skb
mdefine_line|#define compat_dev_kfree_skb( skb, mode ) dev_kfree_skb( (skb) )
multiline_comment|/* I had reports of looong delays with SLOW_DOWN defined as udelay(2) */
DECL|macro|SLOW_DOWN
mdefine_line|#define SLOW_DOWN inb(0x80)
multiline_comment|/* udelay(2) */
DECL|macro|compat_init_data
mdefine_line|#define compat_init_data     __initdata
multiline_comment|/* First, a few definitions that the brave might change. */
multiline_comment|/* A zero-terminated list of I/O addresses to be probed. */
DECL|variable|compat_init_data
r_static
r_int
r_int
id|eepro_portlist
(braket
)braket
id|compat_init_data
op_assign
(brace
l_int|0x300
comma
l_int|0x210
comma
l_int|0x240
comma
l_int|0x280
comma
l_int|0x2C0
comma
l_int|0x200
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* note: 0x300 is default, the 595FX supports ALL IO Ports &n;  from 0x000 to 0x3F0, some of which are reserved in PCs */
multiline_comment|/* To try the (not-really PnP Wakeup: */
multiline_comment|/*&n;#define PnPWakeup&n;*/
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 0
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|EEPRO_IO_EXTENT
mdefine_line|#define EEPRO_IO_EXTENT&t;16
multiline_comment|/* Different 82595 chips */
DECL|macro|LAN595
mdefine_line|#define&t;LAN595&t;&t;0
DECL|macro|LAN595TX
mdefine_line|#define&t;LAN595TX&t;1
DECL|macro|LAN595FX
mdefine_line|#define&t;LAN595FX&t;2
DECL|macro|LAN595FX_10ISA
mdefine_line|#define&t;LAN595FX_10ISA&t;3
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|eepro_local
r_struct
id|eepro_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|rx_start
r_int
id|rx_start
suffix:semicolon
DECL|member|tx_start
r_int
id|tx_start
suffix:semicolon
multiline_comment|/* start of the transmit chain */
DECL|member|tx_last
r_int
id|tx_last
suffix:semicolon
multiline_comment|/* pointer to last packet in the transmit chain */
DECL|member|tx_end
r_int
id|tx_end
suffix:semicolon
multiline_comment|/* end of the transmit chain (plus 1) */
DECL|member|eepro
r_int
id|eepro
suffix:semicolon
multiline_comment|/* 1 for the EtherExpress Pro/10,&n;&t;&t;&t;   2 for the EtherExpress Pro/10+,&n;&t;&t;&t;   0 for other 82595-based lan cards. */
DECL|member|version
r_int
id|version
suffix:semicolon
multiline_comment|/* a flag to indicate if this is a TX or FX&n;&t;&t;&t;&t;   version of the 82595 chip. */
DECL|member|stepping
r_int
id|stepping
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* Serializing lock  */
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for IDing the board. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x00&t;/* Etherexpress Pro/10 */
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0xaa
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0x00
DECL|macro|GetBit
mdefine_line|#define GetBit(x,y) ((x &amp; (1&lt;&lt;y))&gt;&gt;y)
multiline_comment|/* EEPROM Word 0: */
DECL|macro|ee_PnP
mdefine_line|#define ee_PnP       0  /* Plug &squot;n Play enable bit */
DECL|macro|ee_Word1
mdefine_line|#define ee_Word1     1  /* Word 1? */
DECL|macro|ee_BusWidth
mdefine_line|#define ee_BusWidth  2  /* 8/16 bit */
DECL|macro|ee_FlashAddr
mdefine_line|#define ee_FlashAddr 3  /* Flash Address */
DECL|macro|ee_FlashMask
mdefine_line|#define ee_FlashMask 0x7   /* Mask */
DECL|macro|ee_AutoIO
mdefine_line|#define ee_AutoIO    6  /* */
DECL|macro|ee_reserved0
mdefine_line|#define ee_reserved0 7  /* =0! */
DECL|macro|ee_Flash
mdefine_line|#define ee_Flash     8  /* Flash there? */
DECL|macro|ee_AutoNeg
mdefine_line|#define ee_AutoNeg   9  /* Auto Negotiation enabled? */
DECL|macro|ee_IO0
mdefine_line|#define ee_IO0       10 /* IO Address LSB */
DECL|macro|ee_IO0Mask
mdefine_line|#define ee_IO0Mask   0x /*...*/
DECL|macro|ee_IO1
mdefine_line|#define ee_IO1       15 /* IO MSB */
multiline_comment|/* EEPROM Word 1: */
DECL|macro|ee_IntSel
mdefine_line|#define ee_IntSel    0   /* Interrupt */
DECL|macro|ee_IntMask
mdefine_line|#define ee_IntMask   0x7
DECL|macro|ee_LI
mdefine_line|#define ee_LI        3   /* Link Integrity 0= enabled */
DECL|macro|ee_PC
mdefine_line|#define ee_PC        4   /* Polarity Correction 0= enabled */
DECL|macro|ee_TPE_AUI
mdefine_line|#define ee_TPE_AUI   5   /* PortSelection 1=TPE */
DECL|macro|ee_Jabber
mdefine_line|#define ee_Jabber    6   /* Jabber prevention 0= enabled */
DECL|macro|ee_AutoPort
mdefine_line|#define ee_AutoPort  7   /* Auto Port Selection 1= Disabled */
DECL|macro|ee_SMOUT
mdefine_line|#define ee_SMOUT     8   /* SMout Pin Control 0= Input */
DECL|macro|ee_PROM
mdefine_line|#define ee_PROM      9   /* Flash EPROM / PROM 0=Flash */
DECL|macro|ee_reserved1
mdefine_line|#define ee_reserved1 10  /* .. 12 =0! */
DECL|macro|ee_AltReady
mdefine_line|#define ee_AltReady  13  /* Alternate Ready, 0=normal */
DECL|macro|ee_reserved2
mdefine_line|#define ee_reserved2 14  /* =0! */
DECL|macro|ee_Duplex
mdefine_line|#define ee_Duplex    15
multiline_comment|/* Word2,3,4: */
DECL|macro|ee_IA5
mdefine_line|#define ee_IA5       0 /*bit start for individual Addr Byte 5 */
DECL|macro|ee_IA4
mdefine_line|#define ee_IA4       8 /*bit start for individual Addr Byte 5 */
DECL|macro|ee_IA3
mdefine_line|#define ee_IA3       0 /*bit start for individual Addr Byte 5 */
DECL|macro|ee_IA2
mdefine_line|#define ee_IA2       8 /*bit start for individual Addr Byte 5 */
DECL|macro|ee_IA1
mdefine_line|#define ee_IA1       0 /*bit start for individual Addr Byte 5 */
DECL|macro|ee_IA0
mdefine_line|#define ee_IA0       8 /*bit start for individual Addr Byte 5 */
multiline_comment|/* Word 5: */
DECL|macro|ee_BNC_TPE
mdefine_line|#define ee_BNC_TPE   0 /* 0=TPE */
DECL|macro|ee_BootType
mdefine_line|#define ee_BootType  1 /* 00=None, 01=IPX, 10=ODI, 11=NDIS */
DECL|macro|ee_BootTypeMask
mdefine_line|#define ee_BootTypeMask 0x3 
DECL|macro|ee_NumConn
mdefine_line|#define ee_NumConn   3  /* Number of Connections 0= One or Two */
DECL|macro|ee_FlashSock
mdefine_line|#define ee_FlashSock 4  /* Presence of Flash Socket 0= Present */
DECL|macro|ee_PortTPE
mdefine_line|#define ee_PortTPE   5
DECL|macro|ee_PortBNC
mdefine_line|#define ee_PortBNC   6
DECL|macro|ee_PortAUI
mdefine_line|#define ee_PortAUI   7
DECL|macro|ee_PowerMgt
mdefine_line|#define ee_PowerMgt  10 /* 0= disabled */
DECL|macro|ee_CP
mdefine_line|#define ee_CP        13 /* Concurrent Processing */
DECL|macro|ee_CPMask
mdefine_line|#define ee_CPMask    0x7
multiline_comment|/* Word 6: */
DECL|macro|ee_Stepping
mdefine_line|#define ee_Stepping  0 /* Stepping info */
DECL|macro|ee_StepMask
mdefine_line|#define ee_StepMask  0x0F
DECL|macro|ee_BoardID
mdefine_line|#define ee_BoardID   4 /* Manucaturer Board ID, reserved */
DECL|macro|ee_BoardMask
mdefine_line|#define ee_BoardMask 0x0FFF
multiline_comment|/* Word 7: */
DECL|macro|ee_INT_TO_IRQ
mdefine_line|#define ee_INT_TO_IRQ 0 /* int to IRQ Mapping  = 0x1EB8 for Pro/10+ */
DECL|macro|ee_FX_INT2IRQ
mdefine_line|#define ee_FX_INT2IRQ 0x1EB8 /* the _only_ mapping allowed for FX chips */
multiline_comment|/*..*/
DECL|macro|ee_SIZE
mdefine_line|#define ee_SIZE 0x40 /* total EEprom Size */
DECL|macro|ee_Checksum
mdefine_line|#define ee_Checksum 0xBABA /* initial and final value for adding checksum */
multiline_comment|/* Card identification via EEprom:   */
DECL|macro|ee_addr_vendor
mdefine_line|#define ee_addr_vendor 0x10  /* Word offset for EISA Vendor ID */
DECL|macro|ee_addr_id
mdefine_line|#define ee_addr_id 0x11      /* Word offset for Card ID */
DECL|macro|ee_addr_SN
mdefine_line|#define ee_addr_SN 0x12      /* Serial Number */
DECL|macro|ee_addr_CRC_8
mdefine_line|#define ee_addr_CRC_8 0x14   /* CRC over last thee Bytes */
DECL|macro|ee_vendor_intel0
mdefine_line|#define ee_vendor_intel0 0x25  /* Vendor ID Intel */
DECL|macro|ee_vendor_intel1
mdefine_line|#define ee_vendor_intel1 0xD4
DECL|macro|ee_id_eepro10p0
mdefine_line|#define ee_id_eepro10p0 0x10   /* ID for eepro/10+ */
DECL|macro|ee_id_eepro10p1
mdefine_line|#define ee_id_eepro10p1 0x31
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT 40
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|eepro_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eepro_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|eepro_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eepro_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eepro_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|eepro_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eepro_transmit_interrupt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eepro_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|eepro_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eepro_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_int
id|eepro_grab_irq
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;Details of the i82595.&n;&n;You will need either the datasheet or the user manual to understand what&n;is going on here.  The 82595 is very different from the 82586, 82593.&n;&n;The receive algorithm in eepro_rx() is just an implementation of the&n;RCV ring structure that the Intel 82595 imposes at the hardware level.&n;The receive buffer is set at 24K, and the transmit buffer is 8K.  I&n;am assuming that the total buffer memory is 32K, which is true for the&n;Intel EtherExpress Pro/10.  If it is less than that on a generic card,&n;the driver will be broken.&n;&n;The transmit algorithm in the hardware_send_packet() is similar to the&n;one in the eepro_rx().  The transmit buffer is a ring linked list.&n;I just queue the next available packet to the end of the list.  In my&n;system, the 82595 is so fast that the list seems to always contain a&n;single packet.  In other systems with faster computers and more congested&n;network traffics, the ring linked list should improve performance by&n;allowing up to 8K worth of packets to be queued.&n;&n;The sizes of the receive and transmit buffers can now be changed via lilo &n;or insmod.  Lilo uses the appended line &quot;ether=io,irq,debug,rx-buffer,eth0&quot;&n;where rx-buffer is in KB unit.  Modules uses the parameter mem which is&n;also in KB unit, for example &quot;insmod io=io-address irq=0 mem=rx-buffer.&quot;  &n;The receive buffer has to be more than 3K or less than 29K.  Otherwise,&n;it is reset to the default of 24K, and, hence, 8K for the trasnmit&n;buffer (transmit-buffer = 32K - receive-buffer).&n;&n;*/
multiline_comment|/* now this section could be used by both boards: the oldies and the ee10:&n; * ee10 uses tx buffer before of rx buffer and the oldies the inverse.&n; * (aris)&n; */
DECL|macro|RAM_SIZE
mdefine_line|#define RAM_SIZE        0x8000
DECL|macro|RCV_HEADER
mdefine_line|#define RCV_HEADER      8
DECL|macro|RCV_DEFAULT_RAM
mdefine_line|#define RCV_DEFAULT_RAM 0x6000
DECL|macro|RCV_RAM
mdefine_line|#define RCV_RAM         rcv_ram
DECL|variable|rcv_ram
r_static
r_int
id|rcv_ram
op_assign
id|RCV_DEFAULT_RAM
suffix:semicolon
DECL|macro|XMT_HEADER
mdefine_line|#define XMT_HEADER      8
DECL|macro|XMT_RAM
mdefine_line|#define XMT_RAM         (RAM_SIZE - RCV_RAM)
DECL|macro|XMT_START
mdefine_line|#define XMT_START       ((rcv_start + RCV_RAM) % RAM_SIZE)
DECL|macro|RCV_LOWER_LIMIT
mdefine_line|#define RCV_LOWER_LIMIT (rcv_start &gt;&gt; 8)
DECL|macro|RCV_UPPER_LIMIT
mdefine_line|#define RCV_UPPER_LIMIT (((rcv_start + RCV_RAM) - 2) &gt;&gt; 8)
DECL|macro|XMT_LOWER_LIMIT
mdefine_line|#define XMT_LOWER_LIMIT (XMT_START &gt;&gt; 8)
DECL|macro|XMT_UPPER_LIMIT
mdefine_line|#define XMT_UPPER_LIMIT (((XMT_START + XMT_RAM) - 2) &gt;&gt; 8)
DECL|macro|RCV_START_PRO
mdefine_line|#define RCV_START_PRO   0x00
DECL|macro|RCV_START_10
mdefine_line|#define RCV_START_10    XMT_RAM
multiline_comment|/* by default the old driver */
DECL|variable|rcv_start
r_static
r_int
id|rcv_start
op_assign
id|RCV_START_PRO
suffix:semicolon
DECL|macro|RCV_DONE
mdefine_line|#define&t;RCV_DONE&t;0x0008
DECL|macro|RX_OK
mdefine_line|#define&t;RX_OK&t;&t;0x2000
DECL|macro|RX_ERROR
mdefine_line|#define&t;RX_ERROR&t;0x0d81
DECL|macro|TX_DONE_BIT
mdefine_line|#define&t;TX_DONE_BIT&t;0x0080
DECL|macro|CHAIN_BIT
mdefine_line|#define&t;CHAIN_BIT&t;0x8000
DECL|macro|XMT_STATUS
mdefine_line|#define&t;XMT_STATUS&t;0x02
DECL|macro|XMT_CHAIN
mdefine_line|#define&t;XMT_CHAIN&t;0x04
DECL|macro|XMT_COUNT
mdefine_line|#define&t;XMT_COUNT&t;0x06
DECL|macro|BANK0_SELECT
mdefine_line|#define&t;BANK0_SELECT&t;0x00&t;&t;
DECL|macro|BANK1_SELECT
mdefine_line|#define&t;BANK1_SELECT&t;0x40&t;&t;
DECL|macro|BANK2_SELECT
mdefine_line|#define&t;BANK2_SELECT&t;0x80&t;&t;
multiline_comment|/* Bank 0 registers */
DECL|macro|COMMAND_REG
mdefine_line|#define&t;COMMAND_REG&t;0x00&t;/* Register 0 */
DECL|macro|MC_SETUP
mdefine_line|#define&t;MC_SETUP&t;0x03
DECL|macro|XMT_CMD
mdefine_line|#define&t;XMT_CMD&t;&t;0x04
DECL|macro|DIAGNOSE_CMD
mdefine_line|#define&t;DIAGNOSE_CMD&t;0x07
DECL|macro|RCV_ENABLE_CMD
mdefine_line|#define&t;RCV_ENABLE_CMD&t;0x08
DECL|macro|RCV_DISABLE_CMD
mdefine_line|#define&t;RCV_DISABLE_CMD&t;0x0a
DECL|macro|STOP_RCV_CMD
mdefine_line|#define&t;STOP_RCV_CMD&t;0x0b
DECL|macro|RESET_CMD
mdefine_line|#define&t;RESET_CMD&t;0x0e
DECL|macro|POWER_DOWN_CMD
mdefine_line|#define&t;POWER_DOWN_CMD&t;0x18
DECL|macro|RESUME_XMT_CMD
mdefine_line|#define&t;RESUME_XMT_CMD&t;0x1c
DECL|macro|SEL_RESET_CMD
mdefine_line|#define&t;SEL_RESET_CMD&t;0x1e
DECL|macro|STATUS_REG
mdefine_line|#define&t;STATUS_REG&t;0x01&t;/* Register 1 */
DECL|macro|RX_INT
mdefine_line|#define&t;RX_INT&t;&t;0x02
DECL|macro|TX_INT
mdefine_line|#define&t;TX_INT&t;&t;0x04
DECL|macro|EXEC_STATUS
mdefine_line|#define&t;EXEC_STATUS&t;0x30
DECL|macro|ID_REG
mdefine_line|#define&t;ID_REG&t;&t;0x02&t;/* Register 2&t;*/
DECL|macro|R_ROBIN_BITS
mdefine_line|#define&t;R_ROBIN_BITS&t;0xc0&t;/* round robin counter */
DECL|macro|ID_REG_MASK
mdefine_line|#define&t;ID_REG_MASK&t;0x2c
DECL|macro|ID_REG_SIG
mdefine_line|#define&t;ID_REG_SIG&t;0x24
DECL|macro|AUTO_ENABLE
mdefine_line|#define&t;AUTO_ENABLE&t;0x10
DECL|macro|INT_MASK_REG
mdefine_line|#define&t;INT_MASK_REG&t;0x03&t;/* Register 3&t;*/
DECL|macro|RX_STOP_MASK
mdefine_line|#define&t;RX_STOP_MASK&t;0x01
DECL|macro|RX_MASK
mdefine_line|#define&t;RX_MASK&t;&t;0x02
DECL|macro|TX_MASK
mdefine_line|#define&t;TX_MASK&t;&t;0x04
DECL|macro|EXEC_MASK
mdefine_line|#define&t;EXEC_MASK&t;0x08
DECL|macro|ALL_MASK
mdefine_line|#define&t;ALL_MASK&t;0x0f
DECL|macro|IO_32_BIT
mdefine_line|#define&t;IO_32_BIT&t;0x10
DECL|macro|RCV_BAR
mdefine_line|#define&t;RCV_BAR&t;&t;0x04&t;/* The following are word (16-bit) registers */
DECL|macro|RCV_STOP
mdefine_line|#define&t;RCV_STOP&t;0x06
DECL|macro|XMT_BAR_PRO
mdefine_line|#define&t;XMT_BAR_PRO&t;0x0a
DECL|macro|XMT_BAR_10
mdefine_line|#define&t;XMT_BAR_10&t;0x0b
DECL|variable|xmt_bar
r_static
r_int
id|xmt_bar
op_assign
id|XMT_BAR_PRO
suffix:semicolon
DECL|macro|HOST_ADDRESS_REG
mdefine_line|#define&t;HOST_ADDRESS_REG&t;0x0c
DECL|macro|IO_PORT
mdefine_line|#define&t;IO_PORT&t;&t;0x0e
DECL|macro|IO_PORT_32_BIT
mdefine_line|#define&t;IO_PORT_32_BIT&t;0x0c
multiline_comment|/* Bank 1 registers */
DECL|macro|REG1
mdefine_line|#define&t;REG1&t;0x01
DECL|macro|WORD_WIDTH
mdefine_line|#define&t;WORD_WIDTH&t;0x02
DECL|macro|INT_ENABLE
mdefine_line|#define&t;INT_ENABLE&t;0x80
DECL|macro|INT_NO_REG
mdefine_line|#define INT_NO_REG&t;0x02
DECL|macro|RCV_LOWER_LIMIT_REG
mdefine_line|#define&t;RCV_LOWER_LIMIT_REG&t;0x08
DECL|macro|RCV_UPPER_LIMIT_REG
mdefine_line|#define&t;RCV_UPPER_LIMIT_REG&t;0x09
DECL|macro|XMT_LOWER_LIMIT_REG_PRO
mdefine_line|#define&t;XMT_LOWER_LIMIT_REG_PRO 0x0a
DECL|macro|XMT_UPPER_LIMIT_REG_PRO
mdefine_line|#define&t;XMT_UPPER_LIMIT_REG_PRO 0x0b
DECL|macro|XMT_LOWER_LIMIT_REG_10
mdefine_line|#define&t;XMT_LOWER_LIMIT_REG_10  0x0b
DECL|macro|XMT_UPPER_LIMIT_REG_10
mdefine_line|#define&t;XMT_UPPER_LIMIT_REG_10  0x0a
DECL|variable|xmt_lower_limit_reg
r_static
r_int
id|xmt_lower_limit_reg
op_assign
id|XMT_LOWER_LIMIT_REG_PRO
suffix:semicolon
DECL|variable|xmt_upper_limit_reg
r_static
r_int
id|xmt_upper_limit_reg
op_assign
id|XMT_UPPER_LIMIT_REG_PRO
suffix:semicolon
multiline_comment|/* Bank 2 registers */
DECL|macro|XMT_Chain_Int
mdefine_line|#define&t;XMT_Chain_Int&t;0x20&t;/* Interrupt at the end of the transmit chain */
DECL|macro|XMT_Chain_ErrStop
mdefine_line|#define&t;XMT_Chain_ErrStop&t;0x40 /* Interrupt at the end of the chain even if there are errors */
DECL|macro|RCV_Discard_BadFrame
mdefine_line|#define&t;RCV_Discard_BadFrame&t;0x80 /* Throw bad frames away, and continue to receive others */
DECL|macro|REG2
mdefine_line|#define&t;REG2&t;&t;0x02
DECL|macro|PRMSC_Mode
mdefine_line|#define&t;PRMSC_Mode&t;0x01
DECL|macro|Multi_IA
mdefine_line|#define&t;Multi_IA&t;0x20
DECL|macro|REG3
mdefine_line|#define&t;REG3&t;&t;0x03
DECL|macro|TPE_BIT
mdefine_line|#define&t;TPE_BIT&t;&t;0x04
DECL|macro|BNC_BIT
mdefine_line|#define&t;BNC_BIT&t;&t;0x20
DECL|macro|REG13
mdefine_line|#define&t;REG13&t;&t;0x0d
DECL|macro|FDX
mdefine_line|#define&t;FDX&t;&t;0x00
DECL|macro|A_N_ENABLE
mdefine_line|#define&t;A_N_ENABLE&t;0x02
DECL|macro|I_ADD_REG0
mdefine_line|#define&t;I_ADD_REG0&t;0x04
DECL|macro|I_ADD_REG1
mdefine_line|#define&t;I_ADD_REG1&t;0x05
DECL|macro|I_ADD_REG2
mdefine_line|#define&t;I_ADD_REG2&t;0x06
DECL|macro|I_ADD_REG3
mdefine_line|#define&t;I_ADD_REG3&t;0x07
DECL|macro|I_ADD_REG4
mdefine_line|#define&t;I_ADD_REG4&t;0x08
DECL|macro|I_ADD_REG5
mdefine_line|#define&t;I_ADD_REG5&t;0x09
DECL|macro|EEPROM_REG_PRO
mdefine_line|#define&t;EEPROM_REG_PRO 0x0a
DECL|macro|EEPROM_REG_10
mdefine_line|#define&t;EEPROM_REG_10  0x0b
DECL|variable|eeprom_reg
r_static
r_int
id|eeprom_reg
op_assign
id|EEPROM_REG_PRO
suffix:semicolon
DECL|macro|EESK
mdefine_line|#define EESK 0x01
DECL|macro|EECS
mdefine_line|#define EECS 0x02
DECL|macro|EEDI
mdefine_line|#define EEDI 0x04
DECL|macro|EEDO
mdefine_line|#define EEDO 0x08
multiline_comment|/* do a full reset */
DECL|macro|eepro_reset
mdefine_line|#define eepro_reset(ioaddr) outb(RESET_CMD, ioaddr)
multiline_comment|/* do a nice reset */
DECL|macro|eepro_sel_reset
mdefine_line|#define eepro_sel_reset(ioaddr) &t;{ &bslash;&n;&t;&t;&t;&t;&t;outb(SEL_RESET_CMD, ioaddr); &bslash;&n;&t;&t;&t;&t;&t;SLOW_DOWN; &bslash;&n;&t;&t;&t;&t;&t;SLOW_DOWN; &bslash;&n;&t;&t;&t;&t;&t;}
multiline_comment|/* disable all interrupts */
DECL|macro|eepro_dis_int
mdefine_line|#define eepro_dis_int(ioaddr) outb(ALL_MASK, ioaddr + INT_MASK_REG)
multiline_comment|/* clear all interrupts */
DECL|macro|eepro_clear_int
mdefine_line|#define eepro_clear_int(ioaddr) outb(ALL_MASK, ioaddr + STATUS_REG)
multiline_comment|/* enable tx/rx */
DECL|macro|eepro_en_int
mdefine_line|#define eepro_en_int(ioaddr) outb(ALL_MASK &amp; ~(RX_MASK | TX_MASK), &bslash;&n;&t;&t;&t;&t;&t;&t;&t;ioaddr + INT_MASK_REG)
multiline_comment|/* enable exec event interrupt */
DECL|macro|eepro_en_intexec
mdefine_line|#define eepro_en_intexec(ioaddr) outb(ALL_MASK &amp; ~(EXEC_MASK), ioaddr + INT_MASK_REG)
multiline_comment|/* enable rx */
DECL|macro|eepro_en_rx
mdefine_line|#define eepro_en_rx(ioaddr) outb(RCV_ENABLE_CMD, ioaddr)
multiline_comment|/* disable rx */
DECL|macro|eepro_dis_rx
mdefine_line|#define eepro_dis_rx(ioaddr) outb(RCV_DISABLE_CMD, ioaddr)
multiline_comment|/* switch bank */
DECL|macro|eepro_sw2bank0
mdefine_line|#define eepro_sw2bank0(ioaddr) outb(BANK0_SELECT, ioaddr)
DECL|macro|eepro_sw2bank1
mdefine_line|#define eepro_sw2bank1(ioaddr) outb(BANK1_SELECT, ioaddr)
DECL|macro|eepro_sw2bank2
mdefine_line|#define eepro_sw2bank2(ioaddr) outb(BANK2_SELECT, ioaddr)
multiline_comment|/* enable interrupt line */
DECL|macro|eepro_en_intline
mdefine_line|#define eepro_en_intline(ioaddr) outb(inb(ioaddr + REG1) | INT_ENABLE,&bslash;&n;&t;&t;&t;&t;ioaddr + REG1)
multiline_comment|/* disable interrupt line */
DECL|macro|eepro_dis_intline
mdefine_line|#define eepro_dis_intline(ioaddr) outb(inb(ioaddr + REG1) &amp; 0x7f, &bslash;&n;&t;&t;&t;&t;ioaddr + REG1);
multiline_comment|/* set diagnose flag */
DECL|macro|eepro_diag
mdefine_line|#define eepro_diag(ioaddr) outb(DIAGNOSE_CMD, ioaddr)
multiline_comment|/* ack for rx/tx int */
DECL|macro|eepro_ack_rxtx
mdefine_line|#define eepro_ack_rxtx(ioaddr) outb (RX_INT | TX_INT, ioaddr + STATUS_REG)
multiline_comment|/* ack for rx int */
DECL|macro|eepro_ack_rx
mdefine_line|#define eepro_ack_rx(ioaddr) outb (RX_INT, ioaddr + STATUS_REG)
multiline_comment|/* ack for tx int */
DECL|macro|eepro_ack_tx
mdefine_line|#define eepro_ack_tx(ioaddr) outb (TX_INT, ioaddr + STATUS_REG)
multiline_comment|/* a complete sel reset */
DECL|macro|eepro_complete_selreset
mdefine_line|#define eepro_complete_selreset(ioaddr) { &t;eepro_dis_int(ioaddr);&bslash;&n;&t;&t;&t;&t;&t;&t;lp-&gt;stats.tx_errors++;&bslash;&n;&t;&t;&t;&t;&t;&t;eepro_sel_reset(ioaddr);&bslash;&n;&t;&t;&t;&t;&t;&t;lp-&gt;tx_end = &bslash;&n;&t;&t;&t;&t;&t;&t;&t;(XMT_LOWER_LIMIT &lt;&lt; 8);&bslash;&n;&t;&t;&t;&t;&t;&t;lp-&gt;tx_start = lp-&gt;tx_end;&bslash;&n;&t;&t;&t;&t;&t;&t;lp-&gt;tx_last = 0;&bslash;&n;&t;&t;&t;&t;&t;&t;dev-&gt;trans_start = jiffies;&bslash;&n;&t;&t;&t;&t;&t;&t;netif_wake_queue(dev);&bslash;&n;&t;&t;&t;&t;&t;&t;eepro_en_int(ioaddr);&bslash;&n;&t;&t;&t;&t;&t;&t;eepro_en_rx(ioaddr);&bslash;&n;&t;&t;&t;&t;&t;}
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; if one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   */
DECL|function|eepro_probe
r_int
id|__init
id|eepro_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef PnPWakeup
multiline_comment|/* XXXX for multiple cards should this only be run once? */
multiline_comment|/* Wakeup: */
DECL|macro|WakeupPort
mdefine_line|#define WakeupPort 0x279
DECL|macro|WakeupSeq
mdefine_line|#define WakeupSeq    {0x6A, 0xB5, 0xDA, 0xED, 0xF6, 0xFB, 0x7D, 0xBE,&bslash;&n;&t;                      0xDF, 0x6F, 0x37, 0x1B, 0x0D, 0x86, 0xC3, 0x61,&bslash;&n;&t;                      0xB0, 0x58, 0x2C, 0x16, 0x8B, 0x45, 0xA2, 0xD1,&bslash;&n;&t;                      0xE8, 0x74, 0x3A, 0x9D, 0xCE, 0xE7, 0x73, 0x43}
(brace
r_int
r_int
r_int
id|WS
(braket
l_int|32
)braket
op_assign
id|WakeupSeq
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|WakeupPort
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Waking UP&bslash;n&quot;
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|WakeupPort
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|WakeupPort
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|WS
(braket
id|i
)braket
comma
id|WakeupPort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;: %#x &quot;
comma
id|WS
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Checkregion Failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|eepro_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|eepro_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
id|eepro_portlist
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|EEPRO_IO_EXTENT
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|eepro_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|printEEPROMInfo
r_void
id|printEEPROMInfo
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|Word
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|ee_Checksum
suffix:semicolon
id|i
OL
id|ee_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|j
op_add_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
id|i
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Checksum: %#x&bslash;n&quot;
comma
id|j
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|Word
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Word0:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Plug &squot;n Pray: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_PnP
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Buswidth: %d&bslash;n&quot;
comma
(paren
id|GetBit
c_func
(paren
id|Word
comma
id|ee_BusWidth
)paren
op_plus
l_int|1
)paren
op_star
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; AutoNegotiation: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_AutoNeg
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; IO Address: %#x&bslash;n&quot;
comma
(paren
id|Word
op_rshift
id|ee_IO0
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|Word
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|1
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Word1:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; INT: %d&bslash;n&quot;
comma
id|Word
op_amp
id|ee_IntMask
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; LI: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_LI
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; PC: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_PC
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; TPE/AUI: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_TPE_AUI
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Jabber: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_Jabber
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; AutoPort: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
op_logical_neg
id|Word
comma
id|ee_Jabber
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Duplex: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_Duplex
)paren
)paren
suffix:semicolon
)brace
id|Word
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Word5:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; BNC: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_BNC_TPE
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; NumConnectors: %d&bslash;n&quot;
comma
id|GetBit
c_func
(paren
id|Word
comma
id|ee_NumConn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Has &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetBit
c_func
(paren
id|Word
comma
id|ee_PortTPE
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;TPE &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetBit
c_func
(paren
id|Word
comma
id|ee_PortBNC
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;BNC &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetBit
c_func
(paren
id|Word
comma
id|ee_PortAUI
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;AUI &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;port(s) &bslash;n&quot;
)paren
suffix:semicolon
id|Word
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|6
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Word6:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Stepping: %d&bslash;n&quot;
comma
id|Word
op_amp
id|ee_StepMask
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; BoardID: %d&bslash;n&quot;
comma
id|Word
op_rshift
id|ee_BoardID
)paren
suffix:semicolon
id|Word
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|7
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Word7:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; INT to IRQ:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|GetBit
c_func
(paren
id|Word
comma
id|i
)paren
)paren
id|printk
c_func
(paren
l_string|&quot; INT%d -&gt; IRQ %d;&quot;
comma
id|j
op_increment
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This is the real probe routine.  Linux has a history of friendly device&n;   probes on the ISA bus.  A good device probe avoids doing writes, and&n;   verifies that the correct device exists and functions.  */
DECL|function|eepro_probe1
r_static
r_int
id|eepro_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
r_int
id|station_addr
(braket
l_int|6
)braket
comma
id|id
comma
id|counter
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|irqMask
suffix:semicolon
r_int
id|eepro
op_assign
l_int|0
suffix:semicolon
r_struct
id|eepro_local
op_star
id|lp
suffix:semicolon
r_const
r_char
op_star
id|ifmap
(braket
)braket
op_assign
(brace
l_string|&quot;AUI&quot;
comma
l_string|&quot;10Base2&quot;
comma
l_string|&quot;10BaseT&quot;
)brace
suffix:semicolon
r_enum
id|iftype
(brace
id|AUI
op_assign
l_int|0
comma
id|BNC
op_assign
l_int|1
comma
id|TPE
op_assign
l_int|2
)brace
suffix:semicolon
multiline_comment|/* Now, we are going to check for the signature of the&n;&t;   ID_REG (register 2 of bank 0) */
id|id
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|ID_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|id
)paren
op_amp
id|ID_REG_MASK
)paren
op_eq
id|ID_REG_SIG
)paren
(brace
multiline_comment|/* We seem to have the 82595 signature, let&squot;s&n;&t;&t;   play with its counter (last 2 bits of&n;&t;&t;   register 2 of bank 0) to be sure. */
id|counter
op_assign
(paren
id|id
op_amp
id|R_ROBIN_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|id
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|ID_REG
)paren
)paren
op_amp
id|R_ROBIN_BITS
)paren
op_eq
(paren
id|counter
op_plus
l_int|0x40
)paren
)paren
(brace
multiline_comment|/* Yes, the 82595 has been found */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; id: %#x &quot;
comma
id|id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; io: %#x &quot;
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eepro_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eepro_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Now, get the ethernet hardware address from&n;&t;&t;&t;   the EEPROM */
id|station_addr
(braket
l_int|0
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|2
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* FIXME - find another way to know that we&squot;ve found&n;&t;&t;&t; * an Etherexpress 10&n;&t;&t;&t; */
r_if
c_cond
(paren
id|station_addr
(braket
l_int|0
)braket
op_eq
l_int|0x0000
op_logical_or
id|station_addr
(braket
l_int|0
)braket
op_eq
l_int|0xffff
)paren
(brace
id|eepro
op_assign
l_int|3
suffix:semicolon
id|lp-&gt;eepro
op_assign
id|LAN595FX_10ISA
suffix:semicolon
id|eeprom_reg
op_assign
id|EEPROM_REG_10
suffix:semicolon
id|rcv_start
op_assign
id|RCV_START_10
suffix:semicolon
id|xmt_lower_limit_reg
op_assign
id|XMT_LOWER_LIMIT_REG_10
suffix:semicolon
id|xmt_upper_limit_reg
op_assign
id|XMT_UPPER_LIMIT_REG_10
suffix:semicolon
id|station_addr
(braket
l_int|0
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|2
comma
id|dev
)paren
suffix:semicolon
)brace
id|station_addr
(braket
l_int|1
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|3
comma
id|dev
)paren
suffix:semicolon
id|station_addr
(braket
l_int|2
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eepro
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Intel EtherExpress 10 ISA&bslash;n at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|7
comma
id|dev
)paren
op_eq
id|ee_FX_INT2IRQ
)paren
(brace
multiline_comment|/* int to IRQ Mask */
id|eepro
op_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Intel EtherExpress Pro/10+ ISA&bslash;n at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|station_addr
(braket
l_int|2
)braket
op_eq
l_int|0x00aa
)paren
(brace
id|eepro
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Intel EtherExpress Pro/10 ISA at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|eepro
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Intel 82595-based lan card at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|station_addr
)paren
(braket
l_int|5
op_minus
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c%02x&quot;
comma
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|dev-&gt;mem_start
op_assign
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_end
op_amp
l_int|0x3f
)paren
template_param
l_int|29
)paren
multiline_comment|/* and less than 29K */
id|dev-&gt;mem_end
op_assign
(paren
id|RCV_UPPER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
r_else
(brace
id|dev-&gt;mem_end
op_assign
(paren
id|dev-&gt;mem_end
op_star
l_int|1024
)paren
op_plus
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
id|rcv_ram
op_assign
id|dev-&gt;mem_end
op_minus
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* From now on, dev-&gt;mem_end - dev-&gt;mem_start contains &n;&t;&t;&t; * the actual size of rx buffer &n;&t;&t;&t; */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;, %dK RCV buffer&quot;
comma
(paren
r_int
)paren
(paren
id|dev-&gt;mem_end
op_minus
id|dev-&gt;mem_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* ............... */
r_if
c_cond
(paren
id|GetBit
c_func
(paren
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
comma
id|dev
)paren
comma
id|ee_BNC_TPE
)paren
)paren
id|dev-&gt;if_port
op_assign
id|BNC
suffix:semicolon
r_else
id|dev-&gt;if_port
op_assign
id|TPE
suffix:semicolon
multiline_comment|/* ............... */
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
op_logical_and
(paren
id|eepro
op_ne
l_int|0
)paren
)paren
(brace
id|i
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|1
comma
id|dev
)paren
suffix:semicolon
id|irqMask
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|7
comma
id|dev
)paren
suffix:semicolon
id|i
op_and_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* Mask off INT number */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|j
OL
l_int|16
)paren
op_logical_and
(paren
id|i
op_ge
l_int|0
)paren
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|irqMask
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|dev-&gt;irq
op_assign
id|j
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* found bit corresponding to irq */
)brace
id|i
op_decrement
suffix:semicolon
multiline_comment|/* count bits set in irqMask */
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Duh! illegal interrupt vector stored in EEPROM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, IRQ %d, %s.&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|ifmap
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, %s.&bslash;n&quot;
comma
id|ifmap
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
OG
l_int|0
)paren
multiline_comment|/* I don&squot;t know if this is */
id|net_debug
op_assign
id|dev-&gt;mem_start
op_amp
l_int|7
suffix:semicolon
multiline_comment|/* still useful or not */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|i
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x2000
)paren
multiline_comment|/* bit 13 of EEPROM word 5 */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Concurrent Processing is enabled but not used!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Grab the region so we can find another board if autoIRQ fails. */
id|request_region
c_func
(paren
id|ioaddr
comma
id|EEPRO_IO_EXTENT
comma
id|dev-&gt;name
)paren
suffix:semicolon
(paren
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|dev-&gt;open
op_assign
id|eepro_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|eepro_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|eepro_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|eepro_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|eepro_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with&n;&t;&t;&t;   ethernet generic values */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Check the station address for the manufacturer&squot;s code */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printEEPROMInfo
c_func
(paren
id|ioaddr
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* RESET the 82595 */
id|eepro_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
(paren
l_string|&quot;EtherExpress Pro probed failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;   */
DECL|variable|irqrmap
r_static
r_char
id|irqrmap
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_minus
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|3
comma
l_int|4
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|irqrmap2
r_static
r_char
id|irqrmap2
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|4
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
l_int|3
comma
op_minus
l_int|1
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|function|eepro_grab_irq
r_static
r_int
id|eepro_grab_irq
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|irqlist
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|0
)brace
suffix:semicolon
r_int
op_star
id|irqp
op_assign
id|irqlist
comma
id|temp_reg
comma
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|eepro_sw2bank1
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 1 now */
multiline_comment|/* Enable the interrupt line. */
id|eepro_en_intline
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 0 now */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|eepro_clear_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Let EXEC event to interrupt */
id|eepro_en_intexec
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_do
(brace
id|eepro_sw2bank1
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 1 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf8
)paren
op_or
id|irqrmap
(braket
op_star
id|irqp
)braket
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
r_if
c_cond
(paren
id|request_irq
(paren
op_star
id|irqp
comma
l_int|NULL
comma
l_int|0
comma
l_string|&quot;bogus&quot;
comma
id|dev
)paren
op_ne
id|EBUSY
)paren
(brace
multiline_comment|/* Twinkle the interrupt, and check if it&squot;s seen */
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|eepro_diag
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* RESET the 82595 */
r_if
c_cond
(paren
op_star
id|irqp
op_eq
id|autoirq_report
c_func
(paren
l_int|2
)paren
)paren
multiline_comment|/* It&squot;s a good IRQ line */
r_break
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|eepro_clear_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
op_increment
id|irqp
)paren
suffix:semicolon
id|eepro_sw2bank1
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 1 */
multiline_comment|/* Disable the physical interrupt line. */
id|eepro_dis_intline
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
multiline_comment|/* Mask all the interrupts. */
id|eepro_dis_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|eepro_clear_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_return
id|dev-&gt;irq
suffix:semicolon
)brace
DECL|function|eepro_open
r_static
r_int
id|eepro_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|temp_reg
comma
id|old8
comma
id|old9
suffix:semicolon
r_int
id|irqMask
suffix:semicolon
r_int
id|i
comma
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: entering eepro_open routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|irqMask
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|7
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;p-&gt;eepro = 3;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irqMask
op_eq
id|ee_FX_INT2IRQ
)paren
multiline_comment|/* INT to IRQ Mask */
(brace
id|lp-&gt;eepro
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Yes, an Intel EtherExpress Pro/10+ */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;p-&gt;eepro = 2;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_eq
id|SA_ADDR0
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_eq
id|SA_ADDR1
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_eq
id|SA_ADDR2
)paren
)paren
(brace
id|lp-&gt;eepro
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;p-&gt;eepro = 1;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Yes, an Intel EtherExpress Pro/10 */
r_else
id|lp-&gt;eepro
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No, it is a generic 82585 lan card */
multiline_comment|/* Get the interrupt vector for the 82595 */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
op_logical_and
id|eepro_grab_irq
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|eepro_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
macro_line|#ifdef irq2dev_map
r_if
c_cond
(paren
(paren
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_ne
l_int|0
)paren
op_logical_or
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_ne
id|dev
)paren
)paren
(brace
multiline_comment|/* printk(&quot;%s: IRQ map wrong&bslash;n&quot;, dev-&gt;name); */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Initialize the 82595. */
id|eepro_sw2bank2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|eeprom_reg
)paren
suffix:semicolon
id|lp-&gt;stepping
op_assign
id|temp_reg
op_rshift
l_int|5
suffix:semicolon
multiline_comment|/* Get the stepping number of the 595 */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;The stepping of the 82595 is %d&bslash;n&quot;
comma
id|lp-&gt;stepping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_reg
op_amp
l_int|0x10
)paren
multiline_comment|/* Check the TurnOff Enable bit */
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0xef
comma
id|ioaddr
op_plus
id|eeprom_reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|I_ADD_REG0
op_plus
id|i
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
multiline_comment|/* Setup Transmit Chaining */
id|outb
c_func
(paren
id|temp_reg
op_or
id|XMT_Chain_Int
op_or
id|XMT_Chain_ErrStop
multiline_comment|/* and discard bad RCV frames */
op_or
id|RCV_Discard_BadFrame
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
multiline_comment|/* Match broadcast */
id|outb
c_func
(paren
id|temp_reg
op_or
l_int|0x14
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0x3f
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* clear test mode */
multiline_comment|/* Set the receiving mode */
id|eepro_sw2bank1
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 1 now */
multiline_comment|/* Set the interrupt vector */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
l_int|2
op_logical_or
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf8
)paren
op_or
id|irqrmap2
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
r_else
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf8
)paren
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
l_int|2
op_logical_or
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf0
)paren
op_or
id|irqrmap2
(braket
id|dev-&gt;irq
)braket
op_or
l_int|0x08
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
r_else
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf8
)paren
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;eepro_open: content of INT Reg is %x&bslash;n&quot;
comma
id|temp_reg
)paren
suffix:semicolon
multiline_comment|/* Initialize the RCV and XMT upper and lower limits */
id|outb
c_func
(paren
id|RCV_LOWER_LIMIT
comma
id|ioaddr
op_plus
id|RCV_LOWER_LIMIT_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RCV_UPPER_LIMIT
comma
id|ioaddr
op_plus
id|RCV_UPPER_LIMIT_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|XMT_LOWER_LIMIT
comma
id|ioaddr
op_plus
id|xmt_lower_limit_reg
)paren
suffix:semicolon
id|outb
c_func
(paren
id|XMT_UPPER_LIMIT
comma
id|ioaddr
op_plus
id|xmt_upper_limit_reg
)paren
suffix:semicolon
multiline_comment|/* Enable the interrupt line. */
id|eepro_en_intline
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Let RX and TX events to interrupt */
id|eepro_en_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|eepro_clear_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Initialize RCV */
id|outw
c_func
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
comma
id|ioaddr
op_plus
id|RCV_BAR
)paren
suffix:semicolon
id|lp-&gt;rx_start
op_assign
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|RCV_UPPER_LIMIT
op_lshift
l_int|8
)paren
op_or
l_int|0xfe
comma
id|ioaddr
op_plus
id|RCV_STOP
)paren
suffix:semicolon
multiline_comment|/* Initialize XMT */
id|outw
c_func
(paren
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
comma
id|ioaddr
op_plus
id|xmt_bar
)paren
suffix:semicolon
multiline_comment|/* Check for the i82595TX and i82595FX */
id|old8
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
id|outb
c_func
(paren
op_complement
id|old8
comma
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|8
)paren
)paren
op_eq
id|old8
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;i82595 detected!&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;version
op_assign
id|LAN595
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;version
op_assign
id|LAN595TX
suffix:semicolon
id|outb
c_func
(paren
id|old8
comma
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
id|old9
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|9
)paren
suffix:semicolon
multiline_comment|/*outb(~old9, ioaddr + 9);&n;&t;&t;if (((temp_reg = inb(ioaddr + 9)) == ( (~old9)&amp;0xff) )) {*/
r_if
c_cond
(paren
id|irqMask
op_eq
id|ee_FX_INT2IRQ
)paren
(brace
r_enum
id|iftype
(brace
id|AUI
op_assign
l_int|0
comma
id|BNC
op_assign
l_int|1
comma
id|TPE
op_assign
l_int|2
)brace
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;IrqMask: %#x&bslash;n&quot;
comma
id|irqMask
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;i82595FX detected!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|lp-&gt;version
op_assign
id|LAN595FX
suffix:semicolon
id|outb
c_func
(paren
id|old9
comma
id|ioaddr
op_plus
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;if_port
op_ne
id|TPE
)paren
(brace
multiline_comment|/* Hopefully, this will fix the&n;&t;&t;&t;&t;&t;&t;&t;problem of using Pentiums and&n;&t;&t;&t;&t;&t;&t;&t;pro/10 w/ BNC. */
id|eepro_sw2bank2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG13
)paren
suffix:semicolon
multiline_comment|/* disable the full duplex mode since it is not&n;&t;&t;&t;&t;applicable with the 10Base2 cable. */
id|outb
c_func
(paren
id|temp_reg
op_amp
op_complement
(paren
id|FDX
op_or
id|A_N_ENABLE
)paren
comma
id|REG13
)paren
suffix:semicolon
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 0 now */
)brace
)brace
r_else
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;temp_reg: %#x  ~old9: %#x&bslash;n&quot;
comma
id|temp_reg
comma
(paren
(paren
op_complement
id|old9
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;i82595TX detected!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|eepro_sel_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
suffix:semicolon
id|lp-&gt;tx_last
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting eepro_open routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* enabling rx */
id|eepro_en_rx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eepro_tx_timeout
r_static
r_void
id|eepro_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* if (net_debug &gt; 1) */
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* This is not a duplicate. One message for the console, &n;&t;   one for the the log file  */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
id|eepro_complete_selreset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
DECL|function|eepro_send_packet
r_static
r_int
id|eepro_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: entering eepro_send_packet routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|hardware_send_packet
c_func
(paren
id|dev
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* You might need to clean up and record Tx statistics here. */
multiline_comment|/* lp-&gt;stats.tx_aborted_errors++; */
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting eepro_send_packet routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;The typical workload of the driver:&n;&t;Handle the network interface interrupts. */
r_static
r_void
DECL|function|eepro_interrupt
id|eepro_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
multiline_comment|/* (struct net_device *)(irq2dev_map[irq]);*/
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;eepro_interrupt(): irq %d for unknown device.&bslash;&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: entering eepro_interrupt routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|STATUS_REG
)paren
)paren
op_amp
l_int|0x06
)paren
op_logical_and
(paren
id|boguscount
op_decrement
)paren
)paren
(brace
r_switch
c_cond
(paren
id|status
op_amp
(paren
id|RX_INT
op_or
id|TX_INT
)paren
)paren
(brace
r_case
(paren
id|RX_INT
op_or
id|TX_INT
)paren
suffix:colon
id|eepro_ack_rxtx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_INT
suffix:colon
id|eepro_ack_rx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TX_INT
suffix:colon
id|eepro_ack_tx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RX_INT
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: packet received interrupt.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Get the received packets */
id|eepro_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TX_INT
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: packet transmit interrupt.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Process the status of transmitted packets */
id|eepro_transmit_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting eepro_interrupt routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|eepro_close
r_static
r_int
id|eepro_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|temp_reg
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|eepro_sw2bank1
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 1 */
multiline_comment|/* Disable the physical interrupt line. */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0x7f
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
multiline_comment|/* Flush the Tx and disable Rx. */
id|outb
c_func
(paren
id|STOP_RCV_CMD
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
(paren
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
id|lp-&gt;tx_last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mask all the interrupts. */
id|eepro_dis_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|eepro_clear_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Reset the 82595 */
id|eepro_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* release the interrupt */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef irq2dev_map
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Update the statistics here. What statistics? */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|eepro_get_stats
id|eepro_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|mode
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_ALLMULTI
op_or
id|IFF_PROMISC
)paren
op_logical_or
id|dev-&gt;mc_count
OG
l_int|63
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We must make the kernel realise we had to move&n;&t;&t; *&t;into promisc mode or we start all out war on&n;&t;&t; *&t;the cable. If it was a promisc request the&n;&t;&t; *&t;flag is already set. If not we assert it.&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|eepro_sw2bank2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
op_or
id|PRMSC_Mode
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* writing reg. 3 to complete the update */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Return to BANK 0 now */
id|printk
c_func
(paren
l_string|&quot;%s: promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
op_eq
l_int|0
)paren
(brace
id|eepro_sw2bank2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
op_amp
l_int|0xd6
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
multiline_comment|/* Turn off Multi-IA and PRMSC_Mode bits */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* writing reg. 3 to complete the update */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Return to BANK 0 now */
)brace
r_else
(brace
r_int
r_int
id|status
comma
op_star
id|eaddrs
suffix:semicolon
r_int
id|i
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Disable RX and TX interrupts.  Necessary to avoid&n;&t;&t;   corruption of the HOST_ADDRESS_REG by interrupt&n;&t;&t;   service routines. */
id|eepro_dis_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|eepro_sw2bank2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
op_or
id|Multi_IA
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* writing reg. 3 to complete the update */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Return to BANK 0 now */
id|outw
c_func
(paren
id|lp-&gt;tx_end
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_SETUP
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|6
op_star
(paren
id|dev-&gt;mc_count
op_plus
l_int|1
)paren
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eaddrs
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
id|outw
c_func
(paren
op_star
id|eaddrs
op_increment
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
op_star
id|eaddrs
op_increment
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
op_star
id|eaddrs
op_increment
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
id|eaddrs
op_assign
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
suffix:semicolon
id|outw
c_func
(paren
id|eaddrs
(braket
l_int|0
)braket
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|eaddrs
(braket
l_int|1
)braket
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|eaddrs
(braket
l_int|2
)braket
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_end
comma
id|ioaddr
op_plus
id|xmt_bar
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MC_SETUP
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Update the transmit queue */
id|i
op_assign
id|lp-&gt;tx_end
op_plus
id|XMT_HEADER
op_plus
l_int|6
op_star
(paren
id|dev-&gt;mc_count
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_start
op_ne
id|lp-&gt;tx_end
)paren
(brace
multiline_comment|/* update the next address and the chain bit in the &n;&t;&t;&t;   last packet */
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_CHAIN
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_COUNT
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status
op_or
id|CHAIN_BIT
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|lp-&gt;tx_end
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Acknowledge that the MC setup is done */
r_do
(brace
multiline_comment|/* We should be doing this in the eepro_interrupt()! */
id|SLOW_DOWN
suffix:semicolon
id|SLOW_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|STATUS_REG
)paren
op_amp
l_int|0x08
)paren
(brace
id|i
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x08
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* command ABORTed */
id|printk
c_func
(paren
l_string|&quot;%s: multicast setup failed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x03
)paren
(brace
multiline_comment|/* MC-Done */
id|printk
c_func
(paren
l_string|&quot;%s: set Rx mode to %d address%s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;mc_count
comma
id|dev-&gt;mc_count
OG
l_int|1
ques
c_cond
l_string|&quot;es&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_increment
id|boguscount
OL
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Re-enable RX and TX interrupts */
id|eepro_en_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
id|eepro_complete_selreset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* The horrible routine to read a word from the serial EEPROM. */
multiline_comment|/* IMPORTANT - the 82595 will be set to Bank 0 after the eeprom is read */
multiline_comment|/* The delay between EEPROM clock transitions. */
DECL|macro|eeprom_delay
mdefine_line|#define eeprom_delay() { udelay(40); }
DECL|macro|EE_READ_CMD
mdefine_line|#define EE_READ_CMD (6 &lt;&lt; 6)
r_int
DECL|function|read_eeprom
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|ee_addr
op_assign
id|ioaddr
op_plus
id|eeprom_reg
suffix:semicolon
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|read_cmd
op_assign
id|location
op_or
id|EE_READ_CMD
suffix:semicolon
r_int
id|ctrl_val
op_assign
id|EECS
suffix:semicolon
multiline_comment|/* XXXX - this is not the final version. We must test this on other&n;&t; *&t;  boards other than eepro10. I think that it won&squot;t let other&n;&t; *&t;  boards to fail. (aris)&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
(brace
id|eepro_sw2bank1
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
)brace
id|eepro_sw2bank2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* Shift the read command bits out. */
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|outval
op_assign
(paren
id|read_cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|ctrl_val
op_or
id|EEDI
suffix:colon
id|ctrl_val
suffix:semicolon
id|outb
c_func
(paren
id|outval
comma
id|ee_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outval
op_or
id|EESK
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* EEPROM clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outval
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* Finish EEPROM a clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outb
c_func
(paren
id|ctrl_val
op_or
id|EESK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|inb
c_func
(paren
id|ee_addr
)paren
op_amp
id|EEDO
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate the EEPROM access. */
id|ctrl_val
op_and_assign
op_complement
id|EECS
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
op_or
id|EESK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|hardware_send_packet
id|hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
comma
id|tx_available
comma
id|last
comma
id|end
comma
id|boguscount
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: entering hardware_send_packet routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|boguscount
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* Disable RX and TX interrupts.  Necessary to avoid&n;&t;&t;corruption of the HOST_ADDRESS_REG by interrupt&n;&t;&t;service routines. */
id|eepro_dis_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* determine how much of the transmit buffer space is available */
r_if
c_cond
(paren
id|lp-&gt;tx_end
OG
id|lp-&gt;tx_start
)paren
id|tx_available
op_assign
id|XMT_RAM
op_minus
(paren
id|lp-&gt;tx_end
op_minus
id|lp-&gt;tx_start
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lp-&gt;tx_end
OL
id|lp-&gt;tx_start
)paren
id|tx_available
op_assign
id|lp-&gt;tx_start
op_minus
id|lp-&gt;tx_end
suffix:semicolon
r_else
id|tx_available
op_assign
id|XMT_RAM
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|2
op_star
id|XMT_HEADER
)paren
op_ge
id|tx_available
)paren
multiline_comment|/* No space available ??? */
(brace
id|eepro_transmit_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clean up the transmiting queue */
multiline_comment|/* Enable RX and TX interrupts */
id|eepro_en_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|last
op_assign
id|lp-&gt;tx_end
suffix:semicolon
id|end
op_assign
id|last
op_plus
(paren
(paren
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
id|XMT_HEADER
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ge
(paren
id|XMT_UPPER_LIMIT
op_lshift
l_int|8
)paren
)paren
(brace
multiline_comment|/* the transmit buffer is wrapped around */
r_if
c_cond
(paren
(paren
(paren
id|XMT_UPPER_LIMIT
op_lshift
l_int|8
)paren
op_minus
id|last
)paren
op_le
id|XMT_HEADER
)paren
(brace
multiline_comment|/* Arrrr!!!, must keep the xmt header together,&n;&t;&t;&t;&t;several days were lost to chase this one down. */
id|last
op_assign
(paren
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
id|end
op_assign
id|last
op_plus
(paren
(paren
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
id|XMT_HEADER
suffix:semicolon
)brace
r_else
id|end
op_assign
(paren
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
)paren
op_plus
(paren
id|end
op_minus
(paren
id|XMT_UPPER_LIMIT
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|last
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|XMT_CMD
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|end
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|length
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;version
op_eq
id|LAN595
)paren
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
comma
id|buf
comma
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* LAN595TX or LAN595FX, capable of 32-bit I/O processing */
r_int
r_int
id|temp
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_or
id|IO_32_BIT
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outsl
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT_32_BIT
comma
id|buf
comma
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_amp
op_complement
(paren
id|IO_32_BIT
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
)brace
multiline_comment|/* A dummy read to flush the DRAM write pipeline */
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_start
op_eq
id|lp-&gt;tx_end
)paren
(brace
id|outw
c_func
(paren
id|last
comma
id|ioaddr
op_plus
id|xmt_bar
)paren
suffix:semicolon
id|outb
c_func
(paren
id|XMT_CMD
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|last
suffix:semicolon
multiline_comment|/* I don&squot;t like to change tx_start here */
)brace
r_else
(brace
multiline_comment|/* update the next address and the chain bit in the &n;&t;&t;&t;last packet */
r_if
c_cond
(paren
id|lp-&gt;tx_end
op_ne
id|last
)paren
(brace
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_CHAIN
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|last
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_COUNT
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status
op_or
id|CHAIN_BIT
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
multiline_comment|/* Continue the transmit command */
id|outb
c_func
(paren
id|RESUME_XMT_CMD
comma
id|ioaddr
)paren
suffix:semicolon
)brace
id|lp-&gt;tx_last
op_assign
id|last
suffix:semicolon
id|lp-&gt;tx_end
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* now we are serializing tx. queue won&squot;t come back until&n;&t;&t; * the tx interrupt&n;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Enable RX and TX interrupts */
id|eepro_en_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting hardware_send_packet routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting hardware_send_packet routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|eepro_rx
id|eepro_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|20
suffix:semicolon
r_int
id|rcv_car
op_assign
id|lp-&gt;rx_start
suffix:semicolon
r_int
id|rcv_event
comma
id|rcv_status
comma
id|rcv_next_frame
comma
id|rcv_size
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: entering eepro_rx routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Set the read pointer to the start of the RCV */
id|outw
c_func
(paren
id|rcv_car
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|rcv_event
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rcv_event
op_eq
id|RCV_DONE
)paren
(brace
id|rcv_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|rcv_next_frame
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|rcv_size
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rcv_status
op_amp
(paren
id|RX_OK
op_or
id|RX_ERROR
)paren
)paren
op_eq
id|RX_OK
)paren
(brace
multiline_comment|/* Malloc up new buffer. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|rcv_size
suffix:semicolon
id|rcv_size
op_and_assign
l_int|0x3fff
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|rcv_size
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;version
op_eq
id|LAN595
)paren
id|insw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|rcv_size
)paren
comma
(paren
id|rcv_size
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* LAN595TX or LAN595FX, capable of 32-bit I/O processing */
r_int
r_int
id|temp
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_or
id|IO_32_BIT
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|insl
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT_32_BIT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|rcv_size
)paren
comma
(paren
id|rcv_size
op_plus
l_int|3
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_amp
op_complement
(paren
id|IO_32_BIT
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not sure will ever reach here, &n;&t;&t;&t;I set the 595 to discard bad received frames */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x0100
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x0400
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x0800
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: event = %#x, status = %#x, next = %#x, size = %#x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rcv_event
comma
id|rcv_status
comma
id|rcv_next_frame
comma
id|rcv_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x1000
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscount
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|rcv_car
op_assign
id|lp-&gt;rx_start
op_plus
id|RCV_HEADER
op_plus
id|rcv_size
suffix:semicolon
id|lp-&gt;rx_start
op_assign
id|rcv_next_frame
suffix:semicolon
id|outw
c_func
(paren
id|rcv_next_frame
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|rcv_event
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rcv_car
op_eq
l_int|0
)paren
id|rcv_car
op_assign
(paren
id|RCV_UPPER_LIMIT
op_lshift
l_int|8
)paren
op_or
l_int|0xff
suffix:semicolon
id|outw
c_func
(paren
id|rcv_car
op_minus
l_int|1
comma
id|ioaddr
op_plus
id|RCV_STOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting eepro_rx routine.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|eepro_transmit_interrupt
id|eepro_transmit_interrupt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|20
suffix:semicolon
r_int
id|xmt_status
suffix:semicolon
multiline_comment|/*&n;&t;if (dev-&gt;tbusy == 0) {&n;&t;&t;printk(&quot;%s: transmit_interrupt called with tbusy = 0 ??&bslash;n&quot;,&n;&t;&t;&t;dev-&gt;name);&n;&t;&t;printk(KERN_DEBUG &quot;%s: transmit_interrupt called with tbusy = 0 ??&bslash;n&quot;,&n;&t;&t;&t;dev-&gt;name);&n;&t;}&n;&t;*/
r_while
c_loop
(paren
id|lp-&gt;tx_start
op_ne
id|lp-&gt;tx_end
op_logical_and
id|boguscount
)paren
(brace
id|outw
c_func
(paren
id|lp-&gt;tx_start
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|xmt_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xmt_status
op_amp
id|TX_DONE_BIT
)paren
op_eq
l_int|0
)paren
(brace
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|boguscount
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|xmt_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
(brace
id|lp-&gt;tx_start
op_assign
(paren
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
id|lp-&gt;tx_end
op_assign
id|lp-&gt;tx_start
suffix:semicolon
multiline_comment|/* yeah, black magic :( */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|eepro_en_int
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* disabling rx */
id|eepro_dis_rx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* enabling rx */
id|eepro_en_rx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmt_status
op_amp
l_int|0x2000
)paren
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_else
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|xmt_status
op_amp
l_int|0x0400
)paren
(brace
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: carrier error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: XMT status = %#x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|xmt_status
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: XMT status = %#x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|xmt_status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: XMT status = %#x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|xmt_status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;eepro
op_eq
id|LAN595FX_10ISA
)paren
(brace
multiline_comment|/* Try to restart the adaptor. */
multiline_comment|/* We are supposed to wait for 2 us after a SEL_RESET */
id|eepro_sel_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* first enable interrupts */
id|eepro_sw2bank0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ALL_MASK
op_amp
op_complement
(paren
id|RX_INT
op_or
id|TX_INT
)paren
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* enabling rx */
id|eepro_en_rx
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|xmt_status
op_amp
l_int|0x000f
)paren
(brace
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|xmt_status
op_amp
l_int|0x000f
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|xmt_status
op_amp
l_int|0x0040
)paren
op_eq
l_int|0x0
)paren
(brace
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
)brace
id|boguscount
op_decrement
suffix:semicolon
)brace
multiline_comment|/* if it reached here then it&squot;s probable that the adapter won&squot;t&n;&t; * interrupt again for tx. in other words: tx timeout what will take&n;&t; * a lot of time to happen, so we&squot;ll do a complete selreset.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|boguscount
)paren
id|eepro_complete_selreset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
DECL|macro|MAX_EEPRO
mdefine_line|#define MAX_EEPRO 8
DECL|variable|dev_eepro
r_static
r_struct
id|net_device
id|dev_eepro
(braket
id|MAX_EEPRO
)braket
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
(braket
id|MAX_EEPRO
)braket
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|MAX_EEPRO
)braket
suffix:semicolon
DECL|variable|mem
r_static
r_int
id|mem
(braket
id|MAX_EEPRO
)braket
op_assign
(brace
multiline_comment|/* Size of the rx buffer in KB */
(braket
l_int|0
dot
dot
dot
id|MAX_EEPRO
op_minus
l_int|1
)braket
op_assign
id|RCV_DEFAULT_RAM
op_div
l_int|1024
)brace
suffix:semicolon
DECL|variable|autodetect
r_static
r_int
id|autodetect
suffix:semicolon
DECL|variable|n_eepro
r_static
r_int
id|n_eepro
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For linux 2.1.xx */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Pascal Dupuis &lt;dupuis@lei.ucl.ac.be&gt; for the 2.1 stuff (locking,...)&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Intel i82595 ISA EtherExpressPro10/10+ driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_EEPRO
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_EEPRO
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mem
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_EEPRO
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|autodetect
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|1
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|io
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|autodetect
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eepro_init_module: Probe is very dangerous in ISA boards!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eepro_init_module: Please add &bslash;&quot;autodetect=1&bslash;&quot; to force probe&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|autodetect
)paren
(brace
multiline_comment|/* if autodetect is set then we must force detection */
id|io
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eepro_init_module: Auto-detecting boards (May God protect us...)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_EEPRO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net_device
op_star
id|d
op_assign
op_amp
id|dev_eepro
(braket
id|n_eepro
)braket
suffix:semicolon
id|d-&gt;mem_end
op_assign
id|mem
(braket
id|n_eepro
)braket
suffix:semicolon
id|d-&gt;base_addr
op_assign
id|io
(braket
l_int|0
)braket
suffix:semicolon
id|d-&gt;irq
op_assign
id|irq
(braket
id|n_eepro
)braket
suffix:semicolon
id|d-&gt;init
op_assign
id|eepro_probe
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|d
)paren
op_eq
l_int|0
)paren
id|n_eepro
op_increment
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_return
id|n_eepro
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_eepro
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net_device
op_star
id|d
op_assign
op_amp
id|dev_eepro
(braket
id|i
)braket
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|d
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|d-&gt;priv
)paren
suffix:semicolon
id|d-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If we don&squot;t do this, we can&squot;t re-insmod it later. */
id|release_region
c_func
(paren
id|d-&gt;base_addr
comma
id|EEPRO_IO_EXTENT
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
eof
