multiline_comment|/* eepro.c: Intel EtherExpress Pro/10 device driver for Linux. */
multiline_comment|/*&n;&t;Written 1994, 1995,1996 by Bao C. Ha.&n;&n;&t;Copyright (C) 1994, 1995,1996 by Bao C. Ha.&n;&n;&t;This software may be used and distributed&n;&t;according to the terms of the GNU Public License,&n;&t;incorporated herein by reference.&n;&n;&t;The author may be reached at bao@saigon.async.com &n;&t;or 418 Hastings Place, Martinez, GA 30907.&n;&n;&t;Things remaining to do:&n;&t;Better record keeping of errors.&n;&t;Eliminate transmit interrupt to reduce overhead.&n;&t;Implement &quot;concurrent processing&quot;. I won&squot;t be doing it!&n;&t;Allow changes to the partition of the transmit and receive&n;&t;buffers, currently the ratio is 3:1 of receive to transmit&n;&t;buffer ratio.  &n;&n;&t;Bugs:&n;&n;&t;If you have a problem of not detecting the 82595 during a&n;&t;reboot (warm reset), disable the FLASH memory should fix it.&n;&t;This is a compatibility hardware problem.&n;&n;&t;Versions:&n;&n;&t;0.08&t;Implement 32-bit I/O for the 82595TX and 82595FX&n;&t;&t;based lan cards.  Disable full-duplex mode if TPE&n;&t;&t;is not used.  (BCH, 4/8/96)&n;&n;&t;0.07a&t;Fix a stat report which counts every packet as a&n;&t;&t;heart-beat failure. (BCH, 6/3/95)&n;&n;&t;0.07&t;Modified to support all other 82595-based lan cards.  &n;&t;&t;The IRQ vector of the EtherExpress Pro will be set&n;&t;&t;according to the value saved in the EEPROM.  For other&n;&t;&t;cards, I will do autoirq_request() to grab the next&n;&t;&t;available interrupt vector. (BCH, 3/17/95)&n;&n;&t;0.06a,b&t;Interim released.  Minor changes in the comments and&n;&t;&t;print out format. (BCH, 3/9/95 and 3/14/95)&n;&n;&t;0.06&t;First stable release that I am comfortable with. (BCH,&n;&t;&t;3/2/95)&t;&n;&n;&t;0.05&t;Complete testing of multicast. (BCH, 2/23/95)&t;&n;&n;&t;0.04&t;Adding multicast support. (BCH, 2/14/95)&t;&n;&n;&t;0.03&t;First widely alpha release for public testing. &n;&t;&t;(BCH, 2/14/95)&t;&n;&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;eepro.c: v0.08 4/8/96 Bao C. Ha (bao.ha@srs.gov)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n;  Sources:&n;&n;&t;This driver wouldn&squot;t have been written without the availability &n;&t;of the Crynwr&squot;s Lan595 driver source code.  It helps me to &n;&t;familiarize with the 82595 chipset while waiting for the Intel &n;&t;documentation.  I also learned how to detect the 82595 using &n;&t;the packet driver&squot;s technique.&n;&n;&t;This driver is written by cutting and pasting the skeleton.c driver&n;&t;provided by Donald Becker.  I also borrowed the EEPROM routine from&n;&t;Donald Becker&squot;s 82586 driver.&n;&n;&t;Datasheet for the Intel 82595 (including the TX and FX version). It &n;&t;provides just enough info that the casual reader might think that it &n;&t;documents the i82595.&n;&n;&t;The User Manual for the 82595.  It provides a lot of the missing&n;&t;information.&n;&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
multiline_comment|/* First, a few definitions that the brave might change. */
multiline_comment|/* A zero-terminated list of I/O addresses to be probed. */
DECL|variable|eepro_portlist
r_static
r_int
r_int
id|eepro_portlist
(braket
)braket
op_assign
(brace
l_int|0x200
comma
l_int|0x240
comma
l_int|0x280
comma
l_int|0x2C0
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|EEPRO_IO_EXTENT
mdefine_line|#define EEPRO_IO_EXTENT&t;16
multiline_comment|/* Different 82595 chips */
DECL|macro|LAN595
mdefine_line|#define&t;LAN595&t;&t;0
DECL|macro|LAN595TX
mdefine_line|#define&t;LAN595TX&t;1
DECL|macro|LAN595FX
mdefine_line|#define&t;LAN595FX&t;2
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|eepro_local
r_struct
id|eepro_local
(brace
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
DECL|member|rx_start
r_int
id|rx_start
suffix:semicolon
DECL|member|tx_start
r_int
id|tx_start
suffix:semicolon
multiline_comment|/* start of the transmit chain */
DECL|member|tx_last
r_int
id|tx_last
suffix:semicolon
multiline_comment|/* pointer to last packet in the transmit chain */
DECL|member|tx_end
r_int
id|tx_end
suffix:semicolon
multiline_comment|/* end of the transmit chain (plus 1) */
DECL|member|eepro
r_int
id|eepro
suffix:semicolon
multiline_comment|/* a flag, TRUE=1 for the EtherExpress Pro/10,&n;&t;&t;&t;   FALSE = 0 for other 82595-based lan cards. */
DECL|member|version
r_int
id|version
suffix:semicolon
multiline_comment|/* a flag to indicate if this is a TX or FX&n;&t;&t;&t;&t;   version of the 82595 chip. */
DECL|member|stepping
r_int
id|stepping
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for IDing the board. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x00
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0xaa
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0x00
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|eepro_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eepro_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|eepro_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eepro_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eepro_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|eepro_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eepro_transmit_interrupt
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eepro_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|eepro_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
suffix:semicolon
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_int
id|eepro_grab_irq
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;  &t;&t;&t;Details of the i82595.&n;&n;You will need either the datasheet or the user manual to understand what&n;is going on here.  The 82595 is very different from the 82586, 82593.&n;&n;The receive algorithm in eepro_rx() is just an implementation of the&n;RCV ring structure that the Intel 82595 imposes at the hardware level.&n;The receive buffer is set at 24K, and the transmit buffer is 8K.  I&n;am assuming that the total buffer memory is 32K, which is true for the&n;Intel EtherExpress Pro/10.  If it is less than that on a generic card,&n;the driver will be broken.&n;&n;The transmit algorithm in the hardware_send_packet() is similar to the&n;one in the eepro_rx().  The transmit buffer is a ring linked list.&n;I just queue the next available packet to the end of the list.  In my&n;system, the 82595 is so fast that the list seems to always contain a&n;single packet.  In other systems with faster computers and more congested&n;network traffics, the ring linked list should improve performance by&n;allowing up to 8K worth of packets to be queued.&n;&n;*/
DECL|macro|RAM_SIZE
mdefine_line|#define&t;RAM_SIZE&t;0x8000
DECL|macro|RCV_HEADER
mdefine_line|#define&t;RCV_HEADER&t;8
DECL|macro|RCV_RAM
mdefine_line|#define&t;RCV_RAM&t;&t;0x6000&t;/* 24KB for RCV buffer */
DECL|macro|RCV_LOWER_LIMIT
mdefine_line|#define&t;RCV_LOWER_LIMIT&t;0x00&t;/* 0x0000 */
DECL|macro|RCV_UPPER_LIMIT
mdefine_line|#define&t;RCV_UPPER_LIMIT&t;((RCV_RAM - 2) &gt;&gt; 8)&t;/* 0x5ffe */
DECL|macro|XMT_RAM
mdefine_line|#define&t;XMT_RAM&t;&t;(RAM_SIZE - RCV_RAM)&t;/* 8KB for XMT buffer */
DECL|macro|XMT_LOWER_LIMIT
mdefine_line|#define&t;XMT_LOWER_LIMIT&t;(RCV_RAM &gt;&gt; 8)&t;/* 0x6000 */
DECL|macro|XMT_UPPER_LIMIT
mdefine_line|#define&t;XMT_UPPER_LIMIT&t;((RAM_SIZE - 2) &gt;&gt; 8)&t;/* 0x7ffe */
DECL|macro|XMT_HEADER
mdefine_line|#define&t;XMT_HEADER&t;8
DECL|macro|RCV_DONE
mdefine_line|#define&t;RCV_DONE&t;0x0008
DECL|macro|RX_OK
mdefine_line|#define&t;RX_OK&t;&t;0x2000
DECL|macro|RX_ERROR
mdefine_line|#define&t;RX_ERROR&t;0x0d81
DECL|macro|TX_DONE_BIT
mdefine_line|#define&t;TX_DONE_BIT&t;0x0080
DECL|macro|CHAIN_BIT
mdefine_line|#define&t;CHAIN_BIT&t;0x8000
DECL|macro|XMT_STATUS
mdefine_line|#define&t;XMT_STATUS&t;0x02
DECL|macro|XMT_CHAIN
mdefine_line|#define&t;XMT_CHAIN&t;0x04
DECL|macro|XMT_COUNT
mdefine_line|#define&t;XMT_COUNT&t;0x06
DECL|macro|BANK0_SELECT
mdefine_line|#define&t;BANK0_SELECT&t;0x00&t;&t;
DECL|macro|BANK1_SELECT
mdefine_line|#define&t;BANK1_SELECT&t;0x40&t;&t;
DECL|macro|BANK2_SELECT
mdefine_line|#define&t;BANK2_SELECT&t;0x80&t;&t;
multiline_comment|/* Bank 0 registers */
DECL|macro|COMMAND_REG
mdefine_line|#define&t;COMMAND_REG&t;0x00&t;/* Register 0 */
DECL|macro|MC_SETUP
mdefine_line|#define&t;MC_SETUP&t;0x03
DECL|macro|XMT_CMD
mdefine_line|#define&t;XMT_CMD&t;&t;0x04
DECL|macro|DIAGNOSE_CMD
mdefine_line|#define&t;DIAGNOSE_CMD&t;0x07
DECL|macro|RCV_ENABLE_CMD
mdefine_line|#define&t;RCV_ENABLE_CMD&t;0x08
DECL|macro|RCV_DISABLE_CMD
mdefine_line|#define&t;RCV_DISABLE_CMD&t;0x0a
DECL|macro|STOP_RCV_CMD
mdefine_line|#define&t;STOP_RCV_CMD&t;0x0b
DECL|macro|RESET_CMD
mdefine_line|#define&t;RESET_CMD&t;0x0e
DECL|macro|POWER_DOWN_CMD
mdefine_line|#define&t;POWER_DOWN_CMD&t;0x18
DECL|macro|RESUME_XMT_CMD
mdefine_line|#define&t;RESUME_XMT_CMD&t;0x1c
DECL|macro|SEL_RESET_CMD
mdefine_line|#define&t;SEL_RESET_CMD&t;0x1e
DECL|macro|STATUS_REG
mdefine_line|#define&t;STATUS_REG&t;0x01&t;/* Register 1 */
DECL|macro|RX_INT
mdefine_line|#define&t;RX_INT&t;&t;0x02
DECL|macro|TX_INT
mdefine_line|#define&t;TX_INT&t;&t;0x04
DECL|macro|EXEC_STATUS
mdefine_line|#define&t;EXEC_STATUS&t;0x30
DECL|macro|ID_REG
mdefine_line|#define&t;ID_REG&t;&t;0x02&t;/* Register 2&t;*/
DECL|macro|R_ROBIN_BITS
mdefine_line|#define&t;R_ROBIN_BITS&t;0xc0&t;/* round robin counter */
DECL|macro|ID_REG_MASK
mdefine_line|#define&t;ID_REG_MASK&t;0x2c
DECL|macro|ID_REG_SIG
mdefine_line|#define&t;ID_REG_SIG&t;0x24
DECL|macro|AUTO_ENABLE
mdefine_line|#define&t;AUTO_ENABLE&t;0x10
DECL|macro|INT_MASK_REG
mdefine_line|#define&t;INT_MASK_REG&t;0x03&t;/* Register 3&t;*/
DECL|macro|RX_STOP_MASK
mdefine_line|#define&t;RX_STOP_MASK&t;0x01
DECL|macro|RX_MASK
mdefine_line|#define&t;RX_MASK&t;&t;0x02
DECL|macro|TX_MASK
mdefine_line|#define&t;TX_MASK&t;&t;0x04
DECL|macro|EXEC_MASK
mdefine_line|#define&t;EXEC_MASK&t;0x08
DECL|macro|ALL_MASK
mdefine_line|#define&t;ALL_MASK&t;0x0f
DECL|macro|IO_32_BIT
mdefine_line|#define&t;IO_32_BIT&t;0x10
DECL|macro|RCV_BAR
mdefine_line|#define&t;RCV_BAR&t;&t;0x04&t;/* The following are word (16-bit) registers */
DECL|macro|RCV_STOP
mdefine_line|#define&t;RCV_STOP&t;0x06
DECL|macro|XMT_BAR
mdefine_line|#define&t;XMT_BAR&t;&t;0x0a
DECL|macro|HOST_ADDRESS_REG
mdefine_line|#define&t;HOST_ADDRESS_REG&t;0x0c
DECL|macro|IO_PORT
mdefine_line|#define&t;IO_PORT&t;&t;0x0e
DECL|macro|IO_PORT_32_BIT
mdefine_line|#define&t;IO_PORT_32_BIT&t;0x0c
multiline_comment|/* Bank 1 registers */
DECL|macro|REG1
mdefine_line|#define&t;REG1&t;0x01
DECL|macro|WORD_WIDTH
mdefine_line|#define&t;WORD_WIDTH&t;0x02
DECL|macro|INT_ENABLE
mdefine_line|#define&t;INT_ENABLE&t;0x80
DECL|macro|INT_NO_REG
mdefine_line|#define INT_NO_REG&t;0x02
DECL|macro|RCV_LOWER_LIMIT_REG
mdefine_line|#define&t;RCV_LOWER_LIMIT_REG&t;0x08
DECL|macro|RCV_UPPER_LIMIT_REG
mdefine_line|#define&t;RCV_UPPER_LIMIT_REG&t;0x09
DECL|macro|XMT_LOWER_LIMIT_REG
mdefine_line|#define&t;XMT_LOWER_LIMIT_REG&t;0x0a
DECL|macro|XMT_UPPER_LIMIT_REG
mdefine_line|#define&t;XMT_UPPER_LIMIT_REG&t;0x0b
multiline_comment|/* Bank 2 registers */
DECL|macro|XMT_Chain_Int
mdefine_line|#define&t;XMT_Chain_Int&t;0x20&t;/* Interrupt at the end of the transmit chain */
DECL|macro|XMT_Chain_ErrStop
mdefine_line|#define&t;XMT_Chain_ErrStop&t;0x40 /* Interrupt at the end of the chain even if there are errors */
DECL|macro|RCV_Discard_BadFrame
mdefine_line|#define&t;RCV_Discard_BadFrame&t;0x80 /* Throw bad frames away, and continue to receive others */
DECL|macro|REG2
mdefine_line|#define&t;REG2&t;&t;0x02
DECL|macro|PRMSC_Mode
mdefine_line|#define&t;PRMSC_Mode&t;0x01
DECL|macro|Multi_IA
mdefine_line|#define&t;Multi_IA&t;0x20
DECL|macro|REG3
mdefine_line|#define&t;REG3&t;&t;0x03
DECL|macro|TPE_BIT
mdefine_line|#define&t;TPE_BIT&t;&t;0x04
DECL|macro|BNC_BIT
mdefine_line|#define&t;BNC_BIT&t;&t;0x20
DECL|macro|REG13
mdefine_line|#define&t;REG13&t;&t;0x0d
DECL|macro|FDX
mdefine_line|#define&t;FDX&t;&t;0x00
DECL|macro|A_N_ENABLE
mdefine_line|#define&t;A_N_ENABLE&t;0x02
DECL|macro|I_ADD_REG0
mdefine_line|#define&t;I_ADD_REG0&t;0x04
DECL|macro|I_ADD_REG1
mdefine_line|#define&t;I_ADD_REG1&t;0x05
DECL|macro|I_ADD_REG2
mdefine_line|#define&t;I_ADD_REG2&t;0x06
DECL|macro|I_ADD_REG3
mdefine_line|#define&t;I_ADD_REG3&t;0x07
DECL|macro|I_ADD_REG4
mdefine_line|#define&t;I_ADD_REG4&t;0x08
DECL|macro|I_ADD_REG5
mdefine_line|#define&t;I_ADD_REG5&t;0x09
DECL|macro|EEPROM_REG
mdefine_line|#define EEPROM_REG 0x0a
DECL|macro|EESK
mdefine_line|#define EESK 0x01
DECL|macro|EECS
mdefine_line|#define EECS 0x02
DECL|macro|EEDI
mdefine_line|#define EEDI 0x04
DECL|macro|EEDO
mdefine_line|#define EEDO 0x08
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   */
macro_line|#ifdef HAVE_DEVLIST
multiline_comment|/* Support for a alternate probe manager, which will eliminate the&n;   boilerplate below. */
DECL|variable|netcard_drv
r_struct
id|netdev_entry
id|netcard_drv
op_assign
(brace
l_string|&quot;eepro&quot;
comma
id|eepro_probe1
comma
id|EEPRO_IO_EXTENT
comma
id|eepro_portlist
)brace
suffix:semicolon
macro_line|#else
r_int
DECL|function|eepro_probe
id|eepro_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev
ques
c_cond
id|dev-&gt;base_addr
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|eepro_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|eepro_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
id|eepro_portlist
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|EEPRO_IO_EXTENT
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|eepro_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* This is the real probe routine.  Linux has a history of friendly device&n;   probes on the ISA bus.  A good device probes avoids doing writes, and&n;   verifies that the correct device exists and functions.  */
DECL|function|eepro_probe1
r_int
id|eepro_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
r_int
id|station_addr
(braket
l_int|6
)braket
comma
id|id
comma
id|counter
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|eepro
suffix:semicolon
multiline_comment|/* a flag, TRUE=1 for the EtherExpress Pro/10,&n;&t;&t;&t;   FALSE = 0 for other 82595-based lan cards. */
r_const
r_char
op_star
id|ifmap
(braket
)braket
op_assign
(brace
l_string|&quot;AUI&quot;
comma
l_string|&quot;10Base2&quot;
comma
l_string|&quot;10BaseT&quot;
)brace
suffix:semicolon
r_enum
id|iftype
(brace
id|AUI
op_assign
l_int|0
comma
id|BNC
op_assign
l_int|1
comma
id|TPE
op_assign
l_int|2
)brace
suffix:semicolon
multiline_comment|/* Now, we are going to check for the signature of the&n;&t;   ID_REG (register 2 of bank 0) */
r_if
c_cond
(paren
(paren
(paren
id|id
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|ID_REG
)paren
)paren
op_amp
id|ID_REG_MASK
)paren
op_eq
id|ID_REG_SIG
)paren
(brace
multiline_comment|/* We seem to have the 82595 signature, let&squot;s&n;&t;&t;   play with its counter (last 2 bits of&n;&t;&t;   register 2 of bank 0) to be sure. */
id|counter
op_assign
(paren
id|id
op_amp
id|R_ROBIN_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|id
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|ID_REG
)paren
)paren
op_amp
id|R_ROBIN_BITS
)paren
op_eq
(paren
id|counter
op_plus
l_int|0x40
)paren
)paren
(brace
multiline_comment|/* Yes, the 82595 has been found */
multiline_comment|/* Now, get the ethernet hardware address from&n;&t;&t;&t;   the EEPROM */
id|station_addr
(braket
l_int|0
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|2
)paren
suffix:semicolon
id|station_addr
(braket
l_int|1
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|3
)paren
suffix:semicolon
id|station_addr
(braket
l_int|2
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Check the station address for the manufacturer&squot;s code */
r_if
c_cond
(paren
id|station_addr
(braket
l_int|2
)braket
op_ne
l_int|0x00aa
op_logical_or
(paren
id|station_addr
(braket
l_int|1
)braket
op_amp
l_int|0xff00
)paren
op_ne
l_int|0x0000
)paren
(brace
id|eepro
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Intel 82595-based lan card at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|eepro
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Intel EtherExpress Pro/10 at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|station_addr
)paren
(braket
l_int|5
op_minus
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c%02x&quot;
comma
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|id
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_amp
id|TPE_BIT
)paren
id|dev-&gt;if_port
op_assign
id|TPE
suffix:semicolon
r_else
id|dev-&gt;if_port
op_assign
id|BNC
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
op_logical_and
id|eepro
)paren
(brace
id|i
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|i
op_amp
l_int|0x07
)paren
(brace
r_case
l_int|0
suffix:colon
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dev-&gt;irq
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dev-&gt;irq
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|dev-&gt;irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|dev-&gt;irq
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* should never get here !!!!! */
id|printk
c_func
(paren
l_string|&quot; illegal interrupt vector stored in EEPROM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, IRQ %d, %s.&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|ifmap
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|eepro_interrupt
comma
l_int|0
comma
l_string|&quot;eepro&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, %s.&bslash;n&quot;
comma
id|ifmap
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
OG
l_int|0
)paren
id|net_debug
op_assign
id|dev-&gt;mem_start
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|i
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x2000
)paren
multiline_comment|/* bit 13 of EEPROM word 5 */
id|printk
c_func
(paren
l_string|&quot;%s: Concurrent Processing is enabled but not used!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Grab the region so we can find another board if autoIRQ fails. */
id|request_region
c_func
(paren
id|ioaddr
comma
id|EEPRO_IO_EXTENT
comma
l_string|&quot;eepro&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eepro_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eepro_local
)paren
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|eepro_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|eepro_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|eepro_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|eepro_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with&n;&t;&t;&t;   ethernet generic values */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RESET_CMD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* RESET the 82595 */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
(paren
l_string|&quot;EtherExpress Pro probed failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;   */
DECL|variable|irqrmap
r_static
r_char
id|irqrmap
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_minus
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|3
comma
l_int|4
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|function|eepro_grab_irq
r_static
r_int
id|eepro_grab_irq
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|irqlist
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|4
comma
l_int|3
comma
l_int|0
)brace
suffix:semicolon
r_int
op_star
id|irqp
op_assign
id|irqlist
comma
id|temp_reg
comma
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|outb
c_func
(paren
id|BANK1_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 1 now */
multiline_comment|/* Enable the interrupt line. */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_or
id|INT_ENABLE
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 0 now */
multiline_comment|/* clear all interrupts */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Let EXEC event to interrupt */
id|outb
c_func
(paren
id|ALL_MASK
op_amp
op_complement
(paren
id|EXEC_MASK
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
r_do
(brace
id|outb
c_func
(paren
id|BANK1_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 1 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf8
)paren
op_or
id|irqrmap
(braket
op_star
id|irqp
)braket
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
r_if
c_cond
(paren
id|request_irq
(paren
op_star
id|irqp
comma
l_int|NULL
comma
l_int|0
comma
l_string|&quot;bogus&quot;
comma
l_int|NULL
)paren
op_ne
id|EBUSY
)paren
(brace
multiline_comment|/* Twinkle the interrupt, and check if it&squot;s seen */
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DIAGNOSE_CMD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* RESET the 82595 */
r_if
c_cond
(paren
op_star
id|irqp
op_eq
id|autoirq_report
c_func
(paren
l_int|2
)paren
op_logical_and
multiline_comment|/* It&squot;s a good IRQ line */
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
op_assign
op_star
id|irqp
comma
op_amp
id|eepro_interrupt
comma
l_int|0
comma
l_string|&quot;eepro&quot;
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
op_increment
id|irqp
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK1_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 1 */
multiline_comment|/* Disable the physical interrupt line. */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0x7f
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
multiline_comment|/* Mask all the interrupts. */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
r_return
id|dev-&gt;irq
suffix:semicolon
)brace
r_static
r_int
DECL|function|eepro_open
id|eepro_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|temp_reg
comma
id|old8
comma
id|old9
suffix:semicolon
r_int
id|i
comma
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: entering eepro_open routine.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_eq
id|SA_ADDR0
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_eq
id|SA_ADDR1
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_eq
id|SA_ADDR2
)paren
id|lp-&gt;eepro
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Yes, an Intel EtherExpress Pro/10 */
r_else
id|lp-&gt;eepro
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No, it is a generic 82585 lan card */
multiline_comment|/* Get the interrupt vector for the 82595 */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
op_logical_and
id|eepro_grab_irq
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_ne
l_int|0
op_logical_or
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* Initialize the 82595. */
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|EEPROM_REG
)paren
suffix:semicolon
id|lp-&gt;stepping
op_assign
id|temp_reg
op_rshift
l_int|5
suffix:semicolon
multiline_comment|/* Get the stepping number of the 595 */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;The stepping of the 82595 is %d&bslash;n&quot;
comma
id|lp-&gt;stepping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_reg
op_amp
l_int|0x10
)paren
multiline_comment|/* Check the TurnOff Enable bit */
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0xef
comma
id|ioaddr
op_plus
id|EEPROM_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|I_ADD_REG0
op_plus
id|i
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
multiline_comment|/* Setup Transmit Chaining */
id|outb
c_func
(paren
id|temp_reg
op_or
id|XMT_Chain_Int
op_or
id|XMT_Chain_ErrStop
multiline_comment|/* and discard bad RCV frames */
op_or
id|RCV_Discard_BadFrame
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
multiline_comment|/* Match broadcast */
id|outb
c_func
(paren
id|temp_reg
op_or
l_int|0x14
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0x3f
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* clear test mode */
multiline_comment|/* Set the receiving mode */
id|outb
c_func
(paren
id|BANK1_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 1 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|temp_reg
op_amp
l_int|0xf8
)paren
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|INT_NO_REG
)paren
suffix:semicolon
multiline_comment|/* Initialize the RCV and XMT upper and lower limits */
id|outb
c_func
(paren
id|RCV_LOWER_LIMIT
comma
id|ioaddr
op_plus
id|RCV_LOWER_LIMIT_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RCV_UPPER_LIMIT
comma
id|ioaddr
op_plus
id|RCV_UPPER_LIMIT_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|XMT_LOWER_LIMIT
comma
id|ioaddr
op_plus
id|XMT_LOWER_LIMIT_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|XMT_UPPER_LIMIT
comma
id|ioaddr
op_plus
id|XMT_UPPER_LIMIT_REG
)paren
suffix:semicolon
multiline_comment|/* Enable the interrupt line. */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_or
id|INT_ENABLE
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
multiline_comment|/* Let RX and TX events to interrupt */
id|outb
c_func
(paren
id|ALL_MASK
op_amp
op_complement
(paren
id|RX_MASK
op_or
id|TX_MASK
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Initialize RCV */
id|outw
c_func
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
comma
id|ioaddr
op_plus
id|RCV_BAR
)paren
suffix:semicolon
id|lp-&gt;rx_start
op_assign
(paren
id|RCV_LOWER_LIMIT
op_lshift
l_int|8
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|RCV_UPPER_LIMIT
op_lshift
l_int|8
)paren
op_or
l_int|0xfe
comma
id|ioaddr
op_plus
id|RCV_STOP
)paren
suffix:semicolon
multiline_comment|/* Initialize XMT */
id|outw
c_func
(paren
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
comma
id|ioaddr
op_plus
id|XMT_BAR
)paren
suffix:semicolon
multiline_comment|/* Check for the i82595TX and i82595FX */
id|old8
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
id|outb
c_func
(paren
op_complement
id|old8
comma
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|8
)paren
)paren
op_eq
id|old8
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;i82595 detected!&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;version
op_assign
id|LAN595
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;version
op_assign
id|LAN595TX
suffix:semicolon
id|outb
c_func
(paren
id|old8
comma
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
id|old9
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|9
)paren
suffix:semicolon
id|outb
c_func
(paren
op_complement
id|old9
comma
id|ioaddr
op_plus
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|9
)paren
)paren
op_eq
op_complement
id|old9
)paren
(brace
r_enum
id|iftype
(brace
id|AUI
op_assign
l_int|0
comma
id|BNC
op_assign
l_int|1
comma
id|TPE
op_assign
l_int|2
)brace
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;i82595FX detected!&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;version
op_assign
id|LAN595FX
suffix:semicolon
id|outb
c_func
(paren
id|old9
comma
id|ioaddr
op_plus
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;if_port
op_ne
id|TPE
)paren
(brace
multiline_comment|/* Hopefully, this will fix the&n;&t;&t;&t;&t;&t;&t;&t;problem of using Pentiums and&n;&t;&t;&t;&t;&t;&t;&t;pro/10 w/ BNC. */
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG13
)paren
suffix:semicolon
multiline_comment|/* disable the full duplex mode since it is not&n;&t;&t;&t;&t;applicable with the 10Base2 cable. */
id|outb
c_func
(paren
id|temp_reg
op_amp
op_complement
(paren
id|FDX
op_or
id|A_N_ENABLE
)paren
comma
id|REG13
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 0 now */
)brace
)brace
r_else
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;i82595TX detected!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|SEL_RESET_CMD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* We are supposed to wait for 2 us after a SEL_RESET */
id|SLOW_DOWN_IO
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
id|XMT_LOWER_LIMIT
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* or = RCV_RAM */
id|lp-&gt;tx_last
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: exiting eepro_open routine.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RCV_ENABLE_CMD
comma
id|ioaddr
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|eepro_send_packet
id|eepro_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: entering eepro_send_packet routine.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|outb
c_func
(paren
id|SEL_RESET_CMD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* We are supposed to wait for 2 us after a SEL_RESET */
id|SLOW_DOWN_IO
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
multiline_comment|/* Do I also need to flush the transmit buffers here? YES? */
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
id|RCV_RAM
suffix:semicolon
id|lp-&gt;tx_last
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|outb
c_func
(paren
id|RCV_ENABLE_CMD
comma
id|ioaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* If some higher layer thinks we&squot;ve missed an tx-done interrupt&n;&t;   we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;&t;   itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
(brace
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
id|hardware_send_packet
c_func
(paren
id|dev
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* You might need to clean up and record Tx statistics here. */
multiline_comment|/* lp-&gt;stats.tx_aborted_errors++; */
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: exiting eepro_send_packet routine.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;The typical workload of the driver:&n;&t;Handle the network interface interrupts. */
r_static
r_void
DECL|function|eepro_interrupt
id|eepro_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: entering eepro_interrupt routine.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;eepro_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_INT
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: packet received interrupt.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Acknowledge the RX_INT */
id|outb
c_func
(paren
id|RX_INT
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Get the received packets */
id|eepro_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|TX_INT
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: packet transmit interrupt.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Acknowledge the TX_INT */
id|outb
c_func
(paren
id|TX_INT
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Process the status of transmitted packets */
id|eepro_transmit_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
op_increment
id|boguscount
OL
l_int|10
)paren
op_logical_and
(paren
id|status
op_amp
l_int|0x06
)paren
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: exiting eepro_interrupt routine.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|eepro_close
id|eepro_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|temp_reg
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|BANK1_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 1 */
multiline_comment|/* Disable the physical interrupt line. */
id|temp_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp_reg
op_amp
l_int|0x7f
comma
id|ioaddr
op_plus
id|REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Switch back to Bank 0 */
multiline_comment|/* Flush the Tx and disable Rx. */
id|outb
c_func
(paren
id|STOP_RCV_CMD
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
id|RCV_RAM
suffix:semicolon
id|lp-&gt;tx_last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mask all the interrupts. */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Reset the 82595 */
id|outb
c_func
(paren
id|RESET_CMD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* release the interrupt */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Update the statistics here. What statistics? */
multiline_comment|/* We are supposed to wait for 200 us after a RESET */
id|SLOW_DOWN_IO
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
multiline_comment|/* May not be enough? */
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|enet_statistics
op_star
DECL|function|eepro_get_stats
id|eepro_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|mode
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_ALLMULTI
op_or
id|IFF_PROMISC
)paren
op_logical_or
id|dev-&gt;mc_count
OG
l_int|63
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We must make the kernel realise we had to move&n;&t;&t; *&t;into promisc mode or we start all out war on&n;&t;&t; *&t;the cable. If it was a promisc rewquest the&n;&t;&t; *&t;flag is already set. If not we assert it.&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
op_or
id|PRMSC_Mode
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* writing reg. 3 to complete the update */
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Return to BANK 0 now */
id|printk
c_func
(paren
l_string|&quot;%s: promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
op_eq
l_int|0
)paren
(brace
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
op_amp
l_int|0xd6
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
multiline_comment|/* Turn off Multi-IA and PRMSC_Mode bits */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* writing reg. 3 to complete the update */
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Return to BANK 0 now */
)brace
r_else
(brace
r_int
r_int
id|status
comma
op_star
id|eaddrs
suffix:semicolon
r_int
id|i
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Disable RX and TX interrupts.  Neccessary to avoid&n;&t;&t;   corruption of the HOST_ADDRESS_REG by interrupt&n;&t;&t;   service routines. */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* be CAREFUL, BANK 2 now */
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
op_or
id|Multi_IA
comma
id|ioaddr
op_plus
id|REG2
)paren
suffix:semicolon
id|mode
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|ioaddr
op_plus
id|REG3
)paren
suffix:semicolon
multiline_comment|/* writing reg. 3 to complete the update */
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Return to BANK 0 now */
id|outw
c_func
(paren
id|lp-&gt;tx_end
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_SETUP
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|6
op_star
(paren
id|dev-&gt;mc_count
op_plus
l_int|1
)paren
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eaddrs
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
id|outw
c_func
(paren
op_star
id|eaddrs
op_increment
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
op_star
id|eaddrs
op_increment
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
op_star
id|eaddrs
op_increment
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
id|eaddrs
op_assign
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
suffix:semicolon
id|outw
c_func
(paren
id|eaddrs
(braket
l_int|0
)braket
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|eaddrs
(braket
l_int|1
)braket
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|eaddrs
(braket
l_int|2
)braket
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_end
comma
id|ioaddr
op_plus
id|XMT_BAR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MC_SETUP
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Update the transmit queue */
id|i
op_assign
id|lp-&gt;tx_end
op_plus
id|XMT_HEADER
op_plus
l_int|6
op_star
(paren
id|dev-&gt;mc_count
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_start
op_ne
id|lp-&gt;tx_end
)paren
(brace
multiline_comment|/* update the next address and the chain bit in the &n;&t;&t;&t;   last packet */
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_CHAIN
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_COUNT
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status
op_or
id|CHAIN_BIT
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|lp-&gt;tx_end
op_assign
id|i
suffix:semicolon
)brace
r_else
id|lp-&gt;tx_start
op_assign
id|lp-&gt;tx_end
op_assign
id|i
suffix:semicolon
multiline_comment|/* Acknowledge that the MC setup is done */
r_do
(brace
multiline_comment|/* We should be doing this in the eepro_interrupt()! */
id|SLOW_DOWN_IO
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|STATUS_REG
)paren
op_amp
l_int|0x08
)paren
(brace
id|i
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x08
comma
id|ioaddr
op_plus
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* command ABORTed */
id|printk
c_func
(paren
l_string|&quot;%s: multicast setup failed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x03
)paren
(brace
multiline_comment|/* MC-Done */
id|printk
c_func
(paren
l_string|&quot;%s: set Rx mode to %d addresses.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;mc_count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_increment
id|boguscount
OL
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Re-enable RX and TX interrupts */
id|outb
c_func
(paren
id|ALL_MASK
op_amp
op_complement
(paren
id|RX_MASK
op_or
id|TX_MASK
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|RCV_ENABLE_CMD
comma
id|ioaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* The horrible routine to read a word from the serial EEPROM. */
multiline_comment|/* IMPORTANT - the 82595 will be set to Bank 0 after the eeprom is read */
multiline_comment|/* The delay between EEPROM clock transitions. */
DECL|macro|eeprom_delay
mdefine_line|#define eeprom_delay()&t;{ int _i = 40; while (--_i &gt; 0) { __SLOW_DOWN_IO; }}
DECL|macro|EE_READ_CMD
mdefine_line|#define EE_READ_CMD (6 &lt;&lt; 6)
r_int
DECL|function|read_eeprom
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|ee_addr
op_assign
id|ioaddr
op_plus
id|EEPROM_REG
suffix:semicolon
r_int
id|read_cmd
op_assign
id|location
op_or
id|EE_READ_CMD
suffix:semicolon
r_int
id|ctrl_val
op_assign
id|EECS
suffix:semicolon
id|outb
c_func
(paren
id|BANK2_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* Shift the read command bits out. */
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|outval
op_assign
(paren
id|read_cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|ctrl_val
op_or
id|EEDI
suffix:colon
id|ctrl_val
suffix:semicolon
id|outb
c_func
(paren
id|outval
comma
id|ee_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outval
op_or
id|EESK
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* EEPROM clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outval
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* Finish EEPROM a clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outb
c_func
(paren
id|ctrl_val
op_or
id|EESK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|inb
c_func
(paren
id|ee_addr
)paren
op_amp
id|EEDO
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate the EEPROM access. */
id|ctrl_val
op_and_assign
op_complement
id|EECS
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
op_or
id|EESK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|BANK0_SELECT
comma
id|ioaddr
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|hardware_send_packet
id|hardware_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
comma
id|tx_available
comma
id|last
comma
id|end
comma
id|boguscount
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: entering hardware_send_packet routine.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|boguscount
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* determine how much of the transmit buffer space is available */
r_if
c_cond
(paren
id|lp-&gt;tx_end
OG
id|lp-&gt;tx_start
)paren
id|tx_available
op_assign
id|XMT_RAM
op_minus
(paren
id|lp-&gt;tx_end
op_minus
id|lp-&gt;tx_start
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lp-&gt;tx_end
OL
id|lp-&gt;tx_start
)paren
id|tx_available
op_assign
id|lp-&gt;tx_start
op_minus
id|lp-&gt;tx_end
suffix:semicolon
r_else
id|tx_available
op_assign
id|XMT_RAM
suffix:semicolon
multiline_comment|/* Disable RX and TX interrupts.  Neccessary to avoid&n;&t;&t;   corruption of the HOST_ADDRESS_REG by interrupt&n;&t;&t;   service routines. */
id|outb
c_func
(paren
id|ALL_MASK
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|2
op_star
id|XMT_HEADER
)paren
op_ge
id|tx_available
)paren
multiline_comment|/* No space available ??? */
r_continue
suffix:semicolon
id|last
op_assign
id|lp-&gt;tx_end
suffix:semicolon
id|end
op_assign
id|last
op_plus
(paren
(paren
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
id|XMT_HEADER
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ge
id|RAM_SIZE
)paren
(brace
multiline_comment|/* the transmit buffer is wrapped around */
r_if
c_cond
(paren
(paren
id|RAM_SIZE
op_minus
id|last
)paren
op_le
id|XMT_HEADER
)paren
(brace
multiline_comment|/* Arrrr!!!, must keep the xmt header together,&n;&t;&t;&t;  several days were lost to chase this one down. */
id|last
op_assign
id|RCV_RAM
suffix:semicolon
id|end
op_assign
id|last
op_plus
(paren
(paren
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
op_lshift
l_int|1
)paren
op_plus
id|XMT_HEADER
suffix:semicolon
)brace
r_else
id|end
op_assign
id|RCV_RAM
op_plus
(paren
id|end
op_minus
id|RAM_SIZE
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|last
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|XMT_CMD
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|end
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|length
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;version
op_eq
id|LAN595
)paren
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
comma
id|buf
comma
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* LAN595TX or LAN595FX, capable of 32-bit I/O processing */
r_int
r_int
id|temp
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_or
id|IO_32_BIT
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outsl
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT_32_BIT
comma
id|buf
comma
(paren
id|length
op_plus
l_int|3
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_amp
op_complement
(paren
id|IO_32_BIT
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;tx_start
op_ne
id|lp-&gt;tx_end
)paren
(brace
multiline_comment|/* update the next address and the chain bit in the &n;&t;&t;&t;   last packet */
r_if
c_cond
(paren
id|lp-&gt;tx_end
op_ne
id|last
)paren
(brace
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_CHAIN
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|last
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|lp-&gt;tx_last
op_plus
id|XMT_COUNT
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status
op_or
id|CHAIN_BIT
comma
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
multiline_comment|/* A dummy read to flush the DRAM write pipeline */
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
multiline_comment|/* Enable RX and TX interrupts */
id|outb
c_func
(paren
id|ALL_MASK
op_amp
op_complement
(paren
id|RX_MASK
op_or
id|TX_MASK
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_start
op_eq
id|lp-&gt;tx_end
)paren
(brace
id|outw
c_func
(paren
id|last
comma
id|ioaddr
op_plus
id|XMT_BAR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|XMT_CMD
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|last
suffix:semicolon
multiline_comment|/* I don&squot;t like to change tx_start here */
)brace
r_else
id|outb
c_func
(paren
id|RESUME_XMT_CMD
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_last
op_assign
id|last
suffix:semicolon
id|lp-&gt;tx_end
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: exiting hardware_send_packet routine.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: exiting hardware_send_packet routine.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|eepro_rx
id|eepro_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|20
suffix:semicolon
r_int
id|rcv_car
op_assign
id|lp-&gt;rx_start
suffix:semicolon
r_int
id|rcv_event
comma
id|rcv_status
comma
id|rcv_next_frame
comma
id|rcv_size
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: entering eepro_rx routine.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the read pointer to the start of the RCV */
id|outw
c_func
(paren
id|rcv_car
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|rcv_event
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rcv_event
op_eq
id|RCV_DONE
)paren
(brace
id|rcv_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|rcv_next_frame
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|rcv_size
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rcv_status
op_amp
(paren
id|RX_OK
op_or
id|RX_ERROR
)paren
)paren
op_eq
id|RX_OK
)paren
(brace
multiline_comment|/* Malloc up new buffer. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|rcv_size
op_and_assign
l_int|0x3fff
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|rcv_size
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;version
op_eq
id|LAN595
)paren
id|insw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|rcv_size
)paren
comma
(paren
id|rcv_size
op_plus
l_int|3
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* LAN595TX or LAN595FX, capable of 32-bit I/O processing */
r_int
r_int
id|temp
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_or
id|IO_32_BIT
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
id|insl
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT_32_BIT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|rcv_size
)paren
comma
(paren
id|rcv_size
op_plus
l_int|3
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
op_amp
op_complement
(paren
id|IO_32_BIT
)paren
comma
id|ioaddr
op_plus
id|INT_MASK_REG
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not sure will ever reach here, &n;&t;&t;&t;  I set the 595 to discard bad received frames */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x0100
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x0400
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x0800
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: event = %#x, status = %#x, next = %#x, size = %#x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rcv_event
comma
id|rcv_status
comma
id|rcv_next_frame
comma
id|rcv_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rcv_status
op_amp
l_int|0x1000
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscount
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|rcv_car
op_assign
id|lp-&gt;rx_start
op_plus
id|RCV_HEADER
op_plus
id|rcv_size
suffix:semicolon
id|lp-&gt;rx_start
op_assign
id|rcv_next_frame
suffix:semicolon
id|outw
c_func
(paren
id|rcv_next_frame
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|rcv_event
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rcv_car
op_eq
l_int|0
)paren
id|rcv_car
op_assign
(paren
id|RCV_UPPER_LIMIT
op_lshift
l_int|8
)paren
op_or
l_int|0xff
suffix:semicolon
id|outw
c_func
(paren
id|rcv_car
op_minus
l_int|1
comma
id|ioaddr
op_plus
id|RCV_STOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: exiting eepro_rx routine.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|eepro_transmit_interrupt
id|eepro_transmit_interrupt
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|eepro_local
op_star
id|lp
op_assign
(paren
r_struct
id|eepro_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|10
suffix:semicolon
r_int
id|xmt_status
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;tx_start
op_ne
id|lp-&gt;tx_end
)paren
(brace
id|outw
c_func
(paren
id|lp-&gt;tx_start
comma
id|ioaddr
op_plus
id|HOST_ADDRESS_REG
)paren
suffix:semicolon
id|xmt_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xmt_status
op_amp
id|TX_DONE_BIT
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|xmt_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
id|lp-&gt;tx_start
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|IO_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xmt_status
op_amp
l_int|0x2000
)paren
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_else
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|xmt_status
op_amp
l_int|0x0400
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: XMT status = %#x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|xmt_status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xmt_status
op_amp
l_int|0x000f
)paren
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|xmt_status
op_amp
l_int|0x000f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xmt_status
op_amp
l_int|0x0040
)paren
op_eq
l_int|0x0
)paren
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscount
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|variable|devicename
r_static
r_char
id|devicename
(braket
l_int|9
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dev_eepro
r_static
r_struct
id|device
id|dev_eepro
op_assign
(brace
id|devicename
comma
multiline_comment|/* device name is inserted by linux/drivers/net/net_init.c */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|eepro_probe
)brace
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x200
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;eepro: You should not use auto-probing with insmod!&bslash;n&quot;
)paren
suffix:semicolon
id|dev_eepro.base_addr
op_assign
id|io
suffix:semicolon
id|dev_eepro.irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_eepro
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|dev_eepro
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|dev_eepro.priv
comma
r_sizeof
(paren
r_struct
id|eepro_local
)paren
)paren
suffix:semicolon
id|dev_eepro.priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If we don&squot;t do this, we can&squot;t re-insmod it later. */
id|release_region
c_func
(paren
id|dev_eepro.base_addr
comma
id|EEPRO_IO_EXTENT
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
