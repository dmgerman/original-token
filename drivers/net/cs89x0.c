multiline_comment|/* cs89x0.c: A Crystal Semiconductor CS89[02]0 driver for linux. */
multiline_comment|/*&n;&t;Written 1996 by Russell Nelson, with reference to skeleton.c&n;&t;written 1993-1994 by Donald Becker.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;&t;The author may be reached at nelson@crynwr.com, Crynwr&n;&t;Software, 11 Grant St., Potsdam, NY 13676&n;&n;  Changelog:&n;&n;  Mike Cruse        : mcruse@cti-ltd.com&n;                    : Changes for Linux 2.0 compatibility. &n;                    : Added dev_id parameter in net_interrupt(),&n;                    : request_irq() and free_irq(). Just NULL for now.&n;&n;  Mike Cruse        : Added MOD_INC_USE_COUNT and MOD_DEC_USE_COUNT macros&n;                    : in net_open() and net_close() so kerneld would know&n;                    : that the module is in use and wouldn&squot;t eject the &n;                    : driver prematurely.&n;&n;  Mike Cruse        : Rewrote init_module() and cleanup_module using 8390.c&n;                    : as an example. Disabled autoprobing in init_module(),&n;                    : not a good thing to do to other devices while Linux&n;                    : is running from all accounts.&n;                    &n;  Alan Cox          : Removed 1.2 support, added 2.1 extra counters.&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;cs89x0.c:v1.02 11/26/96 Russell Nelson &lt;nelson@crynwr.com&gt;&bslash;n&quot;
suffix:semicolon
multiline_comment|/* ======================= configure the driver here ======================= */
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
multiline_comment|/* ======================= end of configuration ======================= */
multiline_comment|/* Always include &squot;config.h&squot; first in case the user wants to turn on&n;   or override something. */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#else
DECL|macro|MOD_INC_USE_COUNT
mdefine_line|#define MOD_INC_USE_COUNT
DECL|macro|MOD_DEC_USE_COUNT
mdefine_line|#define MOD_DEC_USE_COUNT
macro_line|#endif
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) printk x
multiline_comment|/*&n;  Sources:&n;&n;&t;Crynwr packet driver epktisa.&n;&n;&t;Crystal Semiconductor data sheets.&n;&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;cs89x0.h&quot;
multiline_comment|/* First, a few definitions that the brave might change. */
multiline_comment|/* A zero-terminated list of I/O addresses to be probed. */
DECL|variable|netcard_portlist
r_static
r_int
r_int
id|netcard_portlist
(braket
)braket
op_assign
(brace
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x200
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2a0
comma
l_int|0x2c0
comma
l_int|0x2e0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|NETCARD_IO_EXTENT
mdefine_line|#define NETCARD_IO_EXTENT&t;16
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|chip_type
r_int
id|chip_type
suffix:semicolon
multiline_comment|/* one of: CS8900, CS8920, CS8920M */
DECL|member|chip_revision
r_char
id|chip_revision
suffix:semicolon
multiline_comment|/* revision letter of the chip (&squot;A&squot;...) */
DECL|member|send_cmd
r_int
id|send_cmd
suffix:semicolon
multiline_comment|/* the propercommand used to send a packet. */
DECL|member|auto_neg_cnf
r_int
id|auto_neg_cnf
suffix:semicolon
DECL|member|adapter_cnf
r_int
id|adapter_cnf
suffix:semicolon
DECL|member|isa_config
r_int
id|isa_config
suffix:semicolon
DECL|member|irq_map
r_int
id|irq_map
suffix:semicolon
DECL|member|rx_mode
r_int
id|rx_mode
suffix:semicolon
DECL|member|curr_rx_cfg
r_int
id|curr_rx_cfg
suffix:semicolon
DECL|member|linectl
r_int
id|linectl
suffix:semicolon
DECL|member|send_underrun
r_int
id|send_underrun
suffix:semicolon
multiline_comment|/* keep track of how many underruns in a row we get */
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|cs89x0_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cs89x0_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|reset_chip
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|get_eeprom_data
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|get_eeprom_cksum
c_func
(paren
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|set_mac_address
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
multiline_comment|/* Example routines you must write ;-&gt;. */
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) 1
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   */
macro_line|#ifdef HAVE_DEVLIST
multiline_comment|/* Support for a alternate probe manager, which will eliminate the&n;   boilerplate below. */
DECL|variable|netcard_drv
r_struct
id|netdev_entry
id|netcard_drv
op_assign
(brace
l_string|&quot;netcard&quot;
comma
id|cs89x0_probe1
comma
id|NETCARD_IO_EXTENT
comma
id|netcard_portlist
)brace
suffix:semicolon
macro_line|#else
r_int
DECL|function|cs89x0_probe
id|cs89x0_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev
ques
c_cond
id|dev-&gt;base_addr
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|cs89x0_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|netcard_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
id|netcard_portlist
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|NETCARD_IO_EXTENT
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cs89x0_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;cs89x0: no cs8900 or cs8920 detected.  Be sure to disable PnP with SETUP&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
r_inline
DECL|function|readreg
id|readreg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|portno
)paren
(brace
id|outw
c_func
(paren
id|portno
comma
id|dev-&gt;base_addr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
r_return
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
)brace
r_static
r_void
r_inline
DECL|function|writereg
id|writereg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|portno
comma
r_int
id|value
)paren
(brace
id|outw
c_func
(paren
id|portno
comma
id|dev-&gt;base_addr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|value
comma
id|dev-&gt;base_addr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
)brace
r_static
r_int
r_inline
DECL|function|readword
id|readword
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|portno
)paren
(brace
r_return
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|portno
)paren
suffix:semicolon
)brace
r_static
r_void
r_inline
DECL|function|writeword
id|writeword
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|portno
comma
r_int
id|value
)paren
(brace
id|outw
c_func
(paren
id|value
comma
id|dev-&gt;base_addr
op_plus
id|portno
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wait_eeprom_ready
id|wait_eeprom_ready
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|timeout
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* check to see if the EEPROM is ready, a timeout is used -&n;&t;   just in case EEPROM is ready when SI_BUSY in the&n;&t;   PP_SelfST is clear */
r_while
c_loop
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
id|SI_BUSY
)paren
r_if
c_cond
(paren
id|jiffies
op_minus
id|timeout
op_ge
l_int|40
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|get_eeprom_data
id|get_eeprom_data
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;EEPROM data from %x for %x:&bslash;n&quot;
comma
id|off
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wait_eeprom_ready
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now send the EEPROM read command and EEPROM location to read */
id|writereg
c_func
(paren
id|dev
comma
id|PP_EECMD
comma
(paren
id|off
op_plus
id|i
)paren
op_or
id|EEPROM_READ_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_eeprom_ready
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|buffer
(braket
id|i
)braket
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_EEData
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%04x &quot;
comma
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|get_eeprom_cksum
id|get_eeprom_cksum
c_func
(paren
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
comma
id|cksum
suffix:semicolon
id|cksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|cksum
op_add_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
id|cksum
op_and_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|cksum
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is the real probe routine.  Linux has a history of friendly device&n;   probes on the ISA bus.  A good device probes avoids doing writes, and&n;   verifies that the correct device exists and functions.  */
DECL|function|cs89x0_probe1
r_static
r_int
id|cs89x0_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rev_type
op_assign
l_int|0
suffix:semicolon
r_int
id|eeprom_buff
(braket
id|CHKSUM_LEN
)braket
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* if they give us an odd I/O address, then do ONE write to&n;           the address port, to get it back to address zero, where we&n;           expect to find the EISA signature word. */
r_if
c_cond
(paren
id|ioaddr
op_amp
l_int|1
)paren
(brace
id|ioaddr
op_and_assign
op_complement
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|ADD_PORT
)paren
op_amp
id|ADD_MASK
)paren
op_ne
id|ADD_SIG
)paren
r_return
id|ENODEV
suffix:semicolon
id|outw
c_func
(paren
id|PP_ChipID
comma
id|ioaddr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_PORT
)paren
op_ne
id|CHIP_EISA_ID_SIG
)paren
r_return
id|ENODEV
suffix:semicolon
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* get the chip type */
id|rev_type
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PRODUCT_ID_ADD
)paren
suffix:semicolon
id|lp-&gt;chip_type
op_assign
id|rev_type
op_amp
op_complement
id|REVISON_BITS
suffix:semicolon
id|lp-&gt;chip_revision
op_assign
(paren
(paren
id|rev_type
op_amp
id|REVISON_BITS
)paren
op_rshift
l_int|8
)paren
op_plus
l_char|&squot;A&squot;
suffix:semicolon
multiline_comment|/* Check the chip type and revision in order to set the correct send command&n;&t;CS8920 revision C and CS8900 revision F can use the faster send. */
id|lp-&gt;send_cmd
op_assign
id|TX_AFTER_381
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
op_logical_and
id|lp-&gt;chip_revision
op_ge
l_char|&squot;F&squot;
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_NOW
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
op_logical_and
id|lp-&gt;chip_revision
op_ge
l_char|&squot;C&squot;
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_NOW
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: cs89%c0%s rev %c found at %#3lx&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;chip_type
op_eq
id|CS8900
ques
c_cond
l_char|&squot;0&squot;
suffix:colon
l_char|&squot;2&squot;
comma
id|lp-&gt;chip_type
op_eq
id|CS8920M
ques
c_cond
l_string|&quot;M&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lp-&gt;chip_revision
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|reset_chip
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* First check to see if an EEPROM is attached*/
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
id|EEPROM_PRESENT
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;ncs89x0: No EEPROM, relying on command line....&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|get_eeprom_data
c_func
(paren
id|dev
comma
id|START_EEPROM_DATA
comma
id|CHKSUM_LEN
comma
id|eeprom_buff
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;ncs89x0: EEPROM read failed, relying on command line.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|get_eeprom_cksum
c_func
(paren
id|START_EEPROM_DATA
comma
id|CHKSUM_LEN
comma
id|eeprom_buff
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;ncs89x0: EEPROM checksum bad, relyong on command line&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* get transmission control word  but keep the autonegotiation bits */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;auto_neg_cnf
)paren
id|lp-&gt;auto_neg_cnf
op_assign
id|eeprom_buff
(braket
id|AUTO_NEG_CNF_OFFSET
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Store adapter configuration */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;adapter_cnf
)paren
id|lp-&gt;adapter_cnf
op_assign
id|eeprom_buff
(braket
id|ADAPTER_CNF_OFFSET
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Store ISA configuration */
id|lp-&gt;isa_config
op_assign
id|eeprom_buff
(braket
id|ISA_CNF_OFFSET
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* store the initial memory base address */
id|dev-&gt;mem_start
op_assign
id|eeprom_buff
(braket
id|PACKET_PAGE_OFFSET
op_div
l_int|2
)braket
op_lshift
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_assign
id|eeprom_buff
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|eeprom_buff
(braket
id|i
)braket
op_rshift
l_int|8
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; media %s%s%s&quot;
comma
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_T
)paren
ques
c_cond
l_string|&quot;RJ-45,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_AUI
)paren
ques
c_cond
l_string|&quot;AUI,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_2
)paren
ques
c_cond
l_string|&quot;BNC,&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|lp-&gt;irq_map
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* If this is a CS8900 then no pnp soft */
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
op_logical_and
multiline_comment|/* Check if the ISA IRQ has been set  */
(paren
id|i
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_CS8920_ISAINT
)paren
op_amp
l_int|0xff
comma
(paren
id|i
op_ne
l_int|0
op_logical_and
id|i
OL
id|CS8920_NO_INTS
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
id|dev-&gt;irq
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|lp-&gt;isa_config
op_amp
id|INT_NO_MASK
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
)paren
(brace
multiline_comment|/* the table that follows is dependent upon how you wired up your cs8900&n;&t;&t;&t; * in your system.  The table is the same as the cs8900 engineering demo&n;&t;&t;&t; * board.  irq_map also depends on the contents of the table.  Also see&n;&t;&t;&t; * write_irq, which is the reverse mapping of the table below. */
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
l_int|0
suffix:colon
id|i
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|i
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|i
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|i
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;ncs89x0: bug: isa_config is %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|lp-&gt;irq_map
op_assign
id|CS8900_IRQ_MAP
suffix:semicolon
multiline_comment|/* fixed IRQ map for CS8900 */
)brace
r_else
(brace
r_int
id|irq_map_buff
(braket
id|IRQ_MAP_LEN
op_div
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_eeprom_data
c_func
(paren
id|dev
comma
id|IRQ_MAP_EEPROM_DATA
comma
id|IRQ_MAP_LEN
op_div
l_int|2
comma
id|irq_map_buff
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq_map_buff
(braket
l_int|0
)braket
op_amp
l_int|0xff
)paren
op_eq
id|PNP_IRQ_FRMT
)paren
id|lp-&gt;irq_map
op_assign
(paren
id|irq_map_buff
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
op_or
(paren
id|irq_map_buff
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
id|dev-&gt;irq
op_assign
id|i
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; IRQ %d&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* print the ethernet address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Grab the region so we can find another board if autoIRQ fails. */
id|request_region
c_func
(paren
id|ioaddr
comma
id|NETCARD_IO_EXTENT
comma
l_string|&quot;cs89x0&quot;
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|net_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|net_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
op_amp
id|set_mac_address
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_void
DECL|function|reset_chip
id|reset_chip
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|reset_start_time
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_SelfCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfCTL
)paren
op_or
id|POWER_ON_RESET
)paren
suffix:semicolon
multiline_comment|/* wait 30 ms */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|3
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
)paren
(brace
multiline_comment|/* Hardware problem requires PNP registers to be reconfigured after a reset */
id|outw
c_func
(paren
id|PP_CS8920_ISAINT
comma
id|ioaddr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;irq
comma
id|ioaddr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DATA_PORT
op_plus
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PP_CS8920_ISAMemB
comma
id|ioaddr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|ioaddr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
id|ioaddr
op_plus
id|DATA_PORT
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait until the chip is reset */
id|reset_start_time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
id|INIT_DONE
)paren
op_eq
l_int|0
op_logical_and
id|jiffies
op_minus
id|reset_start_time
OL
l_int|2
)paren
(brace
suffix:semicolon
)brace
)brace
"&f;"
r_static
r_void
DECL|function|control_dc_dc
id|control_dc_dc
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|on_not_off
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|selfcontrol
suffix:semicolon
r_int
id|timenow
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* control the DC to DC convertor in the SelfControl register.  */
id|selfcontrol
op_assign
id|HCB1_ENBL
suffix:semicolon
multiline_comment|/* Enable the HCB1 bit as an output */
r_if
c_cond
(paren
(paren
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_DC_DC_POLARITY
)paren
op_ne
l_int|0
)paren
op_xor
id|on_not_off
)paren
id|selfcontrol
op_or_assign
id|HCB1
suffix:semicolon
r_else
id|selfcontrol
op_and_assign
op_complement
id|HCB1
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_SelfCTL
comma
id|selfcontrol
)paren
suffix:semicolon
multiline_comment|/* Wait for the DC/DC converter to power up - 500ms */
r_while
c_loop
(paren
id|jiffies
op_minus
id|timenow
OL
l_int|100
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|detect_tp
id|detect_tp
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|timenow
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Attempting TP&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* If connected to another full duplex capable 10-Base-T card the link pulses&n;           seem to be lost when the auto detect bit in the LineCTL is set.&n;           To overcome this the auto detect bit will be cleared whilst testing the&n;           10-Base-T interface.  This would not be necessary for the sparrow chip but&n;           is simpler to do it anyway. */
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|lp-&gt;linectl
op_amp
op_complement
id|AUI_ONLY
)paren
suffix:semicolon
id|control_dc_dc
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Delay for the hardware to work out if the TP cable is present - 150ms */
r_for
c_loop
(paren
id|timenow
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_minus
id|timenow
OL
l_int|15
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineST
)paren
op_amp
id|LINK_OK
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
)paren
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_AutoNegCTL
comma
id|lp-&gt;auto_neg_cnf
op_amp
id|AUTO_NEG_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|AUTO_NEG_BITS
)paren
op_eq
id|AUTO_NEG_ENABLE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: negotiating duplex...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_AutoNegST
)paren
op_amp
id|AUTO_NEG_BUSY
)paren
(brace
r_if
c_cond
(paren
id|jiffies
op_minus
id|timenow
OG
l_int|4000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;**** Full / half duplex auto-negotiation timed out ****&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_AutoNegST
)paren
op_amp
id|FDX_ACTIVE
)paren
id|printk
c_func
(paren
l_string|&quot;%s: using full duplex&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: using half duplex&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
id|A_CNF_MEDIA_10B_T
suffix:semicolon
)brace
multiline_comment|/* send a test packet - return true if carrier bits are ok */
r_static
r_int
DECL|function|send_test_pkt
id|send_test_pkt
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_char
id|test_packet
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|46
comma
multiline_comment|/* A 46 in network order */
l_int|0
comma
l_int|0
comma
multiline_comment|/* DSAP=0 &amp; SSAP=0 fields */
l_int|0xf3
comma
l_int|0
multiline_comment|/* Control (Test Req + P bit set) */
)brace
suffix:semicolon
r_int
id|timenow
op_assign
id|jiffies
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
op_or
id|SERIAL_TX_ON
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|test_packet
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|test_packet
op_plus
id|ETH_ALEN
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TX_AFTER_ALL
comma
id|ioaddr
op_plus
id|TX_CMD_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|ETH_ZLEN
comma
id|ioaddr
op_plus
id|TX_LEN_PORT
)paren
suffix:semicolon
multiline_comment|/* Test to see if the chip has allocated memory for the packet */
r_while
c_loop
(paren
id|jiffies
op_minus
id|timenow
OL
l_int|5
)paren
r_if
c_cond
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_BusST
)paren
op_amp
id|READY_FOR_TX_NOW
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|timenow
op_ge
l_int|5
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* this shouldn&squot;t happen */
multiline_comment|/* Write the contents of the packet */
r_if
c_cond
(paren
id|dev-&gt;mem_start
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|PP_TxFrame
comma
id|test_packet
comma
id|ETH_ZLEN
)paren
suffix:semicolon
)brace
r_else
(brace
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|TX_FRAME_PORT
comma
id|test_packet
comma
(paren
id|ETH_ZLEN
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Sending test packet &quot;
)paren
suffix:semicolon
multiline_comment|/* wait a couple of jiffies for packet to be received */
r_for
c_loop
(paren
id|timenow
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_minus
id|timenow
OL
l_int|3
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_TxEvent
)paren
op_amp
id|TX_SEND_OK_BITS
)paren
op_eq
id|TX_OK
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;succeeded&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|detect_aui
id|detect_aui
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Attempting AUI&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|control_dc_dc
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
(paren
id|lp-&gt;linectl
op_amp
op_complement
id|AUTO_AUI_10BASET
)paren
op_or
id|AUI_ONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_test_pkt
c_func
(paren
id|dev
)paren
)paren
r_return
id|A_CNF_MEDIA_AUI
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|detect_bnc
id|detect_bnc
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Attempting BNC&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|control_dc_dc
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
(paren
id|lp-&gt;linectl
op_amp
op_complement
id|AUTO_AUI_10BASET
)paren
op_or
id|AUI_ONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_test_pkt
c_func
(paren
id|dev
)paren
)paren
r_return
id|A_CNF_MEDIA_10B_2
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
r_void
DECL|function|write_irq
id|write_irq
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|chip_type
comma
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|chip_type
op_eq
id|CS8900
)paren
(brace
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|10
suffix:colon
id|i
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|i
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|i
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|i
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
)brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_CS8900_ISAINT
comma
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_CS8920_ISAINT
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;   */
r_static
r_int
DECL|function|net_open
id|net_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
multiline_comment|/* Allow interrupts to be generated by the chip */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|ENABLE_IRQ
op_or
id|MEMORY_ON
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|CS8920_NO_INTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|dev-&gt;irq
)paren
op_amp
id|lp-&gt;irq_map
)paren
(brace
r_if
c_cond
(paren
id|request_irq
(paren
id|i
comma
l_int|NULL
comma
l_int|0
comma
l_string|&quot;cs8920&quot;
comma
l_int|NULL
)paren
op_ne
op_minus
id|EBUSY
)paren
(brace
id|write_irq
c_func
(paren
id|dev
comma
id|lp-&gt;chip_type
comma
id|i
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BufCFG
comma
id|GENERATE_SW_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|dev-&gt;irq
op_assign
id|i
comma
op_amp
id|net_interrupt
comma
l_int|0
comma
l_string|&quot;cs89x0&quot;
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|CS8920_NO_INTS
)paren
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable interrupts. */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|dev-&gt;irq
)paren
op_amp
id|lp-&gt;irq_map
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: IRQ %d is not in our map of allowable IRQs, which is %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|lp-&gt;irq_map
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|ENABLE_IRQ
op_or
id|MEMORY_ON
)paren
suffix:semicolon
id|write_irq
c_func
(paren
id|dev
comma
id|lp-&gt;chip_type
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|net_interrupt
comma
l_int|0
comma
l_string|&quot;cs89x0&quot;
comma
l_int|NULL
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* set the Ethernet address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|writereg
c_func
(paren
id|dev
comma
id|PP_IA
op_plus
id|i
op_star
l_int|2
comma
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* while we&squot;re testing the interface, leave interrupts disabled */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|MEMORY_ON
)paren
suffix:semicolon
multiline_comment|/* Set the LineCTL quintuplet based on adapter configuration read from EEPROM */
r_if
c_cond
(paren
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_EXTND_10B_2
)paren
op_logical_and
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_LOW_RX_SQUELCH
)paren
)paren
id|lp-&gt;linectl
op_assign
id|LOW_RX_SQUELCH
suffix:semicolon
r_else
id|lp-&gt;linectl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check to make sure that they have the &quot;right&quot; hardware available */
r_switch
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_MEDIA_TYPE
)paren
(brace
r_case
id|A_CNF_MEDIA_10B_T
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_T
suffix:semicolon
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUI
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_AUI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_10B_2
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
(paren
id|A_CNF_10B_T
op_or
id|A_CNF_AUI
op_or
id|A_CNF_10B_2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EEPROM is configured for unavailable media&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|release_irq
suffix:colon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
op_amp
op_complement
(paren
id|SERIAL_TX_ON
op_or
id|SERIAL_RX_ON
)paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* set the hardware to the configured choice */
r_switch
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_MEDIA_TYPE
)paren
(brace
r_case
id|A_CNF_MEDIA_10B_T
suffix:colon
id|result
op_assign
id|detect_tp
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|printk
c_func
(paren
l_string|&quot;%s: 10Base-T (RJ-45) has no cable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|IMM_BIT
)paren
multiline_comment|/* check &quot;ignore missing media&quot; bit */
id|result
op_assign
id|A_CNF_MEDIA_10B_T
suffix:semicolon
multiline_comment|/* Yes! I don&squot;t care if I see a link pulse */
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUI
suffix:colon
id|result
op_assign
id|detect_aui
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|printk
c_func
(paren
l_string|&quot;%s: 10Base-5 (AUI) has no cable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|IMM_BIT
)paren
multiline_comment|/* check &quot;ignore missing media&quot; bit */
id|result
op_assign
id|A_CNF_MEDIA_AUI
suffix:semicolon
multiline_comment|/* Yes! I don&squot;t care if I see a carrrier */
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_10B_2
suffix:colon
id|result
op_assign
id|detect_bnc
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|printk
c_func
(paren
l_string|&quot;%s: 10Base-2 (BNC) has no cable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|IMM_BIT
)paren
multiline_comment|/* check &quot;ignore missing media&quot; bit */
id|result
op_assign
id|A_CNF_MEDIA_10B_2
suffix:semicolon
multiline_comment|/* Yes! I don&squot;t care if I can xmit a packet */
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUTO
suffix:colon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|lp-&gt;linectl
op_or
id|AUTO_AUI_10BASET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_T
)paren
r_if
c_cond
(paren
(paren
id|result
op_assign
id|detect_tp
c_func
(paren
id|dev
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_AUI
)paren
r_if
c_cond
(paren
(paren
id|result
op_assign
id|detect_aui
c_func
(paren
id|dev
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_2
)paren
r_if
c_cond
(paren
(paren
id|result
op_assign
id|detect_bnc
c_func
(paren
id|dev
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: no media detected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: no network cable attached to configured media&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
r_case
id|A_CNF_MEDIA_10B_T
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: using 10Base-T (RJ-45)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: using 10Base-5 (AUI)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_10B_2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: using 10Base-2 (BNC)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: unexpected result was %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|result
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
)brace
multiline_comment|/* Turn on both receive and transmit operations */
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
op_or
id|SERIAL_RX_ON
op_or
id|SERIAL_TX_ON
)paren
suffix:semicolon
multiline_comment|/* Receive only error free packets addressed to this card */
id|lp-&gt;rx_mode
op_assign
l_int|0
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCTL
comma
id|DEF_RX_ACCEPT
)paren
suffix:semicolon
id|lp-&gt;curr_rx_cfg
op_assign
id|RX_OK_ENBL
op_or
id|RX_CRC_ERROR_ENBL
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;isa_config
op_amp
id|STREAM_TRANSFER
)paren
id|lp-&gt;curr_rx_cfg
op_or_assign
id|RX_STREAM_ENBL
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCFG
comma
id|lp-&gt;curr_rx_cfg
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_TxCFG
comma
id|TX_LOST_CRS_ENBL
op_or
id|TX_SQE_ERROR_ENBL
op_or
id|TX_OK_ENBL
op_or
id|TX_LATE_COL_ENBL
op_or
id|TX_JBR_ENBL
op_or
id|TX_ANY_COL_ENBL
op_or
id|TX_16_COL_ENBL
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BufCFG
comma
id|READY_FOR_TX_ENBL
op_or
id|RX_MISS_COUNT_OVRFLOW_ENBL
op_or
id|TX_COL_COUNT_OVRFLOW_ENBL
op_or
id|TX_UNDERRUN_ENBL
)paren
suffix:semicolon
multiline_comment|/* now that we&squot;ve got our act together, enable everything */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|ENABLE_IRQ
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|net_send_packet
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping.  This could better be&n;&t;   done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%s: sent %d byte packet of type %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|skb-&gt;len
comma
(paren
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
op_plus
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* keep the upload from being interrupted, since we&n;                   ask the chip to start transmitting before the&n;                   whole packet has been completely uploaded. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initiate a transmit sequence */
id|outw
c_func
(paren
id|lp-&gt;send_cmd
comma
id|ioaddr
op_plus
id|TX_CMD_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|skb-&gt;len
comma
id|ioaddr
op_plus
id|TX_LEN_PORT
)paren
suffix:semicolon
multiline_comment|/* Test to see if the chip has allocated memory for the packet */
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_BusST
)paren
op_amp
id|READY_FOR_TX_NOW
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Gasp!  It hasn&squot;t.  But that shouldn&squot;t happen since&n;&t;&t;&t;   we&squot;re waiting for TxOk, so return 1 and requeue this packet. */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Write the contents of the packet */
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|TX_FRAME_PORT
comma
id|skb-&gt;data
comma
(paren
id|skb-&gt;len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
DECL|function|net_interrupt
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Re-entering the interrupt handler.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* we MUST read all the events out of the ISQ, otherwise we&squot;ll never&n;           get interrupted again.  As a consequence, we can&squot;t have any limit&n;           on the number of times we loop in the interrupt handler.  The&n;           hardware guarantees that eventually we&squot;ll run out of events.  Of&n;           course, if you&squot;re on a slow machine, and packets are arriving&n;           faster than you can read them off, you&squot;re screwed.  Hasta la&n;           vista, baby!  */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|readword
c_func
(paren
id|dev
comma
id|ISQ_PORT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: event=%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
op_amp
id|ISQ_EVENT_MASK
)paren
(brace
r_case
id|ISQ_RECEIVER_EVENT
suffix:colon
multiline_comment|/* Got a packet(s). */
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISQ_TRANSMITTER_EVENT
suffix:colon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|TX_OK
)paren
op_eq
l_int|0
)paren
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_LOST_CRS
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_SQE_ERROR
)paren
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_LATE_COL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_16_COL
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISQ_BUFFER_EVENT
suffix:colon
r_if
c_cond
(paren
id|status
op_amp
id|READY_FOR_TX
)paren
(brace
multiline_comment|/* we tried to transmit a packet earlier,&n;                                   but inexplicably ran out of buffers.&n;                                   That shouldn&squot;t happen since we only ever&n;                                   load one packet.  Shrug.  Do the right&n;                                   thing anyway. */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TX_UNDERRUN
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit underrun&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;send_underrun
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;send_underrun
op_eq
l_int|3
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_AFTER_381
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lp-&gt;send_underrun
op_eq
l_int|6
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_AFTER_ALL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ISQ_RX_MISS_EVENT
suffix:colon
id|lp-&gt;stats.rx_missed_errors
op_add_assign
(paren
id|status
op_rshift
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISQ_TX_COL_EVENT
suffix:colon
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|status
op_rshift
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
r_static
r_void
DECL|function|net_rx
id|net_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|status
comma
id|length
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
)paren
suffix:semicolon
id|length
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|RX_OK
)paren
op_eq
l_int|0
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_RUNT
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_EXTRA_DATA
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_CRC_ERROR
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
(paren
id|RX_EXTRA_DATA
op_or
id|RX_RUNT
)paren
)paren
)paren
multiline_comment|/* per str 172 */
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_DRIBBLE
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Malloc up new buffer. */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|length
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
comma
id|skb-&gt;data
comma
id|length
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
op_amp
l_int|1
)paren
id|skb-&gt;data
(braket
id|length
op_minus
l_int|1
)braket
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%s: received %d byte packet of type %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
comma
(paren
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|net_close
id|net_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCFG
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_TxCFG
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BufCFG
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Update the statistics here. */
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|net_get_stats
id|net_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Update the statistics from the device registers. */
id|lp-&gt;stats.rx_missed_errors
op_add_assign
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_RxMiss
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_TxCol
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|lp-&gt;rx_mode
op_assign
id|RX_ALL_ACCEPT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_list
)paren
(brace
multiline_comment|/* The multicast-accept list is initialized to accept-all, and we&n;&t;&t;   rely on higher-level filtering for now. */
id|lp-&gt;rx_mode
op_assign
id|RX_MULTCAST_ACCEPT
suffix:semicolon
)brace
r_else
id|lp-&gt;rx_mode
op_assign
l_int|0
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCTL
comma
id|DEF_RX_ACCEPT
op_or
id|lp-&gt;rx_mode
)paren
suffix:semicolon
multiline_comment|/* in promiscuous mode, we accept errored packets, so we have to enable interrupts on them also */
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCFG
comma
id|lp-&gt;curr_rx_cfg
op_or
(paren
id|lp-&gt;rx_mode
op_eq
id|RX_ALL_ACCEPT
ques
c_cond
(paren
id|RX_CRC_ERROR_ENBL
op_or
id|RX_RUNT_ENBL
op_or
id|RX_EXTRA_DATA_ENBL
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|set_mac_address
r_static
r_int
id|set_mac_address
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;start
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Setting MAC address to &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|addr
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* set the Ethernet address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|writereg
c_func
(paren
id|dev
comma
id|PP_IA
op_plus
id|i
op_star
l_int|2
comma
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|namespace
r_static
r_char
r_namespace
(braket
l_int|16
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|dev_cs89x0
r_static
r_struct
id|device
id|dev_cs89x0
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|io
r_int
id|io
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
DECL|variable|debug
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
DECL|variable|media
r_char
op_star
id|media
op_assign
l_string|&quot;auto&quot;
suffix:semicolon
DECL|variable|duplex
r_char
op_star
id|duplex
op_assign
l_string|&quot;f&quot;
suffix:semicolon
multiline_comment|/*&n;* media=t             - specify media type&n;   or media=2&n;   or media=aui&n;   or medai=auto&n;* duplex=f            - specify forced half/full/autonegotiate duplex&n;   or duplex=h&n;   or duplex=auto&n;* debug=#             - debug level&n;&n;&n;* Default Chip Configuration:&n;  * DMA Burst = enabled&n;  * IOCHRDY Enabled = enabled&n;    * UseSA = enabled&n;    * CS8900 defaults to half-duplex if not specified on command-line&n;    * CS8920 defaults to autoneg if not specified on command-line&n;    * Use reset defaults for other config parameters&n;&n;* Assumptions:&n;  * media type specified is supported (circuitry is present)&n;  * if memory address is &gt; 1MB, then required mem decode hw is present&n;  * if 10B-2, then agent other than driver will enable DC/DC converter&n;    (hw or software util)&n;&n;&n;*/
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
id|net_debug
op_assign
id|debug
suffix:semicolon
id|dev_cs89x0.name
op_assign
r_namespace
suffix:semicolon
id|dev_cs89x0.irq
op_assign
id|irq
suffix:semicolon
id|dev_cs89x0.base_addr
op_assign
id|io
suffix:semicolon
id|dev_cs89x0.init
op_assign
id|cs89x0_probe
suffix:semicolon
id|dev_cs89x0.priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev_cs89x0.priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev_cs89x0.priv
suffix:semicolon
multiline_comment|/* boy, they&squot;d better get these right */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|media
comma
l_string|&quot;rj45&quot;
)paren
)paren
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_10B_T
op_or
id|A_CNF_10B_T
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|media
comma
l_string|&quot;aui&quot;
)paren
)paren
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_AUI
op_or
id|A_CNF_AUI
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|media
comma
l_string|&quot;bnc&quot;
)paren
)paren
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_10B_2
op_or
id|A_CNF_10B_2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|duplex
comma
l_string|&quot;auto&quot;
)paren
)paren
id|lp-&gt;auto_neg_cnf
op_assign
id|AUTO_NEG_ENABLE
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cs89x0.c: Module autoprobing not allowed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cs89x0.c: Append io=0xNNN&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_cs89x0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs89x0.c: No card found at 0x%x&bslash;n&quot;
comma
id|io
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
macro_line|#endif
macro_line|#ifdef MODULE
id|outw
c_func
(paren
l_int|0
comma
id|dev_cs89x0.base_addr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|dev_cs89x0.priv
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Free up the private structure, or leak memory :-)  */
id|kfree
c_func
(paren
id|dev_cs89x0.priv
)paren
suffix:semicolon
id|dev_cs89x0.priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* gets re-allocated by cs89x0_probe1 */
multiline_comment|/* If we don&squot;t do this, we can&squot;t re-insmod it later. */
id|release_region
c_func
(paren
id|dev_cs89x0.base_addr
comma
id|NETCARD_IO_EXTENT
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|dev_cs89x0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/include -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -DMODULE -DCONFIG_MODVERSIONS -c cs89x0.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  c-indent-level: 8&n; *  tab-width: 8&n; * End:&n; *&n; */
eof
