multiline_comment|/* cs89x0.c: A Crystal Semiconductor (Now Cirrus Logic) CS89[02]0&n; *  driver for linux.&n; */
multiline_comment|/*&n;&t;Written 1996 by Russell Nelson, with reference to skeleton.c&n;&t;written 1993-1994 by Donald Becker.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;        The author may be reached at nelson@crynwr.com, Crynwr&n;        Software, 521 Pleasant Valley Rd., Potsdam, NY 13676&n;&n;  Changelog:&n;&n;  Mike Cruse        : mcruse@cti-ltd.com&n;                    : Changes for Linux 2.0 compatibility. &n;                    : Added dev_id parameter in net_interrupt(),&n;                    : request_irq() and free_irq(). Just NULL for now.&n;&n;  Mike Cruse        : Added MOD_INC_USE_COUNT and MOD_DEC_USE_COUNT macros&n;                    : in net_open() and net_close() so kerneld would know&n;                    : that the module is in use and wouldn&squot;t eject the &n;                    : driver prematurely.&n;&n;  Mike Cruse        : Rewrote init_module() and cleanup_module using 8390.c&n;                    : as an example. Disabled autoprobing in init_module(),&n;                    : not a good thing to do to other devices while Linux&n;                    : is running from all accounts.&n;&n;  Russ Nelson       : Jul 13 1998.  Added RxOnly DMA support.&n;&n;  Melody Lee        : Aug 10 1999.  Changes for Linux 2.2.5 compatibility. &n;                    : email: ethernet@crystal.cirrus.com&n;&n;  Alan Cox          : Removed 1.2 support, added 2.1 extra counters.&n;&n;  Andrew Morton     : andrewm@uow.edu.au&n;                    : Kernel 2.3.48&n;                    : Handle kmalloc() failures&n;                    : Other resource allocation fixes&n;                    : Add SMP locks&n;                    : Integrate Russ Nelson&squot;s ALLOW_DMA functionality back in.&n;                    : If ALLOW_DMA is true, make DMA runtime selectable&n;                    : Folded in changes from Cirrus (Melody Lee&n;                    : &lt;klee@crystal.cirrus.com&gt;)&n;                    : Don&squot;t call netif_wake_queue() in net_send_packet()&n;                    : Fixed an out-of-mem bug in dma_rx()&n;                    : Updated Documentation/cs89x0.txt&n;&n;  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.3.99-pre1&n;                    : Use skb_reserve to longword align IP header (two places)&n;                    : Remove a delay loop from dma_rx()&n;                    : Replace &squot;100&squot; with HZ&n;                    : Clean up a couple of skb API abuses&n;                    : Added &squot;cs89x0_dma=N&squot; kernel boot option&n;                    : Correctly initialise lp-&gt;lock in non-module compile&n;&n;  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.3.99-pre4-1&n;                    : MOD_INC/DEC race fix (see&n;                    : http://www.uwsg.indiana.edu/hypermail/linux/kernel/0003.3/1532.html)&n;&n;  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.4.0-test7-pre2&n;                    : Enhanced EEPROM support to cover more devices,&n;                    :   abstracted IRQ mapping to support CONFIG_ARCH_CLPS7500 arch&n;                    :   (Jason Gunthorpe &lt;jgg@ualberta.ca&gt;)&n;&n;  Andrew Morton     : Kernel 2.4.0-test11-pre4&n;                    : Use dev-&gt;name in request_*() (Andrey Panin)&n;                    : Fix an error-path memleak in init_module()&n;                    : Preserve return value from request_irq()&n;                    : Fix type of `media&squot; module parm (Keith Owens)&n;                    : Use SET_MODULE_OWNER()&n;                    : Tidied up strange request_irq() abuse in net_open().&n;&n;*/
DECL|variable|version
r_static
r_char
id|version
(braket
)braket
op_assign
l_string|&quot;cs89x0.c: v2.4.0-test11-pre4 Russell Nelson &lt;nelson@crynwr.com&gt;, Andrew Morton &lt;andrewm@uow.edu.au&gt;&bslash;n&quot;
suffix:semicolon
multiline_comment|/* ======================= end of configuration ======================= */
multiline_comment|/* Always include &squot;config.h&squot; first in case the user wants to turn on&n;   or override something. */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
multiline_comment|/*&n; * Set this to zero to disable DMA code&n; *&n; * Note that even if DMA is turned off we still support the &squot;dma&squot; and  &squot;use_dma&squot;&n; * module options so we don&squot;t break any startup scripts.&n; */
DECL|macro|ALLOW_DMA
mdefine_line|#define ALLOW_DMA&t;1
multiline_comment|/*&n; * Set this to zero to remove all the debug statements via&n; * dead code elimination&n; */
DECL|macro|DEBUGGING
mdefine_line|#define DEBUGGING&t;1
multiline_comment|/*&n;  Sources:&n;&n;&t;Crynwr packet driver epktisa.&n;&n;&t;Crystal Semiconductor data sheets.&n;&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#if ALLOW_DMA
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;cs89x0.h&quot;
multiline_comment|/* First, a few definitions that the brave might change.&n;   A zero-terminated list of I/O addresses to be probed. Some special flags..&n;      Addr &amp; 1 = Read back the address port, look for signature and reset&n;                 the page window before probing &n;      Addr &amp; 3 = Reset the page window and probe &n;   The CLPS eval board has the Cirrus chip at 0x80090300, in ARM IO space,&n;   but it is possible that a Cirrus board could be plugged into the ISA&n;   slots. */
multiline_comment|/* The cs8900 has 4 IRQ pins, software selectable. cs8900_irq_map maps &n;   them to system IRQ numbers. This mapping is card specific and is set to&n;   the configuration of the Cirrus Eval board for this chip. */
macro_line|#ifdef CONFIG_ARCH_CLPS7500
DECL|variable|__initdata
r_static
r_int
r_int
id|netcard_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x80090303
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0x200
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2a0
comma
l_int|0x2c0
comma
l_int|0x2e0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|cs8900_irq_map
r_static
r_int
r_int
id|cs8900_irq_map
(braket
)braket
op_assign
(brace
l_int|12
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#else
DECL|variable|__initdata
r_static
r_int
r_int
id|netcard_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0x200
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2a0
comma
l_int|0x2c0
comma
l_int|0x2e0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|cs8900_irq_map
r_static
r_int
r_int
id|cs8900_irq_map
(braket
)braket
op_assign
(brace
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|5
)brace
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUGGING
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|DEBUGGING
suffix:semicolon
macro_line|#else
DECL|macro|net_debug
mdefine_line|#define net_debug 0&t;/* gcc will remove all the debug code for us */
macro_line|#endif
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|NETCARD_IO_EXTENT
mdefine_line|#define NETCARD_IO_EXTENT&t;16
multiline_comment|/* we allow the user to override various values normally set in the EEPROM */
DECL|macro|FORCE_RJ45
mdefine_line|#define FORCE_RJ45&t;0x0001    /* pick one of these three */
DECL|macro|FORCE_AUI
mdefine_line|#define FORCE_AUI&t;0x0002
DECL|macro|FORCE_BNC
mdefine_line|#define FORCE_BNC&t;0x0004
DECL|macro|FORCE_AUTO
mdefine_line|#define FORCE_AUTO&t;0x0010    /* pick one of these three */
DECL|macro|FORCE_HALF
mdefine_line|#define FORCE_HALF&t;0x0020
DECL|macro|FORCE_FULL
mdefine_line|#define FORCE_FULL&t;0x0030
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|chip_type
r_int
id|chip_type
suffix:semicolon
multiline_comment|/* one of: CS8900, CS8920, CS8920M */
DECL|member|chip_revision
r_char
id|chip_revision
suffix:semicolon
multiline_comment|/* revision letter of the chip (&squot;A&squot;...) */
DECL|member|send_cmd
r_int
id|send_cmd
suffix:semicolon
multiline_comment|/* the proper send command: TX_NOW, TX_AFTER_381, or TX_AFTER_ALL */
DECL|member|auto_neg_cnf
r_int
id|auto_neg_cnf
suffix:semicolon
multiline_comment|/* auto-negotiation word from EEPROM */
DECL|member|adapter_cnf
r_int
id|adapter_cnf
suffix:semicolon
multiline_comment|/* adapter configuration from EEPROM */
DECL|member|isa_config
r_int
id|isa_config
suffix:semicolon
multiline_comment|/* ISA configuration from EEPROM */
DECL|member|irq_map
r_int
id|irq_map
suffix:semicolon
multiline_comment|/* IRQ map from EEPROM */
DECL|member|rx_mode
r_int
id|rx_mode
suffix:semicolon
multiline_comment|/* what mode are we in? 0, RX_MULTCAST_ACCEPT, or RX_ALL_ACCEPT */
DECL|member|curr_rx_cfg
r_int
id|curr_rx_cfg
suffix:semicolon
multiline_comment|/* a copy of PP_RxCFG */
DECL|member|linectl
r_int
id|linectl
suffix:semicolon
multiline_comment|/* either 0 or LOW_RX_SQUELCH, depending on configuration. */
DECL|member|send_underrun
r_int
id|send_underrun
suffix:semicolon
multiline_comment|/* keep track of how many underruns in a row we get */
DECL|member|force
r_int
id|force
suffix:semicolon
multiline_comment|/* force various values; see FORCE* above. */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
macro_line|#if ALLOW_DMA
DECL|member|use_dma
r_int
id|use_dma
suffix:semicolon
multiline_comment|/* Flag: we&squot;re using dma */
DECL|member|dma
r_int
id|dma
suffix:semicolon
multiline_comment|/* DMA channel */
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
multiline_comment|/* 16 or 64 */
DECL|member|dma_buff
r_int
r_char
op_star
id|dma_buff
suffix:semicolon
multiline_comment|/* points to the beginning of the buffer */
DECL|member|end_dma_buff
r_int
r_char
op_star
id|end_dma_buff
suffix:semicolon
multiline_comment|/* points to the end of the buffer */
DECL|member|rx_dma_ptr
r_int
r_char
op_star
id|rx_dma_ptr
suffix:semicolon
multiline_comment|/* points to the next packet  */
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|cs89x0_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cs89x0_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|reset_chip
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|get_eeprom_data
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|get_eeprom_cksum
c_func
(paren
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_void
id|count_rx_errors
c_func
(paren
r_int
id|status
comma
r_struct
id|net_local
op_star
id|lp
)paren
suffix:semicolon
macro_line|#if ALLOW_DMA
r_static
r_void
id|get_dma_channel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|release_dma_buff
c_func
(paren
r_struct
id|net_local
op_star
id|lp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Example routines you must write ;-&gt;. */
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) 1
multiline_comment|/*&n; * Permit &squot;cs89x0_dma=N&squot; in the kernel boot environment&n; */
macro_line|#if !defined(MODULE) &amp;&amp; (ALLOW_DMA != 0)
DECL|variable|g_cs89x0_dma
r_static
r_int
id|g_cs89x0_dma
suffix:semicolon
DECL|function|dma_fn
r_static
r_int
id|__init
id|dma_fn
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|g_cs89x0_dma
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;cs89x0_dma=&quot;
comma
id|dma_fn
)paren
suffix:semicolon
macro_line|#endif&t;/* !defined(MODULE) &amp;&amp; (ALLOW_DMA != 0) */
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   Return 0 on success.&n;   */
DECL|function|cs89x0_probe
r_int
id|__init
id|cs89x0_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev
ques
c_cond
id|dev-&gt;base_addr
suffix:colon
l_int|0
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
l_string|&quot;cs89x0:cs89x0_probe()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|cs89x0_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|netcard_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cs89x0_probe1
c_func
(paren
id|dev
comma
id|netcard_portlist
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs89x0: no cs8900 or cs8920 detected.  Be sure to disable PnP with SETUP&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_extern
r_int
r_inline
DECL|function|readreg
id|readreg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|portno
)paren
(brace
id|outw
c_func
(paren
id|portno
comma
id|dev-&gt;base_addr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
r_return
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
)brace
r_extern
r_void
r_inline
DECL|function|writereg
id|writereg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|portno
comma
r_int
id|value
)paren
(brace
id|outw
c_func
(paren
id|portno
comma
id|dev-&gt;base_addr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|value
comma
id|dev-&gt;base_addr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
)brace
r_extern
r_int
r_inline
DECL|function|readword
id|readword
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|portno
)paren
(brace
r_return
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|portno
)paren
suffix:semicolon
)brace
r_extern
r_void
r_inline
DECL|function|writeword
id|writeword
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|portno
comma
r_int
id|value
)paren
(brace
id|outw
c_func
(paren
id|value
comma
id|dev-&gt;base_addr
op_plus
id|portno
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|wait_eeprom_ready
id|wait_eeprom_ready
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|timeout
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* check to see if the EEPROM is ready, a timeout is used -&n;&t;   just in case EEPROM is ready when SI_BUSY in the&n;&t;   PP_SelfST is clear */
r_while
c_loop
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
id|SI_BUSY
)paren
r_if
c_cond
(paren
id|jiffies
op_minus
id|timeout
op_ge
l_int|40
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|get_eeprom_data
id|get_eeprom_data
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;EEPROM data from %x for %x:&bslash;n&quot;
comma
id|off
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wait_eeprom_ready
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now send the EEPROM read command and EEPROM location to read */
id|writereg
c_func
(paren
id|dev
comma
id|PP_EECMD
comma
(paren
id|off
op_plus
id|i
)paren
op_or
id|EEPROM_READ_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_eeprom_ready
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|buffer
(braket
id|i
)braket
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_EEData
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%04x &quot;
comma
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|get_eeprom_cksum
id|get_eeprom_cksum
c_func
(paren
r_int
id|off
comma
r_int
id|len
comma
r_int
op_star
id|buffer
)paren
(brace
r_int
id|i
comma
id|cksum
suffix:semicolon
id|cksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|cksum
op_add_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
id|cksum
op_and_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|cksum
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is the real probe routine.  Linux has a history of friendly device&n;   probes on the ISA bus.  A good device probes avoids doing writes, and&n;   verifies that the correct device exists and functions.&n;   Return 0 on success.&n; */
r_static
r_int
id|__init
DECL|function|cs89x0_probe1
id|cs89x0_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rev_type
op_assign
l_int|0
suffix:semicolon
r_int
id|eeprom_buff
(braket
id|CHKSUM_LEN
)braket
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|0
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|lp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
macro_line|#if !defined(MODULE) &amp;&amp; (ALLOW_DMA != 0)
r_if
c_cond
(paren
id|g_cs89x0_dma
)paren
(brace
id|lp-&gt;use_dma
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;dma
op_assign
id|g_cs89x0_dma
suffix:semicolon
id|lp-&gt;dmasize
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Could make this an option... */
)brace
macro_line|#endif
)brace
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Grab the region so we can find another board if autoIRQ fails. */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|NETCARD_IO_EXTENT
comma
id|dev-&gt;name
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
multiline_comment|/* if they give us an odd I/O address, then do ONE write to&n;           the address port, to get it back to address zero, where we&n;           expect to find the EISA signature word. An IO with a base of 0x3&n;&t;   will skip the test for the ADD_PORT. */
r_if
c_cond
(paren
id|ioaddr
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|ioaddr
op_amp
l_int|2
)paren
op_ne
l_int|2
)paren
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
(paren
id|ioaddr
op_amp
op_complement
l_int|3
)paren
op_plus
id|ADD_PORT
)paren
op_amp
id|ADD_MASK
)paren
op_ne
id|ADD_SIG
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
id|ioaddr
op_and_assign
op_complement
l_int|3
suffix:semicolon
id|outw
c_func
(paren
id|PP_ChipID
comma
id|ioaddr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_PORT
)paren
op_ne
id|CHIP_EISA_ID_SIG
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* get the chip type */
id|rev_type
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PRODUCT_ID_ADD
)paren
suffix:semicolon
id|lp-&gt;chip_type
op_assign
id|rev_type
op_amp
op_complement
id|REVISON_BITS
suffix:semicolon
id|lp-&gt;chip_revision
op_assign
(paren
(paren
id|rev_type
op_amp
id|REVISON_BITS
)paren
op_rshift
l_int|8
)paren
op_plus
l_char|&squot;A&squot;
suffix:semicolon
multiline_comment|/* Check the chip type and revision in order to set the correct send command&n;&t;CS8920 revision C and CS8900 revision F can use the faster send. */
id|lp-&gt;send_cmd
op_assign
id|TX_AFTER_381
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
op_logical_and
id|lp-&gt;chip_revision
op_ge
l_char|&squot;F&squot;
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_NOW
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
op_logical_and
id|lp-&gt;chip_revision
op_ge
l_char|&squot;C&squot;
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_NOW
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: cs89%c0%s rev %c found at %#3lx &quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;chip_type
op_eq
id|CS8900
ques
c_cond
l_char|&squot;0&squot;
suffix:colon
l_char|&squot;2&squot;
comma
id|lp-&gt;chip_type
op_eq
id|CS8920M
ques
c_cond
l_string|&quot;M&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|lp-&gt;chip_revision
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|reset_chip
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Here we read the current configuration of the chip. If there&n;&t;   is no Extended EEPROM then the idea is to not disturb the chip&n;&t;   configuration, it should have been correctly setup by automatic&n;&t;   EEPROM read on reset. So, if the chip says it read the EEPROM&n;&t;   the driver will always do *something* instead of complain that&n;&t;   adapter_cnf is 0. */
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
(paren
id|EEPROM_OK
op_or
id|EEPROM_PRESENT
)paren
)paren
op_eq
(paren
id|EEPROM_OK
op_or
id|EEPROM_PRESENT
)paren
)paren
(brace
multiline_comment|/* Load the MAC. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|Addr
suffix:semicolon
id|Addr
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_IA
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_assign
id|Addr
op_amp
l_int|0xFF
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|Addr
op_rshift
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Load the Adapter Configuration. &n;&t;&t;   Note:  Barring any more specific information from some &n;&t;&t;   other source (ie EEPROM+Schematics), we would not know &n;&t;&t;   how to operate a 10Base2 interface on the AUI port. &n;&t;&t;   However, since we  do read the status of HCB1 and use &n;&t;&t;   settings that always result in calls to control_dc_dc(dev,0) &n;&t;&t;   a BNC interface should work if the enable pin &n;&t;&t;   (dc/dc converter) is on HCB1. It will be called AUI &n;&t;&t;   however. */
id|lp-&gt;adapter_cnf
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
suffix:semicolon
multiline_comment|/* Preserve the setting of the HCB1 pin. */
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
id|HCB1
op_or
id|HCB1_ENBL
)paren
)paren
op_eq
(paren
id|HCB1
op_or
id|HCB1_ENBL
)paren
)paren
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_DC_DC_POLARITY
suffix:semicolon
multiline_comment|/* Save the sqelch bit */
r_if
c_cond
(paren
(paren
id|i
op_amp
id|LOW_RX_SQUELCH
)paren
op_eq
id|LOW_RX_SQUELCH
)paren
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_EXTND_10B_2
op_or
id|A_CNF_LOW_RX_SQUELCH
suffix:semicolon
multiline_comment|/* Check if the card is in 10Base-t only mode */
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
id|AUI_ONLY
op_or
id|AUTO_AUI_10BASET
)paren
)paren
op_eq
l_int|0
)paren
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_10B_T
op_or
id|A_CNF_MEDIA_10B_T
suffix:semicolon
multiline_comment|/* Check if the card is in AUI only mode */
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
id|AUI_ONLY
op_or
id|AUTO_AUI_10BASET
)paren
)paren
op_eq
id|AUI_ONLY
)paren
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_AUI
op_or
id|A_CNF_MEDIA_AUI
suffix:semicolon
multiline_comment|/* Check if the card is in Auto mode. */
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
id|AUI_ONLY
op_or
id|AUTO_AUI_10BASET
)paren
)paren
op_eq
id|AUTO_AUI_10BASET
)paren
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_AUI
op_or
id|A_CNF_10B_T
op_or
id|A_CNF_MEDIA_AUI
op_or
id|A_CNF_MEDIA_10B_T
op_or
id|A_CNF_MEDIA_AUTO
suffix:semicolon
multiline_comment|/* IRQ. Other chips already probe, see below. */
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
)paren
id|lp-&gt;isa_config
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_CS8900_ISAINT
)paren
op_amp
id|INT_NO_MASK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[Cirrus EEPROM] &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* First check to see if an EEPROM is attached. */
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
id|EEPROM_PRESENT
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs89x0: No EEPROM, relying on command line....&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|get_eeprom_data
c_func
(paren
id|dev
comma
id|START_EEPROM_DATA
comma
id|CHKSUM_LEN
comma
id|eeprom_buff
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;&bslash;ncs89x0: EEPROM read failed, relying on command line.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|get_eeprom_cksum
c_func
(paren
id|START_EEPROM_DATA
comma
id|CHKSUM_LEN
comma
id|eeprom_buff
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Check if the chip was able to read its own configuration starting&n;&t;&t;   at 0 in the EEPROM*/
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
(paren
id|EEPROM_OK
op_or
id|EEPROM_PRESENT
)paren
)paren
op_ne
(paren
id|EEPROM_OK
op_or
id|EEPROM_PRESENT
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cs89x0: Extended EEPROM checksum bad and no Cirrus EEPROM, relying on command line&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This reads an extended EEPROM that is not documented&n;&t;&t;   in the CS8900 datasheet. */
multiline_comment|/* get transmission control word  but keep the autonegotiation bits */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;auto_neg_cnf
)paren
id|lp-&gt;auto_neg_cnf
op_assign
id|eeprom_buff
(braket
id|AUTO_NEG_CNF_OFFSET
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Store adapter configuration */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;adapter_cnf
)paren
id|lp-&gt;adapter_cnf
op_assign
id|eeprom_buff
(braket
id|ADAPTER_CNF_OFFSET
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Store ISA configuration */
id|lp-&gt;isa_config
op_assign
id|eeprom_buff
(braket
id|ISA_CNF_OFFSET
op_div
l_int|2
)braket
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|eeprom_buff
(braket
id|PACKET_PAGE_OFFSET
op_div
l_int|2
)braket
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* eeprom_buff has 32-bit ints, so we can&squot;t just memcpy it */
multiline_comment|/* store the initial memory base address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_assign
id|eeprom_buff
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|eeprom_buff
(braket
id|i
)braket
op_rshift
l_int|8
suffix:semicolon
)brace
)brace
multiline_comment|/* allow them to force multiple transceivers.  If they force multiple, autosense */
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;force
op_amp
id|FORCE_RJ45
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_10B_T
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;force
op_amp
id|FORCE_AUI
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_AUI
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;force
op_amp
id|FORCE_BNC
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_10B_2
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|1
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_MEDIA_AUTO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;force
op_amp
id|FORCE_RJ45
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_MEDIA_10B_T
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;force
op_amp
id|FORCE_AUI
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_MEDIA_AUI
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;force
op_amp
id|FORCE_BNC
)paren
(brace
id|lp-&gt;adapter_cnf
op_or_assign
id|A_CNF_MEDIA_10B_2
suffix:semicolon
)brace
)brace
multiline_comment|/* FIXME: We don&squot;t let you set dc-dc polarity or low RX squelch from the command line: add it here */
multiline_comment|/* FIXME: We don&squot;t let you set the IMM bit from the command line: add it to lp-&gt;auto_neg_cnf here */
multiline_comment|/* FIXME: we don&squot;t set the Ethernet address on the command line.  Use&n;           ifconfig IFACE hw ether AABBCCDDEEFF */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs89x0 media %s%s%s&quot;
comma
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_T
)paren
ques
c_cond
l_string|&quot;RJ-45,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_AUI
)paren
ques
c_cond
l_string|&quot;AUI,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_2
)paren
ques
c_cond
l_string|&quot;BNC,&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|lp-&gt;irq_map
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* If this is a CS8900 then no pnp soft */
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
op_logical_and
multiline_comment|/* Check if the ISA IRQ has been set  */
(paren
id|i
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_CS8920_ISAINT
)paren
op_amp
l_int|0xff
comma
(paren
id|i
op_ne
l_int|0
op_logical_and
id|i
OL
id|CS8920_NO_INTS
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
id|dev-&gt;irq
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|lp-&gt;isa_config
op_amp
id|INT_NO_MASK
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
)paren
(brace
multiline_comment|/* Translate the IRQ using the IRQ mapping table. */
r_if
c_cond
(paren
id|i
OG
r_sizeof
(paren
id|cs8900_irq_map
)paren
op_div
r_sizeof
(paren
id|cs8900_irq_map
(braket
l_int|0
)braket
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;ncs89x0: bug: isa_config is %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_else
id|i
op_assign
id|cs8900_irq_map
(braket
id|i
)braket
suffix:semicolon
id|lp-&gt;irq_map
op_assign
id|CS8900_IRQ_MAP
suffix:semicolon
multiline_comment|/* fixed IRQ map for CS8900 */
)brace
r_else
(brace
r_int
id|irq_map_buff
(braket
id|IRQ_MAP_LEN
op_div
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_eeprom_data
c_func
(paren
id|dev
comma
id|IRQ_MAP_EEPROM_DATA
comma
id|IRQ_MAP_LEN
op_div
l_int|2
comma
id|irq_map_buff
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq_map_buff
(braket
l_int|0
)braket
op_amp
l_int|0xff
)paren
op_eq
id|PNP_IRQ_FRMT
)paren
id|lp-&gt;irq_map
op_assign
(paren
id|irq_map_buff
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
op_or
(paren
id|irq_map_buff
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
id|dev-&gt;irq
op_assign
id|i
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; IRQ %d&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#if ALLOW_DMA
r_if
c_cond
(paren
id|lp-&gt;use_dma
)paren
(brace
id|get_dma_channel
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, DMA %d&quot;
comma
id|dev-&gt;dma
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|printk
c_func
(paren
l_string|&quot;, programmed I/O&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* print the ethernet address. */
id|printk
c_func
(paren
l_string|&quot;, MAC &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%02x&quot;
comma
id|i
ques
c_cond
l_string|&quot;:&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|dev-&gt;open
op_assign
id|net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|net_close
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|net_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|net_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|set_mac_address
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
l_string|&quot;cs89x0_probe1() successful&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out2
suffix:colon
id|release_region
c_func
(paren
id|ioaddr
comma
id|NETCARD_IO_EXTENT
)paren
suffix:semicolon
id|out1
suffix:colon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
"&f;"
multiline_comment|/*********************************&n; * This page contains DMA routines&n;**********************************/
macro_line|#if ALLOW_DMA
DECL|macro|dma_page_eq
mdefine_line|#define dma_page_eq(ptr1, ptr2) ((long)(ptr1)&gt;&gt;17 == (long)(ptr2)&gt;&gt;17)
r_static
r_void
DECL|function|get_dma_channel
id|get_dma_channel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;dma
)paren
(brace
id|dev-&gt;dma
op_assign
id|lp-&gt;dma
suffix:semicolon
id|lp-&gt;isa_config
op_or_assign
id|ISA_RxDMA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;isa_config
op_amp
id|ANY_ISA_DMA
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|dev-&gt;dma
op_assign
id|lp-&gt;isa_config
op_amp
id|DMA_NO_MASK
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
)paren
id|dev-&gt;dma
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dma
template_param
l_int|7
)paren
(brace
id|lp-&gt;isa_config
op_and_assign
op_complement
id|ANY_ISA_DMA
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|write_dma
id|write_dma
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|chip_type
comma
r_int
id|dma
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;isa_config
op_amp
id|ANY_ISA_DMA
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|chip_type
op_eq
id|CS8900
)paren
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_CS8900_ISADMA
comma
id|dma
op_minus
l_int|5
)paren
suffix:semicolon
)brace
r_else
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_CS8920_ISADMA
comma
id|dma
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|set_dma_cfg
id|set_dma_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;use_dma
)paren
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;isa_config
op_amp
id|ANY_ISA_DMA
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;set_dma_cfg(): no DMA&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;isa_config
op_amp
id|ISA_RxDMA
)paren
(brace
id|lp-&gt;curr_rx_cfg
op_or_assign
id|RX_DMA_ONLY
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;set_dma_cfg(): RX_DMA_ONLY&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;curr_rx_cfg
op_or_assign
id|AUTO_RX_DMA
suffix:semicolon
multiline_comment|/* not that we support it... */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;set_dma_cfg(): AUTO_RX_DMA&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|dma_bufcfg
id|dma_bufcfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;use_dma
)paren
r_return
(paren
id|lp-&gt;isa_config
op_amp
id|ANY_ISA_DMA
)paren
ques
c_cond
id|RX_DMA_ENBL
suffix:colon
l_int|0
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|dma_busctl
id|dma_busctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;use_dma
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;isa_config
op_amp
id|ANY_ISA_DMA
)paren
id|retval
op_or_assign
id|RESET_RX_DMA
suffix:semicolon
multiline_comment|/* Reset the DMA pointer */
r_if
c_cond
(paren
id|lp-&gt;isa_config
op_amp
id|DMA_BURST
)paren
id|retval
op_or_assign
id|DMA_BURST_MODE
suffix:semicolon
multiline_comment|/* Does ISA config specify DMA burst ? */
r_if
c_cond
(paren
id|lp-&gt;dmasize
op_eq
l_int|64
)paren
id|retval
op_or_assign
id|RX_DMA_SIZE_64K
suffix:semicolon
multiline_comment|/* did they ask for 64K? */
id|retval
op_or_assign
id|MEMORY_ON
suffix:semicolon
multiline_comment|/* we need memory enabled to use DMA. */
)brace
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|dma_rx
id|dma_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|status
comma
id|length
suffix:semicolon
r_int
r_char
op_star
id|bp
op_assign
id|lp-&gt;rx_dma_ptr
suffix:semicolon
id|status
op_assign
id|bp
(braket
l_int|0
)braket
op_plus
(paren
id|bp
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|length
op_assign
id|bp
(braket
l_int|2
)braket
op_plus
(paren
id|bp
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|bp
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: receiving DMA packet at %lx, status %x, length %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|bp
comma
id|status
comma
id|length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|RX_OK
)paren
op_eq
l_int|0
)paren
(brace
id|count_rx_errors
c_func
(paren
id|status
comma
id|lp
)paren
suffix:semicolon
r_goto
id|skip_this_frame
suffix:semicolon
)brace
multiline_comment|/* Malloc up new buffer. */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|net_debug
)paren
multiline_comment|/* I don&squot;t think we want to do this to a stressed system */
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* AKPM: advance bp to the next frame */
id|skip_this_frame
suffix:colon
id|bp
op_add_assign
(paren
id|length
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ge
id|lp-&gt;end_dma_buff
)paren
id|bp
op_sub_assign
id|lp-&gt;dmasize
op_star
l_int|1024
suffix:semicolon
id|lp-&gt;rx_dma_ptr
op_assign
id|bp
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* longword align L3 header */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_plus
id|length
OG
id|lp-&gt;end_dma_buff
)paren
(brace
r_int
id|semi_cnt
op_assign
id|lp-&gt;end_dma_buff
op_minus
id|bp
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|semi_cnt
)paren
comma
id|bp
comma
id|semi_cnt
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
op_minus
id|semi_cnt
)paren
comma
id|lp-&gt;dma_buff
comma
id|length
op_minus
id|semi_cnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
comma
id|bp
comma
id|length
)paren
suffix:semicolon
)brace
id|bp
op_add_assign
(paren
id|length
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ge
id|lp-&gt;end_dma_buff
)paren
id|bp
op_sub_assign
id|lp-&gt;dmasize
op_star
l_int|1024
suffix:semicolon
id|lp-&gt;rx_dma_ptr
op_assign
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: received %d byte DMA packet of type %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
comma
(paren
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;/* ALLOW_DMA */
DECL|function|reset_chip
r_void
id|__init
id|reset_chip
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|reset_start_time
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_SelfCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfCTL
)paren
op_or
id|POWER_ON_RESET
)paren
suffix:semicolon
multiline_comment|/* wait 30 ms */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|30
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_ne
id|CS8900
)paren
(brace
multiline_comment|/* Hardware problem requires PNP registers to be reconfigured after a reset */
id|outw
c_func
(paren
id|PP_CS8920_ISAINT
comma
id|ioaddr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;irq
comma
id|ioaddr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DATA_PORT
op_plus
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PP_CS8920_ISAMemB
comma
id|ioaddr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|ioaddr
op_plus
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|ioaddr
op_plus
id|DATA_PORT
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait until the chip is reset */
id|reset_start_time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_SelfST
)paren
op_amp
id|INIT_DONE
)paren
op_eq
l_int|0
op_logical_and
id|jiffies
op_minus
id|reset_start_time
OL
l_int|2
)paren
(brace
suffix:semicolon
)brace
)brace
"&f;"
r_static
r_void
DECL|function|control_dc_dc
id|control_dc_dc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|on_not_off
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|selfcontrol
suffix:semicolon
r_int
id|timenow
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* control the DC to DC convertor in the SelfControl register.  &n;&t;   Note: This is hooked up to a general purpose pin, might not&n;&t;   always be a DC to DC convertor. */
id|selfcontrol
op_assign
id|HCB1_ENBL
suffix:semicolon
multiline_comment|/* Enable the HCB1 bit as an output */
r_if
c_cond
(paren
(paren
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_DC_DC_POLARITY
)paren
op_ne
l_int|0
)paren
op_xor
id|on_not_off
)paren
id|selfcontrol
op_or_assign
id|HCB1
suffix:semicolon
r_else
id|selfcontrol
op_and_assign
op_complement
id|HCB1
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_SelfCTL
comma
id|selfcontrol
)paren
suffix:semicolon
multiline_comment|/* Wait for the DC/DC converter to power up - 500ms */
r_while
c_loop
(paren
id|jiffies
op_minus
id|timenow
OL
id|HZ
)paren
suffix:semicolon
)brace
DECL|macro|DETECTED_NONE
mdefine_line|#define DETECTED_NONE  0
DECL|macro|DETECTED_RJ45H
mdefine_line|#define DETECTED_RJ45H 1
DECL|macro|DETECTED_RJ45F
mdefine_line|#define DETECTED_RJ45F 2
DECL|macro|DETECTED_AUI
mdefine_line|#define DETECTED_AUI   3
DECL|macro|DETECTED_BNC
mdefine_line|#define DETECTED_BNC   4
r_static
r_int
DECL|function|detect_tp
id|detect_tp
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|timenow
op_assign
id|jiffies
suffix:semicolon
r_int
id|fdx
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Attempting TP&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* If connected to another full duplex capable 10-Base-T card the link pulses&n;           seem to be lost when the auto detect bit in the LineCTL is set.&n;           To overcome this the auto detect bit will be cleared whilst testing the&n;           10-Base-T interface.  This would not be necessary for the sparrow chip but&n;           is simpler to do it anyway. */
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|lp-&gt;linectl
op_amp
op_complement
id|AUI_ONLY
)paren
suffix:semicolon
id|control_dc_dc
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Delay for the hardware to work out if the TP cable is present - 150ms */
r_for
c_loop
(paren
id|timenow
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_minus
id|timenow
OL
l_int|15
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineST
)paren
op_amp
id|LINK_OK
)paren
op_eq
l_int|0
)paren
r_return
id|DETECTED_NONE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chip_type
op_eq
id|CS8900
)paren
(brace
r_switch
c_cond
(paren
id|lp-&gt;force
op_amp
l_int|0xf0
)paren
(brace
macro_line|#if 0
r_case
id|FORCE_AUTO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: cs8900 doesn&squot;t autonegotiate&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|DETECTED_NONE
suffix:semicolon
macro_line|#endif
multiline_comment|/* CS8900 doesn&squot;t support AUTO, change to HALF*/
r_case
id|FORCE_AUTO
suffix:colon
id|lp-&gt;force
op_and_assign
op_complement
id|FORCE_AUTO
suffix:semicolon
id|lp-&gt;force
op_or_assign
id|FORCE_HALF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FORCE_HALF
suffix:colon
r_break
suffix:semicolon
r_case
id|FORCE_FULL
suffix:colon
id|writereg
c_func
(paren
id|dev
comma
id|PP_TestCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_TestCTL
)paren
op_or
id|FDX_8900
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fdx
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_TestCTL
)paren
op_amp
id|FDX_8900
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|lp-&gt;force
op_amp
l_int|0xf0
)paren
(brace
r_case
id|FORCE_AUTO
suffix:colon
id|lp-&gt;auto_neg_cnf
op_assign
id|AUTO_NEG_ENABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FORCE_HALF
suffix:colon
id|lp-&gt;auto_neg_cnf
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FORCE_FULL
suffix:colon
id|lp-&gt;auto_neg_cnf
op_assign
id|RE_NEG_NOW
op_or
id|ALLOW_FDX
suffix:semicolon
r_break
suffix:semicolon
)brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_AutoNegCTL
comma
id|lp-&gt;auto_neg_cnf
op_amp
id|AUTO_NEG_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|AUTO_NEG_BITS
)paren
op_eq
id|AUTO_NEG_ENABLE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: negotiating duplex...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_AutoNegST
)paren
op_amp
id|AUTO_NEG_BUSY
)paren
(brace
r_if
c_cond
(paren
id|jiffies
op_minus
id|timenow
OG
l_int|4000
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;**** Full / half duplex auto-negotiation timed out ****&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|fdx
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_AutoNegST
)paren
op_amp
id|FDX_ACTIVE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdx
)paren
r_return
id|DETECTED_RJ45F
suffix:semicolon
r_else
r_return
id|DETECTED_RJ45H
suffix:semicolon
)brace
multiline_comment|/* send a test packet - return true if carrier bits are ok */
r_static
r_int
DECL|function|send_test_pkt
id|send_test_pkt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_char
id|test_packet
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|46
comma
multiline_comment|/* A 46 in network order */
l_int|0
comma
l_int|0
comma
multiline_comment|/* DSAP=0 &amp; SSAP=0 fields */
l_int|0xf3
comma
l_int|0
multiline_comment|/* Control (Test Req + P bit set) */
)brace
suffix:semicolon
r_int
id|timenow
op_assign
id|jiffies
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
op_or
id|SERIAL_TX_ON
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|test_packet
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|test_packet
op_plus
id|ETH_ALEN
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|writeword
c_func
(paren
id|dev
comma
id|TX_CMD_PORT
comma
id|TX_AFTER_ALL
)paren
suffix:semicolon
id|writeword
c_func
(paren
id|dev
comma
id|TX_LEN_PORT
comma
id|ETH_ZLEN
)paren
suffix:semicolon
multiline_comment|/* Test to see if the chip has allocated memory for the packet */
r_while
c_loop
(paren
id|jiffies
op_minus
id|timenow
OL
l_int|5
)paren
r_if
c_cond
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_BusST
)paren
op_amp
id|READY_FOR_TX_NOW
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|timenow
op_ge
l_int|5
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* this shouldn&squot;t happen */
multiline_comment|/* Write the contents of the packet */
id|outsw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TX_FRAME_PORT
comma
id|test_packet
comma
(paren
id|ETH_ZLEN
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Sending test packet &quot;
)paren
suffix:semicolon
multiline_comment|/* wait a couple of jiffies for packet to be received */
r_for
c_loop
(paren
id|timenow
op_assign
id|jiffies
suffix:semicolon
id|jiffies
op_minus
id|timenow
OL
l_int|3
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_TxEvent
)paren
op_amp
id|TX_SEND_OK_BITS
)paren
op_eq
id|TX_OK
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;succeeded&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|detect_aui
id|detect_aui
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Attempting AUI&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|control_dc_dc
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
(paren
id|lp-&gt;linectl
op_amp
op_complement
id|AUTO_AUI_10BASET
)paren
op_or
id|AUI_ONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_test_pkt
c_func
(paren
id|dev
)paren
)paren
r_return
id|DETECTED_AUI
suffix:semicolon
r_else
r_return
id|DETECTED_NONE
suffix:semicolon
)brace
r_static
r_int
DECL|function|detect_bnc
id|detect_bnc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Attempting BNC&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|control_dc_dc
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
(paren
id|lp-&gt;linectl
op_amp
op_complement
id|AUTO_AUI_10BASET
)paren
op_or
id|AUI_ONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_test_pkt
c_func
(paren
id|dev
)paren
)paren
r_return
id|DETECTED_BNC
suffix:semicolon
r_else
r_return
id|DETECTED_NONE
suffix:semicolon
)brace
"&f;"
r_static
r_void
DECL|function|write_irq
id|write_irq
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|chip_type
comma
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|chip_type
op_eq
id|CS8900
)paren
(brace
multiline_comment|/* Search the mapping table for the corresponding IRQ pin. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_ne
r_sizeof
(paren
id|cs8900_irq_map
)paren
op_div
r_sizeof
(paren
id|cs8900_irq_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cs8900_irq_map
(braket
id|i
)braket
op_eq
id|irq
)paren
r_break
suffix:semicolon
multiline_comment|/* Not found */
r_if
c_cond
(paren
id|i
op_eq
r_sizeof
(paren
id|cs8900_irq_map
)paren
op_div
r_sizeof
(paren
id|cs8900_irq_map
(braket
l_int|0
)braket
)paren
)paren
id|i
op_assign
l_int|3
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_CS8900_ISAINT
comma
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_CS8920_ISAINT
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;   */
multiline_comment|/* AKPM: do we need to do any locking here? */
r_static
r_int
DECL|function|net_open
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
multiline_comment|/* Allow interrupts to be generated by the chip */
multiline_comment|/* Cirrus&squot; release had this: */
macro_line|#if 0
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_BusCTL
)paren
op_or
id|ENABLE_IRQ
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* And 2.3.47 had this: */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|ENABLE_IRQ
op_or
id|MEMORY_ON
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|CS8920_NO_INTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|dev-&gt;irq
)paren
op_amp
id|lp-&gt;irq_map
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|i
comma
id|net_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;irq
op_assign
id|i
suffix:semicolon
id|write_irq
c_func
(paren
id|dev
comma
id|lp-&gt;chip_type
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* writereg(dev, PP_BufCFG, GENERATE_SW_INTERRUPT); */
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|CS8920_NO_INTS
)paren
(brace
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable interrupts. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs89x0: can&squot;t get an interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|bad_out
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|dev-&gt;irq
)paren
op_amp
id|lp-&gt;irq_map
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: IRQ %d is not in our map of allowable IRQs, which is %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|lp-&gt;irq_map
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|bad_out
suffix:semicolon
)brace
multiline_comment|/* FIXME: Cirrus&squot; release had this: */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_BusCTL
)paren
op_or
id|ENABLE_IRQ
)paren
suffix:semicolon
multiline_comment|/* And 2.3.47 had this: */
macro_line|#if 0
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|ENABLE_IRQ
op_or
id|MEMORY_ON
)paren
suffix:semicolon
macro_line|#endif
id|write_irq
c_func
(paren
id|dev
comma
id|lp-&gt;chip_type
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|net_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs89x0: request_irq(%d) failed&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_goto
id|bad_out
suffix:semicolon
)brace
)brace
macro_line|#if ALLOW_DMA
r_if
c_cond
(paren
id|lp-&gt;use_dma
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;isa_config
op_amp
id|ANY_ISA_DMA
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|lp-&gt;dma_buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
(paren
id|lp-&gt;dmasize
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;dma_buff
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: cannot get %dK memory for DMA&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;dmasize
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: dma %lx %lx&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|lp-&gt;dma_buff
comma
(paren
r_int
r_int
)paren
id|virt_to_bus
c_func
(paren
id|lp-&gt;dma_buff
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|virt_to_bus
c_func
(paren
id|lp-&gt;dma_buff
)paren
op_ge
id|MAX_DMA_ADDRESS
op_logical_or
op_logical_neg
id|dma_page_eq
c_func
(paren
id|lp-&gt;dma_buff
comma
id|lp-&gt;dma_buff
op_plus
id|lp-&gt;dmasize
op_star
l_int|1024
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: not usable as DMA buffer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lp-&gt;dma_buff
comma
l_int|0
comma
id|lp-&gt;dmasize
op_star
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* Why? */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dev-&gt;dma
comma
id|dev-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: cannot get dma channel %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;dma
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
)brace
id|write_dma
c_func
(paren
id|dev
comma
id|lp-&gt;chip_type
comma
id|dev-&gt;dma
)paren
suffix:semicolon
id|lp-&gt;rx_dma_ptr
op_assign
id|lp-&gt;dma_buff
suffix:semicolon
id|lp-&gt;end_dma_buff
op_assign
id|lp-&gt;dma_buff
op_plus
id|lp-&gt;dmasize
op_star
l_int|1024
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dev-&gt;dma
comma
l_int|0x14
)paren
suffix:semicolon
multiline_comment|/* auto_init as well */
id|set_dma_addr
c_func
(paren
id|dev-&gt;dma
comma
id|virt_to_bus
c_func
(paren
id|lp-&gt;dma_buff
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dev-&gt;dma
comma
id|lp-&gt;dmasize
op_star
l_int|1024
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* ALLOW_DMA */
multiline_comment|/* set the Ethernet address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|writereg
c_func
(paren
id|dev
comma
id|PP_IA
op_plus
id|i
op_star
l_int|2
comma
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* while we&squot;re testing the interface, leave interrupts disabled */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|MEMORY_ON
)paren
suffix:semicolon
multiline_comment|/* Set the LineCTL quintuplet based on adapter configuration read from EEPROM */
r_if
c_cond
(paren
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_EXTND_10B_2
)paren
op_logical_and
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_LOW_RX_SQUELCH
)paren
)paren
id|lp-&gt;linectl
op_assign
id|LOW_RX_SQUELCH
suffix:semicolon
r_else
id|lp-&gt;linectl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check to make sure that they have the &quot;right&quot; hardware available */
r_switch
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_MEDIA_TYPE
)paren
(brace
r_case
id|A_CNF_MEDIA_10B_T
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_T
suffix:semicolon
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUI
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_AUI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_10B_2
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
id|lp-&gt;adapter_cnf
op_amp
(paren
id|A_CNF_10B_T
op_or
id|A_CNF_AUI
op_or
id|A_CNF_10B_2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: EEPROM is configured for unavailable media&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|release_irq
suffix:colon
macro_line|#if ALLOW_DMA
id|release_dma_buff
c_func
(paren
id|lp
)paren
suffix:semicolon
macro_line|#endif
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
op_amp
op_complement
(paren
id|SERIAL_TX_ON
op_or
id|SERIAL_RX_ON
)paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|bad_out
suffix:semicolon
)brace
multiline_comment|/* set the hardware to the configured choice */
r_switch
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_MEDIA_TYPE
)paren
(brace
r_case
id|A_CNF_MEDIA_10B_T
suffix:colon
id|result
op_assign
id|detect_tp
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|DETECTED_NONE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: 10Base-T (RJ-45) has no cable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|IMM_BIT
)paren
multiline_comment|/* check &quot;ignore missing media&quot; bit */
id|result
op_assign
id|DETECTED_RJ45H
suffix:semicolon
multiline_comment|/* Yes! I don&squot;t care if I see a link pulse */
)brace
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUI
suffix:colon
id|result
op_assign
id|detect_aui
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|DETECTED_NONE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: 10Base-5 (AUI) has no cable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|IMM_BIT
)paren
multiline_comment|/* check &quot;ignore missing media&quot; bit */
id|result
op_assign
id|DETECTED_AUI
suffix:semicolon
multiline_comment|/* Yes! I don&squot;t care if I see a carrrier */
)brace
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_10B_2
suffix:colon
id|result
op_assign
id|detect_bnc
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|DETECTED_NONE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: 10Base-2 (BNC) has no cable&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;auto_neg_cnf
op_amp
id|IMM_BIT
)paren
multiline_comment|/* check &quot;ignore missing media&quot; bit */
id|result
op_assign
id|DETECTED_BNC
suffix:semicolon
multiline_comment|/* Yes! I don&squot;t care if I can xmit a packet */
)brace
r_break
suffix:semicolon
r_case
id|A_CNF_MEDIA_AUTO
suffix:colon
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|lp-&gt;linectl
op_or
id|AUTO_AUI_10BASET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_T
)paren
r_if
c_cond
(paren
(paren
id|result
op_assign
id|detect_tp
c_func
(paren
id|dev
)paren
)paren
op_ne
id|DETECTED_NONE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_AUI
)paren
r_if
c_cond
(paren
(paren
id|result
op_assign
id|detect_aui
c_func
(paren
id|dev
)paren
)paren
op_ne
id|DETECTED_NONE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_cnf
op_amp
id|A_CNF_10B_2
)paren
r_if
c_cond
(paren
(paren
id|result
op_assign
id|detect_bnc
c_func
(paren
id|dev
)paren
)paren
op_ne
id|DETECTED_NONE
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no media detected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|DETECTED_NONE
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no network cable attached to configured media&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|release_irq
suffix:semicolon
r_case
id|DETECTED_RJ45H
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using half-duplex 10Base-T (RJ-45)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DETECTED_RJ45F
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using full-duplex 10Base-T (RJ-45)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DETECTED_AUI
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using 10Base-5 (AUI)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DETECTED_BNC
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using 10Base-2 (BNC)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Turn on both receive and transmit operations */
id|writereg
c_func
(paren
id|dev
comma
id|PP_LineCTL
comma
id|readreg
c_func
(paren
id|dev
comma
id|PP_LineCTL
)paren
op_or
id|SERIAL_RX_ON
op_or
id|SERIAL_TX_ON
)paren
suffix:semicolon
multiline_comment|/* Receive only error free packets addressed to this card */
id|lp-&gt;rx_mode
op_assign
l_int|0
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCTL
comma
id|DEF_RX_ACCEPT
)paren
suffix:semicolon
id|lp-&gt;curr_rx_cfg
op_assign
id|RX_OK_ENBL
op_or
id|RX_CRC_ERROR_ENBL
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;isa_config
op_amp
id|STREAM_TRANSFER
)paren
id|lp-&gt;curr_rx_cfg
op_or_assign
id|RX_STREAM_ENBL
suffix:semicolon
macro_line|#if ALLOW_DMA
id|set_dma_cfg
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCFG
comma
id|lp-&gt;curr_rx_cfg
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_TxCFG
comma
id|TX_LOST_CRS_ENBL
op_or
id|TX_SQE_ERROR_ENBL
op_or
id|TX_OK_ENBL
op_or
id|TX_LATE_COL_ENBL
op_or
id|TX_JBR_ENBL
op_or
id|TX_ANY_COL_ENBL
op_or
id|TX_16_COL_ENBL
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BufCFG
comma
id|READY_FOR_TX_ENBL
op_or
id|RX_MISS_COUNT_OVRFLOW_ENBL
op_or
macro_line|#if ALLOW_DMA
id|dma_bufcfg
c_func
(paren
id|dev
)paren
op_or
macro_line|#endif
id|TX_COL_COUNT_OVRFLOW_ENBL
op_or
id|TX_UNDERRUN_ENBL
)paren
suffix:semicolon
multiline_comment|/* now that we&squot;ve got our act together, enable everything */
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
id|ENABLE_IRQ
op_or
(paren
id|dev-&gt;mem_start
ques
c_cond
id|MEMORY_ON
suffix:colon
l_int|0
)paren
multiline_comment|/* turn memory on */
macro_line|#if ALLOW_DMA
op_or
id|dma_busctl
c_func
(paren
id|dev
)paren
macro_line|#endif
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;cs89x0: net_open() succeeded&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|net_timeout
r_static
r_void
id|net_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ conflict ?&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|net_send_packet
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: sent %d byte packet of type %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|skb-&gt;len
comma
(paren
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* keep the upload from being interrupted, since we&n;                  ask the chip to start transmitting before the&n;                  whole packet has been completely uploaded. */
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* initiate a transmit sequence */
id|writeword
c_func
(paren
id|dev
comma
id|TX_CMD_PORT
comma
id|lp-&gt;send_cmd
)paren
suffix:semicolon
id|writeword
c_func
(paren
id|dev
comma
id|TX_LEN_PORT
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Test to see if the chip has allocated memory for the packet */
r_if
c_cond
(paren
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_BusST
)paren
op_amp
id|READY_FOR_TX_NOW
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Gasp!  It hasn&squot;t.  But that shouldn&squot;t happen since&n;&t;&t; * we&squot;re waiting for TxOk, so return 1 and requeue this packet.&n;&t;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
l_string|&quot;cs89x0: Tx buffer not free!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Write the contents of the packet */
id|outsw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TX_FRAME_PORT
comma
id|skb-&gt;data
comma
(paren
id|skb-&gt;len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We DO NOT call netif_wake_queue() here.&n;&t; * We also DO NOT call netif_start_queue().&n;&t; *&n;&t; * Either of these would cause another bottom half run through&n;&t; * net_send_packet() before this packet has fully gone out.  That causes&n;&t; * us to hit the &quot;Gasp!&quot; above and the send is rescheduled.  it runs like&n;&t; * a dog.  We just return and wait for the Tx completion interrupt handler&n;&t; * to restart the netdevice layer&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
DECL|function|net_interrupt
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* we MUST read all the events out of the ISQ, otherwise we&squot;ll never&n;           get interrupted again.  As a consequence, we can&squot;t have any limit&n;           on the number of times we loop in the interrupt handler.  The&n;           hardware guarantees that eventually we&squot;ll run out of events.  Of&n;           course, if you&squot;re on a slow machine, and packets are arriving&n;           faster than you can read them off, you&squot;re screwed.  Hasta la&n;           vista, baby!  */
r_while
c_loop
(paren
(paren
id|status
op_assign
id|readword
c_func
(paren
id|dev
comma
id|ISQ_PORT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: event=%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
op_amp
id|ISQ_EVENT_MASK
)paren
(brace
r_case
id|ISQ_RECEIVER_EVENT
suffix:colon
multiline_comment|/* Got a packet(s). */
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISQ_TRANSMITTER_EVENT
suffix:colon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|TX_OK
op_or
id|TX_LOST_CRS
op_or
id|TX_SQE_ERROR
op_or
id|TX_LATE_COL
op_or
id|TX_16_COL
)paren
)paren
op_ne
id|TX_OK
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|TX_OK
)paren
op_eq
l_int|0
)paren
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_LOST_CRS
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_SQE_ERROR
)paren
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_LATE_COL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TX_16_COL
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ISQ_BUFFER_EVENT
suffix:colon
r_if
c_cond
(paren
id|status
op_amp
id|READY_FOR_TX
)paren
(brace
multiline_comment|/* we tried to transmit a packet earlier,&n;                                   but inexplicably ran out of buffers.&n;                                   That shouldn&squot;t happen since we only ever&n;                                   load one packet.  Shrug.  Do the right&n;                                   thing anyway. */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TX_UNDERRUN
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit underrun&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;send_underrun
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;send_underrun
op_eq
l_int|3
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_AFTER_381
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lp-&gt;send_underrun
op_eq
l_int|6
)paren
id|lp-&gt;send_cmd
op_assign
id|TX_AFTER_ALL
suffix:semicolon
multiline_comment|/* transmit cycle is done, although&n;&t;&t;&t;&t;   frame wasn&squot;t transmitted - this&n;&t;&t;&t;&t;   avoids having to wait for the upper&n;&t;&t;&t;&t;   layers to timeout on us, in the&n;&t;&t;&t;&t;   event of a tx underrun */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
macro_line|#if ALLOW_DMA
r_if
c_cond
(paren
id|lp-&gt;use_dma
op_logical_and
(paren
id|status
op_amp
id|RX_DMA
)paren
)paren
(brace
r_int
id|count
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_DmaFrameCnt
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: receiving %d DMA frames&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
op_logical_and
id|count
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: receiving %d DMA frames&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|count
)paren
suffix:semicolon
id|dma_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|count
op_eq
l_int|0
)paren
id|count
op_assign
id|readreg
c_func
(paren
id|dev
comma
id|PP_DmaFrameCnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
op_logical_and
id|count
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: continuing with %d DMA frames&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|count
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
id|ISQ_RX_MISS_EVENT
suffix:colon
id|lp-&gt;stats.rx_missed_errors
op_add_assign
(paren
id|status
op_rshift
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISQ_TX_COL_EVENT
suffix:colon
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|status
op_rshift
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|count_rx_errors
id|count_rx_errors
c_func
(paren
r_int
id|status
comma
r_struct
id|net_local
op_star
id|lp
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_RUNT
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_EXTRA_DATA
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_CRC_ERROR
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
(paren
id|RX_EXTRA_DATA
op_or
id|RX_RUNT
)paren
)paren
)paren
multiline_comment|/* per str 172 */
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_DRIBBLE
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
r_static
r_void
DECL|function|net_rx
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|status
comma
id|length
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
)paren
suffix:semicolon
id|length
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|RX_OK
)paren
op_eq
l_int|0
)paren
(brace
id|count_rx_errors
c_func
(paren
id|status
comma
id|lp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Malloc up new buffer. */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
macro_line|#if 0&t;&t;/* Again, this seems a cruel thing to do */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* longword align L3 header */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
comma
id|length
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
op_amp
l_int|1
)paren
id|skb-&gt;data
(braket
id|length
op_minus
l_int|1
)braket
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RX_FRAME_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: received %d byte packet of type %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
comma
(paren
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
id|ETH_ALEN
op_plus
id|ETH_ALEN
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if ALLOW_DMA
DECL|function|release_dma_buff
r_static
r_void
id|release_dma_buff
c_func
(paren
r_struct
id|net_local
op_star
id|lp
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;dma_buff
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|lp-&gt;dma_buff
)paren
comma
(paren
id|lp-&gt;dmasize
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
)paren
suffix:semicolon
id|lp-&gt;dma_buff
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|net_close
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCFG
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_TxCFG
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BufCFG
comma
l_int|0
)paren
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_BusCTL
comma
l_int|0
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
macro_line|#if ALLOW_DMA
r_if
c_cond
(paren
id|lp-&gt;use_dma
op_logical_and
id|lp-&gt;dma
)paren
(brace
id|free_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|release_dma_buff
c_func
(paren
id|lp
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|net_get_stats
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Update the statistics from the device registers. */
id|lp-&gt;stats.rx_missed_errors
op_add_assign
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_RxMiss
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|readreg
c_func
(paren
id|dev
comma
id|PP_TxCol
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|lp-&gt;rx_mode
op_assign
id|RX_ALL_ACCEPT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_list
)paren
(brace
multiline_comment|/* The multicast-accept list is initialized to accept-all, and we&n;&t;&t;   rely on higher-level filtering for now. */
id|lp-&gt;rx_mode
op_assign
id|RX_MULTCAST_ACCEPT
suffix:semicolon
)brace
r_else
id|lp-&gt;rx_mode
op_assign
l_int|0
suffix:semicolon
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCTL
comma
id|DEF_RX_ACCEPT
op_or
id|lp-&gt;rx_mode
)paren
suffix:semicolon
multiline_comment|/* in promiscuous mode, we accept errored packets, so we have to enable interrupts on them also */
id|writereg
c_func
(paren
id|dev
comma
id|PP_RxCFG
comma
id|lp-&gt;curr_rx_cfg
op_or
(paren
id|lp-&gt;rx_mode
op_eq
id|RX_ALL_ACCEPT
ques
c_cond
(paren
id|RX_CRC_ERROR_ENBL
op_or
id|RX_RUNT_ENBL
op_or
id|RX_EXTRA_DATA_ENBL
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|set_mac_address
r_static
r_int
id|set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Setting MAC address to &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|addr
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* set the Ethernet address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|writereg
c_func
(paren
id|dev
comma
id|PP_IA
op_plus
id|i
op_star
l_int|2
comma
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_or
(paren
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|dev_cs89x0
r_static
r_struct
id|net_device
id|dev_cs89x0
op_assign
(brace
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Support the &squot;debug&squot; module parm even if we&squot;re compiled for non-debug to &n; * avoid breaking someone&squot;s startup scripts &n; */
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|media
r_static
r_char
id|media
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|duplex
r_static
r_int
id|duplex
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|use_dma
r_static
r_int
id|use_dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These generate unused var warnings if ALLOW_DMA = 0 */
DECL|variable|dma
r_static
r_int
id|dma
op_assign
l_int|0
suffix:semicolon
DECL|variable|dmasize
r_static
r_int
id|dmasize
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* or 64 */
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|media
comma
l_string|&quot;c8&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|duplex
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dmasize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|use_dma
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Mike Cruse, Russwll Nelson &lt;nelson@crynwr.com&gt;, Andrew Morton &lt;andrewm@uow.edu.au&gt;&quot;
)paren
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
multiline_comment|/*&n;* media=t             - specify media type&n;   or media=2&n;   or media=aui&n;   or medai=auto&n;* duplex=0            - specify forced half/full/autonegotiate duplex&n;* debug=#             - debug level&n;&n;&n;* Default Chip Configuration:&n;  * DMA Burst = enabled&n;  * IOCHRDY Enabled = enabled&n;    * UseSA = enabled&n;    * CS8900 defaults to half-duplex if not specified on command-line&n;    * CS8920 defaults to autoneg if not specified on command-line&n;    * Use reset defaults for other config parameters&n;&n;* Assumptions:&n;  * media type specified is supported (circuitry is present)&n;  * if memory address is &gt; 1MB, then required mem decode hw is present&n;  * if 10B-2, then agent other than driver will enable DC/DC converter&n;    (hw or software util)&n;&n;&n;*/
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUGGING
id|net_debug
op_assign
id|debug
suffix:semicolon
macro_line|#else
id|debug
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|dev_cs89x0.irq
op_assign
id|irq
suffix:semicolon
id|dev_cs89x0.base_addr
op_assign
id|io
suffix:semicolon
id|dev_cs89x0.init
op_assign
id|cs89x0_probe
suffix:semicolon
id|dev_cs89x0.priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_cs89x0.priv
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs89x0.c: Out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev_cs89x0.priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev_cs89x0.priv
suffix:semicolon
macro_line|#if ALLOW_DMA
r_if
c_cond
(paren
id|use_dma
)paren
(brace
id|lp-&gt;use_dma
op_assign
id|use_dma
suffix:semicolon
id|lp-&gt;dma
op_assign
id|dma
suffix:semicolon
id|lp-&gt;dmasize
op_assign
id|dmasize
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* boy, they&squot;d better get these right */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|media
comma
l_string|&quot;rj45&quot;
)paren
)paren
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_10B_T
op_or
id|A_CNF_10B_T
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|media
comma
l_string|&quot;aui&quot;
)paren
)paren
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_AUI
op_or
id|A_CNF_AUI
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|media
comma
l_string|&quot;bnc&quot;
)paren
)paren
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_10B_2
op_or
id|A_CNF_10B_2
suffix:semicolon
r_else
id|lp-&gt;adapter_cnf
op_assign
id|A_CNF_MEDIA_10B_T
op_or
id|A_CNF_10B_T
suffix:semicolon
r_if
c_cond
(paren
id|duplex
op_eq
op_minus
l_int|1
)paren
id|lp-&gt;auto_neg_cnf
op_assign
id|AUTO_NEG_ENABLE
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs89x0.c: Module autoprobing not allowed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs89x0.c: Append io=0xNNN&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#if ALLOW_DMA
r_if
c_cond
(paren
id|use_dma
op_logical_and
id|dmasize
op_ne
l_int|16
op_logical_and
id|dmasize
op_ne
l_int|64
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs89x0.c: dma size must be either 16K or 64K, not %dK&bslash;n&quot;
comma
id|dmasize
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_cs89x0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs89x0.c: No card found at 0x%x&bslash;n&quot;
comma
id|io
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|ret
)paren
id|kfree
c_func
(paren
id|dev_cs89x0.priv
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|outw
c_func
(paren
id|PP_ChipID
comma
id|dev_cs89x0.base_addr
op_plus
id|ADD_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_cs89x0.priv
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Free up the private structure, or leak memory :-)  */
id|unregister_netdev
c_func
(paren
op_amp
id|dev_cs89x0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev_cs89x0.priv
)paren
suffix:semicolon
id|dev_cs89x0.priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* gets re-allocated by cs89x0_probe1 */
multiline_comment|/* If we don&squot;t do this, we can&squot;t re-insmod it later. */
id|release_region
c_func
(paren
id|dev_cs89x0.base_addr
comma
id|NETCARD_IO_EXTENT
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  c-indent-level: 8&n; *  tab-width: 8&n; * End:&n; *&n; */
eof
