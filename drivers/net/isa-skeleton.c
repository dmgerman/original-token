multiline_comment|/* isa-skeleton.c: A network driver outline for linux.&n; *&n; *&t;Written 1993-94 by Donald Becker.&n; *&n; *&t;Copyright 1993 United States Government as represented by the&n; *&t;Director, National Security Agency.&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU Public License, incorporated herein by reference.&n; *&n; *&t;The author may be reached as becker@CESDIS.gsfc.nasa.gov, or C/O&n; *&t;Center of Excellence in Space Data and Information Sciences&n; *&t;   Code 930.5, Goddard Space Flight Center, Greenbelt MD 20771&n; *&n; *&t;This file is an outline for writing a network device driver for the&n; *&t;the Linux operating system.&n; *&n; *&t;To write (or understand) a driver, have a look at the &quot;loopback.c&quot; file to&n; *&t;get a feel of what is going on, and then use the code below as a skeleton&n; *&t;for the new driver.&n; *&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;isa-skeleton.c:v1.51 9/24/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; *  Sources:&n; *&t;List your sources of programming information to document that&n; *&t;the driver is your own creation, and give due credit to others&n; *&t;that contributed to the work. Remember that GNU project code&n; *&t;cannot use proprietary or trade secret information. Interface&n; *&t;definitions are generally considered non-copyrightable to the&n; *&t;extent that the same names and structures must be used to be&n; *&t;compatible.&n; *&n; *&t;Finally, keep in mind that the Linux kernel is has an API, not&n; *&t;ABI. Proprietary object-code-only distributions are not permitted&n; *&t;under the GPL.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
multiline_comment|/*&n; * The name of the card. Is used for messages and in the requests for&n; * io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;netcard&quot;
suffix:semicolon
multiline_comment|/* First, a few definitions that the brave might change. */
multiline_comment|/* A zero-terminated list of I/O addresses to be probed. */
DECL|variable|__initdata
r_static
r_int
r_int
id|netcard_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x200
comma
l_int|0x240
comma
l_int|0x280
comma
l_int|0x2C0
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|NETCARD_IO_EXTENT
mdefine_line|#define NETCARD_IO_EXTENT&t;32
DECL|macro|MY_TX_TIMEOUT
mdefine_line|#define MY_TX_TIMEOUT  ((400*HZ)/1000)
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|open_time
r_int
id|open_time
suffix:semicolon
multiline_comment|/* Useless example local info. */
multiline_comment|/* Tx control lock.  This protects the transmit buffer ring&n;&t; * state along with the &quot;tx full&quot; state of the driver.  This&n;&t; * means all netif_queue flow control actions are protected&n;&t; * by this lock as well.&n;&t; */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for IDing the board. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x00
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0x42
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0x65
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|netcard_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|netcard_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Example routines you must write ;-&gt;. */
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) 1
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_int
id|ioaddr
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|chipset_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|startp
)paren
suffix:semicolon
multiline_comment|/*&n; * Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n; * If dev-&gt;base_addr == 0, probe all likely locations.&n; * If dev-&gt;base_addr == 1, always return failure.&n; * If dev-&gt;base_addr == 2, allocate space for the device and return success&n; * (detachable devices only).&n; */
r_int
id|__init
DECL|function|netcard_probe
id|netcard_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|netcard_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|netcard_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
id|netcard_portlist
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|NETCARD_IO_EXTENT
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|netcard_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the real probe routine. Linux has a history of friendly device&n; * probes on the ISA bus. A good device probes avoids doing writes, and&n; * verifies that the correct device exists and functions.&n; */
DECL|function|netcard_probe1
r_static
r_int
id|__init
id|netcard_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_local
op_star
id|np
suffix:semicolon
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * For ethernet adaptors the first three octets of the station address &n;&t; * contains the manufacturer&squot;s unique code. That might be a good probe&n;&t; * method. Ideally you would add additional checks.&n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0
)paren
op_ne
id|SA_ADDR0
op_logical_or
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
op_ne
id|SA_ADDR1
op_logical_or
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|2
)paren
op_ne
id|SA_ADDR2
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s found at %#3x, &quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* Retrieve and print the ethernet address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|i
)paren
)paren
suffix:semicolon
macro_line|#ifdef jumpered_interrupts
multiline_comment|/*&n;&t; * If this board has jumpered interrupts, allocate the interrupt&n;&t; * vector now. There is no point in waiting since no other device&n;&t; * can use the interrupt, and this marks the irq as busy. Jumpered&n;&t; * interrupts are typically not reported by the boards, and we must&n;&t; * used autoIRQ to find them.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Do nothing: a user-level program will set it. */
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
multiline_comment|/* &quot;Auto-IRQ&quot; */
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Trigger an interrupt here. */
id|dev-&gt;irq
op_assign
id|autoirq_report
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
op_ge
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot; autoirq is %d&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
multiline_comment|/*&n;&t;&t; * Fixup for users that don&squot;t know that IRQ 2 is really&n;&t;&t; * IRQ9, or don&squot;t know which one to set.&n;&t;&t; */
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
(brace
r_int
id|irqval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|net_interrupt
comma
l_int|0
comma
id|cardname
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqval
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|irqval
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* jumpered interrupt */
macro_line|#ifdef jumpered_dma
multiline_comment|/*&n;&t; * If we use a jumpered DMA channel, that should be probed for and&n;&t; * allocated here as well. See lance.c for an example.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;dma
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dev-&gt;dma
comma
id|cardname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMA %d allocation failed.&bslash;n&quot;
comma
id|dev-&gt;dma
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, assigned DMA %d.&bslash;n&quot;
comma
id|dev-&gt;dma
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|dma_status
comma
id|new_dma_status
suffix:semicolon
multiline_comment|/* Read the DMA channel status registers. */
id|dma_status
op_assign
(paren
(paren
id|inb
c_func
(paren
id|DMA1_STAT_REG
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_or
(paren
id|inb
c_func
(paren
id|DMA2_STAT_REG
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/* Trigger a DMA request, perhaps pause a bit. */
id|outw
c_func
(paren
l_int|0x1234
comma
id|ioaddr
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Re-read the DMA status registers. */
id|new_dma_status
op_assign
(paren
(paren
id|inb
c_func
(paren
id|DMA1_STAT_REG
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_or
(paren
id|inb
c_func
(paren
id|DMA2_STAT_REG
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Eliminate the old and floating requests,&n;&t;&t; * and DMA4 the cascade.&n;&t;&t; */
id|new_dma_status
op_xor_assign
id|dma_status
suffix:semicolon
id|new_dma_status
op_and_assign
op_complement
l_int|0x10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|new_dma_status
)paren
)paren
(brace
id|dev-&gt;dma
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMA probe failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dev-&gt;dma
comma
id|cardname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;probed DMA %d allocation failed.&bslash;n&quot;
comma
id|dev-&gt;dma
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* jumpered DMA */
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Grab the region so that no one else tries to probe our ioports. */
id|request_region
c_func
(paren
id|ioaddr
comma
id|NETCARD_IO_EXTENT
comma
id|cardname
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|net_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|net_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
op_amp
id|net_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|MY_TX_TIMEOUT
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|net_tx_timeout
r_static
r_void
id|net_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|chipset_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* If we have space available to accept new transmit&n;&t; * requests, wake up the queueing layer.  This would&n;&t; * be the case if the chipset_init() call above just&n;&t; * flushes out the tx queue and empties it.&n;&t; *&n;&t; * If instead, the tx queue is retained then the&n;&t; * netif_wake_queue() call should be placed in the&n;&t; * TX completion interrupt handler of the driver instead&n;&t; * of here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tx_full
c_func
(paren
id|dev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Open/initialize the board. This is called (in the current kernel)&n; * sometime after booting when the &squot;ifconfig&squot; program is run.&n; *&n; * This routine should set everything up anew at each open, even&n; * registers that &quot;should&quot; only need to be set once at boot, so that&n; * there is non-reboot way to recover if something goes wrong.&n; */
r_static
r_int
DECL|function|net_open
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/*&n;&t; * This is used if the interrupt line can turned off (shared).&n;&t; * See 3c503.c for an example of selecting the IRQ at config-time.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|net_interrupt
comma
l_int|0
comma
id|cardname
comma
id|dev
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Always allocate the DMA channel after the IRQ,&n;&t; * and clean up on failure.&n;&t; */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dev-&gt;dma
comma
id|cardname
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Reset the hardware here. Don&squot;t forget to set the station address. */
id|chipset_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
)paren
suffix:semicolon
id|np-&gt;open_time
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* We are now ready to accept transmit requeusts from&n;&t; * the queueing layer of the networking.&n;&t; */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This will only be invoked if your driver is _not_ in XOFF state.&n; * What this means is that you need not check it, and that this&n; * invariant will hold if you make sure that the netif_*_queue()&n; * calls are done at the proper times.&n; */
DECL|function|net_send_packet
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* If some error occurs while trying to transmit this&n;&t; * packet, you should return &squot;1&squot; from this function.&n;&t; * In such a case you _may not_ do anything to the&n;&t; * SKB, it is still owned by the network queueing&n;&t; * layer when an error is returned.  This means you&n;&t; * may not modify any SKB fields, you may not free&n;&t; * the SKB, etc.&n;&t; */
macro_line|#if TX_RING
multiline_comment|/* This is the most common case for modern hardware.&n;&t; * The spinlock protects this code from the TX complete&n;&t; * hardware interrupt handler.  Queue flow control is&n;&t; * thus managed under this lock as well.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
id|add_to_tx_ring
c_func
(paren
id|np
comma
id|skb
comma
id|length
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* If we just used up the very last entry in the&n;&t; * TX ring on this device, tell the queueing&n;&t; * layer to send no more.&n;&t; */
r_if
c_cond
(paren
id|tx_full
c_func
(paren
id|dev
)paren
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* When the TX completion hw interrupt arrives, this&n;&t; * is when the transmit statistics are updated.&n;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* This is the case for older hardware which takes&n;&t; * a single transmit buffer at a time, and it is&n;&t; * just written to the device via PIO.&n;&t; *&n;&t; * No spin locking is needed since there is no TX complete&n;&t; * event.  If by chance your card does have a TX complete&n;&t; * hardware IRQ then you may need to utilize np-&gt;lock here.&n;&t; */
id|hardware_send_packet
c_func
(paren
id|ioaddr
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|np-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* You might need to clean up and record Tx statistics here. */
r_if
c_cond
(paren
id|inw
c_func
(paren
id|ioaddr
)paren
op_eq
multiline_comment|/*RU*/
l_int|81
)paren
id|np-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if TX_RING
multiline_comment|/* This handles TX complete events posted by the device&n; * via interrupts.&n; */
DECL|function|net_tx
r_void
id|net_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
suffix:semicolon
multiline_comment|/* This protects us from concurrent execution of&n;&t; * our dev-&gt;hard_start_xmit function above.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
id|entry
op_assign
id|np-&gt;tx_old
suffix:semicolon
r_while
c_loop
(paren
id|tx_entry_is_sent
c_func
(paren
id|np
comma
id|entry
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|np-&gt;skbs
(braket
id|entry
)braket
suffix:semicolon
id|np-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb_irq
(paren
id|skb
)paren
suffix:semicolon
id|entry
op_assign
id|next_tx_entry
c_func
(paren
id|np
comma
id|entry
)paren
suffix:semicolon
)brace
id|np-&gt;tx_old
op_assign
id|entry
suffix:semicolon
multiline_comment|/* If we had stopped the queue due to a &quot;tx full&quot;&n;&t; * condition, and space has now been made available,&n;&t; * wake up the queue.&n;&t; */
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_logical_and
op_logical_neg
id|tx_full
c_func
(paren
id|dev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|np-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * The typical workload of the driver:&n; * Handle the network interface interrupts.&n; */
DECL|function|net_interrupt
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|np
suffix:semicolon
r_int
id|ioaddr
comma
id|status
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_INTR
)paren
(brace
multiline_comment|/* Got a packet(s). */
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#if TX_RING
r_if
c_cond
(paren
id|status
op_amp
id|TX_INTR
)paren
(brace
multiline_comment|/* Transmit complete. */
id|net_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|np-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status
op_amp
id|COUNTERS_INTR
)paren
(brace
multiline_comment|/* Increment the appropriate &squot;localstats&squot; field. */
id|np-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
r_static
r_void
DECL|function|net_rx
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|10
suffix:semicolon
r_do
(brace
r_int
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
id|pkt_len
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_len
op_eq
l_int|0
)paren
multiline_comment|/* Read all the frames? */
r_break
suffix:semicolon
multiline_comment|/* Done for now */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x20
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x08
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x04
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* &squot;skb-&gt;data&squot; points to the start of sk_buff data area. */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
(paren
r_void
op_star
)paren
id|dev-&gt;rmem_start
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* or */
id|insw
c_func
(paren
id|ioaddr
comma
id|skb-&gt;data
comma
(paren
id|pkt_len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|boguscount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|net_close
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;open_time
op_assign
l_int|0
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here. */
id|disable_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
multiline_comment|/* If not IRQ or DMA jumpered, free up the line. */
id|outw
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Release the physical interrupt line. */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the current statistics.&n; * This may be called with the card open or closed.&n; */
DECL|function|net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* Update the statistics from the device registers. */
id|lp-&gt;stats.rx_missed_errors
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; * Set or clear the multicast filter for this adaptor.&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Enable promiscuous mode */
id|outw
c_func
(paren
id|MULTICAST
op_or
id|PROMISC
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_count
OG
id|HW_MAX_ADDRS
)paren
(brace
multiline_comment|/* Disable promiscuous mode, use normal mode. */
id|hardware_set_filter
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MULTICAST
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
multiline_comment|/* Walk the address list, and load the filter */
id|hardware_set_filter
c_func
(paren
id|dev-&gt;mc_list
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MULTICAST
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|this_device
r_static
r_struct
id|net_device
id|this_device
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x300
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
suffix:semicolon
DECL|variable|dma
r_static
r_int
id|dma
suffix:semicolon
DECL|variable|mem
r_static
r_int
id|mem
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: You shouldn&squot;t use auto-probing with insmod!&bslash;n&quot;
comma
id|cardname
)paren
suffix:semicolon
multiline_comment|/* Copy the parameters from insmod into the device structure. */
id|this_device.base_addr
op_assign
id|io
suffix:semicolon
id|this_device.irq
op_assign
id|irq
suffix:semicolon
id|this_device.dma
op_assign
id|dma
suffix:semicolon
id|this_device.mem_start
op_assign
id|mem
suffix:semicolon
id|this_device.init
op_assign
id|netcard_probe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|this_device
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
id|unregister_netdev
c_func
(paren
op_amp
id|this_device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t do this, we can&squot;t re-insmod it later.&n;&t; * Release irq/dma here, when you have jumpered versions and&n;&t; * allocate them in net_probe1().&n;&t; */
multiline_comment|/*&n;&t;   free_irq(this_device.irq, dev);&n;&t;   free_dma(this_device.dma);&n;&t;*/
id|release_region
c_func
(paren
id|this_device.base_addr
comma
id|NETCARD_IO_EXTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_device.priv
)paren
id|kfree
c_func
(paren
id|this_device.priv
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Local variables:&n; *  compile-command:&n; *&t;gcc -D__KERNEL__ -Wall -Wstrict-prototypes -Wwrite-strings&n; *&t;-Wredundant-decls -O2 -m486 -c skeleton.c&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 4&n; *  c-indent-level: 4&n; * End:&n; */
eof
