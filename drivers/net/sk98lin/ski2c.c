multiline_comment|/******************************************************************************&n; *&n; * Name:&t;ski2c.c&n; * Project:&t;GEnesis, PCI Gigabit Ethernet Adapter&n; * Version:&t;$Revision: 1.44 $&n; * Date:&t;$Date: 2000/08/07 15:49:03 $&n; * Purpose:&t;Funktions to access Voltage and Temperature Sensor&n; *&t;&t;(taken from Monalisa (taken from Concentrator))&n; *&n; ******************************************************************************/
multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998-2000 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/******************************************************************************&n; *&n; * History:&n; *&n; *&t;$Log: ski2c.c,v $&n; *&t;Revision 1.44  2000/08/07 15:49:03  gklug&n; *&t;fix: SK_INFAST only in NetWare driver&n; *&t;&n; *&t;Revision 1.43  2000/08/03 14:28:17  rassmann&n; *&t;- Added function to wait for I2C being ready before resetting the board.&n; *&t;- Replaced one duplicate &quot;out of range&quot; message with correct one.&n; *&t;&n; *&t;Revision 1.42  1999/11/22 13:35:12  cgoos&n; *&t;Changed license header to GPL.&n; *&t;&n; *&t;Revision 1.41  1999/09/14 14:11:30  malthoff&n; *&t;The 1000BT Dual Link adapter has got only one Fan.&n; *&t;The second Fan has been removed.&n; *&t;&n; *&t;Revision 1.40  1999/05/27 13:37:27  malthoff&n; *&t;Set divisor of 1 for fan count calculation.&n; *&t;&n; *&t;Revision 1.39  1999/05/20 14:54:43  malthoff&n; *&t;I2c.DummyReads is not used in Diagnostics.&n; *&t;&n; *&t;Revision 1.38  1999/05/20 09:20:56  cgoos&n; *&t;Changes for 1000Base-T (up to 9 sensors and fans).&n; *&t;&n; *&t;Revision 1.37  1999/03/25 15:11:36  gklug&n; *&t;fix: reset error flag if sensor reads correct value&n; *&t;&n; *&t;Revision 1.36  1999/01/07 14:11:16  gklug&n; *&t;fix: break added&n; *&t;&n; *&t;Revision 1.35  1999/01/05 15:31:49  gklug&n; *&t;fix: CLEAR STAT command is now added correctly&n; *&t;&n; *&t;Revision 1.34  1998/12/01 13:45:16  gklug&n; *&t;fix: introduced Init level, because we don&squot;t need reinits&n; *&t;&n; *&t;Revision 1.33  1998/11/09 14:54:25  malthoff&n; *&t;Modify I2C Transfer Timeout handling for Diagnostics.&n; *&t;&n; *&t;Revision 1.32  1998/11/03 06:54:35  gklug&n; *&t;fix: Need dummy reads at the beginning to init sensors&n; *&n; *&t;Revision 1.31  1998/11/03 06:42:42  gklug&n; *&t;fix: select correctVIO range only if between warning levels&n; *&t;&n; *&t;Revision 1.30  1998/11/02 07:36:53  gklug&n; *&t;fix: Error should not include WARNING message&n; *&t;&n; *&t;Revision 1.29  1998/10/30 15:07:43  malthoff&n; *&t;Disable &squot;I2C does not compelete&squot; error log for diagnostics.&n; *&t;&n; *&t;Revision 1.28  1998/10/22 09:48:11  gklug&n; *&t;fix: SysKonnectFileId typo&n; *&t;&n; *&t;Revision 1.27  1998/10/20 09:59:46  gklug&n; *&t;add: parameter to SkOsGetTime&n; *&t;&n; *&t;Revision 1.26  1998/10/09 06:10:59  malthoff&n; *&t;Remove ID_sccs by SysKonnectFileId.&n; *&t;&n; *&t;Revision 1.25  1998/09/08 12:40:26  gklug&n; *&t;fix: syntax error in if clause&n; *&t;&n; *&t;Revision 1.24  1998/09/08 12:19:42  gklug&n; *&t;chg: INIT Level checking&n; *&t;&n; *&t;Revision 1.23  1998/09/08 07:37:20  gklug&n; *&t;fix: log error if PCI_IO voltage sensor could not be initialized&n; *&t;&n; *&t;Revision 1.22  1998/09/04 08:30:03  malthoff&n; *&t;Bugfixes during SK_DIAG testing:&n; *&t;- correct NS2BCLK() macro&n; *&t;- correct SkI2cSndDev()&n; *&t;- correct SkI2cWait() loop waiting for an event&n; *&t;&n; *&t;Revision 1.21  1998/08/27 14:46:01  gklug&n; *&t;chg: if-then-else replaced by switch&n; *&n; *&t;Revision 1.20  1998/08/27 14:40:07  gklug&n; *&t;test: integral types&n; *&t;&n; *&t;Revision 1.19  1998/08/25 07:51:54  gklug&n; *&t;fix: typos for compiling&n; *&t;&n; *&t;Revision 1.18  1998/08/25 06:12:24  gklug&n; *&t;add: count errors and warnings&n; *&t;fix: check not the sensor state but the ErrFlag!&n; *&t;&n; *&t;Revision 1.17  1998/08/25 05:56:48  gklug&n; *&t;add: CheckSensor function&n; *&t;&n; *&t;Revision 1.16  1998/08/20 11:41:10  gklug&n; *&t;chg: omit STRCPY macro by using char * as Sensor Description&n; *&t;&n; *&t;Revision 1.15  1998/08/20 11:37:35  gklug&n; *&t;chg: change Ioc to IoC&n; *&t;&n; *&t;Revision 1.14  1998/08/20 11:32:52  gklug&n; *&t;fix: Para compile error&n; *&t;&n; *&t;Revision 1.13  1998/08/20 11:27:41  gklug&n; *&t;fix: Compile bugs with new awrning constants&n; *&t;&n; *&t;Revision 1.12  1998/08/20 08:53:05  gklug&n; *&t;fix: compiler errors&n; *&t;add: Threshold values&n; *&t;&n; *&t;Revision 1.11  1998/08/19 12:39:22  malthoff&n; *&t;Compiler Fix: Some names have changed.&n; *&t;&n; *&t;Revision 1.10  1998/08/19 12:20:56  gklug&n; *&t;fix: remove struct from C files (see CCC)&n; *&t;&n; *&t;Revision 1.9  1998/08/19 06:28:46  malthoff&n; *&t;SkOsGetTime returns SK_U64 now.&n; *&t;&n; *&t;Revision 1.8  1998/08/17 13:53:33  gklug&n; *&t;fix: Parameter of event function and its result&n; *&t;&n; *&t;Revision 1.7  1998/08/17 07:02:15  malthoff&n; *&t;Modify the functions for accessing the I2C SW Registers.&n; *&t;Modify SkI2cWait().&n; *&t;Put Lm80RcvReg into sklm80.c&n; *&t;Remove Compiler Errors.&n; *&t;&n; *&t;Revision 1.6  1998/08/14 07:13:20  malthoff&n; *&t;remove pAc with pAC&n; *&t;remove smc with pAC&n; *&t;change names to new convention&n; *&n; *&t;Revision 1.5  1998/08/14 06:24:49  gklug&n; *&t;add: init level 1 and 2&n; *&n; *&t;Revision 1.4  1998/08/12 14:31:12  gklug&n; *&t;add: error log for unknown event&n; *&n; *&t;Revision 1.3  1998/08/12 13:37:04  gklug&n; *&t;add: Init 0 function&n; *&n; *&t;Revision 1.2  1998/08/11 07:27:15  gklug&n; *&t;add: functions of the interface&n; *&t;adapt rest of source to C coding Conventions&n; *&t;rmv: unneccessary code taken from Mona Lisa&n; *&n; *&t;Revision 1.1  1998/06/19 14:28:43  malthoff&n; *&t;Created. Sources taken from ML Projekt.&n; *&t;Sources have to be reworked for GE.&n; *&n; *&n; ******************************************************************************/
multiline_comment|/*&n;&t;I2C Protocol&n;*/
DECL|variable|SysKonnectFileId
r_static
r_const
r_char
id|SysKonnectFileId
(braket
)braket
op_assign
l_string|&quot;$Id: ski2c.c,v 1.44 2000/08/07 15:49:03 gklug Exp $&quot;
suffix:semicolon
macro_line|#include &quot;h/skdrv1st.h&quot;&t;&t;/* Driver Specific Definitions */
macro_line|#include &quot;h/lm80.h&quot;
macro_line|#include &quot;h/skdrv2nd.h&quot;&t;&t;/* Adapter Control- and Driver specific Def. */
macro_line|#ifdef __C2MAN__
multiline_comment|/*&n;&t;I2C protocol implemetation.&n;&n;&t;General Description:&n;&n;&t;The I2C protocol is used for the temperature sensors and for&n;&t;the serial EEPROM which hold the configuration.&n;&n;&t;This file covers functions that allow to read write and do&n;&t;some bulk requests a specified I2C address.&n;&n;&t;The Genesis has 2 I2C buses. One for the EEPROM which holds&n;&t;the VPD Data and one for temperature and voltage sensor.&n;&t;The following picture shows the I2C buses, I2C devices and&n;&t;there control registers.&n;&n;&t;Note: The VPD functions are in skvpd.c&n;.&n;.&t;PCI Config I2C Bus for VPD Data:&n;.&n;.&t;&t;      +------------+&n;.&t;&t;      | VPD EEPROM |&n;.&t;&t;      +------------+&n;.&t;&t;&t;     |&n;.&t;&t;&t;     | &lt;-- I2C&n;.&t;&t;&t;     |&n;.&t;&t; +-----------+-----------+&n;.&t;&t; |&t;&t;&t; |&n;.&t;+-----------------+&t;+-----------------+&n;.&t;| PCI_VPD_ADR_REG |&t;| PCI_VPD_DAT_REG |&n;.&t;+-----------------+&t;+-----------------+&n;.&n;.&n;.&t;I2C Bus for LM80 sensor:&n;.&n;.&t;&t;&t;+-----------------+&n;.&t;&t;&t;| Temperature and |&n;.&t;&t;&t;| Voltage Sensor  |&n;.&t;&t;&t;| &t;LM80&t;  |&n;.&t;&t;&t;+-----------------+&n;.&t;&t;&t;&t;|&n;.&t;&t;&t;&t;|&n;.&t;&t;&t;I2C --&gt; |&n;.&t;&t;&t;&t;|&n;.&t;&t;&t;     +----+&n;.&t;     +--------------&gt;| OR |&lt;--+&n;.&t;     |&t;&t;     +----+   |&n;.     +------+------+&t;&t;      |&n;.     |&t;&t;    |&t;&t;      |&n;. +--------+&t;+--------+&t;+----------+&n;. | B2_I2C |&t;| B2_I2C |&t;|  B2_I2C  |&n;. | _CTRL  |&t;| _DATA  |&t;|   _SW    |&n;. +--------+&t;+--------+&t;+----------+&n;.&n;&t;The I2C bus may be driven by the B2_I2C_SW or by the B2_I2C_CTRL&n;&t;and B2_I2C_DATA registers.&n;&t;For driver software it is recommended to use the I2C control and&n;&t;data register, because I2C bus timing is done by the ASIC and&n;&t;an interrupt may be received when the I2C request is completed.&n;&n;&t;Clock Rate Timing:&t;&t;&t;MIN&t;MAX&t;generated by&n;&t;&t;VPD EEPROM:&t;&t;&t;50 kHz&t;100 kHz&t;&t;HW&n;&t;&t;LM80 over I2C Ctrl/Data reg.&t;50 kHz&t;100 kHz&t;&t;HW&n;&t;&t;LM80 over B2_I2C_SW register&t;0&t;400 kHz&t;&t;SW&n;&n;&t;Note:&t;The clock generated by the hardware is dependend on the&n;&t;&t;PCI clock. If the PCI bus clock is 33 MHz, the I2C/VPD&n;&t;&t;clock is 50 kHz.&n; */
DECL|function|intro
id|intro
c_func
(paren
)paren
(brace
)brace
macro_line|#endif
macro_line|#ifdef&t;SK_DIAG
multiline_comment|/*&n; * I2C Fast Mode timing values used by the LM80.&n; * If new devices are added to the I2C bus the timing values have to be checked.&n; */
macro_line|#ifndef I2C_SLOW_TIMING
DECL|macro|T_CLK_LOW
mdefine_line|#define&t;T_CLK_LOW&t;&t;1300L&t;/* clock low time in ns */
DECL|macro|T_CLK_HIGH
mdefine_line|#define&t;T_CLK_HIGH&t;&t; 600L&t;/* clock high time in ns */
DECL|macro|T_DATA_IN_SETUP
mdefine_line|#define T_DATA_IN_SETUP&t;&t; 100L&t;/* data in Set-UP Time */
DECL|macro|T_START_HOLD
mdefine_line|#define T_START_HOLD&t;&t; 600L&t;/* start condition hold time */
DECL|macro|T_START_SETUP
mdefine_line|#define T_START_SETUP&t;&t; 600L&t;/* start condition Set-up time */
DECL|macro|T_STOP_SETUP
mdefine_line|#define&t;T_STOP_SETUP&t;&t; 600L&t;/* stop condition Set-up time */
DECL|macro|T_BUS_IDLE
mdefine_line|#define T_BUS_IDLE&t;&t;1300L&t;/* time the bus must free after tx */
DECL|macro|T_CLK_2_DATA_OUT
mdefine_line|#define&t;T_CLK_2_DATA_OUT&t; 900L&t;/* max. clock low to data output valid */
macro_line|#else&t;/* I2C_SLOW_TIMING */
multiline_comment|/* I2C Standard Mode Timing */
DECL|macro|T_CLK_LOW
mdefine_line|#define&t;T_CLK_LOW&t;&t;4700L&t;/* clock low time in ns */
DECL|macro|T_CLK_HIGH
mdefine_line|#define&t;T_CLK_HIGH&t;&t;4000L&t;/* clock high time in ns */
DECL|macro|T_DATA_IN_SETUP
mdefine_line|#define T_DATA_IN_SETUP&t;&t; 250L&t;/* data in Set-UP Time */
DECL|macro|T_START_HOLD
mdefine_line|#define T_START_HOLD&t;&t;4000L&t;/* start condition hold time */
DECL|macro|T_START_SETUP
mdefine_line|#define T_START_SETUP&t;&t;4700L&t;/* start condition Set_up time */
DECL|macro|T_STOP_SETUP
mdefine_line|#define&t;T_STOP_SETUP&t;&t;4000L&t;/* stop condition Set-up time */
DECL|macro|T_BUS_IDLE
mdefine_line|#define T_BUS_IDLE&t;&t;4700L&t;/* time the bus must free after tx */
macro_line|#endif&t;/* !I2C_SLOW_TIMING */
DECL|macro|NS2BCLK
mdefine_line|#define NS2BCLK(x)&t;(((x)*125)/10000)
multiline_comment|/*&n; * I2C Wire Operations&n; *&n; * About I2C_CLK_LOW():&n; *&n; * The Data Direction bit (I2C_DATA_DIR) has to be set to input when setting&n; * clock to low, to prevent the ASIC and the I2C data client from driving the&n; * serial data line simultaneously (ASIC: last bit of a byte = &squot;1&squot;, I2C client&n; * send an &squot;ACK&squot;). See also Concentrator Bugreport No. 10192.&n; */
DECL|macro|I2C_DATA_HIGH
mdefine_line|#define I2C_DATA_HIGH(IoC)&t;SK_I2C_SET_BIT(IoC, I2C_DATA)
DECL|macro|I2C_DATA_LOW
mdefine_line|#define&t;I2C_DATA_LOW(IoC)&t;SK_I2C_CLR_BIT(IoC, I2C_DATA)
DECL|macro|I2C_DATA_OUT
mdefine_line|#define&t;I2C_DATA_OUT(IoC)&t;SK_I2C_SET_BIT(IoC, I2C_DATA_DIR)
DECL|macro|I2C_DATA_IN
mdefine_line|#define&t;I2C_DATA_IN(IoC)&t;SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR|I2C_DATA)
DECL|macro|I2C_CLK_HIGH
mdefine_line|#define&t;I2C_CLK_HIGH(IoC)&t;SK_I2C_SET_BIT(IoC, I2C_CLK)
DECL|macro|I2C_CLK_LOW
mdefine_line|#define&t;I2C_CLK_LOW(IoC)&t;SK_I2C_CLR_BIT(IoC, I2C_CLK|I2C_DATA_DIR)
DECL|macro|I2C_START_COND
mdefine_line|#define&t;I2C_START_COND(IoC)&t;SK_I2C_CLR_BIT(IoC, I2C_CLK)
DECL|macro|NS2CLKT
mdefine_line|#define NS2CLKT(x)&t;((x*125L)/10000)
multiline_comment|/*--------------- I2C Interface Register Functions --------------- */
multiline_comment|/*&n; * sending one bit&n; */
DECL|function|SkI2cSndBit
r_void
id|SkI2cSndBit
c_func
(paren
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
id|SK_U8
id|Bit
)paren
multiline_comment|/* Bit to send */
(brace
id|I2C_DATA_OUT
c_func
(paren
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Bit
)paren
(brace
id|I2C_DATA_HIGH
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
r_else
(brace
id|I2C_DATA_LOW
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_DATA_IN_SETUP
)paren
)paren
suffix:semicolon
id|I2C_CLK_HIGH
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_CLK_HIGH
)paren
)paren
suffix:semicolon
id|I2C_CLK_LOW
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cSndBit*/
multiline_comment|/*&n; * Signal a start to the I2C Bus.&n; *&n; * A start is signaled when data goes to low in a high clock cycle.&n; *&n; * Ends with Clock Low.&n; *&n; * Status: not tested&n; */
DECL|function|SkI2cStart
r_void
id|SkI2cStart
c_func
(paren
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
multiline_comment|/* Init data and Clock to output lines */
multiline_comment|/* Set Data high */
id|I2C_DATA_OUT
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|I2C_DATA_HIGH
c_func
(paren
id|IoC
)paren
suffix:semicolon
multiline_comment|/* Set Clock high */
id|I2C_CLK_HIGH
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_START_SETUP
)paren
)paren
suffix:semicolon
multiline_comment|/* Set Data Low */
id|I2C_DATA_LOW
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_START_HOLD
)paren
)paren
suffix:semicolon
multiline_comment|/* Clock low without Data to Input */
id|I2C_START_COND
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_CLK_LOW
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cStart */
DECL|function|SkI2cStop
r_void
id|SkI2cStop
c_func
(paren
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
multiline_comment|/* Init data and Clock to output lines */
multiline_comment|/* Set Data low */
id|I2C_DATA_OUT
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|I2C_DATA_LOW
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_CLK_2_DATA_OUT
)paren
)paren
suffix:semicolon
multiline_comment|/* Set Clock high */
id|I2C_CLK_HIGH
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_STOP_SETUP
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set Data High:&t;Do it by setting the Data Line to Input.&n;&t; *&t;&t;&t;Because of a pull up resistor the Data Line&n;&t; *&t;&t;&t;floods to high.&n;&t; */
id|I2C_DATA_IN
c_func
(paren
id|IoC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;When I2C activity is stopped&n;&t; *&t; o&t;DATA should be set to input and&n;&t; *&t; o&t;CLOCK should be set to high!&n;&t; */
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_BUS_IDLE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cStop */
multiline_comment|/*&n; * Receive just one bit via the I2C bus.&n; *&n; * Note:&t;Clock must be set to LOW before calling this function.&n; *&n; * Returns The received bit.&n; */
DECL|function|SkI2cRcvBit
r_int
id|SkI2cRcvBit
c_func
(paren
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
r_int
id|Bit
suffix:semicolon
id|SK_U8
id|I2cSwCtrl
suffix:semicolon
multiline_comment|/* Init data as input line */
id|I2C_DATA_IN
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_CLK_2_DATA_OUT
)paren
)paren
suffix:semicolon
id|I2C_CLK_HIGH
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_CLK_HIGH
)paren
)paren
suffix:semicolon
id|SK_I2C_GET_SW
c_func
(paren
id|IoC
comma
op_amp
id|I2cSwCtrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I2cSwCtrl
op_amp
id|I2C_DATA
)paren
(brace
id|Bit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|Bit
op_assign
l_int|0
suffix:semicolon
)brace
id|I2C_CLK_LOW
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|SkDgWaitTime
c_func
(paren
id|IoC
comma
id|NS2BCLK
c_func
(paren
id|T_CLK_LOW
op_minus
id|T_CLK_2_DATA_OUT
)paren
)paren
suffix:semicolon
r_return
id|Bit
suffix:semicolon
)brace
multiline_comment|/* SkI2cRcvBit */
multiline_comment|/*&n; * Receive an ACK.&n; *&n; * returns&t;0 If acknoledged&n; *&t;&t;1 in case of an error&n; */
DECL|function|SkI2cRcvAck
r_int
id|SkI2cRcvAck
c_func
(paren
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
multiline_comment|/*&n;&t; * Received bit must be zero.&n;&t; */
r_return
(paren
id|SkI2cRcvBit
c_func
(paren
id|IoC
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cRcvAck */
multiline_comment|/*&n; * Send an NACK.&n; */
DECL|function|SkI2cSndNAck
r_void
id|SkI2cSndNAck
c_func
(paren
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
multiline_comment|/*&n;&t; * Received bit must be zero.&n;&t; */
id|SkI2cSndBit
c_func
(paren
id|IoC
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cSndNAck */
multiline_comment|/*&n; * Send an ACK.&n; */
DECL|function|SkI2cSndAck
r_void
id|SkI2cSndAck
c_func
(paren
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
multiline_comment|/*&n;&t; * Received bit must be zero.&n;&t; *&n;&t; */
id|SkI2cSndBit
c_func
(paren
id|IoC
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cSndAck */
multiline_comment|/*&n; * Send one byte to the I2C device and wait for ACK.&n; *&n; * Return acknoleged status.&n; */
DECL|function|SkI2cSndByte
r_int
id|SkI2cSndByte
c_func
(paren
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
r_int
id|Byte
)paren
multiline_comment|/* byte to send */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|Byte
op_amp
(paren
l_int|1
op_lshift
(paren
l_int|7
op_minus
id|i
)paren
)paren
)paren
(brace
id|SkI2cSndBit
c_func
(paren
id|IoC
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|SkI2cSndBit
c_func
(paren
id|IoC
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
id|SkI2cRcvAck
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cSndByte */
multiline_comment|/*&n; * Receive one byte and ack it.&n; *&n; * Return byte.&n; */
DECL|function|SkI2cRcvByte
r_int
id|SkI2cRcvByte
c_func
(paren
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
r_int
id|Last
)paren
multiline_comment|/* Last Byte Flag */
(brace
r_int
id|i
suffix:semicolon
r_int
id|Byte
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Byte
op_lshift_assign
l_int|1
suffix:semicolon
id|Byte
op_or_assign
id|SkI2cRcvBit
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Last
)paren
(brace
id|SkI2cSndNAck
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
r_else
(brace
id|SkI2cSndAck
c_func
(paren
id|IoC
)paren
suffix:semicolon
)brace
r_return
id|Byte
suffix:semicolon
)brace
multiline_comment|/* SkI2cRcvByte */
multiline_comment|/*&n; * Start dialog and send device address&n; *&n; * Return 0 if acknoleged, 1 in case of an error&n; */
DECL|function|SkI2cSndDev
r_int
id|SkI2cSndDev
c_func
(paren
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
r_int
id|Addr
comma
multiline_comment|/* Device Address */
r_int
id|Rw
)paren
multiline_comment|/* Read / Write Flag */
(brace
id|SkI2cStart
c_func
(paren
id|IoC
)paren
suffix:semicolon
id|Rw
op_assign
op_complement
id|Rw
suffix:semicolon
id|Rw
op_and_assign
id|I2C_WRITE
suffix:semicolon
r_return
id|SkI2cSndByte
c_func
(paren
id|IoC
comma
(paren
id|Addr
op_lshift
l_int|1
)paren
op_or
id|Rw
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cSndDev */
macro_line|#endif&t;/* SK_DIAG */
multiline_comment|/*----------------- I2C CTRL Register Functions ----------*/
multiline_comment|/*&n; * waits for a completion of an I2C transfer&n; *&n; * returns&t;0:&t;success, transfer completes&n; *&t;&t;&t;1:&t;error,&t; transfer does not complete, I2C transfer&n; *&t;&t;&t;&t;&t;&t; killed, wait loop terminated.&n; */
DECL|function|SkI2cWait
r_int
id|SkI2cWait
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
r_int
id|Event
)paren
multiline_comment|/* complete event to wait for (I2C_READ or I2C_WRITE) */
(brace
id|SK_U64
id|StartTime
suffix:semicolon
id|SK_U32
id|I2cCtrl
suffix:semicolon
id|StartTime
op_assign
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
op_minus
id|StartTime
OG
id|SK_TICKS_PER_SEC
op_div
l_int|8
)paren
(brace
id|SK_I2C_STOP
c_func
(paren
id|IoC
)paren
suffix:semicolon
macro_line|#ifndef SK_DIAG
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_I2C_E002
comma
id|SKERR_I2C_E002MSG
)paren
suffix:semicolon
macro_line|#endif&t;/* !SK_DIAG */
r_return
l_int|1
suffix:semicolon
)brace
id|SK_I2C_GET_CTL
c_func
(paren
id|IoC
comma
op_amp
id|I2cCtrl
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|I2cCtrl
op_amp
id|I2C_FLAG
)paren
op_eq
(paren
id|SK_U32
)paren
id|Event
op_lshift
l_int|31
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SkI2cWait */
multiline_comment|/*&n; * waits for a completion of an I2C transfer&n; *&n; * Returns&n; *&t;Nothing&n; */
DECL|function|SkI2cWaitIrq
r_void
id|SkI2cWaitIrq
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
id|SK_SENSOR
op_star
id|pSen
suffix:semicolon
id|SK_U64
id|StartTime
suffix:semicolon
id|SK_U32
id|IrqSrc
suffix:semicolon
id|pSen
op_assign
op_amp
id|pAC-&gt;I2c.SenTable
(braket
id|pAC-&gt;I2c.CurrSens
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pSen-&gt;SenState
op_eq
id|SK_SEN_IDLE
)paren
(brace
r_return
suffix:semicolon
)brace
id|StartTime
op_assign
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
op_minus
id|StartTime
OG
id|SK_TICKS_PER_SEC
op_div
l_int|8
)paren
(brace
id|SK_I2C_STOP
c_func
(paren
id|IoC
)paren
suffix:semicolon
macro_line|#ifndef SK_DIAG
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_I2C_E002
comma
id|SKERR_I2C_E002MSG
)paren
suffix:semicolon
macro_line|#endif&t;/* !SK_DIAG */
r_return
suffix:semicolon
)brace
id|SK_IN32
c_func
(paren
id|pAC
comma
id|B0_ISRC
comma
op_amp
id|IrqSrc
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|IrqSrc
op_amp
id|IS_I2C_READY
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* SkI2cWaitIrq */
macro_line|#ifdef&t;SK_DIAG
multiline_comment|/*&n; * writes a single byte or 4 bytes into the I2C device&n; *&n; * returns&t;0:&t;success&n; *&t;&t;&t;1:&t;error&n; */
DECL|function|SkI2cWrite
r_int
id|SkI2cWrite
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
id|SK_U32
id|I2cData
comma
multiline_comment|/* I2C Data to write */
r_int
id|I2cDev
comma
multiline_comment|/* I2C Device Address */
r_int
id|I2cReg
comma
multiline_comment|/* I2C Device Register Address */
r_int
id|I2cBurst
)paren
multiline_comment|/* I2C Burst Flag ( 0 || I2C_BURST ) */
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
id|I2cData
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|I2cDev
comma
id|I2cReg
comma
id|I2cBurst
)paren
suffix:semicolon
r_return
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cWrite*/
multiline_comment|/*&n; * reads a single byte or 4 bytes from the I2C device&n; *&n; * returns&t;the word read&n; */
DECL|function|SkI2cRead
id|SK_U32
id|SkI2cRead
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
r_int
id|I2cDev
comma
multiline_comment|/* I2C Device Address */
r_int
id|I2cReg
comma
multiline_comment|/* I2C Device Register Address */
r_int
id|I2cBurst
)paren
multiline_comment|/* I2C Burst Flag ( 0 || I2C_BURST ) */
(brace
id|SK_U32
id|Data
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
l_int|0
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_READ
comma
id|I2cDev
comma
id|I2cReg
comma
id|I2cBurst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_READ
)paren
)paren
(brace
id|w_print
c_func
(paren
l_string|&quot;I2C Transfer Timeout!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SK_IN32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
op_amp
id|Data
)paren
suffix:semicolon
r_return
id|Data
suffix:semicolon
)brace
multiline_comment|/* SkI2cRead */
macro_line|#endif&t;/* SK_DIAG */
multiline_comment|/*&n; * read a sensor&squot;s value&n; *&n; * This function read a sensors value from the I2C sensor chip. The sensor&n; * is defined by its index into the sensors database in the struct pAC points&n; * to.&n; * Returns&t;1 if the read is completed&n; *&t;&t;0 if the read must be continued (I2C Bus still allocated)&n; */
DECL|function|SkI2cReadSensor
r_int
id|SkI2cReadSensor
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
id|SK_SENSOR
op_star
id|pSen
)paren
multiline_comment|/* Sensor to be read */
(brace
r_return
(paren
op_star
id|pSen-&gt;SenRead
)paren
(paren
id|pAC
comma
id|IoC
comma
id|pSen
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cReadSensor*/
multiline_comment|/*&n; * Do the Init state 0 initialization&n; */
DECL|function|SkI2cInit0
r_static
r_int
id|SkI2cInit0
c_func
(paren
id|SK_AC
op_star
id|pAC
)paren
multiline_comment|/* Adapter Context */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Begin with first sensor */
id|pAC-&gt;I2c.CurrSens
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set to mimimum sensor number */
id|pAC-&gt;I2c.MaxSens
op_assign
id|SK_MIN_SENSORS
suffix:semicolon
macro_line|#ifndef&t;SK_DIAG
multiline_comment|/* Initialize Number of Dummy Reads */
id|pAC-&gt;I2c.DummyReads
op_assign
id|SK_MAX_SENSORS
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SK_MAX_SENSORS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
l_int|0
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Temperature&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_TEMP
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_TEMP_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage PCI&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_VOLT
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH1
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW1
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH1
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW1
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_VT0_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage PCI-IO&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_VOLT
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH2
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW2
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH2
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW2
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_VT1_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_FALSE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage ASIC&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_VOLT
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH3
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW3
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH3
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW3
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_VT2_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage PMA&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_VOLT
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH4
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW4
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH4
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW4
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_VT3_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage PHY 2V5&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_VOLT
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH5
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW5
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH5
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW5
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_VT4_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage PHY B PLL&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_VOLT
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH6
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW6
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH6
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW6
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_VT5_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Speed Fan&quot;
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenType
op_assign
id|SK_SEN_FAN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreErrLow
op_assign
id|SK_SEN_ERRLOW
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenReg
op_assign
id|LM80_FAN2_IN
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenInit
op_assign
id|SK_TRUE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_INIT
op_or
id|SK_ERRCL_SW
comma
id|SKERR_I2C_E001
comma
id|SKERR_I2C_E001MSG
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenValue
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenErrFlag
op_assign
id|SK_SEN_ERR_OK
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenErrCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenBegErrTS
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenState
op_assign
id|SK_SEN_IDLE
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenRead
op_assign
id|SkLm80ReadSensor
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDev
op_assign
id|LM80_ADDR
suffix:semicolon
)brace
multiline_comment|/* Now we are &quot;INIT data&quot;ed */
id|pAC-&gt;I2c.InitLevel
op_assign
id|SK_INIT_DATA
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SkI2cInit0*/
multiline_comment|/*&n; * Do the init state 1 initialization&n; *&n; * initialize the following register of the LM80:&n; * Configuration register:&n; * - START, noINT, activeLOW, noINT#Clear, noRESET, noCI, noGPO#, noINIT&n; *&n; * Interrupt Mask Register 1:&n; * - all interrupts are Disabled (0xff)&n; *&n; * Interrupt Mask Register 2:&n; * - all interrupts are Disabled (0xff) Interrupt modi doesn&squot;t matter.&n; *&n; * Fan Divisor/RST_OUT register:&n; * - Divisors set to 1 (bits 00), all others 0s.&n; *&n; * OS# Configuration/Temperature resolution Register:&n; * - all 0s&n; *&n; */
DECL|function|SkI2cInit1
r_static
r_int
id|SkI2cInit1
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
r_if
c_cond
(paren
id|pAC-&gt;I2c.InitLevel
op_ne
id|SK_INIT_DATA
)paren
(brace
multiline_comment|/* ReInit not needed in I2C module */
r_return
l_int|0
suffix:semicolon
)brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
l_int|0
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|LM80_ADDR
comma
id|LM80_CFG
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
l_int|0xff
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|LM80_ADDR
comma
id|LM80_IMSK_1
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
l_int|0xff
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|LM80_ADDR
comma
id|LM80_IMSK_2
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
l_int|0x0
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|LM80_ADDR
comma
id|LM80_FAN_CTRL
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
l_int|0
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|LM80_ADDR
comma
id|LM80_TEMP_CTRL
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_DATA
comma
id|LM80_CFG_START
)paren
suffix:semicolon
id|SK_I2C_CTL
c_func
(paren
id|IoC
comma
id|I2C_WRITE
comma
id|LM80_ADDR
comma
id|LM80_CFG
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|SkI2cWait
c_func
(paren
id|pAC
comma
id|IoC
comma
id|I2C_WRITE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * MaxSens has to be initialized here, because PhyType is not&n;&t; * set when performing Init Level 1&n;&t; */
r_switch
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
l_int|0
)braket
dot
id|PhyType
)paren
(brace
r_case
id|SK_PHY_XMAC
suffix:colon
id|pAC-&gt;I2c.MaxSens
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PHY_BCOM
suffix:colon
id|pAC-&gt;I2c.SenTable
(braket
l_int|4
)braket
dot
id|SenDesc
op_assign
l_string|&quot;Voltage PHY A PLL&quot;
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
op_eq
l_int|1
)paren
(brace
id|pAC-&gt;I2c.MaxSens
op_assign
l_int|6
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;I2c.MaxSens
op_assign
l_int|8
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PHY_LONE
suffix:colon
id|pAC-&gt;I2c.MaxSens
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifndef&t;SK_DIAG
id|pAC-&gt;I2c.DummyReads
op_assign
id|pAC-&gt;I2c.MaxSens
suffix:semicolon
macro_line|#endif&t;/* !SK_DIAG */
multiline_comment|/* Now we are IO initialized */
id|pAC-&gt;I2c.InitLevel
op_assign
id|SK_INIT_IO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SkI2cInit1 */
multiline_comment|/*&n; * Init level 2: Start first sensors read&n; */
DECL|function|SkI2cInit2
r_static
r_int
id|SkI2cInit2
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
r_int
id|ReadComplete
suffix:semicolon
id|SK_SENSOR
op_star
id|pSen
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;I2c.InitLevel
op_ne
id|SK_INIT_IO
)paren
(brace
multiline_comment|/* ReInit not needed in I2C module */
multiline_comment|/* Init0 and Init2 not permitted */
r_return
l_int|0
suffix:semicolon
)brace
id|pSen
op_assign
op_amp
id|pAC-&gt;I2c.SenTable
(braket
id|pAC-&gt;I2c.CurrSens
)braket
suffix:semicolon
id|ReadComplete
op_assign
id|SkI2cReadSensor
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pSen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadComplete
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_INIT
comma
id|SKERR_I2C_E008
comma
id|SKERR_I2C_E008MSG
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we are correctly initialized */
id|pAC-&gt;I2c.InitLevel
op_assign
id|SK_INIT_RUN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SkI2cInit2*/
multiline_comment|/*&n; * Initialize I2C devices&n; *&n; * Get the first voltage value and discard it.&n; * Go into temperature read mode. A default pointer is not set.&n; *&n; * The things to be done depend on the init level in the parameter list:&n; * Level 0:&n; *&t;Initialize only the data structures. Do NOT access hardware.&n; * Level 1:&n; *&t;Initialize hardware through SK_IN?OUT commands. Do NOT use interrupts.&n; * Level 2:&n; *&t;Everything is possible. Interrupts may be used from now on.&n; *&n; * return:&t;0 = success&n; *&t;&t;other = error.&n; */
DECL|function|SkI2cInit
r_int
id|SkI2cInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context needed in levels 1 and 2 */
r_int
id|Level
)paren
multiline_comment|/* Init Level */
(brace
r_switch
c_cond
(paren
id|Level
)paren
(brace
r_case
id|SK_INIT_DATA
suffix:colon
r_return
id|SkI2cInit0
c_func
(paren
id|pAC
)paren
suffix:semicolon
r_case
id|SK_INIT_IO
suffix:colon
r_return
id|SkI2cInit1
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_case
id|SK_INIT_RUN
suffix:colon
r_return
id|SkI2cInit2
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SkI2cInit */
macro_line|#ifndef SK_DIAG
multiline_comment|/*&n; * Interrupt service function for the I2C Interface&n; *&n; * Clears the Interrupt source&n; *&n; * Reads the register and check it for sending a trap.&n; *&n; * Starts the timer if necessary.&n; */
DECL|function|SkI2cIsr
r_void
id|SkI2cIsr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* I/O Context */
(brace
id|SK_EVPARA
id|Para
suffix:semicolon
multiline_comment|/* Clear the interrupt source */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_I2C_IRQ
comma
id|I2C_CLR_IRQ
)paren
suffix:semicolon
id|Para.Para64
op_assign
l_int|0
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_I2C
comma
id|SK_I2CEV_IRQ
comma
id|Para
)paren
suffix:semicolon
)brace
multiline_comment|/* SkI2cIsr */
multiline_comment|/*&n; * Check this sensors Value against the threshold and send events.&n; */
DECL|function|SkI2cCheckSensor
r_static
r_void
id|SkI2cCheckSensor
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_SENSOR
op_star
id|pSen
)paren
(brace
id|SK_EVPARA
id|ParaLocal
suffix:semicolon
id|SK_BOOL
id|TooHigh
suffix:semicolon
multiline_comment|/* Is sensor too high? */
id|SK_BOOL
id|TooLow
suffix:semicolon
multiline_comment|/* Is sensor too low? */
id|SK_U64
id|CurrTime
suffix:semicolon
multiline_comment|/* current Time */
id|SK_BOOL
id|DoTrapSend
suffix:semicolon
multiline_comment|/* We need to send a trap */
id|SK_BOOL
id|DoErrLog
suffix:semicolon
multiline_comment|/* We need to log the error */
id|SK_BOOL
id|IsError
suffix:semicolon
multiline_comment|/* We need to log the error */
multiline_comment|/* Check Dummy Reads first */
r_if
c_cond
(paren
id|pAC-&gt;I2c.DummyReads
OG
l_int|0
)paren
(brace
id|pAC-&gt;I2c.DummyReads
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Get the current time */
id|CurrTime
op_assign
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
suffix:semicolon
multiline_comment|/* Set para to the most usefull setting:&n;&t; * The current sensor.&n;&t; */
id|ParaLocal.Para64
op_assign
(paren
id|SK_U64
)paren
id|pAC-&gt;I2c.CurrSens
suffix:semicolon
multiline_comment|/* Check the Value against the thresholds */
multiline_comment|/* First: Error Thresholds */
id|TooHigh
op_assign
(paren
id|pSen-&gt;SenValue
OG
id|pSen-&gt;SenThreErrHigh
)paren
suffix:semicolon
id|TooLow
op_assign
(paren
id|pSen-&gt;SenValue
OL
id|pSen-&gt;SenThreErrLow
)paren
suffix:semicolon
id|IsError
op_assign
id|SK_FALSE
suffix:semicolon
r_if
c_cond
(paren
id|TooHigh
op_logical_or
id|TooLow
)paren
(brace
multiline_comment|/* Error condition is satisfied */
id|DoTrapSend
op_assign
id|SK_TRUE
suffix:semicolon
id|DoErrLog
op_assign
id|SK_TRUE
suffix:semicolon
multiline_comment|/* Now error condition is satisfied */
id|IsError
op_assign
id|SK_TRUE
suffix:semicolon
r_if
c_cond
(paren
id|pSen-&gt;SenErrFlag
op_eq
id|SK_SEN_ERR_ERR
)paren
(brace
multiline_comment|/* This state is the former one */
multiline_comment|/* So check first whether we have to send a trap */
r_if
c_cond
(paren
id|pSen-&gt;SenLastErrTrapTS
op_plus
id|SK_SEN_ERR_TR_HOLD
OG
id|CurrTime
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do NOT send the Trap. The hold back time&n;&t;&t;&t;&t; * has to run out first.&n;&t;&t;&t;&t; */
id|DoTrapSend
op_assign
id|SK_FALSE
suffix:semicolon
)brace
multiline_comment|/* Check now whether we have to log an Error */
r_if
c_cond
(paren
id|pSen-&gt;SenLastErrLogTS
op_plus
id|SK_SEN_ERR_LOG_HOLD
OG
id|CurrTime
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do NOT log the error. The hold back time&n;&t;&t;&t;&t; * has to run out first.&n;&t;&t;&t;&t; */
id|DoErrLog
op_assign
id|SK_FALSE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We came from a different state */
multiline_comment|/* -&gt; Set Begin Time Stamp */
id|pSen-&gt;SenBegErrTS
op_assign
id|CurrTime
suffix:semicolon
id|pSen-&gt;SenErrFlag
op_assign
id|SK_SEN_ERR_ERR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoTrapSend
)paren
(brace
multiline_comment|/* Set current Time */
id|pSen-&gt;SenLastErrTrapTS
op_assign
id|CurrTime
suffix:semicolon
id|pSen-&gt;SenErrCts
op_increment
suffix:semicolon
multiline_comment|/* Queue PNMI Event */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_PNMI
comma
(paren
id|TooHigh
ques
c_cond
id|SK_PNMI_EVT_SEN_ERR_UPP
suffix:colon
id|SK_PNMI_EVT_SEN_ERR_LOW
)paren
comma
id|ParaLocal
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoErrLog
)paren
(brace
multiline_comment|/* Set current Time */
id|pSen-&gt;SenLastErrLogTS
op_assign
id|CurrTime
suffix:semicolon
r_if
c_cond
(paren
id|pSen-&gt;SenType
op_eq
id|SK_SEN_TEMP
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E011
comma
id|SKERR_I2C_E011MSG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pSen-&gt;SenType
op_eq
id|SK_SEN_VOLT
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E012
comma
id|SKERR_I2C_E012MSG
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E015
comma
id|SKERR_I2C_E015MSG
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Check the Value against the thresholds */
multiline_comment|/* 2nd: Warning thresholds */
id|TooHigh
op_assign
(paren
id|pSen-&gt;SenValue
OG
id|pSen-&gt;SenThreWarnHigh
)paren
suffix:semicolon
id|TooLow
op_assign
(paren
id|pSen-&gt;SenValue
OL
id|pSen-&gt;SenThreWarnLow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IsError
op_logical_and
(paren
id|TooHigh
op_logical_or
id|TooLow
)paren
)paren
(brace
multiline_comment|/* Error condition is satisfied */
id|DoTrapSend
op_assign
id|SK_TRUE
suffix:semicolon
id|DoErrLog
op_assign
id|SK_TRUE
suffix:semicolon
r_if
c_cond
(paren
id|pSen-&gt;SenErrFlag
op_eq
id|SK_SEN_ERR_WARN
)paren
(brace
multiline_comment|/* This state is the former one */
multiline_comment|/* So check first whether we have to send a trap */
r_if
c_cond
(paren
id|pSen-&gt;SenLastWarnTrapTS
op_plus
id|SK_SEN_WARN_TR_HOLD
OG
id|CurrTime
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do NOT send the Trap. The hold back time&n;&t;&t;&t;&t; * has to run out first.&n;&t;&t;&t;&t; */
id|DoTrapSend
op_assign
id|SK_FALSE
suffix:semicolon
)brace
multiline_comment|/* Check now whether we have to log an Error */
r_if
c_cond
(paren
id|pSen-&gt;SenLastWarnLogTS
op_plus
id|SK_SEN_WARN_LOG_HOLD
OG
id|CurrTime
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do NOT log the error. The hold back time&n;&t;&t;&t;&t; * has to run out first.&n;&t;&t;&t;&t; */
id|DoErrLog
op_assign
id|SK_FALSE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We came from a different state */
multiline_comment|/* -&gt; Set Begin Time Stamp */
id|pSen-&gt;SenBegWarnTS
op_assign
id|CurrTime
suffix:semicolon
id|pSen-&gt;SenErrFlag
op_assign
id|SK_SEN_ERR_WARN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoTrapSend
)paren
(brace
multiline_comment|/* Set current Time */
id|pSen-&gt;SenLastWarnTrapTS
op_assign
id|CurrTime
suffix:semicolon
id|pSen-&gt;SenWarnCts
op_increment
suffix:semicolon
multiline_comment|/* Queue PNMI Event */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_PNMI
comma
(paren
id|TooHigh
ques
c_cond
id|SK_PNMI_EVT_SEN_WAR_UPP
suffix:colon
id|SK_PNMI_EVT_SEN_WAR_LOW
)paren
comma
id|ParaLocal
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoErrLog
)paren
(brace
multiline_comment|/* Set current Time */
id|pSen-&gt;SenLastWarnLogTS
op_assign
id|CurrTime
suffix:semicolon
r_if
c_cond
(paren
id|pSen-&gt;SenType
op_eq
id|SK_SEN_TEMP
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E009
comma
id|SKERR_I2C_E009MSG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pSen-&gt;SenType
op_eq
id|SK_SEN_VOLT
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E010
comma
id|SKERR_I2C_E010MSG
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E014
comma
id|SKERR_I2C_E014MSG
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Check for NO error at all */
r_if
c_cond
(paren
op_logical_neg
id|IsError
op_logical_and
op_logical_neg
id|TooHigh
op_logical_and
op_logical_neg
id|TooLow
)paren
(brace
multiline_comment|/* Set o.k. Status if no error and no warning condition */
id|pSen-&gt;SenErrFlag
op_assign
id|SK_SEN_ERR_OK
suffix:semicolon
)brace
multiline_comment|/* End of check against the thresholds */
multiline_comment|/*&n;&t; * Check initialization state:&n;&t; * The VIO Thresholds need adaption&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pSen-&gt;SenInit
op_logical_and
id|pSen-&gt;SenReg
op_eq
id|LM80_VT1_IN
op_logical_and
id|pSen-&gt;SenValue
OG
id|SK_SEN_WARNLOW2C
op_logical_and
id|pSen-&gt;SenValue
OL
id|SK_SEN_WARNHIGH2
)paren
(brace
id|pSen-&gt;SenThreErrLow
op_assign
id|SK_SEN_ERRLOW2C
suffix:semicolon
id|pSen-&gt;SenThreWarnLow
op_assign
id|SK_SEN_WARNLOW2C
suffix:semicolon
id|pSen-&gt;SenInit
op_assign
id|SK_TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pSen-&gt;SenInit
op_logical_and
id|pSen-&gt;SenReg
op_eq
id|LM80_VT1_IN
op_logical_and
id|pSen-&gt;SenValue
OG
id|SK_SEN_WARNLOW2
op_logical_and
id|pSen-&gt;SenValue
OL
id|SK_SEN_WARNHIGH2C
)paren
(brace
id|pSen-&gt;SenThreErrHigh
op_assign
id|SK_SEN_ERRHIGH2C
suffix:semicolon
id|pSen-&gt;SenThreWarnHigh
op_assign
id|SK_SEN_WARNHIGH2C
suffix:semicolon
id|pSen-&gt;SenInit
op_assign
id|SK_TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pSen-&gt;SenInit
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_I2C_E013
comma
id|SKERR_I2C_E013MSG
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SkI2cCheckSensor*/
multiline_comment|/*&n; * The only Event to be served is the timeout event&n; *&n; */
DECL|function|SkI2cEvent
r_int
id|SkI2cEvent
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O Context */
id|SK_U32
id|Event
comma
multiline_comment|/* Module specific Event */
id|SK_EVPARA
id|Para
)paren
multiline_comment|/* Event specific Parameter */
(brace
r_int
id|ReadComplete
suffix:semicolon
id|SK_SENSOR
op_star
id|pSen
suffix:semicolon
id|SK_U32
id|Time
suffix:semicolon
id|SK_EVPARA
id|ParaLocal
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|Event
)paren
(brace
r_case
id|SK_I2CEV_IRQ
suffix:colon
r_case
id|SK_I2CEV_TIM
suffix:colon
id|pSen
op_assign
op_amp
id|pAC-&gt;I2c.SenTable
(braket
id|pAC-&gt;I2c.CurrSens
)braket
suffix:semicolon
id|ReadComplete
op_assign
id|SkI2cReadSensor
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pSen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadComplete
)paren
(brace
multiline_comment|/* Check sensor against defined thresholds */
id|SkI2cCheckSensor
(paren
id|pAC
comma
id|pSen
)paren
suffix:semicolon
multiline_comment|/* Increment Current and set appropriate Timeout */
id|Time
op_assign
id|SK_I2C_TIM_SHORT
suffix:semicolon
id|pAC-&gt;I2c.CurrSens
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;I2c.CurrSens
op_eq
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|pAC-&gt;I2c.CurrSens
op_assign
l_int|0
suffix:semicolon
id|Time
op_assign
id|SK_I2C_TIM_LONG
suffix:semicolon
)brace
multiline_comment|/* Start Timer */
id|ParaLocal.Para64
op_assign
(paren
id|SK_U64
)paren
l_int|0
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;I2c.SenTimer
comma
id|Time
comma
id|SKGE_I2C
comma
id|SK_I2CEV_TIM
comma
id|ParaLocal
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_I2CEV_CLEAR
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SK_MAX_SENSORS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenErrFlag
op_assign
id|SK_SEN_ERR_OK
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenErrCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenWarnCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenBegErrTS
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenBegWarnTS
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenLastErrTrapTS
op_assign
(paren
id|SK_U64
)paren
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenLastErrLogTS
op_assign
(paren
id|SK_U64
)paren
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenLastWarnTrapTS
op_assign
(paren
id|SK_U64
)paren
l_int|0
suffix:semicolon
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenLastWarnLogTS
op_assign
(paren
id|SK_U64
)paren
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_I2C_E006
comma
id|SKERR_I2C_E006MSG
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SkI2cEvent*/
macro_line|#endif&t;/* !SK_DIAG */ 
eof
