multiline_comment|/*****************************************************************************&n; *&n; * Name:&t;skgepnmi.c&n; * Project:&t;GEnesis, PCI Gigabit Ethernet Adapter&n; * Version:&t;$Revision: 1.78 $&n; * Date:&t;$Date: 2000/09/12 10:44:58 $&n; * Purpose:&t;Private Network Management Interface&n; *&n; ****************************************************************************/
multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998,1999 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/*****************************************************************************&n; *&n; * History:&n; *&n; *&t;$Log: skgepnmi.c,v $&n; *&t;Revision 1.78  2000/09/12 10:44:58  cgoos&n; *&t;Fixed SK_PNMI_STORE_U32 calls with typecasted argument.&n; *&t;&n; *&t;Revision 1.77  2000/09/07 08:10:19  rwahl&n; *&t;- Modified algorithm for 64bit NDIS statistic counters;&n; *&t;  returns 64bit or 32bit value depending on passed buffer&n; *&t;  size. Indicate capability for 64bit NDIS counter, if passed&n; *&t;  buffer size is zero. OID_GEN_XMIT_ERROR, OID_GEN_RCV_ERROR,&n; *&t;  and OID_GEN_RCV_NO_BUFFER handled as 64bit counter, too.&n; *&t;- corrected OID_SKGE_RLMT_PORT_PREFERRED.&n; *&t;&n; *&t;Revision 1.76  2000/08/03 15:23:39  rwahl&n; *&t;- Correction for FrameTooLong counter has to be moved to OID handling&n; *&t;  routines (instead of statistic counter routine).&n; *&t;- Fix in XMAC Reset Event handling: Only offset counter for hardware&n; *&t;  statistic registers are updated.&n; *&t;&n; *&t;Revision 1.75  2000/08/01 16:46:05  rwahl&n; *&t;- Added StatRxLongFrames counter and correction of FrameTooLong counter.&n; *&t;- Added directive to control width (default = 32bit) of NDIS statistic&n; *&t;  counters (SK_NDIS_64BIT_CTR).&n; *&t;&n; *&t;Revision 1.74  2000/07/04 11:41:53  rwahl&n; *&t;- Added volition connector type.&n; *&t;&n; *&t;Revision 1.73  2000/03/15 16:33:10  rwahl&n; *&t;Fixed bug 10510; wrong reset of virtual port statistic counters.&n; *&t;&n; *&t;Revision 1.72  1999/12/06 16:15:53  rwahl&n; *&t;Fixed problem of instance range for current and factory MAC address.&n; *&t;&n; *&t;Revision 1.71  1999/12/06 10:14:20  rwahl&n; *&t;Fixed bug 10476; set operation for PHY_OPERATION_MODE.&n; *&t;&n; *&t;Revision 1.70  1999/11/22 13:33:34  cgoos&n; *&t;Changed license header to GPL.&n; *&t;&n; *&t;Revision 1.69  1999/10/18 11:42:15  rwahl&n; *&t;Added typecasts for checking event dependent param (debug only).&n; *&t;&n; *&t;Revision 1.68  1999/10/06 09:35:59  cgoos&n; *&t;Added state check to PHY_READ call (hanged if called during startup).&n; *&t;&n; *&t;Revision 1.67  1999/09/22 09:53:20  rwahl&n; *&t;- Read Broadcom register for updating fcs error counter (1000Base-T).&n; *&t;&n; *&t;Revision 1.66  1999/08/26 13:47:56  rwahl&n; *&t;Added SK_DRIVER_SENDEVENT when queueing RLMT_CHANGE_THRES trap.&n; *&t;&n; *&t;Revision 1.65  1999/07/26 07:49:35  cgoos&n; *&t;Added two typecasts to avoid compiler warnings.&n; *&t;&n; *&t;Revision 1.64  1999/05/20 09:24:12  cgoos&n; *&t;Changes for 1000Base-T (sensors, Master/Slave).&n; *&t;&n; *&t;Revision 1.63  1999/04/13 15:11:58  mhaveman&n; *&t;Moved include of rlmt.h to header skgepnmi.h because some macros&n; *&t;are needed there.&n; *&t;&n; *&t;Revision 1.62  1999/04/13 15:08:07  mhaveman&n; *&t;Replaced again SK_RLMT_CHECK_LINK with SK_PNMI_RLMT_MODE_CHK_LINK&n; *&t;to grant unified interface by only using the PNMI header file.&n; *&t;SK_PNMI_RLMT_MODE_CHK_LINK is defined the same as SK_RLMT_CHECK_LINK.&n; *&t;&n; *&t;Revision 1.61  1999/04/13 15:02:48  mhaveman&n; *&t;Changes caused by review:&n; *&t;-Changed some comments&n; *&t;-Removed redundant check for OID_SKGE_PHYS_FAC_ADDR&n; *&t;-Optimized PRESET check.&n; *&t;-Meaning of error SK_ADDR_DUPLICATE_ADDRESS changed. Set of same&n; *&t; address will now not cause this error. Removed corresponding check.&n; *&t;&n; *&t;Revision 1.60  1999/03/23 10:41:23  mhaveman&n; *&t;Added comments.&n; *&t;&n; *&t;Revision 1.59  1999/02/19 08:01:28  mhaveman&n; *&t;Fixed bug 10372 that after counter reset all ports were displayed&n; *&t;as inactive.&n; *&t;&n; *&t;Revision 1.58  1999/02/16 18:04:47  mhaveman&n; *&t;Fixed problem of twisted OIDs SENSOR_WAR_TIME and SENSOR_ERR_TIME.&n; *&t;&n; *&t;Revision 1.56  1999/01/27 12:29:11  mhaveman&n; *&t;SkTimerStart was called with time value in milli seconds but needs&n; *&t;micro seconds.&n; *&t;&n; *&t;Revision 1.55  1999/01/25 15:00:38  mhaveman&n; *&t;Added support to allow multiple ports to be active. If this feature in&n; *&t;future will be used, the Management Data Base variables PORT_ACTIVE&n; *&t;and PORT_PREFERED should be moved to the port specific part of RLMT.&n; *&t;Currently they return the values of the first active physical port&n; *&t;found. A set to the virtual port will actually change all active&n; *&t;physical ports. A get returns the melted values of all active physical&n; *&t;ports. If the port values differ a return value INDETERMINATED will&n; *&t;be returned. This effects especially the CONF group.&n; *&t;&n; *&t;Revision 1.54  1999/01/19 10:10:22  mhaveman&n; *&t;-Fixed bug 10354: Counter values of virtual port were wrong after port&n; *&t; switches&n; *&t;-Added check if a switch to the same port is notified.&n; *&t;&n; *&t;Revision 1.53  1999/01/07 09:25:21  mhaveman&n; *&t;Forgot to initialize a variable.&n; *&t;&n; *&t;Revision 1.52  1999/01/05 10:34:33  mhaveman&n; *&t;Fixed little error in RlmtChangeEstimate calculation.&n; *&t;&n; *&t;Revision 1.51  1999/01/05 09:59:07  mhaveman&n; *&t;-Moved timer start to init level 2&n; *&t;-Redesigned port switch average calculation to avoid 64bit&n; *&t; arithmetic.&n; *&t;&n; *&t;Revision 1.50  1998/12/10 15:13:59  mhaveman&n; *&t;-Fixed: PHYS_CUR_ADDR returned wrong addresses&n; *&t;-Fixed: RLMT_PORT_PREFERED and RLMT_CHANGE_THRES preset returned&n; *&t;        always BAD_VALUE.&n; *&t;-Fixed: TRAP buffer seemed to sometimes suddenly empty&n; *&t;&n; *&t;Revision 1.49  1998/12/09 16:17:07  mhaveman&n; *&t;Fixed: Couldnot delete VPD keys on UNIX.&n; *&t;&n; *&t;Revision 1.48  1998/12/09 14:11:10  mhaveman&n; *&t;-Add: Debugmessage for XMAC_RESET supressed to minimize output.&n; *&t;-Fixed: RlmtChangeThreshold will now be initialized.&n; *&t;-Fixed: VPD_ENTRIES_LIST extended value with unnecessary space char.&n; *&t;-Fixed: On VPD key creation an invalid key name could be created&n; *&t;        (e.g. A5)&n; *&t;-Some minor changes in comments and code.&n; *&t;&n; *&t;Revision 1.47  1998/12/08 16:00:31  mhaveman&n; *&t;-Fixed: For RLMT_PORT_ACTIVE will now be returned a 0 if no port&n; *&t;&t;is active.&n; *&t;-Fixed: For the RLMT statistics group only the last value was&n; *&t;&t;returned and the rest of the buffer was filled with 0xff&n; *&t;-Fixed: Mysteriously the preset on RLMT_MODE still returned&n; *&t;&t;BAD_VALUE.&n; *&t;Revision 1.46  1998/12/08 10:04:56  mhaveman&n; *&t;-Fixed: Preset on RLMT_MODE returned always BAD_VALUE error.&n; *&t;-Fixed: Alignment error in GetStruct&n; *&t;-Fixed: If for Get/Preset/SetStruct the buffer size is equal or&n; *&t;        larger than SK_PNMI_MIN_STRUCT_SIZE the return value is stored&n; *&t;&t;to the buffer. In this case the caller should always return&n; *&t;        ok to its upper routines. Only if the buffer size is less&n; *&t;        than SK_PNMI_MIN_STRUCT_SIZE and the return value is unequal&n; *&t;        to 0, an error should be returned by the caller.&n; *&t;-Fixed: Wrong number of instances with RLMT statistic.&n; *&t;-Fixed: Return now SK_LMODE_STAT_UNKNOWN if the LinkModeStatus is 0.&n; *&t;&n; *&t;Revision 1.45  1998/12/03 17:17:24  mhaveman&n; *&t;-Removed for VPD create action the buffer size limitation to 4 bytes.&n; *&t;-Pass now physical/active physical port to ADDR for CUR_ADDR set&n; *&t;&n; *&t;Revision 1.44  1998/12/03 15:14:35  mhaveman&n; *&t;Another change to Vpd instance evaluation.&n; *&n; *&t;Revision 1.43  1998/12/03 14:18:10  mhaveman&n; *&t;-Fixed problem in PnmiSetStruct. It was impossible to set any value.&n; *&t;-Removed VPD key evaluation for VPD_FREE_BYTES and VPD_ACTION.&n; *&t;&n; *&t;Revision 1.42  1998/12/03 11:31:47  mhaveman&n; *&t;Inserted cast to satisfy lint.&n; *&t;&n; *&t;Revision 1.41  1998/12/03 11:28:16  mhaveman&n; *&t;Removed SK_PNMI_CHECKPTR&n; *&t;&n; *&t;Revision 1.40  1998/12/03 11:19:07  mhaveman&n; *&t;Fixed problems&n; *&t;-A set to virtual port will now be ignored. A set with broadcast&n; *&t; address to any port will be ignored.&n; *&t;-GetStruct function made VPD instance calculation wrong.&n; *&t;-Prefered port returned -1 instead of 0.&n; *&t;&n; *&t;Revision 1.39  1998/11/26 15:30:29  mhaveman&n; *&t;Added sense mode to link mode.&n; *&t;&n; *&t;Revision 1.38  1998/11/23 15:34:00  mhaveman&n; *&t;-Fixed bug for RX counters. On an RX overflow interrupt the high&n; *&t; words of all RX counters were incremented.&n; *&t;-SET operations on FLOWCTRL_MODE and LINK_MODE accept now the&n; *&t; value 0, which has no effect. It is usefull for multiple instance&n; *&t; SETs.&n; *&t;&n; *&t;Revision 1.37  1998/11/20 08:02:04  mhaveman&n; *&t;-Fixed: Ports were compared with MAX_SENSORS&n; *&t;-Fixed: Crash in GetTrapEntry with MEMSET macro&n; *&t;-Fixed: Conversions between physical, logical port index and instance&n; *&t;&n; *&t;Revision 1.36  1998/11/16 07:48:53  mhaveman&n; *&t;Casted SK_DRIVER_SENDEVENT with (void) to eleminate compiler warnings&n; *&t;on Solaris.&n; *&t;&n; *&t;Revision 1.35  1998/11/16 07:45:34  mhaveman&n; *&t;SkAddrOverride now returns value and will be checked.&n; *&t;&n; *&t;Revision 1.34  1998/11/10 13:40:37  mhaveman&n; *&t;Needed to change interface, because NT driver needs a return value&n; *&t;of needed buffer space on TOO_SHORT errors. Therefore all&n; *&t;SkPnmiGet/Preset/Set functions now have a pointer to the length&n; *&t;parameter, where the needed space on error is returned.&n; *&t;&n; *&t;Revision 1.33  1998/11/03 13:52:46  mhaveman&n; *&t;Made file lint conform.&n; *&t;&n; *&t;Revision 1.32  1998/11/03 13:19:07  mhaveman&n; *&t;The events SK_HWEV_SET_LMODE and SK_HWEV_SET_FLOWMODE pass now in&n; *&t;Para32[0] the physical MAC index and in Para32[1] the new mode.&n; *&t;&n; *&t;Revision 1.31  1998/11/03 12:30:40  gklug&n; *&t;fix: compiler warning memset&n; *&n; *&t;Revision 1.30  1998/11/03 12:04:46  mhaveman&n; *&t;Fixed problem in SENSOR_VALUE, which wrote beyond the buffer end&n; *&t;Fixed alignment problem with CHIPSET.&n; *&t;&n; *&t;Revision 1.29  1998/11/02 11:23:54  mhaveman&n; *&t;Corrected SK_ERROR_LOG to SK_ERR_LOG. Sorry.&n; *&t;&n; *&t;Revision 1.28  1998/11/02 10:47:16  mhaveman&n; *&t;Added syslog messages for internal errors.&n; *&t;&n; *&t;Revision 1.27  1998/10/30 15:48:06  mhaveman&n; *&t;Fixed problems after simulation of SK_PNMI_EVT_CHG_EST_TIMER and&n; *&t;RlmtChangeThreshold calculation.&n; *&t;&n; *&t;Revision 1.26  1998/10/29 15:36:55  mhaveman&n; *&t;-Fixed bug in trap buffer handling.&n; *&t;-OID_SKGE_DRIVER_DESCR, OID_SKGE_DRIVER_VERSION, OID_SKGE_HW_DESCR,&n; *&t; OID_SKGE_HW_VERSION, OID_SKGE_VPD_ENTRIES_LIST, OID_SKGE_VPD_KEY,&n; *&t; OID_SKGE_VPD_VALUE, and OID_SKGE_SENSOR_DESCR return values with&n; *&t; a leading octet before each string storing the string length.&n; *&t;-Perform a RlmtUpdate during SK_PNMI_EVT_XMAC_RESET to minimize&n; *&t; RlmtUpdate calls in GetStatVal.&n; *&t;-Inserted SK_PNMI_CHECKFLAGS macro increase readability.&n; *&t;&n; *&t;Revision 1.25  1998/10/29 08:50:36  mhaveman&n; *&t;Fixed problems after second event simulation.&n; *&t;&n; *&t;Revision 1.24  1998/10/28 08:44:37  mhaveman&n; *&t;-Fixed alignment problem&n; *&t;-Fixed problems during event simulation&n; *&t;-Fixed sequence of error return code (INSTANCE -&gt; ACCESS -&gt; SHORT)&n; *&t;-Changed type of parameter Instance back to SK_U32 because of VPD&n; *&t;-Updated new VPD function calls&n; *&t;&n; *&t;Revision 1.23  1998/10/23 10:16:37  mhaveman&n; *&t;Fixed bugs after buffer test simulation.&n; *&t;&n; *&t;Revision 1.22  1998/10/21 13:23:52  mhaveman&n; *&t;-Call syntax of SkOsGetTime() changed to SkOsGetTime(pAc).&n; *&t;-Changed calculation of hundrets of seconds.&n; *&t;&n; *&t;Revision 1.20  1998/10/20 07:30:45  mhaveman&n; *&t;Made type changes to unsigned integer where possible.&n; *&t;&n; *&t;Revision 1.19  1998/10/19 10:51:30  mhaveman&n; *&t;-Made Bug fixes after simulation run&n; *&t;-Renamed RlmtMAC... to RlmtPort...&n; *&t;-Marked workarounds with Errata comments&n; *&t;&n; *&t;Revision 1.18  1998/10/14 07:50:08  mhaveman&n; *&t;-For OID_SKGE_LINK_STATUS the link down detection has moved from RLMT&n; *&t; to HWACCESS.&n; *&t;-Provided all MEMCPY/MEMSET macros with (char *) pointers, because&n; *&t; Solaris throwed warnings when mapping to bcopy/bset.&n; *&t;&n; *&t;Revision 1.17  1998/10/13 07:42:01  mhaveman&n; *&t;-Added OIDs OID_SKGE_TRAP_NUMBER and OID_SKGE_ALL_DATA&n; *&t;-Removed old cvs history entries&n; *&t;-Renamed MacNumber to PortNumber&n; *&t;&n; *&t;Revision 1.16  1998/10/07 10:52:49  mhaveman&n; *&t;-Inserted handling of some OID_GEN_ Ids for windows&n; *&t;-Fixed problem with 803.2 statistic.&n; *&t;&n; *&t;Revision 1.15  1998/10/01 09:16:29  mhaveman&n; *&t;Added Debug messages for function call and UpdateFlag tracing.&n; *&t;&n; *&t;Revision 1.14  1998/09/30 13:39:09  mhaveman&n; *&t;-Reduced namings of &squot;MAC&squot; by replacing them with &squot;PORT&squot;.&n; *&t;-Completed counting of OID_SKGE_RX_HW_ERROR_CTS,&n; *       OID_SKGE_TX_HW_ERROR_CTS,&n; *&t; OID_SKGE_IN_ERRORS_CTS, and OID_SKGE_OUT_ERROR_CTS.&n; *&t;-SET check for RlmtMode&n; *&t;&n; *&t;Revision 1.13  1998/09/28 13:13:08  mhaveman&n; *&t;Hide strcmp, strlen, and strncpy behind macros SK_STRCMP, SK_STRLEN,&n; *&t;and SK_STRNCPY. (Same reasons as for mem.. and MEM..)&n; *&t;&n; *&t;Revision 1.12  1998/09/16 08:18:36  cgoos&n; *&t;Fix: XM_INxx and XM_OUTxx called with different parameter order:&n; *      sometimes IoC,Mac,...  sometimes Mac,IoC,... Now always first variant.&n; *&t;Fix: inserted &quot;Pnmi.&quot; into some pAC-&gt;pDriverDescription / Version.&n; *&t;Change: memset, memcpy to makros SK_MEMSET, SK_MEMCPY&n; *&n; *&t;Revision 1.11  1998/09/04 17:01:45  mhaveman&n; *&t;Added SyncCounter as macro and OID_SKGE_.._NO_DESCR_CTS to&n; *&t;OID_SKGE_RX_NO_BUF_CTS.&n; *&t;&n; *&t;Revision 1.10  1998/09/04 14:35:35  mhaveman&n; *&t;Added macro counters, that are counted by driver.&n; *&t;&n; ****************************************************************************/
DECL|variable|SysKonnectFileId
r_static
r_const
r_char
id|SysKonnectFileId
(braket
)braket
op_assign
l_string|&quot;@(#) $Id: skgepnmi.c,v 1.78 2000/09/12 10:44:58 cgoos Exp $&quot;
l_string|&quot; (C) SysKonnect.&quot;
suffix:semicolon
macro_line|#include &quot;h/skdrv1st.h&quot;
macro_line|#include &quot;h/sktypes.h&quot;
macro_line|#include &quot;h/xmac_ii.h&quot;
macro_line|#include &quot;h/skdebug.h&quot;
macro_line|#include &quot;h/skqueue.h&quot;
macro_line|#include &quot;h/skgepnmi.h&quot;
macro_line|#include &quot;h/skgesirq.h&quot;
macro_line|#include &quot;h/skcsum.h&quot;
macro_line|#include &quot;h/skvpd.h&quot;
macro_line|#include &quot;h/skgehw.h&quot;
macro_line|#include &quot;h/skgeinit.h&quot;
macro_line|#include &quot;h/skdrv2nd.h&quot;
macro_line|#include &quot;h/skgepnm2.h&quot;
multiline_comment|/*&n; * Public Function prototypes&n; */
r_int
id|SkPnmiInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|level
)paren
suffix:semicolon
r_int
id|SkPnmiGetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
)paren
suffix:semicolon
r_int
id|SkPnmiPreSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
)paren
suffix:semicolon
r_int
id|SkPnmiSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
)paren
suffix:semicolon
r_int
id|SkPnmiGetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
)paren
suffix:semicolon
r_int
id|SkPnmiPreSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
)paren
suffix:semicolon
r_int
id|SkPnmiSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
)paren
suffix:semicolon
r_int
id|SkPnmiEvent
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Event
comma
id|SK_EVPARA
id|Param
)paren
suffix:semicolon
multiline_comment|/*&n; * Private Function prototypes&n; */
r_static
r_int
id|Addr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
id|SK_U8
id|CalculateLinkModeStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|PhysPortIndex
)paren
suffix:semicolon
r_static
id|SK_U8
id|CalculateLinkStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|PhysPortIndex
)paren
suffix:semicolon
r_static
r_void
id|CopyMac
c_func
(paren
r_char
op_star
id|pDst
comma
id|SK_MAC_ADDR
op_star
id|pMac
)paren
suffix:semicolon
r_static
r_void
id|CopyTrapQueue
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
r_char
op_star
id|pDstBuf
)paren
suffix:semicolon
r_static
r_int
id|CsumStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|General
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
id|SK_U64
id|GetPhysStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|PhysPortIndex
comma
r_int
r_int
id|StatIndex
)paren
suffix:semicolon
r_static
id|SK_U64
id|GetStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|LogPortIndex
comma
r_int
r_int
id|StatIndex
)paren
suffix:semicolon
r_static
r_char
op_star
id|GetTrapEntry
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
comma
r_int
r_int
id|Size
)paren
suffix:semicolon
r_static
r_void
id|GetTrapQueueLen
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
r_int
r_int
op_star
id|pLen
comma
r_int
r_int
op_star
id|pEntries
)paren
suffix:semicolon
r_static
r_int
id|GetVpdKeyArr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_char
op_star
id|pKeyArr
comma
r_int
r_int
id|KeyArrLen
comma
r_int
r_int
op_star
id|pKeyNo
)paren
suffix:semicolon
r_static
r_int
id|LookupId
c_func
(paren
id|SK_U32
id|Id
)paren
suffix:semicolon
r_static
r_int
id|Mac8023Stat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|MacPrivateConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|MacPrivateStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|MacUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|FirstMac
comma
r_int
r_int
id|LastMac
)paren
suffix:semicolon
r_static
r_int
id|Monitor
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|OidStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|Perform
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|PnmiStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|Action
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
)paren
suffix:semicolon
r_static
r_int
id|PnmiVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|Action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
)paren
suffix:semicolon
r_static
r_void
id|QueueRlmtNewMacTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
r_int
r_int
id|ActiveMac
)paren
suffix:semicolon
r_static
r_void
id|QueueRlmtPortTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
comma
r_int
r_int
id|PortIndex
)paren
suffix:semicolon
r_static
r_void
id|QueueSensorTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
comma
r_int
r_int
id|SensorIndex
)paren
suffix:semicolon
r_static
r_void
id|QueueSimpleTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
)paren
suffix:semicolon
r_static
r_void
id|ResetCounter
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
)paren
suffix:semicolon
r_static
r_int
id|Rlmt
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|RlmtStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|RlmtUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
)paren
suffix:semicolon
r_static
r_int
id|SensorStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
r_static
r_int
id|SirqUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
)paren
suffix:semicolon
r_static
r_void
id|VirtualConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
)paren
suffix:semicolon
r_static
r_int
id|Vpd
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
)paren
suffix:semicolon
multiline_comment|/******************************************************************************&n; *&n; * Global variables&n; */
multiline_comment|/*&n; * Table to correlate OID with handler function and index to&n; * hardware register stored in StatAddress if applicable.&n; */
DECL|variable|IdTable
r_static
r_const
id|SK_PNMI_TAB_ENTRY
id|IdTable
(braket
)braket
op_assign
(brace
(brace
id|OID_GEN_XMIT_OK
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX
)brace
comma
(brace
id|OID_GEN_RCV_OK
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX
)brace
comma
(brace
id|OID_GEN_XMIT_ERROR
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_GEN_RCV_ERROR
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_GEN_RCV_NO_BUFFER
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_GEN_DIRECTED_FRAMES_XMIT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_UNICAST
)brace
comma
(brace
id|OID_GEN_MULTICAST_FRAMES_XMIT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_MULTICAST
)brace
comma
(brace
id|OID_GEN_BROADCAST_FRAMES_XMIT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_BROADCAST
)brace
comma
(brace
id|OID_GEN_DIRECTED_FRAMES_RCV
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX_UNICAST
)brace
comma
(brace
id|OID_GEN_MULTICAST_FRAMES_RCV
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX_MULTICAST
)brace
comma
(brace
id|OID_GEN_BROADCAST_FRAMES_RCV
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX_BROADCAST
)brace
comma
(brace
id|OID_GEN_RCV_CRC_ERROR
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX_FCS
)brace
comma
(brace
id|OID_GEN_TRANSMIT_QUEUE_LENGTH
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_802_3_PERMANENT_ADDRESS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
l_int|0
)brace
comma
(brace
id|OID_802_3_CURRENT_ADDRESS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
l_int|0
)brace
comma
(brace
id|OID_802_3_RCV_ERROR_ALIGNMENT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX_FRAMING
)brace
comma
(brace
id|OID_802_3_XMIT_ONE_COLLISION
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_SINGLE_COL
)brace
comma
(brace
id|OID_802_3_XMIT_MORE_COLLISIONS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_MULTI_COL
)brace
comma
(brace
id|OID_802_3_XMIT_DEFERRED
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_DEFFERAL
)brace
comma
(brace
id|OID_802_3_XMIT_MAX_COLLISIONS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_EXCESS_COL
)brace
comma
(brace
id|OID_802_3_RCV_OVERRUN
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HRX_OVERFLOW
)brace
comma
(brace
id|OID_802_3_XMIT_UNDERRUN
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_UNDERRUN
)brace
comma
(brace
id|OID_802_3_XMIT_TIMES_CRS_LOST
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_CARRIER
)brace
comma
(brace
id|OID_802_3_XMIT_LATE_COLLISIONS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|Mac8023Stat
comma
id|SK_PNMI_HTX_LATE_COL
)brace
comma
(brace
id|OID_SKGE_MDB_VERSION
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|MgmtDBVersion
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SUPPORTED_LIST
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_ALL_DATA
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|SK_PNMI_RW
comma
id|OidStruct
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_FREE_BYTES
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|VpdFreeBytes
)paren
comma
id|SK_PNMI_RO
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_ENTRIES_LIST
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|VpdEntriesList
)paren
comma
id|SK_PNMI_RO
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_ENTRIES_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|VpdEntriesNumber
)paren
comma
id|SK_PNMI_RO
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_KEY
comma
id|SK_PNMI_VPD_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_VPD
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Vpd
)paren
op_plus
id|SK_PNMI_VPD_OFF
c_func
(paren
id|VpdKey
)paren
comma
id|SK_PNMI_RO
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_VALUE
comma
id|SK_PNMI_VPD_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_VPD
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Vpd
)paren
op_plus
id|SK_PNMI_VPD_OFF
c_func
(paren
id|VpdValue
)paren
comma
id|SK_PNMI_RO
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_ACCESS
comma
id|SK_PNMI_VPD_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_VPD
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Vpd
)paren
op_plus
id|SK_PNMI_VPD_OFF
c_func
(paren
id|VpdAccess
)paren
comma
id|SK_PNMI_RO
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_VPD_ACTION
comma
id|SK_PNMI_VPD_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_VPD
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Vpd
)paren
op_plus
id|SK_PNMI_VPD_OFF
c_func
(paren
id|VpdAction
)paren
comma
id|SK_PNMI_RW
comma
id|Vpd
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_PORT_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|PortNumber
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_DEVICE_TYPE
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|DeviceType
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_DRIVER_DESCR
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|DriverDescr
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_DRIVER_VERSION
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|DriverVersion
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_HW_DESCR
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|HwDescr
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_HW_VERSION
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|HwVersion
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHIPSET
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|Chipset
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_ACTION
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|Action
)paren
comma
id|SK_PNMI_RW
comma
id|Perform
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RESULT
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TestResult
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_BUS_TYPE
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|BusType
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_BUS_SPEED
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|BusSpeed
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_BUS_WIDTH
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|BusWidth
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_SW_QUEUE_LEN
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxSwQueueLen
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_SW_QUEUE_MAX
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxSwQueueMax
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_RETRY
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxRetryCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RX_INTR_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RxIntrCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_INTR_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxIntrCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RX_NO_BUF_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RxNoBufCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_NO_BUF_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxNoBufCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_USED_DESCR_NO
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxUsedDescrNo
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RX_DELIVERED_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RxDeliveredCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RX_OCTETS_DELIV_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RxOctetsDeliveredCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RX_HW_ERROR_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RxHwErrorsCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TX_HW_ERROR_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TxHwErrorsCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_IN_ERRORS_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|InErrorsCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_OUT_ERROR_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|OutErrorsCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_ERR_RECOVERY_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|ErrRecoveryCts
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SYSUPTIME
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|SysUpTime
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|SensorNumber
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_INDEX
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorIndex
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_DESCR
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorDescr
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_TYPE
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorType
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_VALUE
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorValue
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_WAR_THRES_LOW
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorWarningThresholdLow
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_WAR_THRES_UPP
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorWarningThresholdHigh
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_ERR_THRES_LOW
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorErrorThresholdLow
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_ERR_THRES_UPP
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorErrorThresholdHigh
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_STATUS
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorStatus
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_WAR_CTS
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorWarningCts
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_ERR_CTS
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorErrorCts
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_WAR_TIME
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorWarningTimestamp
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_SENSOR_ERR_TIME
comma
id|SK_PNMI_SENSOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_SENSOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Sensor
)paren
op_plus
id|SK_PNMI_SEN_OFF
c_func
(paren
id|SensorErrorTimestamp
)paren
comma
id|SK_PNMI_RO
comma
id|SensorStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHKSM_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|ChecksumNumber
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHKSM_RX_OK_CTS
comma
id|SKCS_NUM_PROTOCOLS
comma
r_sizeof
(paren
id|SK_PNMI_CHECKSUM
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Checksum
)paren
op_plus
id|SK_PNMI_CHK_OFF
c_func
(paren
id|ChecksumRxOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|CsumStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHKSM_RX_UNABLE_CTS
comma
id|SKCS_NUM_PROTOCOLS
comma
r_sizeof
(paren
id|SK_PNMI_CHECKSUM
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Checksum
)paren
op_plus
id|SK_PNMI_CHK_OFF
c_func
(paren
id|ChecksumRxUnableCts
)paren
comma
id|SK_PNMI_RO
comma
id|CsumStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHKSM_RX_ERR_CTS
comma
id|SKCS_NUM_PROTOCOLS
comma
r_sizeof
(paren
id|SK_PNMI_CHECKSUM
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Checksum
)paren
op_plus
id|SK_PNMI_CHK_OFF
c_func
(paren
id|ChecksumRxErrCts
)paren
comma
id|SK_PNMI_RO
comma
id|CsumStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHKSM_TX_OK_CTS
comma
id|SKCS_NUM_PROTOCOLS
comma
r_sizeof
(paren
id|SK_PNMI_CHECKSUM
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Checksum
)paren
op_plus
id|SK_PNMI_CHK_OFF
c_func
(paren
id|ChecksumTxOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|CsumStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CHKSM_TX_UNABLE_CTS
comma
id|SKCS_NUM_PROTOCOLS
comma
r_sizeof
(paren
id|SK_PNMI_CHECKSUM
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Checksum
)paren
op_plus
id|SK_PNMI_CHK_OFF
c_func
(paren
id|ChecksumTxUnableCts
)paren
comma
id|SK_PNMI_RO
comma
id|CsumStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_STAT_TX
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX
)brace
comma
(brace
id|OID_SKGE_STAT_TX_OCTETS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxOctetsOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_OCTET
)brace
comma
(brace
id|OID_SKGE_STAT_TX_BROADCAST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxBroadcastOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_BROADCAST
)brace
comma
(brace
id|OID_SKGE_STAT_TX_MULTICAST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxMulticastOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_MULTICAST
)brace
comma
(brace
id|OID_SKGE_STAT_TX_UNICAST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxUnicastOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_UNICAST
)brace
comma
(brace
id|OID_SKGE_STAT_TX_LONGFRAMES
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxLongFramesCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_LONGFRAMES
)brace
comma
(brace
id|OID_SKGE_STAT_TX_BURST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxBurstCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_BURST
)brace
comma
(brace
id|OID_SKGE_STAT_TX_PFLOWC
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxPauseMacCtrlCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_PMACC
)brace
comma
(brace
id|OID_SKGE_STAT_TX_FLOWC
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxMacCtrlCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_MACC
)brace
comma
(brace
id|OID_SKGE_STAT_TX_SINGLE_COL
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxSingleCollisionCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_SINGLE_COL
)brace
comma
(brace
id|OID_SKGE_STAT_TX_MULTI_COL
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxMultipleCollisionCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_MULTI_COL
)brace
comma
(brace
id|OID_SKGE_STAT_TX_EXCESS_COL
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxExcessiveCollisionCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_EXCESS_COL
)brace
comma
(brace
id|OID_SKGE_STAT_TX_LATE_COL
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxLateCollisionCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_LATE_COL
)brace
comma
(brace
id|OID_SKGE_STAT_TX_DEFFERAL
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxDeferralCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_DEFFERAL
)brace
comma
(brace
id|OID_SKGE_STAT_TX_EXCESS_DEF
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxExcessiveDeferralCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_EXCESS_DEF
)brace
comma
(brace
id|OID_SKGE_STAT_TX_UNDERRUN
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxFifoUnderrunCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_UNDERRUN
)brace
comma
(brace
id|OID_SKGE_STAT_TX_CARRIER
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxCarrierCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_CARRIER
)brace
comma
multiline_comment|/*&t;{OID_SKGE_STAT_TX_UTIL,&n;&t;&t;SK_PNMI_MAC_ENTRIES,&n;&t;&t;sizeof(SK_PNMI_STAT),&n;&t;&t;SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxUtilization),&n;&t;&t;SK_PNMI_RO, MacPrivateStat, (SK_U16)(-1)}, */
(brace
id|OID_SKGE_STAT_TX_64
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTx64Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_64
)brace
comma
(brace
id|OID_SKGE_STAT_TX_127
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTx127Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_127
)brace
comma
(brace
id|OID_SKGE_STAT_TX_255
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTx255Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_255
)brace
comma
(brace
id|OID_SKGE_STAT_TX_511
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTx511Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_511
)brace
comma
(brace
id|OID_SKGE_STAT_TX_1023
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTx1023Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_1023
)brace
comma
(brace
id|OID_SKGE_STAT_TX_MAX
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxMaxCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_MAX
)brace
comma
(brace
id|OID_SKGE_STAT_TX_SYNC
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxSyncCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_SYNC
)brace
comma
(brace
id|OID_SKGE_STAT_TX_SYNC_OCTETS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatTxSyncOctetsCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HTX_SYNC_OCTET
)brace
comma
(brace
id|OID_SKGE_STAT_RX
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX
)brace
comma
(brace
id|OID_SKGE_STAT_RX_OCTETS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxOctetsOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_OCTET
)brace
comma
(brace
id|OID_SKGE_STAT_RX_BROADCAST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxBroadcastOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_BROADCAST
)brace
comma
(brace
id|OID_SKGE_STAT_RX_MULTICAST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxMulticastOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_MULTICAST
)brace
comma
(brace
id|OID_SKGE_STAT_RX_UNICAST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxUnicastOkCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_UNICAST
)brace
comma
(brace
id|OID_SKGE_STAT_RX_LONGFRAMES
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxLongFramesCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_LONGFRAMES
)brace
comma
(brace
id|OID_SKGE_STAT_RX_PFLOWC
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxPauseMacCtrlCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_PMACC
)brace
comma
(brace
id|OID_SKGE_STAT_RX_FLOWC
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxMacCtrlCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_MACC
)brace
comma
(brace
id|OID_SKGE_STAT_RX_PFLOWC_ERR
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxPauseMacCtrlErrorCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_PMACC_ERR
)brace
comma
(brace
id|OID_SKGE_STAT_RX_FLOWC_UNKWN
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxMacCtrlUnknownCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_MACC_UNKWN
)brace
comma
(brace
id|OID_SKGE_STAT_RX_BURST
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxBurstCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_BURST
)brace
comma
(brace
id|OID_SKGE_STAT_RX_MISSED
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxMissedCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_MISSED
)brace
comma
(brace
id|OID_SKGE_STAT_RX_FRAMING
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxFramingCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_FRAMING
)brace
comma
(brace
id|OID_SKGE_STAT_RX_OVERFLOW
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxFifoOverflowCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_OVERFLOW
)brace
comma
(brace
id|OID_SKGE_STAT_RX_JABBER
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxJabberCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_JABBER
)brace
comma
(brace
id|OID_SKGE_STAT_RX_CARRIER
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxCarrierCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_CARRIER
)brace
comma
(brace
id|OID_SKGE_STAT_RX_IR_LENGTH
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxIRLengthCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_IRLENGTH
)brace
comma
(brace
id|OID_SKGE_STAT_RX_SYMBOL
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxSymbolCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_SYMBOL
)brace
comma
(brace
id|OID_SKGE_STAT_RX_SHORTS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxShortsCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_SHORTS
)brace
comma
(brace
id|OID_SKGE_STAT_RX_RUNT
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxRuntCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_RUNT
)brace
comma
(brace
id|OID_SKGE_STAT_RX_CEXT
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxCextCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_CEXT
)brace
comma
(brace
id|OID_SKGE_STAT_RX_TOO_LONG
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxTooLongCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_TOO_LONG
)brace
comma
(brace
id|OID_SKGE_STAT_RX_FCS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxFcsCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_FCS
)brace
comma
multiline_comment|/*&t;{OID_SKGE_STAT_RX_UTIL,&n;&t;&t;SK_PNMI_MAC_ENTRIES,&n;&t;&t;sizeof(SK_PNMI_STAT),&n;&t;&t;SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxUtilization),&n;&t;&t;SK_PNMI_RO, MacPrivateStat, (SK_U16)(-1)}, */
(brace
id|OID_SKGE_STAT_RX_64
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRx64Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_64
)brace
comma
(brace
id|OID_SKGE_STAT_RX_127
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRx127Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_127
)brace
comma
(brace
id|OID_SKGE_STAT_RX_255
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRx255Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_255
)brace
comma
(brace
id|OID_SKGE_STAT_RX_511
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRx511Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_511
)brace
comma
(brace
id|OID_SKGE_STAT_RX_1023
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRx1023Cts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_1023
)brace
comma
(brace
id|OID_SKGE_STAT_RX_MAX
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_STAT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Stat
)paren
op_plus
id|SK_PNMI_STA_OFF
c_func
(paren
id|StatRxMaxCts
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateStat
comma
id|SK_PNMI_HRX_MAX
)brace
comma
(brace
id|OID_SKGE_PHYS_CUR_ADDR
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfMacCurrentAddr
)paren
comma
id|SK_PNMI_RW
comma
id|Addr
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_PHYS_FAC_ADDR
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfMacFactoryAddr
)paren
comma
id|SK_PNMI_RO
comma
id|Addr
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_PMD
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfPMD
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_CONNECTOR
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfConnector
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_LINK_CAP
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfLinkCapability
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_LINK_MODE
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfLinkMode
)paren
comma
id|SK_PNMI_RW
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_LINK_MODE_STATUS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfLinkModeStatus
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_LINK_STATUS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfLinkStatus
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_FLOWCTRL_CAP
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfFlowCtrlCapability
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_FLOWCTRL_MODE
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfFlowCtrlMode
)paren
comma
id|SK_PNMI_RW
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_FLOWCTRL_STATUS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfFlowCtrlStatus
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_PHY_OPERATION_CAP
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfPhyOperationCapability
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_PHY_OPERATION_MODE
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfPhyOperationMode
)paren
comma
id|SK_PNMI_RW
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_PHY_OPERATION_STATUS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_CONF
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Conf
)paren
op_plus
id|SK_PNMI_CNF_OFF
c_func
(paren
id|ConfPhyOperationStatus
)paren
comma
id|SK_PNMI_RO
comma
id|MacPrivateConf
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TRAP
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|Trap
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_TRAP_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|TrapNumber
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MODE
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtMode
)paren
comma
id|SK_PNMI_RW
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_PORT_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtPortNumber
)paren
comma
id|SK_PNMI_RO
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_PORT_ACTIVE
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtPortActive
)paren
comma
id|SK_PNMI_RO
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_PORT_PREFERRED
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtPortPreferred
)paren
comma
id|SK_PNMI_RW
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_CHANGE_CTS
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtChangeCts
)paren
comma
id|SK_PNMI_RO
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_CHANGE_TIME
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtChangeTime
)paren
comma
id|SK_PNMI_RO
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_CHANGE_ESTIM
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtChangeEstimate
)paren
comma
id|SK_PNMI_RO
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_CHANGE_THRES
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtChangeThreshold
)paren
comma
id|SK_PNMI_RW
comma
id|Rlmt
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_PORT_INDEX
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Rlmt
)paren
op_plus
id|SK_PNMI_RLM_OFF
c_func
(paren
id|RlmtIndex
)paren
comma
id|SK_PNMI_RO
comma
id|RlmtStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_STATUS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Rlmt
)paren
op_plus
id|SK_PNMI_RLM_OFF
c_func
(paren
id|RlmtStatus
)paren
comma
id|SK_PNMI_RO
comma
id|RlmtStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_TX_HELLO_CTS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Rlmt
)paren
op_plus
id|SK_PNMI_RLM_OFF
c_func
(paren
id|RlmtTxHelloCts
)paren
comma
id|SK_PNMI_RO
comma
id|RlmtStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_RX_HELLO_CTS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Rlmt
)paren
op_plus
id|SK_PNMI_RLM_OFF
c_func
(paren
id|RlmtRxHelloCts
)paren
comma
id|SK_PNMI_RO
comma
id|RlmtStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_TX_SP_REQ_CTS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Rlmt
)paren
op_plus
id|SK_PNMI_RLM_OFF
c_func
(paren
id|RlmtTxSpHelloReqCts
)paren
comma
id|SK_PNMI_RO
comma
id|RlmtStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_RX_SP_CTS
comma
id|SK_PNMI_MAC_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|Rlmt
)paren
op_plus
id|SK_PNMI_RLM_OFF
c_func
(paren
id|RlmtRxSpHelloCts
)paren
comma
id|SK_PNMI_RO
comma
id|RlmtStat
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MONITOR_NUMBER
comma
l_int|1
comma
l_int|0
comma
id|SK_PNMI_MAI_OFF
c_func
(paren
id|RlmtMonitorNumber
)paren
comma
id|SK_PNMI_RO
comma
id|General
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MONITOR_INDEX
comma
id|SK_PNMI_MONITOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT_MONITOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|RlmtMonitor
)paren
op_plus
id|SK_PNMI_MON_OFF
c_func
(paren
id|RlmtMonitorIndex
)paren
comma
id|SK_PNMI_RO
comma
id|Monitor
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MONITOR_ADDR
comma
id|SK_PNMI_MONITOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT_MONITOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|RlmtMonitor
)paren
op_plus
id|SK_PNMI_MON_OFF
c_func
(paren
id|RlmtMonitorAddr
)paren
comma
id|SK_PNMI_RO
comma
id|Monitor
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MONITOR_ERRS
comma
id|SK_PNMI_MONITOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT_MONITOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|RlmtMonitor
)paren
op_plus
id|SK_PNMI_MON_OFF
c_func
(paren
id|RlmtMonitorErrorCts
)paren
comma
id|SK_PNMI_RO
comma
id|Monitor
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MONITOR_TIMESTAMP
comma
id|SK_PNMI_MONITOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT_MONITOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|RlmtMonitor
)paren
op_plus
id|SK_PNMI_MON_OFF
c_func
(paren
id|RlmtMonitorTimestamp
)paren
comma
id|SK_PNMI_RO
comma
id|Monitor
comma
l_int|0
)brace
comma
(brace
id|OID_SKGE_RLMT_MONITOR_ADMIN
comma
id|SK_PNMI_MONITOR_ENTRIES
comma
r_sizeof
(paren
id|SK_PNMI_RLMT_MONITOR
)paren
comma
id|SK_PNMI_OFF
c_func
(paren
id|RlmtMonitor
)paren
op_plus
id|SK_PNMI_MON_OFF
c_func
(paren
id|RlmtMonitorAdmin
)paren
comma
id|SK_PNMI_RW
comma
id|Monitor
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Table for hardware register saving on resets and port switches&n;*/
DECL|variable|StatAddress
r_static
r_const
id|SK_PNMI_STATADDR
id|StatAddress
(braket
id|SK_PNMI_MAX_IDX
)braket
op_assign
(brace
multiline_comment|/*  0 */
(brace
id|TRUE
comma
id|XM_TXF_OK
)brace
comma
multiline_comment|/*  1 */
(brace
id|TRUE
comma
l_int|0
)brace
comma
multiline_comment|/*  2 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/*  3 */
(brace
id|TRUE
comma
id|XM_TXF_BC_OK
)brace
comma
multiline_comment|/*  4 */
(brace
id|TRUE
comma
id|XM_TXF_MC_OK
)brace
comma
multiline_comment|/*  5 */
(brace
id|TRUE
comma
id|XM_TXF_UC_OK
)brace
comma
multiline_comment|/*  6 */
(brace
id|TRUE
comma
id|XM_TXF_LONG
)brace
comma
multiline_comment|/*  7 */
(brace
id|TRUE
comma
id|XM_TXE_BURST
)brace
comma
multiline_comment|/*  8 */
(brace
id|TRUE
comma
id|XM_TXF_MPAUSE
)brace
comma
multiline_comment|/*  9 */
(brace
id|TRUE
comma
id|XM_TXF_MCTRL
)brace
comma
multiline_comment|/* 10 */
(brace
id|TRUE
comma
id|XM_TXF_SNG_COL
)brace
comma
multiline_comment|/* 11 */
(brace
id|TRUE
comma
id|XM_TXF_MUL_COL
)brace
comma
multiline_comment|/* 12 */
(brace
id|TRUE
comma
id|XM_TXF_ABO_COL
)brace
comma
multiline_comment|/* 13 */
(brace
id|TRUE
comma
id|XM_TXF_LAT_COL
)brace
comma
multiline_comment|/* 14 */
(brace
id|TRUE
comma
id|XM_TXF_DEF
)brace
comma
multiline_comment|/* 15 */
(brace
id|TRUE
comma
id|XM_TXF_EX_DEF
)brace
comma
multiline_comment|/* 16 */
(brace
id|TRUE
comma
id|XM_TXE_FIFO_UR
)brace
comma
multiline_comment|/* 17 */
(brace
id|TRUE
comma
id|XM_TXE_CS_ERR
)brace
comma
multiline_comment|/* 18 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 19 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 20 */
(brace
id|TRUE
comma
id|XM_TXF_64B
)brace
comma
multiline_comment|/* 21 */
(brace
id|TRUE
comma
id|XM_TXF_127B
)brace
comma
multiline_comment|/* 22 */
(brace
id|TRUE
comma
id|XM_TXF_255B
)brace
comma
multiline_comment|/* 23 */
(brace
id|TRUE
comma
id|XM_TXF_511B
)brace
comma
multiline_comment|/* 24 */
(brace
id|TRUE
comma
id|XM_TXF_1023B
)brace
comma
multiline_comment|/* 25 */
(brace
id|TRUE
comma
id|XM_TXF_MAX_SZ
)brace
comma
multiline_comment|/* 26 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 27 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 28 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 29 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 30 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 31 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 32 */
(brace
id|TRUE
comma
id|XM_RXF_OK
)brace
comma
multiline_comment|/* 33 */
(brace
id|TRUE
comma
l_int|0
)brace
comma
multiline_comment|/* 34 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 35 */
(brace
id|TRUE
comma
id|XM_RXF_BC_OK
)brace
comma
multiline_comment|/* 36 */
(brace
id|TRUE
comma
id|XM_RXF_MC_OK
)brace
comma
multiline_comment|/* 37 */
(brace
id|TRUE
comma
id|XM_RXF_UC_OK
)brace
comma
multiline_comment|/* 38 */
(brace
id|TRUE
comma
id|XM_RXF_MPAUSE
)brace
comma
multiline_comment|/* 39 */
(brace
id|TRUE
comma
id|XM_RXF_MCTRL
)brace
comma
multiline_comment|/* 40 */
(brace
id|TRUE
comma
id|XM_RXF_INV_MP
)brace
comma
multiline_comment|/* 41 */
(brace
id|TRUE
comma
id|XM_RXF_INV_MOC
)brace
comma
multiline_comment|/* 42 */
(brace
id|TRUE
comma
id|XM_RXE_BURST
)brace
comma
multiline_comment|/* 43 */
(brace
id|TRUE
comma
id|XM_RXE_FMISS
)brace
comma
multiline_comment|/* 44 */
(brace
id|TRUE
comma
id|XM_RXF_FRA_ERR
)brace
comma
multiline_comment|/* 45 */
(brace
id|TRUE
comma
id|XM_RXE_FIFO_OV
)brace
comma
multiline_comment|/* 46 */
(brace
id|TRUE
comma
id|XM_RXF_JAB_PKT
)brace
comma
multiline_comment|/* 47 */
(brace
id|TRUE
comma
id|XM_RXE_CAR_ERR
)brace
comma
multiline_comment|/* 48 */
(brace
id|TRUE
comma
id|XM_RXF_LEN_ERR
)brace
comma
multiline_comment|/* 49 */
(brace
id|TRUE
comma
id|XM_RXE_SYM_ERR
)brace
comma
multiline_comment|/* 50 */
(brace
id|TRUE
comma
id|XM_RXE_SHT_ERR
)brace
comma
multiline_comment|/* 51 */
(brace
id|TRUE
comma
id|XM_RXE_RUNT
)brace
comma
multiline_comment|/* 52 */
(brace
id|TRUE
comma
id|XM_RXF_LNG_ERR
)brace
comma
multiline_comment|/* 53 */
(brace
id|TRUE
comma
id|XM_RXF_FCS_ERR
)brace
comma
multiline_comment|/* 54 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 55 */
(brace
id|TRUE
comma
id|XM_RXF_CEX_ERR
)brace
comma
multiline_comment|/* 56 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 57 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 58 */
(brace
id|TRUE
comma
id|XM_RXF_64B
)brace
comma
multiline_comment|/* 59 */
(brace
id|TRUE
comma
id|XM_RXF_127B
)brace
comma
multiline_comment|/* 60 */
(brace
id|TRUE
comma
id|XM_RXF_255B
)brace
comma
multiline_comment|/* 61 */
(brace
id|TRUE
comma
id|XM_RXF_511B
)brace
comma
multiline_comment|/* 62 */
(brace
id|TRUE
comma
id|XM_RXF_1023B
)brace
comma
multiline_comment|/* 63 */
(brace
id|TRUE
comma
id|XM_RXF_MAX_SZ
)brace
comma
multiline_comment|/* 64 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 65 */
(brace
id|FALSE
comma
l_int|0
)brace
comma
multiline_comment|/* 66 */
(brace
id|TRUE
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************&n; *&n; * Public functions&n; *&n; */
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiInit - Init function of PNMI&n; *&n; * Description:&n; *&t;SK_INIT_DATA: Initialises the data structures&n; *&t;SK_INIT_IO:   Resets the XMAC statistics, determines the device and&n; *&t;              connector type.&n; *&t;SK_INIT_RUN:  Starts a timer event for port switch per hour&n; *&t;              calculation.&n; *&n; * Returns:&n; *&t;Always 0&n; */
DECL|function|SkPnmiInit
r_int
id|SkPnmiInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Level
)paren
multiline_comment|/* Initialization level */
(brace
r_int
r_int
id|PortMax
suffix:semicolon
multiline_comment|/* Number of ports */
r_int
r_int
id|PortIndex
suffix:semicolon
multiline_comment|/* Current port index in loop */
id|SK_U16
id|Val16
suffix:semicolon
multiline_comment|/* Multiple purpose 16 bit variable */
id|SK_U8
id|Val8
suffix:semicolon
multiline_comment|/* Mulitple purpose 8 bit variable */
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/* Event struct for timer event */
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiInit: Called, level=%d&bslash;n&quot;
comma
id|Level
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Level
)paren
(brace
r_case
id|SK_INIT_DATA
suffix:colon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.TrapBufFree
op_assign
id|SK_PNMI_TRAP_QUEUE_LEN
suffix:semicolon
id|pAC-&gt;Pnmi.StartUpTime
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeThreshold
op_assign
id|SK_PNMI_DEF_RLMT_CHG_THRES
suffix:semicolon
r_for
c_loop
(paren
id|PortIndex
op_assign
l_int|0
suffix:semicolon
id|PortIndex
OL
id|SK_MAX_MACS
suffix:semicolon
id|PortIndex
op_increment
)paren
(brace
id|pAC-&gt;Pnmi.Port
(braket
id|PortIndex
)braket
dot
id|ActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_INIT_IO
suffix:colon
multiline_comment|/*&n;&t;&t; * Reset MAC counters&n;&t;&t; */
id|PortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_for
c_loop
(paren
id|PortIndex
op_assign
l_int|0
suffix:semicolon
id|PortIndex
OL
id|PortMax
suffix:semicolon
id|PortIndex
op_increment
)paren
(brace
id|Val16
op_assign
id|XM_SC_CLR_RXC
op_or
id|XM_SC_CLR_TXC
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PortIndex
comma
id|XM_STAT_CMD
comma
id|Val16
)paren
suffix:semicolon
multiline_comment|/* Clear two times according to Errata #3 */
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PortIndex
comma
id|XM_STAT_CMD
comma
id|Val16
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get pci bus speed&n;&t;&t; */
id|SK_IN16
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
op_amp
id|Val16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Val16
op_amp
id|CS_BUS_CLOCK
)paren
op_eq
l_int|0
)paren
(brace
id|pAC-&gt;Pnmi.PciBusSpeed
op_assign
l_int|33
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.PciBusSpeed
op_assign
l_int|66
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get pci bus width&n;&t;&t; */
id|SK_IN16
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
op_amp
id|Val16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Val16
op_amp
id|CS_BUS_SLOT_SZ
)paren
op_eq
l_int|0
)paren
(brace
id|pAC-&gt;Pnmi.PciBusWidth
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.PciBusWidth
op_assign
l_int|64
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get PMD and DeviceType&n;&t;&t; */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_PMD_TYP
comma
op_amp
id|Val8
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Val8
)paren
(brace
r_case
l_char|&squot;S&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020002
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020001
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020004
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020003
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020006
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020005
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020008
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020007
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|1
suffix:semicolon
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get connector&n;&t;&t; */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_CONN_TYP
comma
op_amp
id|Val8
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Val8
)paren
(brace
r_case
l_char|&squot;C&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;J&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;V&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_INIT_RUN
suffix:colon
multiline_comment|/*&n;&t;&t; * Start timer for RLMT change counter&n;&t;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstTimer
comma
l_int|28125000
comma
id|SKGE_PNMI
comma
id|SK_PNMI_EVT_CHG_EST_TIMER
comma
id|EventParam
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* Nothing todo */
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiGetVar - Retrieves the value of a single OID&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this stuff. If the instance&n; *&t;-1 is passed, the values of all instances are returned in an&n; *&t;array of values.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take&n; *&t;                         the data.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiGetVar
r_int
id|SkPnmiGetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
)paren
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiGetVar: Called, Id=0x%x, BufLen=%d&bslash;n&quot;
comma
id|Id
comma
op_star
id|pLen
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_GET
comma
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|Instance
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiPreSetVar - Presets the value of a single OID&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this stuff. The preset does&n; *&t;the same as a set, but returns just before finally setting the&n; *&t;new value. This is usefull to check if a set might be successfull.&n; *&t;If as instance a -1 is passed, an array of values is supposed and&n; *&t;all instance of the OID will be set.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiPreSetVar
r_int
id|SkPnmiPreSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which stores the mgmt data to be set */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Total length of mgmt data */
id|SK_U32
id|Instance
)paren
multiline_comment|/* Instance (1..n) that is to be set or -1 */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiPreSetVar: Called, Id=0x%x, BufLen=%d&bslash;n&quot;
comma
id|Id
comma
op_star
id|pLen
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_PRESET
comma
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|Instance
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiSetVar - Sets the value of a single OID&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this stuff. The preset does&n; *&t;the same as a set, but returns just before finally setting the&n; *&t;new value. This is usefull to check if a set might be successfull.&n; *&t;If as instance a -1 is passed, an array of values is supposed and&n; *&t;all instance of the OID will be set.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiSetVar
r_int
id|SkPnmiSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which stores the mgmt data to be set */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Total length of mgmt data */
id|SK_U32
id|Instance
)paren
multiline_comment|/* Instance (1..n) that is to be set or -1 */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiSetVar: Called, Id=0x%x, BufLen=%d&bslash;n&quot;
comma
id|Id
comma
op_star
id|pLen
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_SET
comma
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|Instance
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiGetStruct - Retrieves the management database in SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;Runs through the IdTable, queries the single OIDs and stores the&n; *&t;returned data into the management database structure&n; *&t;SK_PNMI_STRUCT_DATA. The offset of the OID in the structure&n; *&t;is stored in the IdTable. The return value of the function will also&n; *&t;be stored in SK_PNMI_STRUCT_DATA if the passed buffer has the&n; *&t;minimum size of SK_PNMI_MIN_STRUCT_SIZE.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take&n; *&t;                         the data.&n; */
DECL|function|SkPnmiGetStruct
r_int
id|SkPnmiGetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which will store the retrieved data */
r_int
r_int
op_star
id|pLen
)paren
multiline_comment|/* Length of buffer */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|TableIndex
suffix:semicolon
r_int
r_int
id|DstOffset
suffix:semicolon
r_int
r_int
id|InstanceNo
suffix:semicolon
r_int
r_int
id|InstanceCnt
suffix:semicolon
id|SK_U32
id|Instance
suffix:semicolon
r_int
r_int
id|TmpLen
suffix:semicolon
r_char
id|KeyArr
(braket
id|SK_PNMI_VPD_ARR_SIZE
)braket
(braket
id|SK_PNMI_VPD_STR_SIZE
)braket
suffix:semicolon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiGetStruct: Called, BufLen=%d&bslash;n&quot;
comma
op_star
id|pLen
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|SK_PNMI_STRUCT_SIZE
)paren
(brace
r_if
c_cond
(paren
op_star
id|pLen
op_ge
id|SK_PNMI_MIN_STRUCT_SIZE
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_TOO_SHORT
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|SK_PNMI_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Update statistic */
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On call&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|SirqUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Increment semaphores to indicate that an update was&n;&t; * already done&n;&t; */
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/* Get vpd keys for instance calculation */
id|Ret
op_assign
id|GetVpdKeyArr
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|KeyArr
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|KeyArr
)paren
comma
op_amp
id|TmpLen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Retrieve values */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
id|pBuf
comma
l_int|0
comma
id|SK_PNMI_STRUCT_SIZE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TableIndex
op_assign
l_int|0
suffix:semicolon
id|TableIndex
OL
r_sizeof
(paren
id|IdTable
)paren
op_div
r_sizeof
(paren
id|IdTable
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|TableIndex
op_increment
)paren
(brace
id|InstanceNo
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|InstanceNo
suffix:semicolon
r_for
c_loop
(paren
id|InstanceCnt
op_assign
l_int|1
suffix:semicolon
id|InstanceCnt
op_le
id|InstanceNo
suffix:semicolon
id|InstanceCnt
op_increment
)paren
(brace
id|DstOffset
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Offset
op_plus
(paren
id|InstanceCnt
op_minus
l_int|1
)paren
op_star
id|IdTable
(braket
id|TableIndex
)braket
dot
id|StructSize
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * For the VPD the instance is not an index number&n;&t;&t;&t; * but the key itself. Determin with the instance&n;&t;&t;&t; * counter the VPD key to be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_KEY
op_logical_or
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_VALUE
op_logical_or
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_ACCESS
op_logical_or
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_ACTION
)paren
(brace
id|SK_PNMI_READ_U32
c_func
(paren
id|KeyArr
(braket
id|InstanceCnt
op_minus
l_int|1
)braket
comma
id|Instance
)paren
suffix:semicolon
)brace
r_else
(brace
id|Instance
op_assign
(paren
id|SK_U32
)paren
id|InstanceCnt
suffix:semicolon
)brace
id|TmpLen
op_assign
op_star
id|pLen
op_minus
id|DstOffset
suffix:semicolon
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_GET
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
id|DstOffset
comma
op_amp
id|TmpLen
comma
id|Instance
comma
id|TableIndex
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * An unknown instance error means that we reached&n;&t;&t;&t; * the last instance of that variable. Proceed with&n;&t;&t;&t; * the next OID in the table and ignore the return&n;&t;&t;&t; * code.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Ret
op_eq
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
id|DstOffset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
)brace
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_STRUCT_SIZE
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_OK
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiPreSetStruct - Presets the management database in SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this set stuff. The preset does&n; *&t;the same as a set, but returns just before finally setting the&n; *&t;new value. This is usefull to check if a set might be successfull.&n; *&t;The sub-function runs through the IdTable, checks which OIDs are able&n; *&t;to set, and calls the handler function of the OID to perform the&n; *&t;preset. The return value of the function will also be stored in&n; *&t;SK_PNMI_STRUCT_DATA if the passed buffer has the minimum size of&n; *&t;SK_PNMI_MIN_STRUCT_SIZE.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; */
DECL|function|SkPnmiPreSetStruct
r_int
id|SkPnmiPreSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which contains the data to be set */
r_int
r_int
op_star
id|pLen
)paren
multiline_comment|/* Length of buffer */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiPreSetStruct: Called, BufLen=%d&bslash;n&quot;
comma
op_star
id|pLen
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_PRESET
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiSetStruct - Sets the management database in SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this set stuff. The return value&n; *&t;of the function will also be stored in SK_PNMI_STRUCT_DATA if the&n; *&t;passed buffer has the minimum size of SK_PNMI_MIN_STRUCT_SIZE.&n; *&t;The sub-function runs through the IdTable, checks which OIDs are able&n; *&t;to set, and calls the handler function of the OID to perform the&n; *&t;set. The return value of the function will also be stored in&n; *&t;SK_PNMI_STRUCT_DATA if the passed buffer has the minimum size of&n; *&t;SK_PNMI_MIN_STRUCT_SIZE.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; */
DECL|function|SkPnmiSetStruct
r_int
id|SkPnmiSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which contains the data to be set */
r_int
r_int
op_star
id|pLen
)paren
multiline_comment|/* Length of buffer */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiSetStruct: Called, BufLen=%d&bslash;n&quot;
comma
op_star
id|pLen
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_SET
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiEvent - Event handler&n; *&n; * Description:&n; *&t;Handles the following events:&n; *&t;SK_PNMI_EVT_SIRQ_OVERFLOW     When a hardware counter overflows an&n; *&t;                              interrupt will be generated which is&n; *&t;                              first handled by SIRQ which generates a&n; *&t;                              this event. The event increments the&n; *&t;                              upper 32 bit of the 64 bit counter.&n; *&t;SK_PNMI_EVT_SEN_XXX           The event is generated by the I2C module&n; *&t;                              when a sensor reports a warning or&n; *&t;                              error. The event will store a trap&n; *&t;                              message in the trap buffer.&n; *&t;SK_PNMI_EVT_CHG_EST_TIMER     The timer event was initiated by this&n; *&t;                              module and is used to calculate the&n; *&t;                              port switches per hour.&n; *&t;SK_PNMI_EVT_CLEAR_COUNTER     The event clears all counters and&n; *&t;                              timestamps.&n; *&t;SK_PNMI_EVT_XMAC_RESET        The event is generated by the driver&n; *&t;                              before a hard reset of the XMAC is&n; *&t;                              performed. All counters will be saved&n; *&t;                              and added to the hardware counter&n; *&t;                              values after reset to grant continuous&n; *&t;                              counter values.&n; *&t;SK_PNMI_EVT_RLMT_PORT_UP      Generated by RLMT to notify that a port&n; *&t;                              went logically up. A trap message will&n; *&t;                              be stored to the trap buffer.&n; *&t;SK_PNMI_EVT_RLMT_PORT_DOWN    Generated by RLMT to notify that a port&n; *&t;                              went logically down. A trap message will&n; *&t;                              be stored to the trap buffer.&n; *&t;SK_PNMI_EVT_RLMT_PORT_SWITCH  Generated by RLMT to notify that the&n; *&t;                              active port switched. PNMI will split&n; *&t;                              this into two message ACTIVE_DOWN and&n; *&t;                              ACTIVE_UP to be future compatible with&n; *&t;                              load balancing and card fail over.&n; *&t;SK_PNMI_EVT_RLMT_SEGMENTATION Generated by RLMT to notify that two&n; *&t;                              spanning tree root bridges were&n; *&t;                              detected. A trap message will be stored&n; *&t;                              to the trap buffer.&n; *&t;SK_PNMI_EVT_RLMT_ACTIVE_DOWN  Notifies PNMI that an active port went&n; *&t;                              down. PNMI will not further add the&n; *&t;                              statistic values to the virtual port.&n; *&t;SK_PNMI_EVT_RLMT_ACTIVE_UP    Notifies PNMI that a port went up and&n; *&t;                              is now an active port. PNMI will now&n; *&t;                              add the statistic data of this port to&n; *&t;                              the virtual port.&n; *&n; * Returns:&n; *&t;Always 0&n; */
DECL|function|SkPnmiEvent
r_int
id|SkPnmiEvent
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Event
comma
multiline_comment|/* Event-Id */
id|SK_EVPARA
id|Param
)paren
multiline_comment|/* Event dependent parameter */
(brace
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
id|CounterIndex
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U16
id|MacStatus
suffix:semicolon
id|SK_U64
id|OverflowStatus
suffix:semicolon
id|SK_U64
id|Mask
suffix:semicolon
id|SK_U32
id|MacCntEvent
suffix:semicolon
id|SK_U64
id|Value
suffix:semicolon
id|SK_U16
id|Register
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_U64
id|NewestValue
suffix:semicolon
id|SK_U64
id|OldestValue
suffix:semicolon
id|SK_U64
id|Delta
suffix:semicolon
id|SK_PNMI_ESTIMATE
op_star
id|pEst
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|Event
op_ne
id|SK_PNMI_EVT_XMAC_RESET
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiEvent: Called, Event=0x%x, Param=0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Event
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On call&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Event
)paren
(brace
r_case
id|SK_PNMI_EVT_SIRQ_OVERFLOW
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
id|MacStatus
op_assign
(paren
id|SK_U16
)paren
id|Param.Para32
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SIRQ_OVERFLOW parameter wrong, PhysPortIndex=0x%x&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|OverflowStatus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check which source caused an overflow interrupt. The&n;&t;&t; * interrupt source is a self-clearing register. We only&n;&t;&t; * need to check the interrupt source once. Another check&n;&t;&t; * will be done by the SIRQ module to be sure that no&n;&t;&t; * interrupt get lost during process time.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|MacStatus
op_amp
id|XM_IS_RXC_OV
)paren
op_eq
id|XM_IS_RXC_OV
)paren
(brace
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RX_CNT_EV
comma
op_amp
id|MacCntEvent
)paren
suffix:semicolon
id|OverflowStatus
op_or_assign
(paren
id|SK_U64
)paren
id|MacCntEvent
op_lshift
l_int|32
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|MacStatus
op_amp
id|XM_IS_TXC_OV
)paren
op_eq
id|XM_IS_TXC_OV
)paren
(brace
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TX_CNT_EV
comma
op_amp
id|MacCntEvent
)paren
suffix:semicolon
id|OverflowStatus
op_or_assign
(paren
id|SK_U64
)paren
id|MacCntEvent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|OverflowStatus
op_eq
l_int|0
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check the overflow status register and increment&n;&t;&t; * the upper dword of corresponding counter.&n;&t;&t; */
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
r_sizeof
(paren
id|Mask
)paren
op_star
l_int|8
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
id|Mask
op_assign
(paren
id|SK_U64
)paren
l_int|1
op_lshift
id|CounterIndex
suffix:semicolon
r_if
c_cond
(paren
(paren
id|OverflowStatus
op_amp
id|Mask
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CounterIndex
)paren
(brace
r_case
id|SK_PNMI_HTX_UTILUNDER
suffix:colon
r_case
id|SK_PNMI_HTX_UTILOVER
suffix:colon
id|XM_IN16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TX_CMD
comma
op_amp
id|Register
)paren
suffix:semicolon
id|Register
op_or_assign
id|XM_TX_SAM_LINE
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TX_CMD
comma
id|Register
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_UTILUNDER
suffix:colon
r_case
id|SK_PNMI_HRX_UTILOVER
suffix:colon
id|XM_IN16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RX_CMD
comma
op_amp
id|Register
)paren
suffix:semicolon
id|Register
op_or_assign
id|XM_RX_SAM_LINE
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RX_CMD
comma
id|Register
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_OCTETHIGH
suffix:colon
r_case
id|SK_PNMI_HTX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED26
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED27
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED28
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED29
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED30
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED31
suffix:colon
r_case
id|SK_PNMI_HRX_OCTETHIGH
suffix:colon
r_case
id|SK_PNMI_HRX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HRX_IRLENGTH
suffix:colon
r_case
id|SK_PNMI_HRX_RESERVED22
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * the following counters aren&squot;t be handled (id &gt; 63)&n;&t;&t;&t; */
r_case
id|SK_PNMI_HTX_SYNC
suffix:colon
r_case
id|SK_PNMI_HTX_SYNC_OCTET
suffix:colon
r_case
id|SK_PNMI_HRX_LONGFRAMES
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|CounterIndex
)braket
op_increment
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_WAR_LOW
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_LOW parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_WAR_LOW
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_WAR_UPP
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR:SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_UPP parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_WAR_UPP
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_ERR_LOW
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_ERR_LOW parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_ERR_LOW
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_ERR_UPP
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_ERR_UPP parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_ERR_UPP
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_CHG_EST_TIMER
suffix:colon
multiline_comment|/*&n;&t;&t; * Calculate port switch average on a per hour basis&n;&t;&t; *   Time interval for check       : 28125 ms&n;&t;&t; *   Number of values for average  : 8&n;&t;&t; *&n;&t;&t; * Be careful in changing these values, on change check&n;&t;&t; *   - typedef of SK_PNMI_ESTIMATE (Size of EstValue&n;&t;&t; *     array one less than value number)&n;&t;&t; *   - Timer initilization SkTimerStart() in SkPnmiInit&n;&t;&t; *   - Delta value below must be multiplicated with&n;&t;&t; *     power of 2&n;&t;&t; *&n;&t;&t; */
id|pEst
op_assign
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate
suffix:semicolon
id|CounterIndex
op_assign
id|pEst-&gt;EstValueIndex
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|CounterIndex
op_eq
l_int|7
)paren
(brace
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
)brace
id|pEst-&gt;EstValueIndex
op_assign
id|CounterIndex
suffix:semicolon
id|NewestValue
op_assign
id|pAC-&gt;Pnmi.RlmtChangeCts
suffix:semicolon
id|OldestValue
op_assign
id|pEst-&gt;EstValue
(braket
id|CounterIndex
)braket
suffix:semicolon
id|pEst-&gt;EstValue
(braket
id|CounterIndex
)braket
op_assign
id|NewestValue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate average. Delta stores the number of&n;&t;&t; * port switches per 28125 * 8 = 225000 ms&n;&t;&t; */
r_if
c_cond
(paren
id|NewestValue
op_ge
id|OldestValue
)paren
(brace
id|Delta
op_assign
id|NewestValue
op_minus
id|OldestValue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Overflow situation */
id|Delta
op_assign
(paren
id|SK_U64
)paren
(paren
l_int|0
op_minus
id|OldestValue
)paren
op_plus
id|NewestValue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Extrapolate delta to port switches per hour.&n;&t;&t; *     Estimate = Delta * (3600000 / 225000)&n;&t;&t; *              = Delta * 16&n;&t;&t; *              = Delta &lt;&lt; 4&n;&t;&t; */
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
op_assign
id|Delta
op_lshift
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if threshold is exceeded. If the threshold is&n;&t;&t; * permanently exceeded every 28125 ms an event will be&n;&t;&t; * generated to remind the user of this condition.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pAC-&gt;Pnmi.RlmtChangeThreshold
op_ne
l_int|0
)paren
op_logical_and
(paren
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
op_ge
id|pAC-&gt;Pnmi.RlmtChangeThreshold
)paren
)paren
(brace
id|QueueSimpleTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_CHANGE_THRES
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
)brace
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstTimer
comma
l_int|28125000
comma
id|SKGE_PNMI
comma
id|SK_PNMI_EVT_CHG_EST_TIMER
comma
id|EventParam
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_CLEAR_COUNTER
suffix:colon
multiline_comment|/*&n;&t;&t; * Set all counters and timestamps to zero&n;&t;&t; */
id|ResetCounter
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_XMAC_RESET
suffix:colon
multiline_comment|/*&n;&t;&t; * To grant continuous counter values store the current&n;&t;&t; * XMAC statistic values to the entries 1..n of the&n;&t;&t; * CounterOffset array. XMAC Errata #2 &n;&t;&t; */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_XMAC_RESET parameter wrong, PhysPortIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para64
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update XMAC statistic to get fresh values&n;&t;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Increment semaphore to indicate that an update was&n;&t;&t; * already done&n;&t;&t; */
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
id|SK_PNMI_SCNT_NOT
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StatAddress
(braket
id|CounterIndex
)braket
dot
id|GetOffset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
(braket
id|CounterIndex
)braket
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|CounterIndex
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|CounterIndex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_PORT_UP
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_UP parameter wrong, PhysPortIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueRlmtPortTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_PORT_UP
comma
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_PORT_DOWN
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_DOWN parameter wrong, PhysPortIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueRlmtPortTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_PORT_DOWN
comma
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_ACTIVE_DOWN
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_DOWN parameter too high, PhysPort=%d&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Nothing to do if port is already inactive&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update statistic counters to calculate new offset&n;&t;&t; * for the virtual port and increment semaphore to&n;&t;&t; * indicate that an update was already done.&n;&t;&t; */
r_if
c_cond
(paren
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate new counter offset for virtual port to&n;&t;&t; * grant continous counting on port switches. The virtual&n;&t;&t; * port consists of all currently active ports. The port&n;&t;&t; * down event indicates that a port is removed fromt the&n;&t;&t; * virtual port. Therefore add the counter value of the&n;&t;&t; * removed port to the CounterOffset for the virtual port&n;&t;&t; * to grant the same counter value.&n;&t;&t; */
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
id|SK_PNMI_MAX_IDX
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StatAddress
(braket
id|CounterIndex
)braket
dot
id|GetOffset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|Value
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|CounterIndex
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.VirtualCounterOffset
(braket
id|CounterIndex
)braket
op_add_assign
id|Value
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set port to inactive&n;&t;&t; */
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_ACTIVE_UP
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_UP parameter too high, PhysPort=%d&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Nothing to do if port is already active&n;&t;&t; */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Statistic maintanence&n;&t;&t; */
id|pAC-&gt;Pnmi.RlmtChangeCts
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeTime
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueRlmtNewMacTrap
c_func
(paren
id|pAC
comma
id|PhysPortIndex
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update statistic counters to calculate new offset&n;&t;&t; * for the virtual port and increment semaphore to indicate&n;&t;&t; * that an update was already done.&n;&t;&t; */
r_if
c_cond
(paren
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate new counter offset for virtual port to&n;&t;&t; * grant continous counting on port switches. A new port&n;&t;&t; * is added to the virtual port. Therefore substract the&n;&t;&t; * counter value of the new port from the CounterOffset&n;&t;&t; * for the virtual port to grant the same value.&n;&t;&t; */
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
id|SK_PNMI_MAX_IDX
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StatAddress
(braket
id|CounterIndex
)braket
dot
id|GetOffset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|Value
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|CounterIndex
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.VirtualCounterOffset
(braket
id|CounterIndex
)braket
op_sub_assign
id|Value
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set port to active&n;&t;&t; */
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
op_assign
id|SK_TRUE
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_PORT_SWITCH
suffix:colon
multiline_comment|/*&n;&t;&t; * This event becomes obsolete if RLMT generates directly&n;&t;&t; * the events SK_PNMI_EVT_RLMT_ACTIVE_DOWN and&n;&t;&t; * SK_PNMI_EVT_RLMT_ACTIVE_UP. The events are here emulated.&n;&t;&t; * PNMI handles that multiple ports may become active. &n;&t;&t; * Increment semaphore to indicate that an update was&n;&t;&t; * already done.&n;&t;&t; */
r_if
c_cond
(paren
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
id|SkPnmiEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_EVT_RLMT_ACTIVE_DOWN
comma
id|Param
)paren
suffix:semicolon
id|Param.Para32
(braket
l_int|0
)braket
op_assign
id|Param.Para32
(braket
l_int|1
)braket
suffix:semicolon
id|SkPnmiEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_EVT_RLMT_ACTIVE_UP
comma
id|Param
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_SEGMENTATION
suffix:colon
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSimpleTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_SEGMENTATION
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * Private functions&n; *&n; */
multiline_comment|/*****************************************************************************&n; *&n; * PnmiVar - Gets, presets, and sets single OIDs&n; *&n; * Description:&n; *&t;Looks up the requested OID, calls the corresponding handler&n; *&t;function, and passes the parameters with the get, preset, or&n; *&t;set command. The function is called by SkGePnmiGetVar,&n; *&t;SkGePnmiPreSetVar, or SkGePnmiSetVar.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_XXX. For details have a look to the description of the&n; *&t;calling functions.&n; */
DECL|function|PnmiVar
r_static
r_int
id|PnmiVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer which stores the mgmt data to be set */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Total length of mgmt data */
id|SK_U32
id|Instance
)paren
multiline_comment|/* Instance (1..n) that is to be set or -1 */
(brace
r_int
r_int
id|TableIndex
suffix:semicolon
r_int
id|Ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|TableIndex
op_assign
id|LookupId
c_func
(paren
id|Id
)paren
)paren
op_eq
(paren
r_int
r_int
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_OID
)paren
suffix:semicolon
)brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiVar: On call&quot;
)paren
suffix:semicolon
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Action
comma
id|Id
comma
id|pBuf
comma
id|pLen
comma
id|Instance
comma
id|TableIndex
)paren
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiVar: On return&quot;
)paren
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * PnmiStruct - Presets and Sets data in structure SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;The return value of the function will also be stored in&n; *&t;SK_PNMI_STRUCT_DATA if the passed buffer has the minimum size of&n; *&t;SK_PNMI_MIN_STRUCT_SIZE. The sub-function runs through the IdTable,&n; *&t;checks which OIDs are able to set, and calls the handler function of&n; *&t;the OID to perform the set. The return value of the function will&n; *&t;also be stored in SK_PNMI_STRUCT_DATA if the passed buffer has the&n; *&t;minimum size of SK_PNMI_MIN_STRUCT_SIZE. The function is called&n; *&t;by SkGePnmiPreSetStruct and SkGePnmiSetStruct.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_XXX. The codes are described in the calling functions.&n; */
DECL|function|PnmiStruct
r_static
r_int
id|PnmiStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Set action to be performed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer which contains the data to be set */
r_int
r_int
op_star
id|pLen
)paren
multiline_comment|/* Length of buffer */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|TableIndex
suffix:semicolon
r_int
r_int
id|DstOffset
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|InstanceNo
suffix:semicolon
r_int
r_int
id|InstanceCnt
suffix:semicolon
id|SK_U32
id|Instance
suffix:semicolon
id|SK_U32
id|Id
suffix:semicolon
multiline_comment|/* Check if the passed buffer has the right size */
r_if
c_cond
(paren
op_star
id|pLen
OL
id|SK_PNMI_STRUCT_SIZE
)paren
(brace
multiline_comment|/* Check if we can return the error within the buffer */
r_if
c_cond
(paren
op_star
id|pLen
op_ge
id|SK_PNMI_MIN_STRUCT_SIZE
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_TOO_SHORT
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|SK_PNMI_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On call&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the values of RLMT and SIRQ and increment semaphores to&n;&t; * indicate that an update was already done.&n;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|SirqUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/* Preset/Set values */
r_for
c_loop
(paren
id|TableIndex
op_assign
l_int|0
suffix:semicolon
id|TableIndex
OL
r_sizeof
(paren
id|IdTable
)paren
op_div
r_sizeof
(paren
id|IdTable
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|TableIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Access
op_ne
id|SK_PNMI_RW
)paren
(brace
r_continue
suffix:semicolon
)brace
id|InstanceNo
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|InstanceNo
suffix:semicolon
id|Id
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
suffix:semicolon
r_for
c_loop
(paren
id|InstanceCnt
op_assign
l_int|1
suffix:semicolon
id|InstanceCnt
op_le
id|InstanceNo
suffix:semicolon
id|InstanceCnt
op_increment
)paren
(brace
id|DstOffset
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Offset
op_plus
(paren
id|InstanceCnt
op_minus
l_int|1
)paren
op_star
id|IdTable
(braket
id|TableIndex
)braket
dot
id|StructSize
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Because VPD multiple instance variables are&n;&t;&t;&t; * not setable we do not need to evaluate VPD&n;&t;&t;&t; * instances. Have a look to VPD instance&n;&t;&t;&t; * calculation in SkPnmiGetStruct().&n;&t;&t;&t; */
id|Instance
op_assign
(paren
id|SK_U32
)paren
id|InstanceCnt
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Evaluate needed buffer length&n;&t;&t;&t; */
id|Len
op_assign
l_int|0
suffix:semicolon
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_GET
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
comma
l_int|NULL
comma
op_amp
id|Len
comma
id|Instance
comma
id|TableIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_eq
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_TOO_SHORT
)paren
(brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_GENERAL
comma
id|DstOffset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_VPD_ACTION
)paren
(brace
r_switch
c_cond
(paren
op_star
(paren
id|pBuf
op_plus
id|DstOffset
)paren
)paren
(brace
r_case
id|SK_PNMI_VPD_CREATE
suffix:colon
id|Len
op_assign
l_int|3
op_plus
op_star
(paren
id|pBuf
op_plus
id|DstOffset
op_plus
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_VPD_DELETE
suffix:colon
id|Len
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|Len
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Call the OID handler function */
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Action
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
comma
id|pBuf
op_plus
id|DstOffset
comma
op_amp
id|Len
comma
id|Instance
comma
id|TableIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_BAD_VALUE
comma
id|DstOffset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
)brace
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_OK
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * LookupId - Lookup an OID in the IdTable&n; *&n; * Description:&n; *&t;Scans the IdTable to find the table entry of an OID.&n; *&n; * Returns:&n; *&t;The table index or -1 if not found.&n; */
DECL|function|LookupId
r_static
r_int
id|LookupId
c_func
(paren
id|SK_U32
id|Id
)paren
multiline_comment|/* Object identifier to be searched */
(brace
r_int
id|i
suffix:semicolon
r_int
id|Len
op_assign
r_sizeof
(paren
id|IdTable
)paren
op_div
r_sizeof
(paren
id|IdTable
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|Len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|IdTable
(braket
id|i
)braket
dot
id|Id
op_eq
id|Id
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * OidStruct - Handler of OID_SKGE_ALL_DATA&n; *&n; * Description:&n; *&t;This OID performs a Get/Preset/SetStruct call and returns all data&n; *&t;in a SK_PNMI_STRUCT_DATA structure.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|OidStruct
r_static
r_int
id|OidStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_ALL_DATA
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR003
comma
id|SK_PNMI_ERR003MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|Action
)paren
(brace
r_case
id|SK_PNMI_GET
suffix:colon
r_return
(paren
id|SkPnmiGetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
)paren
suffix:semicolon
r_case
id|SK_PNMI_PRESET
suffix:colon
r_return
(paren
id|SkPnmiPreSetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
)paren
suffix:semicolon
r_case
id|SK_PNMI_SET
suffix:colon
r_return
(paren
id|SkPnmiSetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
)paren
suffix:semicolon
)brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR004
comma
id|SK_PNMI_ERR004MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Perform - OID handler of OID_SKGE_ACTION&n; *&n; * Description:&n; *&t;None.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Perform
r_static
r_int
id|Perform
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
id|Ret
suffix:semicolon
id|SK_U32
id|ActionOp
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if a get should be performed */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/* A get is easy. We always return the same value */
id|ActionOp
op_assign
(paren
id|SK_U32
)paren
id|SK_PNMI_ACT_IDLE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|ActionOp
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Continue with PRESET/SET action */
r_if
c_cond
(paren
op_star
id|pLen
OG
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the command is a known one */
id|SK_PNMI_READ_U32
c_func
(paren
id|pBuf
comma
id|ActionOp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OG
r_sizeof
(paren
id|SK_U32
)paren
op_logical_or
(paren
id|ActionOp
op_ne
id|SK_PNMI_ACT_IDLE
op_logical_and
id|ActionOp
op_ne
id|SK_PNMI_ACT_RESET
op_logical_and
id|ActionOp
op_ne
id|SK_PNMI_ACT_SELFTEST
op_logical_and
id|ActionOp
op_ne
id|SK_PNMI_ACT_RESETCNT
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* A preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ActionOp
)paren
(brace
r_case
id|SK_PNMI_ACT_IDLE
suffix:colon
multiline_comment|/* Nothing to do */
r_break
suffix:semicolon
r_case
id|SK_PNMI_ACT_RESET
suffix:colon
multiline_comment|/*&n;&t;&t; * Perform a driver reset or something that comes near&n;&t;&t; * to this.&n;&t;&t; */
id|Ret
op_assign
id|SK_DRIVER_RESET
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR005
comma
id|SK_PNMI_ERR005MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_ACT_SELFTEST
suffix:colon
multiline_comment|/*&n;&t;&t; * Perform a driver selftest or something similar to this.&n;&t;&t; * Currently this feature is not used and will probably&n;&t;&t; * implemented in another way.&n;&t;&t; */
id|Ret
op_assign
id|SK_DRIVER_SELFTEST
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.TestResult
op_assign
id|Ret
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_ACT_RESETCNT
suffix:colon
multiline_comment|/* Set all counters and timestamps to zero */
id|ResetCounter
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR006
comma
id|SK_PNMI_ERR006MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Mac8023Stat - OID handler of OID_GEN_XXX and OID_802_3_XXX&n; *&n; * Description:&n; *&t;Retrieves the statistic values of the virtual port (logical&n; *&t;index 0). Only special OIDs of NDIS are handled which consist&n; *&t;of a 32 bit instead of a 64 bit value. The OIDs are public&n; *&t;because perhaps some other platform can use them too.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Mac8023Stat
r_static
r_int
id|Mac8023Stat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
id|Ret
suffix:semicolon
id|SK_U64
id|StatVal
suffix:semicolon
id|SK_BOOL
id|Is64BitReq
op_assign
id|SK_FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * Only the active Mac is returned&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action type&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check length&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_802_3_PERMANENT_ADDRESS
suffix:colon
r_case
id|OID_802_3_CURRENT_ADDRESS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#ifndef SK_NDIS_64BIT_CTR
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
macro_line|#else /* SK_NDIS_64BIT_CTR */
multiline_comment|/*&n;&t;&t; * for compatibility, at least 32bit are required for oid&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;* but indicate handling for 64bit values,&n;&t;&t;&t;* if insufficient space is provided&n;&t;&t;&t;*/
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Is64BitReq
op_assign
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
ques
c_cond
id|SK_FALSE
suffix:colon
id|SK_TRUE
suffix:semicolon
macro_line|#endif /* SK_NDIS_64BIT_CTR */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update all statistics, because we retrieve virtual MAC, which&n;&t; * consists of multiple physical statistics and increment semaphore&n;&t; * to indicate that an update was already done.&n;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Get value (MAC Index 0 identifies the virtual MAC)&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_802_3_PERMANENT_ADDRESS
suffix:colon
id|CopyMac
c_func
(paren
id|pBuf
comma
op_amp
id|pAC-&gt;Addr.PermanentMacAddress
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_802_3_CURRENT_ADDRESS
suffix:colon
id|CopyMac
c_func
(paren
id|pBuf
comma
op_amp
id|pAC-&gt;Addr.CurrentMacAddress
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|SK_U32
id|StatVal32
suffix:semicolon
id|StatVal32
op_assign
(paren
id|SK_U32
)paren
id|StatVal
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|StatVal32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|StatVal
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * MacPrivateStat - OID handler function of OID_SKGE_STAT_XXX&n; *&n; * Description:&n; *&t;Retrieves the XMAC statistic data.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|MacPrivateStat
r_static
r_int
id|MacPrivateStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
r_int
id|LogPortMax
suffix:semicolon
r_int
r_int
id|LogPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U64
id|StatVal
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished. MAC index 0 is the virtual&n;&t; * MAC.&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|LogPortIndex
op_assign
id|SK_PNMI_PORT_INST2LOG
c_func
(paren
id|Instance
)paren
suffix:semicolon
id|Limit
op_assign
id|LogPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|LogPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|LogPortMax
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check length&n;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update XMAC statistic and increment semaphore to indicate that&n;&t; * an update was already done.&n;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|PhysPortMax
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Get value&n;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
multiline_comment|/* XXX not yet implemented due to XMAC problems&n;&t;&t;case OID_SKGE_STAT_TX_UTIL:&n;&t;&t;&t;return (SK_PNMI_ERR_GENERAL);&n;*/
multiline_comment|/* XXX not yet implemented due to XMAC problems&n;&t;&t;case OID_SKGE_STAT_RX_UTIL:&n;&t;&t;&t;return (SK_PNMI_ERR_GENERAL);&n;*/
multiline_comment|/*&n;&t;&t; * Frames longer than IEEE 802.3 frame max size are counted&n;&t;&t; * by XMAC in frame_too_long counter even reception of long&n;&t;&t; * frames was enabled and the frame was correct.&n;&t;&t; * So correct the value by subtracting RxLongFrame counter.&n;&t;&t; */
r_case
id|OID_SKGE_STAT_RX_TOO_LONG
suffix:colon
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
)paren
op_minus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HRX_LONGFRAMES
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|StatVal
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|StatVal
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Addr - OID handler function of OID_SKGE_PHYS_CUR_ADDR and _FAC_ADDR&n; *&n; * Description:&n; *&t;Get/Presets/Sets the current and factory MAC address. The MAC&n; *&t;address of the virtual port, which is reported to the OS, may&n; *&t;not be changed, but the physical ones. A set to the virtual port&n; *&t;will be ignored. No error should be reported because otherwise&n; *&t;a multiple instance set (-1) would always fail.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Addr
r_static
r_int
id|Addr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|LogPortMax
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|LogPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|LogPortIndex
op_assign
id|SK_PNMI_PORT_INST2LOG
c_func
(paren
id|Instance
)paren
suffix:semicolon
id|Limit
op_assign
id|LogPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|LogPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|LogPortMax
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform Action&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check length&n;&t;&t;*/
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get value&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_PHYS_CUR_ADDR
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr
dot
id|CurrentMacAddress
)paren
suffix:semicolon
)brace
r_else
(brace
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr
dot
id|Port
(braket
id|PhysPortIndex
)braket
dot
id|CurrentMacAddress
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHYS_FAC_ADDR
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr
dot
id|PermanentMacAddress
)paren
suffix:semicolon
)brace
r_else
(brace
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr
dot
id|Port
(braket
id|PhysPortIndex
)braket
dot
id|PermanentMacAddress
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR008
comma
id|SK_PNMI_ERR008MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The logical MAC address may not be changed only&n;&t;&t; * the physical ones&n;&t;&t; */
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_PHYS_FAC_ADDR
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Only the current address may be changed&n;&t;&t; */
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_PHYS_CUR_ADDR
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR009
comma
id|SK_PNMI_ERR009MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check length&n;&t;&t;*/
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OG
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check Action&n;&t;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set OID_SKGE_MAC_CUR_ADDR&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
comma
id|Offset
op_add_assign
l_int|6
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A set to virtual port and set of broadcast&n;&t;&t;&t; * address will be ignored&n;&t;&t;&t; */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
op_logical_or
id|SK_MEMCMP
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
l_string|&quot;&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&quot;
comma
l_int|6
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|Ret
op_assign
id|SkAddrOverride
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
(paren
id|SK_MAC_ADDR
op_star
)paren
(paren
id|pBuf
op_plus
id|Offset
)paren
comma
(paren
id|LogPortIndex
op_eq
l_int|0
ques
c_cond
id|SK_ADDR_VIRTUAL_ADDRESS
suffix:colon
id|SK_ADDR_PHYSICAL_ADDRESS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_ADDR_OVERRIDE_SUCCESS
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CsumStat - OID handler function of OID_SKGE_CHKSM_XXX&n; *&n; * Description:&n; *&t;Retrieves the statistic values of the CSUM module. The CSUM data&n; *&t;structure must be available in the SK_AC even if the CSUM module&n; *&t;is not included, because PNMI reads the statistic data from the&n; *&t;CSUM part of SK_AC directly.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|CsumStat
r_static
r_int
id|CsumStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
op_assign
l_int|0
suffix:semicolon
id|SK_U64
id|StatVal
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|SKCS_NUM_PROTOCOLS
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|Index
op_assign
(paren
r_int
r_int
)paren
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|Instance
suffix:semicolon
)brace
r_else
(brace
id|Index
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|SKCS_NUM_PROTOCOLS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check length&n;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get value&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|Index
OL
id|Limit
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_CHKSM_RX_OK_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|Index
)braket
dot
id|RxOkCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_RX_UNABLE_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|Index
)braket
dot
id|RxUnableCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_RX_ERR_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|Index
)braket
dot
id|RxErrCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_TX_OK_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|Index
)braket
dot
id|TxOkCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_TX_UNABLE_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|Index
)braket
dot
id|TxUnableCts
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR010
comma
id|SK_PNMI_ERR010MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|StatVal
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Store used buffer space&n;&t; */
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SensorStat - OID handler function of OID_SKGE_SENSOR_XXX&n; *&n; * Description:&n; *&t;Retrieves the statistic values of the I2C module, which handles&n; *&t;the temperature and voltage sensors.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SensorStat
r_static
r_int
id|SensorStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished&n;&t; */
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.MaxSens
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|Index
op_assign
(paren
r_int
r_int
)paren
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|Instance
suffix:semicolon
)brace
r_else
(brace
id|Index
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check length&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_SENSOR_VALUE
suffix:colon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_LOW
suffix:colon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_UPP
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_LOW
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_UPP
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_DESCR
suffix:colon
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|i
op_assign
id|Index
suffix:semicolon
id|i
OL
id|Limit
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Len
op_assign
(paren
r_int
r_int
)paren
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|Len
op_ge
id|SK_PNMI_STRINGLEN2
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR011
comma
id|SK_PNMI_ERR011MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
id|Len
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Offset
)paren
(brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_INDEX
suffix:colon
r_case
id|OID_SKGE_SENSOR_TYPE
suffix:colon
r_case
id|OID_SKGE_SENSOR_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Limit
op_minus
id|Index
)paren
(brace
op_star
id|pLen
op_assign
id|Limit
op_minus
id|Index
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_CTS
suffix:colon
r_case
id|OID_SKGE_SENSOR_WAR_TIME
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_CTS
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_TIME
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR012
comma
id|SK_PNMI_ERR012MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get value&n;&t; */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|Limit
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_SENSOR_INDEX
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|Index
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_DESCR
suffix:colon
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenDesc
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|1
comma
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenDesc
comma
id|Len
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|Len
suffix:semicolon
id|Offset
op_add_assign
id|Len
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_TYPE
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenType
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_VALUE
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenValue
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_LOW
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreWarnLow
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_UPP
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreWarnHigh
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_LOW
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreErrLow
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_UPP
suffix:colon
id|Val32
op_assign
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreErrHigh
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_STATUS
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenErrFlag
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenWarnCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenErrCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_TIME
suffix:colon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenBegWarnTS
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_TIME
suffix:colon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenBegErrTS
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR013
comma
id|SK_PNMI_ERR013MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Store used buffer space&n;&t; */
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Vpd - OID handler function of OID_SKGE_VPD_XXX&n; *&n; * Description:&n; *&t;Get/preset/set of VPD data. As instance the name of a VPD key&n; *&t;can be passed. The Instance parameter is a SK_U32 and can be&n; *&t;used as a string buffer for the VPD key, because their maximum&n; *&t;length is 4 byte.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Vpd
r_static
r_int
id|Vpd
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
id|SK_VPD_STATUS
op_star
id|pVpdStatus
suffix:semicolon
r_int
r_int
id|BufLen
suffix:semicolon
r_char
id|Buf
(braket
l_int|256
)braket
suffix:semicolon
r_char
id|KeyArr
(braket
id|SK_PNMI_VPD_ARR_SIZE
)braket
(braket
id|SK_PNMI_VPD_STR_SIZE
)braket
suffix:semicolon
r_char
id|KeyStr
(braket
id|SK_PNMI_VPD_STR_SIZE
)braket
suffix:semicolon
r_int
r_int
id|KeyNo
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|FirstIndex
suffix:semicolon
r_int
r_int
id|LastIndex
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
multiline_comment|/*&n;&t; * Get array of all currently stored VPD keys&n;&t; */
id|Ret
op_assign
id|GetVpdKeyArr
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|KeyArr
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|KeyArr
)paren
comma
op_amp
id|KeyNo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If instance is not -1, try to find the requested VPD key for&n;&t; * the multiple instance variables. The other OIDs as for example&n;&t; * OID VPD_ACTION are single instance variables and must be&n;&t; * handled separatly.&n;&t; */
id|FirstIndex
op_assign
l_int|0
suffix:semicolon
id|LastIndex
op_assign
id|KeyNo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_VPD_KEY
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_VALUE
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ACCESS
)paren
(brace
id|SK_STRNCPY
c_func
(paren
id|KeyStr
comma
(paren
r_char
op_star
)paren
op_amp
id|Instance
comma
l_int|4
)paren
suffix:semicolon
id|KeyStr
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SK_STRCMP
c_func
(paren
id|KeyStr
comma
id|KeyArr
(braket
id|Index
)braket
)paren
op_eq
l_int|0
)paren
(brace
id|FirstIndex
op_assign
id|Index
suffix:semicolon
id|LastIndex
op_assign
id|Index
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Index
op_eq
id|KeyNo
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Get value, if a query should be performed&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_VPD_FREE_BYTES
suffix:colon
multiline_comment|/* Check length of buffer */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Get number of free bytes */
id|pVpdStatus
op_assign
id|VpdStat
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pVpdStatus
op_eq
l_int|NULL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR017
comma
id|SK_PNMI_ERR017MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pVpdStatus-&gt;vpd_status
op_amp
id|VPD_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR018
comma
id|SK_PNMI_ERR018MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pVpdStatus-&gt;vpd_free_rw
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ENTRIES_LIST
suffix:colon
multiline_comment|/* Check length */
r_for
c_loop
(paren
id|Len
op_assign
l_int|0
comma
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_add_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Get value */
op_star
(paren
id|pBuf
)paren
op_assign
(paren
r_char
)paren
id|Len
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|Offset
op_assign
l_int|1
comma
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Len
)paren
suffix:semicolon
id|Offset
op_add_assign
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|Index
OL
id|KeyNo
op_minus
l_int|1
)paren
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|Offset
op_increment
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ENTRIES_NUMBER
suffix:colon
multiline_comment|/* Check length */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|KeyNo
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_KEY
suffix:colon
multiline_comment|/* Check buffer length, if it is large enough */
r_for
c_loop
(paren
id|Len
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_add_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Get the key to an intermediate buffer, because&n;&t;&t;&t; * we have to prepend a length byte.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|Len
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|1
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Len
)paren
suffix:semicolon
id|Offset
op_add_assign
id|Len
op_plus
l_int|1
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_VALUE
suffix:colon
multiline_comment|/* Check the buffer length if it is large enough */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|BufLen
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|VpdRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Buf
comma
(paren
r_int
op_star
)paren
op_amp
id|BufLen
)paren
OG
l_int|0
op_logical_or
id|BufLen
op_ge
id|SK_PNMI_VPD_DATALEN
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR021
comma
id|SK_PNMI_ERR021MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
id|BufLen
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Offset
)paren
(brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Get the value to an intermediate buffer, because&n;&t;&t;&t; * we have to prepend a length byte.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|BufLen
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|VpdRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Buf
comma
(paren
r_int
op_star
)paren
op_amp
id|BufLen
)paren
OG
l_int|0
op_logical_or
id|BufLen
op_ge
id|SK_PNMI_VPD_DATALEN
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR022
comma
id|SK_PNMI_ERR022MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|BufLen
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|1
comma
id|Buf
comma
id|BufLen
)paren
suffix:semicolon
id|Offset
op_add_assign
id|BufLen
op_plus
l_int|1
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ACCESS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|LastIndex
op_minus
id|FirstIndex
)paren
(brace
op_star
id|pLen
op_assign
id|LastIndex
op_minus
id|FirstIndex
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|VpdMayWrite
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
)paren
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|SK_PNMI_VPD_RW
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|SK_PNMI_VPD_RO
suffix:semicolon
)brace
id|Offset
op_increment
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ACTION
suffix:colon
id|Offset
op_assign
id|LastIndex
op_minus
id|FirstIndex
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Offset
)paren
(brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|SK_MEMSET
c_func
(paren
id|pBuf
comma
l_int|0
comma
id|Offset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR023
comma
id|SK_PNMI_ERR023MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The only OID which can be set is VPD_ACTION */
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_VPD_ACTION
)paren
(brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_VPD_FREE_BYTES
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ENTRIES_LIST
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ENTRIES_NUMBER
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_KEY
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_VALUE
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ACCESS
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR024
comma
id|SK_PNMI_ERR024MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * From this point we handle VPD_ACTION. Check the buffer&n;&t;&t; * length. It should at least have the size of one byte.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The first byte contains the VPD action type we should&n;&t;&t; * perform.&n;&t;&t; */
r_switch
c_cond
(paren
op_star
id|pBuf
)paren
(brace
r_case
id|SK_PNMI_VPD_IGNORE
suffix:colon
multiline_comment|/* Nothing to do */
r_break
suffix:semicolon
r_case
id|SK_PNMI_VPD_CREATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We have to create a new VPD entry or we modify&n;&t;&t;&t; * an existing one. Check first the buffer length.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|4
)paren
(brace
op_star
id|pLen
op_assign
l_int|4
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|KeyStr
(braket
l_int|0
)braket
op_assign
id|pBuf
(braket
l_int|1
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|1
)braket
op_assign
id|pBuf
(braket
l_int|2
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Is the entry writable or does it belong to the&n;&t;&t;&t; * read-only area?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|VpdMayWrite
c_func
(paren
id|KeyStr
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
id|Offset
op_assign
(paren
r_int
)paren
id|pBuf
(braket
l_int|3
)braket
op_amp
l_int|0xFF
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|Buf
comma
id|pBuf
op_plus
l_int|4
comma
id|Offset
)paren
suffix:semicolon
id|Buf
(braket
id|Offset
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* A preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the new entry or modify an existing one */
id|Ret
op_assign
id|VpdWrite
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyStr
comma
id|Buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_eq
id|SK_PNMI_VPD_NOWRITE
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR025
comma
id|SK_PNMI_ERR025MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Perform an update of the VPD data. This is&n;&t;&t;&t; * not mandantory, but just to be sure.&n;&t;&t;&t; */
id|Ret
op_assign
id|VpdUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR026
comma
id|SK_PNMI_ERR026MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_VPD_DELETE
suffix:colon
multiline_comment|/* Check if the buffer size is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|3
)paren
(brace
op_star
id|pLen
op_assign
l_int|3
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OG
l_int|3
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
id|KeyStr
(braket
l_int|0
)braket
op_assign
id|pBuf
(braket
l_int|1
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|1
)braket
op_assign
id|pBuf
(braket
l_int|2
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find the passed key in the array */
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SK_STRCMP
c_func
(paren
id|KeyStr
comma
id|KeyArr
(braket
id|Index
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * If we cannot find the key it is wrong, so we&n;&t;&t;&t; * return an appropriate error value.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Index
op_eq
id|KeyNo
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, you wanted it and you will get it */
id|Ret
op_assign
id|VpdDelete
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyStr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR027
comma
id|SK_PNMI_ERR027MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Perform an update of the VPD data. This is&n;&t;&t;&t; * not mandantory, but just to be sure.&n;&t;&t;&t; */
id|Ret
op_assign
id|VpdUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR028
comma
id|SK_PNMI_ERR028MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * General - OID handler function of various single instance OIDs&n; *&n; * Description:&n; *&t;The code is simple. No description necessary.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|General
r_static
r_int
id|General
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Val
suffix:semicolon
id|SK_U8
id|Val8
suffix:semicolon
id|SK_U16
id|Val16
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
id|SK_U64
id|Val64RxHwErrs
op_assign
l_int|0
suffix:semicolon
id|SK_U64
id|Val64TxHwErrs
op_assign
l_int|0
suffix:semicolon
id|SK_BOOL
id|Is64BitReq
op_assign
id|SK_FALSE
suffix:semicolon
r_char
id|Buf
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action. We only allow get requests.&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check length for the various supported OIDs&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_GEN_XMIT_ERROR
suffix:colon
r_case
id|OID_GEN_RCV_ERROR
suffix:colon
r_case
id|OID_GEN_RCV_NO_BUFFER
suffix:colon
macro_line|#ifndef SK_NDIS_64BIT_CTR
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
macro_line|#else /* SK_NDIS_64BIT_CTR */
multiline_comment|/*&n;&t;&t; * for compatibility, at least 32bit are required for oid&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;* but indicate handling for 64bit values,&n;&t;&t;&t;* if insufficient space is provided&n;&t;&t;&t;*/
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Is64BitReq
op_assign
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
ques
c_cond
id|SK_FALSE
suffix:colon
id|SK_TRUE
suffix:semicolon
macro_line|#endif /* SK_NDIS_64BIT_CTR */
r_break
suffix:semicolon
r_case
id|OID_SKGE_PORT_NUMBER
suffix:colon
r_case
id|OID_SKGE_DEVICE_TYPE
suffix:colon
r_case
id|OID_SKGE_RESULT
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_NUMBER
suffix:colon
r_case
id|OID_GEN_TRANSMIT_QUEUE_LENGTH
suffix:colon
r_case
id|OID_SKGE_TRAP_NUMBER
suffix:colon
r_case
id|OID_SKGE_MDB_VERSION
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHIPSET
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U16
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U16
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_TYPE
suffix:colon
r_case
id|OID_SKGE_BUS_SPEED
suffix:colon
r_case
id|OID_SKGE_BUS_WIDTH
suffix:colon
r_case
id|OID_SKGE_SENSOR_NUMBER
suffix:colon
r_case
id|OID_SKGE_CHKSM_NUMBER
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_SW_QUEUE_LEN
suffix:colon
r_case
id|OID_SKGE_TX_SW_QUEUE_MAX
suffix:colon
r_case
id|OID_SKGE_TX_RETRY
suffix:colon
r_case
id|OID_SKGE_RX_INTR_CTS
suffix:colon
r_case
id|OID_SKGE_TX_INTR_CTS
suffix:colon
r_case
id|OID_SKGE_RX_NO_BUF_CTS
suffix:colon
r_case
id|OID_SKGE_TX_NO_BUF_CTS
suffix:colon
r_case
id|OID_SKGE_TX_USED_DESCR_NO
suffix:colon
r_case
id|OID_SKGE_RX_DELIVERED_CTS
suffix:colon
r_case
id|OID_SKGE_RX_OCTETS_DELIV_CTS
suffix:colon
r_case
id|OID_SKGE_RX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_TX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_IN_ERRORS_CTS
suffix:colon
r_case
id|OID_SKGE_OUT_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_ERR_RECOVERY_CTS
suffix:colon
r_case
id|OID_SKGE_SYSUPTIME
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Checked later */
r_break
suffix:semicolon
)brace
multiline_comment|/* Update statistic */
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_RX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_TX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_IN_ERRORS_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_OUT_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_GEN_XMIT_ERROR
op_logical_or
id|Id
op_eq
id|OID_GEN_RCV_ERROR
)paren
(brace
multiline_comment|/* Force the XMAC to update its statistic counters and&n;&t;&t; * Increment semaphore to indicate that an update was&n;&t;&t; * already done.&n;&t;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some OIDs consist of multiple hardware counters. Those&n;&t;&t; * values which are contained in all of them will be added&n;&t;&t; * now.&n;&t;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_IN_ERRORS_CTS
suffix:colon
r_case
id|OID_GEN_RCV_ERROR
suffix:colon
id|Val64RxHwErrs
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_MISSED
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_FRAMING
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_OVERFLOW
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_JABBER
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_CARRIER
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_IRLENGTH
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_SYMBOL
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_SHORTS
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_RUNT
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_TOO_LONG
)paren
op_minus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_LONGFRAMES
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_FCS
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_CEXT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_OUT_ERROR_CTS
suffix:colon
r_case
id|OID_GEN_XMIT_ERROR
suffix:colon
id|Val64TxHwErrs
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_EXCESS_COL
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_LATE_COL
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_UNDERRUN
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_CARRIER
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_EXCESS_COL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Retrieve value&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_SUPPORTED_LIST
suffix:colon
id|Len
op_assign
r_sizeof
(paren
id|IdTable
)paren
op_div
r_sizeof
(paren
id|IdTable
(braket
l_int|0
)braket
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
l_int|0
suffix:semicolon
id|Offset
OL
id|Len
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
comma
id|Index
op_increment
)paren
(brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|IdTable
(braket
id|Index
)braket
dot
id|Id
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PORT_NUMBER
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_DEVICE_TYPE
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.DeviceType
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_DRIVER_DESCR
suffix:colon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.pDriverDescription
op_eq
l_int|NULL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR007
comma
id|SK_PNMI_ERR007MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;Pnmi.pDriverDescription
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|Len
OG
id|SK_PNMI_STRINGLEN1
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR029
comma
id|SK_PNMI_ERR029MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
l_int|1
comma
id|pAC-&gt;Pnmi.pDriverDescription
comma
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_DRIVER_VERSION
suffix:colon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.pDriverVersion
op_eq
l_int|NULL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR030
comma
id|SK_PNMI_ERR030MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;Pnmi.pDriverVersion
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|Len
OG
id|SK_PNMI_STRINGLEN1
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR031
comma
id|SK_PNMI_ERR031MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
l_int|1
comma
id|pAC-&gt;Pnmi.pDriverVersion
comma
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_HW_DESCR
suffix:colon
multiline_comment|/*&n;&t;&t; * The hardware description is located in the VPD. This&n;&t;&t; * query may move to the initialisation routine. But&n;&t;&t; * the VPD data is cached and therefore a call here&n;&t;&t; * will not make much difference.&n;&t;&t; */
id|Len
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|VpdRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|VPD_NAME
comma
id|Buf
comma
(paren
r_int
op_star
)paren
op_amp
id|Len
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR032
comma
id|SK_PNMI_ERR032MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Len
OG
id|SK_PNMI_STRINGLEN1
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR033
comma
id|SK_PNMI_ERR033MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
l_int|1
comma
id|Buf
comma
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_HW_VERSION
suffix:colon
multiline_comment|/* Oh, I love to do some string manipulation */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|5
)paren
(brace
op_star
id|pLen
op_assign
l_int|5
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Val8
op_assign
(paren
id|SK_U8
)paren
id|pAC-&gt;GIni.GIPciHwRev
suffix:semicolon
id|pBuf
(braket
l_int|0
)braket
op_assign
l_int|4
suffix:semicolon
id|pBuf
(braket
l_int|1
)braket
op_assign
l_char|&squot;v&squot;
suffix:semicolon
id|pBuf
(braket
l_int|2
)braket
op_assign
(paren
r_char
)paren
(paren
l_int|0x30
op_or
(paren
(paren
id|Val8
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)paren
)paren
suffix:semicolon
id|pBuf
(braket
l_int|3
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|pBuf
(braket
l_int|4
)braket
op_assign
(paren
r_char
)paren
(paren
l_int|0x30
op_or
(paren
id|Val8
op_amp
l_int|0x0F
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHIPSET
suffix:colon
id|Val16
op_assign
id|SK_PNMI_CHIPSET
suffix:semicolon
id|SK_PNMI_STORE_U16
c_func
(paren
id|pBuf
comma
id|Val16
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_TYPE
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|SK_PNMI_BUS_PCI
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_SPEED
suffix:colon
op_star
id|pBuf
op_assign
id|pAC-&gt;Pnmi.PciBusSpeed
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_WIDTH
suffix:colon
op_star
id|pBuf
op_assign
id|pAC-&gt;Pnmi.PciBusWidth
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RESULT
suffix:colon
id|Val32
op_assign
id|pAC-&gt;Pnmi.TestResult
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_NUMBER
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.MaxSens
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_NUMBER
suffix:colon
op_star
id|pBuf
op_assign
id|SKCS_NUM_PROTOCOLS
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TRAP_NUMBER
suffix:colon
id|GetTrapQueueLen
c_func
(paren
id|pAC
comma
op_amp
id|Len
comma
op_amp
id|Val
)paren
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TRAP
suffix:colon
id|GetTrapQueueLen
c_func
(paren
id|pAC
comma
op_amp
id|Len
comma
op_amp
id|Val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|CopyTrapQueue
c_func
(paren
id|pAC
comma
id|pBuf
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_MONITOR_NUMBER
suffix:colon
multiline_comment|/* XXX Not yet implemented by RLMT therefore we return zero elements */
id|Val32
op_assign
l_int|0
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_SW_QUEUE_LEN
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.TxSwQueueLen
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_SW_QUEUE_MAX
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.TxSwQueueMax
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_RETRY
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.TxRetryCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_INTR_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RxIntrCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_INTR_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.TxIntrCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_NO_BUF_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RxNoBufCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_NO_BUF_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.TxNoBufCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_USED_DESCR_NO
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.TxUsedDescrNo
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_DELIVERED_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RxDeliveredCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_OCTETS_DELIV_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RxOctetsDeliveredCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_HW_ERROR_CTS
suffix:colon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64RxHwErrs
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_HW_ERROR_CTS
suffix:colon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64TxHwErrs
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_IN_ERRORS_CTS
suffix:colon
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.RxNoBufCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_OUT_ERROR_CTS
suffix:colon
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.TxNoBufCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_ERR_RECOVERY_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.ErrRecoveryCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SYSUPTIME
suffix:colon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
id|Val64
op_sub_assign
id|pAC-&gt;Pnmi.StartUpTime
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_MDB_VERSION
suffix:colon
id|Val32
op_assign
id|SK_PNMI_MDB_VERSION
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_GEN_RCV_ERROR
suffix:colon
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.RxNoBufCts
suffix:semicolon
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|SK_U32
id|Val32
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val64
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_GEN_XMIT_ERROR
suffix:colon
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.TxNoBufCts
suffix:semicolon
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|SK_U32
id|Val32
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val64
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_GEN_RCV_NO_BUFFER
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RxNoBufCts
suffix:semicolon
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|SK_U32
id|Val32
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val64
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_GEN_TRANSMIT_QUEUE_LENGTH
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.TxSwQueueLen
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR034
comma
id|SK_PNMI_ERR034MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_RX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_TX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_IN_ERRORS_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_OUT_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_GEN_XMIT_ERROR
op_logical_or
id|Id
op_eq
id|OID_GEN_RCV_ERROR
)paren
(brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Rlmt - OID handler function of OID_SKGE_RLMT_XXX single instance.&n; *&n; * Description:&n; *&t;Get/Presets/Sets the RLMT OIDs.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Rlmt
r_static
r_int
id|Rlmt
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. Only single instance OIDs are allowed here.&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform the requested action&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check if the buffer length is large enough.&n;&t;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MODE
suffix:colon
r_case
id|OID_SKGE_RLMT_PORT_ACTIVE
suffix:colon
r_case
id|OID_SKGE_RLMT_PORT_PREFERRED
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_NUMBER
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_CHANGE_TIME
suffix:colon
r_case
id|OID_SKGE_RLMT_CHANGE_ESTIM
suffix:colon
r_case
id|OID_SKGE_RLMT_CHANGE_THRES
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR035
comma
id|SK_PNMI_ERR035MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update RLMT statistic and increment semaphores to indicate&n;&t;&t; * that an update was already done. Maybe RLMT will hold its&n;&t;&t; * statistic always up to date some time. Then we can&n;&t;&t; * remove this type of call.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Retrieve Value&n;&t;&t;*/
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MODE
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|pAC-&gt;Rlmt.RlmtMode
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_NUMBER
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_ACTIVE
suffix:colon
op_star
id|pBuf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If multiple ports may become active this OID&n;&t;&t;&t; * doesn&squot;t make sense any more. A new variable in&n;&t;&t;&t; * the port structure should be created. However,&n;&t;&t;&t; * for this variable the first active port is&n;&t;&t;&t; * returned.&n;&t;&t;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_PREFERRED
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|pAC-&gt;Rlmt.MacPreferred
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_TIME
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeTime
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_ESTIM
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_THRES
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeThreshold
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR036
comma
id|SK_PNMI_ERR036MSG
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Perform a preset or set */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MODE
suffix:colon
multiline_comment|/* Check if the buffer length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
r_char
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the value range is correct */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
r_char
)paren
op_logical_or
(paren
op_star
id|pBuf
op_amp
id|SK_PNMI_RLMT_MODE_CHK_LINK
)paren
op_eq
l_int|0
op_logical_or
op_star
(paren
id|SK_U8
op_star
)paren
id|pBuf
OG
l_int|15
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an event to RLMT to change the mode */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|0
)braket
op_or_assign
(paren
id|SK_U32
)paren
(paren
op_star
id|pBuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SkRlmtEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_RLMT_MODE_CHANGE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR037
comma
id|SK_PNMI_ERR037MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_PREFERRED
suffix:colon
multiline_comment|/* Check if the buffer length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
r_char
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the value range is correct */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
r_char
)paren
op_logical_or
op_star
(paren
id|SK_U8
op_star
)paren
id|pBuf
OG
(paren
id|SK_U8
)paren
id|pAC-&gt;GIni.GIMacsFound
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Send an event to RLMT change the preferred port.&n;&t;&t;&t; * A param of -1 means automatic mode. RLMT will&n;&t;&t;&t; * make the decision which is the preferred port.&n;&t;&t;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
(paren
id|SK_U32
)paren
(paren
op_star
id|pBuf
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SkRlmtEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_RLMT_PREFPORT_CHANGE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR038
comma
id|SK_PNMI_ERR038MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_THRES
suffix:colon
multiline_comment|/* Check if the buffer length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * There are not many restrictions to the&n;&t;&t;&t; * value range.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* A preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Store the new threshold, which will be taken&n;&t;&t;&t; * on the next timer event.&n;&t;&t;&t; */
id|SK_PNMI_READ_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeThreshold
op_assign
id|Val64
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* The other OIDs are not be able for set */
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * RlmtStat - OID handler function of OID_SKGE_RLMT_XXX multiple instance.&n; *&n; * Description:&n; *&t;Performs get requests on multiple instance variables.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|RlmtStat
r_static
r_int
id|RlmtStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the port indexes from the instance&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|PhysPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|PhysPortIndex
op_assign
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
id|PhysPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|PhysPortMax
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Currently only get requests are allowed.&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if the buffer length is large enough.&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_PORT_INDEX
suffix:colon
r_case
id|OID_SKGE_RLMT_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_TX_HELLO_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_RX_HELLO_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_TX_SP_REQ_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_RX_SP_CTS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR039
comma
id|SK_PNMI_ERR039MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update statistic and increment semaphores to indicate that&n;&t; * an update was already done.&n;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Get value&n;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|PhysPortIndex
OL
id|Limit
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_PORT_INDEX
suffix:colon
id|Val32
op_assign
id|PhysPortIndex
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_STATUS
suffix:colon
r_if
c_cond
(paren
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|PortState
op_eq
id|SK_RLMT_PS_INIT
op_logical_or
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|PortState
op_eq
id|SK_RLMT_PS_DOWN
)paren
(brace
id|Val32
op_assign
id|SK_PNMI_RLMT_STATUS_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
id|Val32
op_assign
id|SK_PNMI_RLMT_STATUS_ACTIVE
suffix:semicolon
)brace
r_else
(brace
id|Val32
op_assign
id|SK_PNMI_RLMT_STATUS_STANDBY
suffix:semicolon
)brace
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_TX_HELLO_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|TxHelloCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_RX_HELLO_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|RxHelloCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_TX_SP_REQ_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|TxSpHelloReqCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_RX_SP_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|RxSpHelloCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR040
comma
id|SK_PNMI_ERR040MSG
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * MacPrivateConf - OID handler function of OIDs concerning the configuration&n; *&n; * Description:&n; *&t;Get/Presets/Sets the OIDs concerning the configuration.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|MacPrivateConf
r_static
r_int
id|MacPrivateConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|LogPortMax
suffix:semicolon
r_int
r_int
id|LogPortIndex
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_char
id|Val8
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished. MAC index 0 is the virtual&n;&t; * MAC.&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|LogPortIndex
op_assign
id|SK_PNMI_PORT_INST2LOG
c_func
(paren
id|Instance
)paren
suffix:semicolon
id|Limit
op_assign
id|LogPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|LogPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|LogPortMax
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform action&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check length&n;&t;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_PMD
suffix:colon
r_case
id|OID_SKGE_CONNECTOR
suffix:colon
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR041
comma
id|SK_PNMI_ERR041MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update statistic and increment semaphore to indicate&n;&t;&t; * that an update was already done.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|SirqUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get value&n;&t;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_PMD
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;Pnmi.PMD
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CONNECTOR
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;Pnmi.Connector
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkModeConf
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|CalculateLinkModeStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|CalculateLinkStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlMode
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlStatus
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSMode
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSStatus
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR042
comma
id|SK_PNMI_ERR042MSG
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * From here SET or PRESET action. Check if the passed&n;&t; * buffer length is plausible.&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Limit
op_minus
id|LogPortIndex
)paren
(brace
op_star
id|pLen
op_assign
id|Limit
op_minus
id|LogPortIndex
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
op_ne
id|Limit
op_minus
id|LogPortIndex
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform preset or set&n;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
template_param
id|SK_LMODE_AUTOSENSE
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with the new link mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_LMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR043
comma
id|SK_PNMI_ERR043MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new link mode to&n;&t;&t;&t;&t; * the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_LMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR043
comma
id|SK_PNMI_ERR043MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
template_param
id|SK_FLOW_MODE_SYM_OR_REM
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with the new flow control mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_FLOWMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR044
comma
id|SK_PNMI_ERR044MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new flow control&n;&t;&t;&t;&t; * mode to the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_FLOWMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR044
comma
id|SK_PNMI_ERR044MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
multiline_comment|/* mode of this port remains unchanged */
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
template_param
id|SK_MS_MODE_SLAVE
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with new master/slave (role) mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_ROLE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR052
comma
id|SK_PNMI_ERR052MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new master/slave&n;&t;&t;&t;&t; * (role) mode to the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_ROLE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR052
comma
id|SK_PNMI_ERR052MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR045
comma
id|SK_PNMI_ERR045MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Monitor - OID handler function for RLMT_MONITOR_XXX&n; *&n; * Description:&n; *&t;Because RLMT currently does not support the monitoring of&n; *&t;remote adapter cards, we return always an empty table.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Monitor
r_static
r_int
id|Monitor
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
)paren
multiline_comment|/* Index to the Id table */
(brace
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Entries
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished.&n;&t; */
multiline_comment|/* XXX Not yet implemented. Return always an empty table. */
id|Entries
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|Entries
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|Index
op_assign
(paren
r_int
r_int
)paren
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|Instance
suffix:semicolon
)brace
r_else
(brace
id|Index
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|Entries
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get/Set value&n;&t;*/
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|Limit
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MONITOR_INDEX
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_ADDR
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_ERRS
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_TIMESTAMP
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_ADMIN
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR046
comma
id|SK_PNMI_ERR046MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only MONITOR_ADMIN can be set */
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_RLMT_MONITOR_ADMIN
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Okay, we have a wide value range */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
(paren
id|Limit
op_minus
id|Index
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;for (Offset=0; Index &lt; Limit; Index ++) {&n;&t;&t;}&n;*/
multiline_comment|/*&n; * XXX Not yet implemented. Return always BAD_VALUE, because the table&n; * is empty.&n; */
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * VirtualConf - Calculates the values of configuration OIDs for virtual port&n; *&n; * Description:&n; *&t;We handle here the get of the configuration group OIDs, which are&n; *&t;a little bit complicated. The virtual port consists of all currently&n; *&t;active physical ports. If multiple ports are active and configured&n; *&t;differently we get in some trouble to return a single value. So we&n; *&t;get the value of the first active port and compare it with that of&n; *&t;the other active ports. If they are not the same, we return a value&n; *&t;that indicates that the state is indeterminated.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|VirtualConf
r_static
r_void
id|VirtualConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
)paren
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
(brace
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
id|SK_U8
id|Val8
suffix:semicolon
id|SK_BOOL
id|PortActiveFlag
suffix:semicolon
op_star
id|pBuf
op_assign
l_int|0
suffix:semicolon
id|PortActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
multiline_comment|/* Check if the physical port is active */
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|PortActiveFlag
op_assign
id|SK_TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Different capabilities should not happen, but&n;&t;&t;&t; * in the case of the cases OR them all together.&n;&t;&t;&t; * From a curious point of view the virtual port&n;&t;&t;&t; * is capable of all found capabilities.&n;&t;&t;&t; */
op_star
id|pBuf
op_or_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkCap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkModeConf
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different link&n;&t;&t;&t; * mode than the first one we return a value that&n;&t;&t;&t; * indicates that the link mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkModeConf
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_LMODE_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
multiline_comment|/* Get the link mode of the physical port */
id|Val8
op_assign
id|CalculateLinkModeStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|Val8
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different link&n;&t;&t;&t; * mode status than the first one we return a value&n;&t;&t;&t; * that indicates that the link mode status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|Val8
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_LMODE_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
multiline_comment|/* Get the link status of the physical port */
id|Val8
op_assign
id|CalculateLinkStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|Val8
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different link&n;&t;&t;&t; * status than the first one, we return a value&n;&t;&t;&t; * that indicates that the link status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|Val8
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_PNMI_RLMT_LSTAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlCap
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * From a curious point of view the virtual port&n;&t;&t;&t; * is capable of all found capabilities.&n;&t;&t;&t; */
op_star
id|pBuf
op_or_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlCap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlMode
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different flow&n;&t;&t;&t; * control mode than the first one, we return a value&n;&t;&t;&t; * that indicates that the mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlMode
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_FLOW_MODE_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlStatus
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different flow&n;&t;&t;&t; * control status than the first one, we return a&n;&t;&t;&t; * value that indicates that the status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlStatus
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_FLOW_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSCap
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * From a curious point of view the virtual port&n;&t;&t;&t; * is capable of all found capabilities.&n;&t;&t;&t; */
op_star
id|pBuf
op_or_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSCap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSMode
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different master/&n;&t;&t;&t; * slave mode than the first one, we return a value&n;&t;&t;&t; * that indicates that the mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSMode
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_MS_MODE_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSStatus
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different master/&n;&t;&t;&t; * slave status than the first one, we return a&n;&t;&t;&t; * value that indicates that the status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSStatus
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_MS_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If no port is active return an indeterminated answer&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PortActiveFlag
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LMODE_CAP_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LMODE_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LMODE_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_PNMI_RLMT_LSTAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_FLOW_MODE_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_FLOW_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
op_star
id|pBuf
op_assign
id|SK_MS_CAP_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_MS_MODE_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_MS_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CalculateLinkStatus - Determins the link status of a physical port&n; *&n; * Description:&n; *&t;Determins the link status the following way:&n; *&t;  LSTAT_PHY_DOWN:  Link is down&n; *&t;  LSTAT_AUTONEG:   Auto-negotiation failed&n; *&t;  LSTAT_LOG_DOWN:  Link is up but RLMT did not yet put the port&n; *&t;                   logically up.&n; *&t;  LSTAT_LOG_UP:    RLMT marked the port as up&n; *&n; * Returns:&n; *&t;Link status of physical port&n; */
DECL|function|CalculateLinkStatus
r_static
id|SK_U8
id|CalculateLinkStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|PhysPortIndex
)paren
multiline_comment|/* Physical port index */
(brace
id|SK_U8
id|Result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PHWLinkUp
)paren
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_PHY_DOWN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PAutoNegFail
OG
l_int|0
)paren
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_AUTONEG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|PortDown
)paren
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_LOG_UP
suffix:semicolon
)brace
r_else
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_LOG_DOWN
suffix:semicolon
)brace
r_return
(paren
id|Result
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CalculateLinkModeStatus - Determins the link mode status of a phys. port&n; *&n; * Description:&n; *&t;The COMMON module only tells us if the mode is half or full duplex.&n; *&t;But in the decade of auto sensing it is usefull for the user to&n; *&t;know if the mode was negotiated or forced. Therefore we have a&n; *&t;look to the mode, which was last used by the negotiation process.&n; *&n; * Returns:&n; *&t;The link mode status&n; */
DECL|function|CalculateLinkModeStatus
r_static
id|SK_U8
id|CalculateLinkModeStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|PhysPortIndex
)paren
multiline_comment|/* Physical port index */
(brace
id|SK_U8
id|Result
suffix:semicolon
multiline_comment|/* Get the current mode, which can be full or half duplex */
id|Result
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkModeStatus
suffix:semicolon
multiline_comment|/* Check if no valid mode could be found (link is down) */
r_if
c_cond
(paren
id|Result
OL
id|SK_LMODE_STAT_HALF
)paren
(brace
id|Result
op_assign
id|SK_LMODE_STAT_UNKNOWN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkMode
op_ge
id|SK_LMODE_AUTOHALF
)paren
(brace
multiline_comment|/*&n;&t;&t; * Auto-negotiation was used to bring up the link. Change&n;&t;&t; * the already found duplex status that it indicates&n;&t;&t; * auto-negotiation was involved.&n;&t;&t; */
r_if
c_cond
(paren
id|Result
op_eq
id|SK_LMODE_STAT_HALF
)paren
(brace
id|Result
op_assign
id|SK_LMODE_STAT_AUTOHALF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|Result
op_eq
id|SK_LMODE_STAT_FULL
)paren
(brace
id|Result
op_assign
id|SK_LMODE_STAT_AUTOFULL
suffix:semicolon
)brace
)brace
r_return
(paren
id|Result
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetVpdKeyArr - Obtain an array of VPD keys&n; *&n; * Description:&n; *&t;Read the VPD keys and build an array of VPD keys, which are&n; *&t;easy to access.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|GetVpdKeyArr
r_static
r_int
id|GetVpdKeyArr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_char
op_star
id|pKeyArr
comma
multiline_comment|/* Ptr KeyArray */
r_int
r_int
id|KeyArrLen
comma
multiline_comment|/* Length of array in bytes */
r_int
r_int
op_star
id|pKeyNo
)paren
multiline_comment|/* Number of keys */
(brace
r_int
r_int
id|BufKeysLen
op_assign
l_int|128
suffix:semicolon
r_char
id|BufKeys
(braket
l_int|128
)braket
suffix:semicolon
r_int
r_int
id|StartOffset
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
id|Index
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_MEMSET
c_func
(paren
id|pKeyArr
comma
l_int|0
comma
id|KeyArrLen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get VPD key list&n;&t; */
id|Ret
op_assign
id|VpdKeys
c_func
(paren
id|pAC
comma
id|IoC
comma
(paren
r_char
op_star
)paren
op_amp
id|BufKeys
comma
(paren
r_int
op_star
)paren
op_amp
id|BufKeysLen
comma
(paren
r_int
op_star
)paren
id|pKeyNo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR014
comma
id|SK_PNMI_ERR014MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* If no keys are available return now */
r_if
c_cond
(paren
op_star
id|pKeyNo
op_eq
l_int|0
op_logical_or
id|BufKeysLen
op_eq
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the key list is too long for us trunc it and give a&n;&t; * errorlog notification. This case should not happen because&n;&t; * the maximum number of keys is limited due to RAM limitations&n;&t; */
r_if
c_cond
(paren
op_star
id|pKeyNo
OG
id|SK_PNMI_VPD_ARR_SIZE
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR015
comma
id|SK_PNMI_ERR015MSG
)paren
suffix:semicolon
op_star
id|pKeyNo
op_assign
id|SK_PNMI_VPD_ARR_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now build an array of fixed string length size and copy&n;&t; * the keys together.&n;&t; */
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
comma
id|StartOffset
op_assign
l_int|0
comma
id|Offset
op_assign
l_int|0
suffix:semicolon
id|Offset
OL
id|BufKeysLen
suffix:semicolon
id|Offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BufKeys
(braket
id|Offset
)braket
op_ne
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Offset
op_minus
id|StartOffset
OG
id|SK_PNMI_VPD_STR_SIZE
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR016
comma
id|SK_PNMI_ERR016MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|SK_STRNCPY
c_func
(paren
id|pKeyArr
op_plus
id|Index
op_star
id|SK_PNMI_VPD_STR_SIZE
comma
op_amp
id|BufKeys
(braket
id|StartOffset
)braket
comma
id|SK_PNMI_VPD_STR_SIZE
)paren
suffix:semicolon
id|Index
op_increment
suffix:semicolon
id|StartOffset
op_assign
id|Offset
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Last key not zero terminated? Get it anyway */
r_if
c_cond
(paren
id|StartOffset
OL
id|Offset
)paren
(brace
id|SK_STRNCPY
c_func
(paren
id|pKeyArr
op_plus
id|Index
op_star
id|SK_PNMI_VPD_STR_SIZE
comma
op_amp
id|BufKeys
(braket
id|StartOffset
)braket
comma
id|SK_PNMI_VPD_STR_SIZE
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SirqUpdate - Let the SIRQ update its internal values&n; *&n; * Description:&n; *&t;Just to be sure that the SIRQ module holds its internal data&n; *&t;structures up to date, we send an update event before we make&n; *&t;any access.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|SirqUpdate
r_static
r_int
id|SirqUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context handle */
(brace
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/* Was the module already updated during the current PNMI call? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.SirqUpdatedFlag
OG
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an synchronuous update event to the module */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_UPDATE_STAT
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR047
comma
id|SK_PNMI_ERR047MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * RlmtUpdate - Let the RLMT update its internal values&n; *&n; * Description:&n; *&t;Just to be sure that the RLMT module holds its internal data&n; *&t;structures up to date, we send an update event before we make&n; *&t;any access.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|RlmtUpdate
r_static
r_int
id|RlmtUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context handle */
(brace
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/* Was the module already updated during the current PNMI call? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
OG
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an synchronuous update event to the module */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SkRlmtEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_RLMT_STATS_UPDATE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR048
comma
id|SK_PNMI_ERR048MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * MacUpdate - Force the XMAC to output the current statistic&n; *&n; * Description:&n; *&t;The XMAC holds its statistic internally. To obtain the current&n; *&t;values we must send a command so that the statistic data will&n; *&t;be written to a predefined memory area on the adapter. &n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|MacUpdate
r_static
r_int
id|MacUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|FirstMac
comma
multiline_comment|/* Index of the first Mac to be updated */
r_int
r_int
id|LastMac
)paren
multiline_comment|/* Index of the last Mac to be updated */
(brace
r_int
r_int
id|MacIndex
suffix:semicolon
id|SK_U16
id|StatReg
suffix:semicolon
r_int
r_int
id|WaitIndex
suffix:semicolon
multiline_comment|/*&n;&t; * Were the statistics already updated during the&n;&t; * current PNMI call?&n;&t; */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.MacUpdatedFlag
OG
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an update command to all XMACs specified */
r_for
c_loop
(paren
id|MacIndex
op_assign
id|FirstMac
suffix:semicolon
id|MacIndex
op_le
id|LastMac
suffix:semicolon
id|MacIndex
op_increment
)paren
(brace
id|StatReg
op_assign
id|XM_SC_SNP_TXC
op_or
id|XM_SC_SNP_RXC
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|MacIndex
comma
id|XM_STAT_CMD
comma
id|StatReg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * It is an auto-clearing register. If the command bits&n;&t;&t; * went to zero again, the statistics are transfered.&n;&t;&t; * Normally the command should be executed immediately.&n;&t;&t; * But just to be sure we execute a loop.&n;&t;&t; */
r_for
c_loop
(paren
id|WaitIndex
op_assign
l_int|0
suffix:semicolon
id|WaitIndex
OL
l_int|10
suffix:semicolon
id|WaitIndex
op_increment
)paren
(brace
id|XM_IN16
c_func
(paren
id|IoC
comma
id|MacIndex
comma
id|XM_STAT_CMD
comma
op_amp
id|StatReg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|StatReg
op_amp
(paren
id|XM_SC_SNP_TXC
op_or
id|XM_SC_SNP_RXC
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|WaitIndex
op_eq
l_int|10
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SK_PNMI_ERR050
comma
id|SK_PNMI_ERR050MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetStatVal - Retrieve an XMAC statistic counter&n; *&n; * Description:&n; *&t;Retrieves the statistic counter of a virtual or physical port. The&n; *&t;virtual port is identified by the index 0. It consists of all&n; *&t;currently active ports. To obtain the counter value for this port&n; *&t;we must add the statistic counter of all active ports. To grant&n; *&t;continuous counter values for the virtual port even when port&n; *&t;switches occur we must additionally add a delta value, which was&n; *&t;calculated during a SK_PNMI_EVT_RLMT_ACTIVE_UP event.&n; *&n; * Returns:&n; *&t;Requested statistic value&n; */
DECL|function|GetStatVal
r_static
id|SK_U64
id|GetStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|LogPortIndex
comma
multiline_comment|/* Index of the logical Port to be processed */
r_int
r_int
id|StatIndex
)paren
multiline_comment|/* Index to statistic value */
(brace
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
id|SK_U64
id|Val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
multiline_comment|/* Add counter of all active ports */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
id|Val
op_add_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatIndex
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Correct value because of port switches */
id|Val
op_add_assign
id|pAC-&gt;Pnmi.VirtualCounterOffset
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get counter value of physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|Val
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatIndex
)paren
suffix:semicolon
)brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetPhysStatVal - Get counter value for physical port&n; *&n; * Description:&n; *&t;Builds a 64bit counter value. Except for the octet counters&n; *&t;the lower 32bit are counted in hardware and the upper 32bit&n; *&t;in software by monitoring counter overflow interrupts in the&n; *&t;event handler. To grant continous counter values during XMAC&n; *&t;resets (caused by a workaround) we must add a delta value.&n; *&t;The delta was calculated in the event handler when a&n; *&t;SK_PNMI_EVT_XMAC_RESET was received.&n; *&n; * Returns:&n; *&t;Counter value&n; */
DECL|function|GetPhysStatVal
r_static
id|SK_U64
id|GetPhysStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|PhysPortIndex
comma
multiline_comment|/* Index of the logical Port to be processed */
r_int
r_int
id|StatIndex
)paren
multiline_comment|/* Index to statistic value */
(brace
id|SK_U64
id|Val
op_assign
l_int|0
suffix:semicolon
id|SK_U32
id|LowVal
suffix:semicolon
id|SK_U32
id|HighVal
suffix:semicolon
r_switch
c_cond
(paren
id|StatIndex
)paren
(brace
r_case
id|SK_PNMI_HTX_OCTET
suffix:colon
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TXO_OK_LO
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TXO_OK_HI
comma
op_amp
id|HighVal
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_OCTET
suffix:colon
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RXO_OK_LO
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RXO_OK_HI
comma
op_amp
id|HighVal
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HRX_OCTETLOW
suffix:colon
r_return
(paren
id|Val
)paren
suffix:semicolon
r_case
id|SK_PNMI_HTX_SYNC
suffix:colon
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncCts
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncCts
op_rshift
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_SYNC_OCTET
suffix:colon
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncOctetsCts
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncOctetsCts
op_rshift
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_LONGFRAMES
suffix:colon
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxLongFrameCts
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxLongFrameCts
op_rshift
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_FCS
suffix:colon
multiline_comment|/* &n;&t;&t; * Broadcom filters fcs errors and counts it in &n;&t;&t; * Receive Error Counter register&n;&t;&t; */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PhyType
op_eq
id|SK_PHY_BCOM
)paren
(brace
multiline_comment|/* do not read while not initialized (PHY_READ hangs!)*/
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PState
)paren
(brace
id|PHY_READ
c_func
(paren
id|IoC
comma
op_amp
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
comma
id|PhysPortIndex
comma
id|PHY_BCOM_RE_CTR
comma
op_amp
id|LowVal
)paren
suffix:semicolon
)brace
r_else
(brace
id|LowVal
op_assign
l_int|0
suffix:semicolon
)brace
id|HighVal
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_else
(brace
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddress
(braket
id|StatIndex
)braket
dot
id|Param
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_default
suffix:colon
id|XM_IN32
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddress
(braket
id|StatIndex
)braket
dot
id|Param
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
id|Val
op_assign
(paren
(paren
(paren
id|SK_U64
)paren
id|HighVal
op_lshift
l_int|32
)paren
op_or
(paren
id|SK_U64
)paren
id|LowVal
)paren
suffix:semicolon
multiline_comment|/* Correct value because of possible XMAC reset. XMAC Errata #2 */
id|Val
op_add_assign
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
(braket
id|StatIndex
)braket
suffix:semicolon
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * ResetCounter - Set all counters and timestamps to zero&n; *&n; * Description:&n; *&t;Notifies other common modules which store statistic data to&n; *&t;reset their counters and finally reset our own counters.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|ResetCounter
r_static
r_void
id|ResetCounter
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context handle */
(brace
r_int
r_int
id|PhysPortIndex
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
multiline_comment|/* Notify sensor module */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_I2C
comma
id|SK_I2CEV_CLEAR
comma
id|EventParam
)paren
suffix:semicolon
multiline_comment|/* Notify RLMT module */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_RLMT
comma
id|SK_RLMT_STATS_CLEAR
comma
id|EventParam
)paren
suffix:semicolon
multiline_comment|/* Notify SIRQ module */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_HWAC
comma
id|SK_HWEV_CLEAR_STAT
comma
id|EventParam
)paren
suffix:semicolon
multiline_comment|/* Notify CSUM module */
macro_line|#ifdef SK_USE_CSUM
id|EventParam.Para64
op_assign
(paren
id|SK_U64
)paren
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_CSUM
comma
id|SK_CSUM_EVENT_CLEAR_PROTO_STATS
comma
id|EventParam
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Clear XMAC statistic */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
(paren
r_int
r_int
)paren
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_STAT_CMD
comma
id|XM_SC_CLR_RXC
op_or
id|XM_SC_CLR_TXC
)paren
suffix:semicolon
multiline_comment|/* Clear two times according to Errata #3 */
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_STAT_CMD
comma
id|XM_SC_CLR_RXC
op_or
id|XM_SC_CLR_TXC
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncCts
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncOctetsCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncOctetsCts
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxLongFrameCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxLongFrameCts
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear local statistics&n;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.VirtualCounterOffset
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.VirtualCounterOffset
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeTime
op_assign
l_int|0
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstValue
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstValue
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstValueIndex
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.TxSwQueueMax
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.TxRetryCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RxIntrCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.TxIntrCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RxNoBufCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.TxNoBufCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.TxUsedDescrNo
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RxDeliveredCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RxOctetsDeliveredCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.ErrRecoveryCts
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetTrapEntry - Get an entry in the trap buffer&n; *&n; * Description:&n; *&t;The trap buffer stores various events. A user application somehow&n; *&t;gets notified that an event occured and retrieves the trap buffer&n; *&t;contens (or simply polls the buffer). The buffer is organized as&n; *&t;a ring which stores the newest traps at the beginning. The oldest&n; *&t;traps are overwritten by the newest ones. Each trap entry has a&n; *&t;unique number, so that applications may detect new trap entries.&n; *&n; * Returns:&n; *&t;A pointer to the trap entry&n; */
DECL|function|GetTrapEntry
r_static
r_char
op_star
id|GetTrapEntry
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
comma
multiline_comment|/* SNMP ID of the trap */
r_int
r_int
id|Size
)paren
multiline_comment|/* Space needed for trap entry */
(brace
r_int
r_int
id|BufPad
op_assign
id|pAC-&gt;Pnmi.TrapBufPad
suffix:semicolon
r_int
r_int
id|BufFree
op_assign
id|pAC-&gt;Pnmi.TrapBufFree
suffix:semicolon
r_int
r_int
id|Beg
op_assign
id|pAC-&gt;Pnmi.TrapQueueBeg
suffix:semicolon
r_int
r_int
id|End
op_assign
id|pAC-&gt;Pnmi.TrapQueueEnd
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
op_amp
id|pAC-&gt;Pnmi.TrapBuf
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|Wrap
suffix:semicolon
r_int
r_int
id|NeededSpace
suffix:semicolon
r_int
r_int
id|EntrySize
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/* Last byte of entry will get a copy of the entry length */
id|Size
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate needed buffer space */
r_if
c_cond
(paren
id|Beg
op_ge
id|Size
)paren
(brace
id|NeededSpace
op_assign
id|Size
suffix:semicolon
id|Wrap
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|NeededSpace
op_assign
id|Beg
op_plus
id|Size
suffix:semicolon
id|Wrap
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if enough buffer space is provided. Otherwise&n;&t; * free some entries. Leave one byte space between begin&n;&t; * and end of buffer to make it possible to detect whether&n;&t; * the buffer is full or empty&n;&t; */
r_while
c_loop
(paren
id|BufFree
OL
id|NeededSpace
op_plus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|End
op_eq
l_int|0
)paren
(brace
id|End
op_assign
id|SK_PNMI_TRAP_QUEUE_LEN
suffix:semicolon
)brace
id|EntrySize
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|pBuf
op_plus
id|End
op_minus
l_int|1
)paren
suffix:semicolon
id|BufFree
op_add_assign
id|EntrySize
suffix:semicolon
id|End
op_sub_assign
id|EntrySize
suffix:semicolon
macro_line|#ifdef DEBUG
id|SK_MEMSET
c_func
(paren
id|pBuf
op_plus
id|End
comma
(paren
r_char
)paren
(paren
op_minus
l_int|1
)paren
comma
id|EntrySize
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|End
op_eq
id|BufPad
)paren
(brace
macro_line|#ifdef DEBUG
id|SK_MEMSET
c_func
(paren
id|pBuf
comma
(paren
r_char
)paren
(paren
op_minus
l_int|1
)paren
comma
id|End
)paren
suffix:semicolon
macro_line|#endif
id|BufFree
op_add_assign
id|End
suffix:semicolon
id|End
op_assign
l_int|0
suffix:semicolon
id|BufPad
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * Insert new entry as first entry. Newest entries are&n;&t; * stored at the beginning of the queue.&n;&t; */
r_if
c_cond
(paren
id|Wrap
)paren
(brace
id|BufPad
op_assign
id|Beg
suffix:semicolon
id|Beg
op_assign
id|SK_PNMI_TRAP_QUEUE_LEN
op_minus
id|Size
suffix:semicolon
)brace
r_else
(brace
id|Beg
op_assign
id|Beg
op_minus
id|Size
suffix:semicolon
)brace
id|BufFree
op_sub_assign
id|NeededSpace
suffix:semicolon
multiline_comment|/* Save the current offsets */
id|pAC-&gt;Pnmi.TrapQueueBeg
op_assign
id|Beg
suffix:semicolon
id|pAC-&gt;Pnmi.TrapQueueEnd
op_assign
id|End
suffix:semicolon
id|pAC-&gt;Pnmi.TrapBufPad
op_assign
id|BufPad
suffix:semicolon
id|pAC-&gt;Pnmi.TrapBufFree
op_assign
id|BufFree
suffix:semicolon
multiline_comment|/* Initialize the trap entry */
op_star
(paren
id|pBuf
op_plus
id|Beg
op_plus
id|Size
op_minus
l_int|1
)paren
op_assign
(paren
r_char
)paren
id|Size
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Beg
)paren
op_assign
(paren
r_char
)paren
id|Size
suffix:semicolon
id|Val32
op_assign
(paren
id|pAC-&gt;Pnmi.TrapUnique
)paren
op_increment
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Beg
op_plus
l_int|1
comma
id|Val32
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Beg
op_plus
l_int|1
op_plus
r_sizeof
(paren
id|SK_U32
)paren
comma
id|TrapId
)paren
suffix:semicolon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Beg
op_plus
l_int|1
op_plus
l_int|2
op_star
r_sizeof
(paren
id|SK_U32
)paren
comma
id|Val64
)paren
suffix:semicolon
r_return
(paren
id|pBuf
op_plus
id|Beg
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CopyTrapQueue - Copies the trap buffer for the TRAP OID&n; *&n; * Description:&n; *&t;On a query of the TRAP OID the trap buffer contents will be&n; *&t;copied continuously to the request buffer, which must be large&n; *&t;enough. No length check is performed.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|CopyTrapQueue
r_static
r_void
id|CopyTrapQueue
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
r_char
op_star
id|pDstBuf
)paren
multiline_comment|/* Buffer to which the queued traps will be copied */
(brace
r_int
r_int
id|BufPad
op_assign
id|pAC-&gt;Pnmi.TrapBufPad
suffix:semicolon
r_int
r_int
id|Trap
op_assign
id|pAC-&gt;Pnmi.TrapQueueBeg
suffix:semicolon
r_int
r_int
id|End
op_assign
id|pAC-&gt;Pnmi.TrapQueueEnd
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
op_amp
id|pAC-&gt;Pnmi.TrapBuf
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|DstOff
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|Trap
op_ne
id|End
)paren
(brace
id|Len
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
id|pBuf
op_plus
id|Trap
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Last byte containing a copy of the length will&n;&t;&t; * not be copied.&n;&t;&t; */
op_star
(paren
id|pDstBuf
op_plus
id|DstOff
)paren
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pDstBuf
op_plus
id|DstOff
op_plus
l_int|1
comma
id|pBuf
op_plus
id|Trap
op_plus
l_int|1
comma
id|Len
op_minus
l_int|2
)paren
suffix:semicolon
id|DstOff
op_add_assign
id|Len
op_minus
l_int|1
suffix:semicolon
id|Trap
op_add_assign
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|Trap
op_eq
id|SK_PNMI_TRAP_QUEUE_LEN
)paren
(brace
id|Trap
op_assign
id|BufPad
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetTrapQueueLen - Get the length of the trap buffer&n; *&n; * Description:&n; *&t;Evaluates the number of currently stored traps and the needed&n; *&t;buffer size to retrieve them.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|GetTrapQueueLen
r_static
r_void
id|GetTrapQueueLen
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length in Bytes of all queued traps */
r_int
r_int
op_star
id|pEntries
)paren
multiline_comment|/* Returns number of trapes stored in queue */
(brace
r_int
r_int
id|BufPad
op_assign
id|pAC-&gt;Pnmi.TrapBufPad
suffix:semicolon
r_int
r_int
id|Trap
op_assign
id|pAC-&gt;Pnmi.TrapQueueBeg
suffix:semicolon
r_int
r_int
id|End
op_assign
id|pAC-&gt;Pnmi.TrapQueueEnd
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
op_amp
id|pAC-&gt;Pnmi.TrapBuf
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|Entries
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|TotalLen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|Trap
op_ne
id|End
)paren
(brace
id|Len
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
id|pBuf
op_plus
id|Trap
)paren
suffix:semicolon
id|TotalLen
op_add_assign
id|Len
op_minus
l_int|1
suffix:semicolon
id|Entries
op_increment
suffix:semicolon
id|Trap
op_add_assign
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|Trap
op_eq
id|SK_PNMI_TRAP_QUEUE_LEN
)paren
(brace
id|Trap
op_assign
id|BufPad
suffix:semicolon
)brace
)brace
op_star
id|pEntries
op_assign
id|Entries
suffix:semicolon
op_star
id|pLen
op_assign
id|TotalLen
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueSimpleTrap - Store a simple trap to the trap buffer&n; *&n; * Description:&n; *&t;A simple trap is a trap with now additional data. It consists&n; *&t;simply of a trap code.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueSimpleTrap
r_static
r_void
id|QueueSimpleTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
)paren
multiline_comment|/* Type of sensor trap */
(brace
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|TrapId
comma
id|SK_PNMI_TRAP_SIMPLE_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueSensorTrap - Stores a sensor trap in the trap buffer&n; *&n; * Description:&n; *&t;Gets an entry in the trap buffer and fills it with sensor related&n; *&t;data.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueSensorTrap
r_static
r_void
id|QueueSensorTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
comma
multiline_comment|/* Type of sensor trap */
r_int
r_int
id|SensorIndex
)paren
multiline_comment|/* Index of sensor which caused the trap */
(brace
r_char
op_star
id|pBuf
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|DescrLen
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
multiline_comment|/* Get trap buffer entry */
id|DescrLen
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenDesc
)paren
suffix:semicolon
id|pBuf
op_assign
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|TrapId
comma
id|SK_PNMI_TRAP_SENSOR_LEN_BASE
op_plus
id|DescrLen
)paren
suffix:semicolon
id|Offset
op_assign
id|SK_PNMI_TRAP_SIMPLE_LEN
suffix:semicolon
multiline_comment|/* Store additionally sensor trap related data */
id|Val32
op_assign
id|OID_SKGE_SENSOR_INDEX
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
l_int|4
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|SensorIndex
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
l_int|9
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|OID_SKGE_SENSOR_DESCR
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
(paren
r_char
)paren
id|DescrLen
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
comma
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenDesc
comma
id|DescrLen
)paren
suffix:semicolon
id|Offset
op_add_assign
id|DescrLen
op_plus
l_int|5
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_SENSOR_TYPE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
)paren
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenType
suffix:semicolon
id|Offset
op_add_assign
l_int|6
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_SENSOR_VALUE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
l_int|4
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenValue
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
comma
id|Val32
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueRlmtNewMacTrap - Store a port switch trap in the trap buffer&n; *&n; * Description:&n; *&t;Nothing further to explain.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueRlmtNewMacTrap
r_static
r_void
id|QueueRlmtNewMacTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
r_int
r_int
id|ActiveMac
)paren
multiline_comment|/* Index (0..n) of the currently active port */
(brace
r_char
op_star
id|pBuf
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|pBuf
op_assign
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_CHANGE_PORT
comma
id|SK_PNMI_TRAP_RLMT_CHANGE_LEN
)paren
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_RLMT_PORT_ACTIVE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|4
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|5
)paren
op_assign
(paren
r_char
)paren
id|ActiveMac
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueRlmtPortTrap - Store port related RLMT trap to trap buffer&n; *&n; * Description:&n; *&t;Nothing further to explain.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueRlmtPortTrap
r_static
r_void
id|QueueRlmtPortTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
comma
multiline_comment|/* Type of RLMT port trap */
r_int
r_int
id|PortIndex
)paren
multiline_comment|/* Index of the port, which changed its state */
(brace
r_char
op_star
id|pBuf
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|pBuf
op_assign
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|TrapId
comma
id|SK_PNMI_TRAP_RLMT_PORT_LEN
)paren
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_RLMT_PORT_INDEX
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|4
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|5
)paren
op_assign
(paren
r_char
)paren
id|PortIndex
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CopyMac - Copies a MAC address&n; *&n; * Description:&n; *&t;Nothing further to explain.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|CopyMac
r_static
r_void
id|CopyMac
c_func
(paren
r_char
op_star
id|pDst
comma
multiline_comment|/* Pointer to destination buffer */
id|SK_MAC_ADDR
op_star
id|pMac
)paren
multiline_comment|/* Pointer of Source */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|pDst
op_plus
id|i
)paren
op_assign
id|pMac-&gt;a
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
eof
