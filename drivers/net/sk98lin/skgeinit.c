multiline_comment|/******************************************************************************&n; *&n; * Name:&t;skgeinit.c&n; * Project:&t;GEnesis, PCI Gigabit Ethernet Adapter&n; * Version:&t;$Revision: 1.57 $&n; * Date:&t;$Date: 2000/08/03 14:55:28 $&n; * Purpose:&t;Contains functions to initialize the GE HW&n; *&n; ******************************************************************************/
multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998-2000 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/******************************************************************************&n; *&n; * History:&n; *&n; *&t;$Log: skgeinit.c,v $&n; *&t;Revision 1.57  2000/08/03 14:55:28  rassmann&n; *&t;Waiting for I2C to be ready before de-initializing adapter&n; *&t;(prevents sensors from hanging up).&n; *&t;&n; *&t;Revision 1.56  2000/07/27 12:16:48  gklug&n; *&t;fix: Stop Port check of the STOP bit does now take 2/18 sec as wanted&n; *&t;&n; *&t;Revision 1.55  1999/11/22 13:32:26  cgoos&n; *&t;Changed license header to GPL.&n; *&t;&n; *&t;Revision 1.54  1999/10/26 07:32:54  malthoff&n; *&t;Initialize PHWLinkUp with SK_FALSE. Required for Diagnostics.&n; *&t;&n; *&t;Revision 1.53  1999/08/12 19:13:50  malthoff&n; *&t;Fix for 1000BT. Do not owerwrite XM_MMU_CMD when&n; *&t;disabling receiver and transmitter. Other bits&n; *&t;may be lost.&n; *&t;&n; *&t;Revision 1.52  1999/07/01 09:29:54  gklug&n; *&t;fix: DoInitRamQueue needs pAC&n; *&t;&n; *&t;Revision 1.51  1999/07/01 08:42:21  gklug&n; *&t;chg: use Store &amp; forward for RAM buffer when Jumbos are used&n; *&t;&n; *&t;Revision 1.50  1999/05/27 13:19:38  cgoos&n; *&t;Added Tx PCI watermark initialization.&n; *&t;Removed Tx RAM queue Store &amp; Forward setting.&n; *&t;&n; *&t;Revision 1.49  1999/05/20 14:32:45  malthoff&n; *&t;SkGeLinkLED() is completly removed now.&n; *&t;&n; *&t;Revision 1.48  1999/05/19 07:28:24  cgoos&n; *&t;SkGeLinkLED no more available for drivers.&n; *&t;Changes for 1000Base-T.&n; *&t;&n; *&t;Revision 1.47  1999/04/08 13:57:45  gklug&n; *&t;add: Init of new port struct fiels PLinkResCt&n; *&t;chg: StopPort Timer check&n; *&t;&n; *&t;Revision 1.46  1999/03/25 07:42:15  malthoff&n; *&t;SkGeStopPort(): Add workaround for cache incoherency.&n; *&t;&t;&t;Create error log entry, disable port, and&n; *&t;&t;&t;exit loop if it does not terminate.&n; *&t;Add XM_RX_LENERR_OK to the default value for the&n; *&t;XMAC receive command register.&n; *&t;&n; *&t;Revision 1.45  1999/03/12 16:24:47  malthoff&n; *&t;Remove PPollRxD and PPollTxD.&n; *&t;Add check for GIPollTimerVal.&n; *&n; *&t;Revision 1.44  1999/03/12 13:40:23  malthoff&n; *&t;Fix: SkGeXmitLED(), SK_LED_TST mode does not work.&n; *&t;Add: Jumbo frame support.&n; *&t;Chg: Resolution of parameter IntTime in SkGeCfgSync().&n; *&n; *&t;Revision 1.43  1999/02/09 10:29:46  malthoff&n; *&t;Bugfix: The previous modification again also for the second location.&n; *&n; *&t;Revision 1.42  1999/02/09 09:35:16  malthoff&n; *&t;Bugfix: The bits &squot;66 MHz Capable&squot; and &squot;NEWCAP are reset while&n; *&t;&t;clearing the error bits in the PCI status register.&n; *&n; *&t;Revision 1.41  1999/01/18 13:07:02  malthoff&n; *&t;Bugfix: Do not use CFG cycles after during Init- or Runtime, because&n; *&t;&t;they may not be available after Boottime.&n; *&n; *&t;Revision 1.40  1999/01/11 12:40:49  malthoff&n; *&t;Bug fix: PCI_STATUS: clearing error bits sets the UDF bit.&n; *&n; *&t;Revision 1.39  1998/12/11 15:17:33  gklug&n; *&t;chg: Init LipaAutoNeg with Unknown&n; *&n; *&t;Revision 1.38  1998/12/10 11:02:57  malthoff&n; *&t;Disable Error Log Message when calling SkGeInit(level 2)&n; *&t;more than once.&n; *&n; *&t;Revision 1.37  1998/12/07 12:18:25  gklug&n; *&t;add: refinement of autosense mode: take into account the autoneg cap of LiPa&n; *&n; *&t;Revision 1.36  1998/12/07 07:10:39  gklug&n; *&t;fix: init values of LinkBroken/ Capabilities for management&n; *&n; *&t;Revision 1.35  1998/12/02 10:56:20  gklug&n; *&t;fix: do NOT init LoinkSync Counter.&n; *&n; *&t;Revision 1.34  1998/12/01 10:53:21  gklug&n; *&t;add: init of additional Counters for workaround&n; *&n; *&t;Revision 1.33  1998/12/01 10:00:49  gklug&n; *&t;add: init PIsave var in Port struct&n; *&n; *&t;Revision 1.32  1998/11/26 14:50:40  gklug&n; *&t;chg: Default is autosensing with AUTOFULL mode&n; *&n; *&t;Revision 1.31  1998/11/25 15:36:16  gklug&n; *&t;fix: do NOT stop LED Timer when port should be stoped&n; *&n; *&t;Revision 1.30  1998/11/24 13:15:28  gklug&n; *&t;add: Init PCkeckPar struct member&n; *&n; *&t;Revision 1.29  1998/11/18 13:19:27  malthoff&n; *&t;Disable packet arbiter timeouts on receive side.&n; *&t;Use maximum timeout value for packet arbiter&n; *&t;transmit timeouts.&n; *&t;Add TestStopBit() function to handle stop RX/TX&n; *&t;problem with active descriptor poll timers.&n; *&t;Bug Fix: Descriptor Poll Timer not started, beacuse&n; *&t;GIPollTimerVal was initilaized with 0.&n; *&n; *&t;Revision 1.28  1998/11/13 14:24:26  malthoff&n; *&t;Bug Fix: SkGeStopPort() may hang if a Packet Arbiter Timout&n; *&t;is pending or occurs while waiting for TX_STOP and RX_STOP.&n; *&t;The PA timeout is cleared now while waiting for TX- or RX_STOP.&n; *&n; *&t;Revision 1.27  1998/11/02 11:04:36  malthoff&n; *&t;fix the last fix&n; *&n; *&t;Revision 1.26  1998/11/02 10:37:03  malthoff&n; *&t;Fix: SkGePollTxD() enables always the synchronounous poll timer.&n; *&n; *&t;Revision 1.25  1998/10/28 07:12:43  cgoos&n; *&t;Fixed &quot;LED_STOP&quot; in SkGeLnkSyncCnt, &quot;== SK_INIT_IO&quot; in SkGeInit.&n; *&t;Removed: Reset of RAM Interface in SkGeStopPort.&n; *&n; *&t;Revision 1.24  1998/10/27 08:13:12  malthoff&n; *&t;Remove temporary code.&n; *&n; *&t;Revision 1.23  1998/10/26 07:45:03  malthoff&n; *&t;Add Address Calculation Workaround: If the EPROM byte&n; *&t;Id is 3, the address offset is 512 kB.&n; *&t;Initialize default values for PLinkMode and PFlowCtrlMode.&n; *&n; *&t;Revision 1.22  1998/10/22 09:46:47  gklug&n; *&t;fix SysKonnectFileId typo&n; *&n; *&t;Revision 1.21  1998/10/20 12:11:56  malthoff&n; *&t;Don&squot;t dendy the Queue config if the size of the unused&n; *&t;rx qeueu is zero.&n; *&n; *&t;Revision 1.20  1998/10/19 07:27:58  malthoff&n; *&t;SkGeInitRamIface() is public to be called by diagnostics.&n; *&n; *&t;Revision 1.19  1998/10/16 13:33:45  malthoff&n; *&t;Fix: enabling descriptor polling is not allowed until&n; *&t;the descriptor addresses are set. Descriptor polling&n; *&t;must be handled by the driver.&n; *&n; *&t;Revision 1.18  1998/10/16 10:58:27  malthoff&n; *&t;Remove temp. code for Diag prototype.&n; *&t;Remove lint warning for dummy reads.&n; *&t;Call SkGeLoadLnkSyncCnt() during SkGeInitPort().&n; *&n; *&t;Revision 1.17  1998/10/14 09:16:06  malthoff&n; *&t;Change parameter LimCount and programming of&n; *&t;the limit counter in SkGeCfgSync().&n; *&n; *&t;Revision 1.16  1998/10/13 09:21:16  malthoff&n; *&t;Don&squot;t set XM_RX_SELF_RX in RxCmd Reg, because it&squot;s&n; *&t;like a Loopback Mode in half duplex.&n; *&n; *&t;Revision 1.15  1998/10/09 06:47:40  malthoff&n; *&t;SkGeInitMacArb(): set recovery counters init value&n; *&t;to zero although this counters are not uesd.&n; *&t;Bug fix in Rx Upper/Lower Pause Threshold calculation.&n; *&t;Add XM_RX_SELF_RX to RxCmd.&n; *&n; *&t;Revision 1.14  1998/10/06 15:15:53  malthoff&n; *&t;Make sure no pending IRQ is cleared in SkGeLoadLnkSyncCnt().&n; *&n; *&t;Revision 1.13  1998/10/06 14:09:36  malthoff&n; *&t;Add SkGeLoadLnkSyncCnt(). Modify&n; *&t;the &squot;port stopped&squot; condition according&n; *&t;to the current problem report.&n; *&n; *&t;Revision 1.12  1998/10/05 08:17:21  malthoff&n; *&t;Add functions: SkGePollRxD(), SkGePollTxD(),&n; *&t;DoCalcAddr(), SkGeCheckQSize(),&n; *&t;DoInitRamQueue(), and SkGeCfgSync().&n; *&t;Add coding for SkGeInitMacArb(), SkGeInitPktArb(),&n; *&t;SkGeInitMacFifo(), SkGeInitRamBufs(),&n; *&t;SkGeInitRamIface(), and SkGeInitBmu().&n; *&n; *&t;Revision 1.11  1998/09/29 08:26:29  malthoff&n; *&t;bug fix: SkGeInit0() &squot;i&squot; should be increment.&n; *&n; *&t;Revision 1.10  1998/09/28 13:19:01  malthoff&n; *&t;Coding time: Save the done work.&n; *&t;Modify SkGeLinkLED(), add SkGeXmitLED(),&n; *&t;define SkGeCheckQSize(), SkGeInitMacArb(),&n; *&t;SkGeInitPktArb(), SkGeInitMacFifo(),&n; *&t;SkGeInitRamBufs(), SkGeInitRamIface(),&n; *&t;and SkGeInitBmu(). Do coding for SkGeStopPort(),&n; *&t;SkGeInit1(), SkGeInit2(), and SkGeInit3().&n; *&t;Do coding for SkGeDinit() and SkGeInitPort().&n; *&n; *&t;Revision 1.9  1998/09/16 14:29:05  malthoff&n; *&t;Some minor changes.&n; *&n; *&t;Revision 1.8  1998/09/11 05:29:14  gklug&n; *&t;add: init state of a port&n; *&n; *&t;Revision 1.7  1998/09/04 09:26:25  malthoff&n; *&t;Short temporary modification.&n; *&n; *&t;Revision 1.6  1998/09/04 08:27:59  malthoff&n; *&t;Remark the do-while in StopPort() because it never ends&n; *&t;without a GE adapter.&n; *&n; *&t;Revision 1.5  1998/09/03 14:05:45  malthoff&n; *&t;Change comment for SkGeInitPort(). Do not&n; *&t;repair the queue sizes if invalid.&n; *&n; *&t;Revision 1.4  1998/09/03 10:03:19  malthoff&n; *&t;Implement the new interface according to the&n; *&t;reviewed interface specification.&n; *&n; *&t;Revision 1.3  1998/08/19 09:11:25  gklug&n; *&t;fix: struct are removed from c-source (see CCC)&n; *&n; *&t;Revision 1.2  1998/07/28 12:33:58  malthoff&n; *&t;Add &squot;IoC&squot; parameter in function declaration and SK IO macros.&n; *&n; *&t;Revision 1.1  1998/07/23 09:48:57  malthoff&n; *&t;Creation. First dummy &squot;C&squot; file.&n; *&t;SkGeInit(Level 0) is card_start for ML.&n; *&t;SkGeDeInit() is card_stop for ML.&n; *&n; *&n; ******************************************************************************/
macro_line|#include &quot;h/skdrv1st.h&quot;
macro_line|#include &quot;h/xmac_ii.h&quot;
macro_line|#include &quot;h/skdrv2nd.h&quot;
multiline_comment|/* defines ********************************************************************/
multiline_comment|/* defines for SkGeXmitLed() */
DECL|macro|XMIT_LED_INI
mdefine_line|#define XMIT_LED_INI&t;0
DECL|macro|XMIT_LED_CNT
mdefine_line|#define XMIT_LED_CNT&t;(RX_LED_VAL - RX_LED_INI)
DECL|macro|XMIT_LED_CTRL
mdefine_line|#define XMIT_LED_CTRL&t;(RX_LED_CTRL- RX_LED_INI)
DECL|macro|XMIT_LED_TST
mdefine_line|#define XMIT_LED_TST&t;(RX_LED_TST - RX_LED_INI)
multiline_comment|/* Queue Size units */
DECL|macro|QZ_UNITS
mdefine_line|#define QZ_UNITS&t;0x7
multiline_comment|/* Types of RAM Buffer Queues */
DECL|macro|SK_RX_SRAM_Q
mdefine_line|#define SK_RX_SRAM_Q&t;1&t;/* small receive queue */
DECL|macro|SK_RX_BRAM_Q
mdefine_line|#define SK_RX_BRAM_Q&t;2&t;/* big receive queue */
DECL|macro|SK_TX_RAM_Q
mdefine_line|#define SK_TX_RAM_Q&t;3&t;/* small or big transmit queue */
multiline_comment|/* typedefs *******************************************************************/
multiline_comment|/* global variables ***********************************************************/
multiline_comment|/* local variables ************************************************************/
DECL|variable|SysKonnectFileId
r_static
r_const
r_char
id|SysKonnectFileId
(braket
)braket
op_assign
l_string|&quot;@(#)$Id: skgeinit.c,v 1.57 2000/08/03 14:55:28 rassmann Exp $ (C) SK &quot;
suffix:semicolon
DECL|struct|s_QOffTab
r_struct
id|s_QOffTab
(brace
DECL|member|RxQOff
r_int
id|RxQOff
suffix:semicolon
multiline_comment|/* Receive Queue Address Offset */
DECL|member|XsQOff
r_int
id|XsQOff
suffix:semicolon
multiline_comment|/* Sync Tx Queue Address Offset */
DECL|member|XaQOff
r_int
id|XaQOff
suffix:semicolon
multiline_comment|/* Async Tx Queue Address Offset */
)brace
suffix:semicolon
DECL|variable|QOffTab
r_static
r_struct
id|s_QOffTab
id|QOffTab
(braket
)braket
op_assign
(brace
(brace
id|Q_R1
comma
id|Q_XS1
comma
id|Q_XA1
)brace
comma
(brace
id|Q_R2
comma
id|Q_XS2
comma
id|Q_XA2
)brace
)brace
suffix:semicolon
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGePollRxD() - Enable/Disable Descriptor Polling of RxD Ring&n; *&n; * Description:&n; *&t;Enable or disable the descriptor polling the receive descriptor&n; *&t;ring (RxD) of port &squot;port&squot;.&n; *&t;The new configuration is *not* saved over any SkGeStopPort() and&n; *&t;SkGeInitPort() calls.&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGePollRxD
r_void
id|SkGePollRxD
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
comma
multiline_comment|/* Port Index (MAC_1 + n) */
id|SK_BOOL
id|PollRxD
)paren
multiline_comment|/* SK_TRUE (enable pol.), SK_FALSE (disable pol.) */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PollRxD
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|Q_CSR
)paren
comma
id|CSR_ENA_POL
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|Q_CSR
)paren
comma
id|CSR_DIS_POL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SkGePollRxD */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGePollTxD() - Enable/Disable Descriptor Polling of TxD Rings&n; *&n; * Description:&n; *&t;Enable or disable the descriptor polling the transmit descriptor&n; *&t;ring(s) (RxD) of port &squot;port&squot;.&n; *&t;The new configuration is *not* saved over any SkGeStopPort() and&n; *&t;SkGeInitPort() calls.&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGePollTxD
r_void
id|SkGePollTxD
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
comma
multiline_comment|/* Port Index (MAC_1 + n) */
id|SK_BOOL
id|PollTxD
)paren
multiline_comment|/* SK_TRUE (enable pol.), SK_FALSE (disable pol.) */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_U32
id|DWord
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PollTxD
)paren
(brace
id|DWord
op_assign
id|CSR_ENA_POL
suffix:semicolon
)brace
r_else
(brace
id|DWord
op_assign
id|CSR_DIS_POL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pPrt-&gt;PXSQSize
op_ne
l_int|0
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|Q_CSR
)paren
comma
id|DWord
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pPrt-&gt;PXAQSize
op_ne
l_int|0
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|Q_CSR
)paren
comma
id|DWord
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SkGePollTxD */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeYellowLED() - Switch the yellow LED on or off.&n; *&n; * Description:&n; *&t;Switch the yellow LED on or off.&n; *&n; * Note:&n; *&t;This function may be called any time after SkGeInit(Level 1).&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeYellowLED
r_void
id|SkGeYellowLED
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|State
)paren
multiline_comment|/* yellow LED state, 0 = OFF, 0 != ON */
(brace
r_if
c_cond
(paren
id|State
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Switch yellow LED OFF */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B0_LED
comma
id|LED_STAT_OFF
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Switch yellow LED ON */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B0_LED
comma
id|LED_STAT_ON
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SkGeYellowLED */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeXmitLED() - Modify the Operational Mode of a transmission LED.&n; *&n; * Description:&n; *&t;The Rx or Tx LED which is specified by &squot;Led&squot; will be&n; *&t;enabled, disabled or switched on in test mode.&n; *&n; * Note:&n; *&t;&squot;Led&squot; must contain the address offset of the LEDs INI register.&n; *&n; * Usage:&n; *&t;SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_ENA);&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeXmitLED
r_void
id|SkGeXmitLED
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Led
comma
multiline_comment|/* offset to the LED Init Value register */
r_int
id|Mode
)paren
multiline_comment|/* Mode may be SK_LED_DIS, SK_LED_ENA, SK_LED_TST */
(brace
id|SK_U32
id|LedIni
suffix:semicolon
r_switch
c_cond
(paren
id|Mode
)paren
(brace
r_case
id|SK_LED_ENA
suffix:colon
id|LedIni
op_assign
id|SK_XMIT_DUR
op_star
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIHstClkFact
op_div
l_int|100
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_INI
comma
id|LedIni
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_CTRL
comma
id|LED_START
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_LED_TST
suffix:colon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_TST
comma
id|LED_T_ON
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_CNT
comma
l_int|100
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_CTRL
comma
id|LED_START
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_LED_DIS
suffix:colon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t; * Do NOT stop the LED Timer here. The LED might be&n;&t;&t; * in on state. But it needs to go off.&n;&t;&t; */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_CNT
comma
l_int|0
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|Led
op_plus
id|XMIT_LED_TST
comma
id|LED_T_OFF
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * 1000BT: The Transmit LED is driven by the PHY.&n;&t; * But the default LED configuration is used for&n;&t; * Level One and Broadcom PHYs.&n;&t; * (Broadcom: It may be that PHY_B_PEC_EN_LTR has to be set.)&n;&t; * (In this case it has to be added here. But we will see. XXX)&n;&t; */
)brace
multiline_comment|/* SkGeXmitLED */
multiline_comment|/******************************************************************************&n; *&n; *&t;DoCalcAddr() - Calculates the start and the end address of a queue.&n; *&n; * Description:&n; *&t;This function calculates the start- end the end address&n; *&t;of a queue. Afterwards the &squot;StartVal&squot; is incremented to the&n; *&t;next start position.&n; *&t;If the port is already initialized the calculated values&n; *&t;will be checked against the configured values and an&n; *&t;error will be returned, if they are not equal.&n; *&t;If the port is not initialized the values will be written to&n; *&t;*StartAdr and *EndAddr.&n; *&n; * Returns:&n; *&t;0:&t;success&n; *&t;1:&t;configuration error&n; */
DECL|function|DoCalcAddr
r_static
r_int
id|DoCalcAddr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_GEPORT
op_star
id|pPrt
comma
multiline_comment|/* port index */
r_int
id|QuSize
comma
multiline_comment|/* size of the queue to configure in kB */
id|SK_U32
op_star
id|StartVal
comma
multiline_comment|/* start value for address calculation */
id|SK_U32
op_star
id|QuStartAddr
comma
multiline_comment|/* start addr to calculate */
id|SK_U32
op_star
id|QuEndAddr
)paren
multiline_comment|/* end address to calculate */
(brace
id|SK_U32
id|EndVal
suffix:semicolon
id|SK_U32
id|NextStart
suffix:semicolon
r_int
id|Rtv
suffix:semicolon
id|Rtv
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|QuSize
op_eq
l_int|0
)paren
(brace
id|EndVal
op_assign
op_star
id|StartVal
suffix:semicolon
id|NextStart
op_assign
id|EndVal
suffix:semicolon
)brace
r_else
(brace
id|EndVal
op_assign
op_star
id|StartVal
op_plus
(paren
(paren
id|SK_U32
)paren
id|QuSize
op_star
l_int|1024
)paren
op_minus
l_int|1
suffix:semicolon
id|NextStart
op_assign
id|EndVal
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pPrt-&gt;PState
op_ge
id|SK_PRT_INIT
)paren
(brace
r_if
c_cond
(paren
op_star
id|StartVal
op_ne
op_star
id|QuStartAddr
op_logical_or
id|EndVal
op_ne
op_star
id|QuEndAddr
)paren
(brace
id|Rtv
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|QuStartAddr
op_assign
op_star
id|StartVal
suffix:semicolon
op_star
id|QuEndAddr
op_assign
id|EndVal
suffix:semicolon
)brace
op_star
id|StartVal
op_assign
id|NextStart
suffix:semicolon
r_return
(paren
id|Rtv
)paren
suffix:semicolon
)brace
multiline_comment|/* DoCalcAddr */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeCheckQSize() - Checks the Adapters Queue Size Configuration&n; *&n; * Description:&n; *&t;This function verifies the Queue Size Configuration specified&n; *&t;in the variabels PRxQSize, PXSQSize, and PXAQSize of all&n; *&t;used ports.&n; *&t;This requirements must be fullfilled to have a valid configuration:&n; *&t;&t;- The size of all queues must not exceed GIRamSize.&n; *&t;&t;- The queue sizes must be specified in units of 8 kB.&n; *&t;&t;- The size of rx queues of available ports must not be&n; *&t;&t;  smaller than 16kB.&n; *&t;&t;- The RAM start and end addresses must not be changed&n; *&t;&t;  for ports which are already initialized.&n; *&t;Furthermore SkGeCheckQSize() defines the Start and End&n; *&t;Addresses of all ports and stores them into the HWAC port&n; *&t;structure.&n; *&n; * Returns:&n; *&t;0:&t;Queue Size Configuration valid&n; *&t;1:&t;Queue Size Configuration invalid&n; */
DECL|function|SkGeCheckQSize
r_static
r_int
id|SkGeCheckQSize
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
r_int
id|Port
)paren
multiline_comment|/* port index */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
r_int
id|UsedMem
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|Rtv
suffix:semicolon
r_int
id|Rtv2
suffix:semicolon
id|SK_U32
id|StartAddr
suffix:semicolon
id|UsedMem
op_assign
l_int|0
suffix:semicolon
id|Rtv
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pPrt-&gt;PRxQSize
op_amp
id|QZ_UNITS
)paren
op_logical_or
(paren
id|pPrt-&gt;PXSQSize
op_amp
id|QZ_UNITS
)paren
op_logical_or
(paren
id|pPrt-&gt;PXAQSize
op_amp
id|QZ_UNITS
)paren
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E012
comma
id|SKERR_HWI_E012MSG
)paren
suffix:semicolon
id|Rtv
op_assign
l_int|1
suffix:semicolon
r_goto
id|CheckQSizeEnd
suffix:semicolon
)brace
id|UsedMem
op_add_assign
id|pPrt-&gt;PRxQSize
op_plus
id|pPrt-&gt;PXSQSize
op_plus
id|pPrt-&gt;PXAQSize
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|Port
op_logical_and
id|pPrt-&gt;PRxQSize
OL
id|SK_MIN_RXQ_SIZE
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E011
comma
id|SKERR_HWI_E011MSG
)paren
suffix:semicolon
id|Rtv
op_assign
l_int|1
suffix:semicolon
r_goto
id|CheckQSizeEnd
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|UsedMem
OG
id|pAC-&gt;GIni.GIRamSize
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E012
comma
id|SKERR_HWI_E012MSG
)paren
suffix:semicolon
id|Rtv
op_assign
l_int|1
suffix:semicolon
r_goto
id|CheckQSizeEnd
suffix:semicolon
)brace
multiline_comment|/* Now start address calculation */
id|StartAddr
op_assign
id|pAC-&gt;GIni.GIRamOffs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Calculate/Check values for the receive queue */
id|Rtv2
op_assign
id|DoCalcAddr
c_func
(paren
id|pAC
comma
id|pPrt
comma
id|pPrt-&gt;PRxQSize
comma
op_amp
id|StartAddr
comma
op_amp
id|pPrt-&gt;PRxQRamStart
comma
op_amp
id|pPrt-&gt;PRxQRamEnd
)paren
suffix:semicolon
id|Rtv
op_or_assign
id|Rtv2
suffix:semicolon
multiline_comment|/* Calculate/Check values for the synchronous tx queue */
id|Rtv2
op_assign
id|DoCalcAddr
c_func
(paren
id|pAC
comma
id|pPrt
comma
id|pPrt-&gt;PXSQSize
comma
op_amp
id|StartAddr
comma
op_amp
id|pPrt-&gt;PXsQRamStart
comma
op_amp
id|pPrt-&gt;PXsQRamEnd
)paren
suffix:semicolon
id|Rtv
op_or_assign
id|Rtv2
suffix:semicolon
multiline_comment|/* Calculate/Check values for the asynchronous tx queue */
id|Rtv2
op_assign
id|DoCalcAddr
c_func
(paren
id|pAC
comma
id|pPrt
comma
id|pPrt-&gt;PXAQSize
comma
op_amp
id|StartAddr
comma
op_amp
id|pPrt-&gt;PXaQRamStart
comma
op_amp
id|pPrt-&gt;PXaQRamEnd
)paren
suffix:semicolon
id|Rtv
op_or_assign
id|Rtv2
suffix:semicolon
r_if
c_cond
(paren
id|Rtv
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E013
comma
id|SKERR_HWI_E013MSG
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|CheckQSizeEnd
suffix:colon
r_return
(paren
id|Rtv
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeCheckQSize */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitMacArb() - Initialize the MAC Arbiter&n; *&n; * Description:&n; *&t;This function initializes the MAC Arbiter.&n; *&t;It must not be called if there is still an&n; *&t;initilaized or active port.&n; *&n; * Returns:&n; *&t;nothing:&n; */
DECL|function|SkGeInitMacArb
r_static
r_void
id|SkGeInitMacArb
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
multiline_comment|/* release local reset */
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_MA_TO_CTRL
comma
id|MA_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* configure timeout values */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_TOINI_RX1
comma
id|SK_MAC_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_TOINI_RX2
comma
id|SK_MAC_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_TOINI_TX1
comma
id|SK_MAC_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_TOINI_TX2
comma
id|SK_MAC_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_RCINI_RX1
comma
l_int|0
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_RCINI_RX2
comma
l_int|0
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_RCINI_TX1
comma
l_int|0
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_MA_RCINI_TX2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* recovery values are needed for XMAC II Rev. B2 only */
multiline_comment|/* Fast Output Enable Mode was intended to use with Rev. B2, but now? */
multiline_comment|/*&n;&t; * There is not start or enable buttom to push, therefore&n;&t; * the MAC arbiter is configured and enabled now.&n;&t; */
)brace
multiline_comment|/* SkGeInitMacArb */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitPktArb() - Initialize the Packet Arbiter&n; *&n; * Description:&n; *&t;This function initializes the Packet Arbiter.&n; *&t;It must not be called if there is still an&n; *&t;initilaized or active port.&n; *&n; * Returns:&n; *&t;nothing:&n; */
DECL|function|SkGeInitPktArb
r_static
r_void
id|SkGeInitPktArb
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
multiline_comment|/* release local reset */
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_CTRL
comma
id|PA_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* configure timeout values */
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_TOINI_RX1
comma
id|SK_PKT_TO_MAX
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_TOINI_RX2
comma
id|SK_PKT_TO_MAX
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_TOINI_TX1
comma
id|SK_PKT_TO_MAX
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_TOINI_TX2
comma
id|SK_PKT_TO_MAX
)paren
suffix:semicolon
multiline_comment|/* enable timeout timers if jumbo frames not used */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIPortUsage
op_ne
id|SK_JUMBO_LINK
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
op_eq
l_int|1
)paren
(brace
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_CTRL
comma
id|PA_ENA_TO_TX1
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_CTRL
comma
(paren
id|PA_ENA_TO_TX1
op_or
id|PA_ENA_TO_TX2
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* SkGeInitPktArb */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitMacFifo() - Initialize the MAC FIFOs&n; *&n; * Description:&n; *&t;Initialize all MAC FIFOs of the specified port&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeInitMacFifo
r_static
r_void
id|SkGeInitMacFifo
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
)paren
multiline_comment|/* Port Index (MAC_1 + n) */
(brace
multiline_comment|/*&n;&t; * For each FIFO:&n;&t; *&t;- release local reset&n;&t; *&t;- use default value for MAC FIFO size&n;&t; *&t;- setup defaults for the control register&n;&t; *&t;- enable the FIFO&n;&t; */
multiline_comment|/* Configure RX MAC FIFO */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_MFF_CTRL2
)paren
comma
id|MFF_RST_CLR
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_MFF_CTRL1
)paren
comma
id|MFF_RX_CTRL_DEF
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_MFF_CTRL2
)paren
comma
id|MFF_ENA_OP_MD
)paren
suffix:semicolon
multiline_comment|/* Configure TX MAC FIFO */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TX_MFF_CTRL2
)paren
comma
id|MFF_RST_CLR
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TX_MFF_CTRL1
)paren
comma
id|MFF_TX_CTRL_DEF
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TX_MFF_CTRL2
)paren
comma
id|MFF_ENA_OP_MD
)paren
suffix:semicolon
multiline_comment|/* Enable frame flushing if jumbo frames used */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIPortUsage
op_eq
id|SK_JUMBO_LINK
)paren
(brace
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_MFF_CTRL1
)paren
comma
id|MFF_ENA_FLUSH
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SkGeInitMacFifo */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeLoadLnkSyncCnt() - Load the Link Sync Counter and starts counting&n; *&n; * Description:&n; *&t;This function starts the Link Sync Counter of the specified&n; *&t;port and enables the generation of an Link Sync IRQ.&n; *&t;The Link Sync Counter may be used to detect an active link,&n; *&t;if autonegotiation is not used.&n; *&n; * Note:&n; *&t;o To ensure receiving the Link Sync Event the LinkSyncCounter&n; *&t;  should be initialized BEFORE clearing the XMACs reset!&n; *&t;o Enable IS_LNK_SYNC_M1 and IS_LNK_SYNC_M2 after calling this&n; *&t;  function.&n; *&n; * Retruns:&n; *&t;nothing&n; */
DECL|function|SkGeLoadLnkSyncCnt
r_void
id|SkGeLoadLnkSyncCnt
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
comma
multiline_comment|/* Port Index (MAC_1 + n) */
id|SK_U32
id|CntVal
)paren
multiline_comment|/* Counter value */
(brace
id|SK_U32
id|OrgIMsk
suffix:semicolon
id|SK_U32
id|NewIMsk
suffix:semicolon
id|SK_U32
id|ISrc
suffix:semicolon
id|SK_BOOL
id|IrqPend
suffix:semicolon
multiline_comment|/* stop counter */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|LNK_SYNC_CTRL
)paren
comma
id|LED_STOP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ASIC problem:&n;&t; * Each time starting the Link Sync Counter an IRQ is generated&n;&t; * by the adapter. See problem report entry from 21.07.98&n;&t; *&n;&t; * Workaround:&t;Disable Link Sync IRQ and clear the unexpeced IRQ&n;&t; *&t;&t;if no IRQ is already pending.&n;&t; */
id|IrqPend
op_assign
id|SK_FALSE
suffix:semicolon
id|SK_IN32
c_func
(paren
id|IoC
comma
id|B0_ISRC
comma
op_amp
id|ISrc
)paren
suffix:semicolon
id|SK_IN32
c_func
(paren
id|IoC
comma
id|B0_IMSK
comma
op_amp
id|OrgIMsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Port
op_eq
id|MAC_1
)paren
(brace
id|NewIMsk
op_assign
id|OrgIMsk
op_amp
op_complement
id|IS_LNK_SYNC_M1
suffix:semicolon
r_if
c_cond
(paren
id|ISrc
op_amp
id|IS_LNK_SYNC_M1
)paren
(brace
id|IrqPend
op_assign
id|SK_TRUE
suffix:semicolon
)brace
)brace
r_else
(brace
id|NewIMsk
op_assign
id|OrgIMsk
op_amp
op_complement
id|IS_LNK_SYNC_M2
suffix:semicolon
r_if
c_cond
(paren
id|ISrc
op_amp
id|IS_LNK_SYNC_M2
)paren
(brace
id|IrqPend
op_assign
id|SK_TRUE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|IrqPend
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B0_IMSK
comma
id|NewIMsk
)paren
suffix:semicolon
)brace
multiline_comment|/* load counter */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|LNK_SYNC_INI
)paren
comma
id|CntVal
)paren
suffix:semicolon
multiline_comment|/* start counter */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|LNK_SYNC_CTRL
)paren
comma
id|LED_START
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IrqPend
)paren
(brace
multiline_comment|/* clear the unexpected IRQ, and restore the interrupt mask */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|LNK_SYNC_CTRL
)paren
comma
id|LED_CLR_IRQ
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B0_IMSK
comma
id|OrgIMsk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SkGeLoadLnkSyncCnt*/
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeCfgSync() - Configure synchronous bandwidth for this port.&n; *&n; * Description:&n; *&t;This function may be used to configure synchronous bandwidth&n; *&t;to the specified port. This may be done any time after&n; *&t;initializing the port. The configuration values are NOT saved&n; *&t;in the HWAC port structure and will be overwritten any&n; *&t;time when stopping and starting the port.&n; *&t;Any values for the synchronous configuration will be ignored&n; *&t;if the size of the synchronous queue is zero!&n; *&n; *&t;The default configuration for the synchronous service is&n; *&t;TXA_ENA_FSYNC. This means if the size of&n; *&t;the synchronous queue is unequal zero but no specific&n; *&t;synchronous bandwidth is configured, the synchronous queue&n; *&t;will always have the &squot;unlimitted&squot; transmit priority!&n; *&n; *&t;This mode will be restored if the synchronous bandwidth is&n; *&t;deallocated (&squot;IntTime&squot; = 0 and &squot;LimCount&squot; = 0).&n; *&n; * Returns:&n; *&t;0:&t;success&n; *&t;1:&t;paramter configuration error&n; *&t;2:&t;try to configure quality of service although no&n; *&t;&t;synchronous queue is configured&n; */
DECL|function|SkGeCfgSync
r_int
id|SkGeCfgSync
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
comma
multiline_comment|/* Port Index (MAC_1 + n) */
id|SK_U32
id|IntTime
comma
multiline_comment|/* Interval Timer Value in units of 8ns */
id|SK_U32
id|LimCount
comma
multiline_comment|/* Number of bytes to transfer during IntTime */
r_int
id|SyncMode
)paren
multiline_comment|/* Sync Mode: TXA_ENA_ALLOC | TXA_DIS_ALLOC | 0 */
(brace
r_int
id|Rtv
suffix:semicolon
id|Rtv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check the parameters */
r_if
c_cond
(paren
id|LimCount
OG
id|IntTime
op_logical_or
(paren
id|LimCount
op_eq
l_int|0
op_logical_and
id|IntTime
op_ne
l_int|0
)paren
op_logical_or
(paren
id|LimCount
op_ne
l_int|0
op_logical_and
id|IntTime
op_eq
l_int|0
)paren
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E010
comma
id|SKERR_HWI_E010MSG
)paren
suffix:semicolon
id|Rtv
op_assign
l_int|1
suffix:semicolon
r_goto
id|CfgSyncEnd
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
dot
id|PXSQSize
op_ne
l_int|0
)paren
(brace
multiline_comment|/* calculate register values */
id|IntTime
op_assign
(paren
id|IntTime
op_div
l_int|2
)paren
op_star
id|pAC-&gt;GIni.GIHstClkFact
op_div
l_int|100
suffix:semicolon
id|LimCount
op_assign
id|LimCount
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|IntTime
OG
id|TXA_MAX_VAL
op_logical_or
id|LimCount
OG
id|TXA_MAX_VAL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E010
comma
id|SKERR_HWI_E010MSG
)paren
suffix:semicolon
id|Rtv
op_assign
l_int|1
suffix:semicolon
r_goto
id|CfgSyncEnd
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * - Enable &squot;Force Sync&squot; to ensure the synchronous queue&n;&t;&t; *   has the priority while configuring the new values.&n;&t;&t; * - Also &squot;disable alloc&squot; to ensure the settings complies&n;&t;&t; *   to the SyncMode parameter.&n;&t;&t; * - Disable &squot;Rate Control&squot; to configure the new values.&n;&t;&t; * - write IntTime and Limcount&n;&t;&t; * - start &squot;Rate Control&squot; and disable &squot;Force Sync&squot;&n;&t;&t; *   if Interval Timer or Limit Counter not zero.&n;&t;&t; */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_CTRL
)paren
comma
id|TXA_ENA_FSYNC
op_or
id|TXA_DIS_ALLOC
op_or
id|TXA_STOP_RC
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_ITI_INI
)paren
comma
id|IntTime
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_LIM_INI
)paren
comma
id|LimCount
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_CTRL
)paren
comma
(paren
id|SyncMode
op_amp
(paren
id|TXA_ENA_ALLOC
op_or
id|TXA_DIS_ALLOC
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IntTime
op_ne
l_int|0
op_logical_or
id|LimCount
op_ne
l_int|0
)paren
(brace
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_CTRL
)paren
comma
id|TXA_DIS_FSYNC
op_or
id|TXA_START_RC
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E009
comma
id|SKERR_HWI_E009MSG
)paren
suffix:semicolon
id|Rtv
op_assign
l_int|2
suffix:semicolon
)brace
id|CfgSyncEnd
suffix:colon
r_return
(paren
id|Rtv
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeCfgSync */
multiline_comment|/******************************************************************************&n; *&n; *&t;DoInitRamQueue() - Initilaize the RAM Buffer Address of a single Queue&n; *&n; * Desccription:&n; *&t;If the queue is used, enable and initilaize it.&n; *&t;Make sure the queue is still reset, if it is not used.&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|DoInitRamQueue
r_static
r_void
id|DoInitRamQueue
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|QuIoOffs
comma
multiline_comment|/* Queue IO Address Offset */
id|SK_U32
id|QuStartAddr
comma
multiline_comment|/* Queue Start Address */
id|SK_U32
id|QuEndAddr
comma
multiline_comment|/* Queue End Address */
r_int
id|QuType
)paren
multiline_comment|/* Queue Type (SK_RX_SRAM_Q|SK_RX_BRAM_Q|SK_TX_RAM_Q) */
(brace
id|SK_U32
id|RxUpThresVal
suffix:semicolon
id|SK_U32
id|RxLoThresVal
suffix:semicolon
r_if
c_cond
(paren
id|QuStartAddr
op_ne
id|QuEndAddr
)paren
(brace
multiline_comment|/* calculate thresholds, assume we have a big Rx queue */
id|RxUpThresVal
op_assign
(paren
id|QuEndAddr
op_plus
l_int|1
op_minus
id|QuStartAddr
op_minus
id|SK_RB_ULPP
)paren
op_div
l_int|8
suffix:semicolon
id|RxLoThresVal
op_assign
(paren
id|QuEndAddr
op_plus
l_int|1
op_minus
id|QuStartAddr
op_minus
id|SK_RB_LLPP_B
)paren
op_div
l_int|8
suffix:semicolon
multiline_comment|/* build HW address format */
id|QuStartAddr
op_assign
id|QuStartAddr
op_div
l_int|8
suffix:semicolon
id|QuEndAddr
op_assign
id|QuEndAddr
op_div
l_int|8
suffix:semicolon
multiline_comment|/* release local reset */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_CTRL
)paren
comma
id|RB_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* configure addresses */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_START
)paren
comma
id|QuStartAddr
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_END
)paren
comma
id|QuEndAddr
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_WP
)paren
comma
id|QuStartAddr
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_RP
)paren
comma
id|QuStartAddr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|QuType
)paren
(brace
r_case
id|SK_RX_SRAM_Q
suffix:colon
multiline_comment|/* configure threshold for small Rx Queue */
id|RxLoThresVal
op_add_assign
(paren
id|SK_RB_LLPP_B
op_minus
id|SK_RB_LLPP_S
)paren
op_div
l_int|8
suffix:semicolon
multiline_comment|/* continue with SK_RX_BRAM_Q */
r_case
id|SK_RX_BRAM_Q
suffix:colon
multiline_comment|/* write threshold for Rx Queue */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_RX_UTPP
)paren
comma
id|RxUpThresVal
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_RX_LTPP
)paren
comma
id|RxLoThresVal
)paren
suffix:semicolon
multiline_comment|/* the high priority threshold not used */
r_break
suffix:semicolon
r_case
id|SK_TX_RAM_Q
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Do NOT use Store and forward under normal&n;&t;&t;&t; * operation due to performance optimization.&n;&t;&t;&t; * But if Jumbo frames are configured we NEED&n;&t;&t;&t; * the store and forward of the RAM buffer.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIPortUsage
op_eq
id|SK_JUMBO_LINK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * enable Store &amp; Forward Mode for the&n;&t;&t;&t;&t; * Tx Side&n;&t;&t;&t;&t; */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_CTRL
)paren
comma
id|RB_ENA_STFWD
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* set queue operational */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_CTRL
)paren
comma
id|RB_ENA_OP_MD
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ensure the queue is still disabled */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|QuIoOffs
comma
id|RB_CTRL
)paren
comma
id|RB_RST_SET
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* DoInitRamQueue*/
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitRamBufs() - Initialize the RAM Buffer Queues&n; *&n; * Description:&n; *&t;Initialize all RAM Buffer Queues of the specified port&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeInitRamBufs
r_static
r_void
id|SkGeInitRamBufs
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
)paren
multiline_comment|/* Port Index (MAC_1 + n) */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
r_int
id|RxQType
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pPrt-&gt;PRxQSize
op_eq
id|SK_MIN_RXQ_SIZE
)paren
(brace
id|RxQType
op_assign
id|SK_RX_SRAM_Q
suffix:semicolon
multiline_comment|/* small Rx Queue */
)brace
r_else
(brace
id|RxQType
op_assign
id|SK_RX_BRAM_Q
suffix:semicolon
multiline_comment|/* big Rx Queue */
)brace
id|DoInitRamQueue
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pPrt-&gt;PRxQOff
comma
id|pPrt-&gt;PRxQRamStart
comma
id|pPrt-&gt;PRxQRamEnd
comma
id|RxQType
)paren
suffix:semicolon
id|DoInitRamQueue
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pPrt-&gt;PXsQOff
comma
id|pPrt-&gt;PXsQRamStart
comma
id|pPrt-&gt;PXsQRamEnd
comma
id|SK_TX_RAM_Q
)paren
suffix:semicolon
id|DoInitRamQueue
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pPrt-&gt;PXaQOff
comma
id|pPrt-&gt;PXaQRamStart
comma
id|pPrt-&gt;PXaQRamEnd
comma
id|SK_TX_RAM_Q
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeInitRamBufs */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitRamIface() - Initialize the RAM Interface&n; *&n; * Description:&n; *&t;This function initializes the Adapbers RAM Interface.&n; *&n; * Note:&n; *&t;This function is used in the diagnostics.&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeInitRamIface
r_void
id|SkGeInitRamIface
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
multiline_comment|/* release local reset */
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_RI_CTRL
comma
id|RI_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* configure timeout values */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_WTO_R1
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_WTO_XA1
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_WTO_XS1
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_RTO_R1
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_RTO_XA1
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_RTO_XS1
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_WTO_R2
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_WTO_XA2
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_WTO_XS2
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_RTO_R2
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_RTO_XA2
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B3_RI_RTO_XS2
comma
id|SK_RI_TO_53
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeInitRamIface */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitBmu() - Initialize the BMU state machines&n; *&n; * Description:&n; *&t;Initialize all BMU state machines of the specified port&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeInitBmu
r_static
r_void
id|SkGeInitBmu
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
)paren
multiline_comment|/* Port Index (MAC_1 + n) */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
suffix:semicolon
multiline_comment|/* Rx Queue: Release all local resets and set the watermark */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|Q_CSR
)paren
comma
id|CSR_CLR_RESET
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|Q_F
)paren
comma
id|SK_BMU_RX_WM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tx Queue: Release all local resets if the queue is used!&n;&t; * &t;&t;set watermark&n;&t; */
r_if
c_cond
(paren
id|pPrt-&gt;PXSQSize
op_ne
l_int|0
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|Q_CSR
)paren
comma
id|CSR_CLR_RESET
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|Q_F
)paren
comma
id|SK_BMU_TX_WM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pPrt-&gt;PXAQSize
op_ne
l_int|0
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|Q_CSR
)paren
comma
id|CSR_CLR_RESET
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|Q_F
)paren
comma
id|SK_BMU_TX_WM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do NOT enable the descriptor poll timers here, because&n;&t; * the descriptor addresses are not specified yet.&n;&t; */
)brace
multiline_comment|/* SkGeInitBmu */
multiline_comment|/******************************************************************************&n; *&n; *&t;TestStopBit() -&t;Test the stop bit of the queue&n; *&n; * Description:&n; *&t;Stopping a queue is not as simple as it seems to be.&n; *&t;If descriptor polling is enabled, it may happen&n; *&t;that RX/TX stop is done and SV idle is NOT set.&n; *&t;In this case we have to issue another stop command.&n; *&n; * Retruns:&n; *&t;The queues control status register&n; */
DECL|function|TestStopBit
r_static
id|SK_U32
id|TestStopBit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Adapter Context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO Context */
r_int
id|QuIoOffs
)paren
multiline_comment|/* Queue IO Address Offset */
(brace
id|SK_U32
id|QuCsr
suffix:semicolon
multiline_comment|/* CSR contents */
id|SK_IN32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|QuIoOffs
comma
id|Q_CSR
)paren
comma
op_amp
id|QuCsr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|QuCsr
op_amp
(paren
id|CSR_STOP
op_or
id|CSR_SV_IDLE
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|QuIoOffs
comma
id|Q_CSR
)paren
comma
id|CSR_STOP
)paren
suffix:semicolon
id|SK_IN32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|QuIoOffs
comma
id|Q_CSR
)paren
comma
op_amp
id|QuCsr
)paren
suffix:semicolon
)brace
r_return
(paren
id|QuCsr
)paren
suffix:semicolon
)brace
multiline_comment|/* TestStopBit*/
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeStopPort() - Stop the Rx/Tx activity of the port &squot;Port&squot;.&n; *&n; * Description:&n; *&t;After calling this function the descriptor rings and rx and tx&n; *&t;queues of this port may be reconfigured.&n; *&n; *&t;It is possible to stop the receive and transmit path seperate or&n; *&t;both together.&n; *&n; *&t;Dir =&t;SK_STOP_TX &t;Stops the transmit path only and resets&n; *&t;&t;&t;&t;the XMAC. The receive queue is still and&n; *&t;&t;&t;&t;the pending rx frames may still transfered&n; *&t;&t;&t;&t;into the RxD.&n; *&t;&t;SK_STOP_RX&t;Stop the receive path. The tansmit path&n; *&t;&t;&t;&t;has to be stoped once before.&n; *&t;&t;SK_STOP_ALL&t;SK_STOP_TX + SK_STOP_RX&n; *&n; *&t;RstMode=SK_SOFT_RST&t;Resets the XMAC. The PHY is still alive.&n; *&t;&t;SK_HARD_RST&t;Resets the XMAC and the PHY.&n; *&n; * Example:&n; *&t;1) A Link Down event was signaled for a port. Therefore the activity&n; *&t;of this port should be stoped and a hardware reset should be issued&n; *&t;to enable the workaround of XMAC errata #2. But the received frames&n; *&t;should not be discarded.&n; *&t;&t;...&n; *&t;&t;SkGeStopPort(pAC, IoC, Port, SK_STOP_TX, SK_HARD_RST);&n; *&t;&t;(transfer all pending rx frames)&n; *&t;&t;SkGeStopPort(pAC, IoC, Port, SK_STOP_RX, SK_HARD_RST);&n; *&t;&t;...&n; *&n; *&t;2) An event was issued which request the driver to switch&n; *&t;the &squot;virtual active&squot; link to an other already active port&n; *&t;as soon as possible. The frames in the receive queue of this&n; *&t;port may be lost. But the PHY must not be reset during this&n; *&t;event.&n; *&t;&t;...&n; *&t;&t;SkGeStopPort(pAC, IoC, Port, SK_STOP_ALL, SK_SOFT_RST);&n; *&t;&t;...&n; *&n; * Extended Description:&n; *&t;If SK_STOP_TX is set,&n; *&t;&t;o disable the XMACs receive and transmiter to prevent&n; *&t;&t;  from sending incomplete frames&n; *&t;&t;o stop the port&squot;s transmit queues before terminating the&n; *&t;&t;  BMUs to prevent from performing incomplete PCI cycles&n; *&t;&t;  on the PCI bus&n; *&t;&t;- The network rx and tx activity and PCI tx transfer is&n; *&t;&t;  disabled now.&n; *&t;&t;o reset the XMAC depending on the RstMode&n; *&t;&t;o Stop Interval Timer and Limit Counter of Tx Arbiter,&n; *&t;&t;  also disable Force Sync bit and Enable Alloc bit.&n; *&t;&t;o perform a local reset of the port&squot;s tx path&n; *&t;&t;&t;- reset the PCI FIFO of the async tx queue&n; *&t;&t;&t;- reset the PCI FIFO of the sync tx queue&n; *&t;&t;&t;- reset the RAM Buffer async tx queue&n; *&t;&t;&t;- reset the RAM Butter sync tx queue&n; *&t;&t;&t;- reset the MAC Tx FIFO&n; *&t;&t;o switch Link and Tx LED off, stop the LED counters&n; *&n; *&t;If SK_STOP_RX is set,&n; *&t;&t;o stop the port&squot;s receive queue&n; *&t;&t;- The path data transfer activity is fully stopped now.&n; *&t;&t;o perform a local reset of the port&squot;s rx path&n; *&t;&t;&t;- reset the PCI FIFO of the rx queue&n; *&t;&t;&t;- reset the RAM Buffer receive queue&n; *&t;&t;&t;- reset the MAC Rx FIFO&n; *&t;&t;o switch Rx LED off, stop the LED counter&n; *&n; *&t;If all ports are stopped,&n; *&t;&t;o reset the RAM Interface.&n; *&n; * Notes:&n; *&t;o This function may be called during the driver states RESET_PORT and&n; *&t;  SWITCH_PORT.&n; */
DECL|function|SkGeStopPort
r_void
id|SkGeStopPort
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O context */
r_int
id|Port
comma
multiline_comment|/* port to stop (MAC_1 + n) */
r_int
id|Dir
comma
multiline_comment|/* Direction to Stop (SK_STOP_RX, SK_STOP_TX, SK_STOP_ALL) */
r_int
id|RstMode
)paren
multiline_comment|/* Reset Mode (SK_SOFT_RST, SK_HARD_RST) */
(brace
macro_line|#ifndef&t;SK_DIAG
id|SK_EVPARA
id|Para
suffix:semicolon
macro_line|#endif&t;/* !SK_DIAG */
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_U32
id|DWord
suffix:semicolon
id|SK_U16
id|Word
suffix:semicolon
id|SK_U32
id|XsCsr
suffix:semicolon
id|SK_U32
id|XaCsr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SK_BOOL
id|AllPortsDis
suffix:semicolon
id|SK_U64
id|ToutStart
suffix:semicolon
r_int
id|ToutCnt
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
suffix:semicolon
r_if
c_cond
(paren
id|Dir
op_amp
id|SK_STOP_TX
)paren
(brace
multiline_comment|/* disable the XMACs receiver and transmitter */
id|XM_IN16
c_func
(paren
id|IoC
comma
id|Port
comma
id|XM_MMU_CMD
comma
op_amp
id|Word
)paren
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|Port
comma
id|XM_MMU_CMD
comma
id|Word
op_amp
op_complement
(paren
id|XM_MMU_ENA_RX
op_or
id|XM_MMU_ENA_TX
)paren
)paren
suffix:semicolon
multiline_comment|/* dummy read to ensure writing */
id|XM_IN16
c_func
(paren
id|IoC
comma
id|Port
comma
id|XM_MMU_CMD
comma
op_amp
id|Word
)paren
suffix:semicolon
multiline_comment|/* stop both transmit queues */
multiline_comment|/*&n;&t;&t; * If the BMU is in the reset state CSR_STOP will terminate&n;&t;&t; * immediately.&n;&t;&t; */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|Q_CSR
)paren
comma
id|CSR_STOP
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|Q_CSR
)paren
comma
id|CSR_STOP
)paren
suffix:semicolon
id|ToutStart
op_assign
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
suffix:semicolon
id|ToutCnt
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t;&t; * Clear packet arbiter timeout to make sure&n;&t;&t;&t; * this loop will terminate&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Port
op_eq
id|MAC_1
)paren
(brace
id|Word
op_assign
id|PA_CLR_TO_TX1
suffix:semicolon
)brace
r_else
(brace
id|Word
op_assign
id|PA_CLR_TO_TX2
suffix:semicolon
)brace
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_CTRL
comma
id|Word
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the transfer stucks at the XMAC the STOP command&n;&t;&t;&t; * will not terminate if we don&squot;t flush the XMACs&n;&t;&t;&t; * transmit FIFO !&n;&t;&t;&t; */
id|XM_IN32
c_func
(paren
id|IoC
comma
id|Port
comma
id|XM_MODE
comma
op_amp
id|DWord
)paren
suffix:semicolon
id|DWord
op_or_assign
id|XM_MD_FTF
suffix:semicolon
id|XM_OUT32
c_func
(paren
id|IoC
comma
id|Port
comma
id|XM_MODE
comma
id|DWord
)paren
suffix:semicolon
id|XsCsr
op_assign
id|TestStopBit
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pPrt-&gt;PXsQOff
)paren
suffix:semicolon
id|XaCsr
op_assign
id|TestStopBit
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pPrt-&gt;PXaQOff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ToutStart
op_plus
(paren
id|SK_TICKS_PER_SEC
op_div
l_int|18
)paren
op_ge
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Timeout of 1/18 second reached.&n;&t;&t;&t;&t; * This needs to be checked at 1/18 sec only.&n;&t;&t;&t;&t; */
id|ToutCnt
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|ToutCnt
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Cache Incoherency workaround:&n;&t;&t;&t;&t;&t; * Assume a start command has been &n;&t;&t;&t;&t;&t; * lost while sending the frame. &n;&t;&t;&t;&t;&t; */
id|ToutStart
op_assign
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XsCsr
op_amp
id|CSR_STOP
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|Q_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XaCsr
op_amp
id|CSR_STOP
)paren
(brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|Q_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_default
suffix:colon
multiline_comment|/* Might be a problem when the driver event handler&n;&t;&t;&t;&t;&t; * calls StopPort again.&n;&t;&t;&t;&t;&t; * XXX.&n;&t;&t;&t;&t;&t; */
multiline_comment|/* Fatal Error, Loop aborted */
multiline_comment|/* Create an Error Log Entry */
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_HW
comma
id|SKERR_HWI_E018
comma
id|SKERR_HWI_E018MSG
)paren
suffix:semicolon
macro_line|#ifndef SK_DIAG
id|Para.Para64
op_assign
id|Port
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_DRV
comma
id|SK_DRV_PORT_FAIL
comma
id|Para
)paren
suffix:semicolon
macro_line|#endif&t;/* !SK_DIAG */
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Because of the ASIC problem report entry from 21.08.1998 it is&n;&t;&t; * required to wait until CSR_STOP is reset and CSR_SV_IDLE is set.&n;&t;&t; */
)brace
r_while
c_loop
(paren
(paren
id|XsCsr
op_amp
(paren
id|CSR_STOP
op_or
id|CSR_SV_IDLE
)paren
)paren
op_ne
id|CSR_SV_IDLE
op_logical_or
(paren
id|XaCsr
op_amp
(paren
id|CSR_STOP
op_or
id|CSR_SV_IDLE
)paren
)paren
op_ne
id|CSR_SV_IDLE
)paren
suffix:semicolon
multiline_comment|/* reset the XMAC depending on the RstMode */
r_if
c_cond
(paren
id|RstMode
op_eq
id|SK_SOFT_RST
)paren
(brace
id|SkXmSoftRst
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Port
)paren
suffix:semicolon
)brace
r_else
(brace
id|SkXmHardRst
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Port
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Stop Interval Timer and Limit Counter of Tx Arbiter,&n; &t;&t; * also disable Force Sync bit and Enable Alloc bit.&n;&t;&t; */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_CTRL
)paren
comma
id|TXA_DIS_FSYNC
op_or
id|TXA_DIS_ALLOC
op_or
id|TXA_STOP_RC
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_ITI_INI
)paren
comma
l_int|0x00000000L
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_LIM_INI
)paren
comma
l_int|0x00000000L
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * perform a local reset of the port&squot;s tx path&n;&t;&t; *&t;- reset the PCI FIFO of the async tx queue&n;&t;&t; *&t;- reset the PCI FIFO of the sync tx queue&n;&t;&t; *&t;- reset the RAM Buffer async tx queue&n;&t;&t; *&t;- reset the RAM Butter sync tx queue&n;&t;&t; *&t;- reset the MAC Tx FIFO&n;&t;&t; */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|Q_CSR
)paren
comma
id|CSR_SET_RESET
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|Q_CSR
)paren
comma
id|CSR_SET_RESET
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|pPrt-&gt;PXaQOff
comma
id|RB_CTRL
)paren
comma
id|RB_RST_SET
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|pPrt-&gt;PXsQOff
comma
id|RB_CTRL
)paren
comma
id|RB_RST_SET
)paren
suffix:semicolon
multiline_comment|/* Note: MFF_RST_SET does NOT reset the XMAC! */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TX_MFF_CTRL2
)paren
comma
id|MFF_RST_SET
)paren
suffix:semicolon
multiline_comment|/* switch Link and Tx LED off, stop the LED counters */
multiline_comment|/* Link LED is switched off by the RLMT and the Diag itself */
id|SkGeXmitLED
c_func
(paren
id|pAC
comma
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TX_LED_INI
)paren
comma
id|SK_LED_DIS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dir
op_amp
id|SK_STOP_RX
)paren
(brace
multiline_comment|/*&n;&t;&t; * The RX Stop Command will not terminate if no buffers&n;&t;&t; * are queued in the RxD ring. But it will always reach&n;&t;&t; * the Idle state. Therefore we can use this feature to&n;&t;&t; * stop the transfer of received packets.&n;&t;&t; */
multiline_comment|/* stop the port&squot;s receive queue */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|Q_CSR
)paren
comma
id|CSR_STOP
)paren
suffix:semicolon
id|i
op_assign
l_int|100
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t;&t; * Clear packet arbiter timeout to make sure&n;&t;&t;&t; * this loop will terminate&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Port
op_eq
id|MAC_1
)paren
(brace
id|Word
op_assign
id|PA_CLR_TO_RX1
suffix:semicolon
)brace
r_else
(brace
id|Word
op_assign
id|PA_CLR_TO_RX2
suffix:semicolon
)brace
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|B3_PA_CTRL
comma
id|Word
)paren
suffix:semicolon
id|DWord
op_assign
id|TestStopBit
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pPrt-&gt;PRxQOff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
(brace
id|i
op_decrement
suffix:semicolon
)brace
multiline_comment|/* finish if CSR_STOP is done or CSR_SV_IDLE is true and i==0 */
multiline_comment|/*&n;&t;&t; * because of the ASIC problem report entry from 21.08.98&n;&t;&t; * it is required to wait until CSR_STOP is reset and&n;&t;&t; * CSR_SV_IDLE is set.&n;&t;&t; */
)brace
r_while
c_loop
(paren
(paren
id|DWord
op_amp
(paren
id|CSR_STOP
op_or
id|CSR_SV_IDLE
)paren
)paren
op_ne
id|CSR_SV_IDLE
op_logical_and
(paren
(paren
id|DWord
op_amp
id|CSR_SV_IDLE
)paren
op_eq
l_int|0
op_logical_or
id|i
op_ne
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* The path data transfer activity is fully stopped now. */
multiline_comment|/*&n;&t;&t; * perform a local reset of the port&squot;s rx path&n;&t;&t; *&t;- reset the PCI FIFO of the rx queue&n;&t;&t; *&t;- reset the RAM Buffer receive queue&n;&t;&t; *&t;- reset the MAC Rx FIFO&n;&t;&t; */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|Q_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|Q_CSR
)paren
comma
id|CSR_SET_RESET
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|RB_ADDR
c_func
(paren
id|pPrt-&gt;PRxQOff
comma
id|RB_CTRL
)paren
comma
id|RB_RST_SET
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_MFF_CTRL2
)paren
comma
id|MFF_RST_SET
)paren
suffix:semicolon
multiline_comment|/* switch Rx LED off, stop the LED counter */
id|SkGeXmitLED
c_func
(paren
id|pAC
comma
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_LED_INI
)paren
comma
id|SK_LED_DIS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If all ports are stopped reset the RAM Interface.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|AllPortsDis
op_assign
id|SK_TRUE
suffix:semicolon
id|i
OL
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PState
op_ne
id|SK_PRT_RESET
op_logical_and
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PState
op_ne
id|SK_PRT_STOP
)paren
(brace
id|AllPortsDis
op_assign
id|SK_FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|AllPortsDis
)paren
(brace
id|pAC-&gt;GIni.GIAnyPortAct
op_assign
id|SK_FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/* SkGeStopPort */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInit0() - Level 0 Initialization&n; *&n; * Description:&n; *&t;- Initialize the BMU address offsets&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeInit0
r_static
r_void
id|SkGeInit0
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
r_int
id|i
suffix:semicolon
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SK_MAX_MACS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
suffix:semicolon
id|pPrt-&gt;PState
op_assign
id|SK_PRT_RESET
suffix:semicolon
id|pPrt-&gt;PRxQOff
op_assign
id|QOffTab
(braket
id|i
)braket
dot
id|RxQOff
suffix:semicolon
id|pPrt-&gt;PXsQOff
op_assign
id|QOffTab
(braket
id|i
)braket
dot
id|XsQOff
suffix:semicolon
id|pPrt-&gt;PXaQOff
op_assign
id|QOffTab
(braket
id|i
)braket
dot
id|XaQOff
suffix:semicolon
id|pPrt-&gt;PCheckPar
op_assign
id|SK_FALSE
suffix:semicolon
id|pPrt-&gt;PRxCmd
op_assign
id|XM_RX_STRIP_FCS
op_or
id|XM_RX_LENERR_OK
suffix:semicolon
id|pPrt-&gt;PIsave
op_assign
l_int|0
suffix:semicolon
id|pPrt-&gt;PPrevShorts
op_assign
l_int|0
suffix:semicolon
id|pPrt-&gt;PLinkResCt
op_assign
l_int|0
suffix:semicolon
id|pPrt-&gt;PPrevRx
op_assign
l_int|0
suffix:semicolon
id|pPrt-&gt;PPrevFcs
op_assign
l_int|0
suffix:semicolon
id|pPrt-&gt;PRxLim
op_assign
id|SK_DEF_RX_WA_LIM
suffix:semicolon
id|pPrt-&gt;PLinkMode
op_assign
id|SK_LMODE_AUTOFULL
suffix:semicolon
id|pPrt-&gt;PLinkModeConf
op_assign
id|SK_LMODE_AUTOSENSE
suffix:semicolon
id|pPrt-&gt;PFlowCtrlMode
op_assign
id|SK_FLOW_MODE_SYM_OR_REM
suffix:semicolon
id|pPrt-&gt;PLinkBroken
op_assign
id|SK_TRUE
suffix:semicolon
multiline_comment|/* See WA code */
id|pPrt-&gt;PLinkCap
op_assign
(paren
id|SK_LMODE_CAP_HALF
op_or
id|SK_LMODE_CAP_FULL
op_or
id|SK_LMODE_CAP_AUTOHALF
op_or
id|SK_LMODE_CAP_AUTOFULL
)paren
suffix:semicolon
id|pPrt-&gt;PLinkModeStatus
op_assign
id|SK_LMODE_STAT_UNKNOWN
suffix:semicolon
id|pPrt-&gt;PFlowCtrlCap
op_assign
id|SK_FLOW_MODE_SYM_OR_REM
suffix:semicolon
id|pPrt-&gt;PFlowCtrlStatus
op_assign
id|SK_FLOW_STAT_NONE
suffix:semicolon
id|pPrt-&gt;PMSCap
op_assign
(paren
id|SK_MS_CAP_AUTO
op_or
id|SK_MS_CAP_MASTER
op_or
id|SK_MS_CAP_SLAVE
)paren
suffix:semicolon
id|pPrt-&gt;PMSMode
op_assign
id|SK_MS_MODE_AUTO
suffix:semicolon
id|pPrt-&gt;PMSStatus
op_assign
id|SK_MS_STAT_UNSET
suffix:semicolon
id|pPrt-&gt;PAutoNegFail
op_assign
id|SK_FALSE
suffix:semicolon
id|pPrt-&gt;PLipaAutoNeg
op_assign
id|SK_LIPA_UNKNOWN
suffix:semicolon
id|pPrt-&gt;PHWLinkUp
op_assign
id|SK_FALSE
suffix:semicolon
)brace
id|pAC-&gt;GIni.GIPortUsage
op_assign
id|SK_RED_LINK
suffix:semicolon
id|pAC-&gt;GIni.GIAnyPortAct
op_assign
id|SK_FALSE
suffix:semicolon
)brace
multiline_comment|/* SkGeInit0*/
macro_line|#ifdef SK_PCI_RESET
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGePciReset() - Reset PCI interface&n; *&n; * Description:&n; *&t;o Read PCI configuration.&n; *&t;o Change power state to 3.&n; *&t;o Change power state to 0.&n; *&t;o Restore PCI configuration.&n; *&n; * Returns:&n; *&t;0:&t;Success.&n; *&t;1:&t;Power state could not be changed to 3.&n; */
DECL|function|SkGePciReset
r_static
r_int
id|SkGePciReset
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
r_int
id|i
suffix:semicolon
id|SK_U16
id|PmCtlSts
suffix:semicolon
id|SK_U32
id|Bp1
suffix:semicolon
id|SK_U32
id|Bp2
suffix:semicolon
id|SK_U16
id|PciCmd
suffix:semicolon
id|SK_U8
id|Cls
suffix:semicolon
id|SK_U8
id|Lat
suffix:semicolon
id|SK_U8
id|ConfigSpace
(braket
id|PCI_CFG_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Note: Switching to D3 state is like a software reset.&n;&t; *&t;&t; Switching from D3 to D0 is a hardware reset.&n;&t; *&t;&t; We have to save and restore the configuration space.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_CFG_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SkPciReadCfgDWord
c_func
(paren
id|pAC
comma
id|i
op_star
l_int|4
comma
op_amp
id|ConfigSpace
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* We know the RAM Interface Arbiter is enabled. */
id|SkPciWriteCfgWord
c_func
(paren
id|pAC
comma
id|PCI_PM_CTL_STS
comma
id|PCI_PM_STATE_D3
)paren
suffix:semicolon
id|SkPciReadCfgWord
c_func
(paren
id|pAC
comma
id|PCI_PM_CTL_STS
comma
op_amp
id|PmCtlSts
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|PmCtlSts
op_amp
id|PCI_PM_STATE
)paren
op_ne
id|PCI_PM_STATE_D3
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return to D0 state.&n;&t; */
id|SkPciWriteCfgWord
c_func
(paren
id|pAC
comma
id|PCI_PM_CTL_STS
comma
id|PCI_PM_STATE_D0
)paren
suffix:semicolon
multiline_comment|/* Check for D0 state. */
id|SkPciReadCfgWord
c_func
(paren
id|pAC
comma
id|PCI_PM_CTL_STS
comma
op_amp
id|PmCtlSts
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|PmCtlSts
op_amp
id|PCI_PM_STATE
)paren
op_ne
id|PCI_PM_STATE_D0
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check PCI Config Registers.&n;&t; */
id|SkPciReadCfgWord
c_func
(paren
id|pAC
comma
id|PCI_COMMAND
comma
op_amp
id|PciCmd
)paren
suffix:semicolon
id|SkPciReadCfgByte
c_func
(paren
id|pAC
comma
id|PCI_CACHE_LSZ
comma
op_amp
id|Cls
)paren
suffix:semicolon
id|SkPciReadCfgDWord
c_func
(paren
id|pAC
comma
id|PCI_BASE_1ST
comma
op_amp
id|Bp1
)paren
suffix:semicolon
id|SkPciReadCfgDWord
c_func
(paren
id|pAC
comma
id|PCI_BASE_2ND
comma
op_amp
id|Bp2
)paren
suffix:semicolon
id|SkPciReadCfgByte
c_func
(paren
id|pAC
comma
id|PCI_LAT_TIM
comma
op_amp
id|lat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PciCmd
op_ne
l_int|0
op_logical_or
id|Cls
op_ne
l_int|0
op_logical_or
(paren
id|Bp1
op_amp
l_int|0xfffffff0L
)paren
op_ne
l_int|0
op_logical_or
id|Bp2
op_ne
l_int|1
op_logical_or
id|Lat
op_ne
l_int|0
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore Config Space.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_CFG_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SkPciWriteCfgDWord
c_func
(paren
id|pAC
comma
id|i
op_star
l_int|4
comma
id|ConfigSpace
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGePciReset */
macro_line|#endif&t;/* SK_PCI_RESET */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInit1() - Level 1 Initialization&n; *&n; * Description:&n; *&t;o Do a software reset.&n; *&t;o Clear all reset bits.&n; *&t;o Verify that the detected hardware is present.&n; *&t;  Return an error if not.&n; *&t;o Get the hardware configuration&n; *&t;&t;+ Read the number of MACs/Ports.&n; *&t;&t;+ Read the RAM size.&n; *&t;&t;+ Read the PCI Revision ID.&n; *&t;&t;+ Find out the adapters host clock speed&n; *&t;&t;+ Read and check the PHY type&n; *&n; * Returns:&n; *&t;0:&t;success&n; *&t;5:&t;Unexpected PHY type detected&n; */
DECL|function|SkGeInit1
r_static
r_int
id|SkGeInit1
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
id|SK_U8
id|Byte
suffix:semicolon
id|SK_U16
id|Word
suffix:semicolon
r_int
id|RetVal
suffix:semicolon
r_int
id|i
suffix:semicolon
id|RetVal
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SK_PCI_RESET
(paren
r_void
)paren
id|SkGePciReset
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
macro_line|#endif&t;/* SK_PCI_RESET */
multiline_comment|/* Do the reset */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
id|CS_RST_SET
)paren
suffix:semicolon
multiline_comment|/* Release the reset */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
id|CS_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* Reset all error bits in the PCI STATUS register */
multiline_comment|/*&n;&t; * Note: Cfg cycles cannot be used, because they are not&n;&t; *&t;&t; available on some platforms after &squot;boot time&squot;.&n;&t; */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B2_TST_CTRL1
comma
id|TST_CFG_WRITE_ON
)paren
suffix:semicolon
id|SK_IN16
c_func
(paren
id|IoC
comma
id|PCI_C
c_func
(paren
id|PCI_STATUS
)paren
comma
op_amp
id|Word
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|PCI_C
c_func
(paren
id|PCI_STATUS
)paren
comma
id|Word
op_or
id|PCI_ERRBITS
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B2_TST_CTRL1
comma
id|TST_CFG_WRITE_OFF
)paren
suffix:semicolon
multiline_comment|/* Release Master_Reset */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
id|CS_MRST_CLR
)paren
suffix:semicolon
multiline_comment|/* Read number of MACs */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_MAC_CFG
comma
op_amp
id|Byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Byte
op_amp
id|CFG_SNG_MAC
)paren
(brace
id|pAC-&gt;GIni.GIMacsFound
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;GIni.GIMacsFound
op_assign
l_int|2
suffix:semicolon
)brace
id|SK_IN8
c_func
(paren
id|IoC
comma
id|PCI_C
c_func
(paren
id|PCI_REV_ID
)paren
comma
op_amp
id|Byte
)paren
suffix:semicolon
id|pAC-&gt;GIni.GIPciHwRev
op_assign
(paren
r_int
)paren
id|Byte
suffix:semicolon
multiline_comment|/* Read the adapters RAM size */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_E_0
comma
op_amp
id|Byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Byte
op_eq
l_int|3
)paren
(brace
id|pAC-&gt;GIni.GIRamSize
op_assign
(paren
r_int
)paren
(paren
id|Byte
op_minus
l_int|1
)paren
op_star
l_int|512
suffix:semicolon
id|pAC-&gt;GIni.GIRamOffs
op_assign
(paren
id|SK_U32
)paren
l_int|512
op_star
l_int|1024
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;GIni.GIRamSize
op_assign
(paren
r_int
)paren
id|Byte
op_star
l_int|512
suffix:semicolon
id|pAC-&gt;GIni.GIRamOffs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* All known GE Adapters works with 53.125 MHz host clock */
id|pAC-&gt;GIni.GIHstClkFact
op_assign
id|SK_FACT_53
suffix:semicolon
id|pAC-&gt;GIni.GIPollTimerVal
op_assign
id|SK_DPOLL_DEF
op_star
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIHstClkFact
op_div
l_int|100
suffix:semicolon
multiline_comment|/* Read the PHY type */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_E_1
comma
op_amp
id|Byte
)paren
suffix:semicolon
id|Byte
op_and_assign
l_int|0x0f
suffix:semicolon
multiline_comment|/* the PHY type is stored in the lower nibble */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyType
op_assign
id|Byte
suffix:semicolon
r_switch
c_cond
(paren
id|Byte
)paren
(brace
r_case
id|SK_PHY_XMAC
suffix:colon
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyAddr
op_assign
id|PHY_ADDR_XMAC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PHY_BCOM
suffix:colon
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyAddr
op_assign
id|PHY_ADDR_BCOM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PHY_LONE
suffix:colon
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyAddr
op_assign
id|PHY_ADDR_LONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PHY_NAT
suffix:colon
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyAddr
op_assign
id|PHY_ADDR_NAT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* ERROR: unexpected PHY typ detected */
id|RetVal
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_HWM
comma
id|SK_DBGCAT_INIT
comma
(paren
l_string|&quot;PHY type: %d  PHY addr: %x&bslash;n&quot;
comma
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyType
comma
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PhyAddr
)paren
)paren
suffix:semicolon
r_return
(paren
id|RetVal
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeInit1*/
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInit2() - Level 2 Initialization&n; *&n; * Description:&n; *&t;- start the Blink Source Counter&n; *&t;- start the Descriptor Poll Timer&n; *&t;- configure the MAC-Arbiter&n; *&t;- configure the Packet-Arbiter&n; *&t;- enable the Tx Arbiters&n; *&t;- enable the RAM Interface Arbiter&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeInit2
r_static
r_void
id|SkGeInit2
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_U32
id|DWord
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* start the Blink Source Counter */
id|DWord
op_assign
id|SK_BLK_DUR
op_star
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIHstClkFact
op_div
l_int|100
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_BSC_INI
comma
id|DWord
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B2_BSC_CTRL
comma
id|BSC_START
)paren
suffix:semicolon
multiline_comment|/* start the Descriptor Poll Timer */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIPollTimerVal
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIPollTimerVal
OG
id|SK_DPOLL_MAX
)paren
(brace
id|pAC-&gt;GIni.GIPollTimerVal
op_assign
id|SK_DPOLL_MAX
suffix:semicolon
multiline_comment|/* Create an Error Log Entry */
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E017
comma
id|SKERR_HWI_E017MSG
)paren
suffix:semicolon
)brace
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B28_DPT_INI
comma
id|pAC-&gt;GIni.GIPollTimerVal
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B28_DPT_CTRL
comma
id|DPT_START
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Configure&n;&t; *&t;- the MAC-Arbiter and&n;&t; *&t;- the Paket Arbiter&n;&t; *&n;&t; * The MAC and the packet arbiter will be started once&n;&t; * and never be stopped.&n;&t; */
id|SkGeInitMacArb
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
id|SkGeInitPktArb
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/* enable the Tx Arbiters */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|MAC_1
comma
id|TXA_CTRL
)paren
comma
id|TXA_ENA_ARB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|MAC_2
comma
id|TXA_CTRL
)paren
comma
id|TXA_ENA_ARB
)paren
suffix:semicolon
)brace
multiline_comment|/* enable the RAM Interface Arbiter */
id|SkGeInitRamIface
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SK_MAX_MACS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIPortUsage
op_eq
id|SK_JUMBO_LINK
)paren
(brace
id|pPrt-&gt;PRxCmd
op_or_assign
id|XM_RX_BIG_PK_OK
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* SkGeInit2 */
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInit() - Initialize the GE Adapter with the specified level.&n; *&n; * Description:&n; *&t;Level&t;0:&t;Initialize the Module structures.&n; *&t;Level&t;1:&t;Generic Hardware Initialization. The&n; *&t;&t;&t;IOP/MemBase pointer has to be set before&n; *&t;&t;&t;calling this level.&n; *&n; *&t;&t;&t;o Do a software reset.&n; *&t;&t;&t;o Clear all reset bits.&n; *&t;&t;&t;o Verify that the detected hardware is present.&n; *&t;&t;&t;  Return an error if not.&n; *&t;&t;&t;o Get the hardware configuration&n; *&t;&t;&t;&t;+ Set GIMacsFound with the number of MACs.&n; *&t;&t;&t;&t;+ Store the RAM size in GIRamSize.&n; *&t;&t;&t;&t;+ Save the PCI Revision ID in GIPciHwRev.&n; *&t;&t;&t;o return an error&n; *&t;&t;&t;&t;if Number of MACs &gt; SK_MAX_MACS&n; *&n; *&t;&t;&t;After returning from Level 0 the adapter&n; *&t;&t;&t;may be accessed with IO operations.&n; *&n; *&t;Level&t;2:&t;start the Blink Source Counter&n; *&n; * Returns:&n; *&t;0:&t;success&n; *&t;1:&t;Number of MACs exceeds SK_MAX_MACS&t;( after level 1)&n; *&t;2:&t;Adapter not present or not accessable&n; *&t;3:&t;Illegal initialization level&n; *&t;4:&t;Initialization Level 1 Call missing&n; *&t;5:&t;Unexpected PHY type detected&n; */
DECL|function|SkGeInit
r_int
id|SkGeInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Level
)paren
multiline_comment|/* initialization level */
(brace
r_int
id|RetVal
suffix:semicolon
multiline_comment|/* return value */
id|SK_U32
id|DWord
suffix:semicolon
id|RetVal
op_assign
l_int|0
suffix:semicolon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_HWM
comma
id|SK_DBGCAT_INIT
comma
(paren
l_string|&quot;SkGeInit(Level %d)&bslash;n&quot;
comma
id|Level
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Level
)paren
(brace
r_case
id|SK_INIT_DATA
suffix:colon
multiline_comment|/* Initialization Level 0 */
id|SkGeInit0
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
id|pAC-&gt;GIni.GILevel
op_assign
id|SK_INIT_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_INIT_IO
suffix:colon
multiline_comment|/* Initialization Level 1 */
id|RetVal
op_assign
id|SkGeInit1
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/* Check if the adapter seems to be accessable */
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_IRQM_INI
comma
l_int|0x11335577L
)paren
suffix:semicolon
id|SK_IN32
c_func
(paren
id|IoC
comma
id|B2_IRQM_INI
comma
op_amp
id|DWord
)paren
suffix:semicolon
id|SK_OUT32
c_func
(paren
id|IoC
comma
id|B2_IRQM_INI
comma
l_int|0x00000000L
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DWord
op_ne
l_int|0x11335577L
)paren
(brace
id|RetVal
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check if the number of GIMacsFound matches SK_MAX_MACS */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
id|SK_MAX_MACS
)paren
(brace
id|RetVal
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Level 1 successfully passed */
id|pAC-&gt;GIni.GILevel
op_assign
id|SK_INIT_IO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_INIT_RUN
suffix:colon
multiline_comment|/* Initialization Level 2 */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GILevel
op_ne
id|SK_INIT_IO
)paren
(brace
macro_line|#ifndef&t;SK_DIAG
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E002
comma
id|SKERR_HWI_E002MSG
)paren
suffix:semicolon
macro_line|#endif
id|RetVal
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SkGeInit2
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/* Level 2 successfully passed */
id|pAC-&gt;GIni.GILevel
op_assign
id|SK_INIT_RUN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Create an Error Log Entry */
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E003
comma
id|SKERR_HWI_E003MSG
)paren
suffix:semicolon
id|RetVal
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|RetVal
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeInit*/
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeDeInit() - Deinitialize the adapter.&n; *&n; * Description:&n; *&t;All ports of the adapter will be stopped if not already done.&n; *&t;Do a software reset and switch off all LEDs.&n; *&n; * Returns:&n; *&t;nothing&n; */
DECL|function|SkGeDeInit
r_void
id|SkGeDeInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context */
(brace
r_int
id|i
suffix:semicolon
id|SK_U16
id|Word
suffix:semicolon
multiline_comment|/* Ensure I2C is ready. */
id|SkI2cWaitIrq
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/* Stop all current transfer activity */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PState
op_ne
id|SK_PRT_STOP
op_logical_and
id|pAC-&gt;GIni.GP
(braket
id|i
)braket
dot
id|PState
op_ne
id|SK_PRT_RESET
)paren
(brace
id|SkGeStopPort
c_func
(paren
id|pAC
comma
id|IoC
comma
id|i
comma
id|SK_STOP_ALL
comma
id|SK_HARD_RST
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset all bits in the PCI STATUS register */
multiline_comment|/*&n;&t; * Note: Cfg cycles cannot be used, because they are not&n;&t; *&t; available on some platforms after &squot;boot time&squot;.&n;&t; */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B2_TST_CTRL1
comma
id|TST_CFG_WRITE_ON
)paren
suffix:semicolon
id|SK_IN16
c_func
(paren
id|IoC
comma
id|PCI_C
c_func
(paren
id|PCI_STATUS
)paren
comma
op_amp
id|Word
)paren
suffix:semicolon
id|SK_OUT16
c_func
(paren
id|IoC
comma
id|PCI_C
c_func
(paren
id|PCI_STATUS
)paren
comma
id|Word
op_or
id|PCI_ERRBITS
)paren
suffix:semicolon
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B2_TST_CTRL1
comma
id|TST_CFG_WRITE_OFF
)paren
suffix:semicolon
multiline_comment|/* Do the reset, all LEDs are switched off now */
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
id|CS_RST_SET
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeDeInit*/
multiline_comment|/******************************************************************************&n; *&n; *&t;SkGeInitPort()&t;Initialize the specified prot.&n; *&n; * Description:&n; *&t;PRxQSize, PXSQSize, and PXAQSize has to be&n; *&t;configured for the specified port before calling this&n; *&t;function. The descriptor rings has to be initialized, too.&n; *&n; *&t;o (Re)configure queues of the specified port.&n; *&t;o configure the XMAC of the specified port.&n; *&t;o put ASIC and XMAC(s) in operational mode.&n; *&t;o initialize Rx/Tx and Sync LED&n; *&t;o initialize RAM Buffers and MAC FIFOs&n; *&n; *&t;The port is ready to connect when returning.&n; *&n; * Note:&n; *&t;The XMACs Rx and Tx state machine is still disabled when&n; *&t;returning.&n; *&n; * Returns:&n; *&t;0:&t;success&n; *&t;1:&t;Queue size initialization error. The configured values&n; *&t;&t;for PRxQSize, PXSQSize, or PXAQSize are invalid for one&n; *&t;&t;or more queues. The specified port was NOT initialized.&n; *&t;&t;An error log entry was generated.&n; *&t;2:&t;The port has to be stopped before it can be initilaized again.&n; */
DECL|function|SkGeInitPort
r_int
id|SkGeInitPort
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context */
r_int
id|Port
)paren
multiline_comment|/* Port to configure */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|Port
)braket
suffix:semicolon
r_if
c_cond
(paren
id|SkGeCheckQSize
c_func
(paren
id|pAC
comma
id|Port
)paren
op_ne
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E004
comma
id|SKERR_HWI_E004MSG
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pPrt-&gt;PState
op_eq
id|SK_PRT_INIT
op_logical_or
id|pPrt-&gt;PState
op_eq
id|SK_PRT_RUN
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SKERR_HWI_E005
comma
id|SKERR_HWI_E005MSG
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Configuration ok, initialize the Port now */
multiline_comment|/* Initialize Rx, Tx and Link LED */
multiline_comment|/*&n;&t; * If 1000BT Phy needs LED initialization than swap&n;&t; * LED and XMAC initialization order&n;&t; */
id|SkGeXmitLED
c_func
(paren
id|pAC
comma
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TX_LED_INI
)paren
comma
id|SK_LED_ENA
)paren
suffix:semicolon
id|SkGeXmitLED
c_func
(paren
id|pAC
comma
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|RX_LED_INI
)paren
comma
id|SK_LED_ENA
)paren
suffix:semicolon
multiline_comment|/* The Link LED is initialized by RLMT or Diagnostics itself */
multiline_comment|/* Do NOT initialize the Link Sync Counter */
multiline_comment|/*&n;&t; * Configure&n;&t; *&t;- XMAC&n;&t; *&t;- MAC FIFOs&n;&t; *&t;- RAM Buffers&n;&t; *&t;- enable Force Sync bit if synchronous queue available&n;&t; *&t;- BMUs&n;&t; */
id|SkXmInitMac
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Port
)paren
suffix:semicolon
id|SkGeInitMacFifo
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Port
)paren
suffix:semicolon
id|SkGeInitRamBufs
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pPrt-&gt;PXSQSize
op_ne
l_int|0
)paren
(brace
id|SK_OUT8
c_func
(paren
id|IoC
comma
id|MR_ADDR
c_func
(paren
id|Port
comma
id|TXA_CTRL
)paren
comma
id|TXA_ENA_FSYNC
)paren
suffix:semicolon
)brace
id|SkGeInitBmu
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Port
)paren
suffix:semicolon
multiline_comment|/* Mark port as initialized. */
id|pPrt-&gt;PState
op_assign
id|SK_PRT_INIT
suffix:semicolon
id|pAC-&gt;GIni.GIAnyPortAct
op_assign
id|SK_TRUE
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeInitPort */
eof
