multiline_comment|/*&n; *&t;Wavelan Pcmcia driver&n; *&n; *&t;&t;Jean II - HPLB &squot;96&n; *&n; * Reorganisation and extension of the driver.&n; * Original copyright follow. See wavelan_cs.h for details.&n; *&n; * This code is derived from Anthony D. Joseph&squot;s code and all the changes here&n; * are also under the original copyright below.&n; *&n; * This code supports version 2.00 of WaveLAN/PCMCIA cards (2.4GHz), and&n; * can work on Linux 2.0.36 with support of David Hinds&squot; PCMCIA Card Services&n; *&n; * Joe Finney (joe@comp.lancs.ac.uk) at Lancaster University in UK added&n; * critical code in the routine to initialize the Modem Management Controller.&n; *&n; * Thanks to Alan Cox and Bruce Janson for their advice.&n; *&n; *&t;-- Yunzhou Li (scip4166@nus.sg)&n; *&n;#ifdef WAVELAN_ROAMING&t;&n; * Roaming support added 07/22/98 by Justin Seger (jseger@media.mit.edu)&n; * based on patch by Joe Finney from Lancaster University.&n;#endif :-)&n; *&n; * Lucent (formerly AT&amp;T GIS, formerly NCR) WaveLAN PCMCIA card: An&n; * Ethernet-like radio transceiver controlled by an Intel 82593 coprocessor.&n; *&n; *   A non-shared memory PCMCIA ethernet driver for linux&n; *&n; * ISA version modified to support PCMCIA by Anthony Joseph (adj@lcs.mit.edu)&n; *&n; *&n; * Joseph O&squot;Sullivan &amp; John Langford (josullvn@cs.cmu.edu &amp; jcl@cs.cmu.edu)&n; *&n; * Apr 2 &squot;98  made changes to bring the i82593 control/int handling in line&n; *             with offical specs...&n; *&n; ****************************************************************************&n; *   Copyright 1995&n; *   Anthony D. Joseph&n; *   Massachusetts Institute of Technology&n; *&n; *   Permission to use, copy, modify, and distribute this program&n; *   for any purpose and without fee is hereby granted, provided&n; *   that this copyright and permission notice appear on all copies&n; *   and supporting documentation, the name of M.I.T. not be used&n; *   in advertising or publicity pertaining to distribution of the&n; *   program without specific prior permission, and notice be given&n; *   in supporting documentation that copying and distribution is&n; *   by permission of M.I.T.  M.I.T. makes no representations about&n; *   the suitability of this software for any purpose.  It is pro-&n; *   vided &quot;as is&quot; without express or implied warranty.         &n; ****************************************************************************&n; *&n; */
macro_line|#include &quot;wavelan_cs.h&quot;&t;&t;/* Private header */
multiline_comment|/************************* MISC SUBROUTINES **************************/
multiline_comment|/*&n; * Subroutines which won&squot;t fit in one of the following category&n; * (wavelan modem or i82593)&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Wrapper for reporting error to cardservices&n; */
DECL|function|cs_error
r_static
r_void
id|cs_error
c_func
(paren
id|client_handle_t
id|handle
comma
r_int
id|func
comma
r_int
id|ret
)paren
(brace
id|error_info_t
id|err
op_assign
(brace
id|func
comma
id|ret
)brace
suffix:semicolon
id|CardServices
c_func
(paren
id|ReportError
comma
id|handle
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
macro_line|#ifdef STRUCT_CHECK
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Sanity routine to verify the sizes of the various WaveLAN interface&n; * structures.&n; */
r_static
r_char
op_star
DECL|function|wv_structuct_check
id|wv_structuct_check
c_func
(paren
r_void
)paren
(brace
DECL|macro|SC
mdefine_line|#define&t;SC(t,s,n)&t;if (sizeof(t) != s) return(n);
id|SC
c_func
(paren
id|psa_t
comma
id|PSA_SIZE
comma
l_string|&quot;psa_t&quot;
)paren
suffix:semicolon
id|SC
c_func
(paren
id|mmw_t
comma
id|MMW_SIZE
comma
l_string|&quot;mmw_t&quot;
)paren
suffix:semicolon
id|SC
c_func
(paren
id|mmr_t
comma
id|MMR_SIZE
comma
l_string|&quot;mmr_t&quot;
)paren
suffix:semicolon
DECL|macro|SC
macro_line|#undef&t;SC
r_return
(paren
r_char
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* wv_structuct_check */
macro_line|#endif&t;/* STRUCT_CHECK */
multiline_comment|/******************* MODEM MANAGEMENT SUBROUTINES *******************/
multiline_comment|/*&n; * Usefull subroutines to manage the modem of the wavelan&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read from card&squot;s Host Adaptor Status Register.&n; */
r_static
r_inline
id|u_char
DECL|function|hasr_read
id|hasr_read
c_func
(paren
id|u_long
id|base
)paren
(brace
r_return
id|inb
c_func
(paren
id|HASR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* hasr_read */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write to card&squot;s Host Adapter Command Register.&n; */
r_static
r_inline
r_void
DECL|function|hacr_write
id|hacr_write
c_func
(paren
id|u_long
id|base
comma
id|u_char
id|hacr
)paren
(brace
id|outb
c_func
(paren
id|hacr
comma
id|HACR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* hacr_write */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write to card&squot;s Host Adapter Command Register. Include a delay for&n; * those times when it is needed.&n; */
r_static
r_inline
r_void
DECL|function|hacr_write_slow
id|hacr_write_slow
c_func
(paren
id|u_long
id|base
comma
id|u_char
id|hacr
)paren
(brace
id|hacr_write
c_func
(paren
id|base
comma
id|hacr
)paren
suffix:semicolon
multiline_comment|/* delay might only be needed sometimes */
id|mdelay
c_func
(paren
l_int|1L
)paren
suffix:semicolon
)brace
multiline_comment|/* hacr_write_slow */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read the Parameter Storage Area from the WaveLAN card&squot;s memory&n; */
r_static
r_void
DECL|function|psa_read
id|psa_read
c_func
(paren
id|device
op_star
id|dev
comma
r_int
id|o
comma
multiline_comment|/* offset in PSA */
id|u_char
op_star
id|b
comma
multiline_comment|/* buffer to fill */
r_int
id|n
)paren
multiline_comment|/* size to read */
(brace
id|u_char
op_star
id|ptr
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|dev-&gt;mem_start
)paren
op_plus
id|PSA_ADDR
op_plus
(paren
id|o
op_lshift
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
op_star
id|b
op_increment
op_assign
id|readb
c_func
(paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* Due to a lack of address decode pins, the WaveLAN PCMCIA card&n;       * only supports reading even memory addresses. That means the&n;       * increment here MUST be two.&n;       * Because of that, we can&squot;t use memcpy_fromio()...&n;       */
id|ptr
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* psa_read */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write the Paramter Storage Area to the WaveLAN card&squot;s memory&n; */
r_static
r_void
DECL|function|psa_write
id|psa_write
c_func
(paren
id|device
op_star
id|dev
comma
r_int
id|o
comma
multiline_comment|/* Offset in psa */
id|u_char
op_star
id|b
comma
multiline_comment|/* Buffer in memory */
r_int
id|n
)paren
multiline_comment|/* Length of buffer */
(brace
id|u_char
op_star
id|ptr
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|dev-&gt;mem_start
)paren
op_plus
id|PSA_ADDR
op_plus
(paren
id|o
op_lshift
l_int|1
)paren
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* As there seem to have no flag PSA_BUSY as in the ISA model, we are&n;   * oblige to verify this address to know when the PSA is ready... */
r_volatile
id|u_char
op_star
id|verify
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|dev-&gt;mem_start
)paren
op_plus
id|PSA_ADDR
op_plus
(paren
id|psaoff
c_func
(paren
l_int|0
comma
id|psa_comp_number
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Authorize writting to PSA */
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_ROM_WEN
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* write to PSA */
id|writeb
c_func
(paren
op_star
id|b
op_increment
comma
id|ptr
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* I don&squot;t have the spec, so I don&squot;t know what the correct&n;       * sequence to write is. This hack seem to work for me... */
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readb
c_func
(paren
id|verify
)paren
op_ne
id|PSA_COMP_PCMCIA_915
)paren
op_logical_and
(paren
id|count
op_increment
OL
l_int|100
)paren
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Put the host interface back in standard state */
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/* psa_write */
macro_line|#ifdef SET_PSA_CRC
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Calculate the PSA CRC&n; * Thanks to Valster, Nico &lt;NVALSTER@wcnd.nl.lucent.com&gt; for the code&n; * NOTE: By specifying a length including the CRC position the&n; * returned value should be zero. (i.e. a correct checksum in the PSA)&n; *&n; * The Windows drivers don&squot;t use the CRC, but the AP and the PtP tool&n; * depend on it.&n; */
r_static
id|u_short
DECL|function|psa_crc
id|psa_crc
c_func
(paren
r_int
r_char
op_star
id|psa
comma
multiline_comment|/* The PSA */
r_int
id|size
)paren
multiline_comment|/* Number of short for CRC */
(brace
r_int
id|byte_cnt
suffix:semicolon
multiline_comment|/* Loop on the PSA */
id|u_short
id|crc_bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Data in the PSA */
r_int
id|bit_cnt
suffix:semicolon
multiline_comment|/* Loop on the bits of the short */
r_for
c_loop
(paren
id|byte_cnt
op_assign
l_int|0
suffix:semicolon
id|byte_cnt
OL
id|size
suffix:semicolon
id|byte_cnt
op_increment
)paren
(brace
id|crc_bytes
op_xor_assign
id|psa
(braket
id|byte_cnt
)braket
suffix:semicolon
multiline_comment|/* Its an xor */
r_for
c_loop
(paren
id|bit_cnt
op_assign
l_int|1
suffix:semicolon
id|bit_cnt
OL
l_int|9
suffix:semicolon
id|bit_cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|crc_bytes
op_amp
l_int|0x0001
)paren
(brace
id|crc_bytes
op_assign
(paren
id|crc_bytes
op_rshift
l_int|1
)paren
op_xor
l_int|0xA001
suffix:semicolon
)brace
r_else
id|crc_bytes
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|crc_bytes
suffix:semicolon
)brace
multiline_comment|/* psa_crc */
macro_line|#endif&t;/* SET_PSA_CRC */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * update the checksum field in the Wavelan&squot;s PSA&n; */
r_static
r_void
DECL|function|update_psa_checksum
id|update_psa_checksum
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
macro_line|#ifdef SET_PSA_CRC
id|psa_t
id|psa
suffix:semicolon
id|u_short
id|crc
suffix:semicolon
multiline_comment|/* read the parameter storage area */
id|psa_read
c_func
(paren
id|dev
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
multiline_comment|/* update the checksum */
id|crc
op_assign
id|psa_crc
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc
(braket
l_int|0
)braket
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc
(braket
l_int|1
)braket
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc_status
)paren
)paren
suffix:semicolon
id|psa.psa_crc
(braket
l_int|0
)braket
op_assign
id|crc
op_amp
l_int|0xFF
suffix:semicolon
id|psa.psa_crc
(braket
l_int|1
)braket
op_assign
(paren
id|crc
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* Write it ! */
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_crc
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_crc
comma
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: update_psa_checksum(): crc = 0x%02x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|psa.psa_crc
(braket
l_int|0
)braket
comma
id|psa.psa_crc
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Check again (luxury !) */
id|crc
op_assign
id|psa_crc
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc_status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: update_psa_checksum(): CRC does not agree with PSA data (even after recalculating)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_IOCTL_INFO */
macro_line|#endif&t;/* SET_PSA_CRC */
)brace
multiline_comment|/* update_psa_checksum */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write 1 byte to the MMC.&n; */
r_static
r_inline
r_void
DECL|function|mmc_out
id|mmc_out
c_func
(paren
id|u_long
id|base
comma
id|u_short
id|o
comma
id|u_char
id|d
)paren
(brace
multiline_comment|/* Wait for MMC to go idle */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|HASR
c_func
(paren
id|base
)paren
)paren
op_amp
id|HASR_MMI_BUSY
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
(paren
id|u_char
)paren
(paren
(paren
id|o
op_lshift
l_int|1
)paren
op_or
id|MMR_MMI_WR
)paren
comma
id|MMR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|d
comma
id|MMD
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to write bytes to the Modem Management Controller.&n; * We start by the end because it is the way it should be !&n; */
r_static
r_inline
r_void
DECL|function|mmc_write
id|mmc_write
c_func
(paren
id|u_long
id|base
comma
id|u_char
id|o
comma
id|u_char
op_star
id|b
comma
r_int
id|n
)paren
(brace
id|o
op_add_assign
id|n
suffix:semicolon
id|b
op_add_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
id|mmc_out
c_func
(paren
id|base
comma
op_decrement
id|o
comma
op_star
(paren
op_decrement
id|b
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* mmc_write */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read 1 byte from the MMC.&n; * Optimised version for 1 byte, avoid using memory...&n; */
r_static
r_inline
id|u_char
DECL|function|mmc_in
id|mmc_in
c_func
(paren
id|u_long
id|base
comma
id|u_short
id|o
)paren
(brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|HASR
c_func
(paren
id|base
)paren
)paren
op_amp
id|HASR_MMI_BUSY
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
id|o
op_lshift
l_int|1
comma
id|MMR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Set the read address */
id|outb
c_func
(paren
l_int|0
comma
id|MMD
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Required dummy write */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|HASR
c_func
(paren
id|base
)paren
)paren
op_amp
id|HASR_MMI_BUSY
)paren
(brace
suffix:semicolon
)brace
r_return
(paren
id|u_char
)paren
(paren
id|inb
c_func
(paren
id|MMD
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now do the actual read */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to read bytes from the Modem Management Controller.&n; * The implementation is complicated by a lack of address lines,&n; * which prevents decoding of the low-order bit.&n; * (code has just been moved in the above function)&n; * We start by the end because it is the way it should be !&n; */
r_static
r_inline
r_void
DECL|function|mmc_read
id|mmc_read
c_func
(paren
id|u_long
id|base
comma
id|u_char
id|o
comma
id|u_char
op_star
id|b
comma
r_int
id|n
)paren
(brace
id|o
op_add_assign
id|n
suffix:semicolon
id|b
op_add_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
op_star
(paren
op_decrement
id|b
)paren
op_assign
id|mmc_in
c_func
(paren
id|base
comma
op_decrement
id|o
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* mmc_read */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get the type of encryption available...&n; */
r_static
r_inline
r_int
DECL|function|mmc_encr
id|mmc_encr
c_func
(paren
id|u_long
id|base
)paren
multiline_comment|/* i/o port of the card */
(brace
r_int
id|temp
suffix:semicolon
id|temp
op_assign
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_des_avail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_ne
id|MMR_DES_AVAIL_DES
)paren
op_logical_and
(paren
id|temp
op_ne
id|MMR_DES_AVAIL_AES
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|temp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Wait for the frequency EEprom to complete a command...&n; * I hope this one will be optimally inlined...&n; */
r_static
r_inline
r_void
DECL|function|fee_wait
id|fee_wait
c_func
(paren
id|u_long
id|base
comma
multiline_comment|/* i/o port of the card */
r_int
id|delay
comma
multiline_comment|/* Base delay to wait for */
r_int
id|number
)paren
multiline_comment|/* Number of time to wait */
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait only a limited time */
r_while
c_loop
(paren
(paren
id|count
op_increment
OL
id|number
)paren
op_logical_and
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
id|MMR_FEE_STATUS_BUSY
)paren
)paren
(brace
id|udelay
c_func
(paren
id|delay
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read bytes from the Frequency EEprom (frequency select cards).&n; */
r_static
r_void
DECL|function|fee_read
id|fee_read
c_func
(paren
id|u_long
id|base
comma
multiline_comment|/* i/o port of the card */
id|u_short
id|o
comma
multiline_comment|/* destination offset */
id|u_short
op_star
id|b
comma
multiline_comment|/* data buffer */
r_int
id|n
)paren
multiline_comment|/* number of registers */
(brace
id|b
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Position at the end of the area */
multiline_comment|/* Write the address */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|o
op_plus
id|n
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Loop on all buffer */
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* Write the read command */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_READ
)paren
suffix:semicolon
multiline_comment|/* Wait until EEprom is ready (should be quick !) */
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the value */
op_star
op_decrement
id|b
op_assign
(paren
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_h
)paren
)paren
op_lshift
l_int|8
)paren
op_or
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_l
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef WIRELESS_EXT&t;/* If wireless extension exist in the kernel */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write bytes from the Frequency EEprom (frequency select cards).&n; * This is a bit complicated, because the frequency eeprom has to&n; * be unprotected and the write enabled.&n; * Jean II&n; */
r_static
r_void
DECL|function|fee_write
id|fee_write
c_func
(paren
id|u_long
id|base
comma
multiline_comment|/* i/o port of the card */
id|u_short
id|o
comma
multiline_comment|/* destination offset */
id|u_short
op_star
id|b
comma
multiline_comment|/* data buffer */
r_int
id|n
)paren
multiline_comment|/* number of registers */
(brace
id|b
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Position at the end of the area */
macro_line|#ifdef EEPROM_IS_PROTECTED&t;/* disabled */
macro_line|#ifdef DOESNT_SEEM_TO_WORK&t;/* disabled */
multiline_comment|/* Ask to read the protected register */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRREAD
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the protected register */
id|printk
c_func
(paren
l_string|&quot;Protected 2 : %02X-%02X&bslash;n&quot;
comma
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_h
)paren
)paren
comma
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_l
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif&t;/* DOESNT_SEEM_TO_WORK */
multiline_comment|/* Enable protected register */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|MMW_FEE_ADDR_EN
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PREN
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Unprotect area */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|o
op_plus
id|n
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRWRITE
)paren
suffix:semicolon
macro_line|#ifdef DOESNT_SEEM_TO_WORK&t;/* disabled */
multiline_comment|/* Or use : */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRCLEAR
)paren
suffix:semicolon
macro_line|#endif&t;/* DOESNT_SEEM_TO_WORK */
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
macro_line|#endif&t;/* EEPROM_IS_PROTECTED */
multiline_comment|/* Write enable */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|MMW_FEE_ADDR_EN
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_WREN
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Write the EEprom address */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|o
op_plus
id|n
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Loop on all buffer */
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* Write the value */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_data_h
)paren
comma
(paren
op_star
op_decrement
id|b
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_data_l
)paren
comma
op_star
id|b
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* Write the write command */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_WRITE
)paren
suffix:semicolon
multiline_comment|/* Wavelan doc says : wait at least 10 ms for EEBUSY = 0 */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* Write disable */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|MMW_FEE_ADDR_DS
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_WDS
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef EEPROM_IS_PROTECTED&t;/* disabled */
multiline_comment|/* Reprotect EEprom */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
l_int|0x00
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRWRITE
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|base
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
macro_line|#endif&t;/* EEPROM_IS_PROTECTED */
)brace
macro_line|#endif&t;/* WIRELESS_EXT */
multiline_comment|/******************* WaveLAN Roaming routines... ********************/
macro_line|#ifdef WAVELAN_ROAMING&t;/* Conditional compile, see wavelan_cs.h */
DECL|variable|WAVELAN_BEACON_ADDRESS
r_int
r_char
id|WAVELAN_BEACON_ADDRESS
(braket
)braket
op_assign
(brace
l_int|0x09
comma
l_int|0x00
comma
l_int|0x0e
comma
l_int|0x20
comma
l_int|0x03
comma
l_int|0x00
)brace
suffix:semicolon
DECL|function|wv_roam_init
r_void
id|wv_roam_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Do not remove this unless you have a good reason */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Warning, you have enabled roaming on&quot;
l_string|&quot; device %s !&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Roaming is currently an experimental unsuported feature&quot;
l_string|&quot; of the Wavelan driver.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;It may work, but may also make the driver behave in&quot;
l_string|&quot; erratic ways or crash.&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;wavepoint_table.head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialise WavePoint table */
id|lp-&gt;wavepoint_table.num_wavepoints
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;wavepoint_table.locked
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;curr_point
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No default WavePoint */
id|lp-&gt;cell_search
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;cell_timer.data
op_assign
(paren
r_int
)paren
id|lp
suffix:semicolon
multiline_comment|/* Start cell expiry timer */
id|lp-&gt;cell_timer.function
op_assign
id|wl_cell_expiry
suffix:semicolon
id|lp-&gt;cell_timer.expires
op_assign
id|jiffies
op_plus
id|CELL_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;cell_timer
)paren
suffix:semicolon
id|wv_nwid_filter
c_func
(paren
id|NWID_PROMISC
comma
id|lp
)paren
suffix:semicolon
multiline_comment|/* Enter NWID promiscuous mode */
multiline_comment|/* to build up a good WavePoint */
multiline_comment|/* table... */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: Roaming enabled on device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|wv_roam_cleanup
r_void
id|wv_roam_cleanup
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|wavepoint_history
op_star
id|ptr
comma
op_star
id|old_ptr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: Roaming Disabled on device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Fixme : maybe we should check that the timer exist before deleting it */
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;cell_timer
)paren
suffix:semicolon
multiline_comment|/* Remove cell expiry timer       */
id|ptr
op_assign
id|lp-&gt;wavepoint_table.head
suffix:semicolon
multiline_comment|/* Clear device&squot;s WavePoint table */
r_while
c_loop
(paren
id|ptr
op_ne
l_int|NULL
)paren
(brace
id|old_ptr
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|ptr-&gt;next
suffix:semicolon
id|wl_del_wavepoint
c_func
(paren
id|old_ptr
comma
id|lp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Enable/Disable NWID promiscuous mode on a given device */
DECL|function|wv_nwid_filter
r_void
id|wv_nwid_filter
c_func
(paren
r_int
r_char
id|mode
comma
id|net_local
op_star
id|lp
)paren
(brace
id|mm_t
id|m
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef WAVELAN_ROAMING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: NWID promisc %s, device %s&bslash;n&quot;
comma
(paren
id|mode
op_eq
id|NWID_PROMISC
)paren
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
comma
id|lp-&gt;dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable interrupts &amp; save flags */
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|m.w.mmw_loopt_sel
op_assign
(paren
id|mode
op_eq
id|NWID_PROMISC
)paren
ques
c_cond
id|MMW_LOOPT_SEL_DIS_NWID
suffix:colon
l_int|0x00
suffix:semicolon
id|mmc_write
c_func
(paren
id|lp-&gt;dev-&gt;base_addr
comma
(paren
r_char
op_star
)paren
op_amp
id|m.w.mmw_loopt_sel
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.w.mmw_loopt_sel
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* ReEnable interrupts &amp; restore flags */
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|NWID_PROMISC
)paren
(brace
id|lp-&gt;cell_search
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|lp-&gt;cell_search
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find a record in the WavePoint table matching a given NWID */
DECL|function|wl_roam_check
id|wavepoint_history
op_star
id|wl_roam_check
c_func
(paren
r_int
r_int
id|nwid
comma
id|net_local
op_star
id|lp
)paren
(brace
id|wavepoint_history
op_star
id|ptr
op_assign
id|lp-&gt;wavepoint_table.head
suffix:semicolon
r_while
c_loop
(paren
id|ptr
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;nwid
op_eq
id|nwid
)paren
(brace
r_return
id|ptr
suffix:semicolon
)brace
id|ptr
op_assign
id|ptr-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create a new wavepoint table entry */
DECL|function|wl_new_wavepoint
id|wavepoint_history
op_star
id|wl_new_wavepoint
c_func
(paren
r_int
r_int
id|nwid
comma
r_int
r_char
id|seq
comma
id|net_local
op_star
id|lp
)paren
(brace
id|wavepoint_history
op_star
id|new_wavepoint
suffix:semicolon
macro_line|#ifdef WAVELAN_ROAMING_DEBUG&t;
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: New Wavepoint, NWID:%.4X&bslash;n&quot;
comma
id|nwid
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|lp-&gt;wavepoint_table.num_wavepoints
op_eq
id|MAX_WAVEPOINTS
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|new_wavepoint
op_assign
(paren
id|wavepoint_history
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|wavepoint_history
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_wavepoint
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|new_wavepoint-&gt;nwid
op_assign
id|nwid
suffix:semicolon
multiline_comment|/* New WavePoints NWID */
id|new_wavepoint-&gt;average_fast
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Running Averages..*/
id|new_wavepoint-&gt;average_slow
op_assign
l_int|0
suffix:semicolon
id|new_wavepoint-&gt;qualptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start of ringbuffer */
id|new_wavepoint-&gt;last_seq
op_assign
id|seq
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Last sequence no.seen */
id|memset
c_func
(paren
id|new_wavepoint-&gt;sigqual
comma
l_int|0
comma
id|WAVEPOINT_HISTORY
)paren
suffix:semicolon
multiline_comment|/* Empty ringbuffer */
id|new_wavepoint-&gt;next
op_assign
id|lp-&gt;wavepoint_table.head
suffix:semicolon
multiline_comment|/* Add to wavepoint table */
id|new_wavepoint-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;wavepoint_table.head
op_ne
l_int|NULL
)paren
(brace
id|lp-&gt;wavepoint_table.head-&gt;prev
op_assign
id|new_wavepoint
suffix:semicolon
)brace
id|lp-&gt;wavepoint_table.head
op_assign
id|new_wavepoint
suffix:semicolon
id|lp-&gt;wavepoint_table.num_wavepoints
op_increment
suffix:semicolon
multiline_comment|/* no. of visible wavepoints */
r_return
id|new_wavepoint
suffix:semicolon
)brace
multiline_comment|/* Remove a wavepoint entry from WavePoint table */
DECL|function|wl_del_wavepoint
r_void
id|wl_del_wavepoint
c_func
(paren
id|wavepoint_history
op_star
id|wavepoint
comma
r_struct
id|net_local
op_star
id|lp
)paren
(brace
r_if
c_cond
(paren
id|wavepoint
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;curr_point
op_eq
id|wavepoint
)paren
(brace
id|lp-&gt;curr_point
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavepoint-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|wavepoint-&gt;prev-&gt;next
op_assign
id|wavepoint-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavepoint-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|wavepoint-&gt;next-&gt;prev
op_assign
id|wavepoint-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;wavepoint_table.head
op_eq
id|wavepoint
)paren
(brace
id|lp-&gt;wavepoint_table.head
op_assign
id|wavepoint-&gt;next
suffix:semicolon
)brace
id|lp-&gt;wavepoint_table.num_wavepoints
op_decrement
suffix:semicolon
id|kfree
c_func
(paren
id|wavepoint
)paren
suffix:semicolon
)brace
multiline_comment|/* Timer callback function - checks WavePoint table for stale entries */
DECL|function|wl_cell_expiry
r_void
id|wl_cell_expiry
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|data
suffix:semicolon
id|wavepoint_history
op_star
id|wavepoint
op_assign
id|lp-&gt;wavepoint_table.head
comma
op_star
id|old_point
suffix:semicolon
macro_line|#if WAVELAN_ROAMING_DEBUG &gt; 1
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: Wavepoint timeout, dev %s&bslash;n&quot;
comma
id|lp-&gt;dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|lp-&gt;wavepoint_table.locked
)paren
(brace
macro_line|#if WAVELAN_ROAMING_DEBUG &gt; 1
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: Wavepoint table locked...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;cell_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* If table in use, come back later */
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;cell_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wavepoint
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|wavepoint-&gt;last_seen
OL
id|jiffies
op_minus
id|CELL_TIMEOUT
)paren
(brace
macro_line|#ifdef WAVELAN_ROAMING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: Bye bye %.4X&bslash;n&quot;
comma
id|wavepoint-&gt;nwid
)paren
suffix:semicolon
macro_line|#endif
id|old_point
op_assign
id|wavepoint
suffix:semicolon
id|wavepoint
op_assign
id|wavepoint-&gt;next
suffix:semicolon
id|wl_del_wavepoint
c_func
(paren
id|old_point
comma
id|lp
)paren
suffix:semicolon
)brace
r_else
id|wavepoint
op_assign
id|wavepoint-&gt;next
suffix:semicolon
)brace
id|lp-&gt;cell_timer.expires
op_assign
id|jiffies
op_plus
id|CELL_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;cell_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Update SNR history of a wavepoint */
DECL|function|wl_update_history
r_void
id|wl_update_history
c_func
(paren
id|wavepoint_history
op_star
id|wavepoint
comma
r_int
r_char
id|sigqual
comma
r_int
r_char
id|seq
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|num_missed
op_assign
l_int|0
comma
id|ptr
op_assign
l_int|0
suffix:semicolon
r_int
id|average_fast
op_assign
l_int|0
comma
id|average_slow
op_assign
l_int|0
suffix:semicolon
id|num_missed
op_assign
(paren
id|seq
op_minus
id|wavepoint-&gt;last_seq
)paren
op_mod
id|WAVEPOINT_HISTORY
suffix:semicolon
multiline_comment|/* Have we missed&n;&t;&t;&t;&t;&t;&t;&t;    any beacons? */
r_if
c_cond
(paren
id|num_missed
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_missed
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wavepoint-&gt;sigqual
(braket
id|wavepoint-&gt;qualptr
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If so, enter them as 0&squot;s */
id|wavepoint-&gt;qualptr
op_mod_assign
id|WAVEPOINT_HISTORY
suffix:semicolon
multiline_comment|/* in the ringbuffer. */
)brace
id|wavepoint-&gt;last_seen
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Add beacon to history */
id|wavepoint-&gt;last_seq
op_assign
id|seq
suffix:semicolon
id|wavepoint-&gt;sigqual
(braket
id|wavepoint-&gt;qualptr
op_increment
)braket
op_assign
id|sigqual
suffix:semicolon
id|wavepoint-&gt;qualptr
op_mod_assign
id|WAVEPOINT_HISTORY
suffix:semicolon
id|ptr
op_assign
(paren
id|wavepoint-&gt;qualptr
op_minus
id|WAVEPOINT_FAST_HISTORY
op_plus
id|WAVEPOINT_HISTORY
)paren
op_mod
id|WAVEPOINT_HISTORY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WAVEPOINT_FAST_HISTORY
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* Update running averages */
(brace
id|average_fast
op_add_assign
id|wavepoint-&gt;sigqual
(braket
id|ptr
op_increment
)braket
suffix:semicolon
id|ptr
op_mod_assign
id|WAVEPOINT_HISTORY
suffix:semicolon
)brace
id|average_slow
op_assign
id|average_fast
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|WAVEPOINT_FAST_HISTORY
suffix:semicolon
id|i
OL
id|WAVEPOINT_HISTORY
suffix:semicolon
id|i
op_increment
)paren
(brace
id|average_slow
op_add_assign
id|wavepoint-&gt;sigqual
(braket
id|ptr
op_increment
)braket
suffix:semicolon
id|ptr
op_mod_assign
id|WAVEPOINT_HISTORY
suffix:semicolon
)brace
id|wavepoint-&gt;average_fast
op_assign
id|average_fast
op_div
id|WAVEPOINT_FAST_HISTORY
suffix:semicolon
id|wavepoint-&gt;average_slow
op_assign
id|average_slow
op_div
id|WAVEPOINT_HISTORY
suffix:semicolon
)brace
multiline_comment|/* Perform a handover to a new WavePoint */
DECL|function|wv_roam_handover
r_void
id|wv_roam_handover
c_func
(paren
id|wavepoint_history
op_star
id|wavepoint
comma
id|net_local
op_star
id|lp
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|lp-&gt;dev-&gt;base_addr
suffix:semicolon
id|mm_t
id|m
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|wavepoint
op_eq
id|lp-&gt;curr_point
)paren
multiline_comment|/* Sanity check... */
(brace
id|wv_nwid_filter
c_func
(paren
op_logical_neg
id|NWID_PROMISC
comma
id|lp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef WAVELAN_ROAMING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: Doing handover to %.4X, dev %s&bslash;n&quot;
comma
id|wavepoint-&gt;nwid
comma
id|lp-&gt;dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable interrupts &amp; save flags */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|m.w.mmw_netw_id_l
op_assign
id|wavepoint-&gt;nwid
op_amp
l_int|0xFF
suffix:semicolon
id|m.w.mmw_netw_id_h
op_assign
(paren
id|wavepoint-&gt;nwid
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
suffix:semicolon
id|mmc_write
c_func
(paren
id|base
comma
(paren
r_char
op_star
)paren
op_amp
id|m.w.mmw_netw_id_l
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.w.mmw_netw_id_l
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* ReEnable interrupts &amp; restore flags */
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|wv_nwid_filter
c_func
(paren
op_logical_neg
id|NWID_PROMISC
comma
id|lp
)paren
suffix:semicolon
id|lp-&gt;curr_point
op_assign
id|wavepoint
suffix:semicolon
)brace
multiline_comment|/* Called when a WavePoint beacon is received */
DECL|function|wl_roam_gather
r_static
r_inline
r_void
id|wl_roam_gather
c_func
(paren
id|device
op_star
id|dev
comma
id|u_char
op_star
id|hdr
comma
multiline_comment|/* Beacon header */
id|u_char
op_star
id|stats
)paren
multiline_comment|/* SNR, Signal quality &n;&t;&t;&t;&t;&t;&t;      of packet */
(brace
id|wavepoint_beacon
op_star
id|beacon
op_assign
(paren
id|wavepoint_beacon
op_star
)paren
id|hdr
suffix:semicolon
multiline_comment|/* Rcvd. Beacon */
r_int
r_int
id|nwid
op_assign
id|ntohs
c_func
(paren
id|beacon-&gt;nwid
)paren
suffix:semicolon
r_int
r_int
id|sigqual
op_assign
id|stats
(braket
l_int|2
)braket
op_amp
id|MMR_SGNL_QUAL
suffix:semicolon
multiline_comment|/* SNR of beacon */
id|wavepoint_history
op_star
id|wavepoint
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* WavePoint table entry */
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Device info */
macro_line|#if WAVELAN_ROAMING_DEBUG &gt; 1
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN: beacon, dev %s:&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Domain: %.4X NWID: %.4X SigQual=%d&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|beacon-&gt;domain_id
)paren
comma
id|nwid
comma
id|sigqual
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;wavepoint_table.locked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &lt;Mutex&gt; */
id|wavepoint
op_assign
id|wl_roam_check
c_func
(paren
id|nwid
comma
id|lp
)paren
suffix:semicolon
multiline_comment|/* Find WavePoint table entry */
r_if
c_cond
(paren
id|wavepoint
op_eq
l_int|NULL
)paren
multiline_comment|/* If no entry, Create a new one... */
(brace
id|wavepoint
op_assign
id|wl_new_wavepoint
c_func
(paren
id|nwid
comma
id|beacon-&gt;seq
comma
id|lp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavepoint
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lp-&gt;curr_point
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If this is the only WavePoint, */
id|wv_roam_handover
c_func
(paren
id|wavepoint
comma
id|lp
)paren
suffix:semicolon
)brace
multiline_comment|/* Jump on it! */
id|wl_update_history
c_func
(paren
id|wavepoint
comma
id|sigqual
comma
id|beacon-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Update SNR history&n;&t;&t;&t;&t;&t;&t;&t; stats. */
r_if
c_cond
(paren
id|lp-&gt;curr_point-&gt;average_slow
OL
id|SEARCH_THRESH_LOW
)paren
multiline_comment|/* If our current */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;cell_search
)paren
(brace
multiline_comment|/* WavePoint is getting faint, */
id|wv_nwid_filter
c_func
(paren
id|NWID_PROMISC
comma
id|lp
)paren
suffix:semicolon
)brace
multiline_comment|/* start looking for a new one */
r_if
c_cond
(paren
id|wavepoint-&gt;average_slow
OG
id|lp-&gt;curr_point-&gt;average_slow
op_plus
id|WAVELAN_ROAMING_DELTA
)paren
(brace
id|wv_roam_handover
c_func
(paren
id|wavepoint
comma
id|lp
)paren
suffix:semicolon
)brace
multiline_comment|/* Handover to a better WavePoint */
r_if
c_cond
(paren
id|lp-&gt;curr_point-&gt;average_slow
OG
id|SEARCH_THRESH_HIGH
)paren
multiline_comment|/* If our SNR is */
r_if
c_cond
(paren
id|lp-&gt;cell_search
)paren
(brace
multiline_comment|/* getting better, drop out of cell search mode */
id|wv_nwid_filter
c_func
(paren
op_logical_neg
id|NWID_PROMISC
comma
id|lp
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|lp-&gt;wavepoint_table.locked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &lt;/MUTEX&gt;   :-) */
)brace
multiline_comment|/* Test this MAC frame a WavePoint beacon */
DECL|function|WAVELAN_BEACON
r_static
r_inline
r_int
id|WAVELAN_BEACON
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
id|wavepoint_beacon
op_star
id|beacon
op_assign
(paren
id|wavepoint_beacon
op_star
)paren
id|data
suffix:semicolon
r_static
id|wavepoint_beacon
id|beacon_template
op_assign
initialization_block
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|beacon
comma
op_amp
id|beacon_template
comma
l_int|9
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* WAVELAN_ROAMING */
multiline_comment|/************************ I82593 SUBROUTINES *************************/
multiline_comment|/*&n; * Usefull subroutines to manage the Ethernet controler&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to synchronously send a command to the i82593 chip. &n; * Should be called with interrupts enabled.&n; */
r_static
r_int
DECL|function|wv_82593_cmd
id|wv_82593_cmd
c_func
(paren
id|device
op_star
id|dev
comma
r_char
op_star
id|str
comma
r_int
id|cmd
comma
r_int
id|result
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|spin
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
multiline_comment|/* Spin until the chip finishes executing its current command (if any) */
r_do
(brace
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP0_NOP
op_or
id|CR0_STATUS_3
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_amp
id|SR3_EXEC_STATE_MASK
)paren
op_ne
id|SR3_EXEC_IDLE
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* We are waiting for command completion */
id|wv_wait_completed
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Issue the command to the controler */
id|outb
c_func
(paren
id|cmd
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* If we don&squot;t have to check the result of the command */
r_if
c_cond
(paren
id|result
op_eq
id|SR0_NO_RESULT
)paren
(brace
id|wv_wait_completed
op_assign
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Busy wait while the LAN controller executes the command.&n;   * Note : wv_wait_completed should be volatile */
id|spin
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|wv_wait_completed
op_logical_and
(paren
id|spin
op_increment
OL
l_int|1000
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* If the interrupt handler hasn&squot;t be called */
r_if
c_cond
(paren
id|wv_wait_completed
)paren
(brace
id|outb
c_func
(paren
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|SR0_INTERRUPT
)paren
(brace
multiline_comment|/* There was an interrupt : call the interrupt handler */
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;wv_82593_cmd: interrupt handler not installed or interrupt disabled&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|wavelan_interrupt
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|dev
comma
(paren
r_struct
id|pt_regs
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|wv_wait_completed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX */
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wv_82593_cmd: %s timeout, status0 0x%02x&bslash;n&quot;
comma
id|str
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We probably should reset the controller here */
r_return
id|FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/* Check the return code provided by the interrupt handler against&n;   * the expected return code provided by the caller */
r_if
c_cond
(paren
(paren
id|lp-&gt;status
op_amp
id|SR0_EVENT_MASK
)paren
op_ne
id|result
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wv_82593_cmd: %s failed, status0 = 0x%x&bslash;n&quot;
comma
id|str
comma
id|lp-&gt;status
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* wv_82593_cmd */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine does a 593 op-code number 7, and obtains the diagnose&n; * status for the WaveLAN.&n; */
r_static
r_inline
r_int
DECL|function|wv_diag
id|wv_diag
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_diag(): diagnose&quot;
comma
id|OP0_DIAGNOSE
comma
id|SR0_DIAGNOSE_PASSED
)paren
)paren
(brace
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wavelan_cs: i82593 Self Test failed!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* wv_diag */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to read len bytes from the i82593&squot;s ring buffer, starting at&n; * chip address addr. The results read from the chip are stored in buf.&n; * The return value is the address to use for next the call.&n; */
r_static
r_int
DECL|function|read_ringbuf
id|read_ringbuf
c_func
(paren
id|device
op_star
id|dev
comma
r_int
id|addr
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|ring_ptr
op_assign
id|addr
suffix:semicolon
r_int
id|chunk_len
suffix:semicolon
r_char
op_star
id|buf_ptr
op_assign
id|buf
suffix:semicolon
macro_line|#ifdef OLDIES
multiline_comment|/* After having check skb_put (net/core/skbuff.c) in the kernel, it seem&n;   * quite safe to remove this... */
multiline_comment|/* If buf is NULL, just increment the ring buffer pointer */
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
id|ring_ptr
op_minus
id|RX_BASE
op_plus
id|len
)paren
op_mod
id|RX_SIZE
op_plus
id|RX_BASE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Get all the buffer */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
multiline_comment|/* Position the Program I/O Register at the ring buffer pointer */
id|outb
c_func
(paren
id|ring_ptr
op_amp
l_int|0xff
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|ring_ptr
op_rshift
l_int|8
)paren
op_amp
id|PIORH_MASK
)paren
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* First, determine how much we can read without wrapping around the&n;&t; ring buffer */
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|len
)paren
OL
(paren
id|RX_BASE
op_plus
id|RX_SIZE
)paren
)paren
(brace
id|chunk_len
op_assign
id|len
suffix:semicolon
)brace
r_else
id|chunk_len
op_assign
id|RX_BASE
op_plus
id|RX_SIZE
op_minus
id|addr
suffix:semicolon
id|insb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
comma
id|buf_ptr
comma
id|chunk_len
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|chunk_len
suffix:semicolon
id|len
op_sub_assign
id|chunk_len
suffix:semicolon
id|ring_ptr
op_assign
(paren
id|ring_ptr
op_minus
id|RX_BASE
op_plus
id|chunk_len
)paren
op_mod
id|RX_SIZE
op_plus
id|RX_BASE
suffix:semicolon
)brace
r_return
id|ring_ptr
suffix:semicolon
)brace
multiline_comment|/* read_ringbuf */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Reconfigure the i82593, or at least ask for it...&n; * Because wv_82593_config use the transmission buffer, we must do it&n; * when we are sure that there is no transmission, so we do it now&n; * or in wavelan_packet_xmit() (I can&squot;t find any better place,&n; * wavelan_interrupt is not an option...), so you may experience&n; * some delay sometime...&n; */
DECL|function|wv_82593_reconfig
r_static
r_inline
r_void
id|wv_82593_reconfig
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|dev_link_t
op_star
id|link
op_assign
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|link
suffix:semicolon
multiline_comment|/* Check if we can do it now ! */
r_if
c_cond
(paren
op_logical_neg
(paren
id|link-&gt;open
)paren
)paren
(brace
id|lp-&gt;reconfig_82593
op_assign
id|TRUE
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_82593_reconfig(): delayed (link = %d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|link-&gt;open
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;reconfig_82593
op_assign
id|FALSE
suffix:semicolon
id|wv_82593_config
(paren
id|dev
)paren
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef OLDIES
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Dumps the current i82593 receive buffer to the console.&n; */
DECL|function|wavelan_dump
r_static
r_void
id|wavelan_dump
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
multiline_comment|/* disable receiver so we can use channel 1 */
id|outb
c_func
(paren
id|OP0_RCV_DISABLE
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* reset receive DMA pointer */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_RX_DMA_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
multiline_comment|/* dump into receive buffer */
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wavelan_dump(): dump&quot;
comma
id|CR0_CHNL
op_or
id|OP0_DUMP
comma
id|SR0_DUMP_DONE
)paren
suffix:semicolon
multiline_comment|/* set read pointer to start of receive buffer */
id|outb
c_func
(paren
l_int|0
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wavelan_cs: dump:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;     00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|73
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n0x%02x:&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;   &quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|c
op_assign
id|inb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* enable the receiver again */
id|wv_ru_start
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/********************* DEBUG &amp; INFO SUBROUTINES *********************/
multiline_comment|/*&n; * This routines are used in the code to show debug informations.&n; * Most of the time, it dump the content of hardware structures...&n; */
macro_line|#ifdef DEBUG_PSA_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted contents of the Parameter Storage Area.&n; */
r_static
r_void
DECL|function|wv_psa_show
id|wv_psa_show
c_func
(paren
id|psa_t
op_star
id|p
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### wavelan psa contents: #####&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_io_base_addr_1: 0x%02X %02X %02X %02X&bslash;n&quot;
comma
id|p-&gt;psa_io_base_addr_1
comma
id|p-&gt;psa_io_base_addr_2
comma
id|p-&gt;psa_io_base_addr_3
comma
id|p-&gt;psa_io_base_addr_4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_rem_boot_addr_1: 0x%02X %02X %02X&bslash;n&quot;
comma
id|p-&gt;psa_rem_boot_addr_1
comma
id|p-&gt;psa_rem_boot_addr_2
comma
id|p-&gt;psa_rem_boot_addr_3
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_holi_params: 0x%02x, &quot;
comma
id|p-&gt;psa_holi_params
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_int_req_no: %d&bslash;n&quot;
comma
id|p-&gt;psa_int_req_no
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_unused0[]: %02X:%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|p-&gt;psa_unused0
(braket
l_int|0
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|1
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|2
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|3
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|4
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|5
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|6
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_univ_mac_addr[]: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|0
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|1
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|2
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|3
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|4
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_local_mac_addr[]: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|0
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|1
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|2
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|3
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|4
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_univ_local_sel: %d, &quot;
comma
id|p-&gt;psa_univ_local_sel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_comp_number: %d, &quot;
comma
id|p-&gt;psa_comp_number
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_thr_pre_set: 0x%02x&bslash;n&quot;
comma
id|p-&gt;psa_thr_pre_set
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_feature_select/decay_prm: 0x%02x, &quot;
comma
id|p-&gt;psa_feature_select
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_subband/decay_update_prm: %d&bslash;n&quot;
comma
id|p-&gt;psa_subband
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_quality_thr: 0x%02x, &quot;
comma
id|p-&gt;psa_quality_thr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_mod_delay: 0x%02x&bslash;n&quot;
comma
id|p-&gt;psa_mod_delay
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_nwid: 0x%02x%02x, &quot;
comma
id|p-&gt;psa_nwid
(braket
l_int|0
)braket
comma
id|p-&gt;psa_nwid
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_nwid_select: %d&bslash;n&quot;
comma
id|p-&gt;psa_nwid_select
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_encryption_select: %d, &quot;
comma
id|p-&gt;psa_encryption_select
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_encryption_key[]: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|p-&gt;psa_encryption_key
(braket
l_int|0
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|1
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|2
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|3
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|4
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|5
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|6
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_databus_width: %d&bslash;n&quot;
comma
id|p-&gt;psa_databus_width
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_call_code/auto_squelch: 0x%02x, &quot;
comma
id|p-&gt;psa_call_code
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_call_code[]: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|p-&gt;psa_call_code
(braket
l_int|0
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|1
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|2
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|3
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|4
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|5
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|6
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_reserved[]: %02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|p-&gt;psa_reserved
(braket
l_int|0
)braket
comma
id|p-&gt;psa_reserved
(braket
l_int|1
)braket
comma
id|p-&gt;psa_reserved
(braket
l_int|2
)braket
comma
id|p-&gt;psa_reserved
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_conf_status: %d, &quot;
comma
id|p-&gt;psa_conf_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_crc: 0x%02x%02x, &quot;
comma
id|p-&gt;psa_crc
(braket
l_int|0
)braket
comma
id|p-&gt;psa_crc
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_crc_status: 0x%02x&bslash;n&quot;
comma
id|p-&gt;psa_crc_status
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_psa_show */
macro_line|#endif&t;/* DEBUG_PSA_SHOW */
macro_line|#ifdef DEBUG_MMC_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the Modem Management Controller.&n; * This function need to be completed...&n; */
r_static
r_void
DECL|function|wv_mmc_show
id|wv_mmc_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mmr_t
id|m
suffix:semicolon
multiline_comment|/* Basic check */
r_if
c_cond
(paren
id|hasr_read
c_func
(paren
id|base
)paren
op_amp
id|HASR_NO_CLK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wv_mmc_show: modem not connected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read the mmc */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|base
comma
l_int|0
comma
(paren
id|u_char
op_star
)paren
op_amp
id|m
comma
r_sizeof
(paren
id|m
)paren
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef WIRELESS_EXT&t;/* If wireless extension exist in the kernel */
multiline_comment|/* Don&squot;t forget to update statistics */
id|lp-&gt;wstats.discard.nwid
op_add_assign
(paren
id|m.mmr_wrong_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_wrong_nwid_l
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### wavelan modem status registers: #####&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmc_unused0[]: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|m.mmr_unused0
(braket
l_int|0
)braket
comma
id|m.mmr_unused0
(braket
l_int|1
)braket
comma
id|m.mmr_unused0
(braket
l_int|2
)braket
comma
id|m.mmr_unused0
(braket
l_int|3
)braket
comma
id|m.mmr_unused0
(braket
l_int|4
)braket
comma
id|m.mmr_unused0
(braket
l_int|5
)braket
comma
id|m.mmr_unused0
(braket
l_int|6
)braket
comma
id|m.mmr_unused0
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Encryption algorythm: %02X - Status: %02X&bslash;n&quot;
comma
id|m.mmr_des_avail
comma
id|m.mmr_des_status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmc_unused1[]: %02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|m.mmr_unused1
(braket
l_int|0
)braket
comma
id|m.mmr_unused1
(braket
l_int|1
)braket
comma
id|m.mmr_unused1
(braket
l_int|2
)braket
comma
id|m.mmr_unused1
(braket
l_int|3
)braket
comma
id|m.mmr_unused1
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dce_status: 0x%x [%s%s%s%s]&bslash;n&quot;
comma
id|m.mmr_dce_status
comma
(paren
id|m.mmr_dce_status
op_amp
id|MMR_DCE_STATUS_RX_BUSY
)paren
ques
c_cond
l_string|&quot;energy detected,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|m.mmr_dce_status
op_amp
id|MMR_DCE_STATUS_LOOPT_IND
)paren
ques
c_cond
l_string|&quot;loop test indicated,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|m.mmr_dce_status
op_amp
id|MMR_DCE_STATUS_TX_BUSY
)paren
ques
c_cond
l_string|&quot;transmitter on,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|m.mmr_dce_status
op_amp
id|MMR_DCE_STATUS_JBR_EXPIRED
)paren
ques
c_cond
l_string|&quot;jabber timer expired,&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Dsp ID: %02X&bslash;n&quot;
comma
id|m.mmr_dsp_id
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmc_unused2[]: %02X:%02X&bslash;n&quot;
comma
id|m.mmr_unused2
(braket
l_int|0
)braket
comma
id|m.mmr_unused2
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;# correct_nwid: %d, # wrong_nwid: %d&bslash;n&quot;
comma
(paren
id|m.mmr_correct_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_correct_nwid_l
comma
(paren
id|m.mmr_wrong_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_wrong_nwid_l
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;thr_pre_set: 0x%x [current signal %s]&bslash;n&quot;
comma
id|m.mmr_thr_pre_set
op_amp
id|MMR_THR_PRE_SET
comma
(paren
id|m.mmr_thr_pre_set
op_amp
id|MMR_THR_PRE_SET_CUR
)paren
ques
c_cond
l_string|&quot;above&quot;
suffix:colon
l_string|&quot;below&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;signal_lvl: %d [%s], &quot;
comma
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL
comma
(paren
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL_VALID
)paren
ques
c_cond
l_string|&quot;new msg&quot;
suffix:colon
l_string|&quot;no new msg&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;silence_lvl: %d [%s], &quot;
comma
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL
comma
(paren
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL_VALID
)paren
ques
c_cond
l_string|&quot;update done&quot;
suffix:colon
l_string|&quot;no new update&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sgnl_qual: 0x%x [%s]&bslash;n&quot;
comma
id|m.mmr_sgnl_qual
op_amp
id|MMR_SGNL_QUAL
comma
(paren
id|m.mmr_sgnl_qual
op_amp
id|MMR_SGNL_QUAL_ANT
)paren
ques
c_cond
l_string|&quot;Antenna 1&quot;
suffix:colon
l_string|&quot;Antenna 0&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;netw_id_l: %x&bslash;n&quot;
comma
id|m.mmr_netw_id_l
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_SHOW_UNUSED */
)brace
multiline_comment|/* wv_mmc_show */
macro_line|#endif&t;/* DEBUG_MMC_SHOW */
macro_line|#ifdef DEBUG_I82593_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the i82593&squot;s receive unit.&n; */
r_static
r_void
DECL|function|wv_ru_show
id|wv_ru_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### wavelan i82593 receiver status: #####&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ru: rfp %d stop %d&quot;
comma
id|lp-&gt;rfp
comma
id|lp-&gt;stop
)paren
suffix:semicolon
multiline_comment|/*&n;   * Not implemented yet...&n;   */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_ru_show */
macro_line|#endif&t;/* DEBUG_I82593_SHOW */
macro_line|#ifdef DEBUG_DEVICE_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the WaveLAN PCMCIA device driver.&n; */
r_static
r_void
DECL|function|wv_dev_show
id|wv_dev_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dev:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; trans_start=%ld,&quot;
comma
id|dev-&gt;trans_start
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; flags=0x%x,&quot;
comma
id|dev-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_dev_show */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the WaveLAN PCMCIA device driver&squot;s&n; * private information.&n; */
r_static
r_void
DECL|function|wv_local_show
id|wv_local_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
suffix:semicolon
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;local:&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Not implemented yet...&n;   */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_local_show */
macro_line|#endif&t;/* DEBUG_DEVICE_SHOW */
macro_line|#if defined(DEBUG_RX_INFO) || defined(DEBUG_TX_INFO)
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Dump packet header (and content if necessary) on the screen&n; */
r_static
r_inline
r_void
DECL|function|wv_packet_info
id|wv_packet_info
c_func
(paren
id|u_char
op_star
id|p
comma
multiline_comment|/* Packet to dump */
r_int
id|length
comma
multiline_comment|/* Length of the packet */
r_char
op_star
id|msg1
comma
multiline_comment|/* Name of the device */
r_char
op_star
id|msg2
)paren
multiline_comment|/* Name of the function */
(brace
r_int
id|i
suffix:semicolon
r_int
id|maxi
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s(): dest %02X:%02X:%02X:%02X:%02X:%02X, length %d&bslash;n&quot;
comma
id|msg1
comma
id|msg2
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
comma
id|p
(braket
l_int|2
)braket
comma
id|p
(braket
l_int|3
)braket
comma
id|p
(braket
l_int|4
)braket
comma
id|p
(braket
l_int|5
)braket
comma
id|length
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s(): src %02X:%02X:%02X:%02X:%02X:%02X, type 0x%02X%02X&bslash;n&quot;
comma
id|msg1
comma
id|msg2
comma
id|p
(braket
l_int|6
)braket
comma
id|p
(braket
l_int|7
)braket
comma
id|p
(braket
l_int|8
)braket
comma
id|p
(braket
l_int|9
)braket
comma
id|p
(braket
l_int|10
)braket
comma
id|p
(braket
l_int|11
)braket
comma
id|p
(braket
l_int|12
)braket
comma
id|p
(braket
l_int|13
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PACKET_DUMP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;data=&bslash;&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|maxi
op_assign
id|length
)paren
OG
id|DEBUG_PACKET_DUMP
)paren
(brace
id|maxi
op_assign
id|DEBUG_PACKET_DUMP
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|14
suffix:semicolon
id|i
OL
id|maxi
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
op_ge
l_char|&squot; &squot;
op_logical_and
id|p
(braket
id|i
)braket
op_le
l_char|&squot;~&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %c&quot;
comma
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%02X&quot;
comma
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxi
OL
id|length
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;..&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_PACKET_DUMP */
)brace
macro_line|#endif&t;/* defined(DEBUG_RX_INFO) || defined(DEBUG_TX_INFO) */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This is the information which is displayed by the driver at startup&n; * There  is a lot of flag to configure it at your will...&n; */
r_static
r_inline
r_void
DECL|function|wv_init_info
id|wv_init_info
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|psa_t
id|psa
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Read the parameter storage area */
id|psa_read
c_func
(paren
id|dev
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PSA_SHOW
id|wv_psa_show
c_func
(paren
op_amp
id|psa
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_MMC_SHOW
id|wv_mmc_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_I82593_SHOW
id|wv_ru_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_BASIC_SHOW
multiline_comment|/* Now, let&squot;s go for the basic stuff */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: WaveLAN: port %#x, irq %d, hw_addr&quot;
comma
id|dev-&gt;name
comma
id|base
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WAVELAN_ADDR_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%02X&quot;
comma
(paren
id|i
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Print current network id */
r_if
c_cond
(paren
id|psa.psa_nwid_select
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, nwid 0x%02X-%02X&quot;
comma
id|psa.psa_nwid
(braket
l_int|0
)braket
comma
id|psa.psa_nwid
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, nwid off&quot;
)paren
suffix:semicolon
multiline_comment|/* If 2.00 card */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
r_int
r_int
id|freq
suffix:semicolon
multiline_comment|/* Ask the EEprom to read the frequency from the first area */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x00
multiline_comment|/* 1st area - frequency... */
comma
op_amp
id|freq
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Print frequency */
id|printk
c_func
(paren
l_string|&quot;, 2.00, %ld&quot;
comma
(paren
id|freq
op_rshift
l_int|6
)paren
op_plus
l_int|2400L
)paren
suffix:semicolon
multiline_comment|/* Hack !!! */
r_if
c_cond
(paren
id|freq
op_amp
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;.5&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, PCMCIA, &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|psa.psa_subband
)paren
(brace
r_case
id|PSA_SUBBAND_915
suffix:colon
id|printk
c_func
(paren
l_string|&quot;915&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2425
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2425&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2460
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2460&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2484
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2484&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2430_5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2430.5&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;???&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; MHz&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_BASIC_SHOW */
macro_line|#ifdef DEBUG_VERSION_SHOW
multiline_comment|/* Print version information */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* wv_init_info */
multiline_comment|/********************* IOCTL, STATS &amp; RECONFIG *********************/
multiline_comment|/*&n; * We found here routines that are called by Linux on differents&n; * occasions after the configuration and not for transmitting data&n; * These may be called when the user use ifconfig, /proc/net/dev&n; * or wireless extensions&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get the current ethernet statistics. This may be called with the&n; * card open or closed.&n; * Used when the user read /proc/net/dev&n; */
r_static
id|en_stats
op_star
DECL|function|wavelan_get_stats
id|wavelan_get_stats
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;&gt;wavelan_get_stats()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_amp
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set or clear the multicast filter for this adaptor.&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
r_static
r_void
DECL|function|wavelan_set_multicast_list
id|wavelan_set_multicast_list
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_set_multicast_list()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_set_multicast_list(): setting Rx mode %02X to %d addresses.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;flags
comma
id|dev-&gt;mc_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/*&n;       * Enable promiscuous mode: receive all packets.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;promiscuous
)paren
(brace
id|lp-&gt;promiscuous
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;allmulticast
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
id|wv_82593_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Tell the kernel that we are doing a really bad job... */
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* If all multicast addresses&n;     * or too much multicast addresses for the hardware filter */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
(paren
id|dev-&gt;mc_count
OG
id|I82593_MAX_MULTICAST_ADDRESSES
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Disable promiscuous mode, but active the all multicast mode&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;allmulticast
)paren
(brace
id|lp-&gt;promiscuous
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;allmulticast
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
id|wv_82593_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Tell the kernel that we are doing a really bad job... */
id|dev-&gt;flags
op_or_assign
id|IFF_ALLMULTI
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* If there is some multicast addresses to send */
r_if
c_cond
(paren
id|dev-&gt;mc_list
op_ne
(paren
r_struct
id|dev_mc_list
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;   * Disable promiscuous mode, but receive all packets&n;&t;   * in multicast list&n;&t;   */
macro_line|#ifdef MULTICAST_AVOID
r_if
c_cond
(paren
id|lp-&gt;promiscuous
op_logical_or
id|lp-&gt;allmulticast
op_logical_or
(paren
id|dev-&gt;mc_count
op_ne
id|lp-&gt;mc_count
)paren
)paren
macro_line|#endif
(brace
id|lp-&gt;promiscuous
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;allmulticast
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mc_count
op_assign
id|dev-&gt;mc_count
suffix:semicolon
id|wv_82593_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;   * Switch to normal mode: disable promiscuous mode and &n;&t;   * clear the multicast list.&n;&t;   */
r_if
c_cond
(paren
id|lp-&gt;promiscuous
op_logical_or
id|lp-&gt;mc_count
op_eq
l_int|0
)paren
(brace
id|lp-&gt;promiscuous
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;allmulticast
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
id|wv_82593_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_set_multicast_list()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This function doesn&squot;t exist...&n; * (Note : it was a nice way to test the reconfigure stuff...)&n; */
macro_line|#ifdef SET_MAC_ADDRESS
r_static
r_int
DECL|function|wavelan_set_mac_address
id|wavelan_set_mac_address
c_func
(paren
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|sockaddr
op_star
id|mac
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Copy the address */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|mac-&gt;sa_data
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
multiline_comment|/* Reconfig the beast */
id|wv_82593_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SET_MAC_ADDRESS */
macro_line|#ifdef WIRELESS_EXT&t;/* If wireless extension exist in the kernel */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Frequency setting (for hardware able of it)&n; * It&squot;s a bit complicated and you don&squot;t really want to look into it...&n; * (called in wavelan_ioctl)&n; */
r_static
r_inline
r_int
DECL|function|wv_set_frequency
id|wv_set_frequency
c_func
(paren
id|u_long
id|base
comma
multiline_comment|/* i/o port of the card */
id|iw_freq
op_star
id|frequency
)paren
(brace
r_const
r_int
id|BAND_NUM
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Number of bands */
r_int
id|freq
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* offset to 2.4 GHz in .5 MHz */
macro_line|#ifdef DEBUG_IOCTL_INFO
r_int
id|i
suffix:semicolon
macro_line|#endif
multiline_comment|/* Setting by frequency */
multiline_comment|/* Theoritically, you may set any frequency between&n;   * the two limits with a 0.5 MHz precision. In practice,&n;   * I don&squot;t want you to have trouble with local&n;   * regulations... */
r_if
c_cond
(paren
(paren
id|frequency-&gt;e
op_eq
l_int|1
)paren
op_logical_and
(paren
id|frequency-&gt;m
op_ge
(paren
r_int
)paren
l_float|2.412e8
)paren
op_logical_and
(paren
id|frequency-&gt;m
op_le
(paren
r_int
)paren
l_float|2.487e8
)paren
)paren
(brace
id|freq
op_assign
(paren
(paren
id|frequency-&gt;m
op_div
l_int|10000
)paren
op_minus
l_int|24000L
)paren
op_div
l_int|5
suffix:semicolon
)brace
multiline_comment|/* Setting by channel (same as wfreqsel) */
multiline_comment|/* Warning : each channel is 22MHz wide, so some of the channels&n;   * will interfere... */
r_if
c_cond
(paren
(paren
id|frequency-&gt;e
op_eq
l_int|0
)paren
op_logical_and
(paren
id|frequency-&gt;m
op_ge
l_int|0
)paren
op_logical_and
(paren
id|frequency-&gt;m
OL
id|BAND_NUM
)paren
)paren
(brace
multiline_comment|/* Get frequency offset. */
id|freq
op_assign
id|channel_bands
(braket
id|frequency-&gt;m
)braket
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Verify if the frequency is allowed */
r_if
c_cond
(paren
id|freq
op_ne
l_int|0L
)paren
(brace
id|u_short
id|table
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Authorized frequency table */
multiline_comment|/* Read the frequency table */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x71
multiline_comment|/* frequency table */
comma
id|table
comma
l_int|10
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Frequency table :&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %04X&quot;
comma
id|table
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Look in the table if the frequency is allowed */
r_if
c_cond
(paren
op_logical_neg
(paren
id|table
(braket
l_int|9
op_minus
(paren
(paren
id|freq
op_minus
l_int|24
)paren
op_div
l_int|16
)paren
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
(paren
id|freq
op_minus
l_int|24
)paren
op_mod
l_int|16
)paren
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* not allowed */
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* If we get a usable frequency */
r_if
c_cond
(paren
id|freq
op_ne
l_int|0L
)paren
(brace
r_int
r_int
id|area
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|dac
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|area_verify
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|dac_verify
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Corresponding gain (in the power adjust value table)&n;       * see AT&amp;T Wavelan Data Manual, REF 407-024689/E, page 3-8&n;       * &amp; WCIN062D.DOC, page 6.2.9 */
r_int
r_int
id|power_limit
(braket
)braket
op_assign
(brace
l_int|40
comma
l_int|80
comma
l_int|120
comma
l_int|160
comma
l_int|0
)brace
suffix:semicolon
r_int
id|power_band
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Selected band */
r_int
r_int
id|power_adjust
suffix:semicolon
multiline_comment|/* Correct value */
multiline_comment|/* Search for the gain */
id|power_band
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|freq
OG
id|power_limit
(braket
id|power_band
)braket
)paren
op_logical_and
(paren
id|power_limit
(braket
op_increment
id|power_band
)braket
op_ne
l_int|0
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Read the first area */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x00
comma
id|area
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Read the DAC */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x60
comma
id|dac
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Read the new power adjust value */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x6B
op_minus
(paren
id|power_band
op_rshift
l_int|1
)paren
comma
op_amp
id|power_adjust
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|power_band
op_amp
l_int|0x1
)paren
(brace
id|power_adjust
op_rshift_assign
l_int|8
suffix:semicolon
)brace
r_else
id|power_adjust
op_and_assign
l_int|0xFF
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Wavelan EEprom Area 1 :&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %04X&quot;
comma
id|area
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Wavelan EEprom DAC : %04X %04X&bslash;n&quot;
comma
id|dac
(braket
l_int|0
)braket
comma
id|dac
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Frequency offset (for info only...) */
id|area
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|freq
op_lshift
l_int|5
)paren
op_amp
l_int|0xFFE0
)paren
op_or
(paren
id|area
(braket
l_int|0
)braket
op_amp
l_int|0x1F
)paren
suffix:semicolon
multiline_comment|/* Receiver Principle main divider coefficient */
id|area
(braket
l_int|3
)braket
op_assign
(paren
id|freq
op_rshift
l_int|1
)paren
op_plus
l_int|2400L
op_minus
l_int|352L
suffix:semicolon
id|area
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|freq
op_amp
l_int|0x1
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|area
(braket
l_int|2
)braket
op_amp
l_int|0xFFEF
)paren
suffix:semicolon
multiline_comment|/* Transmitter Main divider coefficient */
id|area
(braket
l_int|13
)braket
op_assign
(paren
id|freq
op_rshift
l_int|1
)paren
op_plus
l_int|2400L
suffix:semicolon
id|area
(braket
l_int|12
)braket
op_assign
(paren
(paren
id|freq
op_amp
l_int|0x1
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|area
(braket
l_int|2
)braket
op_amp
l_int|0xFFEF
)paren
suffix:semicolon
multiline_comment|/* Others part of the area are flags, bit streams or unused... */
multiline_comment|/* Set the value in the DAC */
id|dac
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|power_adjust
op_rshift
l_int|1
)paren
op_amp
l_int|0x7F
)paren
op_or
(paren
id|dac
(braket
l_int|1
)braket
op_amp
l_int|0xFF80
)paren
suffix:semicolon
id|dac
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|power_adjust
op_amp
l_int|0x1
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|dac
(braket
l_int|0
)braket
op_amp
l_int|0xFFEF
)paren
suffix:semicolon
multiline_comment|/* Write the first area */
id|fee_write
c_func
(paren
id|base
comma
l_int|0x00
comma
id|area
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Write the DAC */
id|fee_write
c_func
(paren
id|base
comma
l_int|0x60
comma
id|dac
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* We now should verify here that the EEprom writting was ok */
multiline_comment|/* ReRead the first area */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x00
comma
id|area_verify
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* ReRead the DAC */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x60
comma
id|dac_verify
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Compare */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|area
comma
id|area_verify
comma
l_int|16
op_star
l_int|2
)paren
op_logical_or
id|memcmp
c_func
(paren
id|dac
comma
id|dac_verify
comma
l_int|2
op_star
l_int|2
)paren
)paren
(brace
macro_line|#ifdef DEBUG_IOCTL_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Wavelan: wv_set_frequency : unable to write new frequency to EEprom (??)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* We must download the frequency parameters to the&n;       * synthetisers (from the EEprom - area 1)&n;       * Note : as the EEprom is auto decremented, we set the end&n;       * if the area... */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
l_int|0x0F
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished */
id|fee_wait
c_func
(paren
id|base
comma
l_int|100
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* We must now download the power adjust value (gain) to&n;       * the synthetisers (from the EEprom - area 7 - DAC) */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
l_int|0x61
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished */
id|fee_wait
c_func
(paren
id|base
comma
l_int|100
comma
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
multiline_comment|/* Verification of what we have done... */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Wavelan EEprom Area 1 :&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %04X&quot;
comma
id|area_verify
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Wavelan EEprom DAC : %04X %04X&bslash;n&quot;
comma
id|dac_verify
(braket
l_int|0
)braket
comma
id|dac_verify
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Bah, never get there... */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Give the list of available frequencies&n; */
r_static
r_inline
r_int
DECL|function|wv_frequency_list
id|wv_frequency_list
c_func
(paren
id|u_long
id|base
comma
multiline_comment|/* i/o port of the card */
id|iw_freq
op_star
id|list
comma
multiline_comment|/* List of frequency to fill */
r_int
id|max
)paren
multiline_comment|/* Maximum number of frequencies */
(brace
id|u_short
id|table
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Authorized frequency table */
r_int
id|freq
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* offset to 2.4 GHz in .5 MHz + 12 MHz */
r_int
id|i
suffix:semicolon
multiline_comment|/* index in the table */
macro_line|#if WIRELESS_EXT &gt; 7
r_const
r_int
id|BAND_NUM
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Number of bands */
r_int
id|c
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Channel number */
macro_line|#endif WIRELESS_EXT
multiline_comment|/* Read the frequency table */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x71
multiline_comment|/* frequency table */
comma
id|table
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Look all frequencies */
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|freq
op_assign
l_int|0
suffix:semicolon
id|freq
OL
l_int|150
suffix:semicolon
id|freq
op_increment
)paren
multiline_comment|/* Look in the table if the frequency is allowed */
r_if
c_cond
(paren
id|table
(braket
l_int|9
op_minus
(paren
id|freq
op_div
l_int|16
)paren
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|freq
op_mod
l_int|16
)paren
)paren
)paren
(brace
macro_line|#if WIRELESS_EXT &gt; 7
multiline_comment|/* Compute approximate channel number */
r_while
c_loop
(paren
(paren
(paren
(paren
id|channel_bands
(braket
id|c
)braket
op_rshift
l_int|1
)paren
op_minus
l_int|24
)paren
OL
id|freq
)paren
op_logical_and
(paren
id|c
OL
id|BAND_NUM
)paren
)paren
(brace
id|c
op_increment
suffix:semicolon
)brace
id|list
(braket
id|i
)braket
dot
id|i
op_assign
id|c
suffix:semicolon
multiline_comment|/* Set the list index */
macro_line|#endif WIRELESS_EXT
multiline_comment|/* put in the list */
id|list
(braket
id|i
)braket
dot
id|m
op_assign
(paren
(paren
(paren
id|freq
op_plus
l_int|24
)paren
op_star
l_int|5
)paren
op_plus
l_int|24000L
)paren
op_star
l_int|10000
suffix:semicolon
id|list
(braket
id|i
op_increment
)braket
dot
id|e
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Check number */
r_if
c_cond
(paren
id|i
op_ge
id|max
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
macro_line|#ifdef WIRELESS_SPY
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Gather wireless spy statistics : for each packet, compare the source&n; * address with out list, and if match, get the stats...&n; * Sorry, but this function really need wireless extensions...&n; */
r_static
r_inline
r_void
DECL|function|wl_spy_gather
id|wl_spy_gather
c_func
(paren
id|device
op_star
id|dev
comma
id|u_char
op_star
id|mac
comma
multiline_comment|/* MAC address */
id|u_char
op_star
id|stats
)paren
multiline_comment|/* Statistics to gather */
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Look all addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* If match */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|mac
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
comma
id|WAVELAN_ADDR_SIZE
)paren
)paren
(brace
multiline_comment|/* Update statistics */
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|qual
op_assign
id|stats
(braket
l_int|2
)braket
op_amp
id|MMR_SGNL_QUAL
suffix:semicolon
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|level
op_assign
id|stats
(braket
l_int|0
)braket
op_amp
id|MMR_SIGNAL_LVL
suffix:semicolon
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|noise
op_assign
id|stats
(braket
l_int|1
)braket
op_amp
id|MMR_SILENCE_LVL
suffix:semicolon
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|updated
op_assign
l_int|0x7
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* WIRELESS_SPY */
macro_line|#ifdef HISTOGRAM
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This function calculate an histogram on the signal level.&n; * As the noise is quite constant, it&squot;s like doing it on the SNR.&n; * We have defined a set of interval (lp-&gt;his_range), and each time&n; * the level goes in that interval, we increment the count (lp-&gt;his_sum).&n; * With this histogram you may detect if one wavelan is really weak,&n; * or you may also calculate the mean and standard deviation of the level...&n; */
r_static
r_inline
r_void
DECL|function|wl_his_gather
id|wl_his_gather
c_func
(paren
id|device
op_star
id|dev
comma
id|u_char
op_star
id|stats
)paren
multiline_comment|/* Statistics to gather */
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|level
op_assign
id|stats
(braket
l_int|0
)braket
op_amp
id|MMR_SIGNAL_LVL
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Find the correct interval */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
OL
(paren
id|lp-&gt;his_number
op_minus
l_int|1
)paren
)paren
op_logical_and
(paren
id|level
op_ge
id|lp-&gt;his_range
(braket
id|i
op_increment
)braket
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Increment interval counter */
(paren
id|lp-&gt;his_sum
(braket
id|i
)braket
)paren
op_increment
suffix:semicolon
)brace
macro_line|#endif&t;/* HISTOGRAM */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Perform ioctl : config &amp; info stuff&n; * This is here that are treated the wireless extensions (iwconfig)&n; */
r_static
r_int
DECL|function|wavelan_ioctl
id|wavelan_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
multiline_comment|/* Device on wich the ioctl apply */
r_struct
id|ifreq
op_star
id|rq
comma
multiline_comment|/* Data passed */
r_int
id|cmd
)paren
multiline_comment|/* Ioctl number */
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* lp is not unused */
r_struct
id|iwreq
op_star
id|wrq
op_assign
(paren
r_struct
id|iwreq
op_star
)paren
id|rq
suffix:semicolon
id|psa_t
id|psa
suffix:semicolon
id|mm_t
id|m
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_ioctl(cmd=0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable interrupts &amp; save flags */
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Look what is the request */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* --------------- WIRELESS EXTENSIONS --------------- */
r_case
id|SIOCGIWNAME
suffix:colon
id|strcpy
c_func
(paren
id|wrq-&gt;u.name
comma
l_string|&quot;Wavelan&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIWNWID
suffix:colon
multiline_comment|/* Set NWID in wavelan */
macro_line|#if WIRELESS_EXT &gt; 8
r_if
c_cond
(paren
op_logical_neg
id|wrq-&gt;u.nwid.disabled
)paren
(brace
multiline_comment|/* Set NWID in psa */
id|psa.psa_nwid
(braket
l_int|0
)braket
op_assign
(paren
id|wrq-&gt;u.nwid.value
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
suffix:semicolon
id|psa.psa_nwid
(braket
l_int|1
)braket
op_assign
id|wrq-&gt;u.nwid.value
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#else&t;/* WIRELESS_EXT &gt; 8 */
r_if
c_cond
(paren
id|wrq-&gt;u.nwid.on
)paren
(brace
multiline_comment|/* Set NWID in psa */
id|psa.psa_nwid
(braket
l_int|0
)braket
op_assign
(paren
id|wrq-&gt;u.nwid.nwid
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
suffix:semicolon
id|psa.psa_nwid
(braket
l_int|1
)braket
op_assign
id|wrq-&gt;u.nwid.nwid
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT &gt; 8 */
id|psa.psa_nwid_select
op_assign
l_int|0x01
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
id|psa.psa_nwid
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
id|psa.psa_nwid
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Set NWID in mmc */
id|m.w.mmw_netw_id_l
op_assign
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|m.w.mmw_netw_id_h
op_assign
id|psa.psa_nwid
(braket
l_int|0
)braket
suffix:semicolon
id|mmc_write
c_func
(paren
id|base
comma
(paren
r_char
op_star
)paren
op_amp
id|m.w.mmw_netw_id_l
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.w.mmw_netw_id_l
comma
l_int|2
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_loopt_sel
)paren
comma
l_int|0x00
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable nwid in the psa */
id|psa.psa_nwid_select
op_assign
l_int|0x00
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_nwid_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_nwid_select
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Disable nwid in the mmc (no filtering) */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_loopt_sel
)paren
comma
id|MMW_LOOPT_SEL_DIS_NWID
)paren
suffix:semicolon
)brace
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWNWID
suffix:colon
multiline_comment|/* Read the NWID */
id|psa_read
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
id|psa.psa_nwid
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
id|psa.psa_nwid
comma
l_int|3
)paren
suffix:semicolon
macro_line|#if WIRELESS_EXT &gt; 8
id|wrq-&gt;u.nwid.value
op_assign
(paren
id|psa.psa_nwid
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|wrq-&gt;u.nwid.disabled
op_assign
op_logical_neg
(paren
id|psa.psa_nwid_select
)paren
suffix:semicolon
id|wrq-&gt;u.nwid.fixed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Superfluous */
macro_line|#else&t;/* WIRELESS_EXT &gt; 8 */
id|wrq-&gt;u.nwid.nwid
op_assign
(paren
id|psa.psa_nwid
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|wrq-&gt;u.nwid.on
op_assign
id|psa.psa_nwid_select
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT &gt; 8 */
r_break
suffix:semicolon
r_case
id|SIOCSIWFREQ
suffix:colon
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
id|ret
op_assign
id|wv_set_frequency
c_func
(paren
id|base
comma
op_amp
(paren
id|wrq-&gt;u.freq
)paren
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWFREQ
suffix:colon
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable)&n;       * (does it work for everybody ??? - especially old cards...) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
r_int
r_int
id|freq
suffix:semicolon
multiline_comment|/* Ask the EEprom to read the frequency from the first area */
id|fee_read
c_func
(paren
id|base
comma
l_int|0x00
multiline_comment|/* 1st area - frequency... */
comma
op_amp
id|freq
comma
l_int|1
)paren
suffix:semicolon
id|wrq-&gt;u.freq.m
op_assign
(paren
(paren
id|freq
op_rshift
l_int|5
)paren
op_star
l_int|5
op_plus
l_int|24000L
)paren
op_star
l_int|10000
suffix:semicolon
id|wrq-&gt;u.freq.e
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|psa_read
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_subband
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_subband
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psa.psa_subband
op_le
l_int|4
)paren
(brace
id|wrq-&gt;u.freq.m
op_assign
id|fixed_bands
(braket
id|psa.psa_subband
)braket
suffix:semicolon
id|wrq-&gt;u.freq.e
op_assign
(paren
id|psa.psa_subband
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCSIWSENS
suffix:colon
multiline_comment|/* Set the level threshold */
macro_line|#if WIRELESS_EXT &gt; 7
multiline_comment|/* We should complain loudly if wrq-&gt;u.sens.fixed = 0, because we&n;       * can&squot;t set auto mode... */
id|psa.psa_thr_pre_set
op_assign
id|wrq-&gt;u.sens.value
op_amp
l_int|0x3F
suffix:semicolon
macro_line|#else&t;/* WIRELESS_EXT &gt; 7 */
id|psa.psa_thr_pre_set
op_assign
id|wrq-&gt;u.sensitivity
op_amp
l_int|0x3F
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT &gt; 7 */
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_thr_pre_set
)paren
comma
id|psa.psa_thr_pre_set
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWSENS
suffix:colon
multiline_comment|/* Read the level threshold */
id|psa_read
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if WIRELESS_EXT &gt; 7
id|wrq-&gt;u.sens.value
op_assign
id|psa.psa_thr_pre_set
op_amp
l_int|0x3F
suffix:semicolon
id|wrq-&gt;u.sens.fixed
op_assign
l_int|1
suffix:semicolon
macro_line|#else&t;/* WIRELESS_EXT &gt; 7 */
id|wrq-&gt;u.sensitivity
op_assign
id|psa.psa_thr_pre_set
op_amp
l_int|0x3F
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT &gt; 7 */
r_break
suffix:semicolon
macro_line|#if WIRELESS_EXT &gt; 8
r_case
id|SIOCSIWENCODE
suffix:colon
multiline_comment|/* Set encryption key */
r_if
c_cond
(paren
op_logical_neg
id|mmc_encr
c_func
(paren
id|base
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
multiline_comment|/* Check the size of the key */
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.length
op_ne
l_int|8
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Copy the key in the driver */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|psa.psa_encryption_key
comma
id|wrq-&gt;u.encoding.pointer
comma
id|wrq-&gt;u.encoding.length
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|psa.psa_encryption_select
op_assign
l_int|1
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
comma
l_int|8
op_plus
l_int|1
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_encr_enable
)paren
comma
id|MMW_ENCR_ENABLE_EN
op_or
id|MMW_ENCR_ENABLE_MODE
)paren
suffix:semicolon
id|mmc_write
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_encr_key
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_key
comma
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.flags
op_amp
id|IW_ENCODE_DISABLED
)paren
(brace
multiline_comment|/* disable encryption */
id|psa.psa_encryption_select
op_assign
l_int|0
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
comma
l_int|1
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_encr_enable
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWENCODE
suffix:colon
multiline_comment|/* Read the encryption key */
r_if
c_cond
(paren
op_logical_neg
id|mmc_encr
c_func
(paren
id|base
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* only super-user can see encryption key */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
id|psa_read
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
comma
l_int|1
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* encryption is enabled ? */
r_if
c_cond
(paren
id|psa.psa_encryption_select
)paren
(brace
id|wrq-&gt;u.encoding.flags
op_assign
id|IW_ENCODE_ENABLED
suffix:semicolon
)brace
r_else
id|wrq-&gt;u.encoding.flags
op_assign
id|IW_ENCODE_DISABLED
suffix:semicolon
id|wrq-&gt;u.encoding.flags
op_or_assign
id|mmc_encr
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* Copy the key to the user buffer */
id|wrq-&gt;u.encoding.length
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.encoding.pointer
comma
id|psa.psa_encryption_key
comma
l_int|8
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT &gt; 8 */
macro_line|#ifdef WAVELAN_ROAMING_EXT
macro_line|#if WIRELESS_EXT &gt; 5
r_case
id|SIOCSIWESSID
suffix:colon
multiline_comment|/* Check if disable */
r_if
c_cond
(paren
id|wrq-&gt;u.data.flags
op_eq
l_int|0
)paren
(brace
id|lp-&gt;filter_domains
op_assign
l_int|0
suffix:semicolon
)brace
r_else
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
r_char
id|essid
(braket
id|IW_ESSID_MAX_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_char
op_star
id|endp
suffix:semicolon
multiline_comment|/* Check the size of the string */
r_if
c_cond
(paren
id|wrq-&gt;u.data.length
OG
id|IW_ESSID_MAX_SIZE
op_plus
l_int|1
)paren
(brace
id|ret
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Copy the string in the driver */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|essid
comma
id|wrq-&gt;u.data.pointer
comma
id|wrq-&gt;u.data.length
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|essid
(braket
id|IW_ESSID_MAX_SIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SetEssid : ``%s&squot;&squot;&bslash;n&quot;
comma
id|essid
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_IOCTL_INFO */
multiline_comment|/* Convert to a number (note : Wavelan specific) */
id|lp-&gt;domain_id
op_assign
id|simple_strtoul
c_func
(paren
id|essid
comma
op_amp
id|endp
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Has it worked  ? */
r_if
c_cond
(paren
id|endp
OG
id|essid
)paren
(brace
id|lp-&gt;filter_domains
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;filter_domains
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWESSID
suffix:colon
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
r_char
id|essid
(braket
id|IW_ESSID_MAX_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Is the domain ID active ? */
id|wrq-&gt;u.data.flags
op_assign
id|lp-&gt;filter_domains
suffix:semicolon
multiline_comment|/* Copy Domain ID into a string (Wavelan specific) */
multiline_comment|/* Sound crazy, be we can&squot;t have a snprintf in the kernel !!! */
id|sprintf
c_func
(paren
id|essid
comma
l_string|&quot;%lX&quot;
comma
id|lp-&gt;domain_id
)paren
suffix:semicolon
id|essid
(braket
id|IW_ESSID_MAX_SIZE
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Set the length */
id|wrq-&gt;u.data.length
op_assign
id|strlen
c_func
(paren
id|essid
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Copy structure to the user buffer */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
id|essid
comma
id|wrq-&gt;u.data.length
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SIOCSIWAP
suffix:colon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Set AP to : %02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|wrq-&gt;u.ap_addr.sa_data
(braket
l_int|0
)braket
comma
id|wrq-&gt;u.ap_addr.sa_data
(braket
l_int|1
)braket
comma
id|wrq-&gt;u.ap_addr.sa_data
(braket
l_int|2
)braket
comma
id|wrq-&gt;u.ap_addr.sa_data
(braket
l_int|3
)braket
comma
id|wrq-&gt;u.ap_addr.sa_data
(braket
l_int|4
)braket
comma
id|wrq-&gt;u.ap_addr.sa_data
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_IOCTL_INFO */
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Not supported yet */
r_break
suffix:semicolon
r_case
id|SIOCGIWAP
suffix:colon
multiline_comment|/* Should get the real McCoy instead of own Ethernet address */
id|memcpy
c_func
(paren
id|wrq-&gt;u.ap_addr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
id|wrq-&gt;u.ap_addr.sa_family
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Not supported yet */
r_break
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT &gt; 5 */
macro_line|#endif&t;/* WAVELAN_ROAMING_EXT */
macro_line|#if WIRELESS_EXT &gt; 8
macro_line|#ifdef WAVELAN_ROAMING
r_case
id|SIOCSIWMODE
suffix:colon
r_switch
c_cond
(paren
id|wrq-&gt;u.mode
)paren
(brace
r_case
id|IW_MODE_ADHOC
suffix:colon
r_if
c_cond
(paren
id|do_roaming
)paren
(brace
id|wv_roam_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|do_roaming
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IW_MODE_INFRA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|do_roaming
)paren
(brace
id|wv_roam_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|do_roaming
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWMODE
suffix:colon
r_if
c_cond
(paren
id|do_roaming
)paren
(brace
id|wrq-&gt;u.mode
op_assign
id|IW_MODE_INFRA
suffix:semicolon
)brace
r_else
id|wrq-&gt;u.mode
op_assign
id|IW_MODE_ADHOC
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;/* WAVELAN_ROAMING */
macro_line|#endif /* WIRELESS_EXT &gt; 8 */
r_case
id|SIOCGIWRANGE
suffix:colon
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
r_struct
id|iw_range
id|range
suffix:semicolon
multiline_comment|/* Set the length (useless : its constant...) */
id|wrq-&gt;u.data.length
op_assign
r_sizeof
(paren
r_struct
id|iw_range
)paren
suffix:semicolon
multiline_comment|/* Set information in the range struct */
id|range.throughput
op_assign
l_float|1.4
op_star
l_int|1000
op_star
l_int|1000
suffix:semicolon
multiline_comment|/* don&squot;t argue on this ! */
id|range.min_nwid
op_assign
l_int|0x0000
suffix:semicolon
id|range.max_nwid
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
id|range.num_channels
op_assign
l_int|10
suffix:semicolon
id|range.num_frequency
op_assign
id|wv_frequency_list
c_func
(paren
id|base
comma
id|range.freq
comma
id|IW_MAX_FREQUENCIES
)paren
suffix:semicolon
)brace
r_else
id|range.num_channels
op_assign
id|range.num_frequency
op_assign
l_int|0
suffix:semicolon
id|range.sensitivity
op_assign
l_int|0x3F
suffix:semicolon
id|range.max_qual.qual
op_assign
id|MMR_SGNL_QUAL
suffix:semicolon
id|range.max_qual.level
op_assign
id|MMR_SIGNAL_LVL
suffix:semicolon
id|range.max_qual.noise
op_assign
id|MMR_SILENCE_LVL
suffix:semicolon
macro_line|#if WIRELESS_EXT &gt; 7
id|range.num_bitrates
op_assign
l_int|1
suffix:semicolon
id|range.bitrate
(braket
l_int|0
)braket
op_assign
l_int|2000000
suffix:semicolon
multiline_comment|/* 2 Mb/s */
macro_line|#endif /* WIRELESS_EXT &gt; 7 */
macro_line|#if WIRELESS_EXT &gt; 8
multiline_comment|/* Encryption supported ? */
r_if
c_cond
(paren
id|mmc_encr
c_func
(paren
id|base
)paren
)paren
(brace
id|range.encoding_size
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* DES = 64 bits key */
id|range.num_encoding_sizes
op_assign
l_int|1
suffix:semicolon
id|range.max_encoding_tokens
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Only one key possible */
)brace
r_else
(brace
id|range.num_encoding_sizes
op_assign
l_int|0
suffix:semicolon
id|range.max_encoding_tokens
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* WIRELESS_EXT &gt; 8 */
multiline_comment|/* Copy structure to the user buffer */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
op_amp
id|range
comma
r_sizeof
(paren
r_struct
id|iw_range
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWPRIV
suffix:colon
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
r_struct
id|iw_priv_args
id|priv
(braket
)braket
op_assign
(brace
multiline_comment|/* cmd,&t;&t;set_args,&t;get_args,&t;name */
(brace
id|SIOCSIPQTHR
comma
id|IW_PRIV_TYPE_BYTE
op_or
id|IW_PRIV_SIZE_FIXED
op_or
l_int|1
comma
l_int|0
comma
l_string|&quot;setqualthr&quot;
)brace
comma
(brace
id|SIOCGIPQTHR
comma
l_int|0
comma
id|IW_PRIV_TYPE_BYTE
op_or
id|IW_PRIV_SIZE_FIXED
op_or
l_int|1
comma
l_string|&quot;getqualthr&quot;
)brace
comma
(brace
id|SIOCSIPHISTO
comma
id|IW_PRIV_TYPE_BYTE
op_or
l_int|16
comma
l_int|0
comma
l_string|&quot;sethisto&quot;
)brace
comma
(brace
id|SIOCGIPHISTO
comma
l_int|0
comma
id|IW_PRIV_TYPE_INT
op_or
l_int|16
comma
l_string|&quot;gethisto&quot;
)brace
comma
(brace
id|SIOCSIPROAM
comma
id|IW_PRIV_TYPE_BYTE
op_or
id|IW_PRIV_SIZE_FIXED
op_or
l_int|1
comma
l_int|0
comma
l_string|&quot;setroam&quot;
)brace
comma
(brace
id|SIOCGIPROAM
comma
l_int|0
comma
id|IW_PRIV_TYPE_BYTE
op_or
id|IW_PRIV_SIZE_FIXED
op_or
l_int|1
comma
l_string|&quot;getroam&quot;
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Set the number of ioctl available */
id|wrq-&gt;u.data.length
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* Copy structure to the user buffer */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
(paren
id|u_char
op_star
)paren
id|priv
comma
r_sizeof
(paren
id|priv
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#ifdef WIRELESS_SPY
r_case
id|SIOCSIWSPY
suffix:colon
multiline_comment|/* Set the spy list */
multiline_comment|/* Check the number of addresses */
r_if
c_cond
(paren
id|wrq-&gt;u.data.length
OG
id|IW_MAX_SPY
)paren
(brace
id|ret
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;spy_number
op_assign
id|wrq-&gt;u.data.length
suffix:semicolon
multiline_comment|/* If there is some addresses to copy */
r_if
c_cond
(paren
id|lp-&gt;spy_number
OG
l_int|0
)paren
(brace
r_struct
id|sockaddr
id|address
(braket
id|IW_MAX_SPY
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Copy addresses to the driver */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|address
comma
id|wrq-&gt;u.data.pointer
comma
r_sizeof
(paren
r_struct
id|sockaddr
)paren
op_star
id|lp-&gt;spy_number
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Copy addresses to the lp structure */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|lp-&gt;spy_address
(braket
id|i
)braket
comma
id|address
(braket
id|i
)braket
dot
id|sa_data
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset structure... */
id|memset
c_func
(paren
id|lp-&gt;spy_stat
comma
l_int|0x00
comma
r_sizeof
(paren
id|iw_qual
)paren
op_star
id|IW_MAX_SPY
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SetSpy - Set of new addresses is :&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wrq-&gt;u.data.length
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|0
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|1
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|2
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|3
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|4
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG_IOCTL_INFO */
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWSPY
suffix:colon
multiline_comment|/* Get the spy list and spy stats */
multiline_comment|/* Set the number of addresses */
id|wrq-&gt;u.data.length
op_assign
id|lp-&gt;spy_number
suffix:semicolon
multiline_comment|/* If the user want to have the addresses back... */
r_if
c_cond
(paren
(paren
id|lp-&gt;spy_number
OG
l_int|0
)paren
op_logical_and
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
)paren
(brace
r_struct
id|sockaddr
id|address
(braket
id|IW_MAX_SPY
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Copy addresses from the lp structure */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|address
(braket
id|i
)braket
dot
id|sa_data
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
id|address
(braket
id|i
)braket
dot
id|sa_family
op_assign
id|ARPHRD_ETHER
suffix:semicolon
)brace
multiline_comment|/* Copy addresses to the user buffer */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
id|address
comma
r_sizeof
(paren
r_struct
id|sockaddr
)paren
op_star
id|lp-&gt;spy_number
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Copy stats to the user buffer (just after) */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
op_plus
(paren
r_sizeof
(paren
r_struct
id|sockaddr
)paren
op_star
id|lp-&gt;spy_number
)paren
comma
id|lp-&gt;spy_stat
comma
r_sizeof
(paren
id|iw_qual
)paren
op_star
id|lp-&gt;spy_number
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Reset updated flags */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|updated
op_assign
l_int|0x0
suffix:semicolon
)brace
)brace
multiline_comment|/* if(pointer != NULL) */
r_break
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_SPY */
multiline_comment|/* ------------------ PRIVATE IOCTL ------------------ */
r_case
id|SIOCSIPQTHR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|psa.psa_quality_thr
op_assign
op_star
(paren
id|wrq-&gt;u.name
)paren
op_amp
l_int|0x0F
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_quality_thr
)paren
comma
id|psa.psa_quality_thr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIPQTHR
suffix:colon
id|psa_read
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
comma
l_int|1
)paren
suffix:semicolon
op_star
(paren
id|wrq-&gt;u.name
)paren
op_assign
id|psa.psa_quality_thr
op_amp
l_int|0x0F
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef WAVELAN_ROAMING
r_case
id|SIOCSIPROAM
suffix:colon
multiline_comment|/* Note : should check if user == root */
r_if
c_cond
(paren
id|do_roaming
op_logical_and
(paren
op_star
id|wrq-&gt;u.name
)paren
op_eq
l_int|0
)paren
(brace
id|wv_roam_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|do_roaming
op_eq
l_int|0
op_logical_and
(paren
op_star
id|wrq-&gt;u.name
)paren
op_ne
l_int|0
)paren
(brace
id|wv_roam_init
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|do_roaming
op_assign
(paren
op_star
id|wrq-&gt;u.name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIPROAM
suffix:colon
op_star
(paren
id|wrq-&gt;u.name
)paren
op_assign
id|do_roaming
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;/* WAVELAN_ROAMING */
macro_line|#ifdef HISTOGRAM
r_case
id|SIOCSIPHISTO
suffix:colon
multiline_comment|/* Verif if the user is root */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* Check the number of intervals */
r_if
c_cond
(paren
id|wrq-&gt;u.data.length
OG
l_int|16
)paren
(brace
id|ret
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;his_number
op_assign
id|wrq-&gt;u.data.length
suffix:semicolon
multiline_comment|/* If there is some addresses to copy */
r_if
c_cond
(paren
id|lp-&gt;his_number
OG
l_int|0
)paren
(brace
multiline_comment|/* Copy interval ranges to the driver */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lp-&gt;his_range
comma
id|wrq-&gt;u.data.pointer
comma
r_sizeof
(paren
r_char
)paren
op_star
id|lp-&gt;his_number
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Reset structure... */
id|memset
c_func
(paren
id|lp-&gt;his_sum
comma
l_int|0x00
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|16
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIPHISTO
suffix:colon
multiline_comment|/* Set the number of intervals */
id|wrq-&gt;u.data.length
op_assign
id|lp-&gt;his_number
suffix:semicolon
multiline_comment|/* Give back the distribution statistics */
r_if
c_cond
(paren
(paren
id|lp-&gt;his_number
OG
l_int|0
)paren
op_logical_and
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
)paren
(brace
multiline_comment|/* Copy data to the user buffer */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
id|lp-&gt;his_sum
comma
r_sizeof
(paren
r_int
)paren
op_star
id|lp-&gt;his_number
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
multiline_comment|/* if(pointer != NULL) */
r_break
suffix:semicolon
macro_line|#endif&t;/* HISTOGRAM */
multiline_comment|/* ------------------- OTHER IOCTL ------------------- */
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* ReEnable interrupts &amp; restore flags */
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_ioctl()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get wireless statistics&n; * Called by /proc/net/wireless...&n; */
r_static
id|iw_stats
op_star
DECL|function|wavelan_get_wireless_stats
id|wavelan_get_wireless_stats
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mmr_t
id|m
suffix:semicolon
id|iw_stats
op_star
id|wstats
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_get_wireless_stats()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable interrupts &amp; save flags */
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_eq
(paren
id|net_local
op_star
)paren
l_int|NULL
)paren
(brace
r_return
(paren
id|iw_stats
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
id|wstats
op_assign
op_amp
id|lp-&gt;wstats
suffix:semicolon
multiline_comment|/* Get data from the mmc */
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_dce_status
)paren
comma
op_amp
id|m.mmr_dce_status
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_wrong_nwid_l
)paren
comma
op_amp
id|m.mmr_wrong_nwid_l
comma
l_int|2
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_thr_pre_set
)paren
comma
op_amp
id|m.mmr_thr_pre_set
comma
l_int|4
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|base
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Copy data to wireless stuff */
id|wstats-&gt;status
op_assign
id|m.mmr_dce_status
op_amp
id|MMR_DCE_STATUS
suffix:semicolon
id|wstats-&gt;qual.qual
op_assign
id|m.mmr_sgnl_qual
op_amp
id|MMR_SGNL_QUAL
suffix:semicolon
id|wstats-&gt;qual.level
op_assign
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL
suffix:semicolon
id|wstats-&gt;qual.noise
op_assign
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL
suffix:semicolon
id|wstats-&gt;qual.updated
op_assign
(paren
(paren
(paren
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL_VALID
)paren
op_rshift
l_int|7
)paren
op_or
(paren
(paren
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL_VALID
)paren
op_rshift
l_int|6
)paren
op_or
(paren
(paren
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL_VALID
)paren
op_rshift
l_int|5
)paren
)paren
suffix:semicolon
id|wstats-&gt;discard.nwid
op_add_assign
(paren
id|m.mmr_wrong_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_wrong_nwid_l
suffix:semicolon
id|wstats-&gt;discard.code
op_assign
l_int|0L
suffix:semicolon
id|wstats-&gt;discard.misc
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* ReEnable interrupts &amp; restore flags */
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_get_wireless_stats()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_amp
id|lp-&gt;wstats
suffix:semicolon
)brace
macro_line|#endif&t;/* WIRELESS_EXT */
multiline_comment|/************************* PACKET RECEPTION *************************/
multiline_comment|/*&n; * This part deal with receiving the packets.&n; * The interrupt handler get an interrupt when a packet has been&n; * successfully received and called this part...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Calculate the starting address of the frame pointed to by the receive&n; * frame pointer and verify that the frame seem correct&n; * (called by wv_packet_rcv())&n; */
r_static
r_inline
r_int
DECL|function|wv_start_of_frame
id|wv_start_of_frame
c_func
(paren
id|device
op_star
id|dev
comma
r_int
id|rfp
comma
multiline_comment|/* end of frame */
r_int
id|wrap
)paren
multiline_comment|/* start of buffer */
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|rp
suffix:semicolon
r_int
id|len
suffix:semicolon
id|rp
op_assign
(paren
id|rfp
op_minus
l_int|5
op_plus
id|RX_SIZE
)paren
op_mod
id|RX_SIZE
suffix:semicolon
id|outb
c_func
(paren
id|rp
op_amp
l_int|0xff
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|rp
op_rshift
l_int|8
)paren
op_amp
id|PIORH_MASK
)paren
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|len
op_assign
id|inb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|len
op_or_assign
id|inb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* Sanity checks on size */
multiline_comment|/* Frame too big */
r_if
c_cond
(paren
id|len
OG
id|MAXDATAZ
op_plus
l_int|100
)paren
(brace
macro_line|#ifdef DEBUG_RX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_start_of_frame: Received frame too large, rfp %d len 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rfp
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Frame too short */
r_if
c_cond
(paren
id|len
OL
l_int|7
)paren
(brace
macro_line|#ifdef DEBUG_RX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_start_of_frame: Received null frame, rfp %d len 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rfp
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Wrap around buffer */
r_if
c_cond
(paren
id|len
OG
(paren
(paren
id|wrap
op_minus
(paren
id|rfp
op_minus
id|len
)paren
op_plus
id|RX_SIZE
)paren
op_mod
id|RX_SIZE
)paren
)paren
multiline_comment|/* magic formula ! */
(brace
macro_line|#ifdef DEBUG_RX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_start_of_frame: wrap around buffer, wrap %d rfp %d len 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|wrap
comma
id|rfp
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|rp
op_minus
id|len
op_plus
id|RX_SIZE
)paren
op_mod
id|RX_SIZE
suffix:semicolon
)brace
multiline_comment|/* wv_start_of_frame */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine does the actual copy of data (including the ethernet&n; * header structure) from the WaveLAN card to an sk_buff chain that&n; * will be passed up to the network interface layer. NOTE: We&n; * currently don&squot;t handle trailer protocols (neither does the rest of&n; * the network interface), so if that is needed, it will (at least in&n; * part) be added here.  The contents of the receive ring buffer are&n; * copied to a message chain that is then passed to the kernel.&n; *&n; * Note: if any errors occur, the packet is &quot;dropped on the floor&quot;&n; * (called by wv_packet_rcv())&n; */
r_static
r_inline
r_void
DECL|function|wv_packet_read
id|wv_packet_read
c_func
(paren
id|device
op_star
id|dev
comma
r_int
id|fd_p
comma
r_int
id|sksize
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_packet_read(0x%X, %d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|fd_p
comma
id|sksize
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Allocate some buffer for the new packet */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|sksize
op_plus
l_int|2
)paren
)paren
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_RX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_packet_read(): could not alloc_skb(%d, GFP_ATOMIC)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sksize
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/*&n;       * Not only do we want to return here, but we also need to drop the&n;       * packet on the floor to clear the interrupt.&n;       */
r_return
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|fd_p
op_assign
id|read_ringbuf
c_func
(paren
id|dev
comma
id|fd_p
comma
(paren
r_char
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|sksize
)paren
comma
id|sksize
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RX_INFO
multiline_comment|/* Another glitch : Due to the way the GET_PACKET macro is written,&n;   * we are not sure to have the same thing in skb-&gt;data. On the other&n;   * hand, skb-&gt;mac.raw is not defined everywhere...&n;   * For versions between 1.2.13 and those where skb-&gt;mac.raw appear,&n;   * I don&squot;t have a clue...&n;   */
id|wv_packet_info
c_func
(paren
id|skb-&gt;mac.raw
comma
id|sksize
comma
id|dev-&gt;name
comma
l_string|&quot;wv_packet_read&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_RX_INFO */
multiline_comment|/* Statistics gathering &amp; stuff associated.&n;   * It seem a bit messy with all the define, but it&squot;s really simple... */
r_if
c_cond
(paren
macro_line|#ifdef WIRELESS_SPY
(paren
id|lp-&gt;spy_number
OG
l_int|0
)paren
op_logical_or
macro_line|#endif&t;/* WIRELESS_SPY */
macro_line|#ifdef HISTOGRAM
(paren
id|lp-&gt;his_number
OG
l_int|0
)paren
op_logical_or
macro_line|#endif&t;/* HISTOGRAM */
macro_line|#ifdef WAVELAN_ROAMING
(paren
id|do_roaming
)paren
op_logical_or
macro_line|#endif&t;/* WAVELAN_ROAMING */
l_int|0
)paren
(brace
id|u_char
id|stats
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Signal level, Noise level, Signal quality */
multiline_comment|/* read signal level, silence level and signal quality bytes */
id|fd_p
op_assign
id|read_ringbuf
c_func
(paren
id|dev
comma
(paren
id|fd_p
op_plus
l_int|4
)paren
op_mod
id|RX_SIZE
op_plus
id|RX_BASE
comma
id|stats
comma
l_int|3
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RX_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_packet_read(): Signal level %d/63, Silence level %d/63, signal quality %d/16&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats
(braket
l_int|0
)braket
op_amp
l_int|0x3F
comma
id|stats
(braket
l_int|1
)braket
op_amp
l_int|0x3F
comma
id|stats
(braket
l_int|2
)braket
op_amp
l_int|0x0F
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef WAVELAN_ROAMING
r_if
c_cond
(paren
id|do_roaming
)paren
r_if
c_cond
(paren
id|WAVELAN_BEACON
c_func
(paren
id|skb-&gt;data
)paren
)paren
(brace
id|wl_roam_gather
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|stats
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* WAVELAN_ROAMING */
multiline_comment|/* Spying stuff */
macro_line|#ifdef WIRELESS_SPY
multiline_comment|/* Same as above */
id|wl_spy_gather
c_func
(paren
id|dev
comma
id|skb-&gt;mac.raw
op_plus
id|WAVELAN_ADDR_SIZE
comma
id|stats
)paren
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_SPY */
macro_line|#ifdef HISTOGRAM
id|wl_his_gather
c_func
(paren
id|dev
comma
id|stats
)paren
suffix:semicolon
macro_line|#endif&t;/* HISTOGRAM */
)brace
multiline_comment|/*&n;   * Hand the packet to the Network Module&n;   */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keep stats up to date */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_packet_read()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine is called by the interrupt handler to initiate a&n; * packet transfer from the card to the network interface layer above&n; * this driver.  This routine checks if a buffer has been successfully&n; * received by the WaveLAN card.  If so, the routine wv_packet_read is&n; * called to do the actual transfer of the card&squot;s data including the&n; * ethernet header into a packet consisting of an sk_buff chain.&n; * (called by wavelan_interrupt())&n; */
r_static
r_inline
r_void
DECL|function|wv_packet_rcv
id|wv_packet_rcv
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|newrfp
suffix:semicolon
r_int
id|rp
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|f_start
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|i593_rfp
suffix:semicolon
r_int
id|stat_ptr
suffix:semicolon
id|u_char
id|c
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_packet_rcv()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Get the new receive frame pointer from the i82593 chip */
id|outb
c_func
(paren
id|CR0_STATUS_2
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|i593_rfp
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|i593_rfp
op_or_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|i593_rfp
op_mod_assign
id|RX_SIZE
suffix:semicolon
multiline_comment|/* Get the new receive frame pointer from the WaveLAN card.&n;   * It is 3 bytes more than the increment of the i82593 receive&n;   * frame pointer, for each packet. This is because it includes the&n;   * 3 roaming bytes added by the mmc.&n;   */
id|newrfp
op_assign
id|inb
c_func
(paren
id|RPLL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|newrfp
op_or_assign
id|inb
c_func
(paren
id|RPLH
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|newrfp
op_mod_assign
id|RX_SIZE
suffix:semicolon
macro_line|#ifdef DEBUG_RX_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_packet_rcv(): i593_rfp %d stop %d newrfp %d lp-&gt;rfp %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i593_rfp
comma
id|lp-&gt;stop
comma
id|newrfp
comma
id|lp-&gt;rfp
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_RX_ERROR
multiline_comment|/* If no new frame pointer... */
r_if
c_cond
(paren
id|lp-&gt;overrunning
op_logical_or
id|newrfp
op_eq
id|lp-&gt;rfp
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_packet_rcv(): no new frame: i593_rfp %d stop %d newrfp %d lp-&gt;rfp %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i593_rfp
comma
id|lp-&gt;stop
comma
id|newrfp
comma
id|lp-&gt;rfp
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Read all frames (packets) received */
r_while
c_loop
(paren
id|newrfp
op_ne
id|lp-&gt;rfp
)paren
(brace
multiline_comment|/* A frame is composed of the packet, followed by a status word,&n;       * the length of the frame (word) and the mmc info (SNR &amp; qual).&n;       * It&squot;s because the length is at the end that we can only scan&n;       * frames backward. */
multiline_comment|/* Find the first frame by skipping backwards over the frames */
id|rp
op_assign
id|newrfp
suffix:semicolon
multiline_comment|/* End of last frame */
r_while
c_loop
(paren
(paren
(paren
id|f_start
op_assign
id|wv_start_of_frame
c_func
(paren
id|dev
comma
id|rp
comma
id|newrfp
)paren
)paren
op_ne
id|lp-&gt;rfp
)paren
op_logical_and
(paren
id|f_start
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|rp
op_assign
id|f_start
suffix:semicolon
)brace
multiline_comment|/* If we had a problem */
r_if
c_cond
(paren
id|f_start
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef DEBUG_RX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wavelan_cs: cannot find start of frame &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; i593_rfp %d stop %d newrfp %d lp-&gt;rfp %d&bslash;n&quot;
comma
id|i593_rfp
comma
id|lp-&gt;stop
comma
id|newrfp
comma
id|lp-&gt;rfp
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;rfp
op_assign
id|rp
suffix:semicolon
multiline_comment|/* Get to the last usable frame */
r_continue
suffix:semicolon
)brace
multiline_comment|/* f_start point to the beggining of the first frame received&n;       * and rp to the beggining of the next one */
multiline_comment|/* Read status &amp; length of the frame */
id|stat_ptr
op_assign
(paren
id|rp
op_minus
l_int|7
op_plus
id|RX_SIZE
)paren
op_mod
id|RX_SIZE
suffix:semicolon
id|stat_ptr
op_assign
id|read_ringbuf
c_func
(paren
id|dev
comma
id|stat_ptr
comma
id|c
comma
l_int|4
)paren
suffix:semicolon
id|status
op_assign
id|c
(braket
l_int|0
)braket
op_or
(paren
id|c
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|len
op_assign
id|c
(braket
l_int|2
)braket
op_or
(paren
id|c
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Check status */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|RX_RCV_OK
)paren
op_ne
id|RX_RCV_OK
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RX_NO_SFD
)paren
(brace
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RX_CRC_ERR
)paren
(brace
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RX_OVRRUN
)paren
(brace
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_RX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_packet_rcv(): packet not received ok, status = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
multiline_comment|/* Read the packet and transmit to Linux */
id|wv_packet_read
c_func
(paren
id|dev
comma
id|f_start
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* One frame has been processed, skip it */
id|lp-&gt;rfp
op_assign
id|rp
suffix:semicolon
)brace
multiline_comment|/*&n;   * Update the frame stop register, but set it to less than&n;   * the full 8K to allow space for 3 bytes of signal strength&n;   * per packet.&n;   */
id|lp-&gt;stop
op_assign
(paren
id|i593_rfp
op_plus
id|RX_SIZE
op_minus
(paren
(paren
id|RX_SIZE
op_div
l_int|64
)paren
op_star
l_int|3
)paren
)paren
op_mod
id|RX_SIZE
suffix:semicolon
id|outb
c_func
(paren
id|OP0_SWIT_TO_PORT_1
op_or
id|CR0_CHNL
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CR1_STOP_REG_UPDATE
op_or
(paren
id|lp-&gt;stop
op_rshift
id|RX_SIZE_SHIFT
)paren
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP1_SWIT_TO_PORT_0
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_packet_rcv()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*********************** PACKET TRANSMISSION ***********************/
multiline_comment|/*&n; * This part deal with sending packet through the wavelan&n; * We copy the packet to the send buffer and then issue the send&n; * command to the i82593. The result of this operation will be&n; * checked in wavelan_interrupt()&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine fills in the appropriate registers and memory&n; * locations on the WaveLAN card and starts the card off on&n; * the transmit.&n; * (called in wavelan_packet_xmit())&n; */
r_static
r_inline
r_void
DECL|function|wv_packet_write
id|wv_packet_write
c_func
(paren
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|clen
op_assign
id|length
suffix:semicolon
r_register
id|u_short
id|xmtdata_base
op_assign
id|TX_BASE
suffix:semicolon
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_packet_write(%d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check if we need some padding */
r_if
c_cond
(paren
id|clen
OL
id|ETH_ZLEN
)paren
(brace
id|clen
op_assign
id|ETH_ZLEN
suffix:semicolon
)brace
multiline_comment|/* Write the length of data buffer followed by the buffer */
id|outb
c_func
(paren
id|xmtdata_base
op_amp
l_int|0xff
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|xmtdata_base
op_rshift
l_int|8
)paren
op_amp
id|PIORH_MASK
)paren
op_or
id|PIORH_SEL_TX
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|clen
op_amp
l_int|0xff
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* lsb */
id|outb
c_func
(paren
id|clen
op_rshift
l_int|8
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* msb */
multiline_comment|/* Send the data */
id|outsb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
comma
id|buf
comma
id|clen
)paren
suffix:semicolon
multiline_comment|/* Indicate end of transmit chain */
id|outb
c_func
(paren
id|OP0_NOP
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* josullvn@cs.cmu.edu: need to send a second NOP for alignment... */
id|outb
c_func
(paren
id|OP0_NOP
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset the transmit DMA pointer */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_TX_DMA_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
multiline_comment|/* Send the transmit command */
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_packet_write(): transmit&quot;
comma
id|OP0_TRANSMIT
comma
id|SR0_NO_RESULT
)paren
suffix:semicolon
multiline_comment|/* Keep stats up to date */
id|lp-&gt;stats.tx_bytes
op_add_assign
id|length
suffix:semicolon
multiline_comment|/* If watchdog not already active, activate it... */
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
)paren
(brace
multiline_comment|/* set timer to expire in WATCHDOG_JIFFIES */
id|lp-&gt;watchdog.expires
op_assign
id|jiffies
op_plus
id|WATCHDOG_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TX_INFO
id|wv_packet_info
c_func
(paren
(paren
id|u_char
op_star
)paren
id|buf
comma
id|length
comma
id|dev-&gt;name
comma
l_string|&quot;wv_packet_write&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_TX_INFO */
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_packet_write()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine is called when we want to send a packet (NET3 callback)&n; * In this routine, we check if the the harware is ready to accept&n; * the packet. We also prevent reentrance. Then, we call the function&n; * to send the packet...&n; */
DECL|function|wavelan_packet_xmit
r_static
r_int
id|wavelan_packet_xmit
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_packet_xmit(0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * For ethernet, fill in the header.&n;&t; */
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Block a timer-based transmit from overlapping a previous transmit.&n;&t; * In other words, prevent reentering this routine.&n;&t; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
multiline_comment|/* If somebody has asked to reconfigure the controler, we can do it now */
r_if
c_cond
(paren
id|lp-&gt;reconfig_82593
)paren
(brace
id|lp-&gt;reconfig_82593
op_assign
id|FALSE
suffix:semicolon
id|wv_82593_config
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TX_ERROR
r_if
c_cond
(paren
id|skb-&gt;next
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;skb has next&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|wv_packet_write
(paren
id|dev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_packet_xmit()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/********************** HARDWARE CONFIGURATION **********************/
multiline_comment|/*&n; * This part do the real job of starting and configuring the hardware.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to initialize the Modem Management Controller.&n; * (called by wv_hw_config())&n; */
r_static
r_inline
r_int
DECL|function|wv_mmc_init
id|wv_mmc_init
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|psa_t
id|psa
suffix:semicolon
id|mmw_t
id|m
suffix:semicolon
r_int
id|configured
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Loop counter */
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_mmc_init()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the parameter storage area */
id|psa_read
c_func
(paren
id|dev
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Check the first three octets of the MAC addr for the manufacturer&squot;s code.&n;   * Note: If you get the error message below, you&squot;ve got a&n;   * non-NCR/AT&amp;T/Lucent PCMCIA cards, see wavelan_cs.h for detail on&n;   * how to configure your card...&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|MAC_ADDRESSES
)paren
op_div
r_sizeof
(paren
r_char
)paren
op_div
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|psa.psa_univ_mac_addr
(braket
l_int|0
)braket
op_eq
id|MAC_ADDRESSES
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
id|psa.psa_univ_mac_addr
(braket
l_int|1
)braket
op_eq
id|MAC_ADDRESSES
(braket
id|i
)braket
(braket
l_int|1
)braket
)paren
op_logical_and
(paren
id|psa.psa_univ_mac_addr
(braket
l_int|2
)braket
op_eq
id|MAC_ADDRESSES
(braket
id|i
)braket
(braket
l_int|2
)braket
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* If we have not found it... */
r_if
c_cond
(paren
id|i
op_eq
(paren
r_sizeof
(paren
id|MAC_ADDRESSES
)paren
op_div
r_sizeof
(paren
r_char
)paren
op_div
l_int|3
)paren
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wv_mmc_init(): Invalid MAC address: %02X:%02X:%02X:...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|psa.psa_univ_mac_addr
(braket
l_int|0
)braket
comma
id|psa.psa_univ_mac_addr
(braket
l_int|1
)braket
comma
id|psa.psa_univ_mac_addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Get the MAC address */
id|memcpy
c_func
(paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
op_amp
id|psa.psa_univ_mac_addr
(braket
l_int|0
)braket
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
macro_line|#ifdef USE_PSA_CONFIG
id|configured
op_assign
id|psa.psa_conf_status
op_amp
l_int|1
suffix:semicolon
macro_line|#else
id|configured
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is the PSA is not configured */
r_if
c_cond
(paren
op_logical_neg
id|configured
)paren
(brace
multiline_comment|/* User will be able to configure NWID after (with iwconfig) */
id|psa.psa_nwid
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|psa.psa_nwid
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* As NWID is not set : no NWID checking */
id|psa.psa_nwid_select
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Disable encryption */
id|psa.psa_encryption_select
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set to standard values&n;       * 0x04 for AT,&n;       * 0x01 for MCA,&n;       * 0x04 for PCMCIA and 2.00 card (AT&amp;T 407-024689/E document)&n;       */
r_if
c_cond
(paren
id|psa.psa_comp_number
op_amp
l_int|1
)paren
id|psa.psa_thr_pre_set
op_assign
l_int|0x01
suffix:semicolon
r_else
id|psa.psa_thr_pre_set
op_assign
l_int|0x04
suffix:semicolon
id|psa.psa_quality_thr
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* It is configured */
id|psa.psa_conf_status
op_or_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USE_PSA_CONFIG
multiline_comment|/* Write the psa */
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
id|psa.psa_nwid
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
id|psa.psa_nwid
comma
l_int|4
)paren
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
comma
l_int|1
)paren
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
comma
l_int|1
)paren
suffix:semicolon
id|psa_write
c_func
(paren
id|dev
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_conf_status
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_conf_status
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;/* USE_PSA_CONFIG */
)brace
multiline_comment|/* Zero the mmc structure */
id|memset
c_func
(paren
op_amp
id|m
comma
l_int|0x00
comma
r_sizeof
(paren
id|m
)paren
)paren
suffix:semicolon
multiline_comment|/* Copy PSA info to the mmc */
id|m.mmw_netw_id_l
op_assign
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|m.mmw_netw_id_h
op_assign
id|psa.psa_nwid
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|psa.psa_nwid_select
op_amp
l_int|1
)paren
(brace
id|m.mmw_loopt_sel
op_assign
l_int|0x00
suffix:semicolon
)brace
r_else
id|m.mmw_loopt_sel
op_assign
id|MMW_LOOPT_SEL_DIS_NWID
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|m.mmw_encr_key
comma
op_amp
id|psa.psa_encryption_key
comma
r_sizeof
(paren
id|m.mmw_encr_key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psa.psa_encryption_select
)paren
(brace
id|m.mmw_encr_enable
op_assign
id|MMW_ENCR_ENABLE_EN
op_or
id|MMW_ENCR_ENABLE_MODE
suffix:semicolon
)brace
r_else
id|m.mmw_encr_enable
op_assign
l_int|0
suffix:semicolon
id|m.mmw_thr_pre_set
op_assign
id|psa.psa_thr_pre_set
op_amp
l_int|0x3F
suffix:semicolon
id|m.mmw_quality_thr
op_assign
id|psa.psa_quality_thr
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/*&n;   * Set default modem control parameters.&n;   * See NCR document 407-0024326 Rev. A.&n;   */
id|m.mmw_jabber_enable
op_assign
l_int|0x01
suffix:semicolon
id|m.mmw_anten_sel
op_assign
id|MMW_ANTEN_SEL_ALG_EN
suffix:semicolon
id|m.mmw_ifs
op_assign
l_int|0x20
suffix:semicolon
id|m.mmw_mod_delay
op_assign
l_int|0x04
suffix:semicolon
id|m.mmw_jam_time
op_assign
l_int|0x38
suffix:semicolon
id|m.mmw_des_io_invert
op_assign
l_int|0
suffix:semicolon
id|m.mmw_freeze
op_assign
l_int|0
suffix:semicolon
id|m.mmw_decay_prm
op_assign
l_int|0
suffix:semicolon
id|m.mmw_decay_updat_prm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Write all info to mmc */
id|mmc_write
c_func
(paren
id|base
comma
l_int|0
comma
(paren
id|u_char
op_star
)paren
op_amp
id|m
comma
r_sizeof
(paren
id|m
)paren
)paren
suffix:semicolon
multiline_comment|/* The following code start the modem of the 2.00 frequency&n;   * selectable cards at power on. It&squot;s not strictly needed for the&n;   * following boots...&n;   * The original patch was by Joe Finney for the PCMCIA driver, but&n;   * I&squot;ve cleaned it a bit and add documentation.&n;   * Thanks to Loeke Brederveld from Lucent for the info.&n;   */
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable)&n;   * (does it work for everybody ??? - especially old cards...) */
multiline_comment|/* Note : WFREQSEL verify that it is able to read from EEprom&n;   * a sensible frequency (address 0x00) + that MMR_FEE_STATUS_ID&n;   * is 0xA (Xilinx version) or 0xB (Ariadne version).&n;   * My test is more crude but do work... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|base
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
multiline_comment|/* We must download the frequency parameters to the&n;       * synthetisers (from the EEprom - area 1)&n;       * Note : as the EEprom is auto decremented, we set the end&n;       * if the area... */
id|m.mmw_fee_addr
op_assign
l_int|0x0F
suffix:semicolon
id|m.mmw_fee_ctrl
op_assign
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
suffix:semicolon
id|mmc_write
c_func
(paren
id|base
comma
(paren
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished */
id|fee_wait
c_func
(paren
id|base
comma
l_int|100
comma
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
multiline_comment|/* The frequency was in the last word downloaded... */
id|mmc_read
c_func
(paren
id|base
comma
(paren
r_char
op_star
)paren
op_amp
id|m.mmw_fee_data_l
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.mmw_fee_data_l
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Print some info for the user */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Wavelan 2.00 recognised (frequency select) : Current frequency = %ld&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
(paren
id|m.mmw_fee_data_h
op_lshift
l_int|4
)paren
op_or
(paren
id|m.mmw_fee_data_l
op_rshift
l_int|4
)paren
)paren
op_star
l_int|5
op_div
l_int|2
op_plus
l_int|24000L
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We must now download the power adjust value (gain) to&n;       * the synthetisers (from the EEprom - area 7 - DAC) */
id|m.mmw_fee_addr
op_assign
l_int|0x61
suffix:semicolon
id|m.mmw_fee_ctrl
op_assign
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
suffix:semicolon
id|mmc_write
c_func
(paren
id|base
comma
(paren
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished */
)brace
multiline_comment|/* if 2.00 card */
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_mmc_init()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to gracefully turn off reception, and wait for any commands&n; * to complete.&n; * (called in wv_ru_start() and wavelan_close() and wavelan_event())&n; */
r_static
r_int
DECL|function|wv_ru_stop
id|wv_ru_stop
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|spin
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_ru_stop()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* First, send the LAN controller a stop receive command */
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_graceful_shutdown(): stop-rcv&quot;
comma
id|OP0_STOP_RCV
comma
id|SR0_NO_RESULT
)paren
suffix:semicolon
multiline_comment|/* Then, spin until the receive unit goes idle */
id|spin
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP0_NOP
op_or
id|CR0_STATUS_3
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_amp
id|SR3_RCV_STATE_MASK
)paren
op_ne
id|SR3_RCV_IDLE
)paren
op_logical_and
(paren
id|spin
op_increment
OL
l_int|300
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Now, spin until the chip finishes executing its current command */
r_do
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP0_NOP
op_or
id|CR0_STATUS_3
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_amp
id|SR3_EXEC_STATE_MASK
)paren
op_ne
id|SR3_EXEC_IDLE
)paren
op_logical_and
(paren
id|spin
op_increment
OL
l_int|300
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* If there was a problem */
r_if
c_cond
(paren
id|spin
OG
l_int|300
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_ru_stop(): The chip doesn&squot;t want to stop...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_ru_stop()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* wv_ru_stop */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine starts the receive unit running.  First, it checks if&n; * the card is actually ready. Then the card is instructed to receive&n; * packets again.&n; * (called in wv_hw_reset() &amp; wavelan_open())&n; */
r_static
r_int
DECL|function|wv_ru_start
id|wv_ru_start
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_ru_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * We need to start from a quiescent state. To do so, we could check&n;   * if the card is already running, but instead we just try to shut&n;   * it down. First, we disable reception (in case it was already enabled).&n;   */
r_if
c_cond
(paren
op_logical_neg
id|wv_ru_stop
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Now we know that no command is being executed. */
multiline_comment|/* Set the receive frame pointer and stop pointer */
id|lp-&gt;rfp
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|OP0_SWIT_TO_PORT_1
op_or
id|CR0_CHNL
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset ring management.  This sets the receive frame pointer to 1 */
id|outb
c_func
(paren
id|OP1_RESET_RING_MNGMT
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* but I set it to 3 bytes per packet less than 8K */
id|lp-&gt;stop
op_assign
(paren
l_int|0
op_plus
id|RX_SIZE
op_minus
(paren
(paren
id|RX_SIZE
op_div
l_int|64
)paren
op_star
l_int|3
)paren
)paren
op_mod
id|RX_SIZE
suffix:semicolon
id|outb
c_func
(paren
id|CR1_STOP_REG_UPDATE
op_or
(paren
id|lp-&gt;stop
op_rshift
id|RX_SIZE_SHIFT
)paren
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP1_INT_ENABLE
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP1_SWIT_TO_PORT_0
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset receive DMA pointer */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_TX_DMA_RESET
)paren
suffix:semicolon
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
multiline_comment|/* Receive DMA on channel 1 */
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_ru_start(): rcv-enable&quot;
comma
id|CR0_CHNL
op_or
id|OP0_RCV_ENABLE
comma
id|SR0_NO_RESULT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_I82593_SHOW
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* spin until the chip starts receiving */
r_do
(brace
id|spin_lock_irqsave
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OP0_NOP
op_or
id|CR0_STATUS_3
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_increment
OG
l_int|10000
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_amp
id|SR3_RCV_STATE_MASK
)paren
op_ne
id|SR3_RCV_ACTIVE
)paren
op_logical_and
(paren
(paren
id|status
op_amp
id|SR3_RCV_STATE_MASK
)paren
op_ne
id|SR3_RCV_READY
)paren
)paren
(brace
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;rcv status is 0x%x [i:%d]&bslash;n&quot;
comma
(paren
id|status
op_amp
id|SR3_RCV_STATE_MASK
)paren
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_ru_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine does a standard config of the WaveLAN controler (i82593).&n; * In the ISA driver, this is integrated in wavelan_hardware_reset()&n; * (called by wv_hw_config(), wv_82593_reconfig() &amp; wavelan_packet_xmit())&n; */
r_static
r_int
DECL|function|wv_82593_config
id|wv_82593_config
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|i82593_conf_block
id|cfblk
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_82593_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Create &amp; fill i82593 config block&n;   *&n;   * Now conform to Wavelan document WCIN085B&n;   */
id|memset
c_func
(paren
op_amp
id|cfblk
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|i82593_conf_block
)paren
)paren
suffix:semicolon
id|cfblk.d6mod
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Run in i82593 advanced mode */
id|cfblk.fifo_limit
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* = 56 B rx and 40 B tx fifo thresholds */
id|cfblk.forgnesi
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* 0=82C501, 1=AMD7992B compatibility */
id|cfblk.fifo_32
op_assign
l_int|1
suffix:semicolon
id|cfblk.throttle_enb
op_assign
id|FALSE
suffix:semicolon
id|cfblk.contin
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* enable continuous mode */
id|cfblk.cntrxint
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* enable continuous mode receive interrupts */
id|cfblk.addr_len
op_assign
id|WAVELAN_ADDR_SIZE
suffix:semicolon
id|cfblk.acloc
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Disable source addr insertion by i82593 */
id|cfblk.preamb_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 2 bytes preamble (SFD) */
id|cfblk.loopback
op_assign
id|FALSE
suffix:semicolon
id|cfblk.lin_prio
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* conform to 802.3 backoff algoritm */
id|cfblk.exp_prio
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* conform to 802.3 backoff algoritm */
id|cfblk.bof_met
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* conform to 802.3 backoff algoritm */
id|cfblk.ifrm_spc
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* 32 bit times interframe spacing */
id|cfblk.slottim_low
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* 32 bit times slot time */
id|cfblk.slottim_hi
op_assign
l_int|0x0
suffix:semicolon
id|cfblk.max_retr
op_assign
l_int|15
suffix:semicolon
id|cfblk.prmisc
op_assign
(paren
(paren
id|lp-&gt;promiscuous
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* Promiscuous mode */
id|cfblk.bc_dis
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Enable broadcast reception */
id|cfblk.crs_1
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Transmit without carrier sense */
id|cfblk.nocrc_ins
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* i82593 generates CRC */
id|cfblk.crc_1632
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* 32-bit Autodin-II CRC */
id|cfblk.crs_cdt
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* CD not to be interpreted as CS */
id|cfblk.cs_filter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CS is recognized immediately */
id|cfblk.crs_src
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* External carrier sense */
id|cfblk.cd_filter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CD is recognized immediately */
id|cfblk.min_fr_len
op_assign
id|ETH_ZLEN
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* Minimum frame length 64 bytes */
id|cfblk.lng_typ
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Length field &gt; 1500 = type field */
id|cfblk.lng_fld
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Disable 802.3 length field check */
id|cfblk.rxcrc_xf
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Don&squot;t transfer CRC to memory */
id|cfblk.artx
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Disable automatic retransmission */
id|cfblk.sarec
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Disable source addr trig of CD */
id|cfblk.tx_jabber
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Disable jabber jam sequence */
id|cfblk.hash_1
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Use bits 0-5 in mc address hash */
id|cfblk.lbpkpol
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Loopback pin active high */
id|cfblk.fdx
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Disable full duplex operation */
id|cfblk.dummy_6
op_assign
l_int|0x3f
suffix:semicolon
multiline_comment|/* all ones */
id|cfblk.mult_ia
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* No multiple individual addresses */
id|cfblk.dis_bof
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Disable the backoff algorithm ?! */
id|cfblk.dummy_1
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* set to 1 */
id|cfblk.tx_ifs_retrig
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Hmm... Disabled */
macro_line|#ifdef MULTICAST_ALL
id|cfblk.mc_all
op_assign
(paren
id|lp-&gt;allmulticast
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* Allow all multicasts */
macro_line|#else
id|cfblk.mc_all
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* No multicast all mode */
macro_line|#endif
id|cfblk.rcv_mon
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Monitor mode disabled */
id|cfblk.frag_acpt
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Do not accept fragments */
id|cfblk.tstrttrs
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* No start transmission threshold */
id|cfblk.fretx
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* FIFO automatic retransmission */
id|cfblk.syncrqs
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Synchronous DRQ deassertion... */
id|cfblk.sttlen
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* 6 byte status registers */
id|cfblk.rx_eop
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Signal EOP on packet reception */
id|cfblk.tx_eop
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Signal EOP on packet transmission */
id|cfblk.rbuf_size
op_assign
id|RX_SIZE
op_rshift
l_int|11
suffix:semicolon
multiline_comment|/* Set receive buffer size */
id|cfblk.rcvstop
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Enable Receive Stop Register */
macro_line|#ifdef DEBUG_I82593_SHOW
(brace
id|u_char
op_star
id|c
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cfblk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wavelan_cs: config block:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|i82593_conf_block
)paren
suffix:semicolon
id|i
op_increment
comma
id|c
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_DEBUG
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
op_star
id|c
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Copy the config block to the i82593 */
id|outb
c_func
(paren
id|TX_BASE
op_amp
l_int|0xff
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|TX_BASE
op_rshift
l_int|8
)paren
op_amp
id|PIORH_MASK
)paren
op_or
id|PIORH_SEL_TX
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
r_sizeof
(paren
r_struct
id|i82593_conf_block
)paren
op_amp
l_int|0xff
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* lsb */
id|outb
c_func
(paren
r_sizeof
(paren
r_struct
id|i82593_conf_block
)paren
op_rshift
l_int|8
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* msb */
id|outsb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
comma
(paren
r_char
op_star
)paren
op_amp
id|cfblk
comma
r_sizeof
(paren
r_struct
id|i82593_conf_block
)paren
)paren
suffix:semicolon
multiline_comment|/* reset transmit DMA pointer */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_TX_DMA_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_82593_config(): configure&quot;
comma
id|OP0_CONFIGURE
comma
id|SR0_CONFIGURE_DONE
)paren
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Initialize adapter&squot;s ethernet MAC address */
id|outb
c_func
(paren
id|TX_BASE
op_amp
l_int|0xff
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|TX_BASE
op_rshift
l_int|8
)paren
op_amp
id|PIORH_MASK
)paren
op_or
id|PIORH_SEL_TX
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|WAVELAN_ADDR_SIZE
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* byte count lsb */
id|outb
c_func
(paren
l_int|0
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* byte count msb */
id|outsb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
comma
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
multiline_comment|/* reset transmit DMA pointer */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_TX_DMA_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_82593_config(): ia-setup&quot;
comma
id|OP0_IA_SETUP
comma
id|SR0_IA_SETUP_DONE
)paren
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#ifdef WAVELAN_ROAMING
multiline_comment|/* If roaming is enabled, join the &quot;Beacon Request&quot; multicast group... */
multiline_comment|/* But only if it&squot;s not in there already! */
r_if
c_cond
(paren
id|do_roaming
)paren
(brace
id|dev_mc_add
c_func
(paren
id|dev
comma
id|WAVELAN_BEACON_ADDRESS
comma
id|WAVELAN_ADDR_SIZE
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* WAVELAN_ROAMING */
multiline_comment|/* If any multicast address to set */
r_if
c_cond
(paren
id|lp-&gt;mc_count
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_int
id|addrs_len
op_assign
id|WAVELAN_ADDR_SIZE
op_star
id|lp-&gt;mc_count
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_hw_config(): set %d multicast addresses:&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;mc_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|1
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|2
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|3
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|4
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Initialize adapter&squot;s ethernet multicast addresses */
id|outb
c_func
(paren
id|TX_BASE
op_amp
l_int|0xff
comma
id|PIORL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|TX_BASE
op_rshift
l_int|8
)paren
op_amp
id|PIORH_MASK
)paren
op_or
id|PIORH_SEL_TX
comma
id|PIORH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addrs_len
op_amp
l_int|0xff
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* byte count lsb */
id|outb
c_func
(paren
(paren
id|addrs_len
op_rshift
l_int|8
)paren
comma
id|PIOP
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* byte count msb */
r_for
c_loop
(paren
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|outsb
c_func
(paren
id|PIOP
c_func
(paren
id|base
)paren
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
multiline_comment|/* reset transmit DMA pointer */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_PWR_STAT
op_or
id|HACR_TX_DMA_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wv_82593_cmd
c_func
(paren
id|dev
comma
l_string|&quot;wv_82593_config(): mc-setup&quot;
comma
id|OP0_MC_SETUP
comma
id|SR0_MC_SETUP_DONE
)paren
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
id|lp-&gt;mc_count
op_assign
id|dev-&gt;mc_count
suffix:semicolon
multiline_comment|/* remember to avoid repeated reset */
)brace
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_82593_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read the Access Configuration Register, perform a software reset,&n; * and then re-enable the card&squot;s software.&n; *&n; * If I understand correctly : reset the pcmcia interface of the&n; * wavelan.&n; * (called by wv_config())&n; */
r_static
r_inline
r_int
DECL|function|wv_pcmcia_reset
id|wv_pcmcia_reset
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
id|conf_reg_t
id|reg
op_assign
(brace
l_int|0
comma
id|CS_READ
comma
id|CISREG_COR
comma
l_int|0
)brace
suffix:semicolon
id|dev_link_t
op_star
id|link
op_assign
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|link
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_pcmcia_reset()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|CardServices
c_func
(paren
id|AccessConfigurationRegister
comma
id|link-&gt;handle
comma
op_amp
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|AccessConfigurationRegister
comma
id|i
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_pcmcia_reset(): Config reg is 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|u_int
)paren
id|reg.Value
)paren
suffix:semicolon
macro_line|#endif
id|reg.Action
op_assign
id|CS_WRITE
suffix:semicolon
id|reg.Value
op_assign
id|reg.Value
op_or
id|COR_SW_RESET
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|AccessConfigurationRegister
comma
id|link-&gt;handle
comma
op_amp
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|AccessConfigurationRegister
comma
id|i
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|reg.Action
op_assign
id|CS_WRITE
suffix:semicolon
id|reg.Value
op_assign
id|COR_LEVEL_IRQ
op_or
id|COR_CONFIG
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|AccessConfigurationRegister
comma
id|link-&gt;handle
comma
op_amp
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|AccessConfigurationRegister
comma
id|i
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_pcmcia_reset()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * wavelan_hw_config() is called after a CARD_INSERTION event is&n; * received, to configure the wavelan hardware.&n; * Note that the reception will be enabled in wavelan-&gt;open(), so the&n; * device is configured but idle...&n; * Performs the following actions:&n; * &t;1. A pcmcia software reset (using wv_pcmcia_reset())&n; *&t;2. A power reset (reset DMA)&n; *&t;3. Reset the LAN controller&n; *&t;4. Initialize the radio modem (using wv_mmc_init)&n; *&t;5. Configure LAN controller (using wv_82593_config)&n; *&t;6. Perform a diagnostic on the LAN controller&n; * (called by wavelan_event() &amp; wv_hw_reset())&n; */
r_static
r_int
DECL|function|wv_hw_config
id|wv_hw_config
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_hw_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef STRUCT_CHECK
r_if
c_cond
(paren
id|wv_structuct_check
c_func
(paren
)paren
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wv_hw_config: structure/compiler botch: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|wv_structuct_check
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#endif&t;/* STRUCT_CHECK == 1 */
multiline_comment|/* Reset the pcmcia interface */
r_if
c_cond
(paren
id|wv_pcmcia_reset
c_func
(paren
id|dev
)paren
op_eq
id|FALSE
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Power UP the module + reset the modem + reset host adapter&n;   * (in fact, reset DMA channels) */
id|hacr_write_slow
c_func
(paren
id|base
comma
id|HACR_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
multiline_comment|/* Check if the the module has been powered up... */
r_if
c_cond
(paren
id|hasr_read
c_func
(paren
id|base
)paren
op_amp
id|HASR_NO_CLK
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wv_hw_config(): modem not connected or not a wavelan card&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* initialize the modem */
r_if
c_cond
(paren
id|wv_mmc_init
c_func
(paren
id|dev
)paren
op_eq
id|FALSE
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* reset the LAN controller (i82593) */
id|outb
c_func
(paren
id|OP0_RESET
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* A bit crude ! */
multiline_comment|/* Initialize the LAN controler */
r_if
c_cond
(paren
(paren
id|wv_82593_config
c_func
(paren
id|dev
)paren
op_eq
id|FALSE
)paren
op_logical_or
(paren
id|wv_diag
c_func
(paren
id|dev
)paren
op_eq
id|FALSE
)paren
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_hw_config(): i82593 init failed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* &n;   * insert code for loopback test here&n;   */
multiline_comment|/* The device is now configured */
id|lp-&gt;configured
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_hw_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Totally reset the wavelan and restart it.&n; * Performs the following actions:&n; * &t;1. Call wv_hw_config()&n; *&t;2. Start the LAN controller&squot;s receive unit&n; * (called by wavelan_event(), wavelan_watchdog() and wavelan_open())&n; */
r_static
r_inline
r_void
DECL|function|wv_hw_reset
id|wv_hw_reset
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_hw_reset()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If watchdog was activated, kill it ! */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
suffix:semicolon
id|lp-&gt;nresets
op_increment
suffix:semicolon
id|lp-&gt;configured
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Call wv_hw_config() for most of the reset &amp; init stuff */
r_if
c_cond
(paren
id|wv_hw_config
c_func
(paren
id|dev
)paren
op_eq
id|FALSE
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* start receive unit */
id|wv_ru_start
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_hw_reset()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * wv_pcmcia_config() is called after a CARD_INSERTION event is&n; * received, to configure the PCMCIA socket, and to make the ethernet&n; * device available to the system.&n; * (called by wavelan_event())&n; */
r_static
r_inline
r_int
DECL|function|wv_pcmcia_config
id|wv_pcmcia_config
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
id|client_handle_t
id|handle
suffix:semicolon
id|tuple_t
id|tuple
suffix:semicolon
id|cisparse_t
id|parse
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|win_req_t
id|req
suffix:semicolon
id|memreq_t
id|mem
suffix:semicolon
id|handle
op_assign
id|link-&gt;handle
suffix:semicolon
id|dev
op_assign
(paren
id|device
op_star
)paren
id|link-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt;wv_pcmcia_config(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * This reads the card&squot;s CONFIG tuple to find its configuration&n;   * registers.&n;   */
r_do
(brace
id|tuple.Attributes
op_assign
l_int|0
suffix:semicolon
id|tuple.DesiredTuple
op_assign
id|CISTPL_CONFIG
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|GetFirstTuple
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
r_break
suffix:semicolon
)brace
id|tuple.TupleData
op_assign
(paren
id|cisdata_t
op_star
)paren
id|buf
suffix:semicolon
id|tuple.TupleDataMax
op_assign
l_int|64
suffix:semicolon
id|tuple.TupleOffset
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|GetTupleData
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
r_break
suffix:semicolon
)brace
id|i
op_assign
id|CardServices
c_func
(paren
id|ParseTuple
comma
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
r_break
suffix:semicolon
)brace
id|link-&gt;conf.ConfigBase
op_assign
id|parse.config.base
suffix:semicolon
id|link-&gt;conf.Present
op_assign
id|parse.config.rmask
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|ParseTuple
comma
id|i
)paren
suffix:semicolon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG_PENDING
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Configure card */
id|link-&gt;state
op_or_assign
id|DEV_CONFIG
suffix:semicolon
r_do
(brace
id|i
op_assign
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestIO
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;       * Now allocate an interrupt line.  Note that this does not&n;       * actually assign a handler to the interrupt.&n;       */
id|i
op_assign
id|CardServices
c_func
(paren
id|RequestIRQ
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestIRQ
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;       * This actually configures the PCMCIA socket -- setting up&n;       * the I/O windows and the interrupt mapping.&n;       */
id|link-&gt;conf.ConfigIndex
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|RequestConfiguration
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestConfiguration
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;       * Allocate a 4K memory window.  Note that the dev_link_t&n;       * structure provides space for one window handle -- if your&n;       * device needs several windows, you&squot;ll need to keep track of&n;       * the handles in your private data structure, link-&gt;priv.&n;       */
id|req.Attributes
op_assign
id|WIN_DATA_WIDTH_8
op_or
id|WIN_MEMORY_TYPE_AM
op_or
id|WIN_ENABLE
suffix:semicolon
id|req.Base
op_assign
l_int|0
suffix:semicolon
id|req.Size
op_assign
l_int|0x1000
suffix:semicolon
id|req.AccessSpeed
op_assign
id|mem_speed
suffix:semicolon
id|link-&gt;win
op_assign
(paren
id|window_handle_t
)paren
id|link-&gt;handle
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|RequestWindow
comma
op_amp
id|link-&gt;win
comma
op_amp
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestWindow
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;rmem_start
op_assign
id|dev-&gt;mem_start
op_assign
(paren
id|u_long
)paren
id|ioremap
c_func
(paren
id|req.Base
comma
l_int|0x1000
)paren
suffix:semicolon
id|dev-&gt;rmem_end
op_assign
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|req.Size
suffix:semicolon
id|mem.CardOffset
op_assign
l_int|0
suffix:semicolon
id|mem.Page
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|CardServices
c_func
(paren
id|MapMemPage
comma
id|link-&gt;win
comma
op_amp
id|mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|MapMemPage
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Feed device with this info... */
id|dev-&gt;irq
op_assign
id|link-&gt;irq.AssignedIRQ
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|link-&gt;io.BasePort1
suffix:semicolon
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wv_pcmcia_config: MEMSTART 0x%x IRQ %d IOPORT 0x%x&bslash;n&quot;
comma
(paren
id|u_int
)paren
id|dev-&gt;mem_start
comma
id|dev-&gt;irq
comma
(paren
id|u_int
)paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wv_pcmcia_config(): register_netdev() failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Humm... Disguised goto !!! */
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG_PENDING
suffix:semicolon
multiline_comment|/* If any step failed, release any partially configured state */
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
(brace
id|wv_pcmcia_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* ???? Could you explain me this, Dave ? */
id|link-&gt;dev
op_assign
op_amp
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|node
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;-wv_pcmcia_config()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * After a card is removed, wv_pcmcia_release() will unregister the net&n; * device, and release the PCMCIA configuration.  If the device is&n; * still open, this will be postponed until it is closed.&n; */
r_static
r_void
DECL|function|wv_pcmcia_release
id|wv_pcmcia_release
c_func
(paren
id|u_long
id|arg
)paren
multiline_comment|/* Address of the interface struct */
(brace
id|dev_link_t
op_star
id|link
op_assign
(paren
id|dev_link_t
op_star
)paren
id|arg
suffix:semicolon
id|device
op_star
id|dev
op_assign
(paren
id|device
op_star
)paren
id|link-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt; wv_pcmcia_release(0x%p)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|link
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If the device is currently in use, we won&squot;t release until it is&n;   * actually closed. */
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_pcmcia_release: release postponed, device still open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|link-&gt;state
op_or_assign
id|DEV_STALE_CONFIG
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t bother checking to see if these succeed or not */
id|iounmap
c_func
(paren
(paren
id|u_char
op_star
)paren
id|dev-&gt;mem_start
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseWindow
comma
id|link-&gt;win
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseConfiguration
comma
id|link-&gt;handle
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseIRQ
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;irq
)paren
suffix:semicolon
id|link-&gt;state
op_and_assign
op_complement
(paren
id|DEV_CONFIG
op_or
id|DEV_RELEASE_PENDING
op_or
id|DEV_STALE_CONFIG
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;- wv_pcmcia_release()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* wv_pcmcia_release */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Sometimes, netwave_detach can&squot;t be performed following a call from&n; * cardmgr (device still open, pcmcia_release not done) and the device&n; * is put in a STALE_LINK state and remains in memory.&n; *&n; * This function run through our current list of device and attempt&n; * another time to remove them. We hope that since last time the&n; * device has properly been closed.&n; *&n; * (called by wavelan_attach() &amp; cleanup_module())&n; */
r_static
r_void
DECL|function|wv_flush_stale_links
id|wv_flush_stale_links
c_func
(paren
r_void
)paren
(brace
id|dev_link_t
op_star
id|link
suffix:semicolon
multiline_comment|/* Current node in linked list */
id|dev_link_t
op_star
id|next
suffix:semicolon
multiline_comment|/* Next node in linked list */
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; wv_flush_stale_links(0x%p)&bslash;n&quot;
comma
id|dev_list
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Go through the list */
r_for
c_loop
(paren
id|link
op_assign
id|dev_list
suffix:semicolon
id|link
suffix:semicolon
id|link
op_assign
id|next
)paren
(brace
id|next
op_assign
id|link-&gt;next
suffix:semicolon
multiline_comment|/* Check if in need of being removed */
r_if
c_cond
(paren
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_LINK
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|link-&gt;state
op_amp
id|DEV_PRESENT
)paren
)paren
)paren
(brace
id|wavelan_detach
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- wv_flush_stale_links()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************ INTERRUPT HANDLING ************************/
multiline_comment|/*&n; * This function is the interrupt handler for the WaveLAN card. This&n; * routine will be called whenever: &n; *&t;1. A packet is received.&n; *&t;2. A packet has successfully been transfered and the unit is&n; *&t;   ready to transmit another packet.&n; *&t;3. A command has completed execution.&n; */
r_static
r_void
DECL|function|wavelan_interrupt
id|wavelan_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|device
op_star
id|dev
suffix:semicolon
id|net_local
op_star
id|lp
suffix:semicolon
id|ioaddr_t
id|base
suffix:semicolon
r_int
id|status0
suffix:semicolon
id|u_int
id|tx_status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
(paren
id|device
op_star
)paren
id|dev_id
)paren
op_eq
(paren
id|device
op_star
)paren
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;wavelan_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_interrupt()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|spin_lock
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Treat all pending interrupts */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* ---------------- INTERRUPT CHECKING ---------------- */
multiline_comment|/*&n;       * Look for the interrupt and verify the validity&n;       */
id|outb
c_func
(paren
id|CR0_STATUS_0
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status0
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;status0 0x%x [%s =&gt; 0x%x]&quot;
comma
id|status0
comma
(paren
id|status0
op_amp
id|SR0_INTERRUPT
)paren
ques
c_cond
l_string|&quot;int&quot;
suffix:colon
l_string|&quot;no int&quot;
comma
id|status0
op_amp
op_complement
id|SR0_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status0
op_amp
id|SR0_INTERRUPT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; [%s =&gt; %d]&bslash;n&quot;
comma
(paren
id|status0
op_amp
id|SR0_CHNL
)paren
ques
c_cond
l_string|&quot;chnl&quot;
suffix:colon
(paren
(paren
id|status0
op_amp
id|SR0_EXECUTION
)paren
ques
c_cond
l_string|&quot;cmd&quot;
suffix:colon
(paren
(paren
id|status0
op_amp
id|SR0_RECEPTION
)paren
ques
c_cond
l_string|&quot;recv&quot;
suffix:colon
l_string|&quot;unknown&quot;
)paren
)paren
comma
(paren
id|status0
op_amp
id|SR0_EVENT_MASK
)paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Return if no actual interrupt from i82593 (normal exit) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status0
op_amp
id|SR0_INTERRUPT
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* If interrupt is both Rx and Tx or none...&n;       * This code in fact is there to catch the spurious interrupt&n;       * when you remove the wavelan pcmcia card from the socket */
r_if
c_cond
(paren
(paren
(paren
id|status0
op_amp
id|SR0_BOTH_RX_TX
)paren
op_eq
id|SR0_BOTH_RX_TX
)paren
op_logical_or
(paren
(paren
id|status0
op_amp
id|SR0_BOTH_RX_TX
)paren
op_eq
l_int|0x0
)paren
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_interrupt(): bogus interrupt (or from dead card) : %X&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Acknowledge the interrupt */
id|outb
c_func
(paren
id|CR0_INT_ACK
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;status
op_assign
id|status0
suffix:semicolon
multiline_comment|/* Save current status (for commands) */
multiline_comment|/* ----------------- RECEIVING PACKET ----------------- */
multiline_comment|/*&n;       * When the wavelan signal the reception of a new packet,&n;       * we call wv_packet_rcv() to copy if from the buffer and&n;       * send it to NET3&n;       */
r_if
c_cond
(paren
id|status0
op_amp
id|SR0_RECEPTION
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): receive&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|status0
op_amp
id|SR0_EVENT_MASK
)paren
op_eq
id|SR0_STOP_REG_HIT
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_interrupt(): receive buffer overflow&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
id|lp-&gt;overrunning
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Get the packet */
id|wv_packet_rcv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;overrunning
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Acknowledge the interrupt */
id|outb
c_func
(paren
id|CR0_INT_ACK
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* ---------------- COMMAND COMPLETION ---------------- */
multiline_comment|/*&n;       * Interrupts issued when the i82593 has completed a command.&n;       * Most likely : transmission done&n;       */
multiline_comment|/* If we are already waiting elsewhere for the command to complete */
r_if
c_cond
(paren
id|wv_wait_completed
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): command completed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Signal command completion */
id|wv_wait_completed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Acknowledge the interrupt */
id|outb
c_func
(paren
id|CR0_INT_ACK
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If a transmission has been done */
r_if
c_cond
(paren
(paren
id|status0
op_amp
id|SR0_EVENT_MASK
)paren
op_eq
id|SR0_TRANSMIT_DONE
op_logical_or
(paren
id|status0
op_amp
id|SR0_EVENT_MASK
)paren
op_eq
id|SR0_RETRANSMIT_DONE
op_logical_or
(paren
id|status0
op_amp
id|SR0_EVENT_MASK
)paren
op_eq
id|SR0_TRANSMIT_NO_CRC_DONE
)paren
(brace
macro_line|#ifdef DEBUG_TX_ERROR
r_if
c_cond
(paren
(paren
id|status0
op_amp
id|SR0_EVENT_MASK
)paren
op_eq
id|SR0_TRANSMIT_NO_CRC_DONE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_interrupt(): packet transmitted without CRC.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* If watchdog was activated, kill it ! */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
suffix:semicolon
)brace
multiline_comment|/* Get transmission status */
id|tx_status
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|tx_status
op_or_assign
(paren
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): transmission done&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
(brace
id|u_int
id|rcv_bytes
suffix:semicolon
id|u_char
id|status3
suffix:semicolon
id|rcv_bytes
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|rcv_bytes
op_or_assign
(paren
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|status3
op_assign
id|inb
c_func
(paren
id|LCSR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tx_status 0x%02x rcv_bytes 0x%02x status3 0x%x&bslash;n&quot;
comma
id|tx_status
comma
id|rcv_bytes
comma
(paren
id|u_int
)paren
id|status3
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Check for possible errors */
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|TX_OK
)paren
op_ne
id|TX_OK
)paren
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_FRTL
)paren
(brace
macro_line|#ifdef DEBUG_TX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_interrupt(): frame too long&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_UND_RUN
)paren
(brace
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): DMA underrun&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_LOST_CTS
)paren
(brace
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): no CTS&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_LOST_CRS
)paren
(brace
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): no carrier&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_HRT_BEAT
)paren
(brace
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): heart beat&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_DEFER
)paren
(brace
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): channel jammed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Ignore late collisions since they&squot;re more likely to happen&n;&t;       * here (the WaveLAN design prevents the LAN controller from&n;&t;       * receiving while it is transmitting). We take action only when&n;&t;       * the maximum retransmit attempts is exceeded.&n;&t;       */
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_COLL
)paren
(brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|TX_MAX_COL
)paren
(brace
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_interrupt(): channel congestion&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|tx_status
op_amp
id|TX_NCOL_MASK
)paren
)paren
(brace
id|lp-&gt;stats.collisions
op_add_assign
l_int|0x10
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* if(!(tx_status &amp; TX_OK)) */
id|lp-&gt;stats.collisions
op_add_assign
(paren
id|tx_status
op_amp
id|TX_NCOL_MASK
)paren
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CR0_INT_ACK
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Acknowledge the interrupt */
)brace
r_else
multiline_comment|/* if interrupt = transmit done or retransmit done */
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wavelan_cs: unknown interrupt, status0 = %02x&bslash;n&quot;
comma
id|status0
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|CR0_INT_ACK
op_or
id|OP0_NOP
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Acknowledge the interrupt */
)brace
)brace
id|spin_unlock_irq
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_interrupt()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* wv_interrupt */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Watchdog : when we start a transmission, we set a timer in the&n; * kernel.  If the transmission complete, this timer is disabled. If&n; * it expire, it try to unlock the hardware.&n; *&n; * Note : this watchdog doesn&squot;t work on the same principle as the&n; * watchdog in the ISA driver. I make it this way because the overhead&n; * of add_timer() and del_timer() is nothing and that it avoid calling&n; * the watchdog, saving some CPU... If you want to apply the same&n; * watchdog to the ISA driver, you should be a bit carefull, because&n; * of the many transmit buffers...&n; * This watchdog is also move clever, it try to abort the current&n; * command before reseting everything...&n; */
r_static
r_void
DECL|function|wavelan_watchdog
id|wavelan_watchdog
c_func
(paren
id|u_long
id|a
)paren
(brace
id|device
op_star
id|dev
suffix:semicolon
id|net_local
op_star
id|lp
suffix:semicolon
id|ioaddr_t
id|base
suffix:semicolon
r_int
id|spin
suffix:semicolon
id|dev
op_assign
(paren
id|device
op_star
)paren
id|a
suffix:semicolon
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_watchdog()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_watchdog: watchdog timer expired&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We are waiting for command completion */
id|wv_wait_completed
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Ask to abort the current command */
id|outb
c_func
(paren
id|OP0_ABORT
comma
id|LCCR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Busy wait while the LAN controller executes the command.&n;   * Note : wv_wait_completed should be volatile */
id|spin
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|wv_wait_completed
op_logical_and
(paren
id|spin
op_increment
OL
l_int|250
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* If the interrupt handler hasn&squot;t be called or invalid status */
r_if
c_cond
(paren
(paren
id|wv_wait_completed
)paren
op_logical_or
(paren
(paren
id|lp-&gt;status
op_amp
id|SR0_EVENT_MASK
)paren
op_ne
id|SR0_EXECUTION_ABORTED
)paren
)paren
(brace
multiline_comment|/* It seem that it wasn&squot;t enough */
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_watchdog: abort failed, trying reset&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_hw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PSA_SHOW
(brace
id|psa_t
id|psa
suffix:semicolon
id|psa_read
c_func
(paren
id|dev
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
id|wv_psa_show
c_func
(paren
op_amp
id|psa
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DEBUG_MMC_SHOW
id|wv_mmc_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_I82593_SHOW
id|wv_ru_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We are no more waiting for something... */
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_watchdog()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/********************* CONFIGURATION CALLBACKS *********************/
multiline_comment|/*&n; * Here are the functions called by the pcmcia package (cardmgr) and&n; * linux networking (NET3) for initialization, configuration and&n; * deinstallations of the Wavelan Pcmcia Hardware.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Configure and start up the WaveLAN PCMCIA adaptor.&n; * Called by NET3 when it &quot;open&quot; the device.&n; */
r_static
r_int
DECL|function|wavelan_open
id|wavelan_open
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|link
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_open(dev=0x%x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check if the modem is powered up (wavelan_close() power it down */
r_if
c_cond
(paren
id|hasr_read
c_func
(paren
id|base
)paren
op_amp
id|HASR_NO_CLK
)paren
(brace
multiline_comment|/* Power up (power up time is 250us) */
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
multiline_comment|/* Check if the the module has been powered up... */
r_if
c_cond
(paren
id|hasr_read
c_func
(paren
id|base
)paren
op_amp
id|HASR_NO_CLK
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wavelan_open(): modem not connected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/* Start reception and declare the driver ready */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;configured
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wv_ru_start
c_func
(paren
id|dev
)paren
)paren
(brace
id|wv_hw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* If problem : reset */
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Mark the device as used */
id|link-&gt;open
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#ifdef WAVELAN_ROAMING
r_if
c_cond
(paren
id|do_roaming
)paren
(brace
id|wv_roam_init
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* WAVELAN_ROAMING */
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_open()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Shutdown the WaveLAN PCMCIA adaptor.&n; * Called by NET3 when it &quot;close&quot; the device.&n; */
r_static
r_int
DECL|function|wavelan_close
id|wavelan_close
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|link
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_close(dev=0x%x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* If the device isn&squot;t open, then nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|link-&gt;open
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_close(): device not open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef WAVELAN_ROAMING
multiline_comment|/* Cleanup of roaming stuff... */
r_if
c_cond
(paren
id|do_roaming
)paren
(brace
id|wv_roam_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* WAVELAN_ROAMING */
multiline_comment|/* If watchdog was activated, kill it ! */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;watchdog
)paren
suffix:semicolon
)brace
id|link-&gt;open
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/* If the card is still present */
r_if
c_cond
(paren
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
(brace
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Stop receiving new messages and wait end of transmission */
id|wv_ru_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Power down the module */
id|hacr_write
c_func
(paren
id|base
comma
id|HACR_DEFAULT
op_amp
(paren
op_complement
id|HACR_PWR_STAT
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* The card is no more there (flag is activated in wv_pcmcia_release) */
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_CONFIG
)paren
(brace
id|wv_pcmcia_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_close()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * We never need to do anything when a wavelan device is &quot;initialized&quot;&n; * by the net software, because we only register already-found cards.&n; */
r_static
r_int
DECL|function|wavelan_init
id|wavelan_init
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;&gt;wavelan_init()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * wavelan_attach() creates an &quot;instance&quot; of the driver, allocating&n; * local data structures for one device (one interface).  The device&n; * is registered with Card Services.&n; *&n; * The dev_link structure is initialized, but we don&squot;t actually&n; * configure the card at this point -- we wait until we receive a&n; * card insertion event.&n; */
r_static
id|dev_link_t
op_star
DECL|function|wavelan_attach
id|wavelan_attach
c_func
(paren
r_void
)paren
(brace
id|client_reg_t
id|client_reg
suffix:semicolon
multiline_comment|/* Register with cardmgr */
id|dev_link_t
op_star
id|link
suffix:semicolon
multiline_comment|/* Info for cardmgr */
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Interface generic data */
id|net_local
op_star
id|lp
suffix:semicolon
multiline_comment|/* Interface specific data */
r_int
id|i
comma
id|ret
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; wavelan_attach()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Perform some cleanup */
id|wv_flush_stale_links
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the dev_link_t structure */
id|link
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dev_link_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|link
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dev_link_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Unused for the Wavelan */
id|link-&gt;release.function
op_assign
op_amp
id|wv_pcmcia_release
suffix:semicolon
id|link-&gt;release.data
op_assign
(paren
id|u_long
)paren
id|link
suffix:semicolon
multiline_comment|/* The io structure describes IO port mapping */
id|link-&gt;io.NumPorts1
op_assign
l_int|8
suffix:semicolon
id|link-&gt;io.Attributes1
op_assign
id|IO_DATA_PATH_WIDTH_8
suffix:semicolon
id|link-&gt;io.IOAddrLines
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Interrupt setup */
id|link-&gt;irq.Attributes
op_assign
id|IRQ_TYPE_EXCLUSIVE
op_or
id|IRQ_HANDLE_PRESENT
suffix:semicolon
id|link-&gt;irq.IRQInfo1
op_assign
id|IRQ_INFO2_VALID
op_or
id|IRQ_LEVEL_ID
suffix:semicolon
r_if
c_cond
(paren
id|irq_list
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
id|link-&gt;irq.IRQInfo2
op_assign
id|irq_mask
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|link-&gt;irq.IRQInfo2
op_or_assign
l_int|1
op_lshift
id|irq_list
(braket
id|i
)braket
suffix:semicolon
id|link-&gt;irq.Handler
op_assign
id|wavelan_interrupt
suffix:semicolon
multiline_comment|/* General socket configuration */
id|link-&gt;conf.Attributes
op_assign
id|CONF_ENABLE_IRQ
suffix:semicolon
id|link-&gt;conf.Vcc
op_assign
l_int|50
suffix:semicolon
id|link-&gt;conf.IntType
op_assign
id|INT_MEMORY_AND_IO
suffix:semicolon
multiline_comment|/* Chain drivers */
id|link-&gt;next
op_assign
id|dev_list
suffix:semicolon
id|dev_list
op_assign
id|link
suffix:semicolon
multiline_comment|/* Allocate the generic data structure */
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|link-&gt;priv
op_assign
id|link-&gt;irq.Instance
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Allocate the wavelan-specific data structure. */
id|dev-&gt;priv
op_assign
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|lp
comma
l_int|0x00
comma
r_sizeof
(paren
id|net_local
)paren
)paren
suffix:semicolon
multiline_comment|/* Init specific data */
id|wv_wait_completed
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;status
op_assign
id|FALSE
suffix:semicolon
id|lp-&gt;configured
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;reconfig_82593
op_assign
id|FALSE
suffix:semicolon
id|lp-&gt;nresets
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set the watchdog timer */
id|lp-&gt;watchdog.function
op_assign
id|wavelan_watchdog
suffix:semicolon
id|lp-&gt;watchdog.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
multiline_comment|/* back links */
id|lp-&gt;link
op_assign
id|link
suffix:semicolon
id|lp-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Standard setup for generic data */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* wavelan NET3 callbacks */
id|dev-&gt;init
op_assign
op_amp
id|wavelan_init
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|wavelan_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|wavelan_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|wavelan_packet_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|wavelan_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|wavelan_set_multicast_list
suffix:semicolon
macro_line|#ifdef SET_MAC_ADDRESS
id|dev-&gt;set_mac_address
op_assign
op_amp
id|wavelan_set_mac_address
suffix:semicolon
macro_line|#endif&t;/* SET_MAC_ADDRESS */
macro_line|#ifdef WIRELESS_EXT&t;/* If wireless extension exist in the kernel */
id|dev-&gt;do_ioctl
op_assign
id|wavelan_ioctl
suffix:semicolon
multiline_comment|/* wireless extensions */
id|dev-&gt;get_wireless_stats
op_assign
id|wavelan_get_wireless_stats
suffix:semicolon
macro_line|#endif
multiline_comment|/* Other specific data */
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|node.dev_name
)paren
suffix:semicolon
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|WAVELAN_MTU
suffix:semicolon
multiline_comment|/* Register with Card Services */
id|client_reg.dev_info
op_assign
op_amp
id|dev_info
suffix:semicolon
id|client_reg.Attributes
op_assign
id|INFO_IO_CLIENT
op_or
id|INFO_CARD_SHARE
suffix:semicolon
id|client_reg.EventMask
op_assign
id|CS_EVENT_REGISTRATION_COMPLETE
op_or
id|CS_EVENT_CARD_INSERTION
op_or
id|CS_EVENT_CARD_REMOVAL
op_or
id|CS_EVENT_RESET_PHYSICAL
op_or
id|CS_EVENT_CARD_RESET
op_or
id|CS_EVENT_PM_SUSPEND
op_or
id|CS_EVENT_PM_RESUME
suffix:semicolon
id|client_reg.event_handler
op_assign
op_amp
id|wavelan_event
suffix:semicolon
id|client_reg.Version
op_assign
l_int|0x0210
suffix:semicolon
id|client_reg.event_callback_args.client_data
op_assign
id|link
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wavelan_attach(): almost done, calling CardServices&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|CardServices
c_func
(paren
id|RegisterClient
comma
op_amp
id|link-&gt;handle
comma
op_amp
id|client_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RegisterClient
comma
id|ret
)paren
suffix:semicolon
id|wavelan_detach
c_func
(paren
id|link
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- wavelan_attach()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|link
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This deletes a driver &quot;instance&quot;.  The device is de-registered with&n; * Card Services.  If it has been released, all local data structures&n; * are freed.  Otherwise, the structures will be freed when the device&n; * is released.&n; */
r_static
r_void
DECL|function|wavelan_detach
id|wavelan_detach
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; wavelan_detach(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * If the device is currently configured and active, we won&squot;t&n;   * actually delete it yet.  Instead, it is marked so that when the&n;   * release() function is called, that will trigger a proper&n;   * detach().&n;   */
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
multiline_comment|/* Some others haven&squot;t done their job : give them another chance */
id|wv_pcmcia_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_CONFIG
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wavelan_detach: detach postponed,&quot;
l_string|&quot; &squot;%s&squot; still locked&bslash;n&quot;
comma
id|link-&gt;dev-&gt;dev_name
)paren
suffix:semicolon
macro_line|#endif
id|link-&gt;state
op_or_assign
id|DEV_STALE_LINK
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Break the link with Card Services */
r_if
c_cond
(paren
id|link-&gt;handle
)paren
(brace
id|CardServices
c_func
(paren
id|DeregisterClient
comma
id|link-&gt;handle
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove the interface data from the linked list */
r_if
c_cond
(paren
id|dev_list
op_eq
id|link
)paren
(brace
id|dev_list
op_assign
id|link-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dev_link_t
op_star
id|prev
op_assign
id|dev_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|prev
op_ne
(paren
id|dev_link_t
op_star
)paren
l_int|NULL
)paren
op_logical_and
(paren
id|prev-&gt;next
op_ne
id|link
)paren
)paren
(brace
id|prev
op_assign
id|prev-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev
op_eq
(paren
id|dev_link_t
op_star
)paren
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;wavelan_detach : Attempting to remove a nonexistent device.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|prev-&gt;next
op_assign
id|link-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Free pieces */
r_if
c_cond
(paren
id|link-&gt;priv
)paren
(brace
id|device
op_star
id|dev
op_assign
(paren
id|device
op_star
)paren
id|link-&gt;priv
suffix:semicolon
multiline_comment|/* Remove ourselves from the kernel list of ethernet devices */
multiline_comment|/* Warning : can&squot;t be called from interrupt, timer or wavelan_close() */
r_if
c_cond
(paren
id|link-&gt;dev
op_ne
l_int|NULL
)paren
(brace
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|link-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
(brace
multiline_comment|/* Sound strange, but safe... */
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|link
op_assign
(paren
id|dev_link_t
op_star
)paren
l_int|NULL
suffix:semicolon
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|dev
op_assign
(paren
id|device
op_star
)paren
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|link-&gt;priv
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|link
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- wavelan_detach()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * The card status event handler. Mostly, this schedules other stuff&n; * to run after an event is received. A CARD_REMOVAL event also sets&n; * some flags to discourage the net drivers from trying to talk to the&n; * card any more.&n; */
r_static
r_int
DECL|function|wavelan_event
id|wavelan_event
c_func
(paren
id|event_t
id|event
comma
multiline_comment|/* The event received */
r_int
id|priority
comma
id|event_callback_args_t
op_star
id|args
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
(paren
id|dev_link_t
op_star
)paren
id|args-&gt;client_data
suffix:semicolon
id|device
op_star
id|dev
op_assign
(paren
id|device
op_star
)paren
id|link-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt;wavelan_event(): %s&bslash;n&quot;
comma
(paren
(paren
id|event
op_eq
id|CS_EVENT_REGISTRATION_COMPLETE
)paren
ques
c_cond
l_string|&quot;registration complete&quot;
suffix:colon
(paren
(paren
id|event
op_eq
id|CS_EVENT_CARD_REMOVAL
)paren
ques
c_cond
l_string|&quot;card removal&quot;
suffix:colon
(paren
(paren
id|event
op_eq
id|CS_EVENT_CARD_INSERTION
)paren
ques
c_cond
l_string|&quot;card insertion&quot;
suffix:colon
(paren
(paren
id|event
op_eq
id|CS_EVENT_PM_SUSPEND
)paren
ques
c_cond
l_string|&quot;pm suspend&quot;
suffix:colon
(paren
(paren
id|event
op_eq
id|CS_EVENT_RESET_PHYSICAL
)paren
ques
c_cond
l_string|&quot;physical reset&quot;
suffix:colon
(paren
(paren
id|event
op_eq
id|CS_EVENT_PM_RESUME
)paren
ques
c_cond
l_string|&quot;pm resume&quot;
suffix:colon
(paren
(paren
id|event
op_eq
id|CS_EVENT_CARD_RESET
)paren
ques
c_cond
l_string|&quot;card reset&quot;
suffix:colon
l_string|&quot;unknown&quot;
)paren
)paren
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CS_EVENT_REGISTRATION_COMPLETE
suffix:colon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;wavelan_cs: registration complete&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|CS_EVENT_CARD_REMOVAL
suffix:colon
multiline_comment|/* Oups ! The card is no more there */
id|link-&gt;state
op_and_assign
op_complement
id|DEV_PRESENT
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
multiline_comment|/* Accept no more transmissions */
id|netif_device_detach
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Release the card */
id|wv_pcmcia_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CS_EVENT_CARD_INSERTION
suffix:colon
multiline_comment|/* Reset and configure the card */
id|link-&gt;state
op_or_assign
id|DEV_PRESENT
op_or
id|DEV_CONFIG_PENDING
suffix:semicolon
r_if
c_cond
(paren
id|wv_pcmcia_config
c_func
(paren
id|link
)paren
op_logical_and
id|wv_hw_config
c_func
(paren
id|dev
)paren
)paren
(brace
id|wv_init_info
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_EVENT_PM_SUSPEND
suffix:colon
multiline_comment|/* NB: wavelan_close will be called, but too late, so we are&n;&t; * obliged to close nicely the wavelan here. David, could you&n;&t; * close the device before suspending them ? And, by the way,&n;&t; * could you, on resume, add a &quot;route add -net ...&quot; after the&n;&t; * ifconfig up ??? Thanks... */
multiline_comment|/* Stop receiving new messages and wait end of transmission */
id|wv_ru_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Power down the module */
id|hacr_write
c_func
(paren
id|dev-&gt;base_addr
comma
id|HACR_DEFAULT
op_amp
(paren
op_complement
id|HACR_PWR_STAT
)paren
)paren
suffix:semicolon
multiline_comment|/* The card is now suspended */
id|link-&gt;state
op_or_assign
id|DEV_SUSPEND
suffix:semicolon
multiline_comment|/* Fall through... */
r_case
id|CS_EVENT_RESET_PHYSICAL
suffix:colon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
id|netif_device_detach
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|CardServices
c_func
(paren
id|ReleaseConfiguration
comma
id|link-&gt;handle
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CS_EVENT_PM_RESUME
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_SUSPEND
suffix:semicolon
multiline_comment|/* Fall through... */
r_case
id|CS_EVENT_CARD_RESET
suffix:colon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|CardServices
c_func
(paren
id|RequestConfiguration
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;open
)paren
multiline_comment|/* If RESET -&gt; True, If RESUME -&gt; False ??? */
(brace
id|wv_hw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_device_attach
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;-wavelan_event()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************** MODULE ******************************/
multiline_comment|/*&n; * Module entry points : insertion &amp; removal&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module insertion : initialisation of the module.&n; * Register the card with cardmgr...&n; */
r_static
r_int
id|__init
DECL|function|init_wavelan_cs
id|init_wavelan_cs
c_func
(paren
r_void
)paren
(brace
id|servinfo_t
id|serv
suffix:semicolon
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; init_wavelan_cs()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_VERSION_SHOW
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|CardServices
c_func
(paren
id|GetCardServicesInfo
comma
op_amp
id|serv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serv.Revision
op_ne
id|CS_RELEASE_CODE
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;init_wavelan_cs: Card Services release does not match!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|register_pccard_driver
c_func
(paren
op_amp
id|dev_info
comma
op_amp
id|wavelan_attach
comma
op_amp
id|wavelan_detach
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- init_wavelan_cs()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module removal&n; */
r_static
r_void
id|__exit
DECL|function|exit_wavelan_cs
id|exit_wavelan_cs
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; cleanup_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_BASIC_SHOW
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;wavelan_cs: unloading&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Do some cleanup of the device list */
id|wv_flush_stale_links
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If there remain some devices... */
macro_line|#ifdef DEBUG_CONFIG_ERRORS
r_if
c_cond
(paren
id|dev_list
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Honestly, if this happen we are in a deep s**t */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;wavelan_cs: devices remaining when removing module&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Please flush your disks and reboot NOW !&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|unregister_pccard_driver
c_func
(paren
op_amp
id|dev_info
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- cleanup_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|init_wavelan_cs
id|module_init
c_func
(paren
id|init_wavelan_cs
)paren
suffix:semicolon
DECL|variable|exit_wavelan_cs
id|module_exit
c_func
(paren
id|exit_wavelan_cs
)paren
suffix:semicolon
eof
