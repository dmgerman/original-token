multiline_comment|/* [xirc2ps_cs.c wk 03.11.99] (1.40 1999/11/18 00:06:03)&n; * Xircom CreditCard Ethernet Adapter IIps driver&n; * Xircom Realport 10/100 (RE-100) driver &n; *&n; * This driver supports various Xircom CreditCard Ethernet adapters&n; * including the CE2, CE IIps, RE-10, CEM28, CEM33, CE33, CEM56,&n; * CE3-100, CE3B, RE-100, REM10BT, and REM56G-100.&n; * &n; * Written originally by Werner Koch based on David Hinds&squot; skeleton of the&n; * PCMCIA driver.&n; *&n; * Copyright (c) 1997,1998 Werner Koch (dd9jn)&n; *&n; * This driver is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * It is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA&n; *&n; *&n; * ALTERNATIVELY, this driver may be distributed under the terms of&n; * the following license, in which case the provisions of this license&n; * are required INSTEAD OF the GNU General Public License.  (This clause&n; * is necessary due to a potential bad interaction between the GPL and&n; * the restrictions contained in a BSD-style copyright.)&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, and the entire permission notice in its entirety,&n; *    including the disclaimer of warranties.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The name of the author may not be used to endorse or promote&n; *    products derived from this software without specific prior&n; *    written permission.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,&n; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n; * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)&n; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED&n; * OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;pcmcia/version.h&gt;
macro_line|#include &lt;pcmcia/cs_types.h&gt;
macro_line|#include &lt;pcmcia/cs.h&gt;
macro_line|#include &lt;pcmcia/cistpl.h&gt;
macro_line|#include &lt;pcmcia/cisreg.h&gt;
macro_line|#include &lt;pcmcia/ciscode.h&gt;
macro_line|#ifndef MANFID_COMPAQ
DECL|macro|MANFID_COMPAQ
mdefine_line|#define MANFID_COMPAQ &t;   0x0138
DECL|macro|MANFID_COMPAQ2
mdefine_line|#define MANFID_COMPAQ2&t;   0x0183  /* is this correct? */
macro_line|#endif
macro_line|#include &lt;pcmcia/ds.h&gt;
multiline_comment|/* Time in jiffies before concluding Tx hung */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT&t;((400*HZ)/1000)
multiline_comment|/****************&n; * Some constants used to access the hardware&n; */
multiline_comment|/* Register offsets and value constans */
DECL|macro|XIRCREG_CR
mdefine_line|#define XIRCREG_CR  0&t;/* Command register (wr) */
DECL|enum|xirc_cr
r_enum
id|xirc_cr
(brace
DECL|enumerator|TransmitPacket
id|TransmitPacket
op_assign
l_int|0x01
comma
DECL|enumerator|SoftReset
id|SoftReset
op_assign
l_int|0x02
comma
DECL|enumerator|EnableIntr
id|EnableIntr
op_assign
l_int|0x04
comma
DECL|enumerator|ForceIntr
id|ForceIntr
op_assign
l_int|0x08
comma
DECL|enumerator|ClearTxFIFO
id|ClearTxFIFO
op_assign
l_int|0x10
comma
DECL|enumerator|ClearRxOvrun
id|ClearRxOvrun
op_assign
l_int|0x20
comma
DECL|enumerator|RestartTx
id|RestartTx
op_assign
l_int|0x40
)brace
suffix:semicolon
DECL|macro|XIRCREG_ESR
mdefine_line|#define XIRCREG_ESR 0&t;/* Ethernet status register (rd) */
DECL|enum|xirc_esr
r_enum
id|xirc_esr
(brace
DECL|enumerator|FullPktRcvd
id|FullPktRcvd
op_assign
l_int|0x01
comma
multiline_comment|/* full packet in receive buffer */
DECL|enumerator|PktRejected
id|PktRejected
op_assign
l_int|0x04
comma
multiline_comment|/* a packet has been rejected */
DECL|enumerator|TxPktPend
id|TxPktPend
op_assign
l_int|0x08
comma
multiline_comment|/* TX Packet Pending */
DECL|enumerator|IncorPolarity
id|IncorPolarity
op_assign
l_int|0x10
comma
DECL|enumerator|MediaSelect
id|MediaSelect
op_assign
l_int|0x20
multiline_comment|/* set if TP, clear if AUI */
)brace
suffix:semicolon
DECL|macro|XIRCREG_PR
mdefine_line|#define XIRCREG_PR  1&t;/* Page Register select */
DECL|macro|XIRCREG_EDP
mdefine_line|#define XIRCREG_EDP 4&t;/* Ethernet Data Port Register */
DECL|macro|XIRCREG_ISR
mdefine_line|#define XIRCREG_ISR 6&t;/* Ethernet Interrupt Status Register */
DECL|enum|xirc_isr
r_enum
id|xirc_isr
(brace
DECL|enumerator|TxBufOvr
id|TxBufOvr
op_assign
l_int|0x01
comma
multiline_comment|/* TX Buffer Overflow */
DECL|enumerator|PktTxed
id|PktTxed
op_assign
l_int|0x02
comma
multiline_comment|/* Packet Transmitted */
DECL|enumerator|MACIntr
id|MACIntr
op_assign
l_int|0x04
comma
multiline_comment|/* MAC Interrupt occured */
DECL|enumerator|TxResGrant
id|TxResGrant
op_assign
l_int|0x08
comma
multiline_comment|/* Tx Reservation Granted */
DECL|enumerator|RxFullPkt
id|RxFullPkt
op_assign
l_int|0x20
comma
multiline_comment|/* Rx Full Packet */
DECL|enumerator|RxPktRej
id|RxPktRej
op_assign
l_int|0x40
comma
multiline_comment|/* Rx Packet Rejected */
DECL|enumerator|ForcedIntr
id|ForcedIntr
op_assign
l_int|0x80
multiline_comment|/* Forced Interrupt */
)brace
suffix:semicolon
DECL|macro|XIRCREG1_IMR0
mdefine_line|#define XIRCREG1_IMR0 12 /* Ethernet Interrupt Mask Register (on page 1)*/
DECL|macro|XIRCREG1_IMR1
mdefine_line|#define XIRCREG1_IMR1 13
DECL|macro|XIRCREG0_TSO
mdefine_line|#define XIRCREG0_TSO  8  /* Transmit Space Open Register (on page 0)*/
DECL|macro|XIRCREG0_TRS
mdefine_line|#define XIRCREG0_TRS  10 /* Transmit reservation Size Register (page 0)*/
DECL|macro|XIRCREG0_DO
mdefine_line|#define XIRCREG0_DO   12 /* Data Offset Register (page 0) (wr) */
DECL|macro|XIRCREG0_RSR
mdefine_line|#define XIRCREG0_RSR  12 /* Receive Status Register (page 0) (rd) */
DECL|enum|xirc_rsr
r_enum
id|xirc_rsr
(brace
DECL|enumerator|PhyPkt
id|PhyPkt
op_assign
l_int|0x01
comma
multiline_comment|/* set:physical packet, clear: multicast packet */
DECL|enumerator|BrdcstPkt
id|BrdcstPkt
op_assign
l_int|0x02
comma
multiline_comment|/* set if it is a broadcast packet */
DECL|enumerator|PktTooLong
id|PktTooLong
op_assign
l_int|0x04
comma
multiline_comment|/* set if packet length &gt; 1518 */
DECL|enumerator|AlignErr
id|AlignErr
op_assign
l_int|0x10
comma
multiline_comment|/* incorrect CRC and last octet not complete */
DECL|enumerator|CRCErr
id|CRCErr
op_assign
l_int|0x20
comma
multiline_comment|/* incorrect CRC and last octet is complete */
DECL|enumerator|PktRxOk
id|PktRxOk
op_assign
l_int|0x80
multiline_comment|/* received ok */
)brace
suffix:semicolon
DECL|macro|XIRCREG0_PTR
mdefine_line|#define XIRCREG0_PTR 13 /* packets transmitted register (rd) */
DECL|macro|XIRCREG0_RBC
mdefine_line|#define XIRCREG0_RBC 14 /* receive byte count regsister (rd) */
DECL|macro|XIRCREG1_ECR
mdefine_line|#define XIRCREG1_ECR 14 /* ethernet configurationn register */
DECL|enum|xirc_ecr
r_enum
id|xirc_ecr
(brace
DECL|enumerator|FullDuplex
id|FullDuplex
op_assign
l_int|0x04
comma
multiline_comment|/* enable full duplex mode */
DECL|enumerator|LongTPMode
id|LongTPMode
op_assign
l_int|0x08
comma
multiline_comment|/* adjust for longer lengths of TP cable */
DECL|enumerator|DisablePolCor
id|DisablePolCor
op_assign
l_int|0x10
comma
multiline_comment|/* disable auto polarity correction */
DECL|enumerator|DisableLinkPulse
id|DisableLinkPulse
op_assign
l_int|0x20
comma
multiline_comment|/* disable link pulse generation */
DECL|enumerator|DisableAutoTx
id|DisableAutoTx
op_assign
l_int|0x40
comma
multiline_comment|/* disable auto-transmit */
)brace
suffix:semicolon
DECL|macro|XIRCREG2_RBS
mdefine_line|#define XIRCREG2_RBS 8&t;/* receive buffer start register */
DECL|macro|XIRCREG2_LED
mdefine_line|#define XIRCREG2_LED 10 /* LED Configuration register */
multiline_comment|/* values for the leds:    Bits 2-0 for led 1&n; *  0 disabled&t;&t;   Bits 5-3 for led 2&n; *  1 collision&n; *  2 noncollision&n; *  3 link_detected&n; *  4 incor_polarity&n; *  5 jabber&n; *  6 auto_assertion&n; *  7 rx_tx_activity&n; */
DECL|macro|XIRCREG2_MSR
mdefine_line|#define XIRCREG2_MSR 12 /* Mohawk specific register */
DECL|macro|XIRCREG4_GPR0
mdefine_line|#define XIRCREG4_GPR0 8 /* General Purpose Register 0 */
DECL|macro|XIRCREG4_GPR1
mdefine_line|#define XIRCREG4_GPR1 9 /* General Purpose Register 1 */
DECL|macro|XIRCREG2_GPR2
mdefine_line|#define XIRCREG2_GPR2 13 /* General Purpose Register 2 (page2!)*/
DECL|macro|XIRCREG4_BOV
mdefine_line|#define XIRCREG4_BOV 10 /* Bonding Version Register */
DECL|macro|XIRCREG4_LMA
mdefine_line|#define XIRCREG4_LMA 12 /* Local Memory Address Register */
DECL|macro|XIRCREG4_LMD
mdefine_line|#define XIRCREG4_LMD 14 /* Local Memory Data Port */
multiline_comment|/* MAC register can only by accessed with 8 bit operations */
DECL|macro|XIRCREG40_CMD0
mdefine_line|#define XIRCREG40_CMD0 8    /* Command Register (wr) */
DECL|enum|xirc_cmd
r_enum
id|xirc_cmd
(brace
multiline_comment|/* Commands */
DECL|enumerator|Transmit
id|Transmit
op_assign
l_int|0x01
comma
DECL|enumerator|EnableRecv
id|EnableRecv
op_assign
l_int|0x04
comma
DECL|enumerator|DisableRecv
id|DisableRecv
op_assign
l_int|0x08
comma
DECL|enumerator|Abort
id|Abort
op_assign
l_int|0x10
comma
DECL|enumerator|Online
id|Online
op_assign
l_int|0x20
comma
DECL|enumerator|IntrAck
id|IntrAck
op_assign
l_int|0x40
comma
DECL|enumerator|Offline
id|Offline
op_assign
l_int|0x80
)brace
suffix:semicolon
DECL|macro|XIRCREG5_RHSA0
mdefine_line|#define XIRCREG5_RHSA0&t;10  /* Rx Host Start Address */
DECL|macro|XIRCREG40_RXST0
mdefine_line|#define XIRCREG40_RXST0 9   /* Receive Status Register */
DECL|macro|XIRCREG40_TXST0
mdefine_line|#define XIRCREG40_TXST0 11  /* Transmit Status Register 0 */
DECL|macro|XIRCREG40_TXST1
mdefine_line|#define XIRCREG40_TXST1 12  /* Transmit Status Register 10 */
DECL|macro|XIRCREG40_RMASK0
mdefine_line|#define XIRCREG40_RMASK0 13  /* Receive Mask Register */
DECL|macro|XIRCREG40_TMASK0
mdefine_line|#define XIRCREG40_TMASK0 14  /* Transmit Mask Register 0 */
DECL|macro|XIRCREG40_TMASK1
mdefine_line|#define XIRCREG40_TMASK1 15  /* Transmit Mask Register 0 */
DECL|macro|XIRCREG42_SWC0
mdefine_line|#define XIRCREG42_SWC0&t;8   /* Software Configuration 0 */
DECL|macro|XIRCREG42_SWC1
mdefine_line|#define XIRCREG42_SWC1&t;9   /* Software Configuration 1 */
DECL|macro|XIRCREG42_BOC
mdefine_line|#define XIRCREG42_BOC&t;10  /* Back-Off Configuration */
DECL|macro|XIRCREG44_TDR0
mdefine_line|#define XIRCREG44_TDR0&t;8   /* Time Domain Reflectometry 0 */
DECL|macro|XIRCREG44_TDR1
mdefine_line|#define XIRCREG44_TDR1&t;9   /* Time Domain Reflectometry 1 */
DECL|macro|XIRCREG44_RXBC_LO
mdefine_line|#define XIRCREG44_RXBC_LO 10 /* Rx Byte Count 0 (rd) */
DECL|macro|XIRCREG44_RXBC_HI
mdefine_line|#define XIRCREG44_RXBC_HI 11 /* Rx Byte Count 1 (rd) */
DECL|macro|XIRCREG45_REV
mdefine_line|#define XIRCREG45_REV&t; 15 /* Revision Register (rd) */
DECL|macro|XIRCREG50_IA
mdefine_line|#define XIRCREG50_IA&t;8   /* Individual Address (8-13) */
DECL|variable|if_names
r_static
r_char
op_star
id|if_names
(braket
)braket
op_assign
(brace
l_string|&quot;Auto&quot;
comma
l_string|&quot;10BaseT&quot;
comma
l_string|&quot;10Base2&quot;
comma
l_string|&quot;AUI&quot;
comma
l_string|&quot;100BaseT&quot;
)brace
suffix:semicolon
multiline_comment|/****************&n; * All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If&n; * you do not define PCMCIA_DEBUG at all, all the debug code will be&n; * left out.  If you compile with PCMCIA_DEBUG=0, the debug code will&n; * be present but disabled -- but it can then be enabled for specific&n; * modules at load time with a &squot;pc_debug=#&squot; option to insmod.&n; */
macro_line|#ifdef PCMCIA_DEBUG
DECL|variable|pc_debug
r_static
r_int
id|pc_debug
op_assign
id|PCMCIA_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|pc_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|DEBUG
mdefine_line|#define DEBUG(n, args...) if (pc_debug&gt;(n)) printk(KDBG_XIRC args)
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG(n, args...)
macro_line|#endif
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;xirc2ps_cs.c 1.31 1998/12/09 19:32:55 (dd9jn+kvh)&quot;
suffix:semicolon
multiline_comment|/* !--- CVS revision */
DECL|macro|KDBG_XIRC
mdefine_line|#define KDBG_XIRC KERN_DEBUG   &quot;xirc2ps_cs: &quot;
DECL|macro|KERR_XIRC
mdefine_line|#define KERR_XIRC KERN_ERR     &quot;xirc2ps_cs: &quot;
DECL|macro|KWRN_XIRC
mdefine_line|#define KWRN_XIRC KERN_WARNING &quot;xirc2ps_cs: &quot;
DECL|macro|KNOT_XIRC
mdefine_line|#define KNOT_XIRC KERN_NOTICE  &quot;xirc2ps_cs: &quot;
DECL|macro|KINF_XIRC
mdefine_line|#define KINF_XIRC KERN_INFO    &quot;xirc2ps_cs: &quot;
multiline_comment|/* card types */
DECL|macro|XIR_UNKNOWN
mdefine_line|#define XIR_UNKNOWN  0&t;/* unknown: not supported */
DECL|macro|XIR_CE
mdefine_line|#define XIR_CE&t;     1&t;/* (prodid 1) different hardware: not supported */
DECL|macro|XIR_CE2
mdefine_line|#define XIR_CE2      2&t;/* (prodid 2) */
DECL|macro|XIR_CE3
mdefine_line|#define XIR_CE3      3&t;/* (prodid 3) */
DECL|macro|XIR_CEM
mdefine_line|#define XIR_CEM      4&t;/* (prodid 1) different hardware: not supported */
DECL|macro|XIR_CEM2
mdefine_line|#define XIR_CEM2     5&t;/* (prodid 2) */
DECL|macro|XIR_CEM3
mdefine_line|#define XIR_CEM3     6&t;/* (prodid 3) */
DECL|macro|XIR_CEM33
mdefine_line|#define XIR_CEM33    7&t;/* (prodid 4) */
DECL|macro|XIR_CEM56M
mdefine_line|#define XIR_CEM56M   8&t;/* (prodid 5) */
DECL|macro|XIR_CEM56
mdefine_line|#define XIR_CEM56    9&t;/* (prodid 6) */
DECL|macro|XIR_CM28
mdefine_line|#define XIR_CM28    10&t;/* (prodid 3) modem only: not supported here */
DECL|macro|XIR_CM33
mdefine_line|#define XIR_CM33    11&t;/* (prodid 4) modem only: not supported here */
DECL|macro|XIR_CM56
mdefine_line|#define XIR_CM56    12&t;/* (prodid 5) modem only: not supported here */
DECL|macro|XIR_CG
mdefine_line|#define XIR_CG&t;    13&t;/* (prodid 1) GSM modem only: not supported */
DECL|macro|XIR_CBE
mdefine_line|#define XIR_CBE     14&t;/* (prodid 1) cardbus ethernet: not supported */
multiline_comment|/*====================================================================*/
multiline_comment|/* Parameters that can be set with &squot;insmod&squot; */
DECL|macro|INT_MODULE_PARM
mdefine_line|#define INT_MODULE_PARM(n, v) static int n = v; MODULE_PARM(n, &quot;i&quot;)
DECL|variable|irq_list
r_static
r_int
id|irq_list
(braket
l_int|4
)braket
op_assign
(brace
op_minus
l_int|1
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq_list
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
id|INT_MODULE_PARM
c_func
(paren
id|irq_mask
comma
l_int|0xdeb8
)paren
suffix:semicolon
id|INT_MODULE_PARM
c_func
(paren
id|if_port
comma
l_int|0
)paren
suffix:semicolon
id|INT_MODULE_PARM
c_func
(paren
id|full_duplex
comma
l_int|0
)paren
suffix:semicolon
id|INT_MODULE_PARM
c_func
(paren
id|do_sound
comma
l_int|1
)paren
suffix:semicolon
id|INT_MODULE_PARM
c_func
(paren
id|lockup_hack
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* anti lockup hack */
multiline_comment|/*====================================================================*/
multiline_comment|/* We do not process more than these number of bytes during one&n; * interrupt. (Of course we receive complete packets, so this is not&n; * an exact value).&n; * Something between 2000..22000; first value gives best interrupt latency,&n; * the second enables the usage of the complete on-chip buffer. We use the&n; * high value as the initial value.&n; */
DECL|variable|maxrx_bytes
r_static
r_int
id|maxrx_bytes
op_assign
l_int|22000
suffix:semicolon
multiline_comment|/* MII management prototypes */
r_static
r_void
id|mii_idle
c_func
(paren
id|ioaddr_t
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|mii_putbit
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
r_int
id|data
)paren
suffix:semicolon
r_static
r_int
id|mii_getbit
c_func
(paren
id|ioaddr_t
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|mii_wbits
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
r_int
id|data
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|mii_rd
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
id|u_char
id|phyaddr
comma
id|u_char
id|phyreg
)paren
suffix:semicolon
r_static
r_void
id|mii_wr
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
id|u_char
id|phyaddr
comma
id|u_char
id|phyreg
comma
r_int
id|data
comma
r_int
id|len
)paren
suffix:semicolon
multiline_comment|/*&n; * The event() function is this driver&squot;s Card Services event handler.&n; * It will be called by Card Services when an appropriate card status&n; * event is received.  The config() and release() entry points are&n; * used to configure or release a socket, in response to card insertion&n; * and ejection events.  They are invoked from the event handler.&n; */
r_static
r_int
id|has_ce2_string
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
suffix:semicolon
r_static
r_void
id|xirc2ps_config
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
suffix:semicolon
r_static
r_void
id|xirc2ps_release
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_int
id|xirc2ps_event
c_func
(paren
id|event_t
id|event
comma
r_int
id|priority
comma
id|event_callback_args_t
op_star
id|args
)paren
suffix:semicolon
multiline_comment|/****************&n; * The attach() and detach() entry points are used to create and destroy&n; * &quot;instances&quot; of the driver, where each instance represents everything&n; * needed to manage one actual PCMCIA card.&n; */
r_static
id|dev_link_t
op_star
id|xirc2ps_attach
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|xirc2ps_detach
c_func
(paren
id|dev_link_t
op_star
)paren
suffix:semicolon
multiline_comment|/****************&n; * You&squot;ll also need to prototype all the functions that will actually&n; * be used to talk to your device.  See &squot;pcmem_cs&squot; for a good example&n; * of a fully self-sufficient driver; the other drivers rely more or&n; * less on other parts of the kernel.&n; */
r_static
r_void
id|xirc2ps_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; * The dev_info variable is the &quot;key&quot; that is used to match up this&n; * device driver with appropriate cards, through the card configuration&n; * database.&n; */
DECL|variable|dev_info
r_static
id|dev_info_t
id|dev_info
op_assign
l_string|&quot;xirc2ps_cs&quot;
suffix:semicolon
multiline_comment|/****************&n; * A linked list of &quot;instances&quot; of the device.  Each actual&n; * PCMCIA card corresponds to one device instance, and is described&n; * by one dev_link_t structure (defined in ds.h).&n; *&n; * You may not want to use a linked list for this -- for example, the&n; * memory card driver uses an array of dev_link_t pointers, where minor&n; * device numbers are used to derive the corresponding array index.&n; */
DECL|variable|dev_list
r_static
id|dev_link_t
op_star
id|dev_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/****************&n; * A dev_link_t structure has fields for most things that are needed&n; * to keep track of a socket, but there will usually be some device&n; * specific information that also needs to be kept track of.  The&n; * &squot;priv&squot; pointer in a dev_link_t structure can be used to point to&n; * a device-specific private data structure, like this.&n; *&n; * A driver needs to provide a dev_node_t structure for each device&n; * on a card.  In some cases, there is only one device per card (for&n; * example, ethernet cards, modems).  In other cases, there may be&n; * many actual or logical devices (SCSI adapters, memory cards with&n; * multiple partitions).  The dev_node_t structures need to be kept&n; * in a linked list starting at the &squot;dev&squot; field of a dev_link_t&n; * structure.  We allocate them in the card&squot;s private data structure,&n; * because they generally can&squot;t be allocated dynamically.&n; */
DECL|struct|local_info_t
r_typedef
r_struct
id|local_info_t
(brace
DECL|member|link
id|dev_link_t
id|link
suffix:semicolon
DECL|member|dev
r_struct
id|net_device
id|dev
suffix:semicolon
DECL|member|node
id|dev_node_t
id|node
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|card_type
r_int
id|card_type
suffix:semicolon
DECL|member|probe_port
r_int
id|probe_port
suffix:semicolon
DECL|member|silicon
r_int
id|silicon
suffix:semicolon
multiline_comment|/* silicon revision. 0=old CE2, 1=Scipper, 4=Mohawk */
DECL|member|mohawk
r_int
id|mohawk
suffix:semicolon
multiline_comment|/* a CE3 type card */
DECL|member|dingo
r_int
id|dingo
suffix:semicolon
multiline_comment|/* a CEM56 type card */
DECL|member|new_mii
r_int
id|new_mii
suffix:semicolon
multiline_comment|/* has full 10baseT/100baseT MII */
DECL|member|modem
r_int
id|modem
suffix:semicolon
multiline_comment|/* is a multi function card (i.e with a modem) */
DECL|member|dingo_ccr
id|caddr_t
id|dingo_ccr
suffix:semicolon
multiline_comment|/* only used for CEM56 cards */
DECL|member|last_ptr_value
r_int
id|last_ptr_value
suffix:semicolon
multiline_comment|/* last packets transmitted value */
DECL|member|manf_str
r_const
r_char
op_star
id|manf_str
suffix:semicolon
DECL|typedef|local_info_t
)brace
id|local_info_t
suffix:semicolon
multiline_comment|/****************&n; * Some more prototypes&n; */
r_static
r_int
id|do_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|do_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|do_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_addresses
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|set_card_type
c_func
(paren
id|dev_link_t
op_star
id|link
comma
r_const
r_void
op_star
id|s
)paren
suffix:semicolon
r_static
r_int
id|do_config
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifmap
op_star
id|map
)paren
suffix:semicolon
r_static
r_int
id|do_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|do_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|hardreset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|do_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|full
)paren
suffix:semicolon
r_static
r_int
id|init_mii
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|do_powerdown
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|do_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*=============== Helper functions =========================*/
r_static
r_void
DECL|function|flush_stale_links
id|flush_stale_links
c_func
(paren
r_void
)paren
(brace
id|dev_link_t
op_star
id|link
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|link
op_assign
id|dev_list
suffix:semicolon
id|link
suffix:semicolon
id|link
op_assign
id|next
)paren
(brace
id|next
op_assign
id|link-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_LINK
)paren
id|xirc2ps_detach
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|cs_error
id|cs_error
c_func
(paren
id|client_handle_t
id|handle
comma
r_int
id|func
comma
r_int
id|ret
)paren
(brace
id|error_info_t
id|err
op_assign
(brace
id|func
comma
id|ret
)brace
suffix:semicolon
id|CardServices
c_func
(paren
id|ReportError
comma
id|handle
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_tuple_data
id|get_tuple_data
c_func
(paren
r_int
id|fn
comma
id|client_handle_t
id|handle
comma
id|tuple_t
op_star
id|tuple
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|fn
comma
id|handle
comma
id|tuple
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_return
id|CardServices
c_func
(paren
id|GetTupleData
comma
id|handle
comma
id|tuple
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_tuple
id|get_tuple
c_func
(paren
r_int
id|fn
comma
id|client_handle_t
id|handle
comma
id|tuple_t
op_star
id|tuple
comma
id|cisparse_t
op_star
id|parse
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_tuple_data
c_func
(paren
id|fn
comma
id|handle
comma
id|tuple
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_return
id|CardServices
c_func
(paren
id|ParseTuple
comma
id|handle
comma
id|tuple
comma
id|parse
)paren
suffix:semicolon
)brace
DECL|macro|first_tuple
mdefine_line|#define first_tuple(a, b, c) get_tuple(GetFirstTuple, a, b, c)
DECL|macro|next_tuple
mdefine_line|#define next_tuple(a, b, c)  get_tuple(GetNextTuple, a, b, c)
DECL|macro|SelectPage
mdefine_line|#define SelectPage(pgnr)   outb((pgnr), ioaddr + XIRCREG_PR)
DECL|macro|GetByte
mdefine_line|#define GetByte(reg)&t;   ((unsigned)inb(ioaddr + (reg)))
DECL|macro|GetWord
mdefine_line|#define GetWord(reg)&t;   ((unsigned)inw(ioaddr + (reg)))
DECL|macro|PutByte
mdefine_line|#define PutByte(reg,value) outb((value), ioaddr+(reg))
DECL|macro|PutWord
mdefine_line|#define PutWord(reg,value) outw((value), ioaddr+(reg))
r_static
r_void
DECL|function|busy_loop
id|busy_loop
c_func
(paren
id|u_long
id|len
)paren
(brace
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|u_long
id|timeout
op_assign
id|jiffies
op_plus
id|len
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_ge
id|jiffies
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|__set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*====== Functions used for debugging =================================*/
macro_line|#if defined(PCMCIA_DEBUG) &amp;&amp; 0 /* reading regs may change system status */
r_static
r_void
DECL|function|PrintRegisters
id|PrintRegisters
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|pc_debug
OG
l_int|1
)paren
(brace
r_int
id|i
comma
id|page
suffix:semicolon
id|printk
c_func
(paren
id|KDBG_XIRC
l_string|&quot;Register  common: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|GetByte
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
op_le
l_int|8
suffix:semicolon
id|page
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KDBG_XIRC
l_string|&quot;Register page %2x: &quot;
comma
id|page
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|GetByte
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|page
op_assign
l_int|0x40
suffix:semicolon
id|page
op_le
l_int|0x5f
suffix:semicolon
id|page
op_increment
)paren
(brace
r_if
c_cond
(paren
id|page
op_eq
l_int|0x43
op_logical_or
(paren
id|page
op_ge
l_int|0x46
op_logical_and
id|page
op_le
l_int|0x4f
)paren
op_logical_or
(paren
id|page
op_ge
l_int|0x51
op_logical_and
id|page
op_le
l_int|0x5e
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KDBG_XIRC
l_string|&quot;Register page %2x: &quot;
comma
id|page
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|GetByte
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* PCMCIA_DEBUG */
multiline_comment|/*============== MII Management functions ===============*/
multiline_comment|/****************&n; * Turn around for read&n; */
r_static
r_void
DECL|function|mii_idle
id|mii_idle
c_func
(paren
id|ioaddr_t
id|ioaddr
)paren
(brace
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|0x04
op_or
l_int|0
)paren
suffix:semicolon
multiline_comment|/* drive MDCK low */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|0x04
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and drive MDCK high */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/****************&n; * Write a bit to MDI/O&n; */
r_static
r_void
DECL|function|mii_putbit
id|mii_putbit
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
r_int
id|data
)paren
(brace
macro_line|#if 1
r_if
c_cond
(paren
id|data
)paren
(brace
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|0x0c
op_or
l_int|2
op_or
l_int|0
)paren
suffix:semicolon
multiline_comment|/* set MDIO */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|0x0c
op_or
l_int|2
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and drive MDCK high */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|0x0c
op_or
l_int|0
op_or
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear MDIO */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|0x0c
op_or
l_int|0
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and drive MDCK high */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|data
)paren
(brace
id|PutWord
c_func
(paren
id|XIRCREG2_GPR2
op_minus
l_int|1
comma
l_int|0x0e0e
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutWord
c_func
(paren
id|XIRCREG2_GPR2
op_minus
l_int|1
comma
l_int|0x0f0f
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|PutWord
c_func
(paren
id|XIRCREG2_GPR2
op_minus
l_int|1
comma
l_int|0x0c0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutWord
c_func
(paren
id|XIRCREG2_GPR2
op_minus
l_int|1
comma
l_int|0x0d0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/****************&n; * Get a bit from MDI/O&n; */
r_static
r_int
DECL|function|mii_getbit
id|mii_getbit
c_func
(paren
id|ioaddr_t
id|ioaddr
)paren
(brace
r_int
id|d
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|4
op_or
l_int|0
)paren
suffix:semicolon
multiline_comment|/* drive MDCK low */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|d
op_assign
id|GetByte
c_func
(paren
id|XIRCREG2_GPR2
)paren
suffix:semicolon
multiline_comment|/* read MDIO */
id|PutByte
c_func
(paren
id|XIRCREG2_GPR2
comma
l_int|4
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/* drive MDCK high again */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|d
op_amp
l_int|0x20
suffix:semicolon
multiline_comment|/* read MDIO */
)brace
r_static
r_void
DECL|function|mii_wbits
id|mii_wbits
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
r_int
id|data
comma
r_int
id|len
)paren
(brace
r_int
id|m
op_assign
l_int|1
op_lshift
(paren
id|len
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
)paren
id|mii_putbit
c_func
(paren
id|ioaddr
comma
id|data
op_amp
id|m
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mii_rd
id|mii_rd
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
id|u_char
id|phyaddr
comma
id|u_char
id|phyreg
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|data
op_assign
l_int|0
comma
id|m
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* 32 bit preamble */
id|mii_putbit
c_func
(paren
id|ioaddr
comma
l_int|1
)paren
suffix:semicolon
id|mii_wbits
c_func
(paren
id|ioaddr
comma
l_int|0x06
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Start and opcode for read */
id|mii_wbits
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* PHY address to be accessed */
id|mii_wbits
c_func
(paren
id|ioaddr
comma
id|phyreg
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* PHY register to read */
id|mii_idle
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* turn around */
id|mii_getbit
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|1
op_lshift
l_int|15
suffix:semicolon
id|m
suffix:semicolon
id|m
op_rshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|mii_getbit
c_func
(paren
id|ioaddr
)paren
)paren
id|data
op_or_assign
id|m
suffix:semicolon
id|mii_idle
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
r_static
r_void
DECL|function|mii_wr
id|mii_wr
c_func
(paren
id|ioaddr_t
id|ioaddr
comma
id|u_char
id|phyaddr
comma
id|u_char
id|phyreg
comma
r_int
id|data
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* 32 bit preamble */
id|mii_putbit
c_func
(paren
id|ioaddr
comma
l_int|1
)paren
suffix:semicolon
id|mii_wbits
c_func
(paren
id|ioaddr
comma
l_int|0x05
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Start and opcode for write */
id|mii_wbits
c_func
(paren
id|ioaddr
comma
id|phyaddr
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* PHY address to be accessed */
id|mii_wbits
c_func
(paren
id|ioaddr
comma
id|phyreg
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* PHY Register to write */
id|mii_putbit
c_func
(paren
id|ioaddr
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* turn around */
id|mii_putbit
c_func
(paren
id|ioaddr
comma
l_int|0
)paren
suffix:semicolon
id|mii_wbits
c_func
(paren
id|ioaddr
comma
id|data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* And write the data */
id|mii_idle
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
multiline_comment|/*============= Main bulk of functions&t;=========================*/
multiline_comment|/****************&n; * xirc2ps_attach() creates an &quot;instance&quot; of the driver, allocating&n; * local data structures for one device.  The device is registered&n; * with Card Services.&n; *&n; * The dev_link structure is initialized, but we don&squot;t actually&n; * configure the card at this point -- we wait until we receive a&n; * card insertion event.&n; */
r_static
id|dev_link_t
op_star
DECL|function|xirc2ps_attach
id|xirc2ps_attach
c_func
(paren
r_void
)paren
(brace
id|client_reg_t
id|client_reg
suffix:semicolon
id|dev_link_t
op_star
id|link
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|local_info_t
op_star
id|local
suffix:semicolon
r_int
id|err
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;attach()&bslash;n&quot;
)paren
suffix:semicolon
id|flush_stale_links
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Allocate the device structure */
id|local
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|local
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|local
)paren
)paren
suffix:semicolon
id|link
op_assign
op_amp
id|local-&gt;link
suffix:semicolon
id|dev
op_assign
op_amp
id|local-&gt;dev
suffix:semicolon
id|link-&gt;priv
op_assign
id|dev-&gt;priv
op_assign
id|local
suffix:semicolon
id|link-&gt;release.function
op_assign
op_amp
id|xirc2ps_release
suffix:semicolon
id|link-&gt;release.data
op_assign
(paren
id|u_long
)paren
id|link
suffix:semicolon
multiline_comment|/* General socket configuration */
id|link-&gt;conf.Attributes
op_assign
id|CONF_ENABLE_IRQ
suffix:semicolon
id|link-&gt;conf.Vcc
op_assign
l_int|50
suffix:semicolon
id|link-&gt;conf.IntType
op_assign
id|INT_MEMORY_AND_IO
suffix:semicolon
id|link-&gt;conf.ConfigIndex
op_assign
l_int|1
suffix:semicolon
id|link-&gt;conf.Present
op_assign
id|PRESENT_OPTION
suffix:semicolon
id|link-&gt;irq.Handler
op_assign
id|xirc2ps_interrupt
suffix:semicolon
id|link-&gt;irq.Instance
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Fill in card specific entries */
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|do_start_xmit
suffix:semicolon
id|dev-&gt;set_config
op_assign
op_amp
id|do_config
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|do_get_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|do_ioctl
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|do_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|do_stop
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|do_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
multiline_comment|/* Register with Card Services */
id|link-&gt;next
op_assign
id|dev_list
suffix:semicolon
id|dev_list
op_assign
id|link
suffix:semicolon
id|client_reg.dev_info
op_assign
op_amp
id|dev_info
suffix:semicolon
id|client_reg.Attributes
op_assign
id|INFO_IO_CLIENT
op_or
id|INFO_CARD_SHARE
suffix:semicolon
id|client_reg.EventMask
op_assign
id|CS_EVENT_CARD_INSERTION
op_or
id|CS_EVENT_CARD_REMOVAL
op_or
id|CS_EVENT_RESET_PHYSICAL
op_or
id|CS_EVENT_CARD_RESET
op_or
id|CS_EVENT_PM_SUSPEND
op_or
id|CS_EVENT_PM_RESUME
suffix:semicolon
id|client_reg.event_handler
op_assign
op_amp
id|xirc2ps_event
suffix:semicolon
id|client_reg.Version
op_assign
l_int|0x0210
suffix:semicolon
id|client_reg.event_callback_args.client_data
op_assign
id|link
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RegisterClient
comma
op_amp
id|link-&gt;handle
comma
op_amp
id|client_reg
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RegisterClient
comma
id|err
)paren
suffix:semicolon
id|xirc2ps_detach
c_func
(paren
id|link
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|link
suffix:semicolon
)brace
multiline_comment|/* xirc2ps_attach */
multiline_comment|/****************&n; *  This deletes a driver &quot;instance&quot;.  The device is de-registered&n; *  with Card Services.  If it has been released, all local data&n; *  structures are freed.  Otherwise, the structures will be freed&n; *  when the device is released.&n; */
r_static
r_void
DECL|function|xirc2ps_detach
id|xirc2ps_detach
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|link-&gt;priv
suffix:semicolon
id|dev_link_t
op_star
op_star
id|linkp
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;detach(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
multiline_comment|/* Locate device structure */
r_for
c_loop
(paren
id|linkp
op_assign
op_amp
id|dev_list
suffix:semicolon
op_star
id|linkp
suffix:semicolon
id|linkp
op_assign
op_amp
(paren
op_star
id|linkp
)paren
op_member_access_from_pointer
id|next
)paren
r_if
c_cond
(paren
op_star
id|linkp
op_eq
id|link
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|linkp
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;detach(0x%p): dev_link lost&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * If the device is currently configured and active, we won&squot;t&n;     * actually delete it yet.&t;Instead, it is marked so that when&n;     * the release() function is called, that will trigger a proper&n;     * detach().&n;     */
id|del_timer
c_func
(paren
op_amp
id|link-&gt;release
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;detach postponed, &squot;%s&squot; still locked&bslash;n&quot;
comma
id|link-&gt;dev-&gt;dev_name
)paren
suffix:semicolon
id|link-&gt;state
op_or_assign
id|DEV_STALE_LINK
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Break the link with Card Services */
r_if
c_cond
(paren
id|link-&gt;handle
)paren
id|CardServices
c_func
(paren
id|DeregisterClient
comma
id|link-&gt;handle
)paren
suffix:semicolon
multiline_comment|/* Unlink device structure, free it */
op_star
id|linkp
op_assign
id|link-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;dev
)paren
id|unregister_netdev
c_func
(paren
op_amp
id|local-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|local
)paren
suffix:semicolon
)brace
multiline_comment|/* xirc2ps_detach */
multiline_comment|/****************&n; * Detect the type of the card. s is the buffer with the data of tuple 0x20&n; * Returns: 0 := not supported&n; *&t;&t;       mediaid=11 and prodid=47&n; * Media-Id bits:&n; *  Ethernet&t;    0x01&n; *  Tokenring&t;    0x02&n; *  Arcnet&t;    0x04&n; *  Wireless&t;    0x08&n; *  Modem&t;    0x10&n; *  GSM only&t;    0x20&n; * Prod-Id bits:&n; *  Pocket&t;    0x10&n; *  External&t;    0x20&n; *  Creditcard&t;    0x40&n; *  Cardbus&t;    0x80&n; *&n; */
r_static
r_int
DECL|function|set_card_type
id|set_card_type
c_func
(paren
id|dev_link_t
op_star
id|link
comma
r_const
r_void
op_star
id|s
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|link-&gt;priv
suffix:semicolon
macro_line|#ifdef PCMCIA_DEBUG
r_int
id|cisrev
op_assign
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|s
)paren
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
r_int
id|mediaid
op_assign
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|s
)paren
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|prodid
op_assign
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|s
)paren
(braket
l_int|4
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;cisrev=%02x mediaid=%02x prodid=%02x&bslash;n&quot;
comma
id|cisrev
comma
id|mediaid
comma
id|prodid
)paren
suffix:semicolon
id|local-&gt;mohawk
op_assign
l_int|0
suffix:semicolon
id|local-&gt;dingo
op_assign
l_int|0
suffix:semicolon
id|local-&gt;modem
op_assign
l_int|0
suffix:semicolon
id|local-&gt;card_type
op_assign
id|XIR_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|prodid
op_amp
l_int|0x40
)paren
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;Ooops: Not a creditcard&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mediaid
op_amp
l_int|0x01
)paren
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;Not an Ethernet card&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mediaid
op_amp
l_int|0x10
)paren
(brace
id|local-&gt;modem
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|prodid
op_amp
l_int|15
)paren
(brace
r_case
l_int|1
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CEM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CEM2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CEM3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CEM33
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CEM56M
suffix:semicolon
id|local-&gt;mohawk
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
multiline_comment|/* 7 is the RealPort 10/56 */
id|local-&gt;card_type
op_assign
id|XIR_CEM56
suffix:semicolon
id|local-&gt;mohawk
op_assign
l_int|1
suffix:semicolon
id|local-&gt;dingo
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|prodid
op_amp
l_int|15
)paren
(brace
r_case
l_int|1
suffix:colon
id|local-&gt;card_type
op_assign
id|has_ce2_string
c_func
(paren
id|link
)paren
ques
c_cond
id|XIR_CE2
suffix:colon
id|XIR_CE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CE2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|local-&gt;card_type
op_assign
id|XIR_CE3
suffix:semicolon
id|local-&gt;mohawk
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|local-&gt;card_type
op_eq
id|XIR_CE
op_logical_or
id|local-&gt;card_type
op_eq
id|XIR_CEM
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;Sorry, this is an old CE card&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local-&gt;card_type
op_eq
id|XIR_UNKNOWN
)paren
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;unknown card (mediaid=%02x prodid=%02x)&bslash;n&quot;
comma
id|mediaid
comma
id|prodid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/****************&n; * There are some CE2 cards out which claim to be a CE card.&n; * This function looks for a &quot;CE2&quot; in the 3rd version field.&n; * Returns: true if this is a CE2&n; */
r_static
r_int
DECL|function|has_ce2_string
id|has_ce2_string
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
id|client_handle_t
id|handle
op_assign
id|link-&gt;handle
suffix:semicolon
id|tuple_t
id|tuple
suffix:semicolon
id|cisparse_t
id|parse
suffix:semicolon
id|u_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
id|tuple.Attributes
op_assign
l_int|0
suffix:semicolon
id|tuple.TupleData
op_assign
id|buf
suffix:semicolon
id|tuple.TupleDataMax
op_assign
l_int|254
suffix:semicolon
id|tuple.TupleOffset
op_assign
l_int|0
suffix:semicolon
id|tuple.DesiredTuple
op_assign
id|CISTPL_VERS_1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
op_logical_and
id|parse.version_1.ns
OG
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|parse.version_1.str
op_plus
id|parse.version_1.ofs
(braket
l_int|2
)braket
comma
l_string|&quot;CE2&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************&n; * xirc2ps_config() is scheduled to run after a CARD_INSERTION event&n; * is received, to configure the PCMCIA socket, and to make the&n; * ethernet device available to the system.&n; */
r_static
r_void
DECL|function|xirc2ps_config
id|xirc2ps_config
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
id|client_handle_t
id|handle
op_assign
id|link-&gt;handle
suffix:semicolon
id|local_info_t
op_star
id|local
op_assign
id|link-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|local-&gt;dev
suffix:semicolon
id|tuple_t
id|tuple
suffix:semicolon
id|cisparse_t
id|parse
suffix:semicolon
id|ioaddr_t
id|ioaddr
suffix:semicolon
r_int
id|err
comma
id|i
suffix:semicolon
id|u_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|cistpl_lan_node_id_t
op_star
id|node_id
op_assign
(paren
id|cistpl_lan_node_id_t
op_star
)paren
id|parse.funce.data
suffix:semicolon
id|cistpl_cftable_entry_t
op_star
id|cf
op_assign
op_amp
id|parse.cftable_entry
suffix:semicolon
id|local-&gt;dingo_ccr
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;config(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
multiline_comment|/*&n;     * This reads the card&squot;s CONFIG tuple to find its configuration&n;     * registers.&n;     */
id|tuple.Attributes
op_assign
l_int|0
suffix:semicolon
id|tuple.TupleData
op_assign
id|buf
suffix:semicolon
id|tuple.TupleDataMax
op_assign
l_int|64
suffix:semicolon
id|tuple.TupleOffset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is this a valid&t;card */
id|tuple.DesiredTuple
op_assign
id|CISTPL_MANFID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;manfid not found in CIS&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|parse.manfid.manf
)paren
(brace
r_case
id|MANFID_XIRCOM
suffix:colon
id|local-&gt;manf_str
op_assign
l_string|&quot;Xircom&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MANFID_ACCTON
suffix:colon
id|local-&gt;manf_str
op_assign
l_string|&quot;Accton&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MANFID_COMPAQ
suffix:colon
r_case
id|MANFID_COMPAQ2
suffix:colon
id|local-&gt;manf_str
op_assign
l_string|&quot;Compaq&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MANFID_INTEL
suffix:colon
id|local-&gt;manf_str
op_assign
l_string|&quot;Intel&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MANFID_TOSHIBA
suffix:colon
id|local-&gt;manf_str
op_assign
l_string|&quot;Toshiba&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;Unknown Card Manufacturer ID: 0x%04x&bslash;n&quot;
comma
(paren
r_int
)paren
id|parse.manfid.manf
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;found %s card&bslash;n&quot;
comma
id|local-&gt;manf_str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|set_card_type
c_func
(paren
id|link
comma
id|buf
)paren
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;this card is not supported&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* get configuration stuff */
id|tuple.DesiredTuple
op_assign
id|CISTPL_CONFIG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
)paren
)paren
r_goto
id|cis_error
suffix:semicolon
id|link-&gt;conf.ConfigBase
op_assign
id|parse.config.base
suffix:semicolon
id|link-&gt;conf.Present
op_assign
id|parse.config.rmask
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* get the ethernet address from the CIS */
id|tuple.DesiredTuple
op_assign
id|CISTPL_FUNCE
suffix:semicolon
r_for
c_loop
(paren
id|err
op_assign
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
op_logical_neg
id|err
suffix:semicolon
id|err
op_assign
id|next_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
)paren
(brace
multiline_comment|/* Once I saw two CISTPL_FUNCE_LAN_NODE_ID entries:&n;&t; * the first one with a length of zero the second correct -&n;&t; * so I skip all entries with length 0 */
r_if
c_cond
(paren
id|parse.funce.type
op_eq
id|CISTPL_FUNCE_LAN_NODE_ID
op_logical_and
(paren
(paren
id|cistpl_lan_node_id_t
op_star
)paren
id|parse.funce.data
)paren
op_member_access_from_pointer
id|nb
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* not found: try to get the node-id from tuple 0x89 */
id|tuple.DesiredTuple
op_assign
l_int|0x89
suffix:semicolon
multiline_comment|/* data layout looks like tuple 0x22 */
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|get_tuple_data
c_func
(paren
id|GetFirstTuple
comma
id|handle
comma
op_amp
id|tuple
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|tuple.TupleDataLen
op_eq
l_int|8
op_logical_and
op_star
id|buf
op_eq
id|CISTPL_FUNCE_LAN_NODE_ID
)paren
id|memcpy
c_func
(paren
op_amp
id|parse
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
r_else
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* another try&t;(James Lehmer&squot;s CE2 version 4.1)*/
id|tuple.DesiredTuple
op_assign
id|CISTPL_FUNCE
suffix:semicolon
r_for
c_loop
(paren
id|err
op_assign
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
op_logical_neg
id|err
suffix:semicolon
id|err
op_assign
id|next_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
)paren
(brace
r_if
c_cond
(paren
id|parse.funce.type
op_eq
l_int|0x02
op_logical_and
id|parse.funce.data
(braket
l_int|0
)braket
op_eq
l_int|1
op_logical_and
id|parse.funce.data
(braket
l_int|1
)braket
op_eq
l_int|6
op_logical_and
id|tuple.TupleDataLen
op_eq
l_int|13
)paren
(brace
id|buf
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|parse
comma
id|buf
op_plus
l_int|1
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;node-id not found in CIS&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|node_id
op_assign
(paren
id|cistpl_lan_node_id_t
op_star
)paren
id|parse.funce.data
suffix:semicolon
r_if
c_cond
(paren
id|node_id-&gt;nb
op_ne
l_int|6
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;malformed node-id in CIS&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|node_id-&gt;id
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Configure card */
id|link-&gt;state
op_or_assign
id|DEV_CONFIG
suffix:semicolon
id|link-&gt;io.IOAddrLines
op_assign
l_int|10
suffix:semicolon
id|link-&gt;io.Attributes1
op_assign
id|IO_DATA_PATH_WIDTH_16
suffix:semicolon
id|link-&gt;irq.Attributes
op_assign
id|IRQ_HANDLE_PRESENT
suffix:semicolon
id|link-&gt;irq.IRQInfo1
op_assign
id|IRQ_INFO2_VALID
op_or
id|IRQ_LEVEL_ID
suffix:semicolon
r_if
c_cond
(paren
id|irq_list
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
id|link-&gt;irq.IRQInfo2
op_assign
id|irq_mask
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|link-&gt;irq.IRQInfo2
op_or_assign
l_int|1
op_lshift
id|irq_list
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local-&gt;modem
)paren
(brace
r_int
id|pass
suffix:semicolon
r_if
c_cond
(paren
id|do_sound
)paren
(brace
id|link-&gt;conf.Attributes
op_or_assign
id|CONF_ENABLE_SPKR
suffix:semicolon
id|link-&gt;conf.Status
op_or_assign
id|CCSR_AUDIO_ENA
suffix:semicolon
)brace
id|link-&gt;irq.Attributes
op_or_assign
id|IRQ_TYPE_DYNAMIC_SHARING
op_or
id|IRQ_FIRST_SHARED
suffix:semicolon
id|link-&gt;io.NumPorts2
op_assign
l_int|8
suffix:semicolon
id|link-&gt;io.Attributes2
op_assign
id|IO_DATA_PATH_WIDTH_8
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;dingo
)paren
(brace
multiline_comment|/* Take the Modem IO port from the CIS and scan for a free&n;&t;     * Ethernet port */
id|link-&gt;io.NumPorts1
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* no Mako stuff anymore */
id|tuple.DesiredTuple
op_assign
id|CISTPL_CFTABLE_ENTRY
suffix:semicolon
r_for
c_loop
(paren
id|err
op_assign
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
op_logical_neg
id|err
suffix:semicolon
id|err
op_assign
id|next_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
)paren
(brace
r_if
c_cond
(paren
id|cf-&gt;io.nwin
OG
l_int|0
op_logical_and
(paren
id|cf-&gt;io.win
(braket
l_int|0
)braket
dot
id|base
op_amp
l_int|0xf
)paren
op_eq
l_int|8
)paren
(brace
r_for
c_loop
(paren
id|ioaddr
op_assign
l_int|0x300
suffix:semicolon
id|ioaddr
OL
l_int|0x400
suffix:semicolon
id|ioaddr
op_add_assign
l_int|0x10
)paren
(brace
id|link-&gt;conf.ConfigIndex
op_assign
id|cf-&gt;index
suffix:semicolon
id|link-&gt;io.BasePort2
op_assign
id|cf-&gt;io.win
(braket
l_int|0
)braket
dot
id|base
suffix:semicolon
id|link-&gt;io.BasePort1
op_assign
id|ioaddr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
)paren
)paren
r_goto
id|port_found
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|link-&gt;io.NumPorts1
op_assign
l_int|18
suffix:semicolon
multiline_comment|/* We do 2 passes here: The first one uses the regular mapping and&n;&t;     * the second tries again, thereby considering that the 32 ports are&n;&t;     * mirrored every 32 bytes. Actually we use a mirrored port for&n;&t;     * the Mako if (on the first pass) the COR bit 5 is set.&n;&t;     */
r_for
c_loop
(paren
id|pass
op_assign
l_int|0
suffix:semicolon
id|pass
OL
l_int|2
suffix:semicolon
id|pass
op_increment
)paren
(brace
id|tuple.DesiredTuple
op_assign
id|CISTPL_CFTABLE_ENTRY
suffix:semicolon
r_for
c_loop
(paren
id|err
op_assign
id|first_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
op_logical_neg
id|err
suffix:semicolon
id|err
op_assign
id|next_tuple
c_func
(paren
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
)paren
(brace
r_if
c_cond
(paren
id|cf-&gt;io.nwin
OG
l_int|0
op_logical_and
(paren
id|cf-&gt;io.win
(braket
l_int|0
)braket
dot
id|base
op_amp
l_int|0xf
)paren
op_eq
l_int|8
)paren
(brace
id|link-&gt;conf.ConfigIndex
op_assign
id|cf-&gt;index
suffix:semicolon
id|link-&gt;io.BasePort2
op_assign
id|cf-&gt;io.win
(braket
l_int|0
)braket
dot
id|base
suffix:semicolon
id|link-&gt;io.BasePort1
op_assign
id|link-&gt;io.BasePort2
op_plus
(paren
id|pass
ques
c_cond
(paren
id|cf-&gt;index
op_amp
l_int|0x20
ques
c_cond
op_minus
l_int|24
suffix:colon
l_int|8
)paren
suffix:colon
(paren
id|cf-&gt;index
op_amp
l_int|0x20
ques
c_cond
l_int|8
suffix:colon
op_minus
l_int|24
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
)paren
)paren
r_goto
id|port_found
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if special option:&n;&t;     * try to configure as Ethernet only.&n;&t;     * .... */
)brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;no ports available&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|link-&gt;irq.Attributes
op_or_assign
id|IRQ_TYPE_EXCLUSIVE
suffix:semicolon
id|link-&gt;io.NumPorts1
op_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|ioaddr
op_assign
l_int|0x300
suffix:semicolon
id|ioaddr
OL
l_int|0x400
suffix:semicolon
id|ioaddr
op_add_assign
l_int|0x10
)paren
(brace
id|link-&gt;io.BasePort1
op_assign
id|ioaddr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
)paren
)paren
r_goto
id|port_found
suffix:semicolon
)brace
id|link-&gt;io.BasePort1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* let CS decide */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestIO
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
)brace
id|port_found
suffix:colon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|config_error
suffix:semicolon
multiline_comment|/****************&n;     * Now allocate an interrupt line.&t;Note that this does not&n;     * actually assign a handler to the interrupt.&n;     */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestIRQ
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;irq
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestIRQ
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
multiline_comment|/****************&n;     * This actually configures the PCMCIA socket -- setting up&n;     * the I/O windows and the interrupt mapping.&n;     */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestConfiguration
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;conf
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestConfiguration
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local-&gt;dingo
)paren
(brace
id|conf_reg_t
id|reg
suffix:semicolon
id|win_req_t
id|req
suffix:semicolon
id|memreq_t
id|mem
suffix:semicolon
multiline_comment|/* Reset the modem&squot;s BAR to the correct value&n;&t; * This is necessary because in the RequestConfiguration call,&n;&t; * the base address of the ethernet port (BasePort1) is written&n;&t; * to the BAR registers of the modem.&n;&t; */
id|reg.Action
op_assign
id|CS_WRITE
suffix:semicolon
id|reg.Offset
op_assign
id|CISREG_IOBASE_0
suffix:semicolon
id|reg.Value
op_assign
id|link-&gt;io.BasePort2
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|AccessConfigurationRegister
comma
id|link-&gt;handle
comma
op_amp
id|reg
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|AccessConfigurationRegister
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
id|reg.Action
op_assign
id|CS_WRITE
suffix:semicolon
id|reg.Offset
op_assign
id|CISREG_IOBASE_1
suffix:semicolon
id|reg.Value
op_assign
(paren
id|link-&gt;io.BasePort2
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|AccessConfigurationRegister
comma
id|link-&gt;handle
comma
op_amp
id|reg
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|AccessConfigurationRegister
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
multiline_comment|/* There is no config entry for the Ethernet part which&n;&t; * is at 0x0800. So we allocate a window into the attribute&n;&t; * memory and write direct to the CIS registers&n;&t; */
id|req.Attributes
op_assign
id|WIN_DATA_WIDTH_8
op_or
id|WIN_MEMORY_TYPE_AM
op_or
id|WIN_ENABLE
suffix:semicolon
id|req.Base
op_assign
id|req.Size
op_assign
l_int|0
suffix:semicolon
id|req.AccessSpeed
op_assign
l_int|0
suffix:semicolon
id|link-&gt;win
op_assign
(paren
id|window_handle_t
)paren
id|link-&gt;handle
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|RequestWindow
comma
op_amp
id|link-&gt;win
comma
op_amp
id|req
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RequestWindow
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
id|local-&gt;dingo_ccr
op_assign
id|ioremap
c_func
(paren
id|req.Base
comma
l_int|0x1000
)paren
op_plus
l_int|0x0800
suffix:semicolon
id|mem.CardOffset
op_assign
l_int|0x0
suffix:semicolon
id|mem.Page
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|CardServices
c_func
(paren
id|MapMemPage
comma
id|link-&gt;win
comma
op_amp
id|mem
)paren
)paren
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|MapMemPage
comma
id|err
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
multiline_comment|/* Setup the CCRs; there are no infos in the CIS about the Ethernet&n;&t; * part.&n;&t; */
id|writeb
c_func
(paren
l_int|0x47
comma
id|local-&gt;dingo_ccr
op_plus
id|CISREG_COR
)paren
suffix:semicolon
id|ioaddr
op_assign
id|link-&gt;io.BasePort1
suffix:semicolon
id|writeb
c_func
(paren
id|ioaddr
op_amp
l_int|0xff
comma
id|local-&gt;dingo_ccr
op_plus
id|CISREG_IOBASE_0
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|ioaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|local-&gt;dingo_ccr
op_plus
id|CISREG_IOBASE_1
)paren
suffix:semicolon
macro_line|#if 0
(brace
id|u_char
id|tmp
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ECOR:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|readb
c_func
(paren
id|local-&gt;dingo_ccr
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;DCOR:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|readb
c_func
(paren
id|local-&gt;dingo_ccr
op_plus
l_int|0x20
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SCOR:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|readb
c_func
(paren
id|local-&gt;dingo_ccr
op_plus
l_int|0x40
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|writeb
c_func
(paren
l_int|0x01
comma
id|local-&gt;dingo_ccr
op_plus
l_int|0x20
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x0c
comma
id|local-&gt;dingo_ccr
op_plus
l_int|0x22
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
id|local-&gt;dingo_ccr
op_plus
l_int|0x24
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
id|local-&gt;dingo_ccr
op_plus
l_int|0x26
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
id|local-&gt;dingo_ccr
op_plus
l_int|0x28
)paren
suffix:semicolon
)brace
multiline_comment|/* The if_port symbol can be set when the module is loaded */
id|local-&gt;probe_port
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|if_port
)paren
(brace
id|local-&gt;probe_port
op_assign
id|dev-&gt;if_port
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|if_port
op_ge
l_int|1
op_logical_and
id|if_port
op_le
l_int|2
)paren
op_logical_or
(paren
id|local-&gt;mohawk
op_logical_and
id|if_port
op_eq
l_int|4
)paren
)paren
id|dev-&gt;if_port
op_assign
id|if_port
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;invalid if_port requested&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* we can now register the device with the net subsystem */
id|dev-&gt;irq
op_assign
id|link-&gt;irq.AssignedIRQ
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|link-&gt;io.BasePort1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;register_netdev() failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|config_error
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|local-&gt;node.dev_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|link-&gt;dev
op_assign
op_amp
id|local-&gt;node
suffix:semicolon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG_PENDING
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;dingo
)paren
id|do_reset
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* a kludge to make the cem56 work */
multiline_comment|/* give some infos about the hardware */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s: port %#3lx, irq %d, hwaddr&quot;
comma
id|dev-&gt;name
comma
id|local-&gt;manf_str
comma
(paren
id|u_long
)paren
id|dev-&gt;base_addr
comma
(paren
r_int
)paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c%02X&quot;
comma
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|config_error
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG_PENDING
suffix:semicolon
id|xirc2ps_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
r_return
suffix:semicolon
id|cis_error
suffix:colon
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;unable to parse CIS&bslash;n&quot;
)paren
suffix:semicolon
id|failure
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG_PENDING
suffix:semicolon
)brace
multiline_comment|/* xirc2ps_config */
multiline_comment|/****************&n; * After a card is removed, xirc2ps_release() will unregister the net&n; * device, and release the PCMCIA configuration.  If the device is&n; * still open, this will be postponed until it is closed.&n; */
r_static
r_void
DECL|function|xirc2ps_release
id|xirc2ps_release
c_func
(paren
id|u_long
id|arg
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
(paren
id|dev_link_t
op_star
)paren
id|arg
suffix:semicolon
id|local_info_t
op_star
id|local
op_assign
id|link-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|local-&gt;dev
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;release(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the device is currently in use, we won&squot;t release until it&n;     * is actually closed.&n;     */
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;release postponed, &squot;%s&squot; &quot;
l_string|&quot;still open&bslash;n&quot;
comma
id|link-&gt;dev-&gt;dev_name
)paren
suffix:semicolon
id|link-&gt;state
op_or_assign
id|DEV_STALE_CONFIG
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link-&gt;win
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;dingo
)paren
id|iounmap
c_func
(paren
id|local-&gt;dingo_ccr
op_minus
l_int|0x0800
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseWindow
comma
id|link-&gt;win
)paren
suffix:semicolon
)brace
id|CardServices
c_func
(paren
id|ReleaseConfiguration
comma
id|link-&gt;handle
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseIRQ
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;irq
)paren
suffix:semicolon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG
suffix:semicolon
)brace
multiline_comment|/* xirc2ps_release */
multiline_comment|/*====================================================================*/
multiline_comment|/****************&n; * The card status event handler.  Mostly, this schedules other&n; * stuff to run after an event is received.  A CARD_REMOVAL event&n; * also sets some flags to discourage the net drivers from trying&n; * to talk to the card any more.&n; *&n; * When a CARD_REMOVAL event is received, we immediately set a flag&n; * to block future accesses to this device.  All the functions that&n; * actually access the device should check this flag to make sure&n; * the card is still present.&n; */
r_static
r_int
DECL|function|xirc2ps_event
id|xirc2ps_event
c_func
(paren
id|event_t
id|event
comma
r_int
id|priority
comma
id|event_callback_args_t
op_star
id|args
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
id|args-&gt;client_data
suffix:semicolon
id|local_info_t
op_star
id|lp
op_assign
id|link-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|lp-&gt;dev
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;event(%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|event
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CS_EVENT_REGISTRATION_COMPLETE
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;registration complete&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_EVENT_CARD_REMOVAL
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_PRESENT
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|netif_device_detach
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|link-&gt;release
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CS_EVENT_CARD_INSERTION
suffix:colon
id|link-&gt;state
op_or_assign
id|DEV_PRESENT
op_or
id|DEV_CONFIG_PENDING
suffix:semicolon
id|xirc2ps_config
c_func
(paren
id|link
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_EVENT_PM_SUSPEND
suffix:colon
id|link-&gt;state
op_or_assign
id|DEV_SUSPEND
suffix:semicolon
multiline_comment|/* Fall through... */
r_case
id|CS_EVENT_RESET_PHYSICAL
suffix:colon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
id|netif_device_detach
c_func
(paren
id|dev
)paren
suffix:semicolon
id|do_powerdown
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|CardServices
c_func
(paren
id|ReleaseConfiguration
comma
id|link-&gt;handle
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CS_EVENT_PM_RESUME
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_SUSPEND
suffix:semicolon
multiline_comment|/* Fall through... */
r_case
id|CS_EVENT_CARD_RESET
suffix:colon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|CardServices
c_func
(paren
id|RequestConfiguration
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
id|do_reset
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|netif_device_attach
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* xirc2ps_event */
multiline_comment|/*====================================================================*/
multiline_comment|/****************&n; * This is the Interrupt service route.&n; */
r_static
r_void
DECL|function|xirc2ps_interrupt
id|xirc2ps_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
suffix:semicolon
id|u_char
id|saved_page
suffix:semicolon
r_int
id|bytes_rcvd
suffix:semicolon
r_int
id|int_status
comma
id|eth_status
comma
id|rx_status
comma
id|tx_status
suffix:semicolon
r_int
id|rsr
comma
id|pktlen
suffix:semicolon
id|ulong
id|start_ticks
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* fixme: jiffies rollover every 497 days&n;&t;&t;&t;&t;  * is this something to worry about?&n;&t;&t;&t;&t;  * -- on a laptop?&n;&t;&t;&t;&t;  */
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;mohawk
)paren
(brace
multiline_comment|/* must disable the interrupt */
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|6
comma
l_string|&quot;%s: interrupt %d at %#x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|irq
comma
id|ioaddr
)paren
suffix:semicolon
id|saved_page
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_PR
)paren
suffix:semicolon
multiline_comment|/* Read the ISR to see whats the cause for the interrupt.&n;     * This also clears the interrupt flags on CE2 cards&n;     */
id|int_status
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_ISR
)paren
suffix:semicolon
id|bytes_rcvd
op_assign
l_int|0
suffix:semicolon
id|loop_entry
suffix:colon
r_if
c_cond
(paren
id|int_status
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* card may be ejected */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: interrupt %d for dead card&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|irq
)paren
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
id|eth_status
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_ESR
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|rx_status
op_assign
id|GetByte
c_func
(paren
id|XIRCREG40_RXST0
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG40_RXST0
comma
(paren
op_complement
id|rx_status
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|tx_status
op_assign
id|GetByte
c_func
(paren
id|XIRCREG40_TXST0
)paren
suffix:semicolon
id|tx_status
op_or_assign
id|GetByte
c_func
(paren
id|XIRCREG40_TXST1
)paren
op_lshift
l_int|8
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG40_TXST0
comma
l_int|0
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG40_TXST1
comma
l_int|0
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: ISR=%#2.2x ESR=%#2.2x RSR=%#2.2x TSR=%#4.4x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|int_status
comma
id|eth_status
comma
id|rx_status
comma
id|tx_status
)paren
suffix:semicolon
multiline_comment|/***** receive section ******/
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|eth_status
op_amp
id|FullPktRcvd
)paren
(brace
id|rsr
op_assign
id|GetByte
c_func
(paren
id|XIRCREG0_RSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_rcvd
OG
id|maxrx_bytes
op_logical_and
(paren
id|rsr
op_amp
id|PktRxOk
)paren
)paren
(brace
multiline_comment|/* too many bytes received during this int, drop the rest of the&n;&t;     * packets */
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: RX drop, too much done&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|PutWord
c_func
(paren
id|XIRCREG0_DO
comma
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/* issue cmd: skip_rx_packet */
)brace
r_else
r_if
c_cond
(paren
id|rsr
op_amp
id|PktRxOk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pktlen
op_assign
id|GetWord
c_func
(paren
id|XIRCREG0_RBC
)paren
suffix:semicolon
id|bytes_rcvd
op_add_assign
id|pktlen
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|5
comma
l_string|&quot;rsr=%#02x packet_length=%u&bslash;n&quot;
comma
id|rsr
comma
id|pktlen
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pktlen
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* 1 extra so we can use insw */
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;low memory, packet dropped (size=%u)&bslash;n&quot;
comma
id|pktlen
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* okay get the packet */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;silicon
op_eq
l_int|0
)paren
(brace
multiline_comment|/* work around a hardware bug */
r_int
id|rhsa
suffix:semicolon
multiline_comment|/* receive start address */
id|SelectPage
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|rhsa
op_assign
id|GetWord
c_func
(paren
id|XIRCREG5_RHSA0
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|rhsa
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* skip control infos */
r_if
c_cond
(paren
id|rhsa
op_ge
l_int|0x8000
)paren
id|rhsa
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rhsa
op_plus
id|pktlen
OG
l_int|0x8000
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_char
op_star
id|buf
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|pktlen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pktlen
suffix:semicolon
id|i
op_increment
comma
id|rhsa
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_EDP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rhsa
op_eq
l_int|0x8000
)paren
(brace
id|rhsa
op_assign
l_int|0
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|insw
c_func
(paren
id|ioaddr
op_plus
id|XIRCREG_EDP
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pktlen
)paren
comma
(paren
id|pktlen
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
r_else
r_if
c_cond
(paren
id|lp-&gt;mohawk
)paren
(brace
multiline_comment|/* To use this 32 bit access we should use&n;&t;&t;     * a manual optimized loop&n;&t;&t;     * Also the words are swapped, we can get more&n;&t;&t;     * performance by using 32 bit access and swapping&n;&t;&t;     * the words in a register. Will need this for cardbus&n;&t;&t;     *&n;&t;&t;     * Note: don&squot;t forget to change the ALLOC_SKB to .. +3&n;&t;&t;     */
r_int
id|i
suffix:semicolon
id|u_long
op_star
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|pktlen
)paren
suffix:semicolon
r_register
id|u_long
id|a
suffix:semicolon
id|ioaddr_t
id|edpreg
op_assign
id|ioaddr
op_plus
id|XIRCREG_EDP
op_minus
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|4
comma
id|p
op_increment
)paren
(brace
id|a
op_assign
id|inl
c_func
(paren
id|edpreg
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;rorl $16,%0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=q&quot;
(paren
id|a
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|a
)paren
)paren
suffix:semicolon
op_star
id|p
op_assign
id|a
suffix:semicolon
)brace
)brace
macro_line|#endif
r_else
(brace
id|insw
c_func
(paren
id|ioaddr
op_plus
id|XIRCREG_EDP
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pktlen
)paren
comma
(paren
id|pktlen
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pktlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rsr
op_amp
id|PhyPkt
)paren
)paren
id|lp-&gt;stats.multicast
op_increment
suffix:semicolon
)brace
id|PutWord
c_func
(paren
id|XIRCREG0_DO
comma
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/* issue cmd: skip_rx_packet */
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|5
comma
l_string|&quot;rsr=%#02x&bslash;n&quot;
comma
id|rsr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rsr
op_amp
id|PktTooLong
)paren
(brace
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: Packet too long&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rsr
op_amp
id|CRCErr
)paren
(brace
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: CRC error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rsr
op_amp
id|AlignErr
)paren
(brace
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
multiline_comment|/* okay ? */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: Alignment error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* get the new ethernet status */
id|eth_status
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_ESR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rx_status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Receive overrun */
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
id|ClearRxOvrun
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;receive overrun cleared&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/***** transmit section ******/
r_if
c_cond
(paren
id|int_status
op_amp
id|PktTxed
)paren
(brace
r_int
id|n
comma
id|nn
suffix:semicolon
id|n
op_assign
id|lp-&gt;last_ptr_value
suffix:semicolon
id|nn
op_assign
id|GetByte
c_func
(paren
id|XIRCREG0_PTR
)paren
suffix:semicolon
id|lp-&gt;last_ptr_value
op_assign
id|nn
suffix:semicolon
r_if
c_cond
(paren
id|nn
OL
id|n
)paren
multiline_comment|/* rollover */
id|lp-&gt;stats.tx_packets
op_add_assign
l_int|256
op_minus
id|n
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
id|nn
)paren
(brace
multiline_comment|/* happens sometimes - don&squot;t know why */
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;PTR not changed?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|lp-&gt;stats.tx_packets
op_add_assign
id|lp-&gt;last_ptr_value
op_minus
id|n
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0002
)paren
(brace
multiline_comment|/* Execessive collissions */
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;tx restarted due to execssive collissions&bslash;n&quot;
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
id|RestartTx
)paren
suffix:semicolon
multiline_comment|/* restart transmitter process */
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0040
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
multiline_comment|/* recalculate our work chunk so that we limit the duration of this&n;     * ISR to about 1/10 of a second.&n;     * Calculate only if we received a reasonable amount of bytes.&n;     */
r_if
c_cond
(paren
id|bytes_rcvd
OG
l_int|1000
)paren
(brace
id|u_long
id|duration
op_assign
id|jiffies
op_minus
id|start_ticks
suffix:semicolon
r_if
c_cond
(paren
id|duration
op_ge
id|HZ
op_div
l_int|10
)paren
(brace
multiline_comment|/* if more than about 1/10 second */
id|maxrx_bytes
op_assign
(paren
id|bytes_rcvd
op_star
(paren
id|HZ
op_div
l_int|10
)paren
)paren
op_div
id|duration
suffix:semicolon
r_if
c_cond
(paren
id|maxrx_bytes
OL
l_int|2000
)paren
id|maxrx_bytes
op_assign
l_int|2000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|maxrx_bytes
OG
l_int|22000
)paren
id|maxrx_bytes
op_assign
l_int|22000
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;set maxrx=%u (rcvd=%u ticks=%lu)&bslash;n&quot;
comma
id|maxrx_bytes
comma
id|bytes_rcvd
comma
id|duration
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|duration
op_logical_and
id|maxrx_bytes
OL
l_int|22000
)paren
(brace
multiline_comment|/* now much faster */
id|maxrx_bytes
op_add_assign
l_int|2000
suffix:semicolon
r_if
c_cond
(paren
id|maxrx_bytes
OG
l_int|22000
)paren
id|maxrx_bytes
op_assign
l_int|22000
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;set maxrx=%u&bslash;n&quot;
comma
id|maxrx_bytes
)paren
suffix:semicolon
)brace
)brace
id|leave
suffix:colon
r_if
c_cond
(paren
id|lockup_hack
)paren
(brace
r_if
c_cond
(paren
id|int_status
op_ne
l_int|0xff
op_logical_and
(paren
id|int_status
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_ISR
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|loop_entry
suffix:semicolon
)brace
id|SelectPage
c_func
(paren
id|saved_page
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
id|EnableIntr
)paren
suffix:semicolon
multiline_comment|/* re-enable interrupts */
multiline_comment|/* Instead of dropping packets during a receive, we could&n;     * force an interrupt with this command:&n;     *&t;  PutByte(XIRCREG_CR, EnableIntr|ForceIntr);&n;     */
)brace
multiline_comment|/* xirc2ps_interrupt */
multiline_comment|/*====================================================================*/
r_static
r_void
DECL|function|do_tx_timeout
id|do_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: transmit timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* reset the card */
id|do_reset
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_start_xmit
id|do_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|okay
suffix:semicolon
r_int
id|freespace
suffix:semicolon
r_int
id|pktlen
op_assign
id|skb
ques
c_cond
id|skb-&gt;len
suffix:colon
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;do_start_xmit(skb=%p, dev=%p) len=%u&bslash;n&quot;
comma
id|skb
comma
id|dev
comma
id|pktlen
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* adjust the packet length to min. required&n;     * and hope that the buffer is large enough&n;     * to provide some random data.&n;     * fixme: For Mohawk we can change this by sending&n;     * a larger packetlen than we actually have; the chip will&n;     * pad this in his buffer with random bytes&n;     */
r_if
c_cond
(paren
id|pktlen
OL
id|ETH_ZLEN
)paren
id|pktlen
op_assign
id|ETH_ZLEN
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|PutWord
c_func
(paren
id|XIRCREG0_TRS
comma
(paren
id|u_short
)paren
id|pktlen
op_plus
l_int|2
)paren
suffix:semicolon
id|freespace
op_assign
id|GetWord
c_func
(paren
id|XIRCREG0_TSO
)paren
suffix:semicolon
id|okay
op_assign
id|freespace
op_amp
l_int|0x8000
suffix:semicolon
id|freespace
op_and_assign
l_int|0x7fff
suffix:semicolon
multiline_comment|/* TRS doesn&squot;t work - (indeed it is eliminated with sil-rev 1) */
id|okay
op_assign
id|pktlen
op_plus
l_int|2
OL
id|freespace
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
op_plus
(paren
id|okay
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
comma
l_string|&quot;%s: avail. tx space=%u%s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|freespace
comma
id|okay
ques
c_cond
l_string|&quot; (okay)&quot;
suffix:colon
l_string|&quot; (not enough)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|okay
)paren
(brace
multiline_comment|/* not enough space */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* upper layer may decide to requeue this packet */
)brace
multiline_comment|/* send the packet */
id|PutWord
c_func
(paren
id|XIRCREG_EDP
comma
(paren
id|u_short
)paren
id|pktlen
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|XIRCREG_EDP
comma
id|skb-&gt;data
comma
id|pktlen
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pktlen
op_amp
l_int|1
)paren
id|PutByte
c_func
(paren
id|XIRCREG_EDP
comma
id|skb-&gt;data
(braket
id|pktlen
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;mohawk
)paren
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
id|TransmitPacket
op_or
id|EnableIntr
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|pktlen
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|net_device_stats
op_star
DECL|function|do_get_stats
id|do_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&t;lp-&gt;stats.rx_missed_errors = GetByte(?) */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/****************&n; * Set all addresses: This first one is the individual address,&n; * the next 9 addresses are taken from the multicast list and&n; * the rest is filled with the individual address.&n; */
r_static
r_void
DECL|function|set_addresses
id|set_addresses
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
comma
id|n
suffix:semicolon
id|SelectPage
c_func
(paren
id|k
op_assign
l_int|0x50
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|8
comma
id|n
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|5
)paren
(brace
r_if
c_cond
(paren
op_increment
id|n
OG
l_int|9
)paren
r_break
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OG
l_int|15
)paren
(brace
id|j
op_assign
l_int|8
suffix:semicolon
id|k
op_increment
suffix:semicolon
id|SelectPage
c_func
(paren
id|k
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_logical_and
id|n
op_le
id|dev-&gt;mc_count
op_logical_and
id|dmi
)paren
(brace
id|addr
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
)brace
r_else
id|addr
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;mohawk
)paren
id|PutByte
c_func
(paren
id|j
comma
id|addr
(braket
l_int|5
op_minus
id|i
)braket
)paren
suffix:semicolon
r_else
id|PutByte
c_func
(paren
id|j
comma
id|addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/****************&n; * Set or clear the multicast filter for this adaptor.&n; * We can filter up to 9 addresses, if more are requested we set&n; * multicast promiscuous mode.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0x42
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* snoop */
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0x06
)paren
suffix:semicolon
multiline_comment|/* set MPE and PME */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
OG
l_int|9
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0x06
)paren
suffix:semicolon
multiline_comment|/* set MPE */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
multiline_comment|/* the chip can filter 9 addresses perfectly */
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0x00
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG40_CMD0
comma
id|Offline
)paren
suffix:semicolon
id|set_addresses
c_func
(paren
id|dev
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG40_CMD0
comma
id|EnableRecv
op_or
id|Online
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* standard usage */
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0x00
)paren
suffix:semicolon
)brace
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_config
id|do_config
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifmap
op_star
id|map
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|dev-&gt;priv
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;do_config(%p)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;port
op_ne
l_int|255
op_logical_and
id|map-&gt;port
op_ne
id|dev-&gt;if_port
)paren
(brace
r_if
c_cond
(paren
id|map-&gt;port
OG
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map-&gt;port
)paren
(brace
id|local-&gt;probe_port
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;if_port
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|local-&gt;probe_port
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;if_port
op_assign
id|map-&gt;port
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: switching to %s port&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|if_names
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
id|do_reset
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* not the fine way :-) */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************&n; * Open the driver&n; */
r_static
r_int
DECL|function|do_open
id|do_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dev_link_t
op_star
id|link
op_assign
op_amp
id|lp-&gt;link
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;do_open(%p)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Check that the PCMCIA card is still here. */
multiline_comment|/* Physical device present signature. */
r_if
c_cond
(paren
op_logical_neg
id|DEV_OK
c_func
(paren
id|link
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* okay */
id|link-&gt;open
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|do_reset
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_ioctl
id|do_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
op_star
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s: ioctl(%-.6s, %#04x) %04x %04x %04x %04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;ifr_ifrn.ifrn_name
comma
id|cmd
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
comma
id|data
(braket
l_int|2
)braket
comma
id|data
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local-&gt;mohawk
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDEVPRIVATE
suffix:colon
multiline_comment|/* Get the address of the PHY in use. */
id|data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we have only this address */
multiline_comment|/* fall trough */
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|1
suffix:colon
multiline_comment|/* Read the specified MII register. */
id|data
(braket
l_int|3
)braket
op_assign
id|mii_rd
c_func
(paren
id|ioaddr
comma
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|2
suffix:colon
multiline_comment|/* Write the specified MII register */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|mii_wr
c_func
(paren
id|ioaddr
comma
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|2
)braket
comma
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|hardreset
id|hardreset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG4_GPR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear bit 0: power down */
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|25
)paren
suffix:semicolon
multiline_comment|/* wait 40 msec */
r_if
c_cond
(paren
id|local-&gt;mohawk
)paren
id|PutByte
c_func
(paren
id|XIRCREG4_GPR1
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* set bit 0: power up */
r_else
id|PutByte
c_func
(paren
id|XIRCREG4_GPR1
comma
l_int|1
op_or
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set bit 0: power up, bit 2: AIC */
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
multiline_comment|/* wait 20 msec */
)brace
r_static
r_void
DECL|function|do_reset
id|do_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|full
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|value
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s: do_reset(%p,%d)&bslash;n&quot;
comma
id|dev
ques
c_cond
id|dev-&gt;name
suffix:colon
l_string|&quot;eth?&quot;
comma
id|dev
comma
id|full
)paren
suffix:semicolon
id|hardreset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
id|SoftReset
)paren
suffix:semicolon
multiline_comment|/* set */
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
multiline_comment|/* wait 20 msec */
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear */
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|25
)paren
suffix:semicolon
multiline_comment|/* wait 40 msec */
r_if
c_cond
(paren
id|local-&gt;mohawk
)paren
(brace
id|SelectPage
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set pin GP1 and GP2 to output  (0x0c)&n;&t; * set GP1 to low to power up the ML6692 (0x00)&n;&t; * set GP2 to high to power up the 10Mhz chip  (0x02)&n;&t; */
id|PutByte
c_func
(paren
id|XIRCREG4_GPR0
comma
l_int|0x0e
)paren
suffix:semicolon
)brace
multiline_comment|/* give the circuits some time to power up */
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
multiline_comment|/* about 500ms */
id|local-&gt;last_ptr_value
op_assign
l_int|0
suffix:semicolon
id|local-&gt;silicon
op_assign
id|local-&gt;mohawk
ques
c_cond
(paren
id|GetByte
c_func
(paren
id|XIRCREG4_BOV
)paren
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
suffix:colon
(paren
id|GetByte
c_func
(paren
id|XIRCREG4_BOV
)paren
op_amp
l_int|0x30
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;probe_port
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|local-&gt;mohawk
)paren
(brace
id|SelectPage
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG4_GPR0
comma
l_int|4
)paren
suffix:semicolon
id|local-&gt;probe_port
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|2
)paren
(brace
multiline_comment|/* enable 10Base2 */
id|SelectPage
c_func
(paren
l_int|0x42
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0xC0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* enable 10BaseT */
id|SelectPage
c_func
(paren
l_int|0x42
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0x80
)paren
suffix:semicolon
)brace
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|25
)paren
suffix:semicolon
multiline_comment|/* wait 40 msec to let it complete */
macro_line|#ifdef PCMCIA_DEBUG
r_if
c_cond
(paren
id|pc_debug
)paren
(brace
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|value
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_ESR
)paren
suffix:semicolon
multiline_comment|/* read the ESR */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: ESR is: %#02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* setup the ECR */
id|SelectPage
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG1_IMR0
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* allow all ints */
id|PutByte
c_func
(paren
id|XIRCREG1_IMR1
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and Set TxUnderrunDetect */
id|value
op_assign
id|GetByte
c_func
(paren
id|XIRCREG1_ECR
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|local-&gt;mohawk
)paren
id|value
op_or_assign
id|DisableLinkPulse
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG1_ECR
comma
id|value
)paren
suffix:semicolon
macro_line|#endif
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s: ECR is: %#02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|value
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0x42
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG42_SWC0
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* disable source insertion */
r_if
c_cond
(paren
id|local-&gt;silicon
op_ne
l_int|1
)paren
(brace
multiline_comment|/* set the local memory dividing line.&n;&t; * The comments in the sample code say that this is only&n;&t; * settable with the scipper version 2 which is revision 0.&n;&t; * Always for CE3 cards&n;&t; */
id|SelectPage
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|PutWord
c_func
(paren
id|XIRCREG2_RBS
comma
l_int|0x2000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|full
)paren
id|set_addresses
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Hardware workaround:&n;     * The receive byte pointer after reset is off by 1 so we need&n;     * to move the offset pointer back to 0.&n;     */
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|PutWord
c_func
(paren
id|XIRCREG0_DO
comma
l_int|0x2000
)paren
suffix:semicolon
multiline_comment|/* change offset command, off=0 */
multiline_comment|/* setup MAC IMRs and clear status registers */
id|SelectPage
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Bit 7 ... bit 0 */
id|PutByte
c_func
(paren
id|XIRCREG40_RMASK0
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* ROK, RAB, rsv, RO, CRC, AE, PTL, MP */
id|PutByte
c_func
(paren
id|XIRCREG40_TMASK0
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* TOK, TAB, SQE, LL, TU, JAB, EXC, CRS */
id|PutByte
c_func
(paren
id|XIRCREG40_TMASK1
comma
l_int|0xb0
)paren
suffix:semicolon
multiline_comment|/* rsv, rsv, PTD, EXT, rsv,rsv,rsv, rsv*/
id|PutByte
c_func
(paren
id|XIRCREG40_RXST0
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* ROK, RAB, REN, RO, CRC, AE, PTL, MP */
id|PutByte
c_func
(paren
id|XIRCREG40_TXST0
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* TOK, TAB, SQE, LL, TU, JAB, EXC, CRS */
id|PutByte
c_func
(paren
id|XIRCREG40_TXST1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* TEN, rsv, PTD, EXT, retry_counter:4  */
r_if
c_cond
(paren
id|full
op_logical_and
id|local-&gt;mohawk
op_logical_and
id|init_mii
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|4
op_logical_or
id|local-&gt;dingo
op_logical_or
id|local-&gt;new_mii
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: MII selected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG2_MSR
comma
id|GetByte
c_func
(paren
id|XIRCREG2_MSR
)paren
op_or
l_int|0x08
)paren
suffix:semicolon
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: MII detected; using 10mbs&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0x42
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|2
)paren
multiline_comment|/* enable 10Base2 */
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0xC0
)paren
suffix:semicolon
r_else
multiline_comment|/* enable 10BaseT */
id|PutByte
c_func
(paren
id|XIRCREG42_SWC1
comma
l_int|0x80
)paren
suffix:semicolon
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|25
)paren
suffix:semicolon
multiline_comment|/* wait 40 msec to let it complete */
)brace
r_if
c_cond
(paren
id|full_duplex
)paren
id|PutByte
c_func
(paren
id|XIRCREG1_ECR
comma
id|GetByte
c_func
(paren
id|XIRCREG1_ECR
op_or
id|FullDuplex
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No MII */
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|value
op_assign
id|GetByte
c_func
(paren
id|XIRCREG_ESR
)paren
suffix:semicolon
multiline_comment|/* read the ESR */
id|dev-&gt;if_port
op_assign
(paren
id|value
op_amp
id|MediaSelect
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|2
suffix:semicolon
)brace
multiline_comment|/* configure the LEDs */
id|SelectPage
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|1
op_logical_or
id|dev-&gt;if_port
op_eq
l_int|4
)paren
multiline_comment|/* TP: Link and Activity */
id|PutByte
c_func
(paren
id|XIRCREG2_LED
comma
l_int|0x3b
)paren
suffix:semicolon
r_else
multiline_comment|/* Coax: Not-Collision and Activity */
id|PutByte
c_func
(paren
id|XIRCREG2_LED
comma
l_int|0x3a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;dingo
)paren
id|PutByte
c_func
(paren
l_int|0x0b
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* 100 Mbit LED */
multiline_comment|/* enable receiver and put the mac online */
r_if
c_cond
(paren
id|full
)paren
(brace
id|SelectPage
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG40_CMD0
comma
id|EnableRecv
op_or
id|Online
)paren
suffix:semicolon
)brace
multiline_comment|/* setup Ethernet IMR and enable interrupts */
id|SelectPage
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG1_IMR0
comma
l_int|0xff
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
id|EnableIntr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;modem
op_logical_and
op_logical_neg
id|local-&gt;dingo
)paren
(brace
multiline_comment|/* do some magic */
r_if
c_cond
(paren
op_logical_neg
(paren
id|GetByte
c_func
(paren
l_int|0x10
)paren
op_amp
l_int|0x01
)paren
)paren
id|PutByte
c_func
(paren
l_int|0x10
comma
l_int|0x11
)paren
suffix:semicolon
multiline_comment|/* unmask master-int bit */
)brace
r_if
c_cond
(paren
id|full
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: media %s, silicon revision %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|if_names
(braket
id|dev-&gt;if_port
)braket
comma
id|local-&gt;silicon
)paren
suffix:semicolon
multiline_comment|/* We should switch back to page 0 to avoid a bug in revision 0&n;     * where regs with offset below 8 can&squot;t be read after an access&n;     * to the MAC registers */
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/****************&n; * Initialize the Media-Independent-Interface&n; * Returns: True if we have a good MII&n; */
r_static
r_int
DECL|function|init_mii
id|init_mii
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|local_info_t
op_star
id|local
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|control
comma
id|status
comma
id|linkpartner
suffix:semicolon
r_int
id|i
suffix:semicolon
id|status
op_assign
id|mii_rd
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0xff00
)paren
op_ne
l_int|0x7800
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* No MII */
id|local-&gt;new_mii
op_assign
(paren
id|mii_rd
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|2
)paren
op_ne
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local-&gt;probe_port
)paren
id|control
op_assign
l_int|0x1000
suffix:semicolon
multiline_comment|/* auto neg */
r_else
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|4
)paren
id|control
op_assign
l_int|0x2000
suffix:semicolon
multiline_comment|/* no auto neg, 100mbs mode */
r_else
id|control
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* no auto neg, 10mbs mode */
id|mii_wr
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|0
comma
id|control
comma
l_int|16
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|control
op_assign
id|mii_rd
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control
op_amp
l_int|0x0400
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s can&squot;t take PHY out of isolation mode&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|local-&gt;probe_port
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local-&gt;probe_port
)paren
(brace
multiline_comment|/* according to the DP83840A specs the auto negotiation process&n;&t; * may take up to 3.5 sec, so we use this also for our ML6692&n;&t; * Fixme: Better to use a timer here!&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|35
suffix:semicolon
id|i
op_increment
)paren
(brace
id|busy_loop
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* wait 100 msec */
id|status
op_assign
id|mii_rd
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x0020
)paren
op_logical_and
(paren
id|status
op_amp
l_int|0x0004
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x0020
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: autonegotiation failed;&quot;
l_string|&quot; using 10mbs&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local-&gt;new_mii
)paren
(brace
id|control
op_assign
l_int|0x0000
suffix:semicolon
id|mii_wr
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|0
comma
id|control
comma
l_int|16
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|dev-&gt;if_port
op_assign
(paren
id|GetByte
c_func
(paren
id|XIRCREG_ESR
)paren
op_amp
id|MediaSelect
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
id|linkpartner
op_assign
id|mii_rd
c_func
(paren
id|ioaddr
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: MII link partner: %04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|linkpartner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linkpartner
op_amp
l_int|0x0080
)paren
(brace
id|dev-&gt;if_port
op_assign
l_int|4
suffix:semicolon
)brace
r_else
id|dev-&gt;if_port
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_powerdown
id|do_powerdown
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;do_powerdown(%p)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG4_GPR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear bit 0: power down */
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_stop
id|do_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|local_info_t
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dev_link_t
op_star
id|link
op_assign
op_amp
id|lp-&gt;link
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;do_stop(%p)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG_CR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|SelectPage
c_func
(paren
l_int|0x01
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG1_IMR0
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* forbid all ints */
id|SelectPage
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|PutByte
c_func
(paren
id|XIRCREG4_GPR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear bit 0: power down */
id|SelectPage
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|link-&gt;open
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_CONFIG
)paren
id|mod_timer
c_func
(paren
op_amp
id|link-&gt;release
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|init_xirc2ps_cs
id|init_xirc2ps_cs
c_func
(paren
r_void
)paren
(brace
id|servinfo_t
id|serv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lockup_hack
)paren
id|printk
c_func
(paren
id|KINF_XIRC
l_string|&quot;lockup hack is enabled&bslash;n&quot;
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|GetCardServicesInfo
comma
op_amp
id|serv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serv.Revision
op_ne
id|CS_RELEASE_CODE
)paren
(brace
id|printk
c_func
(paren
id|KNOT_XIRC
l_string|&quot;Card Services release does not match!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;pc_debug=%d&bslash;n&quot;
comma
id|pc_debug
)paren
suffix:semicolon
id|register_pccard_driver
c_func
(paren
op_amp
id|dev_info
comma
op_amp
id|xirc2ps_attach
comma
op_amp
id|xirc2ps_detach
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|exit_xirc2ps_cs
id|exit_xirc2ps_cs
c_func
(paren
r_void
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;unloading&bslash;n&quot;
)paren
suffix:semicolon
id|unregister_pccard_driver
c_func
(paren
op_amp
id|dev_info
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dev_list
)paren
(brace
r_if
c_cond
(paren
id|dev_list-&gt;state
op_amp
id|DEV_CONFIG
)paren
id|xirc2ps_release
c_func
(paren
(paren
id|u_long
)paren
id|dev_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_list
)paren
multiline_comment|/* xirc2ps_release() might already have detached... */
id|xirc2ps_detach
c_func
(paren
id|dev_list
)paren
suffix:semicolon
)brace
)brace
DECL|variable|init_xirc2ps_cs
id|module_init
c_func
(paren
id|init_xirc2ps_cs
)paren
suffix:semicolon
DECL|variable|exit_xirc2ps_cs
id|module_exit
c_func
(paren
id|exit_xirc2ps_cs
)paren
suffix:semicolon
eof
