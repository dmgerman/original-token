multiline_comment|/* hamachi.c: A Packet Engines GNIC-II Gigabit Ethernet driver for Linux. */
multiline_comment|/*&n;&t;Written 1998-2000 by Donald Becker.&n;&t;Updates 2000 by Keith Underwood.&n;&n;&t;This software may be used and distributed according to the terms of &n;&t;the GNU Public License (GPL), incorporated herein by reference.&n;&t;Drivers based on or derived from this code fall under the GPL and must&n;&t;retain the authorship, copyright and license notice.  This file is not&n;&t;a complete program and may only be used when the entire operating&n;&t;system is licensed under the GPL.&n;&n;&t;The author may be reached as becker@scyld.com, or C/O&n;&t;Scyld Computing Corporation&n;&t;410 Severn Ave., Suite 210&n;&t;Annapolis MD 21403&n;&n;&t;This driver is for the Packet Engines GNIC-II PCI Gigabit Ethernet&n;&t;adapter.&n;&n;&t;Support and updates available at&n;&t;http://www.scyld.com/network/hamachi.html&n;&t;or&n;&t;http://www.parl.clemson.edu/~keithu/hamachi.html&n;&n;&t;For best viewing, set your tabs to 3.&n;&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;hamachi.c:v1.01 5/16/2000  Written by Donald Becker&bslash;n&quot;
l_string|&quot;   Some modifications by Eric kasten &lt;kasten@nscl.msu.edu&gt;&bslash;n&quot;
l_string|&quot;   Further modifications by Keith Underwood &lt;keithu@parl.clemson.edu&gt;&bslash;n&quot;
l_string|&quot;   Support by many others&bslash;n&quot;
l_string|&quot;   http://www.scyld.com/network/hamachi.html&bslash;n&quot;
l_string|&quot;   or&bslash;n&quot;
l_string|&quot;   http://www.parl.clemson.edu/~keithu/drivers/hamachi.html&bslash;n&quot;
suffix:semicolon
multiline_comment|/* A few user-configurable values. */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 normal messages, 0 quiet .. 7 verbose.  */
DECL|macro|final_version
mdefine_line|#define final_version
DECL|macro|hamachi_debug
mdefine_line|#define hamachi_debug debug
multiline_comment|/* Maximum events (Rx packets, etc.) to handle at each interrupt. */
DECL|variable|max_interrupt_work
r_static
r_int
id|max_interrupt_work
op_assign
l_int|40
suffix:semicolon
DECL|variable|mtu
r_static
r_int
id|mtu
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default values selected by testing on a dual processor PIII-450 */
multiline_comment|/* These six interrupt control parameters may be set directly when loading the&n; * module, or through the rx_params and tx_params variables&n; */
DECL|variable|max_rx_latency
r_static
r_int
id|max_rx_latency
op_assign
l_int|0x11
suffix:semicolon
DECL|variable|max_rx_gap
r_static
r_int
id|max_rx_gap
op_assign
l_int|0x05
suffix:semicolon
DECL|variable|min_rx_pkt
r_static
r_int
id|min_rx_pkt
op_assign
l_int|0x18
suffix:semicolon
DECL|variable|max_tx_latency
r_static
r_int
id|max_tx_latency
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|max_tx_gap
r_static
r_int
id|max_tx_gap
op_assign
l_int|0x00
suffix:semicolon
DECL|variable|min_tx_pkt
r_static
r_int
id|min_tx_pkt
op_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* Set the copy breakpoint for the copy-only-tiny-frames scheme.&n;   -Setting to &gt; 1518 causes all frames to be copied&n;&t;-Setting to 0 disables copies&n;*/
DECL|variable|rx_copybreak
r_static
r_int
id|rx_copybreak
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An override for the hardware detection of bus width.&n;&t;Set to 1 to force 32 bit PCI bus detection.  Set to 4 to force 64 bit.&n;&t;Add 2 to disable parity detection.&n;*/
DECL|variable|force32
r_static
r_int
id|force32
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Used to pass the media type, etc.&n;   These exist for driver interoperability.&n;   No media types are currently defined.&n;&t;&t;- The lower 4 bits are reserved for the media type.&n;&t;&t;- The next three bits may be set to one of the following:&n;&t;&t;&t;0x00000000 : Autodetect PCI bus&n;&t;&t;&t;0x00000010 : Force 32 bit PCI bus&n;&t;&t;&t;0x00000020 : Disable parity detection&n;&t;&t;&t;0x00000040 : Force 64 bit PCI bus&n;&t;&t;&t;Default is autodetect&n;&t;&t;- The next bit can be used to force half-duplex.  This is a bad&n;&t;&t;  idea since no known implementations implement half-duplex, and,&n;&t;&t;  in general, half-duplex for gigabit ethernet is a bad idea.&n;&t;&t;&t;0x00000080 : Force half-duplex &n;&t;&t;&t;Default is full-duplex.&n;&t;&t;- In the original driver, the ninth bit could be used to force&n;&t;&t;  full-duplex.  Maintain that for compatibility&n;&t;&t;   0x00000200 : Force full-duplex&n;*/
DECL|macro|MAX_UNITS
mdefine_line|#define MAX_UNITS 8&t;&t;&t;&t;/* More are supported, limit only on options */
DECL|variable|options
r_static
r_int
id|options
(braket
id|MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|full_duplex
r_static
r_int
id|full_duplex
(braket
id|MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/* The Hamachi chipset supports 3 parameters each for Rx and Tx&n; * interruput management.  Parameters will be loaded as specified into&n; * the TxIntControl and RxIntControl registers.  &n; *&n; * The registers are arranged as follows:&n; *     23 - 16   15 -  8   7    -    0&n; *    _________________________________&n; *   | min_pkt | max_gap | max_latency |&n; *    ---------------------------------&n; *   min_pkt      : The minimum number of packets processed between&n; *                  interrupts. &n; *   max_gap      : The maximum inter-packet gap in units of 8.192 us&n; *   max_latency  : The absolute time between interrupts in units of 8.192 us&n; * &n; */
DECL|variable|rx_params
r_static
r_int
id|rx_params
(braket
id|MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|tx_params
r_static
r_int
id|tx_params
(braket
id|MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Operational parameters that are set at compile time. */
multiline_comment|/* Keep the ring sizes a power of two for compile efficiency.&n;&t;The compiler will convert &lt;unsigned&gt;&squot;%&squot;&lt;2^N&gt; into a bit mask.&n;   Making the Tx ring too large decreases the effectiveness of channel&n;   bonding and packet priority.&n;   There are no ill effects from too-large receive rings, except for&n;&t;excessive memory usage */
multiline_comment|/* Empirically it appears that the Tx ring needs to be a little bigger&n;   for these Gbit adapters or you get into an overrun condition really&n;   easily.  Also, things appear to work a bit better in back-to-back&n;   configurations if the Rx ring is 8 times the size of the Tx ring&n;*/
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE&t;64
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;512
multiline_comment|/*&n; * Enable mii_ioctl.  Added interrupt coalescing parameter adjustment.&n; * 2/19/99 Pete Wyckoff &lt;wyckoff@ca.sandia.gov&gt;&n; */
DECL|macro|HAVE_PRIVATE_IOCTL
mdefine_line|#define HAVE_PRIVATE_IOCTL
multiline_comment|/* play with 64-bit addrlen; seems to be a teensy bit slower  --pw */
multiline_comment|/* #define ADDRLEN 64 */
multiline_comment|/*&n; * RX_CHECKSUM turns on card-generated receive checksum generation for&n; *   TCP and UDP packets.  Otherwise the upper layers do the calculation.&n; * TX_CHECKSUM won&squot;t do anything too useful, even if it works.  There&squot;s no&n; *   easy mechanism by which to tell the TCP/UDP stack that it need not&n; *   generate checksums for this device.  But if somebody can find a way&n; *   to get that to work, most of the card work is in here already.&n; * 3/10/1999 Pete Wyckoff &lt;wyckoff@ca.sandia.gov&gt;&n; */
DECL|macro|TX_CHECKSUM
macro_line|#undef  TX_CHECKSUM
DECL|macro|RX_CHECKSUM
mdefine_line|#define RX_CHECKSUM
multiline_comment|/* Operational parameters that usually are not changed. */
multiline_comment|/* Time in jiffies before concluding the transmitter is hung. */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT  (5*HZ)
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/processor.h&gt;&t;/* Processor type for cache alignment. */
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
multiline_comment|/* IP_MF appears to be only defined in &lt;netinet/ip.h&gt;, however,&n;   we need it for hardware checksumming support.  FYI... some of&n;   the definitions in &lt;netinet/ip.h&gt; conflict/duplicate those in&n;   other linux headers causing many compiler warnings.&n;*/
macro_line|#ifndef IP_MF
DECL|macro|IP_MF
mdefine_line|#define IP_MF 0x2000   /* IP more frags from &lt;netinet/ip.h&gt; */ 
macro_line|#endif
multiline_comment|/* Define IP_OFFSET to be IPOPT_OFFSET */
macro_line|#ifndef IP_OFFSET
macro_line|#ifdef IPOPT_OFFSET
DECL|macro|IP_OFFSET
mdefine_line|#define IP_OFFSET IPOPT_OFFSET
macro_line|#else
DECL|macro|IP_OFFSET
mdefine_line|#define IP_OFFSET 2
macro_line|#endif
macro_line|#endif
DECL|macro|RUN_AT
mdefine_line|#define RUN_AT(x) (jiffies + (x))
multiline_comment|/* Condensed bus+endian portability operations. */
macro_line|#if ADDRLEN == 64
DECL|macro|virt_to_desc
mdefine_line|#define virt_to_desc(addr)  cpu_to_le64(virt_to_bus(addr))
macro_line|#else 
DECL|macro|virt_to_desc
mdefine_line|#define virt_to_desc(addr)  cpu_to_le32(virt_to_bus(addr))
DECL|macro|le32desc_to_virt
mdefine_line|#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
macro_line|#endif   
multiline_comment|/*&n;&t;&t;&t;&t;Theory of Operation&n;&n;I. Board Compatibility&n;&n;This device driver is designed for the Packet Engines &quot;Hamachi&quot;&n;Gigabit Ethernet chip.  The only PCA currently supported is the GNIC-II 64-bit&n;66Mhz PCI card.&n;&n;II. Board-specific settings&n;&n;No jumpers exist on the board.  The chip supports software correction of&n;various motherboard wiring errors, however this driver does not support&n;that feature.&n;&n;III. Driver operation&n;&n;IIIa. Ring buffers&n;&n;The Hamachi uses a typical descriptor based bus-master architecture.&n;The descriptor list is similar to that used by the Digital Tulip.&n;This driver uses two statically allocated fixed-size descriptor lists&n;formed into rings by a branch from the final descriptor to the beginning of&n;the list.  The ring sizes are set at compile time by RX/TX_RING_SIZE.&n;&n;This driver uses a zero-copy receive and transmit scheme similar my other&n;network drivers.&n;The driver allocates full frame size skbuffs for the Rx ring buffers at&n;open() time and passes the skb-&gt;data field to the Hamachi as receive data&n;buffers.  When an incoming frame is less than RX_COPYBREAK bytes long,&n;a fresh skbuff is allocated and the frame is copied to the new skbuff.&n;When the incoming frame is larger, the skbuff is passed directly up the&n;protocol stack and replaced by a newly allocated skbuff.&n;&n;The RX_COPYBREAK value is chosen to trade-off the memory wasted by&n;using a full-sized skbuff for small frames vs. the copying costs of larger&n;frames.  Gigabit cards are typically used on generously configured machines&n;and the underfilled buffers have negligible impact compared to the benefit of&n;a single allocation size, so the default value of zero results in never&n;copying packets.&n;&n;IIIb/c. Transmit/Receive Structure&n;&n;The Rx and Tx descriptor structure are straight-forward, with no historical&n;baggage that must be explained.  Unlike the awkward DBDMA structure, there&n;are no unused fields or option bits that had only one allowable setting.&n;&n;Two details should be noted about the descriptors: The chip supports both 32&n;bit and 64 bit address structures, and the length field is overwritten on&n;the receive descriptors.  The descriptor length is set in the control word&n;for each channel. The development driver uses 32 bit addresses only, however&n;64 bit addresses may be enabled for 64 bit architectures e.g. the Alpha.&n;&n;IIId. Synchronization&n;&n;This driver is very similar to my other network drivers.&n;The driver runs as two independent, single-threaded flows of control.  One&n;is the send-packet routine, which enforces single-threaded use by the&n;dev-&gt;tbusy flag.  The other thread is the interrupt handler, which is single&n;threaded by the hardware and other software.&n;&n;The send packet thread has partial control over the Tx ring and &squot;dev-&gt;tbusy&squot;&n;flag.  It sets the tbusy flag whenever it&squot;s queuing a Tx packet. If the next&n;queue slot is empty, it clears the tbusy flag when finished otherwise it sets&n;the &squot;hmp-&gt;tx_full&squot; flag.&n;&n;The interrupt handler has exclusive control over the Rx ring and records stats&n;from the Tx ring.  After reaping the stats, it marks the Tx queue entry as&n;empty by incrementing the dirty_tx mark. Iff the &squot;hmp-&gt;tx_full&squot; flag is set, it&n;clears both the tx_full and tbusy flags.&n;&n;IV. Notes&n;&n;Thanks to Kim Stearns of Packet Engines for providing a pair of GNIC-II boards.&n;&n;IVb. References&n;&n;Hamachi Engineering Design Specification, 5/15/97&n;(Note: This version was marked &quot;Confidential&quot;.)&n;&n;IVc. Errata&n;&n;None noted.  &n;&n;V.  Recent Changes&n;&n;01/15/1999 EPK  Enlargement of the TX and RX ring sizes.  This appears &n;    to help avoid some stall conditions -- this needs further research.&n;&n;01/15/1999 EPK  Creation of the hamachi_tx function.  This function cleans &n;    the Tx ring and is called from hamachi_start_xmit (this used to be&n;    called from hamachi_interrupt but it tends to delay execution of the&n;    interrupt handler and thus reduce bandwidth by reducing the latency&n;    between hamachi_rx()&squot;s).  Notably, some modification has been made so &n;    that the cleaning loop checks only to make sure that the DescOwn bit &n;    isn&squot;t set in the status flag since the card is not required &n;    to set the entire flag to zero after processing.&n;&n;01/15/1999 EPK In the hamachi_start_tx function, the Tx ring full flag is &n;    checked before attempting to add a buffer to the ring.  If the ring is full&n;    an attempt is made to free any dirty buffers and thus find space for&n;    the new buffer or the function returns non-zero which should case the&n;    scheduler to reschedule the buffer later.&n;&n;01/15/1999 EPK Some adjustments were made to the chip intialization.  &n;    End-to-end flow control should now be fully active and the interrupt &n;    algorithm vars have been changed.  These could probably use further tuning.&n;&n;01/15/1999 EPK Added the max_{rx,tx}_latency options.  These are used to&n;    set the rx and tx latencies for the Hamachi interrupts. If you&squot;re having&n;    problems with network stalls, try setting these to higher values.&n;    Valid values are 0x00 through 0xff.&n;&n;01/15/1999 EPK In general, the overall bandwidth has increased and &n;    latencies are better (sometimes by a factor of 2).  Stalls are rare at&n;    this point, however there still appears to be a bug somewhere between the&n;    hardware and driver.  TCP checksum errors under load also appear to be&n;    eliminated at this point.&n;&n;01/18/1999 EPK Ensured that the DescEndRing bit was being set on both the&n;    Rx and Tx rings.  This appears to have been affecting whether a particular&n;    peer-to-peer connection would hang under high load.  I believe the Rx&n;    rings was typically getting set correctly, but the Tx ring wasn&squot;t getting&n;    the DescEndRing bit set during initialization. ??? Does this mean the&n;    hamachi card is using the DescEndRing in processing even if a particular&n;    slot isn&squot;t in use -- hypothetically, the card might be searching the &n;    entire Tx ring for slots with the DescOwn bit set and then processing&n;    them.  If the DescEndRing bit isn&squot;t set, then it might just wander off&n;    through memory until it hits a chunk of data with that bit set&n;    and then looping back.&n;&n;02/09/1999 EPK Added Michel Mueller&squot;s TxDMA Interrupt and Tx-timeout &n;    problem (TxCmd and RxCmd need only to be set when idle or stopped.&n;&n;02/09/1999 EPK Added code to check/reset dev-&gt;tbusy in hamachi_interrupt.&n;    (Michel Mueller pointed out the ``permanently busy&squot;&squot; potential &n;    problem here).&n;&n;02/22/1999 EPK Added Pete Wyckoff&squot;s ioctl to control the Tx/Rx latencies. &n;&n;02/23/1999 EPK Verified that the interrupt status field bits for Tx were&n;    incorrectly defined and corrected (as per Michel Mueller).&n;&n;02/23/1999 EPK Corrected the Tx full check to check that at least 4 slots&n;    were available before reseting the tbusy and tx_full flags&n;    (as per Michel Mueller).&n;&n;03/11/1999 EPK Added Pete Wyckoff&squot;s hardware checksumming support.&n;&n;12/31/1999 KDU Cleaned up assorted things and added Don&squot;s code to force&n;32 bit.&n;&n;02/20/2000 KDU Some of the control was just plain odd.  Cleaned up the&n;hamachi_start_xmit() and hamachi_interrupt() code.  There is still some&n;re-structuring I would like to do.  &n;&n;03/01/2000 KDU Experimenting with a WIDE range of interrupt mitigation&n;parameters on a dual P3-450 setup yielded the new default interrupt&n;mitigation parameters.  Tx should interrupt VERY infrequently due to&n;Eric&squot;s scheme.  Rx should be more often...&n;&n;03/13/2000 KDU Added a patch to make the Rx Checksum code interact&n;nicely with non-linux machines.  &n;&n;03/13/2000 KDU Experimented with some of the configuration values:  &n;&n;&t;-It seems that enabling PCI performance commands for descriptors&n;&t;(changing RxDMACtrl and TxDMACtrl lower nibble from 5 to D) has minimal &n;&t;performance impact for any of my tests. (ttcp, netpipe, netperf)  I will &n;&t;leave them that way until I hear further feedback.&n;&n;&t;-Increasing the PCI_LATENCY_TIMER to 130 &n;&t;(2 + (burst size of 128 * (0 wait states + 1))) seems to slightly&n;&t;degrade performance.  Leaving default at 64 pending further information.&n;&n;03/14/2000 KDU Further tuning:  &n;&n;&t;-adjusted boguscnt in hamachi_rx() to depend on interrupt&n;&t;mitigation parameters chosen.&n;&n;&t;-Selected a set of interrupt parameters based on some extensive testing.  &n;&t;These may change with more testing.&n;&n;TO DO:&n;&n;-Consider borrowing from the acenic driver code to check PCI_COMMAND for&n;PCI_COMMAND_INVALIDATE.  Set maximum burst size to cache line size in&n;that case.&n;&n;-fix the reset procedure.  It doesn&squot;t quite work.  &n;*/
multiline_comment|/* A few values that may be tweaked. */
multiline_comment|/* Size of each temporary Rx buffer, calculated as:&n; * 1518 bytes (ethernet packet) + 2 bytes (to get 8 byte alignment for&n; * the card) + 8 bytes of status info + 8 bytes for the Rx Checksum +&n; * 2 more because we use skb_reserve.  &n; */
DECL|macro|PKT_BUF_SZ
mdefine_line|#define PKT_BUF_SZ&t;&t;1538
multiline_comment|/* For now, this is going to be set to the maximum size of an ethernet&n; * packet.  Eventually, we may want to make it a variable that is&n; * related to the MTU&n; */
DECL|macro|MAX_FRAME_SIZE
mdefine_line|#define MAX_FRAME_SIZE  1518
multiline_comment|/* The rest of these values should never change. */
r_static
r_void
id|hamachi_timer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
DECL|enum|capability_flags
DECL|enumerator|CanHaveMII
r_enum
id|capability_flags
(brace
id|CanHaveMII
op_assign
l_int|1
comma
)brace
suffix:semicolon
DECL|struct|chip_info
r_static
r_struct
id|chip_info
(brace
DECL|member|vendor_id
DECL|member|device_id
DECL|member|device_id_mask
DECL|member|pad
id|u16
id|vendor_id
comma
id|device_id
comma
id|device_id_mask
comma
id|pad
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|media_timer
r_void
(paren
op_star
id|media_timer
)paren
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|variable|chip_tbl
)brace
id|chip_tbl
(braket
)braket
op_assign
(brace
(brace
l_int|0x1318
comma
l_int|0x0911
comma
l_int|0xffff
comma
l_int|0
comma
l_string|&quot;Hamachi GNIC-II&quot;
comma
id|hamachi_timer
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Offsets to the Hamachi registers.  Various sizes. */
DECL|enum|hamachi_offsets
r_enum
id|hamachi_offsets
(brace
DECL|enumerator|TxDMACtrl
DECL|enumerator|TxCmd
DECL|enumerator|TxStatus
DECL|enumerator|TxPtr
DECL|enumerator|TxCurPtr
id|TxDMACtrl
op_assign
l_int|0x00
comma
id|TxCmd
op_assign
l_int|0x04
comma
id|TxStatus
op_assign
l_int|0x06
comma
id|TxPtr
op_assign
l_int|0x08
comma
id|TxCurPtr
op_assign
l_int|0x10
comma
DECL|enumerator|RxDMACtrl
DECL|enumerator|RxCmd
DECL|enumerator|RxStatus
DECL|enumerator|RxPtr
DECL|enumerator|RxCurPtr
id|RxDMACtrl
op_assign
l_int|0x20
comma
id|RxCmd
op_assign
l_int|0x24
comma
id|RxStatus
op_assign
l_int|0x26
comma
id|RxPtr
op_assign
l_int|0x28
comma
id|RxCurPtr
op_assign
l_int|0x30
comma
DECL|enumerator|PCIClkMeas
DECL|enumerator|MiscStatus
DECL|enumerator|ChipRev
DECL|enumerator|ChipReset
id|PCIClkMeas
op_assign
l_int|0x060
comma
id|MiscStatus
op_assign
l_int|0x066
comma
id|ChipRev
op_assign
l_int|0x68
comma
id|ChipReset
op_assign
l_int|0x06B
comma
DECL|enumerator|LEDCtrl
DECL|enumerator|VirtualJumpers
DECL|enumerator|GPIO
id|LEDCtrl
op_assign
l_int|0x06C
comma
id|VirtualJumpers
op_assign
l_int|0x06D
comma
id|GPIO
op_assign
l_int|0x6E
comma
DECL|enumerator|TxChecksum
DECL|enumerator|RxChecksum
id|TxChecksum
op_assign
l_int|0x074
comma
id|RxChecksum
op_assign
l_int|0x076
comma
DECL|enumerator|TxIntrCtrl
DECL|enumerator|RxIntrCtrl
id|TxIntrCtrl
op_assign
l_int|0x078
comma
id|RxIntrCtrl
op_assign
l_int|0x07C
comma
DECL|enumerator|InterruptEnable
DECL|enumerator|InterruptClear
DECL|enumerator|IntrStatus
id|InterruptEnable
op_assign
l_int|0x080
comma
id|InterruptClear
op_assign
l_int|0x084
comma
id|IntrStatus
op_assign
l_int|0x088
comma
DECL|enumerator|EventStatus
id|EventStatus
op_assign
l_int|0x08C
comma
DECL|enumerator|MACCnfg
DECL|enumerator|FrameGap0
DECL|enumerator|FrameGap1
id|MACCnfg
op_assign
l_int|0x0A0
comma
id|FrameGap0
op_assign
l_int|0x0A2
comma
id|FrameGap1
op_assign
l_int|0x0A4
comma
multiline_comment|/* See enum MII_offsets below. */
DECL|enumerator|MACCnfg2
DECL|enumerator|RxDepth
DECL|enumerator|FlowCtrl
DECL|enumerator|MaxFrameSize
id|MACCnfg2
op_assign
l_int|0x0B0
comma
id|RxDepth
op_assign
l_int|0x0B8
comma
id|FlowCtrl
op_assign
l_int|0x0BC
comma
id|MaxFrameSize
op_assign
l_int|0x0CE
comma
DECL|enumerator|AddrMode
DECL|enumerator|StationAddr
id|AddrMode
op_assign
l_int|0x0D0
comma
id|StationAddr
op_assign
l_int|0x0D2
comma
multiline_comment|/* Gigabit AutoNegotiation. */
DECL|enumerator|ANCtrl
DECL|enumerator|ANStatus
DECL|enumerator|ANXchngCtrl
DECL|enumerator|ANAdvertise
id|ANCtrl
op_assign
l_int|0x0E0
comma
id|ANStatus
op_assign
l_int|0x0E2
comma
id|ANXchngCtrl
op_assign
l_int|0x0E4
comma
id|ANAdvertise
op_assign
l_int|0x0E8
comma
DECL|enumerator|ANLinkPartnerAbility
id|ANLinkPartnerAbility
op_assign
l_int|0x0EA
comma
DECL|enumerator|EECmdStatus
DECL|enumerator|EEData
DECL|enumerator|EEAddr
id|EECmdStatus
op_assign
l_int|0x0F0
comma
id|EEData
op_assign
l_int|0x0F1
comma
id|EEAddr
op_assign
l_int|0x0F2
comma
DECL|enumerator|FIFOcfg
id|FIFOcfg
op_assign
l_int|0x0F8
comma
)brace
suffix:semicolon
multiline_comment|/* Offsets to the MII-mode registers. */
DECL|enum|MII_offsets
r_enum
id|MII_offsets
(brace
DECL|enumerator|MII_Cmd
DECL|enumerator|MII_Addr
DECL|enumerator|MII_Wr_Data
DECL|enumerator|MII_Rd_Data
id|MII_Cmd
op_assign
l_int|0xA6
comma
id|MII_Addr
op_assign
l_int|0xA8
comma
id|MII_Wr_Data
op_assign
l_int|0xAA
comma
id|MII_Rd_Data
op_assign
l_int|0xAC
comma
DECL|enumerator|MII_Status
id|MII_Status
op_assign
l_int|0xAE
comma
)brace
suffix:semicolon
multiline_comment|/* Bits in the interrupt status/mask registers. */
DECL|enum|intr_status_bits
r_enum
id|intr_status_bits
(brace
DECL|enumerator|IntrRxDone
DECL|enumerator|IntrRxPCIFault
DECL|enumerator|IntrRxPCIErr
id|IntrRxDone
op_assign
l_int|0x01
comma
id|IntrRxPCIFault
op_assign
l_int|0x02
comma
id|IntrRxPCIErr
op_assign
l_int|0x04
comma
DECL|enumerator|IntrTxDone
DECL|enumerator|IntrTxPCIFault
DECL|enumerator|IntrTxPCIErr
id|IntrTxDone
op_assign
l_int|0x100
comma
id|IntrTxPCIFault
op_assign
l_int|0x200
comma
id|IntrTxPCIErr
op_assign
l_int|0x400
comma
DECL|enumerator|LinkChange
DECL|enumerator|NegotiationChange
DECL|enumerator|StatsMax
id|LinkChange
op_assign
l_int|0x10000
comma
id|NegotiationChange
op_assign
l_int|0x20000
comma
id|StatsMax
op_assign
l_int|0x40000
comma
)brace
suffix:semicolon
multiline_comment|/* The Hamachi Rx and Tx buffer descriptors. */
DECL|struct|hamachi_desc
r_struct
id|hamachi_desc
(brace
DECL|member|status_n_length
id|u32
id|status_n_length
suffix:semicolon
macro_line|#if ADDRLEN == 64
DECL|member|pad
id|u32
id|pad
suffix:semicolon
DECL|member|addr
id|u64
id|addr
suffix:semicolon
macro_line|#else
DECL|member|addr
id|u32
id|addr
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Bits in hamachi_desc.status_n_length */
DECL|enum|desc_status_bits
r_enum
id|desc_status_bits
(brace
DECL|enumerator|DescOwn
DECL|enumerator|DescEndPacket
DECL|enumerator|DescEndRing
id|DescOwn
op_assign
l_int|0x80000000
comma
id|DescEndPacket
op_assign
l_int|0x40000000
comma
id|DescEndRing
op_assign
l_int|0x20000000
comma
DECL|enumerator|DescIntr
id|DescIntr
op_assign
l_int|0x10000000
comma
)brace
suffix:semicolon
DECL|macro|PRIV_ALIGN
mdefine_line|#define PRIV_ALIGN   15    &t;&t;&t;&t;/* Required alignment mask */
DECL|struct|hamachi_private
r_struct
id|hamachi_private
(brace
multiline_comment|/* Descriptor rings first for alignment.  Tx requires a second descriptor&n;&t;   for status. */
DECL|member|rx_ring
r_struct
id|hamachi_desc
id|rx_ring
(braket
id|RX_RING_SIZE
)braket
suffix:semicolon
DECL|member|tx_ring
r_struct
id|hamachi_desc
id|tx_ring
(braket
id|TX_RING_SIZE
)braket
suffix:semicolon
multiline_comment|/* The addresses of receive-in-place skbuffs. */
DECL|member|rx_skbuff
r_struct
id|sk_buff
op_star
id|rx_skbuff
(braket
id|RX_RING_SIZE
)braket
suffix:semicolon
multiline_comment|/* The saved address of a sent-in-place packet/buffer, for skfree(). */
DECL|member|tx_skbuff
r_struct
id|sk_buff
op_star
id|tx_skbuff
(braket
id|TX_RING_SIZE
)braket
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Media selection timer. */
multiline_comment|/* Frequently used and paired value: keep adjacent for cache effect. */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|chip_id
r_int
id|chip_id
suffix:semicolon
DECL|member|rx_head_desc
r_struct
id|hamachi_desc
op_star
id|rx_head_desc
suffix:semicolon
DECL|member|cur_rx
DECL|member|dirty_rx
r_int
r_int
id|cur_rx
comma
id|dirty_rx
suffix:semicolon
multiline_comment|/* Producer/consumer ring indices */
DECL|member|cur_tx
DECL|member|dirty_tx
r_int
r_int
id|cur_tx
comma
id|dirty_tx
suffix:semicolon
DECL|member|rx_buf_sz
r_int
r_int
id|rx_buf_sz
suffix:semicolon
multiline_comment|/* Based on MTU+slack. */
DECL|member|tx_full
r_int
r_int
id|tx_full
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The Tx queue is full. */
DECL|member|full_duplex
r_int
r_int
id|full_duplex
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Full-duplex operation requested. */
DECL|member|duplex_lock
r_int
r_int
id|duplex_lock
suffix:colon
l_int|1
suffix:semicolon
DECL|member|medialock
r_int
r_int
id|medialock
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Do not sense media. */
DECL|member|default_port
r_int
r_int
id|default_port
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Last dev-&gt;if_port value. */
multiline_comment|/* MII transceiver section. */
DECL|member|mii_cnt
r_int
id|mii_cnt
suffix:semicolon
multiline_comment|/* MII device addresses. */
DECL|member|advertising
id|u16
id|advertising
suffix:semicolon
multiline_comment|/* NWay media advertisement */
DECL|member|phys
r_int
r_char
id|phys
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* MII device addresses. */
DECL|member|rx_int_var
DECL|member|tx_int_var
id|u_int32_t
id|rx_int_var
comma
id|tx_int_var
suffix:semicolon
multiline_comment|/* interrupt control variables */
DECL|member|option
id|u_int32_t
id|option
suffix:semicolon
multiline_comment|/* Hold on to a copy of the options */
DECL|member|pad
id|u_int8_t
id|pad
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Used for 32-byte alignment */
)brace
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Donald Becker &lt;becker@scyld.com&gt;, Eric Kasten &lt;kasten@nscl.msu.edu&gt;, Keith Underwood &lt;keithu@parl.clemson.edu&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Packet Engines &squot;Hamachi&squot; GNIC-II Gigabit Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_interrupt_work
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mtu
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|min_rx_pkt
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_rx_gap
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_rx_latency
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|min_tx_pkt
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_tx_gap
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_tx_latency
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rx_copybreak
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rx_params
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tx_params
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|options
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|full_duplex
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|force32
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
suffix:semicolon
r_static
r_int
id|mdio_read
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|phy_id
comma
r_int
id|location
)paren
suffix:semicolon
r_static
r_void
id|mdio_write
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|phy_id
comma
r_int
id|location
comma
r_int
id|value
)paren
suffix:semicolon
r_static
r_int
id|hamachi_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef HAVE_PRIVATE_IOCTL
r_static
r_int
id|mii_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|hamachi_timer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|hamachi_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hamachi_init_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|hamachi_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hamachi_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_inline
r_int
id|hamachi_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_inline
r_int
id|hamachi_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hamachi_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|intr_status
)paren
suffix:semicolon
r_static
r_int
id|hamachi_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|hamachi_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|function|hamachi_init_one
r_static
r_int
id|__init
id|hamachi_init_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_static
r_int
id|did_version
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Already printed version info. */
r_struct
id|hamachi_private
op_star
id|hmp
suffix:semicolon
r_int
id|option
comma
id|i
comma
id|rx_int_var
comma
id|tx_int_var
comma
id|boguscnt
suffix:semicolon
r_int
id|chip_id
op_assign
id|ent-&gt;driver_data
suffix:semicolon
r_int
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_int
id|ioaddr
suffix:semicolon
r_static
r_int
id|card_idx
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|0
op_logical_and
id|did_version
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|ioaddr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef __alpha__&t;&t;&t;&t;/* Really &quot;64 bit addrs&quot; */
id|ioaddr
op_or_assign
(paren
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|1
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|ioaddr
op_assign
(paren
r_int
)paren
id|ioremap
c_func
(paren
id|ioaddr
comma
l_int|0x400
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|hamachi_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_char
op_star
)paren
id|ioaddr
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef TX_CHECKSUM
id|printk
c_func
(paren
l_string|&quot;check that skbcopy in ip_queue_xmit isn&squot;t happening&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;hard_header_len
op_add_assign
l_int|8
suffix:semicolon
multiline_comment|/* for cksum tag */
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s type %x at 0x%lx, &quot;
comma
id|dev-&gt;name
comma
id|chip_tbl
(braket
id|chip_id
)braket
dot
id|name
comma
id|readl
c_func
(paren
id|ioaddr
op_plus
id|ChipRev
)paren
comma
id|ioaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
l_int|1
ques
c_cond
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
op_plus
id|i
)paren
suffix:colon
id|readb
c_func
(paren
id|ioaddr
op_plus
id|StationAddr
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%2.2x, IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|irq
)paren
suffix:semicolon
macro_line|#if ! defined(final_version)
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|4
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x10
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x%s&quot;
comma
id|read_eeprom
c_func
(paren
id|ioaddr
comma
id|i
)paren
comma
id|i
op_mod
l_int|16
op_ne
l_int|15
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0 /* Moving this until after the force 32 check and reset. */
id|i
op_assign
id|readb
c_func
(paren
id|ioaddr
op_plus
id|PCIClkMeas
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s:  %d-bit %d Mhz PCI bus (%d), Virtual Jumpers &quot;
l_string|&quot;%2.2x, LPA %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MiscStatus
)paren
op_amp
l_int|1
ques
c_cond
l_int|64
suffix:colon
l_int|32
comma
id|i
ques
c_cond
l_int|2000
op_div
(paren
id|i
op_amp
l_int|0x7f
)paren
suffix:colon
l_int|0
comma
id|i
op_amp
l_int|0x7f
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|ioaddr
op_plus
id|VirtualJumpers
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|ANLinkPartnerAbility
)paren
)paren
suffix:semicolon
macro_line|#endif
id|hmp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hmp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Check for options being passed in */
id|option
op_assign
id|card_idx
OL
id|MAX_UNITS
ques
c_cond
id|options
(braket
id|card_idx
)braket
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mem_start
)paren
id|option
op_assign
id|dev-&gt;mem_start
suffix:semicolon
multiline_comment|/* If the bus size is misidentified, do the following. */
id|force32
op_assign
id|force32
ques
c_cond
id|force32
suffix:colon
(paren
(paren
id|option
op_ge
l_int|0
)paren
ques
c_cond
(paren
(paren
id|option
op_amp
l_int|0x00000070
)paren
op_rshift
l_int|4
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|force32
)paren
id|writeb
c_func
(paren
id|force32
comma
id|ioaddr
op_plus
id|VirtualJumpers
)paren
suffix:semicolon
multiline_comment|/* Hmmm, do we really need to reset the chip???. */
id|writeb
c_func
(paren
l_int|0x01
comma
id|ioaddr
op_plus
id|ChipReset
)paren
suffix:semicolon
multiline_comment|/* After a reset, the clock speed measurement of the PCI bus will not&n;&t; * be valid for a moment.  Wait for a little while until it is.  If&n;&t; * it takes more than 10ms, forget it.&n;&t; */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|i
op_assign
id|readb
c_func
(paren
id|ioaddr
op_plus
id|PCIClkMeas
)paren
suffix:semicolon
r_for
c_loop
(paren
id|boguscnt
op_assign
l_int|0
suffix:semicolon
(paren
op_logical_neg
(paren
id|i
op_amp
l_int|0x080
)paren
)paren
op_logical_and
id|boguscnt
OL
l_int|1000
suffix:semicolon
id|boguscnt
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|i
op_assign
id|readb
c_func
(paren
id|ioaddr
op_plus
id|PCIClkMeas
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s:  %d-bit %d Mhz PCI bus (%d), Virtual Jumpers &quot;
l_string|&quot;%2.2x, LPA %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MiscStatus
)paren
op_amp
l_int|1
ques
c_cond
l_int|64
suffix:colon
l_int|32
comma
id|i
ques
c_cond
l_int|2000
op_div
(paren
id|i
op_amp
l_int|0x7f
)paren
suffix:colon
l_int|0
comma
id|i
op_amp
l_int|0x7f
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|ioaddr
op_plus
id|VirtualJumpers
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|ANLinkPartnerAbility
)paren
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|hmp-&gt;chip_id
op_assign
id|chip_id
suffix:semicolon
multiline_comment|/* The lower four bits are the media type. */
r_if
c_cond
(paren
id|option
OG
l_int|0
)paren
(brace
id|hmp-&gt;option
op_assign
id|option
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x200
)paren
id|hmp-&gt;full_duplex
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|option
op_amp
l_int|0x080
)paren
id|hmp-&gt;full_duplex
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;default_port
op_assign
id|option
op_amp
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|hmp-&gt;default_port
)paren
id|hmp-&gt;medialock
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card_idx
template_param
l_int|0
)paren
id|hmp-&gt;full_duplex
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* lock the duplex mode if someone specified a value */
r_if
c_cond
(paren
id|hmp-&gt;full_duplex
op_logical_or
(paren
id|option
op_amp
l_int|0x080
)paren
)paren
id|hmp-&gt;duplex_lock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set interrupt tuning parameters */
id|max_rx_latency
op_assign
id|max_rx_latency
op_amp
l_int|0x00ff
suffix:semicolon
id|max_rx_gap
op_assign
id|max_rx_gap
op_amp
l_int|0x00ff
suffix:semicolon
id|min_rx_pkt
op_assign
id|min_rx_pkt
op_amp
l_int|0x00ff
suffix:semicolon
id|max_tx_latency
op_assign
id|max_tx_latency
op_amp
l_int|0x00ff
suffix:semicolon
id|max_tx_gap
op_assign
id|max_tx_gap
op_amp
l_int|0x00ff
suffix:semicolon
id|min_tx_pkt
op_assign
id|min_tx_pkt
op_amp
l_int|0x00ff
suffix:semicolon
id|rx_int_var
op_assign
id|card_idx
OL
id|MAX_UNITS
ques
c_cond
id|rx_params
(braket
id|card_idx
)braket
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|tx_int_var
op_assign
id|card_idx
OL
id|MAX_UNITS
ques
c_cond
id|tx_params
(braket
id|card_idx
)braket
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|hmp-&gt;rx_int_var
op_assign
id|rx_int_var
op_ge
l_int|0
ques
c_cond
id|rx_int_var
suffix:colon
(paren
id|min_rx_pkt
op_lshift
l_int|16
op_or
id|max_rx_gap
op_lshift
l_int|8
op_or
id|max_rx_latency
)paren
suffix:semicolon
id|hmp-&gt;tx_int_var
op_assign
id|tx_int_var
op_ge
l_int|0
ques
c_cond
id|tx_int_var
suffix:colon
(paren
id|min_tx_pkt
op_lshift
l_int|16
op_or
id|max_tx_gap
op_lshift
l_int|8
op_or
id|max_tx_latency
)paren
suffix:semicolon
multiline_comment|/* The Hamachi-specific entries in the device structure. */
id|dev-&gt;open
op_assign
op_amp
id|hamachi_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|hamachi_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|hamachi_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|hamachi_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_rx_mode
suffix:semicolon
macro_line|#ifdef HAVE_PRIVATE_IOCTL
id|dev-&gt;do_ioctl
op_assign
op_amp
id|mii_ioctl
suffix:semicolon
macro_line|#endif
id|dev-&gt;tx_timeout
op_assign
op_amp
id|hamachi_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|mtu
)paren
id|dev-&gt;mtu
op_assign
id|mtu
suffix:semicolon
r_if
c_cond
(paren
id|chip_tbl
(braket
id|hmp-&gt;chip_id
)braket
dot
id|flags
op_amp
id|CanHaveMII
)paren
(brace
r_int
id|phy
comma
id|phy_idx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|phy
op_assign
l_int|0
suffix:semicolon
id|phy
OL
l_int|32
op_logical_and
id|phy_idx
OL
l_int|4
suffix:semicolon
id|phy
op_increment
)paren
(brace
r_int
id|mii_status
op_assign
id|mdio_read
c_func
(paren
id|ioaddr
comma
id|phy
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_status
op_ne
l_int|0xffff
op_logical_and
id|mii_status
op_ne
l_int|0x0000
)paren
(brace
id|hmp-&gt;phys
(braket
id|phy_idx
op_increment
)braket
op_assign
id|phy
suffix:semicolon
id|hmp-&gt;advertising
op_assign
id|mdio_read
c_func
(paren
id|ioaddr
comma
id|phy
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: MII PHY found at address %d, status &quot;
l_string|&quot;0x%4.4x advertising %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy
comma
id|mii_status
comma
id|hmp-&gt;advertising
)paren
suffix:semicolon
)brace
)brace
id|hmp-&gt;mii_cnt
op_assign
id|phy_idx
suffix:semicolon
)brace
multiline_comment|/* Configure gigabit autonegotiation. */
id|writew
c_func
(paren
l_int|0x0400
comma
id|ioaddr
op_plus
id|ANXchngCtrl
)paren
suffix:semicolon
multiline_comment|/* Enable legacy links. */
id|writew
c_func
(paren
l_int|0x08e0
comma
id|ioaddr
op_plus
id|ANAdvertise
)paren
suffix:semicolon
multiline_comment|/* Set our advertise word. */
id|writew
c_func
(paren
l_int|0x1000
comma
id|ioaddr
op_plus
id|ANCtrl
)paren
suffix:semicolon
multiline_comment|/* Enable negotiation */
id|card_idx
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_eeprom
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
(brace
r_int
id|bogus_cnt
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* We should check busy first - per docs -KDU */
r_while
c_loop
(paren
(paren
id|readb
c_func
(paren
id|ioaddr
op_plus
id|EECmdStatus
)paren
op_amp
l_int|0x40
)paren
op_logical_and
op_decrement
id|bogus_cnt
OG
l_int|0
)paren
suffix:semicolon
id|writew
c_func
(paren
id|location
comma
id|ioaddr
op_plus
id|EEAddr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x02
comma
id|ioaddr
op_plus
id|EECmdStatus
)paren
suffix:semicolon
id|bogus_cnt
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readb
c_func
(paren
id|ioaddr
op_plus
id|EECmdStatus
)paren
op_amp
l_int|0x40
)paren
op_logical_and
op_decrement
id|bogus_cnt
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;   EEPROM status is %2.2x after %d ticks.&bslash;n&quot;
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|ioaddr
op_plus
id|EECmdStatus
)paren
comma
l_int|1000
op_minus
id|bogus_cnt
)paren
suffix:semicolon
r_return
id|readb
c_func
(paren
id|ioaddr
op_plus
id|EEData
)paren
suffix:semicolon
)brace
multiline_comment|/* MII Managemen Data I/O accesses.&n;   These routines assume the MDIO controller is idle, and do not exit until&n;   the command is finished. */
DECL|function|mdio_read
r_static
r_int
id|mdio_read
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|phy_id
comma
r_int
id|location
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* We should check busy first - per docs -KDU */
r_for
c_loop
(paren
id|i
op_assign
l_int|10000
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MII_Status
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|writew
c_func
(paren
(paren
id|phy_id
op_lshift
l_int|8
)paren
op_plus
id|location
comma
id|ioaddr
op_plus
id|MII_Addr
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
id|MII_Cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|10000
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MII_Status
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_return
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MII_Rd_Data
)paren
suffix:semicolon
)brace
DECL|function|mdio_write
r_static
r_void
id|mdio_write
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|phy_id
comma
r_int
id|location
comma
r_int
id|value
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* We should check busy first - per docs -KDU */
r_for
c_loop
(paren
id|i
op_assign
l_int|10000
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MII_Status
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|writew
c_func
(paren
(paren
id|phy_id
op_lshift
l_int|8
)paren
op_plus
id|location
comma
id|ioaddr
op_plus
id|MII_Addr
)paren
suffix:semicolon
id|writew
c_func
(paren
id|value
comma
id|ioaddr
op_plus
id|MII_Wr_Data
)paren
suffix:semicolon
multiline_comment|/* Wait for the command to finish. */
r_for
c_loop
(paren
id|i
op_assign
l_int|10000
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|MII_Status
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_return
suffix:semicolon
)brace
"&f;"
DECL|function|hamachi_open
r_static
r_int
id|hamachi_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u_int32_t
id|rx_int_var
comma
id|tx_int_var
suffix:semicolon
id|u_int16_t
id|fifo_info
suffix:semicolon
id|i
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|hamachi_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: hamachi_open() irq %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|hamachi_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#if ADDRLEN == 64
id|writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;rx_ring
)paren
comma
id|ioaddr
op_plus
id|RxPtr
)paren
suffix:semicolon
id|writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;rx_ring
)paren
op_rshift
l_int|32
comma
id|ioaddr
op_plus
id|RxPtr
op_plus
l_int|4
)paren
suffix:semicolon
id|writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;tx_ring
)paren
comma
id|ioaddr
op_plus
id|TxPtr
)paren
suffix:semicolon
id|writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;tx_ring
)paren
op_rshift
l_int|32
comma
id|ioaddr
op_plus
id|TxPtr
op_plus
l_int|4
)paren
suffix:semicolon
macro_line|#else
id|writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;rx_ring
)paren
comma
id|ioaddr
op_plus
id|RxPtr
)paren
suffix:semicolon
id|writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;tx_ring
)paren
comma
id|ioaddr
op_plus
id|TxPtr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* TODO:  It would make sense to organize this as words since the card &n;&t; * documentation does. -KDU&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|writeb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|StationAddr
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Initialize other registers: with so many this eventually this will&n;&t;   converted to an offset/value list. */
multiline_comment|/* Configure the FIFO */
id|fifo_info
op_assign
(paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|GPIO
)paren
op_amp
l_int|0x00C0
)paren
op_rshift
l_int|6
suffix:semicolon
r_switch
c_cond
(paren
id|fifo_info
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* No FIFO */
id|writew
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
id|FIFOcfg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* Configure the FIFO for 512K external, 16K used for Tx. */
id|writew
c_func
(paren
l_int|0x0028
comma
id|ioaddr
op_plus
id|FIFOcfg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Configure the FIFO for 1024 external, 32K used for Tx. */
id|writew
c_func
(paren
l_int|0x004C
comma
id|ioaddr
op_plus
id|FIFOcfg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Configure the FIFO for 2048 external, 32K used for Tx. */
id|writew
c_func
(paren
l_int|0x006C
comma
id|ioaddr
op_plus
id|FIFOcfg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s:  Unsupported external memory config!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Default to no FIFO */
id|writew
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
id|FIFOcfg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|0
)paren
id|dev-&gt;if_port
op_assign
id|hmp-&gt;default_port
suffix:semicolon
multiline_comment|/* Setting the Rx mode will start the Rx process. */
multiline_comment|/* If someone didn&squot;t choose a duplex, default to full-duplex */
r_if
c_cond
(paren
id|hmp-&gt;duplex_lock
op_ne
l_int|1
)paren
id|hmp-&gt;full_duplex
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* always 1, takes no more time to do it */
id|writew
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
id|RxChecksum
)paren
suffix:semicolon
macro_line|#ifdef TX_CHECKSUM
id|writew
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
id|TxChecksum
)paren
suffix:semicolon
macro_line|#else
id|writew
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
id|TxChecksum
)paren
suffix:semicolon
macro_line|#endif
id|writew
c_func
(paren
l_int|0x8000
comma
id|ioaddr
op_plus
id|MACCnfg
)paren
suffix:semicolon
multiline_comment|/* Soft reset the MAC */
id|writew
c_func
(paren
l_int|0x215F
comma
id|ioaddr
op_plus
id|MACCnfg
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x000C
comma
id|ioaddr
op_plus
id|FrameGap0
)paren
suffix:semicolon
multiline_comment|/* WHAT?!?!?  Why isn&squot;t this documented somewhere? -KDU */
id|writew
c_func
(paren
l_int|0x1018
comma
id|ioaddr
op_plus
id|FrameGap1
)paren
suffix:semicolon
multiline_comment|/* Why do we enable receives/transmits here? -KDU */
id|writew
c_func
(paren
l_int|0x0780
comma
id|ioaddr
op_plus
id|MACCnfg2
)paren
suffix:semicolon
multiline_comment|/* Upper 16 bits control LEDs. */
multiline_comment|/* Enable automatic generation of flow control frames, period 0xffff. */
id|writel
c_func
(paren
l_int|0x0030FFFF
comma
id|ioaddr
op_plus
id|FlowCtrl
)paren
suffix:semicolon
id|writew
c_func
(paren
id|MAX_FRAME_SIZE
comma
id|ioaddr
op_plus
id|MaxFrameSize
)paren
suffix:semicolon
multiline_comment|/* dev-&gt;mtu+14 ??? */
multiline_comment|/* Enable legacy links. */
id|writew
c_func
(paren
l_int|0x0400
comma
id|ioaddr
op_plus
id|ANXchngCtrl
)paren
suffix:semicolon
multiline_comment|/* Enable legacy links. */
multiline_comment|/* Initial Link LED to blinking red. */
id|writeb
c_func
(paren
l_int|0x03
comma
id|ioaddr
op_plus
id|LEDCtrl
)paren
suffix:semicolon
multiline_comment|/* Configure interrupt mitigation.  This has a great effect on&n;&t;   performance, so systems tuning should start here!. */
id|rx_int_var
op_assign
id|hmp-&gt;rx_int_var
suffix:semicolon
id|tx_int_var
op_assign
id|hmp-&gt;tx_int_var
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;max_tx_latency: %d, max_tx_gap: %d, min_tx_pkt: %d&bslash;n&quot;
comma
id|tx_int_var
op_amp
l_int|0x00ff
comma
(paren
id|tx_int_var
op_amp
l_int|0x00ff00
)paren
op_rshift
l_int|8
comma
(paren
id|tx_int_var
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;max_rx_latency: %d, max_rx_gap: %d, min_rx_pkt: %d&bslash;n&quot;
comma
id|rx_int_var
op_amp
l_int|0x00ff
comma
(paren
id|rx_int_var
op_amp
l_int|0x00ff00
)paren
op_rshift
l_int|8
comma
(paren
id|rx_int_var
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rx_int_var: %x, tx_int_var: %x&bslash;n&quot;
comma
id|rx_int_var
comma
id|tx_int_var
)paren
suffix:semicolon
)brace
id|writel
c_func
(paren
id|tx_int_var
comma
id|ioaddr
op_plus
id|TxIntrCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
id|rx_int_var
comma
id|ioaddr
op_plus
id|RxIntrCtrl
)paren
suffix:semicolon
id|set_rx_mode
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts by setting the interrupt mask. */
id|writel
c_func
(paren
l_int|0x80878787
comma
id|ioaddr
op_plus
id|InterruptEnable
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
id|EventStatus
)paren
suffix:semicolon
multiline_comment|/* Clear non-interrupting events */
multiline_comment|/* Configure and start the DMA channels. */
multiline_comment|/* Burst sizes are in the low three bits: size = 4&lt;&lt;(val&amp;7) */
macro_line|#if ADDRLEN == 64
id|writew
c_func
(paren
l_int|0x005D
comma
id|ioaddr
op_plus
id|RxDMACtrl
)paren
suffix:semicolon
multiline_comment|/* 128 dword bursts */
id|writew
c_func
(paren
l_int|0x005D
comma
id|ioaddr
op_plus
id|TxDMACtrl
)paren
suffix:semicolon
macro_line|#else
id|writew
c_func
(paren
l_int|0x001D
comma
id|ioaddr
op_plus
id|RxDMACtrl
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x001D
comma
id|ioaddr
op_plus
id|TxDMACtrl
)paren
suffix:semicolon
macro_line|#endif
id|writew
c_func
(paren
l_int|0x0001
comma
id|dev-&gt;base_addr
op_plus
id|RxCmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Done hamachi_open(), status: Rx %x Tx %x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|RxStatus
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|TxStatus
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the timer to check for link beat. */
id|init_timer
c_func
(paren
op_amp
id|hmp-&gt;timer
)paren
suffix:semicolon
id|hmp-&gt;timer.expires
op_assign
id|RUN_AT
c_func
(paren
(paren
l_int|24
op_star
id|HZ
)paren
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 2.4 sec. */
id|hmp-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|hmp-&gt;timer.function
op_assign
op_amp
id|hamachi_timer
suffix:semicolon
multiline_comment|/* timer handler */
id|add_timer
c_func
(paren
op_amp
id|hmp-&gt;timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hamachi_tx
r_static
r_inline
r_int
id|hamachi_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Update the dirty pointer until we find an entry that is&n;&t;&t;still owned by the card */
r_for
c_loop
(paren
suffix:semicolon
id|hmp-&gt;cur_tx
op_minus
id|hmp-&gt;dirty_tx
OG
l_int|0
suffix:semicolon
id|hmp-&gt;dirty_tx
op_increment
)paren
(brace
r_int
id|entry
op_assign
id|hmp-&gt;dirty_tx
op_mod
id|TX_RING_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_amp
id|cpu_to_le32
c_func
(paren
id|DescOwn
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Free the original skb. */
r_if
c_cond
(paren
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
op_ne
l_int|0
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
)paren
suffix:semicolon
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ge
id|TX_RING_SIZE
op_minus
l_int|1
)paren
id|hmp-&gt;tx_ring
(braket
id|TX_RING_SIZE
op_minus
l_int|1
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescEndRing
)paren
suffix:semicolon
id|hmp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hamachi_timer
r_static
r_void
id|hamachi_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|next_tick
op_assign
l_int|10
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Hamachi Autonegotiation status %4.4x, LPA &quot;
l_string|&quot;%4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|ANStatus
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|ANLinkPartnerAbility
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Autonegotiation regs %4.4x %4.4x %4.4x &quot;
l_string|&quot;%4.4x %4.4x %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0e0
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0e2
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0e4
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0e6
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0e8
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0eA
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We could do something here... nah. */
id|hmp-&gt;timer.expires
op_assign
id|RUN_AT
c_func
(paren
id|next_tick
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hmp-&gt;timer
)paren
suffix:semicolon
)brace
DECL|function|hamachi_tx_timeout
r_static
r_void
id|hamachi_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Hamachi transmit timed out, status %8.8x,&quot;
l_string|&quot; resetting...&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|TxStatus
)paren
)paren
suffix:semicolon
macro_line|#ifndef __alpha__
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  Rx ring %8.8x: &quot;
comma
(paren
r_int
)paren
id|hmp-&gt;rx_ring
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %8.8x&quot;
comma
(paren
r_int
r_int
)paren
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_DEBUG
l_string|&quot;  Tx ring %8.8x: &quot;
comma
(paren
r_int
)paren
id|hmp-&gt;tx_ring
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %4.4x&quot;
comma
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status_n_length
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Reinit the hardware and make sure the Rx and Tx processes &n;&t;&t;are up and running.&n;&t; */
id|dev-&gt;if_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The right way to do Reset. -KDU&n;&t; *&t;&t;-Clear OWN bit in all Rx/Tx descriptors&n;&t; *&t;&t;-Wait 50 uS for channels to go idle&n;&t; *&t;&t;-Turn off MAC receiver&n;&t; *&t;&t;-Issue Reset&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_and_assign
op_complement
id|DescOwn
suffix:semicolon
multiline_comment|/* Presume that all packets in the Tx queue are gone if we have to&n;&t; * re-init the hardware.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|TX_RING_SIZE
op_minus
l_int|1
)paren
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_assign
id|DescEndRing
op_or
(paren
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_amp
l_int|0x0000FFFF
)paren
suffix:semicolon
r_else
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_and_assign
l_int|0x0000ffff
suffix:semicolon
r_if
c_cond
(paren
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|udelay
c_func
(paren
l_int|60
)paren
suffix:semicolon
multiline_comment|/* Sleep 60 us just for safety sake */
id|writew
c_func
(paren
l_int|0x0002
comma
id|dev-&gt;base_addr
op_plus
id|RxCmd
)paren
suffix:semicolon
multiline_comment|/* STOP Rx */
id|writeb
c_func
(paren
l_int|0x01
comma
id|ioaddr
op_plus
id|ChipReset
)paren
suffix:semicolon
multiline_comment|/* Reinit the hardware */
id|hmp-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;cur_rx
op_assign
id|hmp-&gt;cur_tx
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;dirty_rx
op_assign
id|hmp-&gt;dirty_tx
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;rx_head_desc
op_assign
op_amp
id|hmp-&gt;rx_ring
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Rx packets are also presumed lost; however, we need to make sure a&n;&t; * ring of buffers is in tact. -KDU&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Fill in the Rx buffers.  Handle allocation failure gracefully. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|hmp-&gt;rx_buf_sz
)paren
suffix:semicolon
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Mark as being used by this device. */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 16 byte align the IP header. */
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|addr
op_assign
id|virt_to_desc
c_func
(paren
id|skb-&gt;tail
)paren
suffix:semicolon
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_assign
id|cpu_to_le32
c_func
(paren
id|DescOwn
op_or
id|DescEndPacket
op_or
id|DescIntr
op_or
(paren
id|hmp-&gt;rx_buf_sz
op_minus
l_int|2
)paren
)paren
suffix:semicolon
)brace
id|hmp-&gt;dirty_rx
op_assign
(paren
r_int
r_int
)paren
(paren
id|i
op_minus
id|RX_RING_SIZE
)paren
suffix:semicolon
multiline_comment|/* Mark the last entry as wrapping the ring. */
id|hmp-&gt;rx_ring
(braket
id|RX_RING_SIZE
op_minus
l_int|1
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescEndRing
)paren
suffix:semicolon
multiline_comment|/* Trigger an immediate transmit demand. */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|hmp-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* Restart the chip&squot;s Tx/Rx processes . */
id|writew
c_func
(paren
l_int|0x0002
comma
id|dev-&gt;base_addr
op_plus
id|TxCmd
)paren
suffix:semicolon
multiline_comment|/* STOP Tx */
id|writew
c_func
(paren
l_int|0x0001
comma
id|dev-&gt;base_addr
op_plus
id|TxCmd
)paren
suffix:semicolon
multiline_comment|/* START Tx */
id|writew
c_func
(paren
l_int|0x0001
comma
id|dev-&gt;base_addr
op_plus
id|RxCmd
)paren
suffix:semicolon
multiline_comment|/* START Rx */
)brace
multiline_comment|/* Initialize the Rx and Tx rings, along with various &squot;dev&squot; bits. */
DECL|function|hamachi_init_ring
r_static
r_void
id|hamachi_init_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|hmp-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;cur_rx
op_assign
id|hmp-&gt;cur_tx
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;dirty_rx
op_assign
id|hmp-&gt;dirty_tx
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This is wrong.  I&squot;m not sure what the original plan was, but this&n;&t; * is wrong.  An MTU of 1 gets you a buffer of 1536, while an MTU&n;&t; * of 1501 gets a buffer of 1533? -KDU&n;&t; */
id|hmp-&gt;rx_buf_sz
op_assign
(paren
id|dev-&gt;mtu
op_le
l_int|1500
ques
c_cond
id|PKT_BUF_SZ
suffix:colon
id|dev-&gt;mtu
op_plus
l_int|32
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* My attempt at a reasonable correction */
multiline_comment|/* +26 gets the maximum ethernet encapsulation, +7 &amp; ~7 because the&n;&t; * card needs room to do 8 byte alignment, +2 so we can reserve &n;&t; * the first 2 bytes, and +16 gets room for the status word from the &n;&t; * card.  -KDU&n;&t; */
id|hmp-&gt;rx_buf_sz
op_assign
(paren
id|dev-&gt;mtu
op_le
l_int|1492
ques
c_cond
id|PKT_BUF_SZ
suffix:colon
(paren
(paren
(paren
id|dev-&gt;mtu
op_plus
l_int|26
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
l_int|2
op_plus
l_int|16
)paren
)paren
suffix:semicolon
id|hmp-&gt;rx_head_desc
op_assign
op_amp
id|hmp-&gt;rx_ring
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Initialize all Rx descriptors. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fill in the Rx buffers.  Handle allocation failure gracefully. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|hmp-&gt;rx_buf_sz
)paren
suffix:semicolon
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Mark as being used by this device. */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 16 byte align the IP header. */
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|addr
op_assign
id|virt_to_desc
c_func
(paren
id|skb-&gt;tail
)paren
suffix:semicolon
multiline_comment|/* -2 because it doesn&squot;t REALLY have that first 2 bytes -KDU */
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_assign
id|cpu_to_le32
c_func
(paren
id|DescOwn
op_or
id|DescEndPacket
op_or
id|DescIntr
op_or
(paren
id|hmp-&gt;rx_buf_sz
op_minus
l_int|2
)paren
)paren
suffix:semicolon
)brace
id|hmp-&gt;dirty_rx
op_assign
(paren
r_int
r_int
)paren
(paren
id|i
op_minus
id|RX_RING_SIZE
)paren
suffix:semicolon
multiline_comment|/* Mark the last entry as wrapping the ring. */
id|hmp-&gt;rx_ring
(braket
id|RX_RING_SIZE
op_minus
l_int|1
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescEndRing
)paren
suffix:semicolon
multiline_comment|/* Mark the last entry as wrapping the ring. */
id|hmp-&gt;rx_ring
(braket
id|RX_RING_SIZE
op_minus
l_int|1
)braket
dot
id|status_n_length
op_or_assign
id|DescEndRing
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Mark the last entry as wrapping the ring. */
id|hmp-&gt;tx_ring
(braket
id|TX_RING_SIZE
op_minus
l_int|1
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescEndRing
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef TX_CHECKSUM
DECL|macro|csum_add
mdefine_line|#define csum_add(it, val) &bslash;&n;do { &bslash;&n;    it += (u16) (val); &bslash;&n;    if (it &amp; 0xffff0000) { &bslash;&n;&t;it &amp;= 0xffff; &bslash;&n;&t;++it; &bslash;&n;    } &bslash;&n;} while (0)
multiline_comment|/* printk(&quot;add %04x --&gt; %04x&bslash;n&quot;, val, it); &bslash; */
multiline_comment|/* uh-&gt;len already network format, do not swap */
DECL|macro|pseudo_csum_udp
mdefine_line|#define pseudo_csum_udp(sum,ih,uh) do { &bslash;&n;    sum = 0; &bslash;&n;    csum_add(sum, (ih)-&gt;saddr &gt;&gt; 16); &bslash;&n;    csum_add(sum, (ih)-&gt;saddr &amp; 0xffff); &bslash;&n;    csum_add(sum, (ih)-&gt;daddr &gt;&gt; 16); &bslash;&n;    csum_add(sum, (ih)-&gt;daddr &amp; 0xffff); &bslash;&n;    csum_add(sum, __constant_htons(IPPROTO_UDP)); &bslash;&n;    csum_add(sum, (uh)-&gt;len); &bslash;&n;} while (0)
multiline_comment|/* swap len */
DECL|macro|pseudo_csum_tcp
mdefine_line|#define pseudo_csum_tcp(sum,ih,len) do { &bslash;&n;    sum = 0; &bslash;&n;    csum_add(sum, (ih)-&gt;saddr &gt;&gt; 16); &bslash;&n;    csum_add(sum, (ih)-&gt;saddr &amp; 0xffff); &bslash;&n;    csum_add(sum, (ih)-&gt;daddr &gt;&gt; 16); &bslash;&n;    csum_add(sum, (ih)-&gt;daddr &amp; 0xffff); &bslash;&n;    csum_add(sum, __constant_htons(IPPROTO_TCP)); &bslash;&n;    csum_add(sum, htons(len)); &bslash;&n;} while (0)
macro_line|#endif
DECL|function|hamachi_start_xmit
r_static
r_int
id|hamachi_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|u16
id|status
suffix:semicolon
multiline_comment|/* Ok, now make sure that the queue has space before trying to &n;&t;&t;add another skbuff.  if we return non-zero the scheduler&n;&t;&t;should interpret this as a queue full and requeue the buffer&n;&t;&t;for later.&n;&t; */
r_if
c_cond
(paren
id|hmp-&gt;tx_full
)paren
(brace
multiline_comment|/* We should NEVER reach this point -KDU */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Hamachi transmit queue full at slot %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|hmp-&gt;cur_tx
)paren
suffix:semicolon
multiline_comment|/* Wake the potentially-idle transmit channel. */
multiline_comment|/* If we don&squot;t need to read status, DON&squot;T -KDU */
id|status
op_assign
id|readw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TxStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x0001
)paren
op_logical_or
(paren
id|status
op_amp
l_int|0x0002
)paren
)paren
(brace
id|writew
c_func
(paren
l_int|0x0001
comma
id|dev-&gt;base_addr
op_plus
id|TxCmd
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Caution: the write order is important here, set the field&n;&t;   with the &quot;ownership&quot; bits last. */
multiline_comment|/* Calculate the next Tx descriptor entry. */
id|entry
op_assign
id|hmp-&gt;cur_tx
op_mod
id|TX_RING_SIZE
suffix:semicolon
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
op_assign
id|skb
suffix:semicolon
macro_line|#ifdef TX_CHECKSUM
(brace
multiline_comment|/* tack on checksum tag */
id|u32
id|tagval
op_assign
l_int|0
suffix:semicolon
r_struct
id|ethhdr
op_star
id|eh
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|eh-&gt;h_proto
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
r_struct
id|iphdr
op_star
id|ih
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|eh
op_plus
id|ETH_HLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ih-&gt;protocol
op_eq
id|IPPROTO_UDP
)paren
(brace
r_struct
id|udphdr
op_star
id|uh
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ih
op_plus
id|ih-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
id|u32
id|offset
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|uh
op_plus
l_int|6
)paren
op_minus
id|skb-&gt;data
suffix:semicolon
id|u32
id|pseudo
suffix:semicolon
id|pseudo_csum_udp
c_func
(paren
id|pseudo
comma
id|ih
comma
id|uh
)paren
suffix:semicolon
id|pseudo
op_assign
id|htons
c_func
(paren
id|pseudo
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;udp cksum was %04x, sending pseudo %04x&bslash;n&quot;
comma
id|uh-&gt;check
comma
id|pseudo
)paren
suffix:semicolon
id|uh-&gt;check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero out uh-&gt;check before card calc */
multiline_comment|/*&n;&t;&t;     * start at 14 (skip ethhdr), store at offset (uh-&gt;check),&n;&t;&t;     * use pseudo value given.&n;&t;&t;     */
id|tagval
op_assign
(paren
l_int|14
op_lshift
l_int|24
)paren
op_or
(paren
id|offset
op_lshift
l_int|16
)paren
op_or
id|pseudo
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ih-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp, no auto cksum&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
op_star
(paren
id|u32
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
l_int|8
)paren
op_assign
id|tagval
suffix:semicolon
)brace
macro_line|#endif
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|addr
op_assign
id|virt_to_desc
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Hmmmm, could probably put a DescIntr on these, but the way&n;&t;&t;the driver is currently coded makes Tx interrupts unnecessary&n;&t;&t;since the clearing of the Tx ring is handled by the start_xmit&n;&t;&t;routine.  This organization helps mitigate the interrupts a&n;&t;&t;bit and probably renders the max_tx_latency param useless.&n;&t;&t;&n;&t;&t;Update: Putting a DescIntr bit on all of the descriptors and&n;&t;&t;mitigating interrupt frequency with the tx_min_pkt parameter. -KDU&n;&t;*/
r_if
c_cond
(paren
id|entry
op_ge
id|TX_RING_SIZE
op_minus
l_int|1
)paren
multiline_comment|/* Wrap ring */
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_assign
id|cpu_to_le32
c_func
(paren
id|DescOwn
op_or
id|DescEndPacket
op_or
id|DescEndRing
op_or
id|DescIntr
op_or
id|skb-&gt;len
)paren
suffix:semicolon
r_else
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_assign
id|cpu_to_le32
c_func
(paren
id|DescOwn
op_or
id|DescEndPacket
op_or
id|DescIntr
op_or
id|skb-&gt;len
)paren
suffix:semicolon
id|hmp-&gt;cur_tx
op_increment
suffix:semicolon
multiline_comment|/* Non-x86 Todo: explicitly flush cache lines here. */
multiline_comment|/* Wake the potentially-idle transmit channel. */
multiline_comment|/* If we don&squot;t need to read status, DON&squot;T -KDU */
id|status
op_assign
id|readw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TxStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x0001
)paren
op_logical_or
(paren
id|status
op_amp
l_int|0x0002
)paren
)paren
(brace
id|writew
c_func
(paren
l_int|0x0001
comma
id|dev-&gt;base_addr
op_plus
id|TxCmd
)paren
suffix:semicolon
)brace
multiline_comment|/* Immediately before returning, let&squot;s clear as many entries as we can. */
id|hamachi_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* We should kick the bottom half here, since we are not accepting&n;&t; * interrupts with every packet.  i.e. realize that Gigabit ethernet&n;&t; * can transmit faster than ordinary machines can load packets;&n;&t; * hence, any packet that got put off because we were in the transmit&n;&t; * routine should IMMEDIATELY get a chance to be re-queued. -KDU&n;&t; */
r_if
c_cond
(paren
(paren
id|hmp-&gt;cur_tx
op_minus
id|hmp-&gt;dirty_tx
)paren
OL
(paren
id|TX_RING_SIZE
op_minus
l_int|4
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Typical path */
r_else
(brace
id|hmp-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Hamachi transmit frame #%d queued in slot %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|hmp-&gt;cur_tx
comma
id|entry
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The interrupt handler does all of the Rx thread work and cleans up&n;   after the Tx thread. */
DECL|function|hamachi_interrupt
r_static
r_void
id|hamachi_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|rgs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_instance
suffix:semicolon
r_struct
id|hamachi_private
op_star
id|hmp
suffix:semicolon
r_int
id|ioaddr
comma
id|boguscnt
op_assign
id|max_interrupt_work
suffix:semicolon
macro_line|#ifndef final_version&t;&t;&t;/* Can never occur. */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;hamachi_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hmp-&gt;lock
)paren
suffix:semicolon
r_do
(brace
id|u32
id|intr_status
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
id|InterruptClear
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Hamachi interrupt, status %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|intr_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_status
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|intr_status
op_amp
id|IntrRxDone
)paren
id|hamachi_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_status
op_amp
id|IntrTxDone
)paren
(brace
multiline_comment|/* This code should RARELY need to execute. After all, this is&n;&t;&t;&t; * a gigabit link, it should consume packets as fast as we put&n;&t;&t;&t; * them in AND we clear the Tx ring in hamachi_start_xmit().&n;&t;&t;&t; */
r_if
c_cond
(paren
id|hmp-&gt;tx_full
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|hmp-&gt;cur_tx
op_minus
id|hmp-&gt;dirty_tx
OG
l_int|0
suffix:semicolon
id|hmp-&gt;dirty_tx
op_increment
)paren
(brace
r_int
id|entry
op_assign
id|hmp-&gt;dirty_tx
op_mod
id|TX_RING_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_amp
id|cpu_to_le32
c_func
(paren
id|DescOwn
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Free the original skb. */
r_if
c_cond
(paren
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
)paren
(brace
id|dev_kfree_skb_irq
c_func
(paren
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
)paren
suffix:semicolon
id|hmp-&gt;tx_skbuff
(braket
id|entry
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|hmp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ge
id|TX_RING_SIZE
op_minus
l_int|1
)paren
id|hmp-&gt;tx_ring
(braket
id|TX_RING_SIZE
op_minus
l_int|1
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescEndRing
)paren
suffix:semicolon
id|hmp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hmp-&gt;cur_tx
op_minus
id|hmp-&gt;dirty_tx
OL
id|TX_RING_SIZE
op_minus
l_int|4
)paren
(brace
multiline_comment|/* The ring is no longer full */
id|hmp-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Abnormal error summary/uncommon events handlers. */
r_if
c_cond
(paren
id|intr_status
op_amp
(paren
id|IntrTxPCIFault
op_or
id|IntrTxPCIErr
op_or
id|IntrRxPCIFault
op_or
id|IntrRxPCIErr
op_or
id|LinkChange
op_or
id|NegotiationChange
op_or
id|StatsMax
)paren
)paren
id|hamachi_error
c_func
(paren
id|dev
comma
id|intr_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscnt
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Too much work at interrupt, status=0x%4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|intr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exiting interrupt, status=%#4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readl
c_func
(paren
id|ioaddr
op_plus
id|IntrStatus
)paren
)paren
suffix:semicolon
macro_line|#ifndef final_version
multiline_comment|/* Code that should never be run!  Perhaps remove after testing.. */
(brace
r_static
r_int
id|stopit
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;start
op_eq
l_int|0
op_logical_and
op_decrement
id|stopit
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Emergency stop, looping startup interrupt.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|hmp-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#ifdef TX_CHECKSUM
multiline_comment|/*&n; * Copied from eth_type_trans(), with reduced header, since we don&squot;t&n; * get it on RX, only on TX.&n; */
DECL|function|hamachi_eth_type_trans
r_static
r_int
r_int
id|hamachi_eth_type_trans
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth
suffix:semicolon
r_int
r_char
op_star
id|rawp
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
op_minus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* artificially enlarged on tx */
id|eth
op_assign
id|skb-&gt;mac.ethernet
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eth-&gt;h_dest
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;broadcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
(brace
id|skb-&gt;pkt_type
op_assign
id|PACKET_BROADCAST
suffix:semicolon
)brace
r_else
id|skb-&gt;pkt_type
op_assign
id|PACKET_MULTICAST
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;This ALLMULTI check should be redundant by 1.4&n;&t; *&t;so don&squot;t forget to remove it.&n;&t; *&n;&t; *&t;Seems, you forgot to remove it. All silly devices&n;&t; *&t;seems to set IFF_PROMISC.&n;&t; */
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_PROMISC
multiline_comment|/*|IFF_ALLMULTI*/
)paren
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
id|skb-&gt;pkt_type
op_assign
id|PACKET_OTHERHOST
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|eth-&gt;h_proto
)paren
op_ge
l_int|1536
)paren
r_return
id|eth-&gt;h_proto
suffix:semicolon
id|rawp
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is a magic hack to spot IPX packets. Older Novell breaks&n;&t; *&t;the protocol design and runs IPX over 802.3 without an 802.2 LLC&n;&t; *&t;layer. We look for FFFF which isn&squot;t a used 802.2 SSAP/DSAP. This&n;&t; *&t;won&squot;t work for fault tolerant netware but does for the rest.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xFFFF
)paren
r_return
id|htons
c_func
(paren
id|ETH_P_802_3
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Real 802.2 LLC&n;&t; */
r_return
id|htons
c_func
(paren
id|ETH_P_802_2
)paren
suffix:semicolon
)brace
macro_line|#endif  /* TX_CHECKSUM */
multiline_comment|/* This routine is logically part of the interrupt handler, but seperated&n;   for clarity and better register allocation. */
DECL|function|hamachi_rx
r_static
r_int
id|hamachi_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
op_assign
id|hmp-&gt;cur_rx
op_mod
id|RX_RING_SIZE
suffix:semicolon
r_int
id|boguscnt
op_assign
(paren
id|hmp-&gt;dirty_rx
op_plus
id|RX_RING_SIZE
)paren
op_minus
id|hmp-&gt;cur_rx
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; In hamachi_rx(), entry %d status %4.4x.&bslash;n&quot;
comma
id|entry
comma
id|hmp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status_n_length
)paren
suffix:semicolon
)brace
multiline_comment|/* If EOP is set on the next entry, it&squot;s a new packet. Send it up. */
r_while
c_loop
(paren
op_logical_neg
(paren
id|hmp-&gt;rx_head_desc-&gt;status_n_length
op_amp
id|cpu_to_le32
c_func
(paren
id|DescOwn
)paren
)paren
)paren
(brace
r_struct
id|hamachi_desc
op_star
id|desc
op_assign
id|hmp-&gt;rx_head_desc
suffix:semicolon
id|u32
id|desc_status
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;status_n_length
)paren
suffix:semicolon
id|u16
id|data_size
op_assign
id|desc_status
suffix:semicolon
multiline_comment|/* Implicit truncate */
id|u8
op_star
id|buf_addr
op_assign
id|le32desc_to_virt
c_func
(paren
id|desc-&gt;addr
)paren
suffix:semicolon
id|s32
id|frame_status
op_assign
id|le32_to_cpu
c_func
(paren
id|get_unaligned
c_func
(paren
(paren
id|s32
op_star
)paren
op_amp
(paren
id|buf_addr
(braket
id|data_size
op_minus
l_int|12
)braket
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  hamachi_rx() status was %8.8x.&bslash;n&quot;
comma
id|frame_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscnt
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|desc_status
op_amp
id|DescEndPacket
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Oversized Ethernet frame spanned &quot;
l_string|&quot;multiple buffers, entry %#x length %d status %4.4x!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|hmp-&gt;cur_rx
comma
id|data_size
comma
id|desc_status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Oversized Ethernet frame %p vs %p.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|desc
comma
op_amp
id|hmp-&gt;rx_ring
(braket
id|hmp-&gt;cur_rx
op_mod
id|RX_RING_SIZE
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Oversized Ethernet frame -- next status %x/%x last status %x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|hmp-&gt;rx_ring
(braket
(paren
id|hmp-&gt;cur_rx
op_plus
l_int|1
)paren
op_mod
id|RX_RING_SIZE
)braket
dot
id|status_n_length
op_amp
l_int|0xffff0000
comma
id|hmp-&gt;rx_ring
(braket
(paren
id|hmp-&gt;cur_rx
op_plus
l_int|1
)paren
op_mod
id|RX_RING_SIZE
)braket
dot
id|status_n_length
op_amp
l_int|0x0000ffff
comma
id|hmp-&gt;rx_ring
(braket
(paren
id|hmp-&gt;cur_rx
op_minus
l_int|1
)paren
op_mod
id|RX_RING_SIZE
)braket
dot
id|status_n_length
)paren
suffix:semicolon
id|hmp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* else  Omit for prototype errata??? */
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x00380000
)paren
(brace
multiline_comment|/* There was an error. */
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  hamachi_rx() Rx error was %8.8x.&bslash;n&quot;
comma
id|frame_status
)paren
suffix:semicolon
id|hmp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x00600000
)paren
id|hmp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x00080000
)paren
id|hmp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x00100000
)paren
id|hmp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
OL
l_int|0
)paren
id|hmp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Omit CRC */
id|u16
id|pkt_len
op_assign
(paren
id|frame_status
op_amp
l_int|0x07ff
)paren
op_minus
l_int|4
suffix:semicolon
macro_line|#ifdef RX_CHECKSUM
id|u32
id|pfck
op_assign
op_star
(paren
id|u32
op_star
)paren
op_amp
id|buf_addr
(braket
id|data_size
op_minus
l_int|8
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  hamachi_rx() normal Rx pkt length %d&quot;
l_string|&quot; of %d, bogus_cnt %d.&bslash;n&quot;
comma
id|pkt_len
comma
id|data_size
comma
id|boguscnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s:  rx status %8.8x %8.8x %8.8x %8.8x %8.8x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
op_star
(paren
id|s32
op_star
)paren
op_amp
(paren
id|buf_addr
(braket
id|data_size
op_minus
l_int|20
)braket
)paren
comma
op_star
(paren
id|s32
op_star
)paren
op_amp
(paren
id|buf_addr
(braket
id|data_size
op_minus
l_int|16
)braket
)paren
comma
op_star
(paren
id|s32
op_star
)paren
op_amp
(paren
id|buf_addr
(braket
id|data_size
op_minus
l_int|12
)braket
)paren
comma
op_star
(paren
id|s32
op_star
)paren
op_amp
(paren
id|buf_addr
(braket
id|data_size
op_minus
l_int|8
)braket
)paren
comma
op_star
(paren
id|s32
op_star
)paren
op_amp
(paren
id|buf_addr
(braket
id|data_size
op_minus
l_int|4
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check if the packet is long enough to accept without copying&n;&t;&t;&t;   to a minimally-sized skbuff. */
r_if
c_cond
(paren
id|pkt_len
OL
id|rx_copybreak
op_logical_and
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
macro_line|#ifdef RX_CHECKSUM
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: rx_copybreak non-zero &quot;
l_string|&quot;not good with RX_CHECKSUM&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 16 byte align the IP header */
multiline_comment|/* Call copy + cksum if available. */
macro_line|#if 1 || USE_IP_COPYSUM
id|eth_copy_and_sum
c_func
(paren
id|skb
comma
id|bus_to_virt
c_func
(paren
id|desc-&gt;addr
)paren
comma
id|pkt_len
comma
l_int|0
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
macro_line|#else
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
id|bus_to_virt
c_func
(paren
id|desc-&gt;addr
)paren
comma
id|pkt_len
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_char
op_star
id|temp
op_assign
id|skb_put
c_func
(paren
id|skb
op_assign
id|hmp-&gt;rx_skbuff
(braket
id|entry
)braket
comma
id|pkt_len
)paren
suffix:semicolon
id|hmp-&gt;rx_skbuff
(braket
id|entry
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifndef final_version&t;&t;&t;&t;/* Remove after testing. */
r_if
c_cond
(paren
id|bus_to_virt
c_func
(paren
id|desc-&gt;addr
)paren
op_ne
id|temp
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Internal fault: The skbuff addresses &quot;
l_string|&quot;do not match in hamachi_rx: %p vs. %p / %p.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|bus_to_virt
c_func
(paren
id|desc-&gt;addr
)paren
comma
id|skb-&gt;head
comma
id|temp
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|temp
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef TX_CHECKSUM
multiline_comment|/* account for extra TX hard_header bytes */
id|skb-&gt;protocol
op_assign
id|hamachi_eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
macro_line|#else
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef RX_CHECKSUM
multiline_comment|/* TCP or UDP on ipv4, DIX encoding */
r_if
c_cond
(paren
id|pfck
op_rshift
l_int|24
op_eq
l_int|0x91
op_logical_or
id|pfck
op_rshift
l_int|24
op_eq
l_int|0x51
)paren
(brace
r_struct
id|iphdr
op_star
id|ih
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Check that IP packet is at least 46 bytes, otherwise,&n;&t;&t;&t;&t; * there may be pad bytes included in the hardware checksum.&n;&t;&t;&t;&t; * This wouldn&squot;t happen if everyone padded with 0.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|ih-&gt;tot_len
)paren
op_ge
l_int|46
)paren
(brace
multiline_comment|/* don&squot;t worry about frags */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ih-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
)paren
(brace
id|u32
id|inv
op_assign
op_star
(paren
id|u32
op_star
)paren
op_amp
id|buf_addr
(braket
id|data_size
op_minus
l_int|16
)braket
suffix:semicolon
id|u32
op_star
id|p
op_assign
(paren
id|u32
op_star
)paren
op_amp
id|buf_addr
(braket
id|data_size
op_minus
l_int|20
)braket
suffix:semicolon
r_register
id|u32
id|crc
comma
id|p_r
comma
id|p_r1
suffix:semicolon
r_if
c_cond
(paren
id|inv
op_amp
l_int|4
)paren
(brace
id|inv
op_and_assign
op_complement
l_int|4
suffix:semicolon
op_decrement
id|p
suffix:semicolon
)brace
id|p_r
op_assign
op_star
id|p
suffix:semicolon
id|p_r1
op_assign
op_star
(paren
id|p
op_minus
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|inv
)paren
(brace
r_case
l_int|0
suffix:colon
id|crc
op_assign
(paren
id|p_r
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|p_r
op_rshift
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|crc
op_assign
(paren
id|p_r
op_rshift
l_int|16
)paren
op_plus
(paren
id|p_r
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|p_r1
op_rshift
l_int|16
op_amp
l_int|0xff00
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|crc
op_assign
id|p_r
op_plus
(paren
id|p_r1
op_rshift
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|crc
op_assign
id|p_r
op_plus
(paren
id|p_r1
op_amp
l_int|0xff00
)paren
op_plus
(paren
id|p_r1
op_rshift
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*NOTREACHED*/
id|crc
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crc
op_amp
l_int|0xffff0000
)paren
(brace
id|crc
op_and_assign
l_int|0xffff
suffix:semicolon
op_increment
id|crc
suffix:semicolon
)brace
multiline_comment|/* tcp/udp will add in pseudo */
id|skb-&gt;csum
op_assign
id|ntohs
c_func
(paren
id|pfck
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;csum
OG
id|crc
)paren
id|skb-&gt;csum
op_sub_assign
id|crc
suffix:semicolon
r_else
id|skb-&gt;csum
op_add_assign
(paren
op_complement
id|crc
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;* could do the pseudo myself and return&n;&t;&t;&t;&t;&t;&t;* CHECKSUM_UNNECESSARY&n;&t;&t;&t;&t;&t;&t;*/
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_HW
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif  /* RX_CHECKSUM */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|hmp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
id|entry
op_assign
(paren
op_increment
id|hmp-&gt;cur_rx
)paren
op_mod
id|RX_RING_SIZE
suffix:semicolon
id|hmp-&gt;rx_head_desc
op_assign
op_amp
id|hmp-&gt;rx_ring
(braket
id|entry
)braket
suffix:semicolon
)brace
multiline_comment|/* Refill the Rx ring buffers. */
r_for
c_loop
(paren
suffix:semicolon
id|hmp-&gt;cur_rx
op_minus
id|hmp-&gt;dirty_rx
OG
l_int|0
suffix:semicolon
id|hmp-&gt;dirty_rx
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|entry
op_assign
id|hmp-&gt;dirty_rx
op_mod
id|RX_RING_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|hmp-&gt;rx_skbuff
(braket
id|entry
)braket
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|hmp-&gt;rx_buf_sz
)paren
suffix:semicolon
id|hmp-&gt;rx_skbuff
(braket
id|entry
)braket
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* Better luck next round. */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Mark as being used by this device. */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align IP on 16 byte boundaries */
id|hmp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|addr
op_assign
id|virt_to_desc
c_func
(paren
id|skb-&gt;tail
)paren
suffix:semicolon
)brace
id|hmp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_assign
id|cpu_to_le32
c_func
(paren
id|hmp-&gt;rx_buf_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ge
id|RX_RING_SIZE
op_minus
l_int|1
)paren
id|hmp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescOwn
op_or
id|DescEndPacket
op_or
id|DescEndRing
op_or
id|DescIntr
)paren
suffix:semicolon
r_else
id|hmp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status_n_length
op_or_assign
id|cpu_to_le32
c_func
(paren
id|DescOwn
op_or
id|DescEndPacket
op_or
id|DescIntr
)paren
suffix:semicolon
)brace
multiline_comment|/* Restart Rx engine if stopped. */
multiline_comment|/* If we don&squot;t need to check status, don&squot;t. -KDU */
r_if
c_cond
(paren
id|readw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|RxStatus
)paren
op_amp
l_int|0x0002
)paren
id|writew
c_func
(paren
l_int|0x0001
comma
id|dev-&gt;base_addr
op_plus
id|RxCmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is more properly named &quot;uncommon interrupt events&quot;, as it covers more&n;   than just errors. */
DECL|function|hamachi_error
r_static
r_void
id|hamachi_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|intr_status
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|intr_status
op_amp
(paren
id|LinkChange
op_or
id|NegotiationChange
)paren
)paren
(brace
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Link changed: AutoNegotiation Ctrl&quot;
l_string|&quot; %4.4x, Status %4.4x %4.4x Intr status %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0E0
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
l_int|0x0E2
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|ANLinkPartnerAbility
)paren
comma
id|readl
c_func
(paren
id|ioaddr
op_plus
id|IntrStatus
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readw
c_func
(paren
id|ioaddr
op_plus
id|ANStatus
)paren
op_amp
l_int|0x20
)paren
id|writeb
c_func
(paren
l_int|0x01
comma
id|ioaddr
op_plus
id|LEDCtrl
)paren
suffix:semicolon
r_else
id|writeb
c_func
(paren
l_int|0x03
comma
id|ioaddr
op_plus
id|LEDCtrl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr_status
op_amp
id|StatsMax
)paren
(brace
id|hamachi_get_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Read the overflow bits to clear. */
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x370
)paren
suffix:semicolon
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x3F0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|intr_status
op_amp
op_complement
(paren
id|LinkChange
op_or
id|StatsMax
op_or
id|NegotiationChange
op_or
id|IntrRxDone
op_or
id|IntrTxDone
)paren
)paren
op_logical_and
id|hamachi_debug
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Something Wicked happened! %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|intr_status
)paren
suffix:semicolon
multiline_comment|/* Hmmmmm, it&squot;s not clear how to recover from PCI faults. */
r_if
c_cond
(paren
id|intr_status
op_amp
(paren
id|IntrTxPCIErr
op_or
id|IntrTxPCIFault
)paren
)paren
id|hmp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|intr_status
op_amp
(paren
id|IntrRxPCIErr
op_or
id|IntrRxPCIFault
)paren
)paren
id|hmp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
DECL|function|hamachi_close
r_static
r_int
id|hamachi_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Shutting down ethercard, status was Tx %4.4x Rx %4.4x Int %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|TxStatus
)paren
comma
id|readw
c_func
(paren
id|ioaddr
op_plus
id|RxStatus
)paren
comma
id|readl
c_func
(paren
id|ioaddr
op_plus
id|IntrStatus
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Queue pointers were Tx %d / %d,  Rx %d / %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|hmp-&gt;cur_tx
comma
id|hmp-&gt;dirty_tx
comma
id|hmp-&gt;cur_rx
comma
id|hmp-&gt;dirty_rx
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable interrupts by clearing the interrupt mask. */
id|writel
c_func
(paren
l_int|0x0000
comma
id|ioaddr
op_plus
id|InterruptEnable
)paren
suffix:semicolon
multiline_comment|/* Stop the chip&squot;s Tx and Rx processes. */
id|writel
c_func
(paren
l_int|2
comma
id|ioaddr
op_plus
id|RxCmd
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|2
comma
id|ioaddr
op_plus
id|TxCmd
)paren
suffix:semicolon
macro_line|#ifdef __i386__
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_DEBUG
l_string|&quot;  Tx ring at %8.8x:&bslash;n&quot;
comma
(paren
r_int
)paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;tx_ring
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %c #%d desc. %8.8x %8.8x.&bslash;n&quot;
comma
id|readl
c_func
(paren
id|ioaddr
op_plus
id|TxCurPtr
)paren
op_eq
(paren
r_int
)paren
op_amp
id|hmp-&gt;tx_ring
(braket
id|i
)braket
ques
c_cond
l_char|&squot;&gt;&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|i
comma
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status_n_length
comma
id|hmp-&gt;tx_ring
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_DEBUG
l_string|&quot;  Rx ring %8.8x:&bslash;n&quot;
comma
(paren
r_int
)paren
id|virt_to_bus
c_func
(paren
id|hmp-&gt;rx_ring
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; %c #%d desc. %4.4x %8.8x&bslash;n&quot;
comma
id|readl
c_func
(paren
id|ioaddr
op_plus
id|RxCurPtr
)paren
op_eq
(paren
r_int
)paren
op_amp
id|hmp-&gt;rx_ring
(braket
id|i
)braket
ques
c_cond
l_char|&squot;&gt;&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|i
comma
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
comma
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hamachi_debug
OG
l_int|6
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|u8
op_star
)paren
id|bus_to_virt
c_func
(paren
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|addr
)paren
op_ne
l_int|0x69
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|0x50
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %4.4x&quot;
comma
(paren
(paren
id|u16
op_star
)paren
id|le32desc_to_virt
c_func
(paren
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|addr
)paren
)paren
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif /* __i386__ debugging only */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|hmp-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Free all the skbuffs in the Rx queue. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status_n_length
op_assign
l_int|0
suffix:semicolon
id|hmp-&gt;rx_ring
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0xBADF00D0
suffix:semicolon
multiline_comment|/* An invalid address. */
r_if
c_cond
(paren
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|hmp-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
)paren
id|dev_kfree_skb
c_func
(paren
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
id|hmp-&gt;tx_skbuff
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|writeb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|LEDCtrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hamachi_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|hamachi_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|hamachi_private
op_star
id|hmp
op_assign
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* We should lock this segment of code for SMP eventually, although&n;&t;   the vulnerability window is very small and statistics are&n;&t;   non-critical. */
multiline_comment|/* Ok, what goes here?  This appears to be stuck at 21 packets&n;           according to ifconfig.  It does get incremented in hamachi_tx(),&n;           so I think I&squot;ll comment it out here and see if better things&n;           happen.&n;        */
multiline_comment|/* hmp-&gt;stats.tx_packets&t;= readl(ioaddr + 0x000); */
id|hmp-&gt;stats.rx_bytes
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x330
)paren
suffix:semicolon
multiline_comment|/* Total Uni+Brd+Multi */
id|hmp-&gt;stats.tx_bytes
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x3B0
)paren
suffix:semicolon
multiline_comment|/* Total Uni+Brd+Multi */
id|hmp-&gt;stats.multicast
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x320
)paren
suffix:semicolon
multiline_comment|/* Multicast Rx */
id|hmp-&gt;stats.rx_length_errors
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x368
)paren
suffix:semicolon
multiline_comment|/* Over+Undersized */
id|hmp-&gt;stats.rx_over_errors
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x35C
)paren
suffix:semicolon
multiline_comment|/* Jabber */
id|hmp-&gt;stats.rx_crc_errors
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x360
)paren
suffix:semicolon
multiline_comment|/* Jabber */
id|hmp-&gt;stats.rx_frame_errors
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x364
)paren
suffix:semicolon
multiline_comment|/* Symbol Errs */
id|hmp-&gt;stats.rx_missed_errors
op_assign
id|readl
c_func
(paren
id|ioaddr
op_plus
l_int|0x36C
)paren
suffix:semicolon
multiline_comment|/* Dropped */
r_return
op_amp
id|hmp-&gt;stats
suffix:semicolon
)brace
DECL|function|set_rx_mode
r_static
r_void
id|set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Set promiscuous. */
multiline_comment|/* Unconditionally log net taps. */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x000F
comma
id|ioaddr
op_plus
id|AddrMode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;mc_count
OG
l_int|63
)paren
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
multiline_comment|/* Too many to match, or accept all multicasts. */
id|writew
c_func
(paren
l_int|0x000B
comma
id|ioaddr
op_plus
id|AddrMode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
OG
l_int|0
)paren
(brace
multiline_comment|/* Must use the CAM filter. */
r_struct
id|dev_mc_list
op_star
id|mclist
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mclist
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mclist
op_logical_and
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
comma
id|mclist
op_assign
id|mclist-&gt;next
)paren
(brace
id|writel
c_func
(paren
op_star
(paren
id|u32
op_star
)paren
(paren
id|mclist-&gt;dmi_addr
)paren
comma
id|ioaddr
op_plus
l_int|0x100
op_plus
id|i
op_star
l_int|8
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0x20000
op_or
(paren
op_star
(paren
id|u16
op_star
)paren
op_amp
id|mclist-&gt;dmi_addr
(braket
l_int|4
)braket
)paren
comma
id|ioaddr
op_plus
l_int|0x104
op_plus
id|i
op_star
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear remaining entries. */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|writel
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
l_int|0x104
op_plus
id|i
op_star
l_int|8
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x0003
comma
id|ioaddr
op_plus
id|AddrMode
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Normal, unicast/broadcast-only mode. */
id|writew
c_func
(paren
l_int|0x0001
comma
id|ioaddr
op_plus
id|AddrMode
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef HAVE_PRIVATE_IOCTL
DECL|function|mii_ioctl
r_static
r_int
id|mii_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
op_star
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDEVPRIVATE
suffix:colon
multiline_comment|/* Get the address of the PHY in use. */
id|data
(braket
l_int|0
)braket
op_assign
(paren
(paren
r_struct
id|hamachi_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|phys
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* Fall Through */
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|1
suffix:colon
multiline_comment|/* Read the specified MII register. */
id|data
(braket
l_int|3
)braket
op_assign
id|mdio_read
c_func
(paren
id|ioaddr
comma
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|2
suffix:colon
multiline_comment|/* Write the specified MII register */
multiline_comment|/* TODO: Check the sequencing of this.  Might need to stop and&n;&t;&t; * restart Rx and Tx engines. -KDU&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|mdio_write
c_func
(paren
id|ioaddr
comma
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|3
suffix:colon
(brace
multiline_comment|/* set rx,tx intr params */
id|u32
op_star
id|d
op_assign
(paren
id|u32
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
multiline_comment|/* Should add this check here or an ordinary user can do nasty&n;&t;&t; * things. -KDU&n;&t;&t; *&n;&t;&t; * TODO: Shut down the Rx and Tx engines while doing this.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|writel
c_func
(paren
id|d
(braket
l_int|0
)braket
comma
id|dev-&gt;base_addr
op_plus
id|TxIntrCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
id|d
(braket
l_int|1
)braket
comma
id|dev-&gt;base_addr
op_plus
id|RxIntrCtrl
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: tx %08x, rx %08x intr&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|u32
)paren
id|readl
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TxIntrCtrl
)paren
comma
(paren
id|u32
)paren
id|readl
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|RxIntrCtrl
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
macro_line|#endif  /* HAVE_PRIVATE_IOCTL */
DECL|function|hamachi_remove_one
r_static
r_void
id|__exit
id|hamachi_remove_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
r_if
c_cond
(paren
id|dev
)paren
(brace
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|hamachi_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
l_int|0x1318
comma
l_int|0x0911
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|hamachi_pci_tbl
)paren
suffix:semicolon
DECL|variable|hamachi_driver
r_static
r_struct
id|pci_driver
id|hamachi_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;hamachi&quot;
comma
id|id_table
suffix:colon
id|hamachi_pci_tbl
comma
id|probe
suffix:colon
id|hamachi_init_one
comma
id|remove
suffix:colon
id|hamachi_remove_one
comma
)brace
suffix:semicolon
DECL|function|hamachi_init
r_static
r_int
id|__init
id|hamachi_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|pci_register_driver
c_func
(paren
op_amp
id|hamachi_driver
)paren
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|pci_unregister_driver
c_func
(paren
op_amp
id|hamachi_driver
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|hamachi_exit
r_static
r_void
id|__exit
id|hamachi_exit
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|hamachi_driver
)paren
suffix:semicolon
)brace
DECL|variable|hamachi_init
id|module_init
c_func
(paren
id|hamachi_init
)paren
suffix:semicolon
DECL|variable|hamachi_exit
id|module_exit
c_func
(paren
id|hamachi_exit
)paren
suffix:semicolon
eof
