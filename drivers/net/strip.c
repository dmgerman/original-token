multiline_comment|/*&n; * Copyright 1996 The Board of Trustees of The Leland Stanford&n; * Junior University. All Rights Reserved.&n; *&n; * Permission to use, copy, modify, and distribute this&n; * software and its documentation for any purpose and without&n; * fee is hereby granted, provided that the above copyright&n; * notice appear in all copies.  Stanford University&n; * makes no representations about the suitability of this&n; * software for any purpose.  It is provided &quot;as is&quot; without&n; * express or implied warranty.&n; *&n; * strip.c&t;This module implements Starmode Radio IP (STRIP)&n; *&t;&t;for kernel-based devices like TTY.  It interfaces between a&n; *&t;&t;raw TTY, and the kernel&squot;s INET protocol layers (via DDI).&n; *&n; * Version:&t;@(#)strip.c&t;1.3&t;July 1997&n; *&n; * Author:&t;Stuart Cheshire &lt;cheshire@cs.stanford.edu&gt;&n; *&n; * Fixes:&t;v0.9 12th Feb 1996 (SC)&n; *&t;&t;New byte stuffing (2+6 run-length encoding)&n; *&t;&t;New watchdog timer task&n; *&t;&t;New Protocol key (SIP0)&n; *&t;&t;&n; *&t;&t;v0.9.1 3rd March 1996 (SC)&n; *&t;&t;Changed to dynamic device allocation -- no more compile&n; *&t;&t;time (or boot time) limit on the number of STRIP devices.&n; *&t;&t;&n; *&t;&t;v0.9.2 13th March 1996 (SC)&n; *&t;&t;Uses arp cache lookups (but doesn&squot;t send arp packets yet)&n; *&t;&t;&n; *&t;&t;v0.9.3 17th April 1996 (SC)&n; *&t;&t;Fixed bug where STR_ERROR flag was getting set unneccessarily&n; *&t;&t;(causing otherwise good packets to be unneccessarily dropped)&n; *&t;&t;&n; *&t;&t;v0.9.4 27th April 1996 (SC)&n; *&t;&t;First attempt at using &quot;&amp;COMMAND&quot; Starmode AT commands&n; *&t;&t;&n; *&t;&t;v0.9.5 29th May 1996 (SC)&n; *&t;&t;First attempt at sending (unicast) ARP packets&n; *&t;&t;&n; *&t;&t;v0.9.6 5th June 1996 (Elliot)&n; *&t;&t;Put &quot;message level&quot; tags in every &quot;printk&quot; statement&n; *&t;&t;&n; *&t;&t;v0.9.7 13th June 1996 (laik)&n; *&t;&t;Added support for the /proc fs&n; *&n; *              v0.9.8 July 1996 (Mema)&n; *              Added packet logging&n; *&n; *              v1.0 November 1996 (SC)&n; *              Fixed (severe) memory leaks in the /proc fs code&n; *              Fixed race conditions in the logging code&n; *&n; *              v1.1 January 1997 (SC)&n; *              Deleted packet logging (use tcpdump instead)&n; *              Added support for Metricom Firmware v204 features&n; *              (like message checksums)&n; *&n; *              v1.2 January 1997 (SC)&n; *              Put portables list back in&n; *&n; *              v1.3 July 1997 (SC)&n; *              Made STRIP driver set the radio&squot;s baud rate automatically.&n; *              It is no longer necessarily to manually set the radio&squot;s&n; *              rate permanently to 115200 -- the driver handles setting&n; *              the rate automatically.&n; */
macro_line|#ifdef MODULE
DECL|variable|StripVersion
r_static
r_const
r_char
id|StripVersion
(braket
)braket
op_assign
l_string|&quot;1.3-STUART.CHESHIRE-MODULAR&quot;
suffix:semicolon
macro_line|#else
DECL|variable|StripVersion
r_static
r_const
r_char
id|StripVersion
(braket
)braket
op_assign
l_string|&quot;1.3-STUART.CHESHIRE&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|TICKLE_TIMERS
mdefine_line|#define TICKLE_TIMERS 0
DECL|macro|EXT_COUNTERS
mdefine_line|#define EXT_COUNTERS 1
multiline_comment|/************************************************************************/
multiline_comment|/* Header files&t;&t;&t;&t;&t;&t;&t;&t;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
multiline_comment|/*&n; * isdigit() and isspace() use the ctype[] array, which is not available&n; * to kernel modules.  If compiling as a module,  use  a local definition&n; * of isdigit() and isspace() until  _ctype is added to ksyms.&n; */
macro_line|#ifdef MODULE
DECL|macro|isdigit
macro_line|# define isdigit(c) (&squot;0&squot; &lt;= (c) &amp;&amp; (c)  &lt;= &squot;9&squot;)
DECL|macro|isspace
macro_line|# define isspace(c) ((c) == &squot; &squot; || (c)  == &squot;&bslash;t&squot;)
macro_line|#else
macro_line|# include &lt;linux/ctype.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_strip.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serialP.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/time.h&gt;
multiline_comment|/************************************************************************/
multiline_comment|/* Useful structures and definitions&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * A MetricomKey identifies the protocol being carried inside a Metricom&n; * Starmode packet.&n; */
r_typedef
r_union
(brace
DECL|member|c
id|__u8
id|c
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|l
id|__u32
id|l
suffix:semicolon
DECL|typedef|MetricomKey
)brace
id|MetricomKey
suffix:semicolon
multiline_comment|/*&n; * An IP address can be viewed as four bytes in memory (which is what it is) or as&n; * a single 32-bit long (which is convenient for assignment, equality testing etc.)&n; */
r_typedef
r_union
(brace
DECL|member|b
id|__u8
id|b
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|l
id|__u32
id|l
suffix:semicolon
DECL|typedef|IPaddr
)brace
id|IPaddr
suffix:semicolon
multiline_comment|/*&n; * A MetricomAddressString is used to hold a printable representation of&n; * a Metricom address.&n; */
r_typedef
r_struct
(brace
DECL|member|c
id|__u8
id|c
(braket
l_int|24
)braket
suffix:semicolon
DECL|typedef|MetricomAddressString
)brace
id|MetricomAddressString
suffix:semicolon
multiline_comment|/* Encapsulation can expand packet of size x to 65/64x + 1&n; * Sent packet looks like &quot;&lt;CR&gt;*&lt;address&gt;*&lt;key&gt;&lt;encaps payload&gt;&lt;CR&gt;&quot;&n; *                           1 1   1-18  1  4         ?         1&n; * eg.                     &lt;CR&gt;*0000-1234*SIP0&lt;encaps payload&gt;&lt;CR&gt;&n; * We allow 31 bytes for the stars, the key, the address and the &lt;CR&gt;s&n; */
DECL|macro|STRIP_ENCAP_SIZE
mdefine_line|#define STRIP_ENCAP_SIZE(X) (32 + (X)*65L/64L)
multiline_comment|/*&n; * A STRIP_Header is never really sent over the radio, but making a dummy&n; * header for internal use within the kernel that looks like an Ethernet&n; * header makes certain other software happier. For example, tcpdump&n; * already understands Ethernet headers.&n; */
r_typedef
r_struct
(brace
DECL|member|dst_addr
id|MetricomAddress
id|dst_addr
suffix:semicolon
multiline_comment|/* Destination address, e.g. &quot;0000-1234&quot;   */
DECL|member|src_addr
id|MetricomAddress
id|src_addr
suffix:semicolon
multiline_comment|/* Source address, e.g. &quot;0000-5678&quot;        */
DECL|member|protocol
r_int
r_int
id|protocol
suffix:semicolon
multiline_comment|/* The protocol type, using Ethernet codes */
DECL|typedef|STRIP_Header
)brace
id|STRIP_Header
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|60
)braket
suffix:semicolon
DECL|typedef|MetricomNode
)brace
id|MetricomNode
suffix:semicolon
DECL|macro|NODE_TABLE_SIZE
mdefine_line|#define NODE_TABLE_SIZE 32
r_typedef
r_struct
(brace
DECL|member|timestamp
r_struct
id|timeval
id|timestamp
suffix:semicolon
DECL|member|num_nodes
r_int
id|num_nodes
suffix:semicolon
DECL|member|node
id|MetricomNode
id|node
(braket
id|NODE_TABLE_SIZE
)braket
suffix:semicolon
DECL|typedef|MetricomNodeTable
)brace
id|MetricomNodeTable
suffix:semicolon
DECL|enumerator|FALSE
DECL|enumerator|TRUE
r_enum
(brace
id|FALSE
op_assign
l_int|0
comma
id|TRUE
op_assign
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * Holds the radio&squot;s firmware version.&n; */
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|50
)braket
suffix:semicolon
DECL|typedef|FirmwareVersion
)brace
id|FirmwareVersion
suffix:semicolon
multiline_comment|/*&n; * Holds the radio&squot;s serial number.&n; */
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|18
)braket
suffix:semicolon
DECL|typedef|SerialNumber
)brace
id|SerialNumber
suffix:semicolon
multiline_comment|/*&n; * Holds the radio&squot;s battery voltage.&n; */
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|11
)braket
suffix:semicolon
DECL|typedef|BatteryVoltage
)brace
id|BatteryVoltage
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|8
)braket
suffix:semicolon
DECL|typedef|char8
)brace
id|char8
suffix:semicolon
r_enum
(brace
DECL|enumerator|NoStructure
id|NoStructure
op_assign
l_int|0
comma
multiline_comment|/* Really old firmware */
DECL|enumerator|StructuredMessages
id|StructuredMessages
op_assign
l_int|1
comma
multiline_comment|/* Parsable AT response msgs */
DECL|enumerator|ChecksummedMessages
id|ChecksummedMessages
op_assign
l_int|2
multiline_comment|/* Parsable AT response msgs with checksums */
DECL|variable|FirmwareLevel
)brace
id|FirmwareLevel
suffix:semicolon
DECL|struct|strip
r_struct
id|strip
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
multiline_comment|/*&n;     * These are pointers to the malloc()ed frame buffers.&n;     */
DECL|member|rx_buff
r_int
r_char
op_star
id|rx_buff
suffix:semicolon
multiline_comment|/* buffer for received IP packet*/
DECL|member|sx_buff
r_int
r_char
op_star
id|sx_buff
suffix:semicolon
multiline_comment|/* buffer for received serial data*/
DECL|member|sx_count
r_int
id|sx_count
suffix:semicolon
multiline_comment|/* received serial data counter */
DECL|member|sx_size
r_int
id|sx_size
suffix:semicolon
multiline_comment|/* Serial buffer size&t;&t;*/
DECL|member|tx_buff
r_int
r_char
op_star
id|tx_buff
suffix:semicolon
multiline_comment|/* transmitter buffer           */
DECL|member|tx_head
r_int
r_char
op_star
id|tx_head
suffix:semicolon
multiline_comment|/* pointer to next byte to XMIT */
DECL|member|tx_left
r_int
id|tx_left
suffix:semicolon
multiline_comment|/* bytes left in XMIT queue     */
DECL|member|tx_size
r_int
id|tx_size
suffix:semicolon
multiline_comment|/* Serial buffer size&t;&t;*/
multiline_comment|/*&n;     * STRIP interface statistics.&n;     */
DECL|member|rx_packets
r_int
r_int
id|rx_packets
suffix:semicolon
multiline_comment|/* inbound frames counter&t;*/
DECL|member|tx_packets
r_int
r_int
id|tx_packets
suffix:semicolon
multiline_comment|/* outbound frames counter&t;*/
DECL|member|rx_errors
r_int
r_int
id|rx_errors
suffix:semicolon
multiline_comment|/* Parity, etc. errors&t;&t;*/
DECL|member|tx_errors
r_int
r_int
id|tx_errors
suffix:semicolon
multiline_comment|/* Planned stuff&t;&t;*/
DECL|member|rx_dropped
r_int
r_int
id|rx_dropped
suffix:semicolon
multiline_comment|/* No memory for skb&t;&t;*/
DECL|member|tx_dropped
r_int
r_int
id|tx_dropped
suffix:semicolon
multiline_comment|/* When MTU change&t;&t;*/
DECL|member|rx_over_errors
r_int
r_int
id|rx_over_errors
suffix:semicolon
multiline_comment|/* Frame bigger then STRIP buf. */
DECL|member|pps_timer
r_int
r_int
id|pps_timer
suffix:semicolon
multiline_comment|/* Timer to determine pps&t;*/
DECL|member|rx_pps_count
r_int
r_int
id|rx_pps_count
suffix:semicolon
multiline_comment|/* Counter to determine pps&t;*/
DECL|member|tx_pps_count
r_int
r_int
id|tx_pps_count
suffix:semicolon
multiline_comment|/* Counter to determine pps&t;*/
DECL|member|sx_pps_count
r_int
r_int
id|sx_pps_count
suffix:semicolon
multiline_comment|/* Counter to determine pps&t;*/
DECL|member|rx_average_pps
r_int
r_int
id|rx_average_pps
suffix:semicolon
multiline_comment|/* rx packets per second * 8&t;*/
DECL|member|tx_average_pps
r_int
r_int
id|tx_average_pps
suffix:semicolon
multiline_comment|/* tx packets per second * 8&t;*/
DECL|member|sx_average_pps
r_int
r_int
id|sx_average_pps
suffix:semicolon
multiline_comment|/* sent packets per second * 8&t;*/
macro_line|#ifdef EXT_COUNTERS
DECL|member|rx_bytes
r_int
r_int
id|rx_bytes
suffix:semicolon
multiline_comment|/* total received bytes */
DECL|member|tx_bytes
r_int
r_int
id|tx_bytes
suffix:semicolon
multiline_comment|/* total received bytes */
DECL|member|rx_rbytes
r_int
r_int
id|rx_rbytes
suffix:semicolon
multiline_comment|/* bytes thru radio i/f */
DECL|member|tx_rbytes
r_int
r_int
id|tx_rbytes
suffix:semicolon
multiline_comment|/* bytes thru radio i/f */
DECL|member|rx_sbytes
r_int
r_int
id|rx_sbytes
suffix:semicolon
multiline_comment|/* tot bytes thru serial i/f */
DECL|member|tx_sbytes
r_int
r_int
id|tx_sbytes
suffix:semicolon
multiline_comment|/* tot bytes thru serial i/f */
DECL|member|rx_ebytes
r_int
r_int
id|rx_ebytes
suffix:semicolon
multiline_comment|/* tot stat/err bytes */
DECL|member|tx_ebytes
r_int
r_int
id|tx_ebytes
suffix:semicolon
multiline_comment|/* tot stat/err bytes */
macro_line|#endif
multiline_comment|/*&n;     * Internal variables.&n;     */
DECL|member|next
r_struct
id|strip
op_star
id|next
suffix:semicolon
multiline_comment|/* The next struct in the list&t;*/
DECL|member|referrer
r_struct
id|strip
op_star
op_star
id|referrer
suffix:semicolon
multiline_comment|/* The pointer that points to us*/
DECL|member|discard
r_int
id|discard
suffix:semicolon
multiline_comment|/* Set if serial error&t;&t;*/
DECL|member|working
r_int
id|working
suffix:semicolon
multiline_comment|/* Is radio working correctly?&t;*/
DECL|member|firmware_level
r_int
id|firmware_level
suffix:semicolon
multiline_comment|/* Message structuring level&t;*/
DECL|member|next_command
r_int
id|next_command
suffix:semicolon
multiline_comment|/* Next periodic command&t;*/
DECL|member|user_baud
r_int
r_int
id|user_baud
suffix:semicolon
multiline_comment|/* The user-selected baud rate  */
DECL|member|mtu
r_int
id|mtu
suffix:semicolon
multiline_comment|/* Our mtu (to spot changes!)&t;*/
DECL|member|watchdog_doprobe
r_int
id|watchdog_doprobe
suffix:semicolon
multiline_comment|/* Next time to test the radio&t;*/
DECL|member|watchdog_doreset
r_int
id|watchdog_doreset
suffix:semicolon
multiline_comment|/* Time to do next reset&t;*/
DECL|member|gratuitous_arp
r_int
id|gratuitous_arp
suffix:semicolon
multiline_comment|/* Time to send next ARP refresh*/
DECL|member|arp_interval
r_int
id|arp_interval
suffix:semicolon
multiline_comment|/* Next ARP interval&t;&t;*/
DECL|member|idle_timer
r_struct
id|timer_list
id|idle_timer
suffix:semicolon
multiline_comment|/* For periodic wakeup calls&t;*/
DECL|member|true_dev_addr
id|MetricomAddress
id|true_dev_addr
suffix:semicolon
multiline_comment|/* True address of radio&t;*/
DECL|member|manual_dev_addr
r_int
id|manual_dev_addr
suffix:semicolon
multiline_comment|/* Hack: See note below         */
DECL|member|firmware_version
id|FirmwareVersion
id|firmware_version
suffix:semicolon
multiline_comment|/* The radio&squot;s firmware version */
DECL|member|serial_number
id|SerialNumber
id|serial_number
suffix:semicolon
multiline_comment|/* The radio&squot;s serial number    */
DECL|member|battery_voltage
id|BatteryVoltage
id|battery_voltage
suffix:semicolon
multiline_comment|/* The radio&squot;s battery voltage  */
multiline_comment|/*&n;     * Other useful structures.&n;     */
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* ptr to TTY structure&t;&t;*/
DECL|member|dev
r_struct
id|net_device
id|dev
suffix:semicolon
multiline_comment|/* Our device structure&t;&t;*/
multiline_comment|/*&n;     * Neighbour radio records&n;     */
DECL|member|portables
id|MetricomNodeTable
id|portables
suffix:semicolon
DECL|member|poletops
id|MetricomNodeTable
id|poletops
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Note: manual_dev_addr hack&n; * &n; * It is not possible to change the hardware address of a Metricom radio,&n; * or to send packets with a user-specified hardware source address, thus&n; * trying to manually set a hardware source address is a questionable&n; * thing to do.  However, if the user *does* manually set the hardware&n; * source address of a STRIP interface, then the kernel will believe it,&n; * and use it in certain places. For example, the hardware address listed&n; * by ifconfig will be the manual address, not the true one.&n; * (Both addresses are listed in /proc/net/strip.)&n; * Also, ARP packets will be sent out giving the user-specified address as&n; * the source address, not the real address. This is dangerous, because&n; * it means you won&squot;t receive any replies -- the ARP replies will go to&n; * the specified address, which will be some other radio. The case where&n; * this is useful is when that other radio is also connected to the same&n; * machine. This allows you to connect a pair of radios to one machine,&n; * and to use one exclusively for inbound traffic, and the other&n; * exclusively for outbound traffic. Pretty neat, huh?&n; * &n; * Here&squot;s the full procedure to set this up:&n; * &n; * 1. &quot;slattach&quot; two interfaces, e.g. st0 for outgoing packets,&n; *    and st1 for incoming packets&n; * &n; * 2. &quot;ifconfig&quot; st0 (outbound radio) to have the hardware address&n; *    which is the real hardware address of st1 (inbound radio).&n; *    Now when it sends out packets, it will masquerade as st1, and&n; *    replies will be sent to that radio, which is exactly what we want.&n; * &n; * 3. Set the route table entry (&quot;route add default ...&quot; or&n; *    &quot;route add -net ...&quot;, as appropriate) to send packets via the st0&n; *    interface (outbound radio). Do not add any route which sends packets&n; *    out via the st1 interface -- that radio is for inbound traffic only.&n; * &n; * 4. &quot;ifconfig&quot; st1 (inbound radio) to have hardware address zero.&n; *    This tells the STRIP driver to &quot;shut down&quot; that interface and not&n; *    send any packets through it. In particular, it stops sending the&n; *    periodic gratuitous ARP packets that a STRIP interface normally sends.&n; *    Also, when packets arrive on that interface, it will search the&n; *    interface list to see if there is another interface who&squot;s manual&n; *    hardware address matches its own real address (i.e. st0 in this&n; *    example) and if so it will transfer ownership of the skbuff to&n; *    that interface, so that it looks to the kernel as if the packet&n; *    arrived on that interface. This is necessary because when the&n; *    kernel sends an ARP packet on st0, it expects to get a reply on&n; *    st0, and if it sees the reply come from st1 then it will ignore&n; *    it (to be accurate, it puts the entry in the ARP table, but&n; *    labelled in such a way that st0 can&squot;t use it).&n; * &n; * Thanks to Petros Maniatis for coming up with the idea of splitting&n; * inbound and outbound traffic between two interfaces, which turned&n; * out to be really easy to implement, even if it is a bit of a hack.&n; * &n; * Having set a manual address on an interface, you can restore it&n; * to automatic operation (where the address is automatically kept&n; * consistent with the real address of the radio) by setting a manual&n; * address of all ones, e.g. &quot;ifconfig st0 hw strip FFFFFFFFFFFF&quot;&n; * This &squot;turns off&squot; manual override mode for the device address.&n; * &n; * Note: The IEEE 802 headers reported in tcpdump will show the *real*&n; * radio addresses the packets were sent and received from, so that you&n; * can see what is really going on with packets, and which interfaces&n; * they are really going through.&n; */
multiline_comment|/************************************************************************/
multiline_comment|/* Constants&t;&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * CommandString1 works on all radios&n; * Other CommandStrings are only used with firmware that provides structured responses.&n; * &n; * ats319=1 Enables Info message for node additions and deletions&n; * ats319=2 Enables Info message for a new best node&n; * ats319=4 Enables checksums&n; * ats319=8 Enables ACK messages&n; */
DECL|variable|MaxCommandStringLength
r_static
r_const
r_int
id|MaxCommandStringLength
op_assign
l_int|32
suffix:semicolon
DECL|variable|CompatibilityCommand
r_static
r_const
r_int
id|CompatibilityCommand
op_assign
l_int|1
suffix:semicolon
DECL|variable|CommandString0
r_static
r_const
r_char
id|CommandString0
(braket
)braket
op_assign
l_string|&quot;*&amp;COMMAND*ATS319=7&quot;
suffix:semicolon
multiline_comment|/* Turn on checksums &amp; info messages */
DECL|variable|CommandString1
r_static
r_const
r_char
id|CommandString1
(braket
)braket
op_assign
l_string|&quot;*&amp;COMMAND*ATS305?&quot;
suffix:semicolon
multiline_comment|/* Query radio name */
DECL|variable|CommandString2
r_static
r_const
r_char
id|CommandString2
(braket
)braket
op_assign
l_string|&quot;*&amp;COMMAND*ATS325?&quot;
suffix:semicolon
multiline_comment|/* Query battery voltage */
DECL|variable|CommandString3
r_static
r_const
r_char
id|CommandString3
(braket
)braket
op_assign
l_string|&quot;*&amp;COMMAND*ATS300?&quot;
suffix:semicolon
multiline_comment|/* Query version information */
DECL|variable|CommandString4
r_static
r_const
r_char
id|CommandString4
(braket
)braket
op_assign
l_string|&quot;*&amp;COMMAND*ATS311?&quot;
suffix:semicolon
multiline_comment|/* Query poletop list */
DECL|variable|CommandString5
r_static
r_const
r_char
id|CommandString5
(braket
)braket
op_assign
l_string|&quot;*&amp;COMMAND*AT~LA&quot;
suffix:semicolon
multiline_comment|/* Query portables list */
DECL|member|string
DECL|member|length
DECL|typedef|StringDescriptor
r_typedef
r_struct
(brace
r_const
r_char
op_star
id|string
suffix:semicolon
r_int
id|length
suffix:semicolon
)brace
id|StringDescriptor
suffix:semicolon
DECL|variable|CommandString
r_static
r_const
id|StringDescriptor
id|CommandString
(braket
)braket
op_assign
(brace
(brace
id|CommandString0
comma
r_sizeof
(paren
id|CommandString0
)paren
op_minus
l_int|1
)brace
comma
(brace
id|CommandString1
comma
r_sizeof
(paren
id|CommandString1
)paren
op_minus
l_int|1
)brace
comma
(brace
id|CommandString2
comma
r_sizeof
(paren
id|CommandString2
)paren
op_minus
l_int|1
)brace
comma
(brace
id|CommandString3
comma
r_sizeof
(paren
id|CommandString3
)paren
op_minus
l_int|1
)brace
comma
(brace
id|CommandString4
comma
r_sizeof
(paren
id|CommandString4
)paren
op_minus
l_int|1
)brace
comma
(brace
id|CommandString5
comma
r_sizeof
(paren
id|CommandString5
)paren
op_minus
l_int|1
)brace
)brace
suffix:semicolon
DECL|macro|GOT_ALL_RADIO_INFO
mdefine_line|#define GOT_ALL_RADIO_INFO(S)      &bslash;&n;    ((S)-&gt;firmware_version.c[0] &amp;&amp; &bslash;&n;     (S)-&gt;battery_voltage.c[0]  &amp;&amp; &bslash;&n;     memcmp(&amp;(S)-&gt;true_dev_addr, zero_address.c, sizeof(zero_address)))
DECL|variable|hextable
r_static
r_const
r_char
id|hextable
(braket
l_int|16
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
DECL|variable|zero_address
r_static
r_const
id|MetricomAddress
id|zero_address
suffix:semicolon
DECL|variable|broadcast_address
r_static
r_const
id|MetricomAddress
id|broadcast_address
op_assign
(brace
(brace
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)brace
)brace
suffix:semicolon
DECL|variable|SIP0Key
r_static
r_const
id|MetricomKey
id|SIP0Key
op_assign
(brace
(brace
l_string|&quot;SIP0&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ARP0Key
r_static
r_const
id|MetricomKey
id|ARP0Key
op_assign
(brace
(brace
l_string|&quot;ARP0&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ATR_Key
r_static
r_const
id|MetricomKey
id|ATR_Key
op_assign
(brace
(brace
l_string|&quot;ATR &quot;
)brace
)brace
suffix:semicolon
DECL|variable|ACK_Key
r_static
r_const
id|MetricomKey
id|ACK_Key
op_assign
(brace
(brace
l_string|&quot;ACK_&quot;
)brace
)brace
suffix:semicolon
DECL|variable|INF_Key
r_static
r_const
id|MetricomKey
id|INF_Key
op_assign
(brace
(brace
l_string|&quot;INF_&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ERR_Key
r_static
r_const
id|MetricomKey
id|ERR_Key
op_assign
(brace
(brace
l_string|&quot;ERR_&quot;
)brace
)brace
suffix:semicolon
DECL|variable|MaxARPInterval
r_static
r_const
r_int
id|MaxARPInterval
op_assign
l_int|60
op_star
id|HZ
suffix:semicolon
multiline_comment|/* One minute */
multiline_comment|/*&n; * Maximum Starmode packet length is 1183 bytes. Allowing 4 bytes for&n; * protocol key, 4 bytes for checksum, one byte for CR, and 65/64 expansion&n; * for STRIP encoding, that translates to a maximum payload MTU of 1155.&n; * Note: A standard NFS 1K data packet is a total of 0x480 (1152) bytes&n; * long, including IP header, UDP header, and NFS header. Setting the STRIP&n; * MTU to 1152 allows us to send default sized NFS packets without fragmentation.&n; */
DECL|variable|MAX_SEND_MTU
r_static
r_const
r_int
r_int
id|MAX_SEND_MTU
op_assign
l_int|1152
suffix:semicolon
DECL|variable|MAX_RECV_MTU
r_static
r_const
r_int
r_int
id|MAX_RECV_MTU
op_assign
l_int|1500
suffix:semicolon
multiline_comment|/* Hoping for Ethernet sized packets in the future! */
DECL|variable|DEFAULT_STRIP_MTU
r_static
r_const
r_int
r_int
id|DEFAULT_STRIP_MTU
op_assign
l_int|1152
suffix:semicolon
DECL|variable|STRIP_MAGIC
r_static
r_const
r_int
id|STRIP_MAGIC
op_assign
l_int|0x5303
suffix:semicolon
DECL|variable|LongTime
r_static
r_const
r_int
id|LongTime
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Global variables&t;&t;&t;&t;&t;&t;&t;*/
DECL|variable|struct_strip_list
r_static
r_struct
id|strip
op_star
id|struct_strip_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Macros&t;&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* Returns TRUE if text T begins with prefix P */
DECL|macro|has_prefix
mdefine_line|#define has_prefix(T,L,P) (((L) &gt;= sizeof(P)-1) &amp;&amp; !strncmp((T), (P), sizeof(P)-1))
multiline_comment|/* Returns TRUE if text T of length L is equal to string S */
DECL|macro|text_equal
mdefine_line|#define text_equal(T,L,S) (((L) == sizeof(S)-1) &amp;&amp; !strncmp((T), (S), sizeof(S)-1))
DECL|macro|READHEX
mdefine_line|#define READHEX(X) ((X)&gt;=&squot;0&squot; &amp;&amp; (X)&lt;=&squot;9&squot; ? (X)-&squot;0&squot; :      &bslash;&n;                    (X)&gt;=&squot;a&squot; &amp;&amp; (X)&lt;=&squot;f&squot; ? (X)-&squot;a&squot;+10 :   &bslash;&n;                    (X)&gt;=&squot;A&squot; &amp;&amp; (X)&lt;=&squot;F&squot; ? (X)-&squot;A&squot;+10 : 0 )
DECL|macro|READHEX16
mdefine_line|#define READHEX16(X) ((__u16)(READHEX(X)))
DECL|macro|READDEC
mdefine_line|#define READDEC(X) ((X)&gt;=&squot;0&squot; &amp;&amp; (X)&lt;=&squot;9&squot; ? (X)-&squot;0&squot; : 0)
DECL|macro|MIN
mdefine_line|#define MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))
DECL|macro|MAX
mdefine_line|#define MAX(X, Y) ((X) &gt; (Y) ? (X) : (Y))
DECL|macro|ELEMENTS_OF
mdefine_line|#define ELEMENTS_OF(X) (sizeof(X) / sizeof((X)[0]))
DECL|macro|ARRAY_END
mdefine_line|#define ARRAY_END(X) (&amp;((X)[ELEMENTS_OF(X)]))
DECL|macro|JIFFIE_TO_SEC
mdefine_line|#define JIFFIE_TO_SEC(X) ((X) / HZ)
multiline_comment|/************************************************************************/
multiline_comment|/* Utility routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|typedef|InterruptStatus
r_typedef
r_int
r_int
id|InterruptStatus
suffix:semicolon
DECL|function|DisableInterrupts
r_extern
id|__inline__
id|InterruptStatus
id|DisableInterrupts
c_func
(paren
r_void
)paren
(brace
id|InterruptStatus
id|x
suffix:semicolon
id|save_flags
c_func
(paren
id|x
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|RestoreInterrupts
r_extern
id|__inline__
r_void
id|RestoreInterrupts
c_func
(paren
id|InterruptStatus
id|x
)paren
(brace
id|restore_flags
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|arp_query
r_static
r_int
id|arp_query
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|neighbour
op_star
id|neighbor_entry
suffix:semicolon
id|neighbor_entry
op_assign
id|neigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|paddr
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|neighbor_entry
op_ne
l_int|NULL
)paren
(brace
id|neighbor_entry-&gt;used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|neighbor_entry-&gt;nud_state
op_amp
id|NUD_VALID
)paren
(brace
id|memcpy
c_func
(paren
id|haddr
comma
id|neighbor_entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|DumpData
r_static
r_void
id|DumpData
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
r_static
r_const
r_int
id|MAX_DumpData
op_assign
l_int|80
suffix:semicolon
id|__u8
id|pkt_text
(braket
id|MAX_DumpData
)braket
comma
op_star
id|p
op_assign
id|pkt_text
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&quot;&squot;
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|p
OL
op_amp
id|pkt_text
(braket
id|MAX_DumpData
op_minus
l_int|4
)braket
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_ge
l_int|32
op_logical_and
op_star
id|ptr
op_le
l_int|126
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|ptr
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;&bslash;%02X&quot;
comma
op_star
id|ptr
)paren
suffix:semicolon
id|p
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
id|ptr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_eq
id|end
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&quot;&squot;
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %-13s%s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|msg
comma
id|pkt_text
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|HexDump
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|start
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|start
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|msg
comma
id|end
op_minus
id|ptr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
)paren
(brace
r_int
id|offset
op_assign
id|ptr
op_minus
id|start
suffix:semicolon
id|__u8
id|text
(braket
l_int|80
)braket
comma
op_star
id|p
op_assign
id|text
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|p
OL
op_amp
id|text
(braket
l_int|16
op_star
l_int|3
)braket
)paren
(brace
op_star
id|p
op_increment
op_assign
id|hextable
(braket
op_star
id|ptr
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|hextable
(braket
op_star
id|ptr
op_increment
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
id|p
(braket
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %4lX %s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|offset
comma
id|text
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/************************************************************************/
multiline_comment|/* Byte stuffing/unstuffing routines&t;&t;&t;&t;&t;*/
multiline_comment|/* Stuffing scheme:&n; * 00    Unused (reserved character)&n; * 01-3F Run of 2-64 different characters&n; * 40-7F Run of 1-64 different characters plus a single zero at the end&n; * 80-BF Run of 1-64 of the same character&n; * C0-FF Run of 1-64 zeroes (ASCII 0)&n; */
r_typedef
r_enum
(brace
DECL|enumerator|Stuff_Diff
id|Stuff_Diff
op_assign
l_int|0x00
comma
DECL|enumerator|Stuff_DiffZero
id|Stuff_DiffZero
op_assign
l_int|0x40
comma
DECL|enumerator|Stuff_Same
id|Stuff_Same
op_assign
l_int|0x80
comma
DECL|enumerator|Stuff_Zero
id|Stuff_Zero
op_assign
l_int|0xC0
comma
DECL|enumerator|Stuff_NoCode
id|Stuff_NoCode
op_assign
l_int|0xFF
comma
multiline_comment|/* Special code, meaning no code selected */
DECL|enumerator|Stuff_CodeMask
id|Stuff_CodeMask
op_assign
l_int|0xC0
comma
DECL|enumerator|Stuff_CountMask
id|Stuff_CountMask
op_assign
l_int|0x3F
comma
DECL|enumerator|Stuff_MaxCount
id|Stuff_MaxCount
op_assign
l_int|0x3F
comma
DECL|enumerator|Stuff_Magic
id|Stuff_Magic
op_assign
l_int|0x0D
multiline_comment|/* The value we are eliminating */
DECL|typedef|StuffingCode
)brace
id|StuffingCode
suffix:semicolon
multiline_comment|/* StuffData encodes the data starting at &quot;src&quot; for &quot;length&quot; bytes.&n; * It writes it to the buffer pointed to by &quot;dst&quot; (which must be at least&n; * as long as 1 + 65/64 of the input length). The output may be up to 1.6%&n; * larger than the input for pathological input, but will usually be smaller.&n; * StuffData returns the new value of the dst pointer as its result.&n; * &quot;code_ptr_ptr&quot; points to a &quot;__u8 *&quot; which is used to hold encoding state&n; * between calls, allowing an encoded packet to be incrementally built up&n; * from small parts. On the first call, the &quot;__u8 *&quot; pointed to should be&n; * initialized to NULL; between subsequent calls the calling routine should&n; * leave the value alone and simply pass it back unchanged so that the&n; * encoder can recover its current state.&n; */
DECL|macro|StuffData_FinishBlock
mdefine_line|#define StuffData_FinishBlock(X) &bslash;&n;(*code_ptr = (X) ^ Stuff_Magic, code = Stuff_NoCode)
DECL|function|StuffData
r_static
id|__u8
op_star
id|StuffData
c_func
(paren
id|__u8
op_star
id|src
comma
id|__u32
id|length
comma
id|__u8
op_star
id|dst
comma
id|__u8
op_star
op_star
id|code_ptr_ptr
)paren
(brace
id|__u8
op_star
id|end
op_assign
id|src
op_plus
id|length
suffix:semicolon
id|__u8
op_star
id|code_ptr
op_assign
op_star
id|code_ptr_ptr
suffix:semicolon
id|__u8
id|code
op_assign
id|Stuff_NoCode
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|code_ptr
)paren
(brace
multiline_comment|/*&n;         * Recover state from last call, if applicable&n;         */
id|code
op_assign
(paren
op_star
id|code_ptr
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CodeMask
suffix:semicolon
id|count
op_assign
(paren
op_star
id|code_ptr
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CountMask
suffix:semicolon
)brace
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
multiline_comment|/* Stuff_NoCode: If no current code, select one */
r_case
id|Stuff_NoCode
suffix:colon
multiline_comment|/* Record where we&squot;re going to put this code */
id|code_ptr
op_assign
id|dst
op_increment
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the count (zero means one instance) */
multiline_comment|/* Tentatively start a new block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|code
op_assign
id|Stuff_Zero
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
id|code
op_assign
id|Stuff_Same
suffix:semicolon
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
multiline_comment|/* Note: We optimistically assume run of same -- */
multiline_comment|/* which will be fixed later in Stuff_Same */
multiline_comment|/* if it turns out not to be true. */
r_break
suffix:semicolon
multiline_comment|/* Stuff_Zero: We already have at least one zero encoded */
r_case
id|Stuff_Zero
suffix:colon
multiline_comment|/* If another zero, count it, else finish this code block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|count
op_increment
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_Zero
op_plus
id|count
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Stuff_Same: We already have at least one byte encoded */
r_case
id|Stuff_Same
suffix:colon
multiline_comment|/* If another one the same, count it */
r_if
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_eq
id|code_ptr
(braket
l_int|1
)braket
)paren
(brace
id|count
op_increment
suffix:semicolon
id|src
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else, this byte does not match this block. */
multiline_comment|/* If we already have two or more bytes encoded, finish this code block */
r_if
c_cond
(paren
id|count
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_Same
op_plus
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else, we only have one so far, so switch to Stuff_Diff code */
id|code
op_assign
id|Stuff_Diff
suffix:semicolon
multiline_comment|/* and fall through to Stuff_Diff case below&n;                 * Note cunning cleverness here: case Stuff_Diff compares &n;                 * the current character with the previous two to see if it&n;                 * has a run of three the same. Won&squot;t this be an error if&n;                 * there aren&squot;t two previous characters stored to compare with?&n;                 * No. Because we know the current character is *not* the same&n;                 * as the previous one, the first test below will necessarily&n;                 * fail and the send half of the &quot;if&quot; won&squot;t be executed.&n;                 */
multiline_comment|/* Stuff_Diff: We have at least two *different* bytes encoded */
r_case
id|Stuff_Diff
suffix:colon
multiline_comment|/* If this is a zero, must encode a Stuff_DiffZero, and begin a new block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_DiffZero
op_plus
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* else, if we have three in a row, it is worth starting a Stuff_Same block */
r_else
r_if
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_eq
id|dst
(braket
op_minus
l_int|1
)braket
op_logical_and
id|dst
(braket
op_minus
l_int|1
)braket
op_eq
id|dst
(braket
op_minus
l_int|2
)braket
)paren
(brace
multiline_comment|/* Back off the last two characters we encoded */
id|code
op_add_assign
id|count
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* Note: &quot;Stuff_Diff + 0&quot; is an illegal code */
r_if
c_cond
(paren
id|code
op_eq
id|Stuff_Diff
op_plus
l_int|0
)paren
(brace
id|code
op_assign
id|Stuff_Same
op_plus
l_int|0
suffix:semicolon
)brace
id|StuffData_FinishBlock
c_func
(paren
id|code
)paren
suffix:semicolon
id|code_ptr
op_assign
id|dst
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* dst[-1] already holds the correct value */
id|count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 2 means three bytes encoded */
id|code
op_assign
id|Stuff_Same
suffix:semicolon
)brace
multiline_comment|/* else, another different byte, so add it to the block */
r_else
(brace
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|src
op_increment
suffix:semicolon
multiline_comment|/* Consume the byte */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
id|Stuff_MaxCount
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|code
op_plus
id|count
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|code
op_eq
id|Stuff_NoCode
)paren
(brace
op_star
id|code_ptr_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|code_ptr_ptr
op_assign
id|code_ptr
suffix:semicolon
id|StuffData_FinishBlock
c_func
(paren
id|code
op_plus
id|count
)paren
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/*&n; * UnStuffData decodes the data at &quot;src&quot;, up to (but not including) &quot;end&quot;.&n; * It writes the decoded data into the buffer pointed to by &quot;dst&quot;, up to a&n; * maximum of &quot;dst_length&quot;, and returns the new value of &quot;src&quot; so that a&n; * follow-on call can read more data, continuing from where the first left off.&n; * &n; * There are three types of results:&n; * 1. The source data runs out before extracting &quot;dst_length&quot; bytes:&n; *    UnStuffData returns NULL to indicate failure.&n; * 2. The source data produces exactly &quot;dst_length&quot; bytes:&n; *    UnStuffData returns new_src = end to indicate that all bytes were consumed.&n; * 3. &quot;dst_length&quot; bytes are extracted, with more remaining.&n; *    UnStuffData returns new_src &lt; end to indicate that there are more bytes&n; *    to be read.&n; * &n; * Note: The decoding may be destructive, in that it may alter the source&n; * data in the process of decoding it (this is necessary to allow a follow-on&n; * call to resume correctly).&n; */
DECL|function|UnStuffData
r_static
id|__u8
op_star
id|UnStuffData
c_func
(paren
id|__u8
op_star
id|src
comma
id|__u8
op_star
id|end
comma
id|__u8
op_star
id|dst
comma
id|__u32
id|dst_length
)paren
(brace
id|__u8
op_star
id|dst_end
op_assign
id|dst
op_plus
id|dst_length
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
op_logical_neg
id|src
op_logical_or
op_logical_neg
id|end
op_logical_or
op_logical_neg
id|dst
op_logical_or
op_logical_neg
id|dst_length
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
r_int
id|count
op_assign
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CountMask
suffix:semicolon
r_switch
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CodeMask
)paren
(brace
r_case
id|Stuff_Diff
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_plus
id|count
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
op_star
op_increment
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
op_star
id|src
op_assign
id|Stuff_Same
op_xor
id|Stuff_Magic
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Diff
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|Stuff_DiffZero
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_plus
id|count
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
op_star
op_increment
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
op_star
id|src
op_assign
id|Stuff_Zero
op_xor
id|Stuff_Magic
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_DiffZero
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Stuff_Same
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
id|src
(braket
l_int|1
)braket
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|2
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Same
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Stuff_Zero
suffix:colon
r_do
(brace
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|1
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Zero
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dst
OL
id|dst_end
)paren
r_return
l_int|NULL
suffix:semicolon
r_else
r_return
id|src
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* General routines for STRIP&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * get_baud returns the current baud rate, as one of the constants defined in&n; * termbits.h&n; * If the user has issued a baud rate override using the &squot;setserial&squot; command&n; * and the logical current rate is set to 38.4, then the true baud rate&n; * currently in effect (57.6 or 115.2) is returned.&n; */
DECL|function|get_baud
r_static
r_int
r_int
id|get_baud
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|tty-&gt;termios
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_eq
id|B38400
op_logical_and
id|tty-&gt;driver_data
)paren
(brace
r_struct
id|async_struct
op_star
id|info
op_assign
(paren
r_struct
id|async_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_HI
)paren
r_return
id|B57600
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_VHI
)paren
r_return
id|B115200
suffix:semicolon
)brace
r_return
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
suffix:semicolon
)brace
multiline_comment|/*&n; * set_baud sets the baud rate to the rate defined by baudcode&n; * Note: The rate B38400 should be avoided, because the user may have&n; * issued a &squot;setserial&squot; speed override to map that to a different speed.&n; * We could achieve a true rate of 38400 if we needed to by cancelling&n; * any user speed override that is in place, but that might annoy the&n; * user, so it is simplest to just avoid using 38400.&n; */
DECL|function|set_baud
r_static
r_void
id|set_baud
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_int
id|baudcode
)paren
(brace
r_struct
id|termios
id|old_termios
op_assign
op_star
(paren
id|tty-&gt;termios
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUD
suffix:semicolon
multiline_comment|/* Clear the old baud setting */
id|tty-&gt;termios-&gt;c_cflag
op_or_assign
id|baudcode
suffix:semicolon
multiline_comment|/* Set the new baud setting */
id|tty-&gt;driver
dot
id|set_termios
c_func
(paren
id|tty
comma
op_amp
id|old_termios
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a string to a Metricom Address.&n; */
DECL|macro|IS_RADIO_ADDRESS
mdefine_line|#define IS_RADIO_ADDRESS(p) (                                                 &bslash;&n;  isdigit((p)[0]) &amp;&amp; isdigit((p)[1]) &amp;&amp; isdigit((p)[2]) &amp;&amp; isdigit((p)[3]) &amp;&amp; &bslash;&n;  (p)[4] == &squot;-&squot; &amp;&amp;                                                            &bslash;&n;  isdigit((p)[5]) &amp;&amp; isdigit((p)[6]) &amp;&amp; isdigit((p)[7]) &amp;&amp; isdigit((p)[8])    )
DECL|function|string_to_radio_address
r_static
r_int
id|string_to_radio_address
c_func
(paren
id|MetricomAddress
op_star
id|addr
comma
id|__u8
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_RADIO_ADDRESS
c_func
(paren
id|p
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|addr-&gt;c
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|addr-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|addr-&gt;c
(braket
l_int|2
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|0
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|addr-&gt;c
(braket
l_int|3
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|2
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|addr-&gt;c
(braket
l_int|4
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|5
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|addr-&gt;c
(braket
l_int|5
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|7
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|8
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a Metricom Address to a string.&n; */
DECL|function|radio_address_to_string
r_static
id|__u8
op_star
id|radio_address_to_string
c_func
(paren
r_const
id|MetricomAddress
op_star
id|addr
comma
id|MetricomAddressString
op_star
id|p
)paren
(brace
id|sprintf
c_func
(paren
id|p-&gt;c
comma
l_string|&quot;%02X%02X-%02X%02X&quot;
comma
id|addr-&gt;c
(braket
l_int|2
)braket
comma
id|addr-&gt;c
(braket
l_int|3
)braket
comma
id|addr-&gt;c
(braket
l_int|4
)braket
comma
id|addr-&gt;c
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_return
id|p-&gt;c
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: Must make sure sx_size is big enough to receive a stuffed&n; * MAX_RECV_MTU packet. Additionally, we also want to ensure that it&squot;s&n; * big enough to receive a large radio neighbour list (currently 4K).&n; */
DECL|function|allocate_buffers
r_static
r_int
id|allocate_buffers
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
r_int
id|sx_size
op_assign
id|MAX
c_func
(paren
id|STRIP_ENCAP_SIZE
c_func
(paren
id|MAX_RECV_MTU
)paren
comma
l_int|4096
)paren
suffix:semicolon
r_int
id|tx_size
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
id|dev-&gt;mtu
)paren
op_plus
id|MaxCommandStringLength
suffix:semicolon
id|__u8
op_star
id|r
op_assign
id|kmalloc
c_func
(paren
id|MAX_RECV_MTU
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|__u8
op_star
id|s
op_assign
id|kmalloc
c_func
(paren
id|sx_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|__u8
op_star
id|t
op_assign
id|kmalloc
c_func
(paren
id|tx_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_logical_and
id|s
op_logical_and
id|t
)paren
(brace
id|strip_info-&gt;rx_buff
op_assign
id|r
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
id|s
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
id|t
suffix:semicolon
id|strip_info-&gt;sx_size
op_assign
id|sx_size
suffix:semicolon
id|strip_info-&gt;tx_size
op_assign
id|tx_size
suffix:semicolon
id|strip_info-&gt;mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
)paren
id|kfree
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * MTU has been changed by the IP layer. Unfortunately we are not told&n; * about this, but we spot it ourselves and fix things up. We could be in&n; * an upcall from the tty driver, or in an ip packet queue.&n; */
DECL|function|strip_changedmtu
r_static
r_void
id|strip_changedmtu
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_int
id|old_mtu
op_assign
id|strip_info-&gt;mtu
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
r_int
r_char
op_star
id|orbuff
op_assign
id|strip_info-&gt;rx_buff
suffix:semicolon
r_int
r_char
op_star
id|osbuff
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
r_int
r_char
op_star
id|otbuff
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|InterruptStatus
id|intstat
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mtu
OG
id|MAX_SEND_MTU
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: MTU exceeds maximum allowable (%d), MTU change cancelled.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|MAX_SEND_MTU
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|old_mtu
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Have to disable interrupts here because we&squot;re reallocating and resizing&n;     * the serial buffers, and we can&squot;t have data arriving in them while we&squot;re&n;     * moving them around in memory. This may cause data to be lost on the serial&n;     * port, but hopefully people won&squot;t change MTU that often.&n;     * Also note, this may not work on a symmetric multi-processor system.&n;     */
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allocate_buffers
c_func
(paren
id|strip_info
)paren
)paren
(brace
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to grow strip buffers, MTU change cancelled.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|old_mtu
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
)paren
(brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_le
id|strip_info-&gt;sx_size
)paren
id|memcpy
c_func
(paren
id|strip_info-&gt;sx_buff
comma
id|osbuff
comma
id|strip_info-&gt;sx_count
)paren
suffix:semicolon
r_else
(brace
id|strip_info-&gt;discard
op_assign
id|strip_info-&gt;sx_count
suffix:semicolon
id|strip_info-&gt;rx_over_errors
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
)paren
(brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
op_le
id|strip_info-&gt;tx_size
)paren
id|memcpy
c_func
(paren
id|strip_info-&gt;tx_buff
comma
id|strip_info-&gt;tx_head
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
r_else
(brace
id|strip_info-&gt;tx_left
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
)brace
)brace
id|strip_info-&gt;tx_head
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: strip MTU changed fom %d to %d.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|old_mtu
comma
id|strip_info-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orbuff
)paren
id|kfree
c_func
(paren
id|orbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|osbuff
)paren
id|kfree
c_func
(paren
id|osbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|otbuff
)paren
id|kfree
c_func
(paren
id|otbuff
)paren
suffix:semicolon
)brace
DECL|function|strip_unlock
r_static
r_void
id|strip_unlock
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
multiline_comment|/*&n;     * Set the timer to go off in one second.&n;     */
id|strip_info-&gt;idle_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Callback routines for exporting information through /proc&t;&t;*/
multiline_comment|/*&n; * This function updates the total amount of data printed so far. It then&n; * determines if the amount of data printed into a buffer  has reached the&n; * offset requested. If it hasn&squot;t, then the buffer is shifted over so that&n; * the next bit of data can be printed over the old bit. If the total&n; * amount printed so far exceeds the total amount requested, then this&n; * function returns 1, otherwise 0.&n; */
r_static
r_int
DECL|function|shift_buffer
id|shift_buffer
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|requested_offset
comma
r_int
id|requested_len
comma
r_int
op_star
id|total
comma
r_int
op_star
id|slop
comma
r_char
op_star
op_star
id|buf
)paren
(brace
r_int
id|printed
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;shift: buffer: %d o: %d l: %d t: %d buf: %d&bslash;n&quot;,&n;           (int) buffer, requested_offset, requested_len, *total,&n;           (int) *buf); */
id|printed
op_assign
op_star
id|buf
op_minus
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_star
id|total
op_plus
id|printed
op_le
id|requested_offset
)paren
(brace
op_star
id|total
op_add_assign
id|printed
suffix:semicolon
op_star
id|buf
op_assign
id|buffer
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|total
OL
id|requested_offset
)paren
(brace
op_star
id|slop
op_assign
id|requested_offset
op_minus
op_star
id|total
suffix:semicolon
)brace
op_star
id|total
op_assign
id|requested_offset
op_plus
id|printed
op_minus
op_star
id|slop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|total
OG
id|requested_offset
op_plus
id|requested_len
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function calculates the actual start of the requested data&n; * in the buffer. It also calculates actual length of data returned,&n; * which could be less that the amount of data requested.&n; */
r_static
r_int
DECL|function|calc_start_len
id|calc_start_len
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
r_int
id|requested_offset
comma
r_int
id|requested_len
comma
r_int
id|total
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|return_len
comma
id|buffer_len
suffix:semicolon
id|buffer_len
op_assign
id|buf
op_minus
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|buffer_len
op_ge
l_int|4095
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: exceeded /proc buffer size&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * There may be bytes before and after the&n;     * chunk that was actually requested.&n;     */
id|return_len
op_assign
id|total
op_minus
id|requested_offset
suffix:semicolon
r_if
c_cond
(paren
id|return_len
OL
l_int|0
)paren
(brace
id|return_len
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buf
op_minus
id|return_len
suffix:semicolon
r_if
c_cond
(paren
id|return_len
OG
id|requested_len
)paren
(brace
id|return_len
op_assign
id|requested_len
suffix:semicolon
)brace
multiline_comment|/* printk(KERN_DEBUG &quot;return_len: %d&bslash;n&quot;, return_len); */
r_return
id|return_len
suffix:semicolon
)brace
multiline_comment|/*&n; * If the time is in the near future, time_delta prints the number of&n; * seconds to go into the buffer and returns the address of the buffer.&n; * If the time is not in the near future, it returns the address of the&n; * string &quot;Not scheduled&quot; The buffer must be long enough to contain the&n; * ascii representation of the number plus 9 charactes for the &quot; seconds&quot;&n; * and the null character.&n; */
DECL|function|time_delta
r_static
r_char
op_star
id|time_delta
c_func
(paren
r_char
id|buffer
(braket
)braket
comma
r_int
id|time
)paren
(brace
id|time
op_sub_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|time
OG
id|LongTime
op_div
l_int|2
)paren
r_return
l_string|&quot;Not scheduled&quot;
suffix:semicolon
r_if
c_cond
(paren
id|time
OL
l_int|0
)paren
(brace
id|time
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t print negative times */
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%ld seconds&quot;
comma
id|time
op_div
id|HZ
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|sprintf_neighbours
r_static
r_int
id|sprintf_neighbours
c_func
(paren
r_char
op_star
id|buffer
comma
id|MetricomNodeTable
op_star
id|table
comma
r_char
op_star
id|title
)paren
(brace
multiline_comment|/* We wrap this in a do/while loop, so if the table changes */
multiline_comment|/* while we&squot;re reading it, we just go around and try again. */
r_struct
id|timeval
id|t
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_do
(brace
r_int
id|i
suffix:semicolon
id|t
op_assign
id|table-&gt;timestamp
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|table-&gt;num_nodes
)paren
id|ptr
op_add_assign
id|sprintf
c_func
(paren
id|ptr
comma
l_string|&quot;&bslash;n %s&bslash;n&quot;
comma
id|title
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|table-&gt;num_nodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|InterruptStatus
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|MetricomNode
id|node
op_assign
id|table-&gt;node
(braket
id|i
)braket
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
id|ptr
op_add_assign
id|sprintf
c_func
(paren
id|ptr
comma
l_string|&quot;  %s&bslash;n&quot;
comma
id|node.c
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|table-&gt;timestamp.tv_sec
op_ne
id|t.tv_sec
op_logical_or
id|table-&gt;timestamp.tv_usec
op_ne
id|t.tv_usec
)paren
suffix:semicolon
r_return
id|ptr
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * This function prints radio status information into the specified buffer.&n; * I think the buffer size is 4K, so this routine should never print more&n; * than 4K of data into it. With the maximum of 32 portables and 32 poletops&n; * reported, the routine outputs 3107 bytes into the buffer.&n; */
r_static
r_int
DECL|function|sprintf_status_info
id|sprintf_status_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_char
id|temp
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buffer
suffix:semicolon
id|MetricomAddressString
id|addr_string
suffix:semicolon
multiline_comment|/* First, we must copy all of our data to a safe place, */
multiline_comment|/* in case a serial interrupt comes in and changes it.  */
id|InterruptStatus
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
r_int
id|tx_left
op_assign
id|strip_info-&gt;tx_left
suffix:semicolon
r_int
r_int
id|rx_average_pps
op_assign
id|strip_info-&gt;rx_average_pps
suffix:semicolon
r_int
r_int
id|tx_average_pps
op_assign
id|strip_info-&gt;tx_average_pps
suffix:semicolon
r_int
r_int
id|sx_average_pps
op_assign
id|strip_info-&gt;sx_average_pps
suffix:semicolon
r_int
id|working
op_assign
id|strip_info-&gt;working
suffix:semicolon
r_int
id|firmware_level
op_assign
id|strip_info-&gt;firmware_level
suffix:semicolon
r_int
id|watchdog_doprobe
op_assign
id|strip_info-&gt;watchdog_doprobe
suffix:semicolon
r_int
id|watchdog_doreset
op_assign
id|strip_info-&gt;watchdog_doreset
suffix:semicolon
r_int
id|gratuitous_arp
op_assign
id|strip_info-&gt;gratuitous_arp
suffix:semicolon
r_int
id|arp_interval
op_assign
id|strip_info-&gt;arp_interval
suffix:semicolon
id|FirmwareVersion
id|firmware_version
op_assign
id|strip_info-&gt;firmware_version
suffix:semicolon
id|SerialNumber
id|serial_number
op_assign
id|strip_info-&gt;serial_number
suffix:semicolon
id|BatteryVoltage
id|battery_voltage
op_assign
id|strip_info-&gt;battery_voltage
suffix:semicolon
r_char
op_star
id|if_name
op_assign
id|strip_info-&gt;dev.name
suffix:semicolon
id|MetricomAddress
id|true_dev_addr
op_assign
id|strip_info-&gt;true_dev_addr
suffix:semicolon
id|MetricomAddress
id|dev_dev_addr
op_assign
op_star
(paren
id|MetricomAddress
op_star
)paren
id|strip_info-&gt;dev.dev_addr
suffix:semicolon
r_int
id|manual_dev_addr
op_assign
id|strip_info-&gt;manual_dev_addr
suffix:semicolon
macro_line|#ifdef EXT_COUNTERS
r_int
r_int
id|rx_bytes
op_assign
id|strip_info-&gt;rx_bytes
suffix:semicolon
r_int
r_int
id|tx_bytes
op_assign
id|strip_info-&gt;tx_bytes
suffix:semicolon
r_int
r_int
id|rx_rbytes
op_assign
id|strip_info-&gt;rx_rbytes
suffix:semicolon
r_int
r_int
id|tx_rbytes
op_assign
id|strip_info-&gt;tx_rbytes
suffix:semicolon
r_int
r_int
id|rx_sbytes
op_assign
id|strip_info-&gt;rx_sbytes
suffix:semicolon
r_int
r_int
id|tx_sbytes
op_assign
id|strip_info-&gt;tx_sbytes
suffix:semicolon
r_int
r_int
id|rx_ebytes
op_assign
id|strip_info-&gt;rx_ebytes
suffix:semicolon
r_int
r_int
id|tx_ebytes
op_assign
id|strip_info-&gt;tx_ebytes
suffix:semicolon
macro_line|#endif
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nInterface name&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|if_name
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Radio working:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|working
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|radio_address_to_string
c_func
(paren
op_amp
id|true_dev_addr
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Radio address:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|addr_string.c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|manual_dev_addr
)paren
(brace
id|radio_address_to_string
c_func
(paren
op_amp
id|dev_dev_addr
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Device address:&bslash;t%s&bslash;n&quot;
comma
id|addr_string.c
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Firmware version:&bslash;t%s&quot;
comma
op_logical_neg
id|working
ques
c_cond
l_string|&quot;Unknown&quot;
suffix:colon
op_logical_neg
id|firmware_level
ques
c_cond
l_string|&quot;Should be upgraded&quot;
suffix:colon
id|firmware_version.c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|firmware_level
op_ge
id|ChecksummedMessages
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; (Checksums Enabled)&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Serial number:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|serial_number.c
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Battery voltage:&bslash;t%s&bslash;n&quot;
comma
id|battery_voltage.c
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Transmit queue (bytes):%d&bslash;n&quot;
comma
id|tx_left
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Receive packet rate:   %ld packets per second&bslash;n&quot;
comma
id|rx_average_pps
op_div
l_int|8
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Transmit packet rate:  %ld packets per second&bslash;n&quot;
comma
id|tx_average_pps
op_div
l_int|8
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Sent packet rate:      %ld packets per second&bslash;n&quot;
comma
id|sx_average_pps
op_div
l_int|8
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Next watchdog probe:&bslash;t%s&bslash;n&quot;
comma
id|time_delta
c_func
(paren
id|temp
comma
id|watchdog_doprobe
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Next watchdog reset:&bslash;t%s&bslash;n&quot;
comma
id|time_delta
c_func
(paren
id|temp
comma
id|watchdog_doreset
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Next gratuitous ARP:&bslash;t&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|strip_info-&gt;dev.dev_addr
comma
id|zero_address.c
comma
r_sizeof
(paren
id|zero_address
)paren
)paren
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Disabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|time_delta
c_func
(paren
id|temp
comma
id|gratuitous_arp
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Next ARP interval:&bslash;t%ld seconds&bslash;n&quot;
comma
id|JIFFIE_TO_SEC
c_func
(paren
id|arp_interval
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|working
)paren
(brace
macro_line|#ifdef EXT_COUNTERS
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Total bytes:         &bslash;trx:&bslash;t%lu&bslash;ttx:&bslash;t%lu&bslash;n&quot;
comma
id|rx_bytes
comma
id|tx_bytes
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;  thru radio:         &bslash;trx:&bslash;t%lu&bslash;ttx:&bslash;t%lu&bslash;n&quot;
comma
id|rx_rbytes
comma
id|tx_rbytes
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;  thru serial port:   &bslash;trx:&bslash;t%lu&bslash;ttx:&bslash;t%lu&bslash;n&quot;
comma
id|rx_sbytes
comma
id|tx_sbytes
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; Total stat/err bytes:&bslash;trx:&bslash;t%lu&bslash;ttx:&bslash;t%lu&bslash;n&quot;
comma
id|rx_ebytes
comma
id|tx_ebytes
)paren
suffix:semicolon
macro_line|#endif
id|p
op_add_assign
id|sprintf_neighbours
c_func
(paren
id|p
comma
op_amp
id|strip_info-&gt;poletops
comma
l_string|&quot;Poletops:&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf_neighbours
c_func
(paren
id|p
comma
op_amp
id|strip_info-&gt;portables
comma
l_string|&quot;Portables:&quot;
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is exports status information from the STRIP driver through&n; * the /proc file system.&n; */
DECL|function|get_status_info
r_static
r_int
id|get_status_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|req_offset
comma
r_int
id|req_len
)paren
(brace
r_int
id|total
op_assign
l_int|0
comma
id|slop
op_assign
l_int|0
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
id|struct_strip_list
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;strip_version: %s&bslash;n&quot;
comma
id|StripVersion
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift_buffer
c_func
(paren
id|buffer
comma
id|req_offset
comma
id|req_len
comma
op_amp
id|total
comma
op_amp
id|slop
comma
op_amp
id|buf
)paren
)paren
r_goto
m_exit
suffix:semicolon
r_while
c_loop
(paren
id|strip_info
op_ne
l_int|NULL
)paren
(brace
id|buf
op_add_assign
id|sprintf_status_info
c_func
(paren
id|buf
comma
id|strip_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift_buffer
c_func
(paren
id|buffer
comma
id|req_offset
comma
id|req_len
comma
op_amp
id|total
comma
op_amp
id|slop
comma
op_amp
id|buf
)paren
)paren
r_break
suffix:semicolon
id|strip_info
op_assign
id|strip_info-&gt;next
suffix:semicolon
)brace
m_exit
suffix:colon
r_return
id|calc_start_len
c_func
(paren
id|buffer
comma
id|start
comma
id|req_offset
comma
id|req_len
comma
id|total
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Sending routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|function|ResetRadio
r_static
r_void
id|ResetRadio
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|strip_info-&gt;tty
suffix:semicolon
r_static
r_const
r_char
id|init
(braket
)braket
op_assign
l_string|&quot;ate0q1dt**starmode&bslash;r**&quot;
suffix:semicolon
id|StringDescriptor
id|s
op_assign
(brace
id|init
comma
r_sizeof
(paren
id|init
)paren
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/* &n;     * If the radio isn&squot;t working anymore,&n;     * we should clear the old status information.&n;     */
r_if
c_cond
(paren
id|strip_info-&gt;working
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: No response: Resetting radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;firmware_version.c
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strip_info-&gt;serial_number.c
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strip_info-&gt;battery_voltage.c
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strip_info-&gt;portables.num_nodes
op_assign
l_int|0
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|strip_info-&gt;portables.timestamp
)paren
suffix:semicolon
id|strip_info-&gt;poletops.num_nodes
op_assign
l_int|0
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|strip_info-&gt;poletops.timestamp
)paren
suffix:semicolon
)brace
id|strip_info-&gt;pps_timer
op_assign
id|jiffies
suffix:semicolon
id|strip_info-&gt;rx_pps_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_pps_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;sx_pps_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;rx_average_pps
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_average_pps
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;sx_average_pps
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark radio address as unknown */
op_star
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|strip_info-&gt;true_dev_addr
op_assign
id|zero_address
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;manual_dev_addr
)paren
op_star
(paren
id|MetricomAddress
op_star
)paren
id|strip_info-&gt;dev.dev_addr
op_assign
id|zero_address
suffix:semicolon
id|strip_info-&gt;working
op_assign
id|FALSE
suffix:semicolon
id|strip_info-&gt;firmware_level
op_assign
id|NoStructure
suffix:semicolon
id|strip_info-&gt;next_command
op_assign
id|CompatibilityCommand
suffix:semicolon
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
multiline_comment|/* If the user has selected a baud rate above 38.4 see what magic we have to do */
r_if
c_cond
(paren
id|strip_info-&gt;user_baud
OG
id|B38400
)paren
(brace
multiline_comment|/*&n;         * Subtle stuff: Pay attention :-)&n;         * If the serial port is currently at the user&squot;s selected (&gt;38.4) rate,&n;         * then we temporarily switch to 19.2 and issue the ATS304 command&n;         * to tell the radio to switch to the user&squot;s selected rate.&n;         * If the serial port is not currently at that rate, that means we just&n;         * issued the ATS304 command last time through, so this time we restore&n;         * the user&squot;s selected rate and issue the normal starmode reset string.&n;         */
r_if
c_cond
(paren
id|strip_info-&gt;user_baud
op_eq
id|get_baud
c_func
(paren
id|tty
)paren
)paren
(brace
r_static
r_const
r_char
id|b0
(braket
)braket
op_assign
l_string|&quot;ate0q1s304=57600&bslash;r&quot;
suffix:semicolon
r_static
r_const
r_char
id|b1
(braket
)braket
op_assign
l_string|&quot;ate0q1s304=115200&bslash;r&quot;
suffix:semicolon
r_static
r_const
id|StringDescriptor
id|baudstring
(braket
l_int|2
)braket
op_assign
(brace
(brace
id|b0
comma
r_sizeof
(paren
id|b0
)paren
op_minus
l_int|1
)brace
comma
(brace
id|b1
comma
r_sizeof
(paren
id|b1
)paren
op_minus
l_int|1
)brace
)brace
suffix:semicolon
id|set_baud
c_func
(paren
id|tty
comma
id|B19200
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;user_baud
op_eq
id|B57600
)paren
id|s
op_assign
id|baudstring
(braket
l_int|0
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strip_info-&gt;user_baud
op_eq
id|B115200
)paren
id|s
op_assign
id|baudstring
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|s
op_assign
id|baudstring
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* For now */
)brace
r_else
id|set_baud
c_func
(paren
id|tty
comma
id|strip_info-&gt;user_baud
)paren
suffix:semicolon
)brace
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|s.string
comma
id|s.length
)paren
suffix:semicolon
macro_line|#ifdef EXT_COUNTERS
id|strip_info-&gt;tx_ebytes
op_add_assign
id|s.length
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Called by the driver when there&squot;s room for more data.  If we have&n; * more packets to send, we send them here.&n; */
DECL|function|strip_write_some_more
r_static
r_void
id|strip_write_some_more
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
op_logical_or
op_logical_neg
id|netif_running
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;         * If some data left, send it&n;         * Note: There&squot;s a kernel design bug here. The write_wakeup routine has to&n;         * know how many bytes were written in the previous call, but the number of&n;         * bytes written is returned as the result of the tty-&gt;driver.write call,&n;         * and there&squot;s no guarantee that the tty-&gt;driver.write routine will have&n;         * returned before the write_wakeup routine is invoked. If the PC has fast&n;         * Serial DMA hardware, then it&squot;s quite possible that the write could complete&n;         * almost instantaneously, meaning that my write_wakeup routine could be&n;         * called immediately, before tty-&gt;driver.write has had a chance to return&n;         * the number of bytes that it wrote. In an attempt to guard against this,&n;         * I disable interrupts around the call to tty-&gt;driver.write, although even&n;         * this might not work on a symmetric multi-processor system.&n;         */
id|InterruptStatus
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
r_int
id|num_written
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|strip_info-&gt;tx_head
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
id|strip_info-&gt;tx_left
op_sub_assign
id|num_written
suffix:semicolon
id|strip_info-&gt;tx_head
op_add_assign
id|num_written
suffix:semicolon
macro_line|#ifdef EXT_COUNTERS
id|strip_info-&gt;tx_sbytes
op_add_assign
id|num_written
suffix:semicolon
macro_line|#endif
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Else start transmission of another packet */
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|strip_unlock
c_func
(paren
id|strip_info
)paren
suffix:semicolon
)brace
)brace
DECL|function|add_checksum
r_static
id|__u8
op_star
id|add_checksum
c_func
(paren
id|__u8
op_star
id|buffer
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u16
id|sum
op_assign
l_int|0
suffix:semicolon
id|__u8
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
)paren
id|sum
op_add_assign
op_star
id|p
op_increment
suffix:semicolon
id|end
(braket
l_int|3
)braket
op_assign
id|hextable
(braket
id|sum
op_amp
l_int|0xF
)braket
suffix:semicolon
id|sum
op_rshift_assign
l_int|4
suffix:semicolon
id|end
(braket
l_int|2
)braket
op_assign
id|hextable
(braket
id|sum
op_amp
l_int|0xF
)braket
suffix:semicolon
id|sum
op_rshift_assign
l_int|4
suffix:semicolon
id|end
(braket
l_int|1
)braket
op_assign
id|hextable
(braket
id|sum
op_amp
l_int|0xF
)braket
suffix:semicolon
id|sum
op_rshift_assign
l_int|4
suffix:semicolon
id|end
(braket
l_int|0
)braket
op_assign
id|hextable
(braket
id|sum
op_amp
l_int|0xF
)braket
suffix:semicolon
r_return
id|end
op_plus
l_int|4
suffix:semicolon
)brace
DECL|function|strip_make_packet
r_static
r_int
r_char
op_star
id|strip_make_packet
c_func
(paren
r_int
r_char
op_star
id|buffer
comma
r_struct
id|strip
op_star
id|strip_info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
id|__u8
op_star
id|stuffstate
op_assign
l_int|NULL
suffix:semicolon
id|STRIP_Header
op_star
id|header
op_assign
(paren
id|STRIP_Header
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|MetricomAddress
id|haddr
op_assign
id|header-&gt;dst_addr
suffix:semicolon
r_int
id|len
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
id|STRIP_Header
)paren
suffix:semicolon
id|MetricomKey
id|key
suffix:semicolon
multiline_comment|/*HexDump(&quot;strip_make_packet&quot;, strip_info, skb-&gt;data, skb-&gt;data + skb-&gt;len);*/
r_if
c_cond
(paren
id|header-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
id|key
op_assign
id|SIP0Key
suffix:semicolon
r_else
r_if
c_cond
(paren
id|header-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
)paren
id|key
op_assign
id|ARP0Key
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: strip_make_packet: Unknown packet type 0x%04X&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|ntohs
c_func
(paren
id|header-&gt;protocol
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|strip_info-&gt;mtu
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Dropping oversized transmit packet: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|len
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we&squot;re sending to ourselves, discard the packet.&n;     * (Metricom radios choke if they try to send a packet to their own address.)&n;     */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|haddr.c
comma
id|strip_info-&gt;true_dev_addr.c
comma
r_sizeof
(paren
id|haddr
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Dropping packet addressed to self&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * If this is a broadcast packet, send it to our designated Metricom&n;     * &squot;broadcast hub&squot; radio (First byte of address being 0xFF means broadcast)&n;     */
r_if
c_cond
(paren
id|haddr.c
(braket
l_int|0
)braket
op_eq
l_int|0xFF
)paren
(brace
id|u32
id|brd
op_assign
l_int|0
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list
)paren
id|brd
op_assign
id|in_dev-&gt;ifa_list-&gt;ifa_broadcast
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
multiline_comment|/* arp_query returns 1 if it succeeds in looking up the address, 0 if it fails */
r_if
c_cond
(paren
op_logical_neg
id|arp_query
c_func
(paren
id|haddr.c
comma
id|brd
comma
op_amp
id|strip_info-&gt;dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to send packet (no broadcast hub configured)&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we are the broadcast hub, don&squot;t bother sending to ourselves.&n;&t; * (Metricom radios choke if they try to send a packet to their own address.)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|haddr.c
comma
id|strip_info-&gt;true_dev_addr.c
comma
r_sizeof
(paren
id|haddr
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|ptr
op_increment
op_assign
l_int|0x0D
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|2
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|2
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|3
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|3
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|4
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|4
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|5
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|5
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|1
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|2
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|3
)braket
suffix:semicolon
id|ptr
op_assign
id|StuffData
c_func
(paren
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|STRIP_Header
)paren
comma
id|len
comma
id|ptr
comma
op_amp
id|stuffstate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;firmware_level
op_ge
id|ChecksummedMessages
)paren
id|ptr
op_assign
id|add_checksum
c_func
(paren
id|buffer
op_plus
l_int|1
comma
id|ptr
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0x0D
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
DECL|function|strip_send
r_static
r_void
id|strip_send
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|MetricomAddress
id|haddr
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
r_int
id|doreset
op_assign
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doreset
op_ge
l_int|0
suffix:semicolon
r_int
id|doprobe
op_assign
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doprobe
op_ge
l_int|0
op_logical_and
op_logical_neg
id|doreset
suffix:semicolon
id|u32
id|addr
comma
id|brd
suffix:semicolon
multiline_comment|/*&n;     * 1. If we have a packet, encapsulate it and put it in the buffer&n;     */
r_if
c_cond
(paren
id|skb
)paren
(brace
r_char
op_star
id|newptr
op_assign
id|strip_make_packet
c_func
(paren
id|ptr
comma
id|strip_info
comma
id|skb
)paren
suffix:semicolon
id|strip_info-&gt;tx_pps_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newptr
)paren
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
r_else
(brace
id|ptr
op_assign
id|newptr
suffix:semicolon
id|strip_info-&gt;sx_pps_count
op_increment
suffix:semicolon
id|strip_info-&gt;tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Count another successful packet */
macro_line|#ifdef EXT_COUNTERS
id|strip_info-&gt;tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|strip_info-&gt;tx_rbytes
op_add_assign
id|ptr
op_minus
id|strip_info-&gt;tx_buff
suffix:semicolon
macro_line|#endif
multiline_comment|/*DumpData(&quot;Sending:&quot;, strip_info, strip_info-&gt;tx_buff, ptr);*/
multiline_comment|/*HexDump(&quot;Sending&quot;, strip_info, strip_info-&gt;tx_buff, ptr);*/
)brace
)brace
multiline_comment|/*&n;     * 2. If it is time for another tickle, tack it on, after the packet&n;     */
r_if
c_cond
(paren
id|doprobe
)paren
(brace
id|StringDescriptor
id|ts
op_assign
id|CommandString
(braket
id|strip_info-&gt;next_command
)braket
suffix:semicolon
macro_line|#if TICKLE_TIMERS
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;**** Sending tickle string %d      at %02d.%06d&bslash;n&quot;
comma
id|strip_info-&gt;next_command
comma
id|tv.tv_sec
op_mod
l_int|100
comma
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ptr
op_eq
id|strip_info-&gt;tx_buff
)paren
op_star
id|ptr
op_increment
op_assign
l_int|0x0D
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
multiline_comment|/* First send &quot;**&quot; to provoke an error message */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
multiline_comment|/* Then add the command */
id|memcpy
c_func
(paren
id|ptr
comma
id|ts.string
comma
id|ts.length
)paren
suffix:semicolon
multiline_comment|/* Add a checksum ? */
r_if
c_cond
(paren
id|strip_info-&gt;firmware_level
OL
id|ChecksummedMessages
)paren
id|ptr
op_add_assign
id|ts.length
suffix:semicolon
r_else
id|ptr
op_assign
id|add_checksum
c_func
(paren
id|ptr
comma
id|ptr
op_plus
id|ts.length
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0x0D
suffix:semicolon
multiline_comment|/* Terminate the command with a &lt;CR&gt; */
multiline_comment|/* Cycle to next periodic command? */
r_if
c_cond
(paren
id|strip_info-&gt;firmware_level
op_ge
id|StructuredMessages
)paren
r_if
c_cond
(paren
op_increment
id|strip_info-&gt;next_command
op_ge
id|ELEMENTS_OF
c_func
(paren
id|CommandString
)paren
)paren
id|strip_info-&gt;next_command
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef EXT_COUNTERS
id|strip_info-&gt;tx_ebytes
op_add_assign
id|ts.length
suffix:semicolon
macro_line|#endif
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
multiline_comment|/*printk(KERN_INFO &quot;%s: Routine radio test.&bslash;n&quot;, strip_info-&gt;dev.name);*/
)brace
multiline_comment|/*&n;     * 3. Set up the strip_info ready to send the data (if any).&n;     */
id|strip_info-&gt;tx_head
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tx_left
op_assign
id|ptr
op_minus
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
multiline_comment|/*&n;     * 4. Debugging check to make sure we&squot;re not overflowing the buffer.&n;     */
r_if
c_cond
(paren
id|strip_info-&gt;tx_size
op_minus
id|strip_info-&gt;tx_left
OL
l_int|20
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Sending%5d bytes;%5d bytes free.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|strip_info-&gt;tx_left
comma
id|strip_info-&gt;tx_size
op_minus
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
multiline_comment|/*&n;     * 5. If watchdog has expired, reset the radio. Note: if there&squot;s data waiting in&n;     * the buffer, strip_write_some_more will send it after the reset has finished&n;     */
r_if
c_cond
(paren
id|doreset
)paren
(brace
id|ResetRadio
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|1
)paren
(brace
r_struct
id|in_device
op_star
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|brd
op_assign
id|addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list
)paren
(brace
id|brd
op_assign
id|in_dev-&gt;ifa_list-&gt;ifa_broadcast
suffix:semicolon
id|addr
op_assign
id|in_dev-&gt;ifa_list-&gt;ifa_local
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * 6. If it is time for a periodic ARP, queue one up to be sent.&n;     * We only do this if:&n;     *  1. The radio is working&n;     *  2. It&squot;s time to send another periodic ARP&n;     *  3. We really know what our address is (and it is not manually set to zero)&n;     *  4. We have a designated broadcast address configured&n;     * If we queue up an ARP packet when we don&squot;t have a designated broadcast&n;     * address configured, then the packet will just have to be discarded in&n;     * strip_make_packet. This is not fatal, but it causes misleading information&n;     * to be displayed in tcpdump. tcpdump will report that periodic APRs are&n;     * being sent, when in fact they are not, because they are all being dropped&n;     * in the strip_make_packet routine.&n;     */
r_if
c_cond
(paren
id|strip_info-&gt;working
op_logical_and
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;gratuitous_arp
op_ge
l_int|0
op_logical_and
id|memcmp
c_func
(paren
id|strip_info-&gt;dev.dev_addr
comma
id|zero_address.c
comma
r_sizeof
(paren
id|zero_address
)paren
)paren
op_logical_and
id|arp_query
c_func
(paren
id|haddr.c
comma
id|brd
comma
op_amp
id|strip_info-&gt;dev
)paren
)paren
(brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Sending gratuitous ARP with interval %ld&bslash;n&quot;,&n;            strip_info-&gt;dev.name, strip_info-&gt;arp_interval / HZ);*/
id|strip_info-&gt;gratuitous_arp
op_assign
id|jiffies
op_plus
id|strip_info-&gt;arp_interval
suffix:semicolon
id|strip_info-&gt;arp_interval
op_mul_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;arp_interval
OG
id|MaxARPInterval
)paren
id|strip_info-&gt;arp_interval
op_assign
id|MaxARPInterval
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|addr
comma
multiline_comment|/* Target address of ARP packet is our address */
op_amp
id|strip_info-&gt;dev
comma
multiline_comment|/* Device to send packet on */
id|addr
comma
multiline_comment|/* Source IP address this ARP packet comes from */
l_int|NULL
comma
multiline_comment|/* Destination HW address is NULL (broadcast it) */
id|strip_info-&gt;dev.dev_addr
comma
multiline_comment|/* Source HW address is our HW address */
id|strip_info-&gt;dev.dev_addr
)paren
suffix:semicolon
multiline_comment|/* Target HW address is our HW address (redundant) */
)brace
multiline_comment|/*&n;     * 7. All ready. Start the transmission&n;     */
id|strip_write_some_more
c_func
(paren
id|strip_info-&gt;tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Encapsulate a datagram and kick it into a TTY queue. */
DECL|function|strip_xmit
r_static
r_int
id|strip_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: xmit call when iface is down&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
multiline_comment|/* See if someone has been ifconfigging */
r_if
c_cond
(paren
id|strip_info-&gt;mtu
op_ne
id|strip_info-&gt;dev.mtu
)paren
id|strip_changedmtu
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|strip_info-&gt;pps_timer
OG
id|HZ
)paren
(brace
r_int
r_int
id|t
op_assign
id|jiffies
op_minus
id|strip_info-&gt;pps_timer
suffix:semicolon
r_int
r_int
id|rx_pps_count
op_assign
(paren
id|strip_info-&gt;rx_pps_count
op_star
id|HZ
op_star
l_int|8
op_plus
id|t
op_div
l_int|2
)paren
op_div
id|t
suffix:semicolon
r_int
r_int
id|tx_pps_count
op_assign
(paren
id|strip_info-&gt;tx_pps_count
op_star
id|HZ
op_star
l_int|8
op_plus
id|t
op_div
l_int|2
)paren
op_div
id|t
suffix:semicolon
r_int
r_int
id|sx_pps_count
op_assign
(paren
id|strip_info-&gt;sx_pps_count
op_star
id|HZ
op_star
l_int|8
op_plus
id|t
op_div
l_int|2
)paren
op_div
id|t
suffix:semicolon
id|strip_info-&gt;pps_timer
op_assign
id|jiffies
suffix:semicolon
id|strip_info-&gt;rx_pps_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_pps_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;sx_pps_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;rx_average_pps
op_assign
(paren
id|strip_info-&gt;rx_average_pps
op_plus
id|rx_pps_count
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
id|strip_info-&gt;tx_average_pps
op_assign
(paren
id|strip_info-&gt;tx_average_pps
op_plus
id|tx_pps_count
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
id|strip_info-&gt;sx_average_pps
op_assign
(paren
id|strip_info-&gt;sx_average_pps
op_plus
id|sx_pps_count
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|rx_pps_count
op_div
l_int|8
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: WARNING: Receiving %ld packets per second.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|rx_pps_count
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tx_pps_count
op_div
l_int|8
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: WARNING: Tx        %ld packets per second.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|tx_pps_count
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_pps_count
op_div
l_int|8
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: WARNING: Sending   %ld packets per second.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|sx_pps_count
op_div
l_int|8
)paren
suffix:semicolon
)brace
id|strip_send
c_func
(paren
id|strip_info
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * IdleTask periodically calls strip_xmit, so even when we have no IP packets&n; * to send for an extended period of time, the watchdog processing still gets&n; * done to ensure that the radio stays in Starmode&n; */
DECL|function|strip_IdleTask
r_static
r_void
id|strip_IdleTask
c_func
(paren
r_int
r_int
id|parameter
)paren
(brace
id|strip_xmit
c_func
(paren
l_int|NULL
comma
(paren
r_struct
id|net_device
op_star
)paren
id|parameter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the MAC header for an arbitrary protocol layer&n; *&n; * saddr!=NULL        means use this specific address (n/a for Metricom)&n; * saddr==NULL        means use default device source address&n; * daddr!=NULL        means use this destination address&n; * daddr==NULL        means leave destination address alone&n; *                 (e.g. unresolved arp -- kernel will call&n; *                 rebuild_header later to fill in the address)&n; */
DECL|function|strip_header
r_static
r_int
id|strip_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|STRIP_Header
op_star
id|header
op_assign
(paren
id|STRIP_Header
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
suffix:semicolon
multiline_comment|/*printk(KERN_INFO &quot;%s: strip_header 0x%04X %s&bslash;n&quot;, dev-&gt;name, type,&n;        type == ETH_P_IP ? &quot;IP&quot; : type == ETH_P_ARP ? &quot;ARP&quot; : &quot;&quot;);*/
id|header-&gt;src_addr
op_assign
id|strip_info-&gt;true_dev_addr
suffix:semicolon
id|header-&gt;protocol
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
multiline_comment|/*HexDump(&quot;strip_header&quot;, (struct strip *)(dev-&gt;priv), skb-&gt;data, skb-&gt;data + skb-&gt;len);*/
r_if
c_cond
(paren
op_logical_neg
id|daddr
)paren
r_return
op_minus
id|dev-&gt;hard_header_len
suffix:semicolon
id|header-&gt;dst_addr
op_assign
op_star
(paren
id|MetricomAddress
op_star
)paren
id|daddr
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
multiline_comment|/*&n; * Rebuild the MAC header. This is called after an ARP&n; * (or in future other address resolution) has completed on this&n; * sk_buff. We now let ARP fill in the other fields.&n; * I think this should return zero if packet is ready to send,&n; * or non-zero if it needs more time to do an address lookup&n; */
DECL|function|strip_rebuild_header
r_static
r_int
id|strip_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef CONFIG_INET
id|STRIP_Header
op_star
id|header
op_assign
(paren
id|STRIP_Header
op_star
)paren
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Arp find returns zero if if knows the address, */
multiline_comment|/* or if it doesn&squot;t know the address it sends an ARP packet and returns non-zero */
r_return
id|arp_find
c_func
(paren
id|header-&gt;dst_addr.c
comma
id|skb
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Receiving routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|function|strip_receive_room
r_static
r_int
id|strip_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|0x10000
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/*&n; * This function parses the response to the ATS300? command,&n; * extracting the radio version and serial number.&n; */
DECL|function|get_radio_version
r_static
r_void
id|get_radio_version
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u8
op_star
id|p
comma
op_star
id|value_begin
comma
op_star
id|value_end
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Determine the beginning of the second line of the payload */
id|p
op_assign
id|ptr
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|value_begin
op_assign
id|p
suffix:semicolon
multiline_comment|/* Determine the end of line */
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
id|value_end
op_assign
id|p
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|len
op_assign
id|value_end
op_minus
id|value_begin
suffix:semicolon
id|len
op_assign
id|MIN
c_func
(paren
id|len
comma
r_sizeof
(paren
id|FirmwareVersion
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;firmware_version.c
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio Firmware: %.*s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|len
comma
id|value_begin
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|strip_info-&gt;firmware_version.c
comma
l_string|&quot;%.*s&quot;
comma
id|len
comma
id|value_begin
)paren
suffix:semicolon
multiline_comment|/* Look for the first colon */
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
multiline_comment|/* Skip over the space */
id|p
op_add_assign
l_int|2
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|SerialNumber
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p
op_plus
id|len
op_le
id|end
)paren
(brace
id|sprintf
c_func
(paren
id|strip_info-&gt;serial_number.c
comma
l_string|&quot;%.*s&quot;
comma
id|len
comma
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;STRIP: radio serial number shorter (%d) than expected (%d)&bslash;n&quot;
comma
id|end
op_minus
id|p
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function parses the response to the ATS325? command,&n; * extracting the radio battery voltage.&n; */
DECL|function|get_radio_voltage
r_static
r_void
id|get_radio_voltage
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|BatteryVoltage
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_plus
id|len
op_le
id|end
)paren
(brace
id|sprintf
c_func
(paren
id|strip_info-&gt;battery_voltage.c
comma
l_string|&quot;%.*s&quot;
comma
id|len
comma
id|ptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;STRIP: radio voltage string shorter (%d) than expected (%d)&bslash;n&quot;
comma
id|end
op_minus
id|ptr
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function parses the responses to the AT~LA and ATS311 commands,&n; * which list the radio&squot;s neighbours.&n; */
DECL|function|get_radio_neighbours
r_static
r_void
id|get_radio_neighbours
c_func
(paren
id|MetricomNodeTable
op_star
id|table
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|table-&gt;num_nodes
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|table-&gt;num_nodes
OL
id|NODE_TABLE_SIZE
)paren
(brace
id|MetricomNode
op_star
id|node
op_assign
op_amp
id|table-&gt;node
(braket
id|table-&gt;num_nodes
op_increment
)braket
suffix:semicolon
r_char
op_star
id|dst
op_assign
id|node-&gt;c
comma
op_star
id|limit
op_assign
id|dst
op_plus
r_sizeof
(paren
op_star
id|node
)paren
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
op_star
id|ptr
op_le
l_int|32
)paren
id|ptr
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|dst
OL
id|limit
op_logical_and
op_star
id|ptr
op_ne
l_int|10
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|ptr
(braket
op_minus
l_int|1
)braket
op_ne
l_int|10
)paren
id|ptr
op_increment
suffix:semicolon
)brace
id|do_gettimeofday
c_func
(paren
op_amp
id|table-&gt;timestamp
)paren
suffix:semicolon
)brace
DECL|function|get_radio_address
r_static
r_int
id|get_radio_address
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|p
)paren
(brace
id|MetricomAddress
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|string_to_radio_address
c_func
(paren
op_amp
id|addr
comma
id|p
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* See if our radio address has changed */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|strip_info-&gt;true_dev_addr.c
comma
id|addr.c
comma
r_sizeof
(paren
id|addr
)paren
)paren
)paren
(brace
id|MetricomAddressString
id|addr_string
suffix:semicolon
id|radio_address_to_string
c_func
(paren
op_amp
id|addr
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio address = %s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|addr_string.c
)paren
suffix:semicolon
id|strip_info-&gt;true_dev_addr
op_assign
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;manual_dev_addr
)paren
op_star
(paren
id|MetricomAddress
op_star
)paren
id|strip_info-&gt;dev.dev_addr
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Give the radio a few seconds to get its head straight, then send an arp */
id|strip_info-&gt;gratuitous_arp
op_assign
id|jiffies
op_plus
l_int|15
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;arp_interval
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|verify_checksum
r_static
r_int
id|verify_checksum
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|__u8
op_star
id|p
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
op_minus
l_int|4
suffix:semicolon
id|u_short
id|sum
op_assign
(paren
id|READHEX16
c_func
(paren
id|end
(braket
l_int|0
)braket
)paren
op_lshift
l_int|12
)paren
op_or
(paren
id|READHEX16
c_func
(paren
id|end
(braket
l_int|1
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|READHEX16
c_func
(paren
id|end
(braket
l_int|2
)braket
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|READHEX16
c_func
(paren
id|end
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
)paren
id|sum
op_sub_assign
op_star
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sum
op_eq
l_int|0
op_logical_and
id|strip_info-&gt;firmware_level
op_eq
id|StructuredMessages
)paren
(brace
id|strip_info-&gt;firmware_level
op_assign
id|ChecksummedMessages
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio provides message checksums&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_return
id|sum
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|RecvErr
r_static
r_void
id|RecvErr
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
suffix:semicolon
id|DumpData
c_func
(paren
id|msg
comma
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
id|strip_info-&gt;rx_errors
op_increment
suffix:semicolon
)brace
DECL|function|RecvErr_Message
r_static
r_void
id|RecvErr_Message
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|sendername
comma
r_const
id|__u8
op_star
id|msg
comma
id|u_long
id|len
)paren
(brace
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;001&quot;
)paren
)paren
multiline_comment|/* Not in StarMode! */
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio %s is not in StarMode&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|sendername
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;002&quot;
)paren
)paren
multiline_comment|/* Remap handle */
(brace
multiline_comment|/* We ignore &quot;Remap handle&quot; messages for now */
)brace
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;003&quot;
)paren
)paren
multiline_comment|/* Can&squot;t resolve name */
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Destination radio name is unknown&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;004&quot;
)paren
)paren
multiline_comment|/* Name too small or missing */
(brace
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
id|LongTime
suffix:semicolon
macro_line|#if TICKLE_TIMERS
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;**** Got ERR_004 response         at %02d.%06d&bslash;n&quot;
comma
id|tv.tv_sec
op_mod
l_int|100
comma
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;working
)paren
(brace
id|strip_info-&gt;working
op_assign
id|TRUE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio now in starmode&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
multiline_comment|/*&n;             * If the radio has just entered a working state, we should do our first&n;             * probe ASAP, so that we find out our radio address etc. without delay.&n;             */
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;firmware_level
op_eq
id|NoStructure
op_logical_and
id|sendername
)paren
(brace
id|strip_info-&gt;firmware_level
op_assign
id|StructuredMessages
suffix:semicolon
id|strip_info-&gt;next_command
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Try to enable checksums ASAP */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio provides structured messages&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;firmware_level
op_ge
id|StructuredMessages
)paren
(brace
multiline_comment|/*&n;             * If this message has a valid checksum on the end, then the call to verify_checksum&n;             * will elevate the firmware_level to ChecksummedMessages for us. (The actual return&n;             * code from verify_checksum is ignored here.)&n;             */
id|verify_checksum
c_func
(paren
id|strip_info
)paren
suffix:semicolon
multiline_comment|/*&n;             * If the radio has structured messages but we don&squot;t yet have all our information about it,&n;             * we should do probes without delay, until we have gathered all the information&n;             */
r_if
c_cond
(paren
op_logical_neg
id|GOT_ALL_RADIO_INFO
c_func
(paren
id|strip_info
)paren
)paren
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;005&quot;
)paren
)paren
multiline_comment|/* Bad count specification */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;006&quot;
)paren
)paren
multiline_comment|/* Header too big */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;007&quot;
)paren
)paren
multiline_comment|/* Body too big */
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error! Packet size too big for radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;008&quot;
)paren
)paren
multiline_comment|/* Bad character in name */
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Radio name contains illegal character&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;009&quot;
)paren
)paren
multiline_comment|/* No count or line terminator */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;010&quot;
)paren
)paren
multiline_comment|/* Invalid checksum */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;011&quot;
)paren
)paren
multiline_comment|/* Checksum didn&squot;t match */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;012&quot;
)paren
)paren
multiline_comment|/* Failed to transmit packet */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
DECL|function|process_AT_response
r_static
r_void
id|process_AT_response
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|u_long
id|len
suffix:semicolon
id|__u8
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
id|p
(braket
op_minus
l_int|1
)braket
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
multiline_comment|/* Skip past first newline character */
multiline_comment|/* Now ptr points to the AT command, and p points to the text of the response. */
id|len
op_assign
id|p
op_minus
id|ptr
suffix:semicolon
macro_line|#if TICKLE_TIMERS
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;**** Got AT response %.7s      at %02d.%06d&bslash;n&quot;
comma
id|ptr
comma
id|tv.tv_sec
op_mod
l_int|100
comma
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ATS300?&quot;
)paren
)paren
id|get_radio_version
c_func
(paren
id|strip_info
comma
id|p
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ATS305?&quot;
)paren
)paren
id|get_radio_address
c_func
(paren
id|strip_info
comma
id|p
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ATS311?&quot;
)paren
)paren
id|get_radio_neighbours
c_func
(paren
op_amp
id|strip_info-&gt;poletops
comma
id|p
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ATS319=7&quot;
)paren
)paren
id|verify_checksum
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ATS325?&quot;
)paren
)paren
id|get_radio_voltage
c_func
(paren
id|strip_info
comma
id|p
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;AT~LA&quot;
)paren
)paren
id|get_radio_neighbours
c_func
(paren
op_amp
id|strip_info-&gt;portables
comma
id|p
comma
id|end
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Unknown AT Response:&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
DECL|function|process_ACK
r_static
r_void
id|process_ACK
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
multiline_comment|/* Currently we don&squot;t do anything with ACKs from the radio */
)brace
DECL|function|process_Info
r_static
r_void
id|process_Info
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
r_if
c_cond
(paren
id|ptr
op_plus
l_int|16
OG
id|end
)paren
id|RecvErr
c_func
(paren
l_string|&quot;Bad Info Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
DECL|function|get_strip_dev
r_static
r_struct
id|net_device
op_star
id|get_strip_dev
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
multiline_comment|/* If our hardware address is *manually set* to zero, and we know our */
multiline_comment|/* real radio hardware address, try to find another strip device that has been */
multiline_comment|/* manually set to that address that we can &squot;transfer ownership&squot; of this packet to  */
r_if
c_cond
(paren
id|strip_info-&gt;manual_dev_addr
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|strip_info-&gt;dev.dev_addr
comma
id|zero_address.c
comma
r_sizeof
(paren
id|zero_address
)paren
)paren
op_logical_and
id|memcmp
c_func
(paren
op_amp
id|strip_info-&gt;true_dev_addr
comma
id|zero_address.c
comma
r_sizeof
(paren
id|zero_address
)paren
)paren
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|dev_base
suffix:semicolon
r_while
c_loop
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|strip_info-&gt;dev.type
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
op_amp
id|strip_info-&gt;true_dev_addr
comma
r_sizeof
(paren
id|MetricomAddress
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Transferred packet ownership to %s.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
)brace
r_return
op_amp
id|strip_info-&gt;dev
suffix:semicolon
)brace
multiline_comment|/*&n; * Send one completely decapsulated datagram to the next layer.&n; */
DECL|function|deliver_packet
r_static
r_void
id|deliver_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|STRIP_Header
op_star
id|header
comma
id|__u16
id|packetlen
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
r_sizeof
(paren
id|STRIP_Header
)paren
op_plus
id|packetlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: memory squeeze, dropping packet.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
comma
id|header
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|packetlen
)paren
comma
id|strip_info-&gt;rx_buff
comma
id|packetlen
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|get_strip_dev
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|header-&gt;protocol
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Having put a fake header on the front of the sk_buff for the */
multiline_comment|/* benefit of tools like tcpdump, skb_pull now &squot;consumes&squot; that  */
multiline_comment|/* fake header before we hand the packet up to the next layer.  */
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
suffix:semicolon
multiline_comment|/* Finally, hand the packet up to the next layer (e.g. IP or ARP, etc.) */
id|strip_info-&gt;rx_packets
op_increment
suffix:semicolon
id|strip_info-&gt;rx_pps_count
op_increment
suffix:semicolon
macro_line|#ifdef EXT_COUNTERS
id|strip_info-&gt;rx_bytes
op_add_assign
id|packetlen
suffix:semicolon
macro_line|#endif
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
DECL|function|process_IP_packet
r_static
r_void
id|process_IP_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|STRIP_Header
op_star
id|header
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u16
id|packetlen
suffix:semicolon
multiline_comment|/* Decode start of the IP packet header */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;IP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|packetlen
op_assign
(paren
(paren
id|__u16
)paren
id|strip_info-&gt;rx_buff
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|strip_info-&gt;rx_buff
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|packetlen
OG
id|MAX_RECV_MTU
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Dropping oversized received IP packet: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|packetlen
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Got %d byte IP packet&bslash;n&quot;, strip_info-&gt;dev.name, packetlen);*/
multiline_comment|/* Decode remainder of the IP packet */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
op_plus
l_int|4
comma
id|packetlen
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;IP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
OL
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;IP Packet too long&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|header-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|deliver_packet
c_func
(paren
id|strip_info
comma
id|header
comma
id|packetlen
)paren
suffix:semicolon
)brace
DECL|function|process_ARP_packet
r_static
r_void
id|process_ARP_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|STRIP_Header
op_star
id|header
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u16
id|packetlen
suffix:semicolon
r_struct
id|arphdr
op_star
id|arphdr
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|strip_info-&gt;rx_buff
suffix:semicolon
multiline_comment|/* Decode start of the ARP packet */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;ARP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|packetlen
op_assign
l_int|8
op_plus
(paren
id|arphdr-&gt;ar_hln
op_plus
id|arphdr-&gt;ar_pln
)paren
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|packetlen
OG
id|MAX_RECV_MTU
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Dropping oversized received ARP packet: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|packetlen
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Got %d byte ARP %s&bslash;n&quot;,&n;        strip_info-&gt;dev.name, packetlen,&n;        ntohs(arphdr-&gt;ar_op) == ARPOP_REQUEST ? &quot;request&quot; : &quot;reply&quot;);*/
multiline_comment|/* Decode remainder of the ARP packet */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
op_plus
l_int|8
comma
id|packetlen
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;ARP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
OL
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;ARP Packet too long&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|header-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
id|deliver_packet
c_func
(paren
id|strip_info
comma
id|header
comma
id|packetlen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * process_text_message processes a &lt;CR&gt;-terminated block of data received&n; * from the radio that doesn&squot;t begin with a &squot;*&squot; character. All normal&n; * Starmode communication messages with the radio begin with a &squot;*&squot;,&n; * so any text that does not indicates a serial port error, a radio that&n; * is in Hayes command mode instead of Starmode, or a radio with really&n; * old firmware that doesn&squot;t frame its Starmode responses properly.&n; */
DECL|function|process_text_message
r_static
r_void
id|process_text_message
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|__u8
op_star
id|msg
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
r_int
id|len
op_assign
id|strip_info-&gt;sx_count
suffix:semicolon
multiline_comment|/* Check for anything that looks like it might be our radio name */
multiline_comment|/* (This is here for backwards compatibility with old firmware)  */
r_if
c_cond
(paren
id|len
op_eq
l_int|9
op_logical_and
id|get_radio_address
c_func
(paren
id|strip_info
comma
id|msg
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|text_equal
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;OK&quot;
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Ignore &squot;OK&squot; responses from prior commands */
r_if
c_cond
(paren
id|text_equal
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;ERROR&quot;
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Ignore &squot;ERROR&squot; messages */
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;ate0q1&quot;
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Ignore character echo back from the radio */
multiline_comment|/* Catch other error messages */
multiline_comment|/* (This is here for backwards compatibility with old firmware) */
r_if
c_cond
(paren
id|has_prefix
c_func
(paren
id|msg
comma
id|len
comma
l_string|&quot;ERR_&quot;
)paren
)paren
(brace
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
l_int|NULL
comma
op_amp
id|msg
(braket
l_int|4
)braket
comma
id|len
op_minus
l_int|4
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|RecvErr
c_func
(paren
l_string|&quot;No initial *&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * process_message processes a &lt;CR&gt;-terminated block of data received&n; * from the radio. If the radio is not in Starmode or has old firmware,&n; * it may be a line of text in response to an AT command. Ideally, with&n; * a current radio that&squot;s properly in Starmode, all data received should&n; * be properly framed and checksummed radio message blocks, containing&n; * either a starmode packet, or a other communication from the radio&n; * firmware, like &quot;INF_&quot; Info messages and &amp;COMMAND responses.&n; */
DECL|function|process_message
r_static
r_void
id|process_message
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|STRIP_Header
id|header
op_assign
(brace
id|zero_address
comma
id|zero_address
comma
l_int|0
)brace
suffix:semicolon
id|__u8
op_star
id|ptr
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
suffix:semicolon
id|__u8
id|sendername
(braket
l_int|32
)braket
comma
op_star
id|sptr
op_assign
id|sendername
suffix:semicolon
id|MetricomKey
id|key
suffix:semicolon
multiline_comment|/*HexDump(&quot;Receiving&quot;, strip_info, ptr, end);*/
multiline_comment|/* Check for start of address marker, and then skip over it */
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;*&squot;
)paren
id|ptr
op_increment
suffix:semicolon
r_else
(brace
id|process_text_message
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Copy out the return address */
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
op_logical_and
id|sptr
OL
id|ARRAY_END
c_func
(paren
id|sendername
)paren
op_minus
l_int|1
)paren
op_star
id|sptr
op_increment
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
op_star
id|sptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Null terminate the sender name */
multiline_comment|/* Check for end of address marker, and skip over it */
r_if
c_cond
(paren
id|ptr
op_ge
id|end
op_logical_or
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;No second *&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Skip the second &squot;*&squot; */
multiline_comment|/* If the sender name is &quot;&amp;COMMAND&quot;, ignore this &squot;packet&squot;       */
multiline_comment|/* (This is here for backwards compatibility with old firmware) */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sendername
comma
l_string|&quot;&amp;COMMAND&quot;
)paren
)paren
(brace
id|strip_info-&gt;firmware_level
op_assign
id|NoStructure
suffix:semicolon
id|strip_info-&gt;next_command
op_assign
id|CompatibilityCommand
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_plus
l_int|4
OG
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;No proto key&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Get the protocol key out of the buffer */
id|key.c
(braket
l_int|0
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|1
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|2
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|3
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* If we&squot;re using checksums, verify the checksum at the end of the packet */
r_if
c_cond
(paren
id|strip_info-&gt;firmware_level
op_ge
id|ChecksummedMessages
)paren
(brace
id|end
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* Chop the last four bytes off the packet (they&squot;re the checksum) */
r_if
c_cond
(paren
id|ptr
OG
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Missing Checksum&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|verify_checksum
c_func
(paren
id|strip_info
)paren
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Bad Checksum&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Got packet from &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;, strip_info-&gt;dev.name, sendername);*/
multiline_comment|/*&n;     * Fill in (pseudo) source and destination addresses in the packet.&n;     * We assume that the destination address was our address (the radio does not&n;     * tell us this). If the radio supplies a source address, then we use it.&n;     */
id|header.dst_addr
op_assign
id|strip_info-&gt;true_dev_addr
suffix:semicolon
id|string_to_radio_address
c_func
(paren
op_amp
id|header.src_addr
comma
id|sendername
)paren
suffix:semicolon
macro_line|#ifdef EXT_COUNTERS
r_if
c_cond
(paren
id|key.l
op_eq
id|SIP0Key.l
)paren
(brace
id|strip_info-&gt;rx_rbytes
op_add_assign
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
id|process_IP_packet
c_func
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ARP0Key.l
)paren
(brace
id|strip_info-&gt;rx_rbytes
op_add_assign
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
id|process_ARP_packet
c_func
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ATR_Key.l
)paren
(brace
id|strip_info-&gt;rx_ebytes
op_add_assign
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
id|process_AT_response
c_func
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ACK_Key.l
)paren
(brace
id|strip_info-&gt;rx_ebytes
op_add_assign
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
id|process_ACK
c_func
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|INF_Key.l
)paren
(brace
id|strip_info-&gt;rx_ebytes
op_add_assign
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
id|process_Info
c_func
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ERR_Key.l
)paren
(brace
id|strip_info-&gt;rx_ebytes
op_add_assign
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
id|sendername
comma
id|ptr
comma
id|end
op_minus
id|ptr
)paren
suffix:semicolon
)brace
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Unrecognized protocol key&quot;
comma
id|strip_info
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|key.l
op_eq
id|SIP0Key.l
)paren
id|process_IP_packet
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ARP0Key.l
)paren
id|process_ARP_packet
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ATR_Key.l
)paren
id|process_AT_response
c_func
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ACK_Key.l
)paren
id|process_ACK
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|INF_Key.l
)paren
id|process_Info
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ERR_Key.l
)paren
id|RecvErr_Message
(paren
id|strip_info
comma
id|sendername
comma
id|ptr
comma
id|end
op_minus
id|ptr
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Unrecognized protocol key&quot;
comma
id|strip_info
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|TTYERROR
mdefine_line|#define TTYERROR(X) ((X) == TTY_BREAK   ? &quot;Break&quot;            : &bslash;&n;                     (X) == TTY_FRAME   ? &quot;Framing Error&quot;    : &bslash;&n;                     (X) == TTY_PARITY  ? &quot;Parity Error&quot;     : &bslash;&n;                     (X) == TTY_OVERRUN ? &quot;Hardware Overrun&quot; : &quot;Unknown Error&quot;)
multiline_comment|/*&n; * Handle the &squot;receiver data ready&squot; interrupt.&n; * This function is called by the &squot;tty_io&squot; module in the kernel when&n; * a block of STRIP data has been received, which can now be decapsulated&n; * and sent on to some IP layer for further processing.&n; */
r_static
r_void
DECL|function|strip_receive_buf
id|strip_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_const
r_int
r_char
op_star
id|end
op_assign
id|cp
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
op_logical_or
op_logical_neg
id|netif_running
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Argh! mtu change time! - costs us the packet part received at the change */
r_if
c_cond
(paren
id|strip_info-&gt;mtu
op_ne
id|strip_info-&gt;dev.mtu
)paren
id|strip_changedmtu
c_func
(paren
id|strip_info
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;**** strip_receive_buf: %3d bytes at %02d.%06d&bslash;n&quot;
comma
id|count
comma
id|tv.tv_sec
op_mod
l_int|100
comma
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef EXT_COUNTERS
id|strip_info-&gt;rx_sbytes
op_add_assign
id|count
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the characters out of the buffer */
r_while
c_loop
(paren
id|cp
OL
id|end
)paren
(brace
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s on serial port&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|TTYERROR
c_func
(paren
op_star
id|fp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
op_increment
op_logical_and
op_logical_neg
id|strip_info-&gt;discard
)paren
multiline_comment|/* If there&squot;s a serial error, record it */
(brace
multiline_comment|/* If we have some characters in the buffer, discard them */
id|strip_info-&gt;discard
op_assign
id|strip_info-&gt;sx_count
suffix:semicolon
id|strip_info-&gt;rx_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* Leading control characters (CR, NL, Tab, etc.) are ignored */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OG
l_int|0
op_logical_or
op_star
id|cp
op_ge
l_char|&squot; &squot;
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_int|0x0D
)paren
multiline_comment|/* If end of packet, decide what to do with it */
(brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OG
l_int|3000
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Cut a %d byte packet (%d bytes remaining)%s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|strip_info-&gt;sx_count
comma
id|end
op_minus
id|cp
op_minus
l_int|1
comma
id|strip_info-&gt;discard
ques
c_cond
l_string|&quot; (discarded)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OG
id|strip_info-&gt;sx_size
)paren
(brace
id|strip_info-&gt;rx_over_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: sx_buff overflow (%d bytes total)&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|strip_info-&gt;sx_count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strip_info-&gt;discard
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Discarding bad packet (%d/%d)&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|strip_info-&gt;discard
comma
id|strip_info-&gt;sx_count
)paren
suffix:semicolon
r_else
id|process_message
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;discard
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Make sure we have space in the buffer */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OL
id|strip_info-&gt;sx_size
)paren
id|strip_info-&gt;sx_buff
(braket
id|strip_info-&gt;sx_count
)braket
op_assign
op_star
id|cp
suffix:semicolon
id|strip_info-&gt;sx_count
op_increment
suffix:semicolon
)brace
)brace
id|cp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* General control routines&t;&t;&t;&t;&t;&t;*/
DECL|function|set_mac_address
r_static
r_int
id|set_mac_address
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|MetricomAddress
op_star
id|addr
)paren
(brace
multiline_comment|/*&n;     * We&squot;re using a manually specified address if the address is set&n;     * to anything other than all ones. Setting the address to all ones&n;     * disables manual mode and goes back to automatic address determination&n;     * (tracking the true address that the radio has).&n;     */
id|strip_info-&gt;manual_dev_addr
op_assign
id|memcmp
c_func
(paren
id|addr-&gt;c
comma
id|broadcast_address.c
comma
r_sizeof
(paren
id|broadcast_address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;manual_dev_addr
)paren
op_star
(paren
id|MetricomAddress
op_star
)paren
id|strip_info-&gt;dev.dev_addr
op_assign
op_star
id|addr
suffix:semicolon
r_else
op_star
(paren
id|MetricomAddress
op_star
)paren
id|strip_info-&gt;dev.dev_addr
op_assign
id|strip_info-&gt;true_dev_addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dev_set_mac_address
r_static
r_int
id|dev_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_struct
id|sockaddr
op_star
id|sa
op_assign
id|addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: strip_set_dev_mac_address called&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|set_mac_address
c_func
(paren
id|strip_info
comma
(paren
id|MetricomAddress
op_star
)paren
id|sa-&gt;sa_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|strip_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|strip_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_struct
id|net_device_stats
id|stats
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|stats.rx_packets
op_assign
id|strip_info-&gt;rx_packets
suffix:semicolon
id|stats.tx_packets
op_assign
id|strip_info-&gt;tx_packets
suffix:semicolon
id|stats.rx_dropped
op_assign
id|strip_info-&gt;rx_dropped
suffix:semicolon
id|stats.tx_dropped
op_assign
id|strip_info-&gt;tx_dropped
suffix:semicolon
id|stats.tx_errors
op_assign
id|strip_info-&gt;tx_errors
suffix:semicolon
id|stats.rx_errors
op_assign
id|strip_info-&gt;rx_errors
suffix:semicolon
id|stats.rx_over_errors
op_assign
id|strip_info-&gt;rx_over_errors
suffix:semicolon
r_return
op_amp
id|stats
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Opening and closing&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * Here&squot;s the order things happen:&n; * When the user runs &quot;slattach -p strip ...&quot;&n; *  1. The TTY module calls strip_open&n; *  2. strip_open calls strip_alloc&n; *  3.                  strip_alloc calls register_netdev&n; *  4.                  register_netdev calls strip_dev_init&n; *  5. then strip_open finishes setting up the strip_info&n; *&n; * When the user runs &quot;ifconfig st&lt;x&gt; up address netmask ...&quot;&n; *  6. strip_open_low gets called&n; *&n; * When the user runs &quot;ifconfig st&lt;x&gt; down&quot;&n; *  7. strip_close_low gets called&n; *&n; * When the user kills the slattach process&n; *  8. strip_close gets called&n; *  9. strip_close calls dev_close&n; * 10. if the device is still up, then dev_close calls strip_close_low&n; * 11. strip_close calls strip_free&n; */
multiline_comment|/* Open the low-level part of the STRIP channel. Easy! */
DECL|function|strip_open_low
r_static
r_int
id|strip_open_low
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
macro_line|#if 0
r_struct
id|in_device
op_star
id|in_dev
op_assign
id|dev-&gt;ip_ptr
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|strip_info-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allocate_buffers
c_func
(paren
id|strip_info
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_left
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;discard
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;working
op_assign
id|FALSE
suffix:semicolon
id|strip_info-&gt;firmware_level
op_assign
id|NoStructure
suffix:semicolon
id|strip_info-&gt;next_command
op_assign
id|CompatibilityCommand
suffix:semicolon
id|strip_info-&gt;user_baud
op_assign
id|get_baud
c_func
(paren
id|strip_info-&gt;tty
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;     * Needed because address &squot;0&squot; is special&n;     *&n;     * --ANK Needed it or not needed, it does not matter at all.&n;     *&t;     Make it at user level, guys.&n;     */
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list-&gt;ifa_address
op_eq
l_int|0
)paren
id|in_dev-&gt;ifa_list-&gt;ifa_address
op_assign
id|ntohl
c_func
(paren
l_int|0xC0A80001
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Initializing Radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|ResetRadio
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;idle_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the low-level part of the STRIP channel. Easy!&n; */
DECL|function|strip_close_low
r_static
r_int
id|strip_close_low
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|strip_info-&gt;tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;     * Free all STRIP frame buffers.&n;     */
r_if
c_cond
(paren
id|strip_info-&gt;rx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;rx_buff
)paren
suffix:semicolon
id|strip_info-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;sx_buff
)paren
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;tx_buff
)paren
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by DDI when the&n; * (dynamically assigned) device is registered&n; */
DECL|function|strip_dev_init
r_static
r_int
id|strip_dev_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/*&n;     * Finish setting up the DEVICE info.&n;     */
id|dev-&gt;trans_start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;last_rx
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* Drop after 30 frames queued */
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|DEFAULT_STRIP_MTU
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_METRICOM
suffix:semicolon
multiline_comment|/* dtang */
id|dev-&gt;hard_header_len
op_assign
r_sizeof
(paren
id|STRIP_Header
)paren
suffix:semicolon
multiline_comment|/*&n;     *  dev-&gt;priv             Already holds a pointer to our struct strip&n;     */
op_star
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|dev-&gt;broadcast
op_assign
id|broadcast_address
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;addr_len
op_assign
r_sizeof
(paren
id|MetricomAddress
)paren
suffix:semicolon
multiline_comment|/*&n;     * Pointers to interface service routines.&n;     */
id|dev-&gt;open
op_assign
id|strip_open_low
suffix:semicolon
id|dev-&gt;stop
op_assign
id|strip_close_low
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|strip_xmit
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|strip_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|strip_rebuild_header
suffix:semicolon
multiline_comment|/*  dev-&gt;type_trans            unused */
multiline_comment|/*  dev-&gt;set_multicast_list   unused */
id|dev-&gt;set_mac_address
op_assign
id|dev_set_mac_address
suffix:semicolon
multiline_comment|/*  dev-&gt;do_ioctl             unused */
multiline_comment|/*  dev-&gt;set_config           unused */
id|dev-&gt;get_stats
op_assign
id|strip_get_stats
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a STRIP channel.&n; */
DECL|function|strip_free
r_static
r_void
id|strip_free
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
op_star
(paren
id|strip_info-&gt;referrer
)paren
op_assign
id|strip_info-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;next
)paren
id|strip_info-&gt;next-&gt;referrer
op_assign
id|strip_info-&gt;referrer
suffix:semicolon
id|strip_info-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|strip_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a new free STRIP channel&n; */
DECL|function|strip_alloc
r_static
r_struct
id|strip
op_star
id|strip_alloc
c_func
(paren
r_void
)paren
(brace
r_int
id|channel_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|strip
op_star
op_star
id|s
op_assign
op_amp
id|struct_strip_list
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strip
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If no more memory, return */
multiline_comment|/*&n;     * Clear the allocated memory&n;     */
id|memset
c_func
(paren
id|strip_info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|strip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Search the list to find where to put our new entry&n;     * (and in the process decide what channel number it is&n;     * going to be)&n;     */
r_while
c_loop
(paren
op_star
id|s
op_logical_and
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|dev.base_addr
op_eq
id|channel_id
)paren
(brace
id|channel_id
op_increment
suffix:semicolon
id|s
op_assign
op_amp
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
multiline_comment|/*&n;     * Fill in the link pointers&n;     */
id|strip_info-&gt;next
op_assign
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|referrer
op_assign
op_amp
id|strip_info-&gt;next
suffix:semicolon
id|strip_info-&gt;referrer
op_assign
id|s
suffix:semicolon
op_star
id|s
op_assign
id|strip_info
suffix:semicolon
id|strip_info-&gt;magic
op_assign
id|STRIP_MAGIC
suffix:semicolon
id|strip_info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strip_info-&gt;gratuitous_arp
op_assign
id|jiffies
op_plus
id|LongTime
suffix:semicolon
id|strip_info-&gt;arp_interval
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
id|strip_info-&gt;idle_timer.data
op_assign
(paren
r_int
)paren
op_amp
id|strip_info-&gt;dev
suffix:semicolon
id|strip_info-&gt;idle_timer.function
op_assign
id|strip_IdleTask
suffix:semicolon
multiline_comment|/* Note: strip_info-&gt;if_name is currently 8 characters long */
id|sprintf
c_func
(paren
id|strip_info-&gt;dev.name
comma
l_string|&quot;st%d&quot;
comma
id|channel_id
)paren
suffix:semicolon
id|strip_info-&gt;dev.base_addr
op_assign
id|channel_id
suffix:semicolon
id|strip_info-&gt;dev.priv
op_assign
(paren
r_void
op_star
)paren
id|strip_info
suffix:semicolon
id|strip_info-&gt;dev.next
op_assign
l_int|NULL
suffix:semicolon
id|strip_info-&gt;dev.init
op_assign
id|strip_dev_init
suffix:semicolon
r_return
id|strip_info
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the high-level part of the STRIP channel.&n; * This function is called by the TTY module when the&n; * STRIP line discipline is called for.  Because we are&n; * sure the tty line exists, we only have to link it to&n; * a free STRIP channel...&n; */
DECL|function|strip_open
r_static
r_int
id|strip_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;     * First make sure we&squot;re not already connected.&n;     */
r_if
c_cond
(paren
id|strip_info
op_logical_and
id|strip_info-&gt;magic
op_eq
id|STRIP_MAGIC
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/*&n;     * OK.  Find a free STRIP channel to use.&n;     */
r_if
c_cond
(paren
(paren
id|strip_info
op_assign
id|strip_alloc
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/*&n;     * Register our newly created device so it can be ifconfig&squot;d&n;     * strip_dev_init() will be called as a side-effect&n;     */
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;strip: register_netdev() failed.&bslash;n&quot;
)paren
suffix:semicolon
id|strip_free
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
id|strip_info-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|strip_info
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/*&n;     * Restore default settings&n;     */
id|strip_info-&gt;dev.type
op_assign
id|ARPHRD_METRICOM
suffix:semicolon
multiline_comment|/* dtang */
multiline_comment|/*&n;     * Set tty options&n;     */
id|tty-&gt;termios-&gt;c_iflag
op_or_assign
id|IGNBRK
op_or
id|IGNPAR
suffix:semicolon
multiline_comment|/* Ignore breaks and parity errors. */
id|tty-&gt;termios-&gt;c_cflag
op_or_assign
id|CLOCAL
suffix:semicolon
multiline_comment|/* Ignore modem control signals. */
id|tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|HUPCL
suffix:semicolon
multiline_comment|/* Don&squot;t close on hup */
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;STRIP: device &bslash;&quot;%s&bslash;&quot; activated&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
multiline_comment|/*&n;     * Done.  We have linked the TTY line to a channel.&n;     */
r_return
id|strip_info-&gt;dev.base_addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a STRIP channel.&n; * This means flushing out any pending queues, and then restoring the&n; * TTY line discipline to what it was before it got hooked to STRIP&n; * (which usually is TTY again).&n; */
DECL|function|strip_close
r_static
r_void
id|strip_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;     * First make sure we&squot;re connected.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
)paren
r_return
suffix:semicolon
id|dev_close
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;STRIP: device &bslash;&quot;%s&bslash;&quot; closed down&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_free
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Perform I/O control calls on an active STRIP channel.&t;&t;*/
DECL|function|strip_ioctl
r_static
r_int
id|strip_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;     * First make sure we&squot;re connected.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFNAME
suffix:colon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|strip_info-&gt;dev.name
comma
id|strlen
c_func
(paren
id|strip_info-&gt;dev.name
)paren
op_plus
l_int|1
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
(brace
id|MetricomAddress
id|addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: SIOCSIFHWADDR&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
r_return
id|copy_from_user
c_func
(paren
op_amp
id|addr
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|MetricomAddress
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
id|set_mac_address
c_func
(paren
id|strip_info
comma
op_amp
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;         * Allow stty to read, but not set, the serial port&n;         */
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
r_return
id|n_tty_ioctl
c_func
(paren
id|tty
comma
(paren
r_struct
id|file
op_star
)paren
id|file
comma
id|cmd
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Initialization&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * Initialize the STRIP driver.&n; * This routine is called at boot time, to bootstrap the multi-channel&n; * STRIP driver&n; */
DECL|function|strip_init_ctrl_dev
r_int
id|strip_init_ctrl_dev
c_func
(paren
r_struct
id|net_device
op_star
id|dummy
)paren
(brace
r_static
r_struct
id|tty_ldisc
id|strip_ldisc
suffix:semicolon
r_int
id|status
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;STRIP: Version %s (unlimited channels)&bslash;n&quot;
comma
id|StripVersion
)paren
suffix:semicolon
multiline_comment|/*&n;     * Fill in our line protocol discipline, and register it&n;     */
id|memset
c_func
(paren
op_amp
id|strip_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|strip_ldisc
)paren
)paren
suffix:semicolon
id|strip_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|strip_ldisc.flags
op_assign
l_int|0
suffix:semicolon
id|strip_ldisc.open
op_assign
id|strip_open
suffix:semicolon
id|strip_ldisc.close
op_assign
id|strip_close
suffix:semicolon
id|strip_ldisc.read
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.write
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.ioctl
op_assign
id|strip_ioctl
suffix:semicolon
id|strip_ldisc.poll
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.receive_buf
op_assign
id|strip_receive_buf
suffix:semicolon
id|strip_ldisc.receive_room
op_assign
id|strip_receive_room
suffix:semicolon
id|strip_ldisc.write_wakeup
op_assign
id|strip_write_some_more
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_STRIP
comma
op_amp
id|strip_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: can&squot;t register line discipline (err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Register the status file with /proc&n;     */
id|proc_net_create
(paren
l_string|&quot;strip&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|get_status_info
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_return
id|status
suffix:semicolon
macro_line|#else
multiline_comment|/* Return &quot;not found&quot;, so that dev_init() will unlink&n;     * the placeholder device entry for us.&n;     */
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* From here down is only used when compiled as an external module&t;*/
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|strip_init_ctrl_dev
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|struct_strip_list
)paren
id|strip_free
c_func
(paren
id|struct_strip_list
)paren
suffix:semicolon
multiline_comment|/* Unregister with the /proc/net file here. */
id|proc_net_remove
(paren
l_string|&quot;strip&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_STRIP
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;STRIP: Module Unloaded&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
