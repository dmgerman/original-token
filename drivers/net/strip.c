multiline_comment|/*&n; * Copyright 1996 The Board of Trustees of The Leland Stanford&n; * Junior University. All Rights Reserved.&n; *&n; * Permission to use, copy, modify, and distribute this&n; * software and its documentation for any purpose and without&n; * fee is hereby granted, provided that the above copyright&n; * notice appear in all copies.  Stanford University&n; * makes no representations about the suitability of this&n; * software for any purpose.  It is provided &quot;as is&quot; without&n; * express or implied warranty.&n; *&n; * strip.c&t;This module implements Starmode Radio IP (STRIP)&n; *&t;&t;for kernel-based devices like TTY.  It interfaces between a&n; *&t;&t;raw TTY, and the kernel&squot;s INET protocol layers (via DDI).&n; *&n; * Version:&t;@(#)strip.c&t;0.9.8&t;June 1996&n; *&n; * Author:&t;Stuart Cheshire &lt;cheshire@cs.stanford.edu&gt;&n; *&n; * Fixes:&t;v0.9 12th Feb 1996.&n; *&t;&t;New byte stuffing (2+6 run-length encoding)&n; *&t;&t;New watchdog timer task&n; *&t;&t;New Protocol key (SIP0)&n; *&t;&t;&n; *&t;&t;v0.9.1 3rd March 1996&n; *&t;&t;Changed to dynamic device allocation -- no more compile&n; *&t;&t;time (or boot time) limit on the number of STRIP devices.&n; *&t;&t;&n; *&t;&t;v0.9.2 13th March 1996&n; *&t;&t;Uses arp cache lookups (but doesn&squot;t send arp packets yet)&n; *&t;&t;&n; *&t;&t;v0.9.3 17th April 1996&n; *&t;&t;Fixed bug where STR_ERROR flag was getting set unneccessarily&n; *&t;&t;&n; *&t;&t;v0.9.4 27th April 1996&n; *&t;&t;First attempt at using &quot;&amp;COMMAND&quot; Starmode AT commands&n; *&t;&t;&n; *&t;&t;v0.9.5 29th May 1996&n; *&t;&t;First attempt at sending (unicast) ARP packets&n; *&t;&t;&n; *&t;&t;v0.9.6 5th June 1996&n; *&t;&t;Elliot put &quot;message level&quot; tags in every &quot;printk&quot; statement&n; *&t;&t;&n; *&t;&t;v0.9.7 13th June 1996&n; *&t;&t;Added support for the /proc fs (laik)&n; *&n; *              v0.9.8 July 1996&n; *              Added packet logging (Mema)&n; */
multiline_comment|/*&n; * Undefine this symbol if you don&squot;t have PROC_NET_STRIP_STATUS&n; * defined in include/linux/proc_fs.h&n; */
DECL|macro|DO_PROC_NET_STRIP_STATUS
mdefine_line|#define DO_PROC_NET_STRIP_STATUS 1
multiline_comment|/*&n; * Define this symbol if you want to enable STRIP packet tracing.&n; */
DECL|macro|DO_PROC_NET_STRIP_TRACE
mdefine_line|#define DO_PROC_NET_STRIP_TRACE 0
multiline_comment|/************************************************************************/
multiline_comment|/* Header files&t;&t;&t;&t;&t;&t;&t;&t;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
multiline_comment|/*&n; * isdigit() and isspace() use the ctype[] array, which is not available&n; * to kernel modules.  If compiling as a module,  use  a local definition&n; * of isdigit() and isspace() until  _ctype is added to ksyms.&n; */
macro_line|#ifdef MODULE
DECL|macro|isdigit
macro_line|# define isdigit(c) (&squot;0&squot; &lt;= (c) &amp;&amp; (c)  &lt;= &squot;9&squot;)
DECL|macro|isspace
macro_line|# define isspace(c) ((c) == &squot; &squot; || (c)  == &squot;&bslash;t&squot;)
macro_line|#else
macro_line|# include &lt;linux/ctype.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_strip.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#ifdef CONFIG_INET
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#endif
multiline_comment|/************************************************************************/
multiline_comment|/* Useful structures and definitions&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * A MetricomKey identifies the protocol being carried inside a Metricom&n; * Starmode packet.&n; */
r_typedef
r_union
(brace
DECL|member|c
id|__u8
id|c
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|l
id|__u32
id|l
suffix:semicolon
DECL|typedef|MetricomKey
)brace
id|MetricomKey
suffix:semicolon
multiline_comment|/*&n; * An IP address can be viewed as four bytes in memory (which is what it is) or as&n; * a single 32-bit long (which is convenient for assignment, equality testing etc.)&n; */
r_typedef
r_union
(brace
DECL|member|b
id|__u8
id|b
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|l
id|__u32
id|l
suffix:semicolon
DECL|typedef|IPaddr
)brace
id|IPaddr
suffix:semicolon
multiline_comment|/*&n; * A MetricomAddressString is used to hold a printable representation of&n; * a Metricom address.&n; */
r_typedef
r_struct
(brace
DECL|member|c
id|__u8
id|c
(braket
l_int|24
)braket
suffix:semicolon
DECL|typedef|MetricomAddressString
)brace
id|MetricomAddressString
suffix:semicolon
multiline_comment|/*&n; * Note: A Metricom packet looks like this: *&lt;address&gt;*&lt;key&gt;&lt;payload&gt;&lt;CR&gt;&n; * eg. *0000-1234*SIP0&lt;payload&gt;&lt;CR&gt;&n; * A STRIP_Header is never really sent over the radio, but making a dummy header&n; * for internal use within the kernel that looks like an Ethernet header makes&n; * certain other software happier. For example, tcpdump already understands&n; * Ethernet headers.&n; */
r_typedef
r_struct
(brace
DECL|member|dst_addr
id|MetricomAddress
id|dst_addr
suffix:semicolon
multiline_comment|/* Destination address, e.g. &quot;0000-1234&quot;   */
DECL|member|src_addr
id|MetricomAddress
id|src_addr
suffix:semicolon
multiline_comment|/* Source address, e.g. &quot;0000-5678&quot;        */
DECL|member|protocol
r_int
r_int
id|protocol
suffix:semicolon
multiline_comment|/* The protocol type, using Ethernet codes */
DECL|typedef|STRIP_Header
)brace
id|STRIP_Header
suffix:semicolon
DECL|struct|GeographicLocation
r_typedef
r_struct
id|GeographicLocation
(brace
DECL|member|s
r_char
id|s
(braket
l_int|18
)braket
suffix:semicolon
DECL|typedef|GeographicLocation
)brace
id|GeographicLocation
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|NodeValid
id|NodeValid
op_assign
l_int|0x1
comma
DECL|enumerator|NodeHasWAN
id|NodeHasWAN
op_assign
l_int|0x2
comma
DECL|enumerator|NodeIsRouter
id|NodeIsRouter
op_assign
l_int|0x4
DECL|typedef|NodeType
)brace
id|NodeType
suffix:semicolon
DECL|struct|MetricomNode
r_typedef
r_struct
id|MetricomNode
(brace
DECL|member|type
id|NodeType
id|type
suffix:semicolon
multiline_comment|/* Some flags about the type of node */
DECL|member|gl
id|GeographicLocation
id|gl
suffix:semicolon
multiline_comment|/* The location of the node. */
DECL|member|addr
id|MetricomAddress
id|addr
suffix:semicolon
multiline_comment|/* The metricom address of this node */
DECL|member|poll_latency
r_int
id|poll_latency
suffix:semicolon
multiline_comment|/* The latency to poll that node ? */
DECL|member|rssi
r_int
id|rssi
suffix:semicolon
multiline_comment|/* The Receiver Signal Strength Indicator */
DECL|member|next
r_struct
id|MetricomNode
op_star
id|next
suffix:semicolon
multiline_comment|/* The next node */
DECL|typedef|MetricomNode
)brace
id|MetricomNode
suffix:semicolon
DECL|enumerator|FALSE
DECL|enumerator|TRUE
r_enum
(brace
id|FALSE
op_assign
l_int|0
comma
id|TRUE
op_assign
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * Holds the packet signature for an IP packet.&n; */
r_typedef
r_struct
(brace
DECL|member|src
id|IPaddr
id|src
suffix:semicolon
multiline_comment|/* Data is stored in the following field in network byte order. */
DECL|member|id
id|__u16
id|id
suffix:semicolon
DECL|typedef|IPSignature
)brace
id|IPSignature
suffix:semicolon
multiline_comment|/*&n; * Holds the packet signature for an ARP packet.&n; */
r_typedef
r_struct
(brace
DECL|member|src
id|IPaddr
id|src
suffix:semicolon
multiline_comment|/* Data is stored in the following field in network byte order. */
DECL|member|op
id|__u16
id|op
suffix:semicolon
DECL|typedef|ARPSignature
)brace
id|ARPSignature
suffix:semicolon
multiline_comment|/*&n; * Holds the signature of a packet.&n; */
r_typedef
r_union
(brace
DECL|member|ip_sig
id|IPSignature
id|ip_sig
suffix:semicolon
DECL|member|arp_sig
id|ARPSignature
id|arp_sig
suffix:semicolon
DECL|member|print_sig
id|__u8
id|print_sig
(braket
l_int|6
)braket
suffix:semicolon
DECL|typedef|PacketSignature
)brace
id|PacketSignature
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|EntrySend
id|EntrySend
op_assign
l_int|0
comma
DECL|enumerator|EntryReceive
id|EntryReceive
op_assign
l_int|1
DECL|typedef|LogEntry
)brace
id|LogEntry
suffix:semicolon
multiline_comment|/* Structure for Packet Logging */
DECL|struct|stripLog
r_typedef
r_struct
id|stripLog
(brace
DECL|member|entry_type
id|LogEntry
id|entry_type
suffix:semicolon
DECL|member|seqNum
id|u_long
id|seqNum
suffix:semicolon
DECL|member|packet_type
r_int
id|packet_type
suffix:semicolon
DECL|member|sig
id|PacketSignature
id|sig
suffix:semicolon
DECL|member|src
id|MetricomAddress
id|src
suffix:semicolon
DECL|member|dest
id|MetricomAddress
id|dest
suffix:semicolon
DECL|member|timeStamp
r_struct
id|timeval
id|timeStamp
suffix:semicolon
DECL|member|rawSize
id|u_long
id|rawSize
suffix:semicolon
DECL|member|stripSize
id|u_long
id|stripSize
suffix:semicolon
DECL|member|slipSize
id|u_long
id|slipSize
suffix:semicolon
DECL|member|valid
id|u_long
id|valid
suffix:semicolon
DECL|typedef|StripLog
)brace
id|StripLog
suffix:semicolon
DECL|macro|ENTRY_TYPE_TO_STRING
mdefine_line|#define ENTRY_TYPE_TO_STRING(X) ((X) ? &quot;r&quot; : &quot;s&quot;)
DECL|macro|BOOLEAN_TO_STRING
mdefine_line|#define BOOLEAN_TO_STRING(X) ((X) ? &quot;true&quot; : &quot;false&quot;)
multiline_comment|/*&n; * Holds the radio&squot;s firmware version.&n; */
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|50
)braket
suffix:semicolon
DECL|typedef|MetricomFirmwareVersion
)brace
id|MetricomFirmwareVersion
suffix:semicolon
multiline_comment|/*&n; * Holds the radio&squot;s serial number.&n; */
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|18
)braket
suffix:semicolon
DECL|typedef|MetricomSerialNumber
)brace
id|MetricomSerialNumber
suffix:semicolon
multiline_comment|/*&n; * Holds the radio&squot;s battery voltage.&n; */
r_typedef
r_struct
(brace
DECL|member|c
r_char
id|c
(braket
l_int|11
)braket
suffix:semicolon
DECL|typedef|MetricomBatteryVoltage
)brace
id|MetricomBatteryVoltage
suffix:semicolon
DECL|struct|strip
r_struct
id|strip
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
multiline_comment|/*&n;     * These are pointers to the malloc()ed frame buffers.&n;     */
DECL|member|rx_buff
r_int
r_char
op_star
id|rx_buff
suffix:semicolon
multiline_comment|/* buffer for received IP packet*/
DECL|member|sx_buff
r_int
r_char
op_star
id|sx_buff
suffix:semicolon
multiline_comment|/* buffer for received serial data*/
DECL|member|sx_count
r_int
id|sx_count
suffix:semicolon
multiline_comment|/* received serial data counter */
DECL|member|sx_size
r_int
id|sx_size
suffix:semicolon
multiline_comment|/* Serial buffer size&t;&t;*/
DECL|member|tx_buff
r_int
r_char
op_star
id|tx_buff
suffix:semicolon
multiline_comment|/* transmitter buffer           */
DECL|member|tx_head
r_int
r_char
op_star
id|tx_head
suffix:semicolon
multiline_comment|/* pointer to next byte to XMIT */
DECL|member|tx_left
r_int
id|tx_left
suffix:semicolon
multiline_comment|/* bytes left in XMIT queue     */
DECL|member|tx_size
r_int
id|tx_size
suffix:semicolon
multiline_comment|/* Serial buffer size&t;&t;*/
multiline_comment|/*&n;     * STRIP interface statistics.&n;     */
DECL|member|rx_packets
r_int
r_int
id|rx_packets
suffix:semicolon
multiline_comment|/* inbound frames counter&t;*/
DECL|member|tx_packets
r_int
r_int
id|tx_packets
suffix:semicolon
multiline_comment|/* outbound frames counter&t;*/
DECL|member|rx_errors
r_int
r_int
id|rx_errors
suffix:semicolon
multiline_comment|/* Parity, etc. errors&t;&t;*/
DECL|member|tx_errors
r_int
r_int
id|tx_errors
suffix:semicolon
multiline_comment|/* Planned stuff&t;&t;*/
DECL|member|rx_dropped
r_int
r_int
id|rx_dropped
suffix:semicolon
multiline_comment|/* No memory for skb&t;&t;*/
DECL|member|tx_dropped
r_int
r_int
id|tx_dropped
suffix:semicolon
multiline_comment|/* When MTU change&t;&t;*/
DECL|member|rx_over_errors
r_int
r_int
id|rx_over_errors
suffix:semicolon
multiline_comment|/* Frame bigger then STRIP buf. */
multiline_comment|/*&n;     * Internal variables.&n;     */
DECL|member|next
r_struct
id|strip
op_star
id|next
suffix:semicolon
multiline_comment|/* The next struct in the list&t;*/
DECL|member|referrer
r_struct
id|strip
op_star
op_star
id|referrer
suffix:semicolon
multiline_comment|/* The pointer that points to us*/
DECL|member|discard
r_int
id|discard
suffix:semicolon
multiline_comment|/* Set if serial error&t;&t;*/
DECL|member|working
r_int
id|working
suffix:semicolon
multiline_comment|/* Is radio working correctly?&t;*/
DECL|member|structured_messages
r_int
id|structured_messages
suffix:semicolon
multiline_comment|/* Parsable AT response msgs?&t;*/
DECL|member|mtu
r_int
id|mtu
suffix:semicolon
multiline_comment|/* Our mtu (to spot changes!)&t;*/
DECL|member|watchdog_doprobe
r_int
id|watchdog_doprobe
suffix:semicolon
multiline_comment|/* Next time to test the radio&t;*/
DECL|member|watchdog_doreset
r_int
id|watchdog_doreset
suffix:semicolon
multiline_comment|/* Time to do next reset&t;*/
DECL|member|gratuitous_arp
r_int
id|gratuitous_arp
suffix:semicolon
multiline_comment|/* Time to send next ARP refresh*/
DECL|member|arp_interval
r_int
id|arp_interval
suffix:semicolon
multiline_comment|/* Next ARP interval&t;&t;*/
DECL|member|idle_timer
r_struct
id|timer_list
id|idle_timer
suffix:semicolon
multiline_comment|/* For periodic wakeup calls&t;*/
DECL|member|neighbor_list
id|MetricomNode
op_star
id|neighbor_list
suffix:semicolon
multiline_comment|/* The list of neighbor nodes   */
DECL|member|neighbor_list_locked
r_int
id|neighbor_list_locked
suffix:semicolon
multiline_comment|/* Indicates the list is locked */
DECL|member|firmware_version
id|MetricomFirmwareVersion
id|firmware_version
suffix:semicolon
multiline_comment|/* The radio&squot;s firmware version */
DECL|member|serial_number
id|MetricomSerialNumber
id|serial_number
suffix:semicolon
multiline_comment|/* The radio&squot;s serial number    */
DECL|member|battery_voltage
id|MetricomBatteryVoltage
id|battery_voltage
suffix:semicolon
multiline_comment|/* The radio&squot;s battery voltage  */
multiline_comment|/*&n;     * Other useful structures.&n;     */
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* ptr to TTY structure&t;&t;*/
DECL|member|if_name
r_char
id|if_name
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Dynamically generated name&t;*/
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
multiline_comment|/* Our device structure&t;&t;*/
multiline_comment|/*&n;     * Packet Logging Structures.&n;     */
DECL|member|num_sent
id|u_long
id|num_sent
suffix:semicolon
DECL|member|num_received
id|u_long
id|num_received
suffix:semicolon
DECL|member|next_entry
r_int
id|next_entry
suffix:semicolon
multiline_comment|/* The index of the oldest packet; */
multiline_comment|/* Also the next to be logged. */
DECL|member|packetLog
id|StripLog
id|packetLog
(braket
l_int|610
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Constants&t;&t;&t;&t;&t;&t;&t;&t;*/
macro_line|#ifdef MODULE
DECL|variable|StripVersion
r_static
r_const
r_char
id|StripVersion
(braket
)braket
op_assign
l_string|&quot;0.9.8-STUART.CHESHIRE-MODULAR&quot;
suffix:semicolon
macro_line|#else
DECL|variable|StripVersion
r_static
r_const
r_char
id|StripVersion
(braket
)braket
op_assign
l_string|&quot;0.9.8-STUART.CHESHIRE&quot;
suffix:semicolon
macro_line|#endif
DECL|variable|TickleString1
r_static
r_const
r_char
id|TickleString1
(braket
)braket
op_assign
l_string|&quot;***&amp;COMMAND*ATS305?&bslash;r&quot;
suffix:semicolon
DECL|variable|TickleString2
r_static
r_const
r_char
id|TickleString2
(braket
)braket
op_assign
l_string|&quot;***&amp;COMMAND*ATS305?&bslash;r&bslash;r&quot;
l_string|&quot;*&amp;COMMAND*ATS300?&bslash;r&bslash;r*&amp;COMMAND*ATS325?&bslash;r&bslash;r*&amp;COMMAND*AT~I2 nn&bslash;r&bslash;r&quot;
suffix:semicolon
DECL|variable|hextable
r_static
r_const
r_char
id|hextable
(braket
l_int|16
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
DECL|variable|zero_address
r_static
r_const
id|MetricomAddress
id|zero_address
suffix:semicolon
DECL|variable|broadcast_address
r_static
r_const
id|MetricomAddress
id|broadcast_address
op_assign
(brace
(brace
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)brace
)brace
suffix:semicolon
DECL|variable|SIP0Key
r_static
r_const
id|MetricomKey
id|SIP0Key
op_assign
(brace
(brace
l_string|&quot;SIP0&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ARP0Key
r_static
r_const
id|MetricomKey
id|ARP0Key
op_assign
(brace
(brace
l_string|&quot;ARP0&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ERR_Key
r_static
r_const
id|MetricomKey
id|ERR_Key
op_assign
(brace
(brace
l_string|&quot;ERR_&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ATR_Key
r_static
r_const
id|MetricomKey
id|ATR_Key
op_assign
(brace
(brace
l_string|&quot;ATR &quot;
)brace
)brace
suffix:semicolon
DECL|variable|MaxARPInterval
r_static
r_const
r_int
id|MaxARPInterval
op_assign
l_int|60
op_star
id|HZ
suffix:semicolon
multiline_comment|/* One minute */
multiline_comment|/*&n; * Maximum Starmode packet length (including starmode address) is 1183 bytes.&n; * Allowing 32 bytes for header, and 65/64 expansion for STRIP encoding,&n; * that translates to a maximum payload MTU of 1132.&n; */
DECL|variable|MAX_STRIP_MTU
r_static
r_const
r_int
r_int
id|MAX_STRIP_MTU
op_assign
l_int|1132
suffix:semicolon
DECL|variable|DEFAULT_STRIP_MTU
r_static
r_const
r_int
r_int
id|DEFAULT_STRIP_MTU
op_assign
l_int|1024
suffix:semicolon
DECL|variable|STRIP_MAGIC
r_static
r_const
r_int
id|STRIP_MAGIC
op_assign
l_int|0x5303
suffix:semicolon
DECL|variable|LongTime
r_static
r_const
r_int
id|LongTime
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
DECL|variable|STRIP_NODE_LEN
r_static
r_const
r_int
id|STRIP_NODE_LEN
op_assign
l_int|64
suffix:semicolon
DECL|variable|STRIP_PORTABLE_CHAR
r_static
r_const
r_char
id|STRIP_PORTABLE_CHAR
op_assign
l_char|&squot;P&squot;
suffix:semicolon
DECL|variable|STRIP_ROUTER_CHAR
r_static
r_const
r_char
id|STRIP_ROUTER_CHAR
op_assign
l_char|&squot;r&squot;
suffix:semicolon
DECL|variable|STRIP_PROC_BUFFER_SIZE
r_static
r_const
r_int
id|STRIP_PROC_BUFFER_SIZE
op_assign
l_int|4096
suffix:semicolon
DECL|variable|STRIP_LOG_INT_SIZE
r_static
r_const
r_int
id|STRIP_LOG_INT_SIZE
op_assign
l_int|10
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Global variables&t;&t;&t;&t;&t;&t;&t;*/
DECL|variable|struct_strip_list
r_static
r_struct
id|strip
op_star
id|struct_strip_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Macros&t;&t;&t;&t;&t;&t;&t;&t;*/
DECL|macro|READHEX
mdefine_line|#define READHEX(X) ((X)&gt;=&squot;0&squot; &amp;&amp; (X)&lt;=&squot;9&squot; ? (X)-&squot;0&squot; :      &bslash;&n;                    (X)&gt;=&squot;a&squot; &amp;&amp; (X)&lt;=&squot;f&squot; ? (X)-&squot;a&squot;+10 :   &bslash;&n;                    (X)&gt;=&squot;A&squot; &amp;&amp; (X)&lt;=&squot;F&squot; ? (X)-&squot;A&squot;+10 : 0 )
DECL|macro|READDEC
mdefine_line|#define READDEC(X) ((X)&gt;=&squot;0&squot; &amp;&amp; (X)&lt;=&squot;9&squot; ? (X)-&squot;0&squot; : 0)
DECL|macro|MIN
mdefine_line|#define MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))
DECL|macro|MAX
mdefine_line|#define MAX(X, Y) ((X) &gt; (Y) ? (X) : (Y))
DECL|macro|ELEMENTS_OF
mdefine_line|#define ELEMENTS_OF(X) (sizeof(X) / sizeof((X)[0]))
DECL|macro|ARRAY_END
mdefine_line|#define ARRAY_END(X) (&amp;((X)[ELEMENTS_OF(X)]))
multiline_comment|/* Encapsulation can expand packet of size x to 65/64x + 1              */
multiline_comment|/* Sent packet looks like &quot;*&lt;address&gt;*&lt;key&gt;&lt;encaps payload&gt;&lt;CR&gt;&quot;        */
multiline_comment|/*                         1   1-18  1  4         ?         1           */
multiline_comment|/* We allow 31 bytes for the stars, the key, the address and the &lt;CR&gt;   */
DECL|macro|STRIP_ENCAP_SIZE
mdefine_line|#define STRIP_ENCAP_SIZE(X) (32 + (X)*65L/64L)
DECL|macro|IS_RADIO_ADDRESS
mdefine_line|#define IS_RADIO_ADDRESS(p) (                                                   &bslash;&n;    isdigit((p)[0]) &amp;&amp; isdigit((p)[1]) &amp;&amp; isdigit((p)[2]) &amp;&amp; isdigit((p)[3]) &amp;&amp; &bslash;&n;    (p)[4] == &squot;-&squot; &amp;&amp;                                                            &bslash;&n;    isdigit((p)[5]) &amp;&amp; isdigit((p)[6]) &amp;&amp; isdigit((p)[7]) &amp;&amp; isdigit((p)[8])    )
DECL|macro|JIFFIE_TO_SEC
mdefine_line|#define JIFFIE_TO_SEC(X) ((X) / HZ)
multiline_comment|/************************************************************************/
multiline_comment|/* Utility routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|typedef|InterruptStatus
r_typedef
r_int
r_int
id|InterruptStatus
suffix:semicolon
DECL|function|DisableInterrupts
r_extern
id|__inline__
id|InterruptStatus
id|DisableInterrupts
c_func
(paren
r_void
)paren
(brace
id|InterruptStatus
id|x
suffix:semicolon
id|save_flags
c_func
(paren
id|x
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|RestoreInterrupts
r_extern
id|__inline__
r_void
id|RestoreInterrupts
c_func
(paren
id|InterruptStatus
id|x
)paren
(brace
id|restore_flags
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|DumpData
r_static
r_void
id|DumpData
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
r_static
r_const
r_int
id|MAX_DumpData
op_assign
l_int|80
suffix:semicolon
id|__u8
id|pkt_text
(braket
id|MAX_DumpData
)braket
comma
op_star
id|p
op_assign
id|pkt_text
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&quot;&squot;
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|p
OL
op_amp
id|pkt_text
(braket
id|MAX_DumpData
op_minus
l_int|4
)braket
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_ge
l_int|32
op_logical_and
op_star
id|ptr
op_le
l_int|126
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|ptr
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;&bslash;%02X&quot;
comma
op_star
id|ptr
)paren
suffix:semicolon
id|p
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
id|ptr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_eq
id|end
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&quot;&squot;
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %-13s%s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|msg
comma
id|pkt_text
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|HexDump
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|start
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|start
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|msg
comma
id|end
op_minus
id|ptr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
)paren
(brace
r_int
id|offset
op_assign
id|ptr
op_minus
id|start
suffix:semicolon
id|__u8
id|text
(braket
l_int|80
)braket
comma
op_star
id|p
op_assign
id|text
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|p
OL
op_amp
id|text
(braket
l_int|16
op_star
l_int|3
)braket
)paren
(brace
op_star
id|p
op_increment
op_assign
id|hextable
(braket
op_star
id|ptr
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|hextable
(braket
op_star
id|ptr
op_increment
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
id|p
(braket
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %4lX %s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|offset
comma
id|text
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/************************************************************************/
multiline_comment|/* Byte stuffing/unstuffing routines&t;&t;&t;&t;&t;*/
multiline_comment|/* Stuffing scheme:&n; * 00    Unused (reserved character)&n; * 01-3F Run of 2-64 different characters&n; * 40-7F Run of 1-64 different characters plus a single zero at the end&n; * 80-BF Run of 1-64 of the same character&n; * C0-FF Run of 1-64 zeroes (ASCII 0)&n; */
r_typedef
r_enum
(brace
DECL|enumerator|Stuff_Diff
id|Stuff_Diff
op_assign
l_int|0x00
comma
DECL|enumerator|Stuff_DiffZero
id|Stuff_DiffZero
op_assign
l_int|0x40
comma
DECL|enumerator|Stuff_Same
id|Stuff_Same
op_assign
l_int|0x80
comma
DECL|enumerator|Stuff_Zero
id|Stuff_Zero
op_assign
l_int|0xC0
comma
DECL|enumerator|Stuff_NoCode
id|Stuff_NoCode
op_assign
l_int|0xFF
comma
multiline_comment|/* Special code, meaning no code selected */
DECL|enumerator|Stuff_CodeMask
id|Stuff_CodeMask
op_assign
l_int|0xC0
comma
DECL|enumerator|Stuff_CountMask
id|Stuff_CountMask
op_assign
l_int|0x3F
comma
DECL|enumerator|Stuff_MaxCount
id|Stuff_MaxCount
op_assign
l_int|0x3F
comma
DECL|enumerator|Stuff_Magic
id|Stuff_Magic
op_assign
l_int|0x0D
multiline_comment|/* The value we are eliminating */
DECL|typedef|StuffingCode
)brace
id|StuffingCode
suffix:semicolon
multiline_comment|/* StuffData encodes the data starting at &quot;src&quot; for &quot;length&quot; bytes.&n; * It writes it to the buffer pointed to by &quot;dst&quot; (which must be at least&n; * as long as 1 + 65/64 of the input length). The output may be up to 1.6%&n; * larger than the input for pathological input, but will usually be smaller.&n; * StuffData returns the new value of the dst pointer as its result.&n; * &quot;code_ptr_ptr&quot; points to a &quot;__u8 *&quot; which is used to hold encoding state&n; * between calls, allowing an encoded packet to be incrementally built up&n; * from small parts. On the first call, the &quot;__u8 *&quot; pointed to should be&n; * initialized to NULL; between subsequent calls the calling routine should&n; * leave the value alone and simply pass it back unchanged so that the&n; * encoder can recover its current state.&n; */
DECL|macro|StuffData_FinishBlock
mdefine_line|#define StuffData_FinishBlock(X) &bslash;&n;(*code_ptr = (X) ^ Stuff_Magic, code = Stuff_NoCode)
DECL|function|StuffData
r_static
id|__u8
op_star
id|StuffData
c_func
(paren
id|__u8
op_star
id|src
comma
id|__u32
id|length
comma
id|__u8
op_star
id|dst
comma
id|__u8
op_star
op_star
id|code_ptr_ptr
)paren
(brace
id|__u8
op_star
id|end
op_assign
id|src
op_plus
id|length
suffix:semicolon
id|__u8
op_star
id|code_ptr
op_assign
op_star
id|code_ptr_ptr
suffix:semicolon
id|__u8
id|code
op_assign
id|Stuff_NoCode
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|code_ptr
)paren
(brace
multiline_comment|/*&n;         * Recover state from last call, if applicable&n;         */
id|code
op_assign
(paren
op_star
id|code_ptr
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CodeMask
suffix:semicolon
id|count
op_assign
(paren
op_star
id|code_ptr
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CountMask
suffix:semicolon
)brace
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
multiline_comment|/* Stuff_NoCode: If no current code, select one */
r_case
id|Stuff_NoCode
suffix:colon
multiline_comment|/* Record where we&squot;re going to put this code */
id|code_ptr
op_assign
id|dst
op_increment
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the count (zero means one instance) */
multiline_comment|/* Tentatively start a new block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|code
op_assign
id|Stuff_Zero
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
id|code
op_assign
id|Stuff_Same
suffix:semicolon
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
multiline_comment|/* Note: We optimistically assume run of same -- */
multiline_comment|/* which will be fixed later in Stuff_Same */
multiline_comment|/* if it turns out not to be true. */
r_break
suffix:semicolon
multiline_comment|/* Stuff_Zero: We already have at least one zero encoded */
r_case
id|Stuff_Zero
suffix:colon
multiline_comment|/* If another zero, count it, else finish this code block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|count
op_increment
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_Zero
op_plus
id|count
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Stuff_Same: We already have at least one byte encoded */
r_case
id|Stuff_Same
suffix:colon
multiline_comment|/* If another one the same, count it */
r_if
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_eq
id|code_ptr
(braket
l_int|1
)braket
)paren
(brace
id|count
op_increment
suffix:semicolon
id|src
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else, this byte does not match this block. */
multiline_comment|/* If we already have two or more bytes encoded, finish this code block */
r_if
c_cond
(paren
id|count
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_Same
op_plus
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else, we only have one so far, so switch to Stuff_Diff code */
id|code
op_assign
id|Stuff_Diff
suffix:semicolon
multiline_comment|/* and fall through to Stuff_Diff case below */
multiline_comment|/* Stuff_Diff: We have at least two *different* bytes encoded */
r_case
id|Stuff_Diff
suffix:colon
multiline_comment|/* If this is a zero, must encode a Stuff_DiffZero, and begin a new block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_DiffZero
op_plus
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* else, if we have three in a row, it is worth starting a Stuff_Same block */
r_else
r_if
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_eq
id|dst
(braket
op_minus
l_int|1
)braket
op_logical_and
id|dst
(braket
op_minus
l_int|1
)braket
op_eq
id|dst
(braket
op_minus
l_int|2
)braket
)paren
(brace
multiline_comment|/* Back off the last two characters we encoded */
id|code
op_add_assign
id|count
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* Note: &quot;Stuff_Diff + 0&quot; is an illegal code */
r_if
c_cond
(paren
id|code
op_eq
id|Stuff_Diff
op_plus
l_int|0
)paren
(brace
id|code
op_assign
id|Stuff_Same
op_plus
l_int|0
suffix:semicolon
)brace
id|StuffData_FinishBlock
c_func
(paren
id|code
)paren
suffix:semicolon
id|code_ptr
op_assign
id|dst
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* dst[-1] already holds the correct value */
id|count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 2 means three bytes encoded */
id|code
op_assign
id|Stuff_Same
suffix:semicolon
)brace
multiline_comment|/* else, another different byte, so add it to the block */
r_else
(brace
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|src
op_increment
suffix:semicolon
multiline_comment|/* Consume the byte */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
id|Stuff_MaxCount
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|code
op_plus
id|count
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|code
op_eq
id|Stuff_NoCode
)paren
(brace
op_star
id|code_ptr_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|code_ptr_ptr
op_assign
id|code_ptr
suffix:semicolon
id|StuffData_FinishBlock
c_func
(paren
id|code
op_plus
id|count
)paren
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/*&n; * UnStuffData decodes the data at &quot;src&quot;, up to (but not including) &quot;end&quot;.&n; * It writes the decoded data into the buffer pointed to by &quot;dst&quot;, up to a&n; * maximum of &quot;dst_length&quot;, and returns the new value of &quot;src&quot; so that a&n; * follow-on call can read more data, continuing from where the first left off.&n; * &n; * There are three types of results:&n; * 1. The source data runs out before extracting &quot;dst_length&quot; bytes:&n; *    UnStuffData returns NULL to indicate failure.&n; * 2. The source data produces exactly &quot;dst_length&quot; bytes:&n; *    UnStuffData returns new_src = end to indicate that all bytes were consumed.&n; * 3. &quot;dst_length&quot; bytes are extracted, with more remaining.&n; *    UnStuffData returns new_src &lt; end to indicate that there are more bytes&n; *    to be read.&n; * &n; * Note: The decoding may be destructive, in that it may alter the source&n; * data in the process of decoding it (this is necessary to allow a follow-on&n; * call to resume correctly).&n; */
DECL|function|UnStuffData
r_static
id|__u8
op_star
id|UnStuffData
c_func
(paren
id|__u8
op_star
id|src
comma
id|__u8
op_star
id|end
comma
id|__u8
op_star
id|dst
comma
id|__u32
id|dst_length
)paren
(brace
id|__u8
op_star
id|dst_end
op_assign
id|dst
op_plus
id|dst_length
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
op_logical_neg
id|src
op_logical_or
op_logical_neg
id|end
op_logical_or
op_logical_neg
id|dst
op_logical_or
op_logical_neg
id|dst_length
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
r_int
id|count
op_assign
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CountMask
suffix:semicolon
r_switch
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CodeMask
)paren
(brace
r_case
id|Stuff_Diff
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_plus
id|count
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
op_star
op_increment
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
op_star
id|src
op_assign
id|Stuff_Same
op_xor
id|Stuff_Magic
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Diff
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|Stuff_DiffZero
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_plus
id|count
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
op_star
op_increment
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
op_star
id|src
op_assign
id|Stuff_Zero
op_xor
id|Stuff_Magic
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_DiffZero
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Stuff_Same
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
id|src
(braket
l_int|1
)braket
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|2
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Same
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Stuff_Zero
suffix:colon
r_do
(brace
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|1
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Zero
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dst
OL
id|dst_end
)paren
r_return
l_int|NULL
suffix:semicolon
r_else
r_return
id|src
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* General routines for STRIP&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * Convert a string to a Metricom Address.&n; */
DECL|function|string_to_radio_address
r_static
r_void
id|string_to_radio_address
c_func
(paren
id|MetricomAddress
op_star
id|addr
comma
id|__u8
op_star
id|p
)paren
(brace
id|addr-&gt;c
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|addr-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|addr-&gt;c
(braket
l_int|2
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|0
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|addr-&gt;c
(braket
l_int|3
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|2
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|addr-&gt;c
(braket
l_int|4
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|5
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|addr-&gt;c
(braket
l_int|5
)braket
op_assign
id|READHEX
c_func
(paren
id|p
(braket
l_int|7
)braket
)paren
op_lshift
l_int|4
op_or
id|READHEX
c_func
(paren
id|p
(braket
l_int|8
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a Metricom Address to a string.&n; */
DECL|function|radio_address_to_string
r_static
id|__u8
op_star
id|radio_address_to_string
c_func
(paren
r_const
id|MetricomAddress
op_star
id|addr
comma
id|MetricomAddressString
op_star
id|p
)paren
(brace
id|sprintf
c_func
(paren
id|p-&gt;c
comma
l_string|&quot;%02X%02X-%02X%02X&quot;
comma
id|addr-&gt;c
(braket
l_int|2
)braket
comma
id|addr-&gt;c
(braket
l_int|3
)braket
comma
id|addr-&gt;c
(braket
l_int|4
)braket
comma
id|addr-&gt;c
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_return
id|p-&gt;c
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: Must make sure sx_size is big enough to receive a stuffed&n; * MAX_STRIP_MTU packet. Additionally, we also want to ensure that it&squot;s&n; * big enough to receive a large radio neighbour list (currently 4K).&n; */
DECL|function|allocate_buffers
r_static
r_int
id|allocate_buffers
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
r_int
id|stuffedlen
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
id|dev-&gt;mtu
)paren
suffix:semicolon
r_int
id|sx_size
op_assign
id|MAX
c_func
(paren
id|stuffedlen
comma
l_int|4096
)paren
suffix:semicolon
r_int
id|tx_size
op_assign
id|stuffedlen
op_plus
r_sizeof
(paren
id|TickleString2
)paren
suffix:semicolon
id|__u8
op_star
id|r
op_assign
id|kmalloc
c_func
(paren
id|MAX_STRIP_MTU
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|__u8
op_star
id|s
op_assign
id|kmalloc
c_func
(paren
id|sx_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|__u8
op_star
id|t
op_assign
id|kmalloc
c_func
(paren
id|tx_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_logical_and
id|s
op_logical_and
id|t
)paren
(brace
id|strip_info-&gt;rx_buff
op_assign
id|r
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
id|s
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
id|t
suffix:semicolon
id|strip_info-&gt;sx_size
op_assign
id|sx_size
suffix:semicolon
id|strip_info-&gt;tx_size
op_assign
id|tx_size
suffix:semicolon
id|strip_info-&gt;mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
)paren
id|kfree
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * MTU has been changed by the IP layer. Unfortunately we are not told&n; * about this, but we spot it ourselves and fix things up. We could be in&n; * an upcall from the tty driver, or in an ip packet queue.&n; */
DECL|function|strip_changedmtu
r_static
r_void
id|strip_changedmtu
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_int
id|old_mtu
op_assign
id|strip_info-&gt;mtu
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
r_int
r_char
op_star
id|orbuff
op_assign
id|strip_info-&gt;rx_buff
suffix:semicolon
r_int
r_char
op_star
id|osbuff
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
r_int
r_char
op_star
id|otbuff
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|InterruptStatus
id|intstat
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mtu
OG
id|MAX_STRIP_MTU
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: MTU exceeds maximum allowable (%d), MTU change cancelled.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|MAX_STRIP_MTU
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|old_mtu
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Have to disable interrupts here because we&squot;re reallocating and resizing&n;     * the serial buffers, and we can&squot;t have data arriving in them while we&squot;re&n;     * moving them around in memory. This may cause data to be lost on the serial&n;     * port, but hopefully people won&squot;t change MTU that often.&n;     * Also note, this may not work on a symmetric multi-processor system.&n;     */
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allocate_buffers
c_func
(paren
id|strip_info
)paren
)paren
(brace
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to grow strip buffers, MTU change cancelled.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|old_mtu
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
)paren
(brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_le
id|strip_info-&gt;sx_size
)paren
id|memcpy
c_func
(paren
id|strip_info-&gt;sx_buff
comma
id|osbuff
comma
id|strip_info-&gt;sx_count
)paren
suffix:semicolon
r_else
(brace
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;rx_over_errors
op_increment
suffix:semicolon
id|strip_info-&gt;discard
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
)paren
(brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
op_le
id|strip_info-&gt;tx_size
)paren
id|memcpy
c_func
(paren
id|strip_info-&gt;tx_buff
comma
id|strip_info-&gt;tx_head
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
r_else
(brace
id|strip_info-&gt;tx_left
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
)brace
)brace
id|strip_info-&gt;tx_head
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: strip MTU changed fom %d to %d.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|old_mtu
comma
id|strip_info-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orbuff
)paren
id|kfree
c_func
(paren
id|orbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|osbuff
)paren
id|kfree
c_func
(paren
id|osbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|otbuff
)paren
id|kfree
c_func
(paren
id|otbuff
)paren
suffix:semicolon
)brace
DECL|function|strip_unlock
r_static
r_void
id|strip_unlock
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
multiline_comment|/*&n;     * Set the time to go off in one second.&n;     */
id|strip_info-&gt;idle_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|strip_info-&gt;dev.tbusy
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: trying to unlock already unlocked device!&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Callback routines for exporting information through /proc&t;&t;*/
macro_line|#if DO_PROC_NET_STRIP_STATUS | DO_PROC_NET_STRIP_TRACE
multiline_comment|/*&n; * This function updates the total amount of data printed so far. It then&n; * determines if the amount of data printed into a buffer  has reached the&n; * offset requested. If it hasn&squot;t, then the buffer is shifted over so that&n; * the next bit of data can be printed over the old bit. If the total&n; * amount printed so far exceeds the total amount requested, then this&n; * function returns 1, otherwise 0.&n; */
r_static
r_int
DECL|function|shift_buffer
id|shift_buffer
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|requested_offset
comma
r_int
id|requested_len
comma
r_int
op_star
id|total
comma
r_int
op_star
id|slop
comma
r_char
op_star
op_star
id|buf
)paren
(brace
r_int
id|printed
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;shift: buffer: %d o: %d l: %d t: %d buf: %d&bslash;n&quot;,&n;&t;   (int) buffer, requested_offset, requested_len, *total,&n;&t;   (int) *buf); */
id|printed
op_assign
op_star
id|buf
op_minus
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_star
id|total
op_plus
id|printed
op_le
id|requested_offset
)paren
(brace
op_star
id|total
op_add_assign
id|printed
suffix:semicolon
op_star
id|buf
op_assign
id|buffer
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|total
OL
id|requested_offset
)paren
(brace
op_star
id|slop
op_assign
id|requested_offset
op_minus
op_star
id|total
suffix:semicolon
)brace
op_star
id|total
op_assign
id|requested_offset
op_plus
id|printed
op_minus
op_star
id|slop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|total
OG
id|requested_offset
op_plus
id|requested_len
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function calculates the actual start of the requested data&n; * in the buffer. It also calculates actual length of data returned,&n; * which could be less that the amount of data requested.&n; */
r_static
r_int
DECL|function|calc_start_len
id|calc_start_len
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
r_int
id|requested_offset
comma
r_int
id|requested_len
comma
r_int
id|total
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|return_len
comma
id|buffer_len
suffix:semicolon
id|buffer_len
op_assign
id|buf
op_minus
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|buffer_len
op_ge
id|STRIP_PROC_BUFFER_SIZE
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: exceeded /proc buffer size&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * There may be bytes before and after the&n;     * chunk that was actually requested.&n;     */
id|return_len
op_assign
id|total
op_minus
id|requested_offset
suffix:semicolon
r_if
c_cond
(paren
id|return_len
OL
l_int|0
)paren
(brace
id|return_len
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buf
op_minus
id|return_len
suffix:semicolon
r_if
c_cond
(paren
id|return_len
OG
id|requested_len
)paren
(brace
id|return_len
op_assign
id|requested_len
suffix:semicolon
)brace
multiline_comment|/* printk(KERN_DEBUG &quot;return_len: %d&bslash;n&quot;, return_len); */
r_return
id|return_len
suffix:semicolon
)brace
macro_line|#endif DO_PROC_NET_STRIP_STATUS | DO_PROC_NET_STRIP_TRACE
macro_line|#if DO_PROC_NET_STRIP_STATUS
multiline_comment|/*&n; * If the time is in the near future, time_delta prints the number of&n; * seconds to go into the buffer and returns the address of the buffer.&n; * If the time is not in the near future, it returns the address of the&n; * string &quot;Not scheduled&quot; The buffer must be long enough to contain the&n; * ascii representation of the number plus 9 charactes for the &quot; seconds&quot;&n; * and the null character.&n; */
DECL|function|time_delta
r_static
r_char
op_star
id|time_delta
c_func
(paren
r_char
id|buffer
(braket
)braket
comma
r_int
id|time
)paren
(brace
id|time
op_sub_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|time
OG
id|LongTime
op_div
l_int|2
)paren
r_return
l_string|&quot;Not scheduled&quot;
suffix:semicolon
r_if
c_cond
(paren
id|time
OL
l_int|0
)paren
(brace
id|time
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t print negative times */
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%ld seconds&quot;
comma
id|time
op_div
id|HZ
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * This function prints radio status information into the specified&n; * buffer.&n; */
r_static
r_int
DECL|function|sprintf_status_info
id|sprintf_status_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_char
id|temp_buffer
(braket
l_int|32
)braket
suffix:semicolon
id|MetricomAddressString
id|addr_string
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;Interface name&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|strip_info-&gt;if_name
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Radio working:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|strip_info-&gt;working
op_logical_and
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doreset
OL
l_int|0
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|radio_address_to_string
c_func
(paren
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|strip_info-&gt;dev.dev_addr
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Device address:&bslash;t%s&bslash;n&quot;
comma
id|addr_string.c
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Firmware version:&bslash;t%s&bslash;n&quot;
comma
op_logical_neg
id|strip_info-&gt;working
ques
c_cond
l_string|&quot;Unknown&quot;
suffix:colon
op_logical_neg
id|strip_info-&gt;structured_messages
ques
c_cond
l_string|&quot;Should be upgraded&quot;
suffix:colon
id|strip_info-&gt;firmware_version.c
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Serial number:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|strip_info-&gt;serial_number.c
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Battery voltage:&bslash;t%s&bslash;n&quot;
comma
id|strip_info-&gt;battery_voltage.c
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Transmit queue (bytes):%d&bslash;n&quot;
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Next watchdog probe:&bslash;t%s&bslash;n&quot;
comma
id|time_delta
c_func
(paren
id|temp_buffer
comma
id|strip_info-&gt;watchdog_doprobe
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Next watchdog reset:&bslash;t%s&bslash;n&quot;
comma
id|time_delta
c_func
(paren
id|temp_buffer
comma
id|strip_info-&gt;watchdog_doreset
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Next gratuitous ARP:&bslash;t%s&bslash;n&quot;
comma
id|time_delta
c_func
(paren
id|temp_buffer
comma
id|strip_info-&gt;gratuitous_arp
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; Next ARP interval:&bslash;t%ld seconds&bslash;n&quot;
comma
id|JIFFIE_TO_SEC
c_func
(paren
id|strip_info-&gt;arp_interval
)paren
)paren
suffix:semicolon
r_return
id|buf
op_minus
id|buffer
suffix:semicolon
)brace
r_static
r_int
DECL|function|sprintf_portables
id|sprintf_portables
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|MetricomAddressString
id|addr_string
suffix:semicolon
id|MetricomNode
op_star
id|node
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; portables: name&bslash;t&bslash;tpoll_latency&bslash;tsignal strength&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|strip_info-&gt;neighbor_list
suffix:semicolon
id|node
op_ne
l_int|NULL
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|node-&gt;type
op_amp
id|NodeValid
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;type
op_amp
id|NodeHasWAN
)paren
(brace
r_continue
suffix:semicolon
)brace
(paren
r_void
)paren
id|radio_address_to_string
c_func
(paren
op_amp
id|node-&gt;addr
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;  %s&bslash;t&bslash;t&bslash;t&bslash;t%d&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|addr_string.c
comma
id|node-&gt;poll_latency
comma
id|node-&gt;rssi
)paren
suffix:semicolon
)brace
r_return
id|buf
op_minus
id|buffer
suffix:semicolon
)brace
r_static
r_int
DECL|function|sprintf_poletops
id|sprintf_poletops
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|MetricomNode
op_star
id|node
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; poletops: GPS&bslash;t&bslash;t&bslash;tpoll_latency&bslash;tsignal strength&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|strip_info-&gt;neighbor_list
suffix:semicolon
id|node
op_ne
l_int|NULL
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|node-&gt;type
op_amp
id|NodeValid
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|node-&gt;type
op_amp
id|NodeHasWAN
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;  %s&bslash;t&bslash;t&bslash;t%d&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|node-&gt;gl.s
comma
id|node-&gt;poll_latency
comma
id|node-&gt;rssi
)paren
suffix:semicolon
)brace
r_return
id|buf
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is exports status information from the STRIP driver through&n; * the /proc file system. /proc filesystem should be fixed:&n; *    1) slow (sprintfs here, a memory copy in the proc that calls this one)&n; *    2) length of buffer not passed&n; *    3) dummy isn&squot;t client data set when the callback was registered&n; *    4) poorly documented (this function is called until the requested amount&n; *       of data is returned, buffer is only 4K long, dummy is the permissions&n; *       of the file (?), the proc_dir_entry passed to proc_net_register must&n; *       be kmalloc-ed)&n; */
r_static
r_int
DECL|function|strip_get_status_info
id|strip_get_status_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|requested_offset
comma
r_int
id|requested_len
comma
r_int
id|dummy
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|total
op_assign
l_int|0
comma
id|slop
op_assign
l_int|0
comma
id|len_exceeded
suffix:semicolon
id|InterruptStatus
id|i_status
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
suffix:semicolon
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;strip_version: %s&bslash;n&quot;
comma
id|StripVersion
)paren
suffix:semicolon
id|i_status
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|strip_info
op_assign
id|struct_strip_list
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|i_status
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strip_info
op_ne
l_int|NULL
)paren
(brace
id|i_status
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf_status_info
c_func
(paren
id|buf
comma
id|strip_info
)paren
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|i_status
)paren
suffix:semicolon
id|len_exceeded
op_assign
id|shift_buffer
c_func
(paren
id|buffer
comma
id|requested_offset
comma
id|requested_len
comma
op_amp
id|total
comma
op_amp
id|slop
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_exceeded
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|strip_info-&gt;neighbor_list_locked
op_assign
id|TRUE
suffix:semicolon
id|buf
op_add_assign
id|sprintf_portables
c_func
(paren
id|buf
comma
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;neighbor_list_locked
op_assign
id|FALSE
suffix:semicolon
id|len_exceeded
op_assign
id|shift_buffer
c_func
(paren
id|buffer
comma
id|requested_offset
comma
id|requested_len
comma
op_amp
id|total
comma
op_amp
id|slop
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_exceeded
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|strip_info-&gt;neighbor_list_locked
op_assign
id|TRUE
suffix:semicolon
id|buf
op_add_assign
id|sprintf_poletops
c_func
(paren
id|buf
comma
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;neighbor_list_locked
op_assign
id|FALSE
suffix:semicolon
id|len_exceeded
op_assign
id|shift_buffer
c_func
(paren
id|buffer
comma
id|requested_offset
comma
id|requested_len
comma
op_amp
id|total
comma
op_amp
id|slop
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_exceeded
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|strip_info
op_assign
id|strip_info-&gt;next
suffix:semicolon
)brace
id|done
suffix:colon
r_return
id|calc_start_len
c_func
(paren
id|buffer
comma
id|start
comma
id|requested_offset
comma
id|requested_len
comma
id|total
comma
id|buf
)paren
suffix:semicolon
)brace
macro_line|#endif DO_PROC_NET_STRIP_STATUS
macro_line|#if DO_PROC_NET_STRIP_TRACE
multiline_comment|/*&n; * Convert an Ethernet protocol to a string&n; * Returns the number of characters printed.&n; */
DECL|function|protocol_to_string
r_static
r_int
id|protocol_to_string
c_func
(paren
r_int
id|protocol
comma
id|__u8
op_star
id|p
)paren
(brace
r_int
id|printed
suffix:semicolon
r_switch
c_cond
(paren
id|protocol
)paren
(brace
r_case
id|ETH_P_IP
suffix:colon
id|printed
op_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;IP&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_ARP
suffix:colon
id|printed
op_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;ARP&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printed
op_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d&quot;
comma
id|protocol
)paren
suffix:semicolon
)brace
r_return
id|printed
suffix:semicolon
)brace
r_static
r_int
DECL|function|sprintf_log_entry
id|sprintf_log_entry
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|strip
op_star
id|strip_info
comma
r_int
id|packet_index
)paren
(brace
id|StripLog
op_star
id|entry
suffix:semicolon
id|MetricomAddressString
id|addr_string
suffix:semicolon
id|__u8
id|sig_buf
(braket
l_int|24
)braket
comma
op_star
id|s
suffix:semicolon
r_char
op_star
id|buf
comma
id|proto_buf
(braket
l_int|10
)braket
suffix:semicolon
id|entry
op_assign
op_amp
id|strip_info-&gt;packetLog
(braket
id|packet_index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;valid
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%-4s %s   %7lu &quot;
comma
id|strip_info-&gt;if_name
comma
id|ENTRY_TYPE_TO_STRING
c_func
(paren
id|entry-&gt;entry_type
)paren
comma
id|entry-&gt;seqNum
)paren
suffix:semicolon
(paren
r_void
)paren
id|protocol_to_string
c_func
(paren
id|entry-&gt;packet_type
comma
id|proto_buf
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%-4s&quot;
comma
id|proto_buf
)paren
suffix:semicolon
id|s
op_assign
id|entry-&gt;sig.print_sig
suffix:semicolon
id|sprintf
c_func
(paren
id|sig_buf
comma
l_string|&quot;%d.%d.%d.%d.%d.%d&quot;
comma
id|s
(braket
l_int|0
)braket
comma
id|s
(braket
l_int|1
)braket
comma
id|s
(braket
l_int|2
)braket
comma
id|s
(braket
l_int|3
)braket
comma
id|s
(braket
l_int|4
)braket
comma
id|s
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%-24s&quot;
comma
id|sig_buf
)paren
suffix:semicolon
(paren
r_void
)paren
id|radio_address_to_string
c_func
(paren
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|entry-&gt;src
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%-10s&quot;
comma
id|addr_string.c
)paren
suffix:semicolon
(paren
r_void
)paren
id|radio_address_to_string
c_func
(paren
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|entry-&gt;dest
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%-10s&quot;
comma
id|addr_string.c
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%8d %6d %5lu %6lu %5lu&bslash;n&quot;
comma
id|entry-&gt;timeStamp.tv_sec
comma
id|entry-&gt;timeStamp.tv_usec
comma
id|entry-&gt;rawSize
comma
id|entry-&gt;stripSize
comma
id|entry-&gt;slipSize
)paren
suffix:semicolon
r_return
id|buf
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * This function exports trace information from the STRIP driver through the&n; * /proc file system.&n; */
r_static
r_int
DECL|function|strip_get_trace_info
id|strip_get_trace_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|requested_offset
comma
r_int
id|requested_len
comma
r_int
id|dummy
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|len_exceeded
comma
id|total
op_assign
l_int|0
comma
id|slop
op_assign
l_int|0
comma
id|packet_index
comma
id|oldest
suffix:semicolon
id|InterruptStatus
id|i_status
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
suffix:semicolon
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;if   s/r seqnum  t   signature               &quot;
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;src       dest      sec      usec   raw   strip  slip&bslash;n&quot;
)paren
suffix:semicolon
id|i_status
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|strip_info
op_assign
id|struct_strip_list
suffix:semicolon
id|oldest
op_assign
id|strip_info-&gt;next_entry
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|i_status
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we disable interrupts for this entire loop,&n;     * characters from the serial port could be lost,&n;     * so we only disable interrupts when accessing&n;     * a log entry. If more than STRIP_LOG_INT_SIZE&n;     * packets are logged before the first entry is&n;     * printed, then some of the entries could be&n;     * printed out of order.&n;     */
r_while
c_loop
(paren
id|strip_info
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|packet_index
op_assign
id|oldest
op_plus
id|STRIP_LOG_INT_SIZE
suffix:semicolon
id|packet_index
op_ne
id|oldest
suffix:semicolon
id|packet_index
op_assign
(paren
id|packet_index
op_plus
l_int|1
)paren
op_mod
id|ELEMENTS_OF
c_func
(paren
id|strip_info-&gt;packetLog
)paren
)paren
(brace
id|i_status
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|buf
op_add_assign
id|sprintf_log_entry
c_func
(paren
id|buf
comma
id|strip_info
comma
id|packet_index
)paren
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|i_status
)paren
suffix:semicolon
id|len_exceeded
op_assign
id|shift_buffer
c_func
(paren
id|buffer
comma
id|requested_offset
comma
id|requested_len
comma
op_amp
id|total
comma
op_amp
id|slop
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_exceeded
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
)brace
id|strip_info
op_assign
id|strip_info-&gt;next
suffix:semicolon
)brace
id|done
suffix:colon
r_return
id|calc_start_len
c_func
(paren
id|buffer
comma
id|start
comma
id|requested_offset
comma
id|requested_len
comma
id|total
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|slip_len
r_static
r_int
id|slip_len
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_static
r_const
r_int
r_char
id|SLIP_END
op_assign
l_int|0300
suffix:semicolon
multiline_comment|/* indicates end of SLIP frame&t;*/
r_static
r_const
r_int
r_char
id|SLIP_ESC
op_assign
l_int|0333
suffix:semicolon
multiline_comment|/* indicates SLIP byte stuffing&t;*/
r_int
id|count
op_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|len
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|data
op_eq
id|SLIP_END
op_logical_or
op_star
id|data
op_eq
id|SLIP_ESC
)paren
id|count
op_increment
suffix:semicolon
id|data
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Copied from kernel/sched.c */
DECL|function|jiffiestotimeval
r_static
r_void
id|jiffiestotimeval
c_func
(paren
r_int
r_int
id|jiffies
comma
r_struct
id|timeval
op_star
id|value
)paren
(brace
id|value-&gt;tv_usec
op_assign
(paren
id|jiffies
op_mod
id|HZ
)paren
op_star
(paren
l_float|1000000.0
op_div
id|HZ
)paren
suffix:semicolon
id|value-&gt;tv_sec
op_assign
id|jiffies
op_div
id|HZ
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function logs a packet.&n; * A pointer to the packet itself is passed so that some of the data can be&n; * used to compute a signature. The pointer should point the the&n; * part of the packet following the STRIP_header.&n; */
DECL|function|packet_log
r_static
r_void
id|packet_log
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|packet
comma
id|LogEntry
id|entry_type
comma
id|STRIP_Header
op_star
id|hdr
comma
r_int
id|raw_size
comma
r_int
id|strip_size
comma
r_int
id|slip_size
)paren
(brace
id|StripLog
op_star
id|entry
suffix:semicolon
r_struct
id|iphdr
op_star
id|iphdr
suffix:semicolon
r_struct
id|arphdr
op_star
id|arphdr
suffix:semicolon
id|entry
op_assign
op_amp
id|strip_info-&gt;packetLog
(braket
id|strip_info-&gt;next_entry
)braket
suffix:semicolon
r_if
c_cond
(paren
id|entry_type
op_eq
id|EntrySend
)paren
(brace
id|entry-&gt;seqNum
op_assign
id|strip_info-&gt;num_sent
op_increment
suffix:semicolon
)brace
r_else
(brace
id|entry-&gt;seqNum
op_assign
id|strip_info-&gt;num_received
op_increment
suffix:semicolon
)brace
id|entry-&gt;entry_type
op_assign
id|entry_type
suffix:semicolon
id|entry-&gt;packet_type
op_assign
id|ntohs
c_func
(paren
id|hdr-&gt;protocol
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;packet_type
)paren
(brace
r_case
id|ETH_P_IP
suffix:colon
multiline_comment|/*&n;&t; * The signature for IP is the sender&squot;s ip address and&n;&t; * the identification field.&n;&t; */
id|iphdr
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|packet
suffix:semicolon
id|entry-&gt;sig.ip_sig.id
op_assign
id|iphdr-&gt;id
suffix:semicolon
id|entry-&gt;sig.ip_sig.src.l
op_assign
id|iphdr-&gt;saddr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_ARP
suffix:colon
multiline_comment|/*&n;&t; * The signature for ARP is the sender&squot;s ip address and&n;&t; * the operation.&n;&t; */
id|arphdr
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|packet
suffix:semicolon
id|entry-&gt;sig.arp_sig.op
op_assign
id|arphdr-&gt;ar_op
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;sig.arp_sig.src.l
comma
id|packet
op_plus
l_int|8
op_plus
id|arphdr-&gt;ar_hln
comma
r_sizeof
(paren
id|entry-&gt;sig.arp_sig.src.l
)paren
)paren
suffix:semicolon
id|entry-&gt;sig.arp_sig.src.l
op_assign
id|entry-&gt;sig.arp_sig.src.l
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;STRIP: packet_log: unknown packet type: %d&bslash;n&quot;
comma
id|entry-&gt;packet_type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;src
comma
op_amp
id|hdr-&gt;src_addr
comma
r_sizeof
(paren
id|MetricomAddress
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;dest
comma
op_amp
id|hdr-&gt;dst_addr
comma
r_sizeof
(paren
id|MetricomAddress
)paren
)paren
suffix:semicolon
id|jiffiestotimeval
c_func
(paren
id|jiffies
comma
op_amp
(paren
id|entry-&gt;timeStamp
)paren
)paren
suffix:semicolon
id|entry-&gt;rawSize
op_assign
id|raw_size
suffix:semicolon
id|entry-&gt;stripSize
op_assign
id|strip_size
suffix:semicolon
id|entry-&gt;slipSize
op_assign
id|slip_size
suffix:semicolon
id|entry-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|strip_info-&gt;next_entry
op_assign
(paren
id|strip_info-&gt;next_entry
op_plus
l_int|1
)paren
op_mod
id|ELEMENTS_OF
c_func
(paren
id|strip_info-&gt;packetLog
)paren
suffix:semicolon
)brace
macro_line|#endif DO_PROC_NET_STRIP_TRACE
multiline_comment|/*&n; * This function parses the response to the ATS300? command,&n; * extracting the radio version and serial number.&n; */
DECL|function|get_radio_version
r_static
r_void
id|get_radio_version
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u8
op_star
id|p
comma
op_star
id|value_begin
comma
op_star
id|value_end
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Determine the beginning of the second line of the payload */
id|p
op_assign
id|ptr
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|value_begin
op_assign
id|p
suffix:semicolon
multiline_comment|/* Determine the end of line */
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
id|value_end
op_assign
id|p
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|len
op_assign
id|value_end
op_minus
id|value_begin
suffix:semicolon
id|len
op_assign
id|MIN
c_func
(paren
id|len
comma
r_sizeof
(paren
id|MetricomFirmwareVersion
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|strip_info-&gt;firmware_version.c
comma
l_string|&quot;%.*s&quot;
comma
id|len
comma
id|value_begin
)paren
suffix:semicolon
multiline_comment|/* Look for the first colon */
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
multiline_comment|/* Skip over the space */
id|p
op_add_assign
l_int|2
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|MetricomSerialNumber
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p
op_plus
id|len
op_le
id|end
)paren
(brace
id|sprintf
c_func
(paren
id|strip_info-&gt;serial_number.c
comma
l_string|&quot;%.*s&quot;
comma
id|len
comma
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: radio serial number shorter (%d) than expected (%d)&bslash;n&quot;
comma
id|end
op_minus
id|p
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function parses the response to the ATS325? command,&n; * extracting the radio battery voltage.&n; */
DECL|function|get_radio_voltage
r_static
r_void
id|get_radio_voltage
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|MetricomBatteryVoltage
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_plus
id|len
op_le
id|end
)paren
(brace
id|sprintf
c_func
(paren
id|strip_info-&gt;battery_voltage.c
comma
l_string|&quot;%.*s&quot;
comma
id|len
comma
id|ptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: radio voltage string shorter (%d) than expected (%d)&bslash;n&quot;
comma
id|end
op_minus
id|ptr
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function parses the response to the AT~I2 command,&n; * which gives the names of the radio&squot;s nearest neighbors.&n; * It relies on the format of the response.&n; */
DECL|function|get_radio_neighbors
r_static
r_void
id|get_radio_neighbors
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u8
op_star
id|p
comma
op_star
id|line_begin
suffix:semicolon
r_int
id|num_nodes_reported
comma
id|num_nodes_counted
suffix:semicolon
id|MetricomNode
op_star
id|node
comma
op_star
id|last
suffix:semicolon
multiline_comment|/* Check if someone is reading the list */
r_if
c_cond
(paren
id|strip_info-&gt;neighbor_list_locked
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Determine the number of Nodes */
id|p
op_assign
id|ptr
suffix:semicolon
id|num_nodes_reported
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;num_nodes: %d&bslash;n&quot;, num_nodes_reported); */
multiline_comment|/* Determine the beginning of the next line */
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
id|p
op_increment
suffix:semicolon
multiline_comment|/*&n;     * The node list should never be empty because we allocate one empty&n;     * node when the strip_info is allocated. The nodes which were allocated&n;     * when the number of neighbors was high but are no longer needed because&n;     * there aren&squot;t as many neighbors any more are marked invalid. Invalid nodes&n;     * are kept at the end of the list.&n;     */
id|node
op_assign
id|strip_info-&gt;neighbor_list
suffix:semicolon
id|last
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|NULL
)paren
(brace
id|DumpData
c_func
(paren
l_string|&quot;Neighbor list is NULL:&quot;
comma
id|strip_info
comma
id|p
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|line_begin
op_assign
id|p
suffix:semicolon
id|num_nodes_counted
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|line_begin
OL
id|end
)paren
(brace
multiline_comment|/* Check to see if the format is what we expect. */
r_if
c_cond
(paren
(paren
id|line_begin
op_plus
id|STRIP_NODE_LEN
)paren
OG
id|end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: radio neighbor node string shorter (%d) than expected (%d)&bslash;n&quot;
comma
id|end
op_minus
id|line_begin
comma
id|STRIP_NODE_LEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Get a node */
r_if
c_cond
(paren
id|node
op_eq
l_int|NULL
)paren
(brace
id|node
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|MetricomNode
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|node-&gt;type
op_assign
id|NodeValid
suffix:semicolon
multiline_comment|/* Fill the node in */
multiline_comment|/* Determine if it has a GPS location and fill it in if it does. */
id|p
op_assign
id|line_begin
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;node: %64s&bslash;n&quot;, p); */
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
id|STRIP_PORTABLE_CHAR
)paren
(brace
id|node-&gt;type
op_or_assign
id|NodeHasWAN
suffix:semicolon
id|sprintf
c_func
(paren
id|node-&gt;gl.s
comma
l_string|&quot;%.*s&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
id|GeographicLocation
)paren
op_minus
l_int|1
comma
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if it is a router */
id|p
op_assign
id|line_begin
op_plus
l_int|18
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|STRIP_ROUTER_CHAR
)paren
(brace
id|node-&gt;type
op_or_assign
id|NodeIsRouter
suffix:semicolon
)brace
multiline_comment|/* Could be a radio address or some weird poletop address. */
id|p
op_assign
id|line_begin
op_plus
l_int|20
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;before addr: %6s&bslash;n&quot;, p); */
id|string_to_radio_address
c_func
(paren
op_amp
id|node-&gt;addr
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* radio_address_to_string(&amp;node-&gt;addr, addr_string);&n;&t;printk(KERN_DEBUG &quot;after addr: %s&bslash;n&quot;, addr_string);  */
r_if
c_cond
(paren
id|IS_RADIO_ADDRESS
c_func
(paren
id|p
)paren
)paren
(brace
id|string_to_radio_address
c_func
(paren
op_amp
id|node-&gt;addr
comma
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
op_amp
id|node-&gt;addr
comma
l_int|0
comma
r_sizeof
(paren
id|MetricomAddress
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the poll latency. %$#!@ simple_strtoul can&squot;t skip white space */
id|p
op_assign
id|line_begin
op_plus
l_int|41
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
op_logical_and
(paren
id|p
OL
id|end
)paren
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
id|node-&gt;poll_latency
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Get the signal strength. simple_strtoul doesn&squot;t do minus signs */
id|p
op_assign
id|line_begin
op_plus
l_int|60
suffix:semicolon
id|node-&gt;rssi
op_assign
op_minus
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_ne
id|node
)paren
(brace
id|last-&gt;next
op_assign
id|node
suffix:semicolon
id|last
op_assign
id|node
suffix:semicolon
)brace
id|node
op_assign
id|node-&gt;next
suffix:semicolon
id|line_begin
op_add_assign
id|STRIP_NODE_LEN
suffix:semicolon
id|num_nodes_counted
op_increment
suffix:semicolon
)brace
multiline_comment|/* invalidate all remaining nodes */
r_for
c_loop
(paren
suffix:semicolon
id|node
op_ne
l_int|NULL
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
id|node-&gt;type
op_and_assign
op_complement
id|NodeValid
suffix:semicolon
)brace
multiline_comment|/*&n;     * If the number of nodes reported is different&n;     * from the number counted, might need to up the number&n;     * requested.&n;     */
r_if
c_cond
(paren
id|num_nodes_reported
op_ne
id|num_nodes_counted
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nodes reported: %d &bslash;tnodes counted: %d&bslash;n&quot;
comma
id|num_nodes_reported
comma
id|num_nodes_counted
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Sending routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|function|ResetRadio
r_static
r_void
id|ResetRadio
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_static
r_const
r_char
id|InitString
(braket
)braket
op_assign
l_string|&quot;&bslash;rat&bslash;r&bslash;rate0q1dt**starmode&bslash;r&bslash;r**&quot;
suffix:semicolon
multiline_comment|/* If the radio isn&squot;t working anymore, we should clear the old status information. */
r_if
c_cond
(paren
id|strip_info-&gt;working
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: No response: Resetting radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;firmware_version.c
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strip_info-&gt;serial_number.c
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strip_info-&gt;battery_voltage.c
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/* Mark radio address as unknown */
op_star
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|strip_info-&gt;dev.dev_addr
op_assign
id|zero_address
suffix:semicolon
id|strip_info-&gt;working
op_assign
id|FALSE
suffix:semicolon
id|strip_info-&gt;structured_messages
op_assign
id|FALSE
suffix:semicolon
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|strip_info-&gt;tty
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|InitString
comma
r_sizeof
(paren
id|InitString
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the driver when there&squot;s room for more data.  If we have&n; * more packets to send, we send them here.&n; */
DECL|function|strip_write_some_more
r_static
r_void
id|strip_write_some_more
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
op_logical_or
op_logical_neg
id|strip_info-&gt;dev.start
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;         * If some data left, send it&n;         * Note: There&squot;s a kernel design bug here. The write_wakeup routine has to&n;         * know how many bytes were written in the previous call, but the number of&n;         * bytes written is returned as the result of the tty-&gt;driver.write call,&n;         * and there&squot;s no guarantee that the tty-&gt;driver.write routine will have&n;         * returned before the write_wakeup routine is invoked. If the PC has fast&n;         * Serial DMA hardware, then it&squot;s quite possible that the write could complete&n;         * almost instantaneously, meaning that my write_wakeup routine could be&n;         * called immediately, before tty-&gt;driver.write has had a chance to return&n;         * the number of bytes that it wrote. In an attempt to guard against this,&n;         * I disable interrupts around the call to tty-&gt;driver.write, although even&n;         * this might not work on a symmetric multi-processor system.&n;         */
id|InterruptStatus
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
r_int
id|num_written
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|strip_info-&gt;tx_head
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
id|strip_info-&gt;tx_left
op_sub_assign
id|num_written
suffix:semicolon
id|strip_info-&gt;tx_head
op_add_assign
id|num_written
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Else start transmission of another packet */
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|strip_unlock
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
DECL|function|strip_make_packet
r_static
r_int
r_char
op_star
id|strip_make_packet
c_func
(paren
r_int
r_char
op_star
id|ptr
comma
r_struct
id|strip
op_star
id|strip_info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#if DO_PROC_NET_STRIP_TRACE
r_int
r_char
op_star
id|start_ptr
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
id|__u8
op_star
id|stuffstate
op_assign
l_int|NULL
suffix:semicolon
id|STRIP_Header
op_star
id|header
op_assign
(paren
id|STRIP_Header
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|MetricomAddress
id|haddr
op_assign
id|header-&gt;dst_addr
suffix:semicolon
r_int
id|len
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
id|STRIP_Header
)paren
suffix:semicolon
id|MetricomKey
id|key
suffix:semicolon
multiline_comment|/*HexDump(&quot;strip_make_packet&quot;, strip_info, skb-&gt;data, skb-&gt;data + skb-&gt;len);*/
r_if
c_cond
(paren
id|header-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
id|key
op_assign
id|SIP0Key
suffix:semicolon
r_else
r_if
c_cond
(paren
id|header-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
)paren
id|key
op_assign
id|ARP0Key
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: strip_make_packet: Unknown packet type 0x%04X&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|ntohs
c_func
(paren
id|header-&gt;protocol
)paren
)paren
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|strip_info-&gt;mtu
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Dropping oversized transmit packet: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|len
)paren
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * If this is a broadcast packet, send it to our designated Metricom&n;     * &squot;broadcast hub&squot; radio (First byte of address being 0xFF means broadcast)&n;     */
r_if
c_cond
(paren
id|haddr.c
(braket
l_int|0
)braket
op_eq
l_int|0xFF
)paren
(brace
id|memcpy
c_func
(paren
id|haddr.c
comma
id|dev-&gt;broadcast
comma
r_sizeof
(paren
id|haddr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|haddr.c
(braket
l_int|0
)braket
op_eq
l_int|0xFF
)paren
(brace
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|2
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|2
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|3
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|3
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|4
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|4
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|5
)braket
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hextable
(braket
id|haddr.c
(braket
l_int|5
)braket
op_amp
l_int|0xF
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|1
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|2
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|key.c
(braket
l_int|3
)braket
suffix:semicolon
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|start_ptr
op_assign
id|ptr
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
id|ptr
op_assign
id|StuffData
c_func
(paren
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|STRIP_Header
)paren
comma
id|len
comma
id|ptr
comma
op_amp
id|stuffstate
)paren
suffix:semicolon
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|packet_log
c_func
(paren
id|strip_info
comma
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|STRIP_Header
)paren
comma
id|EntrySend
comma
id|header
comma
id|len
comma
id|ptr
op_minus
id|start_ptr
comma
id|slip_len
c_func
(paren
id|skb-&gt;data
op_plus
r_sizeof
(paren
id|STRIP_Header
)paren
comma
id|len
)paren
)paren
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
op_star
id|ptr
op_increment
op_assign
l_int|0x0D
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
DECL|function|strip_send
r_static
r_void
id|strip_send
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_char
op_star
id|ptr
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
multiline_comment|/* If we have a packet, encapsulate it and put it in the buffer */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|ptr
op_assign
id|strip_make_packet
c_func
(paren
id|ptr
comma
id|strip_info
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* If error, unlock and return */
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|strip_unlock
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strip_info-&gt;tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Count another successful packet */
multiline_comment|/*DumpData(&quot;Sending:&quot;, strip_info, strip_info-&gt;tx_buff, ptr);*/
multiline_comment|/*HexDump(&quot;Sending&quot;, strip_info, strip_info-&gt;tx_buff, ptr);*/
)brace
multiline_comment|/* Set up the strip_info ready to send the data */
id|strip_info-&gt;tx_head
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tx_left
op_assign
id|ptr
op_minus
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
multiline_comment|/* If watchdog has expired, reset the radio */
r_if
c_cond
(paren
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doreset
op_ge
l_int|0
)paren
(brace
id|ResetRadio
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Note: if there&squot;s a packet to send, strip_write_some_more&n;                 will do it after the reset has finished */
)brace
multiline_comment|/* No reset.&n;     * If it is time for another tickle, tack it on the end of the packet&n;     */
r_if
c_cond
(paren
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doprobe
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Send tickle to make radio protest */
multiline_comment|/*printk(KERN_INFO &quot;%s: Routine radio test.&bslash;n&quot;, strip_info-&gt;dev.name);*/
r_const
r_char
op_star
id|TickleString
op_assign
id|TickleString1
suffix:semicolon
r_int
id|length
op_assign
r_sizeof
(paren
id|TickleString1
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;structured_messages
)paren
(brace
id|TickleString
op_assign
id|TickleString2
suffix:semicolon
id|length
op_assign
r_sizeof
(paren
id|TickleString2
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ptr
comma
id|TickleString
comma
id|length
)paren
suffix:semicolon
id|strip_info-&gt;tx_left
op_add_assign
id|length
suffix:semicolon
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
)brace
multiline_comment|/*&n;     * If it is time for a periodic ARP, queue one up to be sent&n;     */
r_if
c_cond
(paren
id|strip_info-&gt;working
op_logical_and
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;gratuitous_arp
op_ge
l_int|0
op_logical_and
id|memcmp
c_func
(paren
id|strip_info-&gt;dev.dev_addr
comma
id|zero_address.c
comma
r_sizeof
(paren
id|zero_address
)paren
)paren
)paren
(brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Sending gratuitous ARP with interval %ld&bslash;n&quot;,&n;            strip_info-&gt;dev.name, strip_info-&gt;arp_interval / HZ);*/
id|strip_info-&gt;gratuitous_arp
op_assign
id|jiffies
op_plus
id|strip_info-&gt;arp_interval
suffix:semicolon
id|strip_info-&gt;arp_interval
op_mul_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;arp_interval
OG
id|MaxARPInterval
)paren
id|strip_info-&gt;arp_interval
op_assign
id|MaxARPInterval
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|strip_info-&gt;dev.pa_addr
comma
op_amp
id|strip_info-&gt;dev
comma
id|strip_info-&gt;dev.pa_addr
comma
l_int|NULL
comma
id|strip_info-&gt;dev.dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_size
op_minus
id|strip_info-&gt;tx_left
OL
l_int|20
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Sending%5d bytes;%5d bytes free.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|strip_info-&gt;tx_left
comma
id|strip_info-&gt;tx_size
op_minus
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
multiline_comment|/* All ready. Start the transmission */
id|strip_write_some_more
c_func
(paren
id|strip_info-&gt;tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Encapsulate a datagram and kick it into a TTY queue. */
DECL|function|strip_xmit
r_static
r_int
id|strip_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;start
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: xmit call when iface is down&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|strip_info-&gt;dev.tbusy
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
multiline_comment|/* See if someone has been ifconfigging */
r_if
c_cond
(paren
id|strip_info-&gt;mtu
op_ne
id|strip_info-&gt;dev.mtu
)paren
id|strip_changedmtu
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_send
c_func
(paren
id|strip_info
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the MAC header for an arbitrary protocol layer&n; *&n; * saddr!=NULL        means use this specific address (n/a for Metricom)&n; * saddr==NULL        means use default device source address&n; * daddr!=NULL        means use this destination address&n; * daddr==NULL        means leave destination address alone&n; *                 (e.g. unresolved arp -- kernel will call&n; *                 rebuild_header later to fill in the address)&n; */
DECL|function|strip_header
r_static
r_int
id|strip_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
id|STRIP_Header
op_star
id|header
op_assign
(paren
id|STRIP_Header
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
suffix:semicolon
multiline_comment|/*printk(KERN_INFO &quot;%s: strip_header 0x%04X %s&bslash;n&quot;, dev-&gt;name, type,&n;        type == ETH_P_IP ? &quot;IP&quot; : type == ETH_P_ARP ? &quot;ARP&quot; : &quot;&quot;);*/
id|memcpy
c_func
(paren
id|header-&gt;src_addr.c
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|header-&gt;protocol
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
multiline_comment|/*HexDump(&quot;strip_header&quot;, (struct strip *)(dev-&gt;priv), skb-&gt;data, skb-&gt;data + skb-&gt;len);*/
r_if
c_cond
(paren
op_logical_neg
id|daddr
)paren
r_return
op_minus
id|dev-&gt;hard_header_len
suffix:semicolon
id|memcpy
c_func
(paren
id|header-&gt;dst_addr.c
comma
id|daddr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
multiline_comment|/*&n; * Rebuild the MAC header. This is called after an ARP&n; * (or in future other address resolution) has completed on this&n; * sk_buff. We now let ARP fill in the other fields.&n; * I think this should return zero if packet is ready to send,&n; * or non-zero if it needs more time to do an address lookup&n; */
DECL|function|strip_rebuild_header
r_static
r_int
id|strip_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|STRIP_Header
op_star
id|header
op_assign
(paren
id|STRIP_Header
op_star
)paren
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*printk(KERN_INFO &quot;%s: strip_rebuild_header&bslash;n&quot;, skb-&gt;dev-&gt;name);*/
macro_line|#ifdef CONFIG_INET
multiline_comment|/* Arp find returns zero if if knows the address, */
multiline_comment|/* or if it doesn&squot;t know the address it sends an ARP packet and returns non-zero */
r_return
id|arp_find
c_func
(paren
id|header-&gt;dst_addr.c
comma
id|skb
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * IdleTask periodically calls strip_xmit, so even when we have no IP packets&n; * to send for an extended period of time, the watchdog processing still gets&n; * done to ensure that the radio stays in Starmode&n; */
DECL|function|strip_IdleTask
r_static
r_void
id|strip_IdleTask
c_func
(paren
r_int
r_int
id|parameter
)paren
(brace
id|strip_xmit
c_func
(paren
l_int|NULL
comma
(paren
r_struct
id|device
op_star
)paren
id|parameter
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Receiving routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|function|strip_receive_room
r_static
r_int
id|strip_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|0x10000
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
DECL|function|get_radio_address
r_static
r_void
id|get_radio_address
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|p
)paren
(brace
id|MetricomAddress
id|addr
suffix:semicolon
id|string_to_radio_address
c_func
(paren
op_amp
id|addr
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* See if our radio address has changed */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|strip_info-&gt;dev.dev_addr
comma
id|addr.c
comma
r_sizeof
(paren
id|addr
)paren
)paren
)paren
(brace
id|MetricomAddressString
id|addr_string
suffix:semicolon
id|radio_address_to_string
c_func
(paren
op_amp
id|addr
comma
op_amp
id|addr_string
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: My radio address = %s&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|addr_string.c
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|strip_info-&gt;dev.dev_addr
comma
id|addr.c
comma
r_sizeof
(paren
id|addr
)paren
)paren
suffix:semicolon
multiline_comment|/* Give the radio a few seconds to get its head straight, then send an arp */
id|strip_info-&gt;gratuitous_arp
op_assign
id|jiffies
op_plus
l_int|6
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;arp_interval
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
)brace
)brace
DECL|function|RecvErr
r_static
r_void
id|RecvErr
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
suffix:semicolon
id|DumpData
c_func
(paren
id|msg
comma
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
id|strip_info-&gt;rx_errors
op_increment
suffix:semicolon
)brace
DECL|function|RecvErr_Message
r_static
r_void
id|RecvErr_Message
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|sendername
comma
r_const
id|__u8
op_star
id|msg
)paren
(brace
r_static
r_const
r_char
id|ERR_001
(braket
)braket
op_assign
l_string|&quot;001&quot;
suffix:semicolon
multiline_comment|/* Not in StarMode! */
r_static
r_const
r_char
id|ERR_002
(braket
)braket
op_assign
l_string|&quot;002&quot;
suffix:semicolon
multiline_comment|/* Remap handle */
r_static
r_const
r_char
id|ERR_003
(braket
)braket
op_assign
l_string|&quot;003&quot;
suffix:semicolon
multiline_comment|/* Can&squot;t resolve name */
r_static
r_const
r_char
id|ERR_004
(braket
)braket
op_assign
l_string|&quot;004&quot;
suffix:semicolon
multiline_comment|/* Name too small or missing */
r_static
r_const
r_char
id|ERR_005
(braket
)braket
op_assign
l_string|&quot;005&quot;
suffix:semicolon
multiline_comment|/* Bad count specification */
r_static
r_const
r_char
id|ERR_006
(braket
)braket
op_assign
l_string|&quot;006&quot;
suffix:semicolon
multiline_comment|/* Header too big */
r_static
r_const
r_char
id|ERR_007
(braket
)braket
op_assign
l_string|&quot;007&quot;
suffix:semicolon
multiline_comment|/* Body too big */
r_static
r_const
r_char
id|ERR_008
(braket
)braket
op_assign
l_string|&quot;008&quot;
suffix:semicolon
multiline_comment|/* Bad character in name */
r_static
r_const
r_char
id|ERR_009
(braket
)braket
op_assign
l_string|&quot;009&quot;
suffix:semicolon
multiline_comment|/* No count or line terminator */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_001
comma
r_sizeof
(paren
id|ERR_001
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio %s is not in StarMode&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|sendername
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_002
comma
r_sizeof
(paren
id|ERR_002
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
macro_line|#ifdef notyet        /*Kernel doesn&squot;t have scanf!*/
r_int
id|handle
suffix:semicolon
id|__u8
id|newname
(braket
l_int|64
)braket
suffix:semicolon
id|sscanf
c_func
(paren
id|msg
comma
l_string|&quot;ERR_002 Remap handle &amp;%d to name %s&quot;
comma
op_amp
id|handle
comma
id|newname
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio name %s is handle %d&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|newname
comma
id|handle
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_003
comma
r_sizeof
(paren
id|ERR_003
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Destination radio name is unknown&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_004
comma
r_sizeof
(paren
id|ERR_004
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
id|LongTime
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;working
)paren
(brace
id|strip_info-&gt;working
op_assign
id|TRUE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio now in starmode&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
multiline_comment|/*&n;             * If the radio has just entered a working state, we should do our first&n;             * probe ASAP, so that we find out our radio address etc. without delay.&n;             */
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;structured_messages
op_logical_and
id|sendername
)paren
(brace
id|strip_info-&gt;structured_messages
op_assign
id|TRUE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Radio provides structured messages&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_005
comma
r_sizeof
(paren
id|ERR_005
)paren
op_minus
l_int|1
)paren
)paren
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_006
comma
r_sizeof
(paren
id|ERR_006
)paren
op_minus
l_int|1
)paren
)paren
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_007
comma
r_sizeof
(paren
id|ERR_007
)paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;         * Note: This error knocks the radio back into&n;         * command mode.&n;         */
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error! Packet size too big for radio.&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Do reset ASAP */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_008
comma
r_sizeof
(paren
id|ERR_008
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Radio name contains illegal character&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_009
comma
r_sizeof
(paren
id|ERR_009
)paren
op_minus
l_int|1
)paren
)paren
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
DECL|function|process_AT_response
r_static
r_void
id|process_AT_response
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
r_static
r_const
r_char
id|ATS305
(braket
)braket
op_assign
l_string|&quot;ATS305?&quot;
suffix:semicolon
r_static
r_const
r_char
id|ATS300
(braket
)braket
op_assign
l_string|&quot;ATS300?&quot;
suffix:semicolon
r_static
r_const
r_char
id|ATS325
(braket
)braket
op_assign
l_string|&quot;ATS325?&quot;
suffix:semicolon
r_static
r_const
r_char
id|ATI2
(braket
)braket
op_assign
l_string|&quot;AT~I2 nn&quot;
suffix:semicolon
multiline_comment|/* Skip to the first newline character */
id|__u8
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
op_logical_and
op_star
id|p
op_ne
l_int|10
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|end
)paren
r_return
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ptr
comma
id|ATS305
comma
r_sizeof
(paren
id|ATS305
)paren
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_RADIO_ADDRESS
c_func
(paren
id|p
)paren
)paren
id|get_radio_address
c_func
(paren
id|strip_info
comma
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ptr
comma
id|ATS300
comma
r_sizeof
(paren
id|ATS300
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|get_radio_version
c_func
(paren
id|strip_info
comma
id|p
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ptr
comma
id|ATS325
comma
r_sizeof
(paren
id|ATS325
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|get_radio_voltage
c_func
(paren
id|strip_info
comma
id|p
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ptr
comma
id|ATI2
comma
r_sizeof
(paren
id|ATI2
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|get_radio_neighbors
c_func
(paren
id|strip_info
comma
id|p
comma
id|end
)paren
suffix:semicolon
)brace
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Unknown AT Response:&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send one completely decapsulated datagram to the next layer.&n; */
DECL|function|deliver_packet
r_static
r_void
id|deliver_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|STRIP_Header
op_star
id|header
comma
id|__u16
id|packetlen
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
r_sizeof
(paren
id|STRIP_Header
)paren
op_plus
id|packetlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: memory squeeze, dropping packet.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
comma
id|header
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|packetlen
)paren
comma
id|strip_info-&gt;rx_buff
comma
id|packetlen
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|header-&gt;protocol
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Having put a fake header on the front of the sk_buff for the */
multiline_comment|/* benefit of tools like tcpdump, skb_pull now &squot;consumes&squot; that  */
multiline_comment|/* fake header before we hand the packet up to the next layer.  */
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|STRIP_Header
)paren
)paren
suffix:semicolon
multiline_comment|/* Finally, hand the packet up to the next layer (e.g. IP or ARP, etc.) */
id|strip_info-&gt;rx_packets
op_increment
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
DECL|function|process_IP_packet
r_static
r_void
id|process_IP_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|STRIP_Header
op_star
id|header
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u16
id|packetlen
suffix:semicolon
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|__u8
op_star
id|start_ptr
op_assign
id|ptr
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
multiline_comment|/* Decode start of the IP packet header */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;IP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|packetlen
op_assign
(paren
(paren
id|__u16
)paren
id|strip_info-&gt;rx_buff
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|strip_info-&gt;rx_buff
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|packetlen
OG
id|MAX_STRIP_MTU
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Dropping oversized receive packet: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|packetlen
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Got %d byte IP packet&bslash;n&quot;, strip_info-&gt;dev.name, packetlen);*/
multiline_comment|/* Decode remainder of the IP packet */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
op_plus
l_int|4
comma
id|packetlen
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;IP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
OL
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;IP Packet too long&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|header-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|packet_log
c_func
(paren
id|strip_info
comma
id|strip_info-&gt;rx_buff
comma
id|EntryReceive
comma
id|header
comma
id|packetlen
comma
id|end
op_minus
id|start_ptr
comma
id|slip_len
c_func
(paren
id|strip_info-&gt;rx_buff
comma
id|packetlen
)paren
)paren
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
id|deliver_packet
c_func
(paren
id|strip_info
comma
id|header
comma
id|packetlen
)paren
suffix:semicolon
)brace
DECL|function|process_ARP_packet
r_static
r_void
id|process_ARP_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|STRIP_Header
op_star
id|header
comma
id|__u8
op_star
id|ptr
comma
id|__u8
op_star
id|end
)paren
(brace
id|__u16
id|packetlen
suffix:semicolon
r_struct
id|arphdr
op_star
id|arphdr
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|strip_info-&gt;rx_buff
suffix:semicolon
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|__u8
op_star
id|start_ptr
op_assign
id|ptr
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
multiline_comment|/* Decode start of the ARP packet */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;ARP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|packetlen
op_assign
l_int|8
op_plus
(paren
id|arphdr-&gt;ar_hln
op_plus
id|arphdr-&gt;ar_pln
)paren
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|packetlen
OG
id|MAX_STRIP_MTU
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Dropping oversized receive packet: %d bytes&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|packetlen
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Got %d byte ARP %s&bslash;n&quot;,&n;        strip_info-&gt;dev.name, packetlen,&n;        ntohs(arphdr-&gt;ar_op) == ARPOP_REQUEST ? &quot;request&quot; : &quot;reply&quot;);*/
multiline_comment|/* Decode remainder of the ARP packet */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
op_plus
l_int|8
comma
id|packetlen
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;ARP Packet too short&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
OL
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;ARP Packet too long&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|header-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|packet_log
c_func
(paren
id|strip_info
comma
id|strip_info-&gt;rx_buff
comma
id|EntryReceive
comma
id|header
comma
id|packetlen
comma
id|end
op_minus
id|start_ptr
comma
id|slip_len
c_func
(paren
id|strip_info-&gt;rx_buff
comma
id|packetlen
)paren
)paren
suffix:semicolon
macro_line|#endif DO_PROC_NET_STRIP_TRACE
id|deliver_packet
c_func
(paren
id|strip_info
comma
id|header
comma
id|packetlen
)paren
suffix:semicolon
)brace
DECL|function|process_packet
r_static
r_void
id|process_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|STRIP_Header
id|header
op_assign
(brace
id|zero_address
comma
id|zero_address
comma
l_int|0
)brace
suffix:semicolon
id|__u8
op_star
id|ptr
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
suffix:semicolon
id|__u8
id|sendername
(braket
l_int|32
)braket
comma
op_star
id|sptr
op_assign
id|sendername
suffix:semicolon
id|MetricomKey
id|key
suffix:semicolon
multiline_comment|/* Ignore &squot;OK&squot; responses from prior commands */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_eq
l_int|2
op_logical_and
id|ptr
(braket
l_int|0
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;K&squot;
)paren
r_return
suffix:semicolon
multiline_comment|/* Check for anything that looks like it might be our radio name: dddd-dddd */
multiline_comment|/* (This is here for backwards compatibility with old firmware)             */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_eq
l_int|9
op_logical_and
id|IS_RADIO_ADDRESS
c_func
(paren
id|ptr
)paren
)paren
(brace
id|get_radio_address
c_func
(paren
id|strip_info
comma
id|ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*HexDump(&quot;Receiving&quot;, strip_info, ptr, end);*/
multiline_comment|/* Check for start of address marker, and then skip over it */
r_if
c_cond
(paren
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
)paren
(brace
multiline_comment|/* Catch other error messages */
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_eq
l_char|&squot;E&squot;
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|ptr
(braket
l_int|2
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|ptr
(braket
l_int|3
)braket
op_eq
l_char|&squot;_&squot;
)paren
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
l_int|NULL
comma
op_amp
id|ptr
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;No initial *&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Skip the initial &squot;*&squot; */
multiline_comment|/* Copy out the return address */
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
op_logical_and
id|sptr
OL
id|ARRAY_END
c_func
(paren
id|sendername
)paren
op_minus
l_int|1
)paren
op_star
id|sptr
op_increment
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
op_star
id|sptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Null terminate the sender name */
multiline_comment|/* Check for end of address marker, and skip over it */
r_if
c_cond
(paren
id|ptr
op_ge
id|end
op_logical_or
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;No second *&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Skip the second &squot;*&squot; */
multiline_comment|/* If the sender name is &quot;&amp;COMMAND&quot;, ignore this &squot;packet&squot;       */
multiline_comment|/* (This is here for backwards compatibility with old firmware) */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sendername
comma
l_string|&quot;&amp;COMMAND&quot;
)paren
)paren
(brace
id|strip_info-&gt;structured_messages
op_assign
id|FALSE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_plus
l_int|4
op_ge
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;No proto key&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*printk(KERN_INFO &quot;%s: Got packet from &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;, strip_info-&gt;dev.name, sendername);*/
multiline_comment|/*&n;     * Fill in (pseudo) source and destination addresses in the packet.&n;     * We assume that the destination address was our address (the radio does not&n;     * tell us this). If the radio supplies a source address, then we use it.&n;     */
id|memcpy
c_func
(paren
op_amp
id|header.dst_addr
comma
id|strip_info-&gt;dev.dev_addr
comma
r_sizeof
(paren
id|MetricomAddress
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RADIO_ADDRESS
c_func
(paren
id|sendername
)paren
)paren
id|string_to_radio_address
c_func
(paren
op_amp
id|header.src_addr
comma
id|sendername
)paren
suffix:semicolon
multiline_comment|/* Get the protocol key out of the buffer */
id|key.c
(braket
l_int|0
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|1
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|2
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|3
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key.l
op_eq
id|SIP0Key.l
)paren
id|process_IP_packet
c_func
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ARP0Key.l
)paren
id|process_ARP_packet
c_func
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ATR_Key.l
)paren
id|process_AT_response
c_func
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ERR_Key.l
)paren
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
id|sendername
comma
id|ptr
)paren
suffix:semicolon
r_else
multiline_comment|/* RecvErr(&quot;Unrecognized protocol key&quot;, strip_info); */
multiline_comment|/* Note, this &quot;else&quot; block is temporary, until Metricom fix their */
multiline_comment|/* packet corruption bug */
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Unrecognized protocol key (retrying)&quot;
comma
id|strip_info
)paren
suffix:semicolon
id|ptr
op_sub_assign
l_int|3
suffix:semicolon
multiline_comment|/* Back up and try again */
id|key.c
(braket
l_int|0
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|1
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|2
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
id|key.c
(braket
l_int|3
)braket
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key.l
op_eq
id|SIP0Key.l
)paren
id|process_IP_packet
c_func
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ARP0Key.l
)paren
id|process_ARP_packet
c_func
(paren
id|strip_info
comma
op_amp
id|header
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ATR_Key.l
)paren
id|process_AT_response
c_func
(paren
id|strip_info
comma
id|ptr
comma
id|end
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key.l
op_eq
id|ERR_Key.l
)paren
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
id|sendername
comma
id|ptr
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Unrecognized protocol key&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handle the &squot;receiver data ready&squot; interrupt.&n; * This function is called by the &squot;tty_io&squot; module in the kernel when&n; * a block of STRIP data has been received, which can now be decapsulated&n; * and sent on to some IP layer for further processing.&n; */
r_static
r_void
DECL|function|strip_receive_buf
id|strip_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_const
r_int
r_char
op_star
id|end
op_assign
id|cp
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
op_logical_or
op_logical_neg
id|strip_info-&gt;dev.start
)paren
r_return
suffix:semicolon
multiline_comment|/* Argh! mtu change time! - costs us the packet part received at the change */
r_if
c_cond
(paren
id|strip_info-&gt;mtu
op_ne
id|strip_info-&gt;dev.mtu
)paren
id|strip_changedmtu
c_func
(paren
id|strip_info
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;**** strip_receive_buf: %3d bytes at %d.%06d&bslash;n&quot;
comma
id|count
comma
id|tv.tv_sec
op_mod
l_int|100
comma
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Read the characters out of the buffer */
r_while
c_loop
(paren
id|cp
OL
id|end
)paren
(brace
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
op_increment
op_logical_and
op_logical_neg
id|strip_info-&gt;discard
)paren
multiline_comment|/* If there&squot;s a serial error, record it */
(brace
id|strip_info-&gt;discard
op_assign
l_int|1
suffix:semicolon
id|strip_info-&gt;rx_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* Leading control characters (CR, NL, Tab, etc.) are ignored */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OG
l_int|0
op_logical_or
op_star
id|cp
op_ge
l_char|&squot; &squot;
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_int|0x0D
)paren
multiline_comment|/* If end of packet, decide what to do with it */
(brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OG
l_int|3000
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Cut a %d byte packet (%d bytes remaining)%s&bslash;n&quot;
comma
id|strip_info-&gt;sx_count
comma
id|end
op_minus
id|cp
op_minus
l_int|1
comma
id|strip_info-&gt;discard
ques
c_cond
l_string|&quot; (discarded)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OG
id|strip_info-&gt;sx_size
)paren
(brace
id|strip_info-&gt;discard
op_assign
l_int|1
suffix:semicolon
id|strip_info-&gt;rx_over_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: sx_buff overflow (%d bytes total)&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|strip_info-&gt;sx_count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;discard
)paren
id|process_packet
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;discard
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strip_info-&gt;discard
)paren
multiline_comment|/* If we&squot;re not discarding, store the character */
(brace
multiline_comment|/* Make sure we have space in the buffer */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OL
id|strip_info-&gt;sx_size
)paren
id|strip_info-&gt;sx_buff
(braket
id|strip_info-&gt;sx_count
)braket
op_assign
op_star
id|cp
suffix:semicolon
id|strip_info-&gt;sx_count
op_increment
suffix:semicolon
)brace
)brace
id|cp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* General control routines&t;&t;&t;&t;&t;&t;*/
DECL|function|strip_set_dev_mac_address
r_static
r_int
id|strip_set_dev_mac_address
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* You cannot override a Metricom radio&squot;s address */
)brace
DECL|function|strip_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|strip_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_struct
id|net_device_stats
id|stats
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|stats.rx_packets
op_assign
id|strip_info-&gt;rx_packets
suffix:semicolon
id|stats.tx_packets
op_assign
id|strip_info-&gt;tx_packets
suffix:semicolon
id|stats.rx_dropped
op_assign
id|strip_info-&gt;rx_dropped
suffix:semicolon
id|stats.tx_dropped
op_assign
id|strip_info-&gt;tx_dropped
suffix:semicolon
id|stats.tx_errors
op_assign
id|strip_info-&gt;tx_errors
suffix:semicolon
id|stats.rx_errors
op_assign
id|strip_info-&gt;rx_errors
suffix:semicolon
id|stats.rx_over_errors
op_assign
id|strip_info-&gt;rx_over_errors
suffix:semicolon
r_return
op_amp
id|stats
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Opening and closing&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * Here&squot;s the order things happen:&n; * When the user runs &quot;slattach -p strip ...&quot;&n; *  1. The TTY module calls strip_open&n; *  2. strip_open calls strip_alloc&n; *  3.                  strip_alloc calls register_netdev&n; *  4.                  register_netdev calls strip_dev_init&n; *  5. then strip_open finishes setting up the strip_info&n; *&n; * When the user runs &quot;ifconfig st&lt;x&gt; up address netmask ...&quot;&n; *  6. strip_open_low gets called&n; *&n; * When the user runs &quot;ifconfig st&lt;x&gt; down&quot;&n; *  7. strip_close_low gets called&n; *&n; * When the user kills the slattach process&n; *  8. strip_close gets called&n; *  9. strip_close calls dev_close&n; * 10. if the device is still up, then dev_close calls strip_close_low&n; * 11. strip_close calls strip_free&n; */
multiline_comment|/* Open the low-level part of the STRIP channel. Easy! */
DECL|function|strip_open_low
r_static
r_int
id|strip_open_low
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allocate_buffers
c_func
(paren
id|strip_info
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|strip_info-&gt;discard
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;working
op_assign
id|FALSE
suffix:semicolon
id|strip_info-&gt;structured_messages
op_assign
id|FALSE
suffix:semicolon
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_left
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Initializing Radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|ResetRadio
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;idle_timer.expires
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the low-level part of the STRIP channel. Easy!&n; */
DECL|function|strip_close_low
r_static
r_int
id|strip_close_low
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|strip_info-&gt;tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Free all STRIP frame buffers.&n;     */
r_if
c_cond
(paren
id|strip_info-&gt;rx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;rx_buff
)paren
suffix:semicolon
id|strip_info-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;sx_buff
)paren
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;tx_buff
)paren
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by DDI when the&n; * (dynamically assigned) device is registered&n; */
DECL|function|strip_dev_init
r_static
r_int
id|strip_dev_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/*&n;     * Finish setting up the DEVICE info.&n;     */
id|dev-&gt;trans_start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;last_rx
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* Drop after 30 frames queued */
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
id|dev-&gt;metric
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|DEFAULT_STRIP_MTU
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_METRICOM
suffix:semicolon
multiline_comment|/* dtang */
id|dev-&gt;hard_header_len
op_assign
r_sizeof
(paren
id|STRIP_Header
)paren
suffix:semicolon
multiline_comment|/*&n;     *  dev-&gt;priv             Already holds a pointer to our struct strip&n;     */
op_star
(paren
id|MetricomAddress
op_star
)paren
op_amp
id|dev-&gt;broadcast
op_assign
id|broadcast_address
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;addr_len
op_assign
r_sizeof
(paren
id|MetricomAddress
)paren
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_alen
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n;     * Pointer to the interface buffers.&n;     */
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;     * Pointers to interface service routines.&n;     */
id|dev-&gt;open
op_assign
id|strip_open_low
suffix:semicolon
id|dev-&gt;stop
op_assign
id|strip_close_low
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|strip_xmit
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|strip_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|strip_rebuild_header
suffix:semicolon
multiline_comment|/*  dev-&gt;type_trans            unused */
multiline_comment|/*  dev-&gt;set_multicast_list   unused */
id|dev-&gt;set_mac_address
op_assign
id|strip_set_dev_mac_address
suffix:semicolon
multiline_comment|/*  dev-&gt;do_ioctl             unused */
multiline_comment|/*  dev-&gt;set_config           unused */
id|dev-&gt;get_stats
op_assign
id|strip_get_stats
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a STRIP channel.&n; */
DECL|function|strip_free
r_static
r_void
id|strip_free
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|MetricomNode
op_star
id|node
comma
op_star
id|free
suffix:semicolon
op_star
(paren
id|strip_info-&gt;referrer
)paren
op_assign
id|strip_info-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;next
)paren
id|strip_info-&gt;next-&gt;referrer
op_assign
id|strip_info-&gt;referrer
suffix:semicolon
id|strip_info-&gt;magic
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|strip_info-&gt;neighbor_list
suffix:semicolon
id|node
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|free
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|free
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|strip_info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a new free STRIP channel&n; */
DECL|function|strip_alloc
r_static
r_struct
id|strip
op_star
id|strip_alloc
c_func
(paren
r_void
)paren
(brace
r_int
id|channel_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|strip
op_star
op_star
id|s
op_assign
op_amp
id|struct_strip_list
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strip
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If no more memory, return */
multiline_comment|/*&n;     * Clear the allocated memory&n;     */
id|memset
c_func
(paren
id|strip_info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|strip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Search the list to find where to put our new entry&n;     * (and in the process decide what channel number it is&n;     * going to be)&n;     */
r_while
c_loop
(paren
op_star
id|s
op_logical_and
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|dev.base_addr
op_eq
id|channel_id
)paren
(brace
id|channel_id
op_increment
suffix:semicolon
id|s
op_assign
op_amp
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
multiline_comment|/*&n;     * Fill in the link pointers&n;     */
id|strip_info-&gt;next
op_assign
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|referrer
op_assign
op_amp
id|strip_info-&gt;next
suffix:semicolon
id|strip_info-&gt;referrer
op_assign
id|s
suffix:semicolon
op_star
id|s
op_assign
id|strip_info
suffix:semicolon
id|strip_info-&gt;magic
op_assign
id|STRIP_MAGIC
suffix:semicolon
id|strip_info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strip_info-&gt;gratuitous_arp
op_assign
id|jiffies
op_plus
id|LongTime
suffix:semicolon
id|strip_info-&gt;arp_interval
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
id|strip_info-&gt;idle_timer.data
op_assign
(paren
r_int
)paren
op_amp
id|strip_info-&gt;dev
suffix:semicolon
id|strip_info-&gt;idle_timer.function
op_assign
id|strip_IdleTask
suffix:semicolon
id|strip_info-&gt;neighbor_list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|MetricomNode
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|strip_info-&gt;neighbor_list-&gt;type
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;neighbor_list-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Note: strip_info-&gt;if_name is currently 8 characters long */
id|sprintf
c_func
(paren
id|strip_info-&gt;if_name
comma
l_string|&quot;st%d&quot;
comma
id|channel_id
)paren
suffix:semicolon
id|strip_info-&gt;dev.name
op_assign
id|strip_info-&gt;if_name
suffix:semicolon
id|strip_info-&gt;dev.base_addr
op_assign
id|channel_id
suffix:semicolon
id|strip_info-&gt;dev.priv
op_assign
(paren
r_void
op_star
)paren
id|strip_info
suffix:semicolon
id|strip_info-&gt;dev.next
op_assign
l_int|NULL
suffix:semicolon
id|strip_info-&gt;dev.init
op_assign
id|strip_dev_init
suffix:semicolon
r_return
id|strip_info
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the high-level part of the STRIP channel.&n; * This function is called by the TTY module when the&n; * STRIP line discipline is called for.  Because we are&n; * sure the tty line exists, we only have to link it to&n; * a free STRIP channel...&n; */
DECL|function|strip_open
r_static
r_int
id|strip_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;     * First make sure we&squot;re not already connected.&n;     */
r_if
c_cond
(paren
id|strip_info
op_logical_and
id|strip_info-&gt;magic
op_eq
id|STRIP_MAGIC
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/*&n;     * OK.  Find a free STRIP channel to use.&n;     */
r_if
c_cond
(paren
(paren
id|strip_info
op_assign
id|strip_alloc
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/*&n;     * Register our newly created device so it can be ifconfig&squot;d&n;     * strip_dev_init() will be called as a side-effect&n;     */
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;strip: register_netdev() failed.&bslash;n&quot;
)paren
suffix:semicolon
id|strip_free
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
id|strip_info-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|strip_info
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/*&n;     * Restore default settings&n;     */
id|strip_info-&gt;dev.type
op_assign
id|ARPHRD_METRICOM
suffix:semicolon
multiline_comment|/* dtang */
multiline_comment|/*&n;     * Set tty options&n;     */
id|tty-&gt;termios-&gt;c_iflag
op_or_assign
id|IGNBRK
op_or
id|IGNPAR
suffix:semicolon
multiline_comment|/* Ignore breaks and parity errors. */
id|tty-&gt;termios-&gt;c_cflag
op_or_assign
id|CLOCAL
suffix:semicolon
multiline_comment|/* Ignore modem control signals. */
id|tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|HUPCL
suffix:semicolon
multiline_comment|/* Don&squot;t close on hup */
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Done.  We have linked the TTY line to a channel.&n;     */
r_return
id|strip_info-&gt;dev.base_addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a STRIP channel.&n; * This means flushing out any pending queues, and then restoring the&n; * TTY line discipline to what it was before it got hooked to STRIP&n; * (which usually is TTY again).&n; */
DECL|function|strip_close
r_static
r_void
id|strip_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;     * First make sure we&squot;re connected.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
)paren
r_return
suffix:semicolon
id|dev_close
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strip_free
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Perform I/O control calls on an active STRIP channel.&t;&t;*/
DECL|function|strip_ioctl
r_static
r_int
id|strip_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;     * First make sure we&squot;re connected.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFNAME
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|err
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|strip_info-&gt;dev.name
comma
id|strlen
c_func
(paren
id|strip_info-&gt;dev.name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;         * Allow stty to read, but not set, the serial port&n;         */
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
r_return
id|n_tty_ioctl
c_func
(paren
id|tty
comma
(paren
r_struct
id|file
op_star
)paren
id|file
comma
id|cmd
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Initialization&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; *      Registers with the /proc file system to create different /proc/net files.&n; */
DECL|function|strip_proc_net_register
r_static
r_int
id|strip_proc_net_register
c_func
(paren
r_int
r_int
id|type
comma
r_char
op_star
id|file_name
comma
r_int
(paren
op_star
id|get_info
)paren
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
)paren
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|strip_entry
suffix:semicolon
id|strip_entry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|strip_entry
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
id|strip_entry-&gt;low_ino
op_assign
id|type
suffix:semicolon
id|strip_entry-&gt;namelen
op_assign
id|strlen
c_func
(paren
id|file_name
)paren
suffix:semicolon
id|strip_entry-&gt;name
op_assign
id|file_name
suffix:semicolon
id|strip_entry-&gt;mode
op_assign
id|S_IFREG
op_or
id|S_IRUGO
suffix:semicolon
id|strip_entry-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|strip_entry-&gt;uid
op_assign
l_int|0
suffix:semicolon
id|strip_entry-&gt;gid
op_assign
l_int|0
suffix:semicolon
id|strip_entry-&gt;size
op_assign
l_int|0
suffix:semicolon
id|strip_entry-&gt;ops
op_assign
op_amp
id|proc_net_inode_operations
suffix:semicolon
id|strip_entry-&gt;get_info
op_assign
id|get_info
suffix:semicolon
r_return
id|proc_net_register
c_func
(paren
id|strip_entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the STRIP driver.&n; * This routine is called at boot time, to bootstrap the multi-channel&n; * STRIP driver&n; */
macro_line|#ifdef MODULE
r_static
macro_line|#endif
DECL|function|strip_init_ctrl_dev
r_int
id|strip_init_ctrl_dev
c_func
(paren
r_struct
id|device
op_star
id|dummy
)paren
(brace
r_static
r_struct
id|tty_ldisc
id|strip_ldisc
suffix:semicolon
r_int
id|status
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STRIP: version %s (unlimited channels)&bslash;n&quot;
comma
id|StripVersion
)paren
suffix:semicolon
multiline_comment|/*&n;     * Fill in our line protocol discipline, and register it&n;     */
id|memset
c_func
(paren
op_amp
id|strip_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|strip_ldisc
)paren
)paren
suffix:semicolon
id|strip_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|strip_ldisc.flags
op_assign
l_int|0
suffix:semicolon
id|strip_ldisc.open
op_assign
id|strip_open
suffix:semicolon
id|strip_ldisc.close
op_assign
id|strip_close
suffix:semicolon
id|strip_ldisc.read
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.write
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.ioctl
op_assign
id|strip_ioctl
suffix:semicolon
id|strip_ldisc.poll
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.receive_buf
op_assign
id|strip_receive_buf
suffix:semicolon
id|strip_ldisc.receive_room
op_assign
id|strip_receive_room
suffix:semicolon
id|strip_ldisc.write_wakeup
op_assign
id|strip_write_some_more
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_STRIP
comma
op_amp
id|strip_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: can&squot;t register line discipline (err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Register the status and trace files with /proc&n;     */
macro_line|#if DO_PROC_NET_STRIP_STATUS
r_if
c_cond
(paren
id|strip_proc_net_register
c_func
(paren
id|PROC_NET_STRIP_STATUS
comma
l_string|&quot;strip_status&quot;
comma
op_amp
id|strip_get_status_info
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;strip: status strip_proc_net_register() failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if DO_PROC_NET_STRIP_TRACE
r_if
c_cond
(paren
id|strip_proc_net_register
c_func
(paren
id|PROC_NET_STRIP_TRACE
comma
l_string|&quot;strip_trace&quot;
comma
op_amp
id|strip_get_trace_info
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;strip: trace strip_proc_net_register() failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
r_return
id|status
suffix:semicolon
macro_line|#else
multiline_comment|/* Return &quot;not found&quot;, so that dev_init() will unlink&n;     * the placeholder device entry for us.&n;     */
r_return
id|ENODEV
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* From here down is only used when compiled as an external module&t;*/
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|strip_init_ctrl_dev
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|struct_strip_list
)paren
id|strip_free
c_func
(paren
id|struct_strip_list
)paren
suffix:semicolon
multiline_comment|/* Unregister with the /proc/net files here. */
macro_line|#if DO_PROC_NET_STRIP_TRACE
id|proc_net_unregister
c_func
(paren
id|PROC_NET_STRIP_TRACE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DO_PROC_NET_STRIP_STATUS
id|proc_net_unregister
c_func
(paren
id|PROC_NET_STRIP_STATUS
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|i
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_STRIP
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;STRIP: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
