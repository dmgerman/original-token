multiline_comment|/*&n; * Copyright 1996 The Board of Trustees of The Leland Stanford&n; * Junior University. All Rights Reserved.&n; *&n; * Permission to use, copy, modify, and distribute this&n; * software and its documentation for any purpose and without&n; * fee is hereby granted, provided that the above copyright&n; * notice appear in all copies.  Stanford University&n; * makes no representations about the suitability of this&n; * software for any purpose.  It is provided &quot;as is&quot; without&n; * express or implied warranty.&n; *&n; * strip.c&t;This module implements Starmode Radio IP (STRIP)&n; *&t;&t;for kernel-based devices like TTY.  It interfaces between a&n; *&t;&t;raw TTY, and the kernel&squot;s INET protocol layers (via DDI).&n; *&n; * Version:&t;@(#)strip.c&t;0.9.1&t;3/6/95&n; *&n; * Author:&t;Stuart Cheshire &lt;cheshire@cs.stanford.edu&gt;&n; *&n; * Fixes:&n; *&t;&t;Stuart Cheshire:&n; *&t;&t;&t;Original version converted from SLIP driver&n; *&t;&t;Jonathan Stone:&n; *&t;&t;&t;change to 1.3 calling conventions&n; *&t;&t;Stuart Cheshire:&n; *&t;&t;&t;v0.9 12th Feb 1996.&n; *&t;&t;&t;New byte stuffing (2+6 run-length encoding)&n; *&t;&t;&t;New watchdog timer task&n; *&t;&t;&t;New Protocol key (SIP0)&n; *&t;&t;&t;v0.9.1 3rd March 1996&n; *&t;&t;&t;Changed to dynamic device allocation&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_strip.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#ifdef CONFIG_INET
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#endif
macro_line|#ifdef MODULE
DECL|macro|STRIP_VERSION
mdefine_line|#define STRIP_VERSION    &quot;0.9.1-STUART.CHESHIRE-MODULAR&quot;
macro_line|#else
DECL|macro|STRIP_VERSION
mdefine_line|#define STRIP_VERSION    &quot;0.9.1-STUART.CHESHIRE&quot;
macro_line|#endif
DECL|macro|STRIP_MTU
mdefine_line|#define STRIP_MTU 1024
DECL|macro|STRIP_MAGIC
mdefine_line|#define STRIP_MAGIC 0x5303
multiline_comment|/*&n; *&t;Do we still needs all these flags? &n; */
r_enum
(brace
DECL|enumerator|STR_INUSE
id|STR_INUSE
op_assign
l_int|0
comma
multiline_comment|/* Channel in use&t;*/
DECL|enumerator|STR_ESCAPE
id|STR_ESCAPE
comma
multiline_comment|/* ESC received&t;&t;*/
DECL|enumerator|STR_ERROR
id|STR_ERROR
multiline_comment|/* Parity, etc. error&t;*/
)brace
DECL|variable|STRIP_FLAGS
id|STRIP_FLAGS
suffix:semicolon
DECL|struct|strip
r_struct
id|strip
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Other useful structures. &n;&t; */
multiline_comment|/*&n;&t; *&t;These are pointers to the malloc()ed frame buffers.&n;&t; */
DECL|member|rx_buff
r_int
r_char
op_star
id|rx_buff
suffix:semicolon
multiline_comment|/* buffer for received IP packet*/
DECL|member|sx_buff
r_int
r_char
op_star
id|sx_buff
suffix:semicolon
multiline_comment|/* buffer for received serial data*/
DECL|member|sx_count
r_int
id|sx_count
suffix:semicolon
multiline_comment|/* received serial data counter */
DECL|member|tx_buff
r_int
r_char
op_star
id|tx_buff
suffix:semicolon
multiline_comment|/* transmitter buffer  */
DECL|member|tx_head
r_int
r_char
op_star
id|tx_head
suffix:semicolon
multiline_comment|/* pointer to next byte to XMIT */
DECL|member|tx_left
r_int
id|tx_left
suffix:semicolon
multiline_comment|/* bytes left in XMIT queue     */
multiline_comment|/*&n;&t; *&t;STRIP interface statistics.&n;&t; */
DECL|member|rx_packets
r_int
r_int
id|rx_packets
suffix:semicolon
multiline_comment|/* inbound frames counter&t;*/
DECL|member|tx_packets
r_int
r_int
id|tx_packets
suffix:semicolon
multiline_comment|/* outbound frames counter&t;*/
DECL|member|rx_errors
r_int
r_int
id|rx_errors
suffix:semicolon
multiline_comment|/* Parity, etc. errors&t;&t;*/
DECL|member|tx_errors
r_int
r_int
id|tx_errors
suffix:semicolon
multiline_comment|/* Planned stuff&t;&t;*/
DECL|member|rx_dropped
r_int
r_int
id|rx_dropped
suffix:semicolon
multiline_comment|/* No memory for skb&t;&t;*/
DECL|member|tx_dropped
r_int
r_int
id|tx_dropped
suffix:semicolon
multiline_comment|/* When MTU change&t;&t;*/
DECL|member|rx_over_errors
r_int
r_int
id|rx_over_errors
suffix:semicolon
multiline_comment|/* Frame bigger then STRIP buf. */
multiline_comment|/*&n;&t; *&t;Internal variables.&n;&t; */
DECL|member|next
r_struct
id|strip
op_star
id|next
suffix:semicolon
multiline_comment|/* The next struct in the list &t;*/
DECL|member|referrer
r_struct
id|strip
op_star
op_star
id|referrer
suffix:semicolon
multiline_comment|/* The pointer that points to us */
DECL|member|flags
r_int
r_char
id|flags
suffix:semicolon
multiline_comment|/* Flag values/ mode etc&t;*/
DECL|member|mtu
r_int
id|mtu
suffix:semicolon
multiline_comment|/* Our mtu (to spot changes!)&t;*/
DECL|member|buffsize
r_int
id|buffsize
suffix:semicolon
multiline_comment|/* Max buffers sizes&t;&t;*/
DECL|member|watchdog_doprobe
r_int
id|watchdog_doprobe
suffix:semicolon
multiline_comment|/* Next time to test the radio&t;*/
DECL|member|watchdog_doreset
r_int
id|watchdog_doreset
suffix:semicolon
multiline_comment|/* Time to do next reset&t;*/
DECL|member|idle_timer
r_struct
id|timer_list
id|idle_timer
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* ptr to TTY structure&t;&t;*/
DECL|member|if_name
r_char
id|if_name
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Dynamically generated name&t;*/
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
multiline_comment|/* Our device structure&t;&t;*/
)brace
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Utility routines for disabling and restoring interrupts&t;&t;*/
DECL|typedef|InterruptStatus
r_typedef
r_int
r_int
id|InterruptStatus
suffix:semicolon
DECL|function|DisableInterrupts
r_extern
id|__inline__
id|InterruptStatus
id|DisableInterrupts
c_func
(paren
r_void
)paren
(brace
id|InterruptStatus
id|x
suffix:semicolon
id|save_flags
c_func
(paren
id|x
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|RestoreInterrupts
r_extern
id|__inline__
r_void
id|RestoreInterrupts
c_func
(paren
id|InterruptStatus
id|x
)paren
(brace
id|restore_flags
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Useful structures and definitions&t;&t;&t;&t;&t;*/
r_typedef
r_struct
(brace
DECL|member|c
id|__u8
id|c
(braket
l_int|32
)braket
suffix:semicolon
DECL|typedef|RadioName
)brace
id|RadioName
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|c
id|__u8
id|c
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|MetricomKey
)brace
id|MetricomKey
suffix:semicolon
r_typedef
r_union
(brace
DECL|member|b
id|__u8
id|b
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|l
id|__u32
id|l
suffix:semicolon
DECL|typedef|IPaddr
)brace
id|IPaddr
suffix:semicolon
DECL|variable|ProtocolKey
r_static
r_const
id|MetricomKey
id|ProtocolKey
op_assign
(brace
(brace
l_string|&quot;SIP0&quot;
)brace
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|FALSE
id|FALSE
op_assign
l_int|0
comma
DECL|enumerator|TRUE
id|TRUE
op_assign
l_int|1
)brace
suffix:semicolon
DECL|macro|LONG_TIME
mdefine_line|#define LONG_TIME 0x7FFFFFFF
r_typedef
r_struct
(brace
DECL|member|name
id|RadioName
id|name
suffix:semicolon
multiline_comment|/* The address, with delimiters eg. *0000-1164* */
DECL|member|key
id|MetricomKey
id|key
suffix:semicolon
multiline_comment|/* Protocol type */
DECL|typedef|STRIP_Header
)brace
id|STRIP_Header
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|h
id|STRIP_Header
id|h
suffix:semicolon
DECL|member|data
id|__u8
id|data
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Placeholder for payload (The IP packet) */
DECL|typedef|STRIP_Packet
)brace
id|STRIP_Packet
suffix:semicolon
multiline_comment|/*&n; *&t;STRIP_ENCAP_SIZE of an IP packet is the STRIP header at the front,&n; *&t;byte-stuffing overhead of the payload, plus the CR at the end&n; */
DECL|macro|STRIP_ENCAP_SIZE
mdefine_line|#define STRIP_ENCAP_SIZE(X) (sizeof(STRIP_Header) + (X)*65L/64L + 2)
multiline_comment|/*&n; *&t;Note: A Metricom packet looks like this: *&lt;address&gt;*&lt;key&gt;&lt;payload&gt;&lt;CR&gt;&n; *&t;eg. *0000-1164*SIP0&lt;payload&gt;&lt;CR&gt;&n; */
DECL|variable|struct_strip_list
r_static
r_struct
id|strip
op_star
id|struct_strip_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/************************************************************************/
multiline_comment|/* Byte stuffing/unstuffing routines&t;&t;&t;&t;&t;*/
multiline_comment|/* Stuffing scheme:&n; * 00    Unused (reserved character)&n; * 01-3F Run of 2-64 different characters&n; * 40-7F Run of 1-64 different characters plus a single zero at the end&n; * 80-BF Run of 1-64 of the same character&n; * C0-FF Run of 1-64 zeroes (ASCII 0)&n; */
r_typedef
r_enum
(brace
DECL|enumerator|Stuff_Diff
id|Stuff_Diff
op_assign
l_int|0x00
comma
DECL|enumerator|Stuff_DiffZero
id|Stuff_DiffZero
op_assign
l_int|0x40
comma
DECL|enumerator|Stuff_Same
id|Stuff_Same
op_assign
l_int|0x80
comma
DECL|enumerator|Stuff_Zero
id|Stuff_Zero
op_assign
l_int|0xC0
comma
DECL|enumerator|Stuff_NoCode
id|Stuff_NoCode
op_assign
l_int|0xFF
comma
multiline_comment|/* Special code, meaning no code selected */
DECL|enumerator|Stuff_CodeMask
id|Stuff_CodeMask
op_assign
l_int|0xC0
comma
DECL|enumerator|Stuff_CountMask
id|Stuff_CountMask
op_assign
l_int|0x3F
comma
DECL|enumerator|Stuff_MaxCount
id|Stuff_MaxCount
op_assign
l_int|0x3F
comma
DECL|enumerator|Stuff_Magic
id|Stuff_Magic
op_assign
l_int|0x0D
multiline_comment|/* The value we are eliminating */
DECL|typedef|StuffingCode
)brace
id|StuffingCode
suffix:semicolon
multiline_comment|/* StuffData encodes the data starting at &quot;src&quot; for &quot;length&quot; bytes.&n; * It writes it to the buffer pointed to by &quot;dst&quot; (which must be at least&n; * as long as 1 + 65/64 of the input length). The output may be up to 1.6%&n; * larger than the input for pathological input, but will usually be smaller.&n; * StuffData returns the new value of the dst pointer as its result.&n; * &quot;code_ptr_ptr&quot; points to a &quot;__u8 *&quot; which is used to hold encoding state&n; * between calls, allowing an encoded packet to be incrementally built up&n; * from small parts. On the first call, the &quot;__u8 *&quot; pointed to should be&n; * initialized to NULL; between subsequent calls the calling routine should&n; * leave the value alone and simply pass it back unchanged so that the&n; * encoder can recover its current state.&n; */
DECL|macro|StuffData_FinishBlock
mdefine_line|#define StuffData_FinishBlock(X) &bslash;&n;(*code_ptr = (X) ^ Stuff_Magic, code = Stuff_NoCode)
DECL|function|StuffData
r_static
id|__u8
op_star
id|StuffData
c_func
(paren
id|__u8
op_star
id|src
comma
id|__u32
id|length
comma
id|__u8
op_star
id|dst
comma
id|__u8
op_star
op_star
id|code_ptr_ptr
)paren
(brace
id|__u8
op_star
id|end
op_assign
id|src
op_plus
id|length
suffix:semicolon
id|__u8
op_star
id|code_ptr
op_assign
op_star
id|code_ptr_ptr
suffix:semicolon
id|__u8
id|code
op_assign
id|Stuff_NoCode
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|code_ptr
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Recover state from last call, if applicable &n;&t;&t; */
id|code
op_assign
(paren
op_star
id|code_ptr
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CodeMask
suffix:semicolon
id|count
op_assign
(paren
op_star
id|code_ptr
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CountMask
suffix:semicolon
)brace
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
multiline_comment|/* Stuff_NoCode: If no current code, select one */
r_case
id|Stuff_NoCode
suffix:colon
multiline_comment|/* Record where we&squot;re going to put this code */
id|code_ptr
op_assign
id|dst
op_increment
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the count (zero means one instance) */
multiline_comment|/* Tentatively start a new block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|code
op_assign
id|Stuff_Zero
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
id|code
op_assign
id|Stuff_Same
suffix:semicolon
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
multiline_comment|/* Note: We optimistically assume run of same -- */
multiline_comment|/* which will be fixed later in Stuff_Same */
multiline_comment|/* if it turns out not to be true. */
r_break
suffix:semicolon
multiline_comment|/* Stuff_Zero: We already have at least one zero encoded */
r_case
id|Stuff_Zero
suffix:colon
multiline_comment|/* If another zero, count it, else finish this code block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|count
op_increment
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_Zero
op_plus
id|count
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Stuff_Same: We already have at least one byte encoded */
r_case
id|Stuff_Same
suffix:colon
multiline_comment|/* If another one the same, count it */
r_if
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_eq
id|code_ptr
(braket
l_int|1
)braket
)paren
(brace
id|count
op_increment
suffix:semicolon
id|src
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else, this byte does not match this block. */
multiline_comment|/* If we already have two or more bytes encoded, */
multiline_comment|/* finish this code block */
r_if
c_cond
(paren
id|count
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_Same
op_plus
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else, we only have one so far, */
multiline_comment|/* so switch to Stuff_Diff code */
id|code
op_assign
id|Stuff_Diff
suffix:semicolon
multiline_comment|/* and fall through to Stuff_Diff case below */
multiline_comment|/* Stuff_Diff: We have at least two *different* bytes encoded */
r_case
id|Stuff_Diff
suffix:colon
multiline_comment|/* If this is a zero, must encode a Stuff_DiffZero, */
multiline_comment|/* and begin a new block */
r_if
c_cond
(paren
op_star
id|src
op_eq
l_int|0
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|Stuff_DiffZero
op_plus
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* else, if we have three in a row, it is worth starting */
multiline_comment|/* a Stuff_Same block */
r_else
r_if
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_eq
id|dst
(braket
op_minus
l_int|1
)braket
op_logical_and
id|dst
(braket
op_minus
l_int|1
)braket
op_eq
id|dst
(braket
op_minus
l_int|2
)braket
)paren
(brace
multiline_comment|/* Back off the last two characters we encoded */
id|code
op_add_assign
id|count
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* Note: &quot;Stuff_Diff + 0&quot; is an illegal code */
r_if
c_cond
(paren
id|code
op_eq
id|Stuff_Diff
op_plus
l_int|0
)paren
(brace
id|code
op_assign
id|Stuff_Same
op_plus
l_int|0
suffix:semicolon
)brace
id|StuffData_FinishBlock
c_func
(paren
id|code
)paren
suffix:semicolon
id|code_ptr
op_assign
id|dst
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* dst[-1] already holds the correct value */
id|count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 2 means three bytes encoded */
id|code
op_assign
id|Stuff_Same
suffix:semicolon
)brace
multiline_comment|/* else, another different byte, so add it to the block */
r_else
(brace
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|src
op_increment
suffix:semicolon
multiline_comment|/* Consume the byte */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
id|Stuff_MaxCount
)paren
(brace
id|StuffData_FinishBlock
c_func
(paren
id|code
op_plus
id|count
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|code
op_eq
id|Stuff_NoCode
)paren
(brace
op_star
id|code_ptr_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|code_ptr_ptr
op_assign
id|code_ptr
suffix:semicolon
id|StuffData_FinishBlock
c_func
(paren
id|code
op_plus
id|count
)paren
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/* UnStuffData decodes the data at &quot;src&quot;, up to (but not including) &quot;end&quot;.&n;It writes the decoded data into the buffer pointed to by &quot;dst&quot;, up to a&n;maximum of &quot;dst_length&quot;, and returns the new value of &quot;src&quot; so that a&n;follow-on call can read more data, continuing from where the first left off.&n;&n;There are three types of results:&n;1. The source data runs out before extracting &quot;dst_length&quot; bytes:&n;   UnStuffData returns NULL to indicate failure.&n;2. The source data produces exactly &quot;dst_length&quot; bytes:&n;   UnStuffData returns new_src = end to indicate that all bytes were consumed.&n;3. &quot;dst_length&quot; bytes are extracted, with more remaining.&n;   UnStuffData returns new_src &lt; end to indicate that there are more bytes&n;   to be read.&n;&n;Note: The decoding may be destructive, in that it may alter the source&n;data in the process of decoding it (this is necessary to allow a follow-on&n;call to resume correctly). */
DECL|function|UnStuffData
r_static
id|__u8
op_star
id|UnStuffData
c_func
(paren
id|__u8
op_star
id|src
comma
id|__u8
op_star
id|end
comma
id|__u8
op_star
id|dst
comma
id|__u32
id|dst_length
)paren
(brace
id|__u8
op_star
id|dst_end
op_assign
id|dst
op_plus
id|dst_length
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
op_logical_neg
id|src
op_logical_or
op_logical_neg
id|end
op_logical_or
op_logical_neg
id|dst
op_logical_or
op_logical_neg
id|dst_length
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
r_int
id|count
op_assign
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CountMask
suffix:semicolon
r_switch
c_cond
(paren
(paren
op_star
id|src
op_xor
id|Stuff_Magic
)paren
op_amp
id|Stuff_CodeMask
)paren
(brace
r_case
id|Stuff_Diff
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_plus
id|count
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
op_star
op_increment
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
op_star
id|src
op_assign
id|Stuff_Same
op_xor
id|Stuff_Magic
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Diff
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|Stuff_DiffZero
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_plus
id|count
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
op_star
op_increment
id|src
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
op_star
id|src
op_assign
id|Stuff_Zero
op_xor
id|Stuff_Magic
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_DiffZero
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Stuff_Same
suffix:colon
r_if
c_cond
(paren
id|src
op_plus
l_int|1
op_ge
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
op_star
id|dst
op_increment
op_assign
id|src
(braket
l_int|1
)braket
op_xor
id|Stuff_Magic
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|2
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Same
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Stuff_Zero
suffix:colon
r_do
(brace
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
op_logical_and
id|dst
OL
id|dst_end
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|src
op_add_assign
l_int|1
suffix:semicolon
r_else
op_star
id|src
op_assign
(paren
id|Stuff_Zero
op_plus
id|count
)paren
op_xor
id|Stuff_Magic
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dst
OL
id|dst_end
)paren
r_return
l_int|NULL
suffix:semicolon
r_else
r_return
id|src
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* General routines for STRIP&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* MTU has been changed by the IP layer. Unfortunately we are not told&n; * about this, but we spot it ourselves and fix things up. We could be in&n; * an upcall from the tty driver, or in an ip packet queue.&n; */
DECL|function|strip_changedmtu
r_static
r_void
id|strip_changedmtu
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
r_int
r_char
op_star
id|tbuff
comma
op_star
id|rbuff
comma
op_star
id|sbuff
comma
op_star
id|otbuff
comma
op_star
id|orbuff
comma
op_star
id|osbuff
suffix:semicolon
r_int
id|len
suffix:semicolon
id|InterruptStatus
id|intstat
suffix:semicolon
id|len
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
id|dev-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|STRIP_ENCAP_SIZE
c_func
(paren
l_int|576
)paren
)paren
id|len
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
l_int|576
)paren
suffix:semicolon
id|tbuff
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
(paren
id|len
op_plus
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|rbuff
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
(paren
id|len
op_plus
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|sbuff
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
(paren
id|len
op_plus
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbuff
op_logical_or
op_logical_neg
id|rbuff
op_logical_or
op_logical_neg
id|sbuff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to grow strip buffers, MTU change cancelled.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|strip_info-&gt;mtu
suffix:semicolon
r_if
c_cond
(paren
id|tbuff
)paren
id|kfree
c_func
(paren
id|tbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuff
)paren
id|kfree
c_func
(paren
id|rbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbuff
)paren
id|kfree
c_func
(paren
id|sbuff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|otbuff
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
id|tbuff
suffix:semicolon
id|orbuff
op_assign
id|strip_info-&gt;rx_buff
suffix:semicolon
id|strip_info-&gt;rx_buff
op_assign
id|rbuff
suffix:semicolon
id|osbuff
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
id|sbuff
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
)paren
(brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
op_le
id|len
)paren
id|memcpy
c_func
(paren
id|strip_info-&gt;tx_buff
comma
id|strip_info-&gt;tx_head
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
r_else
(brace
id|strip_info-&gt;tx_left
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
)brace
)brace
id|strip_info-&gt;tx_head
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
)paren
(brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_le
id|len
)paren
id|memcpy
c_func
(paren
id|strip_info-&gt;sx_buff
comma
id|osbuff
comma
id|strip_info-&gt;sx_count
)paren
suffix:semicolon
r_else
(brace
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;rx_over_errors
op_increment
suffix:semicolon
id|set_bit
c_func
(paren
id|STR_ERROR
comma
op_amp
id|strip_info-&gt;flags
)paren
suffix:semicolon
)brace
)brace
id|strip_info-&gt;mtu
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
id|dev-&gt;mtu
)paren
suffix:semicolon
id|strip_info-&gt;buffsize
op_assign
id|len
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|otbuff
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|otbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orbuff
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|orbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|osbuff
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|osbuff
)paren
suffix:semicolon
)brace
DECL|function|strip_unlock
r_static
r_void
id|strip_unlock
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|strip_info-&gt;idle_timer.expires
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|strip_info-&gt;dev.tbusy
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: trying to unlock already unlocked device!&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Sending routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|function|ResetRadio
r_static
r_void
id|ResetRadio
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_static
r_const
r_char
id|InitString
(braket
)braket
op_assign
l_string|&quot;ate0dt**starmode&bslash;r**&quot;
suffix:semicolon
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|strip_info-&gt;tty
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|InitString
comma
r_sizeof
(paren
id|InitString
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the driver when there&squot;s room for more data.  If we have&n; * more packets to send, we send them here.&n; */
DECL|function|strip_write_some_more
r_static
r_void
id|strip_write_some_more
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|InterruptStatus
id|intstat
suffix:semicolon
r_int
id|num_written
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
op_logical_or
op_logical_neg
id|strip_info-&gt;dev.start
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tx_left
OG
l_int|0
)paren
(brace
multiline_comment|/* If some data left, send it */
multiline_comment|/* Must disable interrupts because otherwise the write_wakeup might&n;&t;&t; * happen before we&squot;ve had a chance to update the tx_left and&n;&t;&t; *  tx_head fields&n; &t;&t; */
id|intstat
op_assign
id|DisableInterrupts
c_func
(paren
)paren
suffix:semicolon
id|num_written
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|strip_info-&gt;tx_head
comma
id|strip_info-&gt;tx_left
)paren
suffix:semicolon
id|strip_info-&gt;tx_left
op_sub_assign
id|num_written
suffix:semicolon
id|strip_info-&gt;tx_head
op_add_assign
id|num_written
suffix:semicolon
id|RestoreInterrupts
c_func
(paren
id|intstat
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Else start transmission of another packet */
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|strip_unlock
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Encapsulate one IP datagram. */
DECL|function|strip_stuff
r_static
r_int
r_char
op_star
id|strip_stuff
c_func
(paren
r_int
r_char
op_star
id|ptr
comma
r_struct
id|strip
op_star
id|strip_info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__u8
op_star
id|start
suffix:semicolon
id|__u8
op_star
id|stuffstate
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|icp
op_assign
id|skb-&gt;data
suffix:semicolon
r_int
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
id|MetricomAddress
id|haddr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|strip_info-&gt;mtu
)paren
(brace
multiline_comment|/* Sigh, shouldn&squot;t occur BUT ... */
id|printk
c_func
(paren
l_string|&quot;%s: Dropping oversized transmit packet!&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|arp_query
c_func
(paren
id|haddr.c
comma
id|skb-&gt;raddr
comma
op_amp
id|strip_info-&gt;dev
)paren
)paren
(brace
id|IPaddr
id|a
comma
id|b
comma
id|c
suffix:semicolon
id|a.l
op_assign
id|skb-&gt;raddr
suffix:semicolon
id|b.l
op_assign
id|skb-&gt;saddr
suffix:semicolon
id|c.l
op_assign
id|skb-&gt;daddr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Unknown dest %d.%d.%d.%d s=%d.%d.%d.%d d=%d.%d.%d.%d&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
comma
id|a.b
(braket
l_int|0
)braket
comma
id|a.b
(braket
l_int|1
)braket
comma
id|a.b
(braket
l_int|2
)braket
comma
id|a.b
(braket
l_int|3
)braket
comma
id|b.b
(braket
l_int|0
)braket
comma
id|b.b
(braket
l_int|1
)braket
comma
id|b.b
(braket
l_int|2
)braket
comma
id|b.b
(braket
l_int|3
)braket
comma
id|c.b
(braket
l_int|0
)braket
comma
id|c.b
(braket
l_int|1
)braket
comma
id|c.b
(braket
l_int|2
)braket
comma
id|c.b
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|strip_info-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|0
)braket
op_mod
l_int|10
suffix:semicolon
id|haddr.s
(braket
l_int|0
)braket
op_div_assign
l_int|10
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|0
)braket
op_mod
l_int|10
suffix:semicolon
id|haddr.s
(braket
l_int|0
)braket
op_div_assign
l_int|10
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|0
)braket
op_mod
l_int|10
suffix:semicolon
id|haddr.s
(braket
l_int|0
)braket
op_div_assign
l_int|10
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|0
)braket
op_mod
l_int|10
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|1
)braket
op_mod
l_int|10
suffix:semicolon
id|haddr.s
(braket
l_int|1
)braket
op_div_assign
l_int|10
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|1
)braket
op_mod
l_int|10
suffix:semicolon
id|haddr.s
(braket
l_int|1
)braket
op_div_assign
l_int|10
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|1
)braket
op_mod
l_int|10
suffix:semicolon
id|haddr.s
(braket
l_int|1
)braket
op_div_assign
l_int|10
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|haddr.s
(braket
l_int|1
)braket
op_mod
l_int|10
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|ProtocolKey.c
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Protocol key */
op_star
id|ptr
op_increment
op_assign
id|ProtocolKey.c
(braket
l_int|1
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|ProtocolKey.c
(braket
l_int|2
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|ProtocolKey.c
(braket
l_int|3
)braket
suffix:semicolon
id|start
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|StuffData
c_func
(paren
id|icp
comma
id|len
comma
id|ptr
comma
op_amp
id|stuffstate
)paren
suffix:semicolon
multiline_comment|/* Make payload */
op_star
id|ptr
op_increment
op_assign
l_int|0x0D
suffix:semicolon
multiline_comment|/* Put on final delimiter */
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* Encapsulate one IP datagram and stuff into a TTY queue. */
DECL|function|strip_send
r_static
r_void
id|strip_send
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
multiline_comment|/* See if someone has been ifconfigging */
r_if
c_cond
(paren
id|strip_info-&gt;mtu
op_ne
id|STRIP_ENCAP_SIZE
c_func
(paren
id|strip_info-&gt;dev.mtu
)paren
)paren
id|strip_changedmtu
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|ptr
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
multiline_comment|/* If we have a packet, encapsulate it and put it in the buffer */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|ptr
op_assign
id|strip_stuff
c_func
(paren
id|ptr
comma
id|strip_info
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* If error, unlock and return */
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|strip_unlock
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strip_info-&gt;tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Count another successful packet */
)brace
multiline_comment|/* Set up the strip_info ready to send the data */
id|strip_info-&gt;tx_head
op_assign
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tx_left
op_assign
id|ptr
op_minus
id|strip_info-&gt;tx_buff
suffix:semicolon
id|strip_info-&gt;tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
multiline_comment|/* If watchdog has expired, reset the radio */
r_if
c_cond
(paren
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doreset
op_ge
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: No response: Resetting radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|ResetRadio
c_func
(paren
id|strip_info
)paren
suffix:semicolon
multiline_comment|/* Note: if there&squot;s a packet to send, strip_write_some_more&n;                 will do it after the reset has finished */
r_return
suffix:semicolon
)brace
multiline_comment|/* No reset.&n;     * If it is time for another tickle, tack it on the end of the packet&n;     */
r_if
c_cond
(paren
(paren
r_int
)paren
id|jiffies
op_minus
id|strip_info-&gt;watchdog_doprobe
op_ge
l_int|0
)paren
(brace
multiline_comment|/* printk(&quot;%s: Routine radio test.&bslash;n&quot;, strip_info-&gt;dev.name); */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
multiline_comment|/* Tickle to make radio protest */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;*&squot;
suffix:semicolon
id|strip_info-&gt;tx_left
op_add_assign
l_int|2
suffix:semicolon
id|strip_info-&gt;watchdog_doprobe
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
)brace
multiline_comment|/* All ready. Start the transmission */
id|strip_write_some_more
c_func
(paren
id|strip_info-&gt;tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Encapsulate an IP datagram and kick it into a TTY queue. */
DECL|function|strip_xmit
r_static
r_int
id|strip_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;start
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: xmit call when iface is down&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|strip_info-&gt;dev.tbusy
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
id|strip_send
c_func
(paren
id|strip_info
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* IdleTask periodically calls strip_xmit, so even when we have no IP packets&n;   to send for an extended period of time, the watchdog processing still gets&n;   done to ensure that the radio stays in Starmode */
DECL|function|strip_IdleTask
r_static
r_void
id|strip_IdleTask
c_func
(paren
r_int
r_int
id|parameter
)paren
(brace
id|strip_xmit
c_func
(paren
l_int|NULL
comma
(paren
r_struct
id|device
op_star
)paren
id|parameter
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Receiving routines&t;&t;&t;&t;&t;&t;&t;*/
DECL|function|strip_receive_room
r_static
r_int
id|strip_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65536
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/* Send one completely decapsulated IP datagram to the IP layer. */
DECL|function|strip_bump
r_static
r_void
id|strip_bump
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u16
id|packetlen
)paren
(brace
r_int
id|count
op_assign
r_sizeof
(paren
id|STRIP_Header
)paren
op_plus
id|packetlen
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: memory squeeze, dropping packet.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
op_amp
id|strip_info-&gt;dev
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
comma
id|strip_info-&gt;rx_buff
comma
id|count
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|strip_info-&gt;rx_packets
op_increment
suffix:semicolon
)brace
DECL|function|RecvErr
r_static
r_void
id|RecvErr
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
r_static
r_const
r_int
id|MAX_RecvErr
op_assign
l_int|80
suffix:semicolon
id|__u8
op_star
id|ptr
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
suffix:semicolon
id|__u8
id|pkt_text
(braket
id|MAX_RecvErr
)braket
comma
op_star
id|p
op_assign
id|pkt_text
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&quot;&squot;
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
id|p
OL
op_amp
id|pkt_text
(braket
id|MAX_RecvErr
op_minus
l_int|4
)braket
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_ge
l_int|32
op_logical_and
op_star
id|ptr
op_le
l_int|126
)paren
op_star
id|p
op_increment
op_assign
op_star
id|ptr
suffix:semicolon
r_else
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;&bslash;%02X&quot;
comma
op_star
id|ptr
)paren
suffix:semicolon
id|p
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
id|ptr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_eq
id|end
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;&quot;&squot;
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-13s%s&bslash;n&quot;
comma
id|msg
comma
id|pkt_text
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STR_ERROR
comma
op_amp
id|strip_info-&gt;flags
)paren
suffix:semicolon
id|strip_info-&gt;rx_errors
op_increment
suffix:semicolon
)brace
DECL|function|RecvErr_Message
r_static
r_void
id|RecvErr_Message
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
comma
id|__u8
op_star
id|sendername
comma
id|__u8
op_star
id|msg
)paren
(brace
r_static
r_const
r_char
id|ERR_001
(braket
)braket
op_assign
l_string|&quot;ERR_001 Not in StarMode!&quot;
suffix:semicolon
r_static
r_const
r_char
id|ERR_002
(braket
)braket
op_assign
l_string|&quot;ERR_002 Remap handle&quot;
suffix:semicolon
r_static
r_const
r_char
id|ERR_003
(braket
)braket
op_assign
l_string|&quot;ERR_003 Can&squot;t resolve name&quot;
suffix:semicolon
r_static
r_const
r_char
id|ERR_004
(braket
)braket
op_assign
l_string|&quot;ERR_004 Name too small or missing&quot;
suffix:semicolon
r_static
r_const
r_char
id|ERR_007
(braket
)braket
op_assign
l_string|&quot;ERR_007 Body too big&quot;
suffix:semicolon
r_static
r_const
r_char
id|ERR_008
(braket
)braket
op_assign
l_string|&quot;ERR_008 Bad character in name&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_001
comma
r_sizeof
(paren
id|ERR_001
)paren
op_minus
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Radio %s is not in StarMode&bslash;n&quot;
comma
id|sendername
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_002
comma
r_sizeof
(paren
id|ERR_002
)paren
op_minus
l_int|1
)paren
)paren
(brace
macro_line|#ifdef notyet&t;&t;/*Kernel doesn&squot;t have scanf!*/
r_int
id|handle
suffix:semicolon
id|__u8
id|newname
(braket
l_int|64
)braket
suffix:semicolon
id|sscanf
c_func
(paren
id|msg
comma
l_string|&quot;ERR_002 Remap handle &amp;%d to name %s&quot;
comma
op_amp
id|handle
comma
id|newname
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Radio name %s is handle %d&bslash;n&quot;
comma
id|newname
comma
id|handle
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_003
comma
r_sizeof
(paren
id|ERR_003
)paren
op_minus
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Radio name &lt;unspecified&gt; is unknown (&bslash;&quot;Can&squot;t resolve name&bslash;&quot; error)&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_004
comma
r_sizeof
(paren
id|ERR_004
)paren
op_minus
l_int|1
)paren
)paren
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
op_plus
id|LONG_TIME
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_007
comma
r_sizeof
(paren
id|ERR_007
)paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Note: This error knocks the radio back into &n;&t;&t; *&t;command mode. &n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Error! Packet size &lt;unspecified&gt; is too big for radio.&quot;
)paren
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Do reset ASAP */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|msg
comma
id|ERR_008
comma
r_sizeof
(paren
id|ERR_008
)paren
op_minus
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Name &lt;unspecified&gt; contains illegal character&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Error Msg:&quot;
comma
id|strip_info
)paren
suffix:semicolon
)brace
DECL|function|process_packet
r_static
r_void
id|process_packet
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|strip_info-&gt;sx_buff
suffix:semicolon
id|__u8
op_star
id|end
op_assign
id|strip_info-&gt;sx_buff
op_plus
id|strip_info-&gt;sx_count
suffix:semicolon
id|__u8
op_star
id|name
comma
op_star
id|name_end
suffix:semicolon
id|__u16
id|packetlen
suffix:semicolon
multiline_comment|/* Ignore empty lines */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Catch &squot;OK&squot; responses which show radio has fallen out of starmode */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
op_eq
l_int|2
op_logical_and
id|ptr
(braket
l_int|0
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;K&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Radio is back in AT command mode: Will Reset&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|strip_info-&gt;watchdog_doreset
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Do reset ASAP */
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for start of address marker, and then skip over it */
r_if
c_cond
(paren
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
)paren
(brace
multiline_comment|/* Catch other error messages */
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_eq
l_char|&squot;E&squot;
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|ptr
(braket
l_int|2
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|ptr
(braket
l_int|3
)braket
op_eq
l_char|&squot;_&squot;
)paren
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
l_int|NULL
comma
id|strip_info-&gt;sx_buff
)paren
suffix:semicolon
r_else
id|RecvErr
c_func
(paren
l_string|&quot;No initial *&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Skip the return address */
id|name
op_assign
id|ptr
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
op_logical_and
op_star
id|ptr
op_ne
l_char|&squot;*&squot;
)paren
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Check for end of address marker, and skip over it */
r_if
c_cond
(paren
id|ptr
op_eq
id|end
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;No second *&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|name_end
op_assign
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Check for STRIP key, and skip over it */
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_ne
id|ProtocolKey.c
(braket
l_int|0
)braket
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_ne
id|ProtocolKey.c
(braket
l_int|1
)braket
op_logical_or
id|ptr
(braket
l_int|2
)braket
op_ne
id|ProtocolKey.c
(braket
l_int|2
)braket
op_logical_or
id|ptr
(braket
l_int|3
)braket
op_ne
id|ProtocolKey.c
(braket
l_int|3
)braket
)paren
(brace
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_eq
l_char|&squot;E&squot;
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|ptr
(braket
l_int|2
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|ptr
(braket
l_int|3
)braket
op_eq
l_char|&squot;_&squot;
)paren
(brace
op_star
id|name_end
op_assign
l_int|0
suffix:semicolon
id|RecvErr_Message
c_func
(paren
id|strip_info
comma
id|name
comma
id|ptr
)paren
suffix:semicolon
)brace
r_else
id|RecvErr
c_func
(paren
l_string|&quot;Unrecognized protocol key&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ptr
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* Decode start of the IP packet header */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Runt packet&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|packetlen
op_assign
(paren
(paren
id|__u16
)paren
id|strip_info-&gt;rx_buff
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|strip_info-&gt;rx_buff
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&t;printk(&quot;Packet %02X.%02X.%02X.%02X&bslash;n&quot;,&n;        strip_info-&gt;rx_buff[0], strip_info-&gt;rx_buff[1],&n;        strip_info-&gt;rx_buff[2], strip_info-&gt;rx_buff[3]);&n;    printk(&quot;Got %d byte packet&bslash;n&quot;, packetlen);*/
multiline_comment|/* Decode remainder of the IP packer */
id|ptr
op_assign
id|UnStuffData
c_func
(paren
id|ptr
comma
id|end
comma
id|strip_info-&gt;rx_buff
op_plus
l_int|4
comma
id|packetlen
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|RecvErr
c_func
(paren
l_string|&quot;Runt packet&quot;
comma
id|strip_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strip_bump
c_func
(paren
id|strip_info
comma
id|packetlen
)paren
suffix:semicolon
multiline_comment|/* This turns out to be a mistake. Taking receipt of a valid packet as&n;     * evidence that the radio is correctly in Starmode (and resetting the&n;     * watchdog_doreset timer) is wrong.  It turns out that if the radio is&n;     * in command mode, with character echo on, then the echo of the packet&n;     * you sent coming back looks like a valid packet and fools this test.&n;     * We should only accept the &quot;ERR_004 Name too small or missing&quot; message&n;     * as evidence that the radio is correctly in Starmode.&n;    strip_info-&gt;watchdog_doprobe = jiffies + 10 * HZ;&n;    strip_info-&gt;watchdog_doreset = jiffies + LONG_TIME;&n;     */
)brace
multiline_comment|/*&n; * Handle the &squot;receiver data ready&squot; interrupt.&n; * This function is called by the &squot;tty_io&squot; module in the kernel when&n; * a block of STRIP data has been received, which can now be decapsulated&n; * and sent on to some IP layer for further processing.&n; */
r_static
r_void
DECL|function|strip_receive_buf
id|strip_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
multiline_comment|/*&t;struct timeval tv;*/
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_const
r_int
r_char
op_star
id|end
op_assign
id|cp
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
op_logical_or
op_logical_neg
id|strip_info-&gt;dev.start
)paren
r_return
suffix:semicolon
multiline_comment|/* Argh! mtu change time! - costs us the packet part received at the change */
r_if
c_cond
(paren
id|strip_info-&gt;mtu
op_ne
id|STRIP_ENCAP_SIZE
c_func
(paren
id|strip_info-&gt;dev.mtu
)paren
)paren
id|strip_changedmtu
c_func
(paren
id|strip_info
)paren
suffix:semicolon
multiline_comment|/*&t;do_gettimeofday(&amp;tv);&n;    printk(&quot;**** strip_receive_buf: %3d bytes at %d.%06d&bslash;n&quot;,&n;        count, tv.tv_sec % 100, tv.tv_usec);*/
multiline_comment|/* Read the characters out of the buffer */
r_while
c_loop
(paren
id|cp
OL
id|end
)paren
(brace
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|set_bit
c_func
(paren
id|STR_ERROR
comma
op_amp
id|strip_info-&gt;flags
)paren
)paren
id|strip_info-&gt;rx_errors
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_int|0x0D
)paren
(brace
multiline_comment|/*printk(&quot;Cut a %d byte packet (%d bytes remaining)&bslash;n&quot;,&n;                strip_info-&gt;sx_count, end-cp-1);*/
r_if
c_cond
(paren
op_logical_neg
id|clear_bit
c_func
(paren
id|STR_ERROR
comma
op_amp
id|strip_info-&gt;flags
)paren
)paren
id|process_packet
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|STR_ERROR
comma
op_amp
id|strip_info-&gt;flags
)paren
op_logical_and
(paren
id|strip_info-&gt;sx_count
OG
l_int|0
op_logical_or
op_star
id|cp
op_ne
l_int|0x0A
)paren
)paren
(brace
multiline_comment|/* (leading newline characters are ignored) */
r_if
c_cond
(paren
id|strip_info-&gt;sx_count
OL
id|strip_info-&gt;buffsize
)paren
id|strip_info-&gt;sx_buff
(braket
id|strip_info-&gt;sx_count
op_increment
)braket
op_assign
op_star
id|cp
suffix:semicolon
r_else
(brace
id|set_bit
c_func
(paren
id|STR_ERROR
comma
op_amp
id|strip_info-&gt;flags
)paren
suffix:semicolon
id|strip_info-&gt;rx_over_errors
op_increment
suffix:semicolon
)brace
)brace
id|cp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* General control routines&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; *&t; Create the Ethernet MAC header for an arbitrary protocol layer &n; *&n; *&t;saddr=NULL&t;means use device source address&n; *&t;daddr=NULL&t;means leave destination address (eg unresolved arp)&n; */
DECL|function|strip_header
r_static
r_int
id|strip_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_return
op_minus
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rebuild the Ethernet MAC header. This is called after an ARP&n; *&t;(or in future other address resolution) has completed on this&n; *&t;sk_buff. We now let ARP fill in the other fields.&n; */
multiline_comment|/* I think this should return zero if packet is ready to send, */
multiline_comment|/* or non-zero if it needs more time to do an address lookup   */
DECL|function|strip_rebuild_header
r_static
r_int
id|strip_rebuild_header
c_func
(paren
r_void
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|dst
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/*&t;STRIP_Header *h = (STRIP_Header *)buff;*/
macro_line|#ifdef CONFIG_INET
multiline_comment|/* I&squot;ll use arp_find when I understand it */
multiline_comment|/* Arp find returns zero if if knows the address, or if it doesn&squot;t */
multiline_comment|/* know the address it sends an ARP packet and returns non-zero */
multiline_comment|/*return arp_find(eth-&gt;h_dest, dst, dev, dev-&gt;pa_addr, skb)? 1 : 0;*/
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif&t;
)brace
DECL|function|strip_set_dev_mac_address
r_static
r_int
id|strip_set_dev_mac_address
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr
comma
l_int|7
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|strip_get_stats
r_static
r_struct
id|enet_statistics
op_star
id|strip_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_struct
id|enet_statistics
id|stats
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|enet_statistics
)paren
)paren
suffix:semicolon
id|stats.rx_packets
op_assign
id|strip_info-&gt;rx_packets
suffix:semicolon
id|stats.tx_packets
op_assign
id|strip_info-&gt;tx_packets
suffix:semicolon
id|stats.rx_dropped
op_assign
id|strip_info-&gt;rx_dropped
suffix:semicolon
id|stats.tx_dropped
op_assign
id|strip_info-&gt;tx_dropped
suffix:semicolon
id|stats.tx_errors
op_assign
id|strip_info-&gt;tx_errors
suffix:semicolon
id|stats.rx_errors
op_assign
id|strip_info-&gt;rx_errors
suffix:semicolon
id|stats.rx_over_errors
op_assign
id|strip_info-&gt;rx_over_errors
suffix:semicolon
r_return
op_amp
id|stats
suffix:semicolon
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Opening and closing&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; * Here&squot;s the order things happen:&n; * When the user runs &quot;slattach -p strip ...&quot;&n; *  1. The TTY module calls strip_open&n; *  2. strip_open calls strip_alloc&n; *  3.                  strip_alloc calls register_netdev&n; *  4.                  register_netdev calls strip_dev_init&n; *  5. then strip_open finishes setting up the strip_info&n; *&n; * When the user runs &quot;ifconfig st&lt;x&gt; up address netmask ...&quot;&n; *  6. strip_open_low gets called&n; *&n; * When the user runs &quot;ifconfig st&lt;x&gt; down&quot;&n; *  7. strip_close_low gets called&n; *&n; * When the user kills the slattach process&n; *  8. strip_close gets called&n; *  9. strip_close calls dev_close&n; * 10. if the device is still up, then dev_close calls strip_close_low&n; * 11. strip_close calls strip_free&n; */
multiline_comment|/* Open the low-level part of the STRIP channel. Easy! */
DECL|function|strip_open_low
r_static
r_int
id|strip_open_low
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the STRIP frame buffers:&n;&t; *&n;&t; * rbuff&t;Receive buffer.&n;&t; * tbuff&t;Transmit buffer.&n;&t; * cbuff        Temporary compression buffer.&n;&t; */
id|len
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
id|dev-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|STRIP_ENCAP_SIZE
c_func
(paren
l_int|576
)paren
)paren
id|len
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
l_int|576
)paren
suffix:semicolon
id|strip_info-&gt;rx_buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;rx_buff
op_eq
l_int|NULL
)paren
r_goto
id|norbuff
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;sx_buff
op_eq
l_int|NULL
)paren
r_goto
id|nosbuff
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tx_buff
op_eq
l_int|NULL
)paren
r_goto
id|notbuff
suffix:semicolon
id|strip_info-&gt;flags
op_and_assign
(paren
l_int|1
op_lshift
id|STR_INUSE
)paren
suffix:semicolon
multiline_comment|/* Clear ESCAPE &amp; ERROR flags */
id|strip_info-&gt;mtu
op_assign
id|STRIP_ENCAP_SIZE
c_func
(paren
id|dev-&gt;mtu
)paren
suffix:semicolon
id|strip_info-&gt;buffsize
op_assign
id|len
suffix:semicolon
id|strip_info-&gt;sx_count
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tx_left
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Needed because address &squot;0&squot; is special &n;&t; */
r_if
c_cond
(paren
id|dev-&gt;pa_addr
op_eq
l_int|0
)paren
id|dev-&gt;pa_addr
op_assign
id|ntohl
c_func
(paren
l_int|0xC0A80001
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Initializing Radio.&bslash;n&quot;
comma
id|strip_info-&gt;dev.name
)paren
suffix:semicolon
id|ResetRadio
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|strip_info-&gt;idle_timer.expires
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|notbuff
suffix:colon
id|kfree
c_func
(paren
id|strip_info-&gt;sx_buff
)paren
suffix:semicolon
id|nosbuff
suffix:colon
id|kfree
c_func
(paren
id|strip_info-&gt;rx_buff
)paren
suffix:semicolon
id|norbuff
suffix:colon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Close the low-level part of the STRIP channel. Easy! &n; */
DECL|function|strip_close_low
r_static
r_int
id|strip_close_low
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|strip_info-&gt;tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free all STRIP frame buffers.&n;&t; */
r_if
c_cond
(paren
id|strip_info-&gt;rx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;rx_buff
)paren
suffix:semicolon
id|strip_info-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;sx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;sx_buff
)paren
suffix:semicolon
id|strip_info-&gt;sx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strip_info-&gt;tx_buff
)paren
(brace
id|kfree
c_func
(paren
id|strip_info-&gt;tx_buff
)paren
suffix:semicolon
id|strip_info-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;This routine is called by DDI when the&n; *&t;(dynamically assigned) device is registered&n; */
DECL|function|strip_dev_init
r_static
r_int
id|strip_dev_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Finish setting up the DEVICE info. &n;&t; */
id|dev-&gt;trans_start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;last_rx
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* Drop after 30 frames queued */
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
id|dev-&gt;metric
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|STRIP_MTU
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_METRICOM
suffix:semicolon
multiline_comment|/* dtang */
id|dev-&gt;hard_header_len
op_assign
l_int|8
suffix:semicolon
multiline_comment|/*sizeof(STRIP_Header);*/
multiline_comment|/*&n;&t; *  dev-&gt;priv                 Already holds a pointer to our struct strip &n;&t; */
id|dev-&gt;broadcast
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;addr_len
op_assign
r_sizeof
(paren
id|MetricomAddress
)paren
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_alen
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Pointer to the interface buffers. &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Pointers to interface service routines. &n;&t; */
id|dev-&gt;open
op_assign
id|strip_open_low
suffix:semicolon
id|dev-&gt;stop
op_assign
id|strip_close_low
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|strip_xmit
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|strip_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|strip_rebuild_header
suffix:semicolon
multiline_comment|/*  dev-&gt;type_trans            unused */
multiline_comment|/*  dev-&gt;set_multicast_list   unused */
id|dev-&gt;set_mac_address
op_assign
id|strip_set_dev_mac_address
suffix:semicolon
multiline_comment|/*  dev-&gt;do_ioctl             unused */
multiline_comment|/*  dev-&gt;set_config           unused */
id|dev-&gt;get_stats
op_assign
id|strip_get_stats
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free a STRIP channel. &n; */
DECL|function|strip_free
r_static
r_void
id|strip_free
c_func
(paren
r_struct
id|strip
op_star
id|strip_info
)paren
(brace
op_star
(paren
id|strip_info-&gt;referrer
)paren
op_assign
id|strip_info-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|strip_info-&gt;next
)paren
id|strip_info-&gt;next-&gt;referrer
op_assign
id|strip_info-&gt;referrer
suffix:semicolon
id|strip_info-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|strip_info
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Allocate a new free STRIP channel &n; */
DECL|function|strip_alloc
r_static
r_struct
id|strip
op_star
id|strip_alloc
c_func
(paren
r_void
)paren
(brace
r_int
id|channel_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|strip
op_star
op_star
id|s
op_assign
op_amp
id|struct_strip_list
suffix:semicolon
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strip
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_info
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If no more memory, return */
multiline_comment|/*&n;&t; *&t;Clear the allocated memory &n;&t; */
id|memset
c_func
(paren
id|strip_info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|strip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Search the list to find where to put our new entry&n;&t; *&t;(and in the process decide what channel number it is&n;&t; *&t;going to be) &n;&t; */
r_while
c_loop
(paren
op_star
id|s
op_logical_and
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|dev.base_addr
op_eq
id|channel_id
)paren
(brace
id|channel_id
op_increment
suffix:semicolon
id|s
op_assign
op_amp
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Fill in the link pointers &n;&t; */
id|strip_info-&gt;next
op_assign
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
(paren
op_star
id|s
)paren
op_member_access_from_pointer
id|referrer
op_assign
op_amp
id|strip_info-&gt;next
suffix:semicolon
id|strip_info-&gt;referrer
op_assign
id|s
suffix:semicolon
op_star
id|s
op_assign
id|strip_info
suffix:semicolon
id|set_bit
c_func
(paren
id|STR_INUSE
comma
op_amp
id|strip_info-&gt;flags
)paren
suffix:semicolon
id|strip_info-&gt;magic
op_assign
id|STRIP_MAGIC
suffix:semicolon
id|strip_info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|strip_info-&gt;idle_timer
)paren
suffix:semicolon
id|strip_info-&gt;idle_timer.data
op_assign
(paren
r_int
)paren
op_amp
id|strip_info-&gt;dev
suffix:semicolon
id|strip_info-&gt;idle_timer.function
op_assign
id|strip_IdleTask
suffix:semicolon
id|sprintf
c_func
(paren
id|strip_info-&gt;if_name
comma
l_string|&quot;st%d&quot;
comma
id|channel_id
)paren
suffix:semicolon
id|strip_info-&gt;dev.name
op_assign
id|strip_info-&gt;if_name
suffix:semicolon
id|strip_info-&gt;dev.base_addr
op_assign
id|channel_id
suffix:semicolon
id|strip_info-&gt;dev.priv
op_assign
(paren
r_void
op_star
)paren
id|strip_info
suffix:semicolon
id|strip_info-&gt;dev.next
op_assign
l_int|NULL
suffix:semicolon
id|strip_info-&gt;dev.init
op_assign
id|strip_dev_init
suffix:semicolon
r_return
id|strip_info
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Open the high-level part of the STRIP channel.&n; *&t;This function is called by the TTY module when the&n; *&t;STRIP line discipline is called for.  Because we are&n; *&t;sure the tty line exists, we only have to link it to&n; *&t;a free STRIP channel...&n; */
DECL|function|strip_open
r_static
r_int
id|strip_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First make sure we&squot;re not already connected.&n;&t; */
r_if
c_cond
(paren
id|strip_info
op_logical_and
id|strip_info-&gt;magic
op_eq
id|STRIP_MAGIC
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/*&n;&t; *&t;OK.  Find a free STRIP channel to use. &n;&t; */
r_if
c_cond
(paren
(paren
id|strip_info
op_assign
id|strip_alloc
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register our newly created device so it can be ifconfig&squot;d&n;&t; * strip_dev_init() will be called as a side-effect&n;&t; */
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;strip: register_netdev() failed.&bslash;n&quot;
)paren
suffix:semicolon
id|strip_free
c_func
(paren
id|strip_info
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
id|strip_info-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|strip_info
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Restore default settings &n;&t; */
id|strip_info-&gt;dev.type
op_assign
id|ARPHRD_METRICOM
suffix:semicolon
multiline_comment|/* dtang */
multiline_comment|/*&n;&t; *&t;Set tty options &n;&t; */
id|tty-&gt;termios-&gt;c_iflag
op_or_assign
id|IGNBRK
op_or
id|IGNPAR
suffix:semicolon
multiline_comment|/* Ignore breaks and parity errors. */
id|tty-&gt;termios-&gt;c_cflag
op_or_assign
id|CLOCAL
suffix:semicolon
multiline_comment|/* Ignore modem control signals. */
id|tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|HUPCL
suffix:semicolon
multiline_comment|/* Don&squot;t close on hup */
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Done.  We have linked the TTY line to a channel. &n;&t; */
r_return
id|strip_info-&gt;dev.base_addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a STRIP channel.&n; * This means flushing out any pending queues, and then restoring the&n; * TTY line discipline to what it was before it got hooked to STRIP&n; * (which usually is TTY again).&n; */
DECL|function|strip_close
r_static
r_void
id|strip_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First make sure we&squot;re connected. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
)paren
r_return
suffix:semicolon
id|dev_close
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|strip_info-&gt;dev
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|strip_info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strip_free
c_func
(paren
id|strip_info
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Perform I/O control calls on an active STRIP channel.       &t;&t;*/
DECL|function|strip_ioctl
r_static
r_int
id|strip_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|strip
op_star
id|strip_info
op_assign
(paren
r_struct
id|strip
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First make sure we&squot;re connected. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strip_info
op_logical_or
id|strip_info-&gt;magic
op_ne
id|STRIP_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFNAME
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|err
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|strip_info-&gt;dev.name
comma
id|strlen
c_func
(paren
id|strip_info-&gt;dev.name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Allow stty to read, but not set, the serial port &n;&t;&t; */
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
r_return
id|n_tty_ioctl
c_func
(paren
id|tty
comma
(paren
r_struct
id|file
op_star
)paren
id|file
comma
id|cmd
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* Initialization&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n; *&t;Initialize the STRIP driver.&n; *&t;This routine is called at boot time, to bootstrap the multi-channel&n; *&t;STRIP driver&n; */
macro_line|#ifdef MODULE
r_static
macro_line|#endif
DECL|function|strip_init_ctrl_dev
r_int
id|strip_init_ctrl_dev
c_func
(paren
r_struct
id|device
op_star
id|dummy
)paren
(brace
r_static
r_struct
id|tty_ldisc
id|strip_ldisc
suffix:semicolon
r_int
id|status
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STRIP: version %s (unlimited channels)&bslash;n&quot;
comma
id|STRIP_VERSION
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill in our line protocol discipline, and register it&n;&t; */
id|memset
c_func
(paren
op_amp
id|strip_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|strip_ldisc
)paren
)paren
suffix:semicolon
id|strip_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|strip_ldisc.flags
op_assign
l_int|0
suffix:semicolon
id|strip_ldisc.open
op_assign
id|strip_open
suffix:semicolon
id|strip_ldisc.close
op_assign
id|strip_close
suffix:semicolon
id|strip_ldisc.read
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.write
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.ioctl
op_assign
id|strip_ioctl
suffix:semicolon
id|strip_ldisc.select
op_assign
l_int|NULL
suffix:semicolon
id|strip_ldisc.receive_buf
op_assign
id|strip_receive_buf
suffix:semicolon
id|strip_ldisc.receive_room
op_assign
id|strip_receive_room
suffix:semicolon
id|strip_ldisc.write_wakeup
op_assign
id|strip_write_some_more
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_STRIP
comma
op_amp
id|strip_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STRIP: can&squot;t register line discipline (err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_return
id|status
suffix:semicolon
macro_line|#else
multiline_comment|/* Return &quot;not found&quot;, so that dev_init() will unlink&n;&t; * the placeholder device entry for us.&n;&t; */
r_return
id|ENODEV
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/************************************************************************/
multiline_comment|/* From here down is only used when compiled as an external module        */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|strip_init_ctrl_dev
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|struct_strip_list
)paren
id|strip_free
c_func
(paren
id|struct_strip_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_STRIP
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STRIP: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
