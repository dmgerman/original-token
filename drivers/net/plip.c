multiline_comment|/*&n; *&t; Plip.c: A parallel port &quot;network&quot; driver for linux. &n; */
multiline_comment|/*&n; *&t;Developement History:&n; *&n; *&t;Original version and the name &squot;PLIP&squot; from Donald Becker  &lt;becker@super.org&gt;&n; *&t;&t;inspired by Russ Nelson&squot;s parallel port packet driver.&n; *&t;Further development by Tommy Thorn &lt;thorn@daimi.aau.dk&gt;&n; *&t;Some changes by Tanabe Hiroyasu &lt;hiro@sanpo.t.u-tokyo.ac.jp&gt;&n; *&t;Upgraded for PL12 by Donald Becker&n; *&t;Minor hacks by Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt; to get it working&n; *&t;&t;more reliably (Ha!)&n; *     Changes even more Peter Bauer (100136.3530@compuserve.com)&n; *     Protocol changed back to original plip as in crynwr&squot;s packet-drivers.&n; *     Tested this against ncsa-telnet 2.3 and pcip_pkt using plip.com (which&n; *     contains &quot;version&t;equ&t;0&quot; and &quot;;History:562,1&quot; in the firts 2&n; *    source-lines&t;&t;&t;&t;&t;&t;28-Mar-94&n; *&n; *&t;Modularised it (Alan Cox). Will upgrade to Niibe&squot;s PLIP once its settled&n; *&t;down better.&n; *&t;&n; *&n; *  This is parallel port packet pusher.  It&squot;s actually more general&n; *  than the &quot;IP&quot; in its name suggests -- but &squot;plip&squot; is just such a&n; *  great name!&n; * &n; *    &n; *   Bugs: Please read this: The PLIP driver is a nasty hack and like all nasty hacks &n; *&t;   has some &squot;features&squot;.&n; *&n; *&t;Can lock machines solid if one end goes down or crashes, or due to cable faults.&n; *&t;Can lock both machines solid on a broadcast collision.&n; *&t;Some laptops don&squot;t have all the wires we use.&n; *&t;Doesn&squot;t match the original Russ Nelson protocol so won&squot;t talk to Amiga or PC drivers.&n; *&t;Waits far too long with interrupts off [X is unbearable, forget action games, xntp is a joke]&n; *&t;Doesn&squot;t work on some fast 486DX machines&n; *&n; *&t;If it works be thankful, if not fix it!&n; *&n; *  Info:&n; *     &t;I &lt;Alan&gt; got 15K/second NFS throughput (about 20-25K second IP). I also got some ethernet cards&n; *&t;so don&squot;t ask me for help. This code needs a real major rewrite. Any volunteers ?&n; *&n; ***** So we can all compare loads of different PLIP drivers for a bit I&squot;ve modularised this beastie too.&n; ***** In addition a seperate bidirectional plip module can be done.&n; */
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;NET3 &quot;
macro_line|#ifdef MODULE
l_string|&quot;MODULAR &quot;
macro_line|#endif    
l_string|&quot;PLIP.010 (from plip.c:v0.15 for 0.99pl12+, 8/11/93)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n;  Sources:&n;&t;Ideas and protocols came from Russ Nelson&squot;s (nelson@crynwr.com)&n;&t;&quot;parallel.asm&quot; parallel port packet driver.&n;&t;TANABE Hiroyasu changes the protocol.&n;  The &quot;Crynwr&quot; parallel port standard specifies the following protocol:&n;   send header nibble &squot;8&squot;&n;   type octet &squot;0xfd&squot; or &squot;0xfc&squot;&n;   count-low octet&n;   count-high octet&n;   ... data octets&n;   checksum octet&n;Each octet is sent as &lt;wait for rx. &squot;0x1?&squot;&gt; &lt;send 0x10+(octet&amp;0x0F)&gt;&n;&t;&t;&t;&lt;wait for rx. &squot;0x0?&squot;&gt; &lt;send 0x00+((octet&gt;&gt;4)&amp;0x0F)&gt;&n;&n;The cable used is a de facto standard parallel null cable -- sold as&n;a &quot;LapLink&quot; cable by various places.  You&squot;ll need a 10-conductor cable to&n;make one yourself.  The wiring is:&n;    INIT&t;16 - 16&t;&t;SLCTIN&t;17 - 17&n;    GROUND&t;25 - 25&n;    D0-&gt;ERROR&t;2 - 15&t;&t;15 - 2&n;    D1-&gt;SLCT&t;3 - 13&t;&t;13 - 3&n;    D2-&gt;PAPOUT&t;4 - 12&t;&t;12 - 4&n;    D3-&gt;ACK&t;5 - 10&t;&t;10 - 5&n;    D4-&gt;BUSY&t;6 - 11&t;&t;11 - 6&n;  Do not connect the other pins.  They are&n;    D5,D6,D7 are 7,8,9&n;    STROBE is 1, FEED is 14&n;    extra grounds are 18,19,20,21,22,23,24&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;../../tools/version.h&quot;
macro_line|#endif
macro_line|#ifdef PRINTK
DECL|macro|PRINTK
macro_line|#undef PRINTK
macro_line|#endif
macro_line|#ifdef PRINTK2
DECL|macro|PRINTK2
macro_line|#undef PRINTK2
macro_line|#endif
DECL|macro|PLIP_DEBUG
mdefine_line|#define PLIP_DEBUG&t;/* debugging */
DECL|macro|PLIP_DEBUG2
macro_line|#undef  PLIP_DEBUG2&t;/* debugging with more varbose report */
macro_line|#ifdef PLIP_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) printk x
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) /**/
macro_line|#endif
macro_line|#ifdef PLIP_DEBUG2
DECL|macro|PRINTK2
mdefine_line|#define PRINTK2(x) printk x
macro_line|#else
DECL|macro|PRINTK2
mdefine_line|#define PRINTK2(x) /**/
macro_line|#endif
multiline_comment|/* The map from IRQ number (as passed to the interrupt handler) to&n;   &squot;struct device&squot;. */
r_extern
r_struct
id|device
op_star
id|irq2dev_map
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Network statistics, with the same names as &squot;struct enet_statistics&squot;. */
DECL|macro|netstats
mdefine_line|#define netstats enet_statistics
multiline_comment|/* constants */
DECL|macro|PAR_DATA
mdefine_line|#define PAR_DATA&t;0
DECL|macro|PAR_STATUS
mdefine_line|#define PAR_STATUS&t;1
DECL|macro|PAR_CONTROL
mdefine_line|#define PAR_CONTROL&t;2
DECL|macro|PLIP_MTU
mdefine_line|#define PLIP_MTU 1600
DECL|macro|PLIP_HEADER_TYPE1
mdefine_line|#define PLIP_HEADER_TYPE1 0xfd
DECL|macro|PLIP_HEADER_TYPE2
mdefine_line|#define PLIP_HEADER_TYPE2 0xfc
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|plip_probe
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_tx_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_header
(paren
r_int
r_char
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|dest
comma
r_void
op_star
id|source
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* variables used internally. */
DECL|macro|INITIALTIMEOUTFACTOR
mdefine_line|#define INITIALTIMEOUTFACTOR 4
DECL|macro|MAXTIMEOUTFACTOR
mdefine_line|#define MAXTIMEOUTFACTOR 20
DECL|variable|timeoutfactor
r_static
r_int
id|timeoutfactor
op_assign
id|INITIALTIMEOUTFACTOR
suffix:semicolon
multiline_comment|/* Routines used internally. */
r_static
r_void
id|plip_device_clear
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|plip_receiver_error
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|plip_set_physicaladdr
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|ipaddr
)paren
suffix:semicolon
r_static
r_int
id|plip_addrcmp
c_func
(paren
r_struct
id|ethhdr
op_star
id|eth
)paren
suffix:semicolon
r_static
r_void
id|cold_sleep
c_func
(paren
r_int
id|tics
)paren
suffix:semicolon
r_static
r_void
id|plip_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
multiline_comment|/* Dispatch from interrupts. */
r_static
r_int
id|plip_receive_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_int
id|plip_send_start
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ethhdr
op_star
id|eth
)paren
suffix:semicolon
r_static
r_void
id|double_timeoutfactor
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|plip_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
r_int
DECL|function|plip_init
id|plip_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|port_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check that there is something at base_addr. */
id|outb
c_func
(paren
l_int|0x00
comma
id|port_base
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x55
comma
id|port_base
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port_base
op_plus
id|PAR_DATA
)paren
op_ne
l_int|0x55
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Alpha testers must have the version number to report bugs. */
macro_line|#ifdef PLIP_DEBUG
(brace
r_static
r_int
id|version_shown
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|version_shown
)paren
id|printk
c_func
(paren
id|version
)paren
comma
id|version_shown
op_increment
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|netstats
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|netstats
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
suffix:semicolon
id|dev-&gt;hard_header
op_assign
op_amp
id|plip_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|eth_rebuild_header
suffix:semicolon
id|dev-&gt;type_trans
op_assign
id|eth_type_trans
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|plip_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|plip_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|plip_tx_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|plip_get_stats
suffix:semicolon
multiline_comment|/* These are ethernet specific. */
id|dev-&gt;type
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|ETH_HLEN
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|PLIP_MTU
suffix:semicolon
multiline_comment|/* PLIP may later negotiate max pkt size */
id|dev-&gt;addr_len
op_assign
id|ETH_ALEN
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;addr_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: configured for parallel port at %#3x, IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* initialize internal value */
id|timeoutfactor
op_assign
id|INITIALTIMEOUTFACTOR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;config &lt;dev-&gt;name&gt;&squot; program is&n;   run.&n;&n;   This routine gets exclusive access to the parallel port by allocating&n;   its IRQ line.&n;   */
DECL|function|plip_open
r_static
r_int
id|plip_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
id|dev-&gt;irq
op_assign
l_int|7
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|plip_interrupt
)paren
op_ne
l_int|0
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;%s: couldn&squot;t get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|plip_device_clear
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif        
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to plip_open(). */
r_static
r_int
DECL|function|plip_close
id|plip_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
multiline_comment|/* Release the interrupt. */
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif        
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_tx_packet
id|plip_tx_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ret_val
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_or
id|dev-&gt;interrupt
)paren
(brace
multiline_comment|/* Do timeouts, to avoid hangs. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|50
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|plip_device_clear
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If some higher layer thinks we&squot;ve missed an tx-done interrupt&n;       we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;       itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ret_val
op_assign
id|plip_send_packet
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;free
)paren
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
l_int|0
multiline_comment|/*ret_val*/
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_header
id|plip_header
(paren
r_int
r_char
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* set physical address */
id|plip_set_physicaladdr
c_func
(paren
id|dev
comma
id|dev-&gt;pa_addr
)paren
suffix:semicolon
)brace
r_return
id|eth_header
c_func
(paren
id|buff
comma
id|dev
comma
id|type
comma
id|daddr
comma
id|saddr
comma
id|len
comma
id|skb
)paren
suffix:semicolon
)brace
"&f;"
r_static
r_void
DECL|function|plip_device_clear
id|plip_device_clear
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Enable the rx interrupt. */
)brace
r_static
r_void
DECL|function|plip_receiver_error
id|plip_receiver_error
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x02
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Enable the rx interrupt. */
)brace
r_static
r_int
DECL|function|get_byte
id|get_byte
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|val
comma
id|oldval
suffix:semicolon
r_int
r_char
id|low_nibble
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
op_star
l_int|2
suffix:semicolon
r_do
(brace
id|oldval
op_assign
id|val
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|val
)paren
r_continue
suffix:semicolon
multiline_comment|/* it&squot;s unstable */
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|val
op_amp
l_int|0x80
)paren
)paren
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
id|low_nibble
op_assign
(paren
id|val
op_rshift
l_int|3
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
op_star
l_int|2
suffix:semicolon
r_do
(brace
id|oldval
op_assign
id|val
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|val
)paren
r_continue
suffix:semicolon
multiline_comment|/* it&squot;s unstable */
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|val
op_amp
l_int|0x80
)paren
)paren
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;%02x %s &quot;
comma
id|low_nibble
op_or
(paren
(paren
id|val
op_lshift
l_int|1
)paren
op_amp
l_int|0xf0
)paren
comma
id|error
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* timeout error */
id|double_timeoutfactor
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|low_nibble
op_or
(paren
(paren
id|val
op_lshift
l_int|1
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
)brace
multiline_comment|/* The typical workload of the driver:&n;   Handle the parallel port interrupts. */
r_static
r_void
DECL|function|plip_interrupt
id|plip_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|irq2dev_map
(braket
id|irq
)braket
suffix:semicolon
r_struct
id|netstats
op_star
id|localstats
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;plip_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_or
id|dev-&gt;interrupt
)paren
r_return
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Disable the rx interrupt. */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Allow other interrupts. */
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;%s: interrupt.  &quot;
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
(brace
multiline_comment|/* check whether the interrupt is valid or not.*/
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0xf8
)paren
op_ne
l_int|0xc0
)paren
(brace
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;%s: No interrupt (status=%#02x)!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
)paren
)paren
suffix:semicolon
id|plip_device_clear
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|plip_receive_packet
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* get some error while receiving data */
id|localstats-&gt;rx_errors
op_increment
suffix:semicolon
id|plip_receiver_error
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|plip_device_clear
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|plip_receive_packet
id|plip_receive_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|length
suffix:semicolon
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|netstats
op_star
id|localstats
suffix:semicolon
r_struct
id|ethhdr
id|eth
suffix:semicolon
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Ack: &squot;Ready&squot; */
(brace
multiline_comment|/* get header octet and length of packet */
id|length
op_assign
id|get_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
id|length
op_or_assign
id|get_byte
c_func
(paren
id|dev
)paren
op_lshift
l_int|8
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|eth_p
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|eth
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|eth
)paren
suffix:semicolon
id|i
op_increment
comma
id|eth_p
op_increment
)paren
(brace
op_star
id|eth_p
op_assign
id|get_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;length = %d&bslash;n&quot;
comma
id|length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|dev-&gt;mtu
op_logical_or
id|length
OL
l_int|8
)paren
(brace
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;%s: bogus packet size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
(brace
multiline_comment|/* get skb area from kernel and &n;&t; * set appropriate values to skb&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
)brace
(brace
multiline_comment|/* phase of receiving the data */
multiline_comment|/* &squot;skb-&gt;data&squot; points to the start of sk_buff data area. */
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|eth_p
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|eth
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|eth
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
op_star
id|eth_p
suffix:semicolon
op_star
id|buf
op_increment
op_assign
op_star
id|eth_p
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
op_minus
r_sizeof
(paren
id|eth
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|new_byte
op_assign
id|get_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
id|checksum
op_add_assign
id|new_byte
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|new_byte
suffix:semicolon
)brace
id|checksum
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|get_byte
c_func
(paren
id|dev
)paren
)paren
(brace
id|localstats-&gt;rx_crc_errors
op_increment
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;checksum error&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev_rint
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|skb
comma
id|length
comma
id|IN_SKBUFF
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: rcv buff full.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|localstats-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
(brace
multiline_comment|/* phase of terminating this connection */
r_int
id|timeout
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|length
op_star
id|timeoutfactor
op_div
l_int|16
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Wait for the remote end to reset. */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0xf8
)paren
op_ne
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|double_timeoutfactor
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;Remote has not reset.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|localstats-&gt;rx_packets
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
DECL|function|send_byte
r_static
r_int
id|send_byte
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
id|val
)paren
(brace
r_int
id|timeout
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot; S%02x&quot;
comma
id|val
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|val
op_amp
l_int|0xf
)paren
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
multiline_comment|/* this makes data bits more stable */
multiline_comment|/* (especially the &amp;0xf :-&gt; PB )    */
id|outb
c_func
(paren
l_int|0x10
op_or
(paren
id|val
op_amp
l_int|0xf
)paren
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0x80
)paren
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x10
op_or
(paren
id|val
op_rshift
l_int|4
)paren
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
op_rshift
l_int|4
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* timeout error */
id|double_timeoutfactor
c_func
(paren
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;t&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * plip_send_start&n; * trigger remoto rx interrupt and establish a connection.&n; * &n; * return value&n; * 0 : establish the connection&n; * -1 : connection failed.&n; */
r_static
r_int
DECL|function|plip_send_start
id|plip_send_start
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ethhdr
op_star
id|eth
)paren
(brace
r_int
id|timeout
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|lasttrigger
suffix:semicolon
r_struct
id|netstats
op_star
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* This starts the packet protocol by triggering a remote IRQ. */
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
op_star
l_int|16
suffix:semicolon
id|lasttrigger
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Disable my rx intr. */
id|outb
c_func
(paren
l_int|0x08
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Trigger remote rx intr. */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* The remote end is also trying to send a packet.&n;&t;     * Only one end may go to the receiving phase,&n;&t;     * so we use the &quot;ethernet&quot; address (set from the IP address)&n;&t;     * to determine which end dominates.&n;&t;     */
r_if
c_cond
(paren
id|plip_addrcmp
c_func
(paren
id|eth
)paren
OG
l_int|0
)paren
(brace
id|localstats-&gt;collisions
op_increment
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;both ends are trying to send a packet.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plip_receive_packet
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* get some error while receiving data */
id|localstats-&gt;rx_errors
op_increment
suffix:semicolon
id|outb
c_func
(paren
l_int|0x02
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
)brace
id|cold_sleep
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* make sure that remote end is ready */
)brace
r_continue
suffix:semicolon
multiline_comment|/* restart send sequence */
)brace
r_if
c_cond
(paren
id|lasttrigger
op_ne
id|jiffies
)paren
(brace
multiline_comment|/* trigger again */
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|cold_sleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|lasttrigger
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|double_timeoutfactor
c_func
(paren
)paren
suffix:semicolon
id|plip_device_clear
c_func
(paren
id|dev
)paren
suffix:semicolon
id|localstats-&gt;tx_errors
op_increment
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;%s: Connect failed in send_packet().&bslash;n&quot;
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
multiline_comment|/* We failed to send the packet.  To emulate the ethernet we&n;&t;       should pretent the send worked fine */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_send_packet
id|plip_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|netstats
op_star
id|localstats
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;%s: plip_send_packet(%d) %02x %02x %02x %02x %02x...&quot;
comma
id|dev-&gt;name
comma
id|length
comma
id|buf
(braket
l_int|0
)braket
comma
id|buf
(braket
l_int|1
)braket
comma
id|buf
(braket
l_int|2
)braket
comma
id|buf
(braket
l_int|3
)braket
comma
id|buf
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|dev-&gt;mtu
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: packet too big, %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
(brace
multiline_comment|/* phase of checking remote status */
r_int
id|i
suffix:semicolon
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|timeoutfactor
op_star
l_int|8
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0xe8
)paren
)paren
op_ne
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0x78
)paren
(brace
multiline_comment|/* probably cable is not connected */
multiline_comment|/* Implementation Note:&n;&t;&t; * This status should result in &squot;Network unreachable&squot;.&n;&t;&t; * but I don&squot;t know the way.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
multiline_comment|/* remote end is not ready */
id|double_timeoutfactor
c_func
(paren
)paren
suffix:semicolon
id|localstats-&gt;tx_errors
op_increment
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;remote end is not ready.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Failed to send the packet */
)brace
)brace
)brace
multiline_comment|/* phase of making a connection */
r_if
c_cond
(paren
id|plip_send_start
c_func
(paren
id|dev
comma
(paren
r_struct
id|ethhdr
op_star
)paren
id|buf
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
(brace
multiline_comment|/* send packet&squot;s length &n;&t;   the byte order has changed now and then. Today it&squot;s sent as in &n;           the original crynwr-plip ...&n;           Gruss PB&n;&t; */
id|send_byte
c_func
(paren
id|dev
comma
id|length
)paren
suffix:semicolon
id|send_byte
c_func
(paren
id|dev
comma
id|length
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
(brace
multiline_comment|/* phase of sending data */
r_int
id|i
suffix:semicolon
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|ethhdr
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|send_byte
c_func
(paren
id|dev
comma
op_star
id|buf
)paren
suffix:semicolon
id|checksum
op_add_assign
op_star
id|buf
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
op_minus
r_sizeof
(paren
r_struct
id|ethhdr
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|send_byte
c_func
(paren
id|dev
comma
id|buf
(braket
id|i
)braket
)paren
OL
l_int|0
)paren
(brace
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|send_byte
c_func
(paren
id|dev
comma
id|checksum
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
(brace
multiline_comment|/* phase of terminating this connection */
r_int
id|timeout
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Wait for the remote end to reset. */
id|timeout
op_assign
id|jiffies
op_plus
(paren
(paren
id|length
op_star
id|timeoutfactor
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0xe8
)paren
op_ne
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|timeout
OL
id|jiffies
)paren
(brace
id|double_timeoutfactor
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;Remote end has not reset.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|error
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* receiver reports error */
id|error
op_increment
suffix:semicolon
)brace
)brace
id|plip_device_clear
c_func
(paren
id|dev
)paren
suffix:semicolon
id|localstats-&gt;tx_packets
op_increment
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;plip_send_packet(%d) done.&bslash;n&quot;
comma
id|length
)paren
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * some trivial functions&n; */
r_static
r_void
DECL|function|plip_set_physicaladdr
id|plip_set_physicaladdr
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|ipaddr
)paren
(brace
multiline_comment|/*&n;     * set physical address to&n;     *  0xfd.0xfd.ipaddr&n;     */
r_int
r_char
op_star
id|addr
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ipaddr
op_rshift
l_int|24
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ipaddr
op_rshift
l_int|24
)paren
op_eq
l_int|0xff
)paren
r_return
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;%s: set physical address to %08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ipaddr
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
(braket
id|i
)braket
op_assign
l_int|0xfd
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
(paren
id|addr
(braket
id|i
)braket
)paren
comma
op_amp
id|ipaddr
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_addrcmp
id|plip_addrcmp
c_func
(paren
r_struct
id|ethhdr
op_star
id|eth
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|eth-&gt;h_dest
(braket
id|i
)braket
OG
id|eth-&gt;h_source
(braket
id|i
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|eth-&gt;h_dest
(braket
id|i
)braket
OL
id|eth-&gt;h_source
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;h_dest = %08x%04x h_source = %08x%04x&bslash;n&quot;
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|eth-&gt;h_dest
(braket
l_int|2
)braket
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|eth-&gt;h_dest
(braket
l_int|0
)braket
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|eth-&gt;h_source
(braket
l_int|2
)braket
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|eth-&gt;h_source
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function is evil, evil, evil.  This should be a&n;   _kernel_, rescheduling sleep!. */
r_static
r_void
DECL|function|cold_sleep
id|cold_sleep
c_func
(paren
r_int
id|tics
)paren
(brace
r_int
id|start
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|start
op_plus
id|tics
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* do nothing */
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|double_timeoutfactor
id|double_timeoutfactor
c_func
(paren
)paren
(brace
id|timeoutfactor
op_mul_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|timeoutfactor
op_ge
id|MAXTIMEOUTFACTOR
)paren
(brace
id|timeoutfactor
op_assign
id|MAXTIMEOUTFACTOR
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_struct
id|enet_statistics
op_star
DECL|function|plip_get_stats
id|plip_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|netstats
op_star
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
id|localstats
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -Wall -O6 -fomit-frame-pointer -x c++ -c plip.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; * End:&n; */
macro_line|#ifdef MODULE
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|variable|dev_plip0
r_static
r_struct
id|device
id|dev_plip0
op_assign
(brace
l_string|&quot;plip0&quot;
multiline_comment|/*&quot;plip&quot;*/
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* memory */
l_int|0x3BC
comma
l_int|5
comma
multiline_comment|/* base, irq */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|plip_init
)brace
suffix:semicolon
DECL|variable|dev_plip1
r_static
r_struct
id|device
id|dev_plip1
op_assign
(brace
l_string|&quot;plip1&quot;
multiline_comment|/*&quot;plip&quot;*/
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* memory */
l_int|0x378
comma
l_int|7
comma
multiline_comment|/* base, irq */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|plip_init
)brace
suffix:semicolon
DECL|variable|dev_plip2
r_static
r_struct
id|device
id|dev_plip2
op_assign
(brace
l_string|&quot;plip2&quot;
multiline_comment|/*&quot;plip&quot;*/
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* memory */
l_int|0x278
comma
l_int|2
comma
multiline_comment|/* base, irq */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|plip_init
)brace
suffix:semicolon
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|err
op_assign
id|register_netdev
c_func
(paren
op_amp
id|dev_plip0
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|err
op_assign
id|register_netdev
c_func
(paren
op_amp
id|dev_plip1
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|err
op_assign
id|register_netdev
c_func
(paren
op_amp
id|dev_plip2
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EEXIST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;plip devices already present. Module not loaded.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
id|printk
c_func
(paren
l_string|&quot;plip: device busy, remove delayed&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|dev_plip0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_plip0.priv
)paren
(brace
id|kfree_s
c_func
(paren
id|dev_plip0.priv
comma
r_sizeof
(paren
r_struct
id|netstats
)paren
)paren
suffix:semicolon
id|dev_plip0.priv
op_assign
l_int|NULL
suffix:semicolon
)brace
id|unregister_netdev
c_func
(paren
op_amp
id|dev_plip1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_plip1.priv
)paren
(brace
id|kfree_s
c_func
(paren
id|dev_plip1.priv
comma
r_sizeof
(paren
r_struct
id|netstats
)paren
)paren
suffix:semicolon
id|dev_plip0.priv
op_assign
l_int|NULL
suffix:semicolon
)brace
id|unregister_netdev
c_func
(paren
op_amp
id|dev_plip2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_plip2.priv
)paren
(brace
id|kfree_s
c_func
(paren
id|dev_plip2.priv
comma
r_sizeof
(paren
r_struct
id|netstats
)paren
)paren
suffix:semicolon
id|dev_plip2.priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* MODULE */
eof
