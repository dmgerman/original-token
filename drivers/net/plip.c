multiline_comment|/* $Id: plip.c,v 1.3.6.2 1997/04/16 15:07:56 phil Exp $ */
multiline_comment|/* PLIP: A parallel port &quot;network&quot; driver for Linux. */
multiline_comment|/* This driver is for parallel port with 5-bit cable (LapLink (R) cable). */
multiline_comment|/*&n; * Authors:&t;Donald Becker &lt;becker@super.org&gt;&n; *&t;&t;Tommy Thorn &lt;thorn@daimi.aau.dk&gt;&n; *&t;&t;Tanabe Hiroyasu &lt;hiro@sanpo.t.u-tokyo.ac.jp&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Peter Bauer &lt;100136.3530@compuserve.com&gt;&n; *&t;&t;Niibe Yutaka &lt;gniibe@mri.co.jp&gt;&n; *&t;&t;Nimrod Zimerman &lt;zimerman@mailandnews.com&gt;&n; *&n; * Enhancements:&n; *&t;&t;Modularization and ifreq/ifmap support by Alan Cox.&n; *&t;&t;Rewritten by Niibe Yutaka.&n; *&t;&t;parport-sharing awareness code by Philip Blundell.&n; *&t;&t;SMP locking by Niibe Yutaka.&n; *&t;&t;Support for parallel ports with no IRQ (poll mode),&n; *&t;&t;Modifications to use the parallel port API &n; *&t;&t;by Nimrod Zimerman.&n; *&n; * Fixes:&n; *&t;&t;Niibe Yutaka&n; *&t;&t;  - Module initialization.&n; *&t;&t;  - MTU fix.&n; *&t;&t;  - Make sure other end is OK, before sending a packet.&n; *&t;&t;  - Fix immediate timer problem.&n; *&n; *&t;&t;Al Viro&n; *&t;&t;  - Changed {enable,disable}_irq handling to make it work&n; *&t;&t;    with new (&quot;stack&quot;) semantics.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; * Original version and the name &squot;PLIP&squot; from Donald Becker &lt;becker@super.org&gt;&n; * inspired by Russ Nelson&squot;s parallel port packet driver.&n; *&n; * NOTE:&n; *     Tanabe Hiroyasu had changed the protocol, and it was in Linux v1.0.&n; *     Because of the necessity to communicate to DOS machines with the&n; *     Crynwr packet driver, Peter Bauer changed the protocol again&n; *     back to original protocol.&n; *&n; *     This version follows original PLIP protocol.&n; *     So, this PLIP can&squot;t communicate the PLIP of Linux v1.0.&n; */
multiline_comment|/*&n; *     To use with DOS box, please do (Turn on ARP switch):&n; *&t;# ifconfig plip[0-2] arp&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;NET3 PLIP version 2.4-parport gniibe@mri.co.jp&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n;  Sources:&n;&t;Ideas and protocols came from Russ Nelson&squot;s &lt;nelson@crynwr.com&gt;&n;&t;&quot;parallel.asm&quot; parallel port packet driver.&n;&n;  The &quot;Crynwr&quot; parallel port standard specifies the following protocol:&n;    Trigger by sending nibble &squot;0x8&squot; (this causes interrupt on other end)&n;    count-low octet&n;    count-high octet&n;    ... data octets&n;    checksum octet&n;  Each octet is sent as &lt;wait for rx. &squot;0x1?&squot;&gt; &lt;send 0x10+(octet&amp;0x0F)&gt;&n;&t;&t;&t;&lt;wait for rx. &squot;0x0?&squot;&gt; &lt;send 0x00+((octet&gt;&gt;4)&amp;0x0F)&gt;&n;&n;  The packet is encapsulated as if it were ethernet.&n;&n;  The cable used is a de facto standard parallel null cable -- sold as&n;  a &quot;LapLink&quot; cable by various places.  You&squot;ll need a 12-conductor cable to&n;  make one yourself.  The wiring is:&n;    SLCTIN&t;17 - 17&n;    GROUND&t;25 - 25&n;    D0-&gt;ERROR&t;2 - 15&t;&t;15 - 2&n;    D1-&gt;SLCT&t;3 - 13&t;&t;13 - 3&n;    D2-&gt;PAPOUT&t;4 - 12&t;&t;12 - 4&n;    D3-&gt;ACK&t;5 - 10&t;&t;10 - 5&n;    D4-&gt;BUSY&t;6 - 11&t;&t;11 - 6&n;  Do not connect the other pins.  They are&n;    D5,D6,D7 are 7,8,9&n;    STROBE is 1, FEED is 14, INIT is 16&n;    extra grounds are 18,19,20,21,22,23,24&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/lp.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_plip.h&gt;
macro_line|#include &lt;net/neighbour.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
multiline_comment|/* Maximum number of devices to support. */
DECL|macro|PLIP_MAX
mdefine_line|#define PLIP_MAX  8
multiline_comment|/* Use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 1
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
DECL|macro|ENABLE
mdefine_line|#define ENABLE(irq)  if (irq != -1) enable_irq(irq)
DECL|macro|DISABLE
mdefine_line|#define DISABLE(irq) if (irq != -1) disable_irq(irq)
multiline_comment|/* In micro second */
DECL|macro|PLIP_DELAY_UNIT
mdefine_line|#define PLIP_DELAY_UNIT&t;&t;   1
multiline_comment|/* Connection time out = PLIP_TRIGGER_WAIT * PLIP_DELAY_UNIT usec */
DECL|macro|PLIP_TRIGGER_WAIT
mdefine_line|#define PLIP_TRIGGER_WAIT&t; 500
multiline_comment|/* Nibble time out = PLIP_NIBBLE_WAIT * PLIP_DELAY_UNIT usec */
DECL|macro|PLIP_NIBBLE_WAIT
mdefine_line|#define PLIP_NIBBLE_WAIT        3000
multiline_comment|/* Bottom halves */
r_static
r_void
id|plip_kick_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|plip_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|plip_timer_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Interrupt handler */
r_static
r_void
id|plip_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/* Functions for DEV methods */
r_static
r_int
id|plip_tx_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_hard_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|plip_hard_header_cache
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|hh_cache
op_star
id|hh
)paren
suffix:semicolon
r_static
r_int
id|plip_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|plip_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|plip_preempt
c_func
(paren
r_void
op_star
id|handle
)paren
suffix:semicolon
r_static
r_void
id|plip_wakeup
c_func
(paren
r_void
op_star
id|handle
)paren
suffix:semicolon
"&f;"
DECL|enum|plip_connection_state
r_enum
id|plip_connection_state
(brace
DECL|enumerator|PLIP_CN_NONE
id|PLIP_CN_NONE
op_assign
l_int|0
comma
DECL|enumerator|PLIP_CN_RECEIVE
id|PLIP_CN_RECEIVE
comma
DECL|enumerator|PLIP_CN_SEND
id|PLIP_CN_SEND
comma
DECL|enumerator|PLIP_CN_CLOSING
id|PLIP_CN_CLOSING
comma
DECL|enumerator|PLIP_CN_ERROR
id|PLIP_CN_ERROR
)brace
suffix:semicolon
DECL|enum|plip_packet_state
r_enum
id|plip_packet_state
(brace
DECL|enumerator|PLIP_PK_DONE
id|PLIP_PK_DONE
op_assign
l_int|0
comma
DECL|enumerator|PLIP_PK_TRIGGER
id|PLIP_PK_TRIGGER
comma
DECL|enumerator|PLIP_PK_LENGTH_LSB
id|PLIP_PK_LENGTH_LSB
comma
DECL|enumerator|PLIP_PK_LENGTH_MSB
id|PLIP_PK_LENGTH_MSB
comma
DECL|enumerator|PLIP_PK_DATA
id|PLIP_PK_DATA
comma
DECL|enumerator|PLIP_PK_CHECKSUM
id|PLIP_PK_CHECKSUM
)brace
suffix:semicolon
DECL|enum|plip_nibble_state
r_enum
id|plip_nibble_state
(brace
DECL|enumerator|PLIP_NB_BEGIN
id|PLIP_NB_BEGIN
comma
DECL|enumerator|PLIP_NB_1
id|PLIP_NB_1
comma
DECL|enumerator|PLIP_NB_2
id|PLIP_NB_2
comma
)brace
suffix:semicolon
DECL|struct|plip_local
r_struct
id|plip_local
(brace
DECL|member|state
r_enum
id|plip_packet_state
id|state
suffix:semicolon
DECL|member|nibble
r_enum
id|plip_nibble_state
id|nibble
suffix:semicolon
r_union
(brace
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN)
DECL|member|lsb
r_int
r_char
id|lsb
suffix:semicolon
DECL|member|msb
r_int
r_char
id|msb
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN)
r_int
r_char
id|msb
suffix:semicolon
r_int
r_char
id|lsb
suffix:semicolon
macro_line|#else
macro_line|#error&t;&quot;Please fix the endianness defines in &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|member|h
r_int
r_int
id|h
suffix:semicolon
DECL|member|length
)brace
id|length
suffix:semicolon
DECL|member|byte
r_int
r_int
id|byte
suffix:semicolon
DECL|member|checksum
r_int
r_char
id|checksum
suffix:semicolon
DECL|member|data
r_int
r_char
id|data
suffix:semicolon
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|enet_stats
r_struct
id|net_device_stats
id|enet_stats
suffix:semicolon
DECL|member|immediate
r_struct
id|tq_struct
id|immediate
suffix:semicolon
DECL|member|deferred
r_struct
id|tq_struct
id|deferred
suffix:semicolon
DECL|member|timer
r_struct
id|tq_struct
id|timer
suffix:semicolon
DECL|member|snd_data
r_struct
id|plip_local
id|snd_data
suffix:semicolon
DECL|member|rcv_data
r_struct
id|plip_local
id|rcv_data
suffix:semicolon
DECL|member|pardev
r_struct
id|pardevice
op_star
id|pardev
suffix:semicolon
DECL|member|trigger
r_int
r_int
id|trigger
suffix:semicolon
DECL|member|nibble
r_int
r_int
id|nibble
suffix:semicolon
DECL|member|connection
r_enum
id|plip_connection_state
id|connection
suffix:semicolon
DECL|member|timeout_count
r_int
r_int
id|timeout_count
suffix:semicolon
DECL|member|is_deferred
r_int
id|is_deferred
suffix:semicolon
DECL|member|port_owner
r_int
id|port_owner
suffix:semicolon
DECL|member|should_relinquish
r_int
id|should_relinquish
suffix:semicolon
DECL|member|orig_hard_header
r_int
(paren
op_star
id|orig_hard_header
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|orig_hard_header_cache
r_int
(paren
op_star
id|orig_hard_header_cache
)paren
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|hh_cache
op_star
id|hh
)paren
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|kill_timer
id|atomic_t
id|kill_timer
suffix:semicolon
DECL|member|killed_timer_sem
r_struct
id|semaphore
id|killed_timer_sem
suffix:semicolon
)brace
suffix:semicolon
"&f;"
DECL|function|enable_parport_interrupts
r_inline
r_static
r_void
id|enable_parport_interrupts
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
op_minus
l_int|1
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|pardev-&gt;port
suffix:semicolon
id|port-&gt;ops-&gt;enable_irq
(paren
id|port
)paren
suffix:semicolon
)brace
)brace
DECL|function|disable_parport_interrupts
r_inline
r_static
r_void
id|disable_parport_interrupts
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
op_minus
l_int|1
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|pardev-&gt;port
suffix:semicolon
id|port-&gt;ops-&gt;disable_irq
(paren
id|port
)paren
suffix:semicolon
)brace
)brace
DECL|function|write_data
r_inline
r_static
r_void
id|write_data
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_char
id|data
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|pardev-&gt;port
suffix:semicolon
id|port-&gt;ops-&gt;write_data
(paren
id|port
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|read_status
r_inline
r_static
r_int
r_char
id|read_status
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|pardev-&gt;port
suffix:semicolon
r_return
id|port-&gt;ops-&gt;read_status
(paren
id|port
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Entry point of PLIP driver.&n;   Probe the hardware, and register/initialize the driver.&n;&n;   PLIP is rather weird, because of the way it interacts with the parport&n;   system.  It is _not_ initialised from Space.c.  Instead, plip_init()&n;   is called, and that function makes up a &quot;struct net_device&quot; for each port, and&n;   then calls us here.&n;&n;   */
r_int
id|__init
DECL|function|plip_init_dev
id|plip_init_dev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_struct
id|net_local
op_star
id|nl
suffix:semicolon
r_struct
id|pardevice
op_star
id|pardev
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|pb-&gt;irq
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|pb-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;plip: %s has no IRQ. Using IRQ-less mode,&quot;
l_string|&quot;which is fairly inefficient!&bslash;n&quot;
comma
id|pb-&gt;name
)paren
suffix:semicolon
)brace
id|pardev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
id|dev-&gt;name
comma
id|plip_preempt
comma
id|plip_wakeup
comma
id|plip_interrupt
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pardev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Parallel port at %#3lx, using IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Parallel port at %#3lx, not using IRQ.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
multiline_comment|/* Fill in the generic fields of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Then, override parts of it */
id|dev-&gt;hard_start_xmit
op_assign
id|plip_tx_packet
suffix:semicolon
id|dev-&gt;open
op_assign
id|plip_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|plip_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|plip_get_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|plip_ioctl
suffix:semicolon
id|dev-&gt;header_cache_update
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|10
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;dev_addr
comma
l_int|0xfc
comma
id|ETH_ALEN
)paren
suffix:semicolon
multiline_comment|/* Set the private structure */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: out of memory&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|pardev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|nl-&gt;orig_hard_header
op_assign
id|dev-&gt;hard_header
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|plip_hard_header
suffix:semicolon
id|nl-&gt;orig_hard_header_cache
op_assign
id|dev-&gt;hard_header_cache
suffix:semicolon
id|dev-&gt;hard_header_cache
op_assign
id|plip_hard_header_cache
suffix:semicolon
id|nl-&gt;pardev
op_assign
id|pardev
suffix:semicolon
id|nl-&gt;port_owner
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize constants */
id|nl-&gt;trigger
op_assign
id|PLIP_TRIGGER_WAIT
suffix:semicolon
id|nl-&gt;nibble
op_assign
id|PLIP_NIBBLE_WAIT
suffix:semicolon
multiline_comment|/* Initialize task queue structures */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|nl-&gt;immediate.list
)paren
suffix:semicolon
id|nl-&gt;immediate.sync
op_assign
l_int|0
suffix:semicolon
id|nl-&gt;immediate.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|plip_bh
suffix:semicolon
id|nl-&gt;immediate.data
op_assign
id|dev
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|nl-&gt;deferred.list
)paren
suffix:semicolon
id|nl-&gt;deferred.sync
op_assign
l_int|0
suffix:semicolon
id|nl-&gt;deferred.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|plip_kick_bh
suffix:semicolon
id|nl-&gt;deferred.data
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
op_minus
l_int|1
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|nl-&gt;timer.list
)paren
suffix:semicolon
id|nl-&gt;timer.sync
op_assign
l_int|0
suffix:semicolon
id|nl-&gt;timer.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|plip_timer_bh
suffix:semicolon
id|nl-&gt;timer.data
op_assign
id|dev
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Bottom half handler for the delayed request.&n;   This routine is kicked by do_timer().&n;   Request `plip_bh&squot; to be invoked. */
r_static
r_void
DECL|function|plip_kick_bh
id|plip_kick_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;is_deferred
)paren
(brace
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;immediate
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Forward declarations of internal routines */
r_static
r_int
id|plip_none
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|net_local
op_star
comma
r_struct
id|plip_local
op_star
comma
r_struct
id|plip_local
op_star
)paren
suffix:semicolon
r_static
r_int
id|plip_receive_packet
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|net_local
op_star
comma
r_struct
id|plip_local
op_star
comma
r_struct
id|plip_local
op_star
)paren
suffix:semicolon
r_static
r_int
id|plip_send_packet
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|net_local
op_star
comma
r_struct
id|plip_local
op_star
comma
r_struct
id|plip_local
op_star
)paren
suffix:semicolon
r_static
r_int
id|plip_connection_close
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|net_local
op_star
comma
r_struct
id|plip_local
op_star
comma
r_struct
id|plip_local
op_star
)paren
suffix:semicolon
r_static
r_int
id|plip_error
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|net_local
op_star
comma
r_struct
id|plip_local
op_star
comma
r_struct
id|plip_local
op_star
)paren
suffix:semicolon
r_static
r_int
id|plip_bh_timeout_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
comma
r_int
id|error
)paren
suffix:semicolon
DECL|macro|OK
mdefine_line|#define OK        0
DECL|macro|TIMEOUT
mdefine_line|#define TIMEOUT   1
DECL|macro|ERROR
mdefine_line|#define ERROR     2
DECL|macro|HS_TIMEOUT
mdefine_line|#define HS_TIMEOUT&t;3
DECL|typedef|plip_func
r_typedef
r_int
(paren
op_star
id|plip_func
)paren
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
)paren
suffix:semicolon
DECL|variable|connection_state_table
r_static
id|plip_func
id|connection_state_table
(braket
)braket
op_assign
(brace
id|plip_none
comma
id|plip_receive_packet
comma
id|plip_send_packet
comma
id|plip_connection_close
comma
id|plip_error
)brace
suffix:semicolon
multiline_comment|/* Bottom half handler of PLIP. */
r_static
r_void
DECL|function|plip_bh
id|plip_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|plip_local
op_star
id|snd
op_assign
op_amp
id|nl-&gt;snd_data
suffix:semicolon
r_struct
id|plip_local
op_star
id|rcv
op_assign
op_amp
id|nl-&gt;rcv_data
suffix:semicolon
id|plip_func
id|f
suffix:semicolon
r_int
id|r
suffix:semicolon
id|nl-&gt;is_deferred
op_assign
l_int|0
suffix:semicolon
id|f
op_assign
id|connection_state_table
(braket
id|nl-&gt;connection
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
(paren
op_star
id|f
)paren
(paren
id|dev
comma
id|nl
comma
id|snd
comma
id|rcv
)paren
)paren
op_ne
id|OK
op_logical_and
(paren
id|r
op_assign
id|plip_bh_timeout_error
c_func
(paren
id|dev
comma
id|nl
comma
id|snd
comma
id|rcv
comma
id|r
)paren
)paren
op_ne
id|OK
)paren
(brace
id|nl-&gt;is_deferred
op_assign
l_int|1
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;deferred
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|plip_timer_bh
id|plip_timer_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|atomic_read
(paren
op_amp
id|nl-&gt;kill_timer
)paren
)paren
)paren
(brace
id|plip_interrupt
(paren
op_minus
l_int|1
comma
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|queue_task
(paren
op_amp
id|nl-&gt;timer
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
r_else
(brace
id|up
(paren
op_amp
id|nl-&gt;killed_timer_sem
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|plip_bh_timeout_error
id|plip_bh_timeout_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
comma
r_int
id|error
)paren
(brace
r_int
r_char
id|c0
suffix:semicolon
multiline_comment|/*&n;&t; * This is tricky. If we got here from the beginning of send (either&n;&t; * with ERROR or HS_TIMEOUT) we have IRQ enabled. Otherwise it&squot;s&n;&t; * already disabled. With the old variant of {enable,disable}_irq()&n;&t; * extra disable_irq() was a no-op. Now it became mortal - it&squot;s&n;&t; * unbalanced and thus we&squot;ll never re-enable IRQ (until rmmod plip,&n;&t; * that is). So we have to treat HS_TIMEOUT and ERROR from send&n;&t; * in a special way.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;connection
op_eq
id|PLIP_CN_SEND
)paren
(brace
r_if
c_cond
(paren
id|error
op_ne
id|ERROR
)paren
(brace
multiline_comment|/* Timeout */
id|nl-&gt;timeout_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_eq
id|HS_TIMEOUT
op_logical_and
id|nl-&gt;timeout_count
op_le
l_int|10
)paren
op_logical_or
id|nl-&gt;timeout_count
op_le
l_int|3
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Try again later */
r_return
id|TIMEOUT
suffix:semicolon
)brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timeout(%d,%02x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|snd-&gt;state
comma
id|c0
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|HS_TIMEOUT
suffix:semicolon
id|nl-&gt;enet_stats.tx_errors
op_increment
suffix:semicolon
id|nl-&gt;enet_stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nl-&gt;connection
op_eq
id|PLIP_CN_RECEIVE
)paren
(brace
r_if
c_cond
(paren
id|rcv-&gt;state
op_eq
id|PLIP_PK_TRIGGER
)paren
(brace
multiline_comment|/* Transmission was interrupted. */
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_ne
id|ERROR
)paren
(brace
multiline_comment|/* Timeout */
r_if
c_cond
(paren
op_increment
id|nl-&gt;timeout_count
op_le
l_int|3
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Try again later */
r_return
id|TIMEOUT
suffix:semicolon
)brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: receive timeout(%d,%02x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rcv-&gt;state
comma
id|c0
)paren
suffix:semicolon
)brace
id|nl-&gt;enet_stats.rx_dropped
op_increment
suffix:semicolon
)brace
id|rcv-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
r_if
c_cond
(paren
id|rcv-&gt;skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|rcv-&gt;skb
)paren
suffix:semicolon
id|rcv-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|snd-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
r_if
c_cond
(paren
id|snd-&gt;skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|snd-&gt;skb
)paren
suffix:semicolon
id|snd-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|HS_TIMEOUT
)paren
(brace
id|DISABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
)brace
id|disable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_ERROR
suffix:semicolon
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
r_return
id|TIMEOUT
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|plip_none
id|plip_none
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
)paren
(brace
r_return
id|OK
suffix:semicolon
)brace
multiline_comment|/* PLIP_RECEIVE --- receive a byte(two nibbles)&n;   Returns OK on success, TIMEOUT on timeout */
r_inline
r_static
r_int
DECL|function|plip_receive
id|plip_receive
c_func
(paren
r_int
r_int
id|nibble_timeout
comma
r_struct
id|net_device
op_star
id|dev
comma
r_enum
id|plip_nibble_state
op_star
id|ns_p
comma
r_int
r_char
op_star
id|data_p
)paren
(brace
r_int
r_char
id|c0
comma
id|c1
suffix:semicolon
r_int
r_int
id|cx
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|ns_p
)paren
(brace
r_case
id|PLIP_NB_BEGIN
suffix:colon
id|cx
op_assign
id|nibble_timeout
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|PLIP_DELAY_UNIT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c0
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|c1
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c0
op_eq
id|c1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|cx
op_eq
l_int|0
)paren
r_return
id|TIMEOUT
suffix:semicolon
)brace
op_star
id|data_p
op_assign
(paren
id|c0
op_rshift
l_int|3
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|write_data
(paren
id|dev
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* send ACK */
op_star
id|ns_p
op_assign
id|PLIP_NB_1
suffix:semicolon
r_case
id|PLIP_NB_1
suffix:colon
id|cx
op_assign
id|nibble_timeout
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|PLIP_DELAY_UNIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c0
op_amp
l_int|0x80
)paren
(brace
id|c1
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c0
op_eq
id|c1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|cx
op_eq
l_int|0
)paren
r_return
id|TIMEOUT
suffix:semicolon
)brace
op_star
id|data_p
op_or_assign
(paren
id|c0
op_lshift
l_int|1
)paren
op_amp
l_int|0xf0
suffix:semicolon
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* send ACK */
op_star
id|ns_p
op_assign
id|PLIP_NB_BEGIN
suffix:semicolon
r_case
id|PLIP_NB_2
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|OK
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Determine the packet&squot;s protocol ID. The rule here is that we &n; *&t;assume 802.3 if the type field is short enough to be a length.&n; *&t;This is normal practice and works for any &squot;now in use&squot; protocol.&n; *&n; *&t;PLIP is ethernet ish but the daddr might not be valid if unicast.&n; *&t;PLIP fortunately has no bus architecture (its Point-to-point).&n; *&n; *&t;We can&squot;t fix the daddr thing as that quirk (more bug) is embedded&n; *&t;in far too many old systems not all even running Linux.&n; */
DECL|function|plip_type_trans
r_static
r_int
r_int
id|plip_type_trans
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth
suffix:semicolon
r_int
r_char
op_star
id|rawp
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|eth
op_assign
id|skb-&gt;mac.ethernet
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eth-&gt;h_dest
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;broadcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
(brace
id|skb-&gt;pkt_type
op_assign
id|PACKET_BROADCAST
suffix:semicolon
)brace
r_else
id|skb-&gt;pkt_type
op_assign
id|PACKET_MULTICAST
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;This ALLMULTI check should be redundant by 1.4&n;&t; *&t;so don&squot;t forget to remove it.&n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|eth-&gt;h_proto
)paren
op_ge
l_int|1536
)paren
r_return
id|eth-&gt;h_proto
suffix:semicolon
id|rawp
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is a magic hack to spot IPX packets. Older Novell breaks&n;&t; *&t;the protocol design and runs IPX over 802.3 without an 802.2 LLC&n;&t; *&t;layer. We look for FFFF which isn&squot;t a used 802.2 SSAP/DSAP. This&n;&t; *&t;won&squot;t work for fault tolerant netware but does for the rest.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xFFFF
)paren
r_return
id|htons
c_func
(paren
id|ETH_P_802_3
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Real 802.2 LLC&n;&t; */
r_return
id|htons
c_func
(paren
id|ETH_P_802_2
)paren
suffix:semicolon
)brace
multiline_comment|/* PLIP_RECEIVE_PACKET --- receive a packet */
r_static
r_int
DECL|function|plip_receive_packet
id|plip_receive_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
)paren
(brace
r_int
r_int
id|nibble_timeout
op_assign
id|nl-&gt;nibble
suffix:semicolon
r_int
r_char
op_star
id|lbuf
suffix:semicolon
r_switch
c_cond
(paren
id|rcv-&gt;state
)paren
(brace
r_case
id|PLIP_PK_TRIGGER
suffix:colon
id|DISABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t need to synchronize irq, as we can safely ignore it */
id|disable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|write_data
(paren
id|dev
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* send ACK */
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: receive start&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|rcv-&gt;state
op_assign
id|PLIP_PK_LENGTH_LSB
suffix:semicolon
id|rcv-&gt;nibble
op_assign
id|PLIP_NB_BEGIN
suffix:semicolon
r_case
id|PLIP_PK_LENGTH_LSB
suffix:colon
r_if
c_cond
(paren
id|snd-&gt;state
op_ne
id|PLIP_PK_DONE
)paren
(brace
r_if
c_cond
(paren
id|plip_receive
c_func
(paren
id|nl-&gt;trigger
comma
id|dev
comma
op_amp
id|rcv-&gt;nibble
comma
op_amp
id|rcv-&gt;length.b.lsb
)paren
)paren
(brace
multiline_comment|/* collision, here dev-&gt;tbusy == 1 */
id|rcv-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
id|nl-&gt;is_deferred
op_assign
l_int|1
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_SEND
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;deferred
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
id|enable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|ENABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|plip_receive
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|rcv-&gt;nibble
comma
op_amp
id|rcv-&gt;length.b.lsb
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
)brace
id|rcv-&gt;state
op_assign
id|PLIP_PK_LENGTH_MSB
suffix:semicolon
r_case
id|PLIP_PK_LENGTH_MSB
suffix:colon
r_if
c_cond
(paren
id|plip_receive
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|rcv-&gt;nibble
comma
op_amp
id|rcv-&gt;length.b.msb
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|rcv-&gt;length.h
OG
id|dev-&gt;mtu
op_plus
id|dev-&gt;hard_header_len
op_logical_or
id|rcv-&gt;length.h
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: bogus packet size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rcv-&gt;length.h
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
multiline_comment|/* Malloc up new buffer. */
id|rcv-&gt;skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|rcv-&gt;length.h
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rcv-&gt;skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Memory squeeze.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|rcv-&gt;skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align IP on 16 byte boundaries */
id|skb_put
c_func
(paren
id|rcv-&gt;skb
comma
id|rcv-&gt;length.h
)paren
suffix:semicolon
id|rcv-&gt;skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|rcv-&gt;state
op_assign
id|PLIP_PK_DATA
suffix:semicolon
id|rcv-&gt;byte
op_assign
l_int|0
suffix:semicolon
id|rcv-&gt;checksum
op_assign
l_int|0
suffix:semicolon
r_case
id|PLIP_PK_DATA
suffix:colon
id|lbuf
op_assign
id|rcv-&gt;skb-&gt;data
suffix:semicolon
r_do
r_if
c_cond
(paren
id|plip_receive
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|rcv-&gt;nibble
comma
op_amp
id|lbuf
(braket
id|rcv-&gt;byte
)braket
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|rcv-&gt;byte
OL
id|rcv-&gt;length.h
)paren
suffix:semicolon
r_do
id|rcv-&gt;checksum
op_add_assign
id|lbuf
(braket
op_decrement
id|rcv-&gt;byte
)braket
suffix:semicolon
r_while
c_loop
(paren
id|rcv-&gt;byte
)paren
suffix:semicolon
id|rcv-&gt;state
op_assign
id|PLIP_PK_CHECKSUM
suffix:semicolon
r_case
id|PLIP_PK_CHECKSUM
suffix:colon
r_if
c_cond
(paren
id|plip_receive
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|rcv-&gt;nibble
comma
op_amp
id|rcv-&gt;data
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|rcv-&gt;data
op_ne
id|rcv-&gt;checksum
)paren
(brace
id|nl-&gt;enet_stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: checksum error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
id|rcv-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
r_case
id|PLIP_PK_DONE
suffix:colon
multiline_comment|/* Inform the upper layer for the arrival of a packet. */
id|rcv-&gt;skb-&gt;protocol
op_assign
id|plip_type_trans
c_func
(paren
id|rcv-&gt;skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|rcv-&gt;skb
)paren
suffix:semicolon
id|nl-&gt;enet_stats.rx_bytes
op_add_assign
id|rcv-&gt;length.h
suffix:semicolon
id|nl-&gt;enet_stats.rx_packets
op_increment
suffix:semicolon
id|rcv-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: receive end&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Close the connection. */
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd-&gt;state
op_ne
id|PLIP_PK_DONE
)paren
(brace
id|nl-&gt;connection
op_assign
id|PLIP_CN_SEND
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;immediate
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
id|enable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|ENABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
r_else
(brace
id|nl-&gt;connection
op_assign
id|PLIP_CN_NONE
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
id|enable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|ENABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
)brace
r_return
id|OK
suffix:semicolon
)brace
multiline_comment|/* PLIP_SEND --- send a byte (two nibbles)&n;   Returns OK on success, TIMEOUT when timeout    */
r_inline
r_static
r_int
DECL|function|plip_send
id|plip_send
c_func
(paren
r_int
r_int
id|nibble_timeout
comma
r_struct
id|net_device
op_star
id|dev
comma
r_enum
id|plip_nibble_state
op_star
id|ns_p
comma
r_int
r_char
id|data
)paren
(brace
r_int
r_char
id|c0
suffix:semicolon
r_int
r_int
id|cx
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|ns_p
)paren
(brace
r_case
id|PLIP_NB_BEGIN
suffix:colon
id|write_data
(paren
id|dev
comma
id|data
op_amp
l_int|0x0f
)paren
suffix:semicolon
op_star
id|ns_p
op_assign
id|PLIP_NB_1
suffix:semicolon
r_case
id|PLIP_NB_1
suffix:colon
id|write_data
(paren
id|dev
comma
l_int|0x10
op_or
(paren
id|data
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
id|cx
op_assign
id|nibble_timeout
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c0
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cx
op_eq
l_int|0
)paren
r_return
id|TIMEOUT
suffix:semicolon
id|udelay
c_func
(paren
id|PLIP_DELAY_UNIT
)paren
suffix:semicolon
)brace
id|write_data
(paren
id|dev
comma
l_int|0x10
op_or
(paren
id|data
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
op_star
id|ns_p
op_assign
id|PLIP_NB_2
suffix:semicolon
r_case
id|PLIP_NB_2
suffix:colon
id|write_data
(paren
id|dev
comma
(paren
id|data
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|cx
op_assign
id|nibble_timeout
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c0
op_amp
l_int|0x80
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cx
op_eq
l_int|0
)paren
r_return
id|TIMEOUT
suffix:semicolon
id|udelay
c_func
(paren
id|PLIP_DELAY_UNIT
)paren
suffix:semicolon
)brace
op_star
id|ns_p
op_assign
id|PLIP_NB_BEGIN
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
r_return
id|OK
suffix:semicolon
)brace
multiline_comment|/* PLIP_SEND_PACKET --- send a packet */
r_static
r_int
DECL|function|plip_send_packet
id|plip_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
)paren
(brace
r_int
r_int
id|nibble_timeout
op_assign
id|nl-&gt;nibble
suffix:semicolon
r_int
r_char
op_star
id|lbuf
suffix:semicolon
r_int
r_char
id|c0
suffix:semicolon
r_int
r_int
id|cx
suffix:semicolon
r_if
c_cond
(paren
id|snd-&gt;skb
op_eq
l_int|NULL
op_logical_or
(paren
id|lbuf
op_assign
id|snd-&gt;skb-&gt;data
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: send skb lost&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
id|snd-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|snd-&gt;state
)paren
(brace
r_case
id|PLIP_PK_TRIGGER
suffix:colon
r_if
c_cond
(paren
(paren
id|read_status
c_func
(paren
id|dev
)paren
op_amp
l_int|0xf8
)paren
op_ne
l_int|0x80
)paren
r_return
id|HS_TIMEOUT
suffix:semicolon
multiline_comment|/* Trigger remote rx interrupt. */
id|write_data
(paren
id|dev
comma
l_int|0x08
)paren
suffix:semicolon
id|cx
op_assign
id|nl-&gt;trigger
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|udelay
c_func
(paren
id|PLIP_DELAY_UNIT
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;connection
op_eq
id|PLIP_CN_RECEIVE
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Interrupted. */
id|nl-&gt;enet_stats.collisions
op_increment
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c0
op_amp
l_int|0x08
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
id|DISABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;connection
op_eq
id|PLIP_CN_RECEIVE
)paren
(brace
multiline_comment|/* Interrupted.&n;&t;&t;&t;&t;&t;   We don&squot;t need to enable irq,&n;&t;&t;&t;&t;&t;   as it is soon disabled.    */
multiline_comment|/* Yes, we do. New variant of&n;&t;&t;&t;&t;&t;   {enable,disable}_irq *counts*&n;&t;&t;&t;&t;&t;   them.  -- AV  */
id|ENABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|nl-&gt;enet_stats.collisions
op_increment
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
id|disable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: send start&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_LENGTH_LSB
suffix:semicolon
id|snd-&gt;nibble
op_assign
id|PLIP_NB_BEGIN
suffix:semicolon
id|nl-&gt;timeout_count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cx
op_eq
l_int|0
)paren
(brace
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
r_return
id|HS_TIMEOUT
suffix:semicolon
)brace
)brace
r_case
id|PLIP_PK_LENGTH_LSB
suffix:colon
r_if
c_cond
(paren
id|plip_send
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|snd-&gt;nibble
comma
id|snd-&gt;length.b.lsb
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_LENGTH_MSB
suffix:semicolon
r_case
id|PLIP_PK_LENGTH_MSB
suffix:colon
r_if
c_cond
(paren
id|plip_send
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|snd-&gt;nibble
comma
id|snd-&gt;length.b.msb
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_DATA
suffix:semicolon
id|snd-&gt;byte
op_assign
l_int|0
suffix:semicolon
id|snd-&gt;checksum
op_assign
l_int|0
suffix:semicolon
r_case
id|PLIP_PK_DATA
suffix:colon
r_do
r_if
c_cond
(paren
id|plip_send
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|snd-&gt;nibble
comma
id|lbuf
(braket
id|snd-&gt;byte
)braket
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|snd-&gt;byte
OL
id|snd-&gt;length.h
)paren
suffix:semicolon
r_do
id|snd-&gt;checksum
op_add_assign
id|lbuf
(braket
op_decrement
id|snd-&gt;byte
)braket
suffix:semicolon
r_while
c_loop
(paren
id|snd-&gt;byte
)paren
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_CHECKSUM
suffix:semicolon
r_case
id|PLIP_PK_CHECKSUM
suffix:colon
r_if
c_cond
(paren
id|plip_send
c_func
(paren
id|nibble_timeout
comma
id|dev
comma
op_amp
id|snd-&gt;nibble
comma
id|snd-&gt;checksum
)paren
)paren
r_return
id|TIMEOUT
suffix:semicolon
id|nl-&gt;enet_stats.tx_bytes
op_add_assign
id|snd-&gt;skb-&gt;len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|snd-&gt;skb
)paren
suffix:semicolon
id|nl-&gt;enet_stats.tx_packets
op_increment
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
r_case
id|PLIP_PK_DONE
suffix:colon
multiline_comment|/* Close the connection */
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
id|snd-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: send end&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_CLOSING
suffix:semicolon
id|nl-&gt;is_deferred
op_assign
l_int|1
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;deferred
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
id|enable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|ENABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
r_return
id|OK
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_connection_close
id|plip_connection_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;connection
op_eq
id|PLIP_CN_CLOSING
)paren
(brace
id|nl-&gt;connection
op_assign
id|PLIP_CN_NONE
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;should_relinquish
)paren
(brace
id|nl-&gt;should_relinquish
op_assign
id|nl-&gt;port_owner
op_assign
l_int|0
suffix:semicolon
id|parport_release
c_func
(paren
id|nl-&gt;pardev
)paren
suffix:semicolon
)brace
r_return
id|OK
suffix:semicolon
)brace
multiline_comment|/* PLIP_ERROR --- wait till other end settled */
r_static
r_int
DECL|function|plip_error
id|plip_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_local
op_star
id|nl
comma
r_struct
id|plip_local
op_star
id|snd
comma
r_struct
id|plip_local
op_star
id|rcv
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|status
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0xf8
)paren
op_eq
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: reset interface.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_NONE
suffix:semicolon
id|nl-&gt;should_relinquish
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
id|enable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
id|ENABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|nl-&gt;is_deferred
op_assign
l_int|1
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;deferred
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
r_return
id|OK
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Handle the parallel port interrupts. */
r_static
r_void
DECL|function|plip_interrupt
id|plip_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|nl
suffix:semicolon
r_struct
id|plip_local
op_star
id|rcv
suffix:semicolon
r_int
r_char
id|c0
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;plip_interrupt: irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|rcv
op_assign
op_amp
id|nl-&gt;rcv_data
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
id|c0
op_assign
id|read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c0
op_amp
l_int|0xf8
)paren
op_ne
l_int|0xc0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|net_debug
OG
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: spurious interrupt&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: interrupt.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nl-&gt;connection
)paren
(brace
r_case
id|PLIP_CN_CLOSING
suffix:colon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
r_case
id|PLIP_CN_NONE
suffix:colon
r_case
id|PLIP_CN_SEND
suffix:colon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|rcv-&gt;state
op_assign
id|PLIP_PK_TRIGGER
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_RECEIVE
suffix:semicolon
id|nl-&gt;timeout_count
op_assign
l_int|0
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;immediate
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PLIP_CN_RECEIVE
suffix:colon
multiline_comment|/* May occur because there is race condition&n;&t;&t;   around test and set of dev-&gt;interrupt.&n;&t;&t;   Ignore this interrupt. */
r_break
suffix:semicolon
r_case
id|PLIP_CN_ERROR
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: receive interrupt in error state&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|plip_tx_packet
id|plip_tx_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|plip_local
op_star
id|snd
op_assign
op_amp
id|nl-&gt;snd_data
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We may need to grab the bus */
r_if
c_cond
(paren
op_logical_neg
id|nl-&gt;port_owner
)paren
(brace
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|nl-&gt;pardev
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|nl-&gt;port_owner
op_assign
l_int|1
suffix:semicolon
)brace
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|dev-&gt;mtu
op_plus
id|dev-&gt;hard_header_len
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: packet too big, %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: send request&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|snd-&gt;skb
op_assign
id|skb
suffix:semicolon
id|snd-&gt;length.h
op_assign
id|skb-&gt;len
suffix:semicolon
id|snd-&gt;state
op_assign
id|PLIP_PK_TRIGGER
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;connection
op_eq
id|PLIP_CN_NONE
)paren
(brace
id|nl-&gt;connection
op_assign
id|PLIP_CN_SEND
suffix:semicolon
id|nl-&gt;timeout_count
op_assign
l_int|0
suffix:semicolon
)brace
id|queue_task
c_func
(paren
op_amp
id|nl-&gt;immediate
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|nl-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|plip_rewrite_address
id|plip_rewrite_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethhdr
op_star
id|eth
)paren
(brace
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|in_dev
op_assign
id|dev-&gt;ip_ptr
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Any address will do - we take the first */
r_struct
id|in_ifaddr
op_star
id|ifa
op_assign
id|in_dev-&gt;ifa_list
suffix:semicolon
r_if
c_cond
(paren
id|ifa
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|eth-&gt;h_source
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
id|memset
c_func
(paren
id|eth-&gt;h_dest
comma
l_int|0xfc
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eth-&gt;h_dest
op_plus
l_int|2
comma
op_amp
id|ifa-&gt;ifa_address
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|plip_hard_header
id|plip_hard_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nl
op_member_access_from_pointer
id|orig_hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|type
comma
id|daddr
comma
id|saddr
comma
id|len
)paren
)paren
op_ge
l_int|0
)paren
id|plip_rewrite_address
(paren
id|dev
comma
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb-&gt;data
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|plip_hard_header_cache
r_int
id|plip_hard_header_cache
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|hh_cache
op_star
id|hh
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|neigh-&gt;dev-&gt;priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nl
op_member_access_from_pointer
id|orig_hard_header_cache
c_func
(paren
id|neigh
comma
id|hh
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
(paren
(paren
(paren
id|u8
op_star
)paren
id|hh-&gt;hh_data
)paren
op_plus
l_int|2
)paren
suffix:semicolon
id|plip_rewrite_address
(paren
id|neigh-&gt;dev
comma
id|eth
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine gets exclusive access to the parallel port by allocating&n;   its IRQ line.&n; */
r_static
r_int
DECL|function|plip_open
id|plip_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
multiline_comment|/* Grab the port */
r_if
c_cond
(paren
op_logical_neg
id|nl-&gt;port_owner
)paren
(brace
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|nl-&gt;pardev
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|nl-&gt;port_owner
op_assign
l_int|1
suffix:semicolon
)brace
id|nl-&gt;should_relinquish
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the data port. */
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Enable rx interrupt. */
id|enable_parport_interrupts
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
op_minus
l_int|1
)paren
(brace
id|atomic_set
(paren
op_amp
id|nl-&gt;kill_timer
comma
l_int|0
)paren
suffix:semicolon
id|queue_task
(paren
op_amp
id|nl-&gt;timer
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the state machine. */
id|nl-&gt;rcv_data.state
op_assign
id|nl-&gt;snd_data.state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
id|nl-&gt;rcv_data.skb
op_assign
id|nl-&gt;snd_data.skb
op_assign
l_int|NULL
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_NONE
suffix:semicolon
id|nl-&gt;is_deferred
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the MAC-level header.&n;&t;   We used to abuse dev-&gt;broadcast to store the point-to-point&n;&t;   MAC address, but we no longer do it. Instead, we fetch the&n;&t;   interface address whenever it is needed, which is cheap enough&n;&t;   because we use the hh_cache. Actually, abusing dev-&gt;broadcast&n;&t;   didn&squot;t work, because when using plip_open the point-to-point&n;&t;   address isn&squot;t yet known.&n;&t;   PLIP doesn&squot;t have a real MAC address, but we need it to be&n;&t;   DOS compatible, and to properly support taps (otherwise,&n;&t;   when the device address isn&squot;t identical to the address of a&n;&t;   received frame, the kernel incorrectly drops it).             */
r_if
c_cond
(paren
(paren
id|in_dev
op_assign
id|dev-&gt;ip_ptr
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Any address will do - we take the first. We already&n;&t;&t;   have the first two bytes filled with 0xfc, from&n;&t;&t;   plip_init_dev(). */
r_struct
id|in_ifaddr
op_star
id|ifa
op_assign
id|in_dev-&gt;ifa_list
suffix:semicolon
r_if
c_cond
(paren
id|ifa
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
op_plus
l_int|2
comma
op_amp
id|ifa-&gt;ifa_local
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to plip_open (). */
r_static
r_int
DECL|function|plip_close
id|plip_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|plip_local
op_star
id|snd
op_assign
op_amp
id|nl-&gt;snd_data
suffix:semicolon
r_struct
id|plip_local
op_star
id|rcv
op_assign
op_amp
id|nl-&gt;rcv_data
suffix:semicolon
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
id|DISABLE
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
op_minus
l_int|1
)paren
(brace
id|init_MUTEX_LOCKED
(paren
op_amp
id|nl-&gt;killed_timer_sem
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|nl-&gt;kill_timer
comma
l_int|1
)paren
suffix:semicolon
id|down
(paren
op_amp
id|nl-&gt;killed_timer_sem
)paren
suffix:semicolon
)brace
macro_line|#ifdef NOTDEF
id|outb
c_func
(paren
l_int|0x00
comma
id|PAR_DATA
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|nl-&gt;is_deferred
op_assign
l_int|0
suffix:semicolon
id|nl-&gt;connection
op_assign
id|PLIP_CN_NONE
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;port_owner
)paren
(brace
id|parport_release
c_func
(paren
id|nl-&gt;pardev
)paren
suffix:semicolon
id|nl-&gt;port_owner
op_assign
l_int|0
suffix:semicolon
)brace
id|snd-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
r_if
c_cond
(paren
id|snd-&gt;skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|snd-&gt;skb
)paren
suffix:semicolon
id|snd-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|rcv-&gt;state
op_assign
id|PLIP_PK_DONE
suffix:semicolon
r_if
c_cond
(paren
id|rcv-&gt;skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|rcv-&gt;skb
)paren
suffix:semicolon
id|rcv-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef NOTDEF
multiline_comment|/* Reset. */
id|outb
c_func
(paren
l_int|0x00
comma
id|PAR_CONTROL
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_preempt
id|plip_preempt
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|handle
suffix:semicolon
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Stand our ground if a datagram is on the wire */
r_if
c_cond
(paren
id|nl-&gt;connection
op_ne
id|PLIP_CN_NONE
)paren
(brace
id|nl-&gt;should_relinquish
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|nl-&gt;port_owner
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remember that we released the bus */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|plip_wakeup
id|plip_wakeup
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|handle
suffix:semicolon
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;port_owner
)paren
(brace
multiline_comment|/* Why are we being woken up? */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: why am I being woken up?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parport_claim
c_func
(paren
id|nl-&gt;pardev
)paren
)paren
multiline_comment|/* bus_owner is already set (but why?) */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: I&squot;m broken.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
multiline_comment|/* Don&squot;t need the port when the interface is down */
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parport_claim
c_func
(paren
id|nl-&gt;pardev
)paren
)paren
(brace
id|nl-&gt;port_owner
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Clear the data port. */
id|write_data
(paren
id|dev
comma
l_int|0x00
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_struct
id|net_device_stats
op_star
DECL|function|plip_get_stats
id|plip_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|r
op_assign
op_amp
id|nl-&gt;enet_stats
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_ioctl
id|plip_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|plipconf
op_star
id|pc
op_assign
(paren
r_struct
id|plipconf
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
r_switch
c_cond
(paren
id|pc-&gt;pcmd
)paren
(brace
r_case
id|PLIP_GET_TIMEOUT
suffix:colon
id|pc-&gt;trigger
op_assign
id|nl-&gt;trigger
suffix:semicolon
id|pc-&gt;nibble
op_assign
id|nl-&gt;nibble
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PLIP_SET_TIMEOUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|nl-&gt;trigger
op_assign
id|pc-&gt;trigger
suffix:semicolon
id|nl-&gt;nibble
op_assign
id|pc-&gt;nibble
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
DECL|variable|parport
r_static
r_int
id|parport
(braket
id|PLIP_MAX
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PLIP_MAX
op_minus
l_int|1
)braket
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|timid
r_static
r_int
id|timid
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|parport
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PLIP_MAX
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|timid
comma
l_string|&quot;1i&quot;
)paren
suffix:semicolon
DECL|variable|dev_plip
r_static
r_struct
id|net_device
op_star
id|dev_plip
(braket
id|PLIP_MAX
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
r_static
r_int
r_inline
DECL|function|plip_searchfor
id|plip_searchfor
c_func
(paren
r_int
id|list
(braket
)braket
comma
r_int
id|a
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PLIP_MAX
op_logical_and
id|list
(braket
id|i
)braket
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|list
(braket
id|i
)braket
op_eq
id|a
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* plip_attach() is called (by the parport code) when a port is&n; * available to use. */
DECL|function|plip_attach
r_static
r_void
id|plip_attach
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_static
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|parport
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
op_logical_and
(paren
op_logical_neg
id|timid
op_logical_or
op_logical_neg
id|port-&gt;devices
)paren
)paren
op_logical_or
id|plip_searchfor
c_func
(paren
id|parport
comma
id|port-&gt;number
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|PLIP_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;plip: too many devices&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev_plip
(braket
id|i
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_plip
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;plip: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev_plip
(braket
id|i
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev_plip
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
l_string|&quot;plip%d&quot;
comma
id|i
)paren
suffix:semicolon
id|dev_plip
(braket
id|i
)braket
op_member_access_from_pointer
id|priv
op_assign
id|port
suffix:semicolon
r_if
c_cond
(paren
id|plip_init_dev
c_func
(paren
id|dev_plip
(braket
id|i
)braket
comma
id|port
)paren
op_logical_or
id|register_netdev
c_func
(paren
id|dev_plip
(braket
id|i
)braket
)paren
)paren
(brace
id|kfree
c_func
(paren
id|dev_plip
(braket
id|i
)braket
)paren
suffix:semicolon
id|dev_plip
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* plip_detach() is called (by the parport code) when a port is&n; * no longer available to use. */
DECL|function|plip_detach
r_static
r_void
id|plip_detach
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
multiline_comment|/* Nothing to do */
)brace
DECL|variable|plip_driver
r_static
r_struct
id|parport_driver
id|plip_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;plip&quot;
comma
id|attach
suffix:colon
id|plip_attach
comma
id|detach
suffix:colon
id|plip_detach
)brace
suffix:semicolon
DECL|function|plip_cleanup_module
r_static
r_void
id|__exit
id|plip_cleanup_module
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|parport_unregister_driver
(paren
op_amp
id|plip_driver
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PLIP_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev_plip
(braket
id|i
)braket
)paren
(brace
r_struct
id|net_local
op_star
id|nl
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev_plip
(braket
id|i
)braket
op_member_access_from_pointer
id|priv
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev_plip
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nl-&gt;port_owner
)paren
id|parport_release
c_func
(paren
id|nl-&gt;pardev
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|nl-&gt;pardev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev_plip
(braket
id|i
)braket
op_member_access_from_pointer
id|priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev_plip
(braket
id|i
)braket
)paren
suffix:semicolon
id|dev_plip
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifndef MODULE
DECL|variable|parport_ptr
r_static
r_int
id|parport_ptr
op_assign
l_int|0
suffix:semicolon
DECL|function|plip_setup
r_static
r_int
id|__init
id|plip_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|4
)braket
suffix:semicolon
id|str
op_assign
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
multiline_comment|/* Ugh. */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;parport&quot;
comma
l_int|7
)paren
)paren
(brace
r_int
id|n
op_assign
id|simple_strtoul
c_func
(paren
id|str
op_plus
l_int|7
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_ptr
OL
id|PLIP_MAX
)paren
id|parport
(braket
id|parport_ptr
op_increment
)braket
op_assign
id|n
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;plip: too many ports, %s ignored.&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;timid&quot;
)paren
)paren
(brace
id|timid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_or
id|ints
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* disable driver on &quot;plip=&quot; or &quot;plip=0&quot; */
id|parport
(braket
l_int|0
)braket
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;warning: &squot;plip=0x%x&squot; ignored&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;plip=&quot;
comma
id|plip_setup
)paren
suffix:semicolon
macro_line|#endif /* !MODULE */
DECL|function|plip_init
r_static
r_int
id|__init
id|plip_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
op_eq
op_minus
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
op_ne
op_minus
l_int|1
op_logical_and
id|timid
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;plip: warning, ignoring `timid&squot; since specific ports given.&bslash;n&quot;
)paren
suffix:semicolon
id|timid
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parport_register_driver
(paren
op_amp
id|plip_driver
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;plip: couldn&squot;t register driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|plip_init
id|module_init
c_func
(paren
id|plip_init
)paren
suffix:semicolon
DECL|variable|plip_cleanup_module
id|module_exit
c_func
(paren
id|plip_cleanup_module
)paren
suffix:semicolon
multiline_comment|/*&n; * Local variables:&n; * compile-command: &quot;gcc -DMODULE -DMODVERSIONS -D__KERNEL__ -Wall -Wstrict-prototypes -O2 -g -fomit-frame-pointer -pipe -c plip.c&quot;&n; * End:&n; */
eof
