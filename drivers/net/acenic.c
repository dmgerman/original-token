multiline_comment|/*&n; * acenic.c: Linux driver for the Alteon AceNIC Gigabit Ethernet card&n; *           and other Tigon based cards.&n; *&n; * Copyright 1998, 1999 by Jes Sorensen, &lt;Jes.Sorensen@cern.ch&gt;.&n; *&n; * Thanks to Alteon and 3Com for providing hardware and documentation&n; * enabling me to write this driver.&n; *&n; * A mailing list for discussing the use of this driver has been&n; * setup, please subscribe to the lists if you have any questions&n; * about the driver. Send mail to linux-acenic-help@sunsite.auc.dk to&n; * see how to subscribe.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * Additional work by Pete Wyckoff &lt;wyckoff@ca.sandia.gov&gt; for initial&n; * Alpha and trace dump support. The trace dump support has not been&n; * integrated yet however.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#ifdef ETHTOOL
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#endif
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_ACENIC_OMIT_TIGON_I
DECL|macro|ACE_IS_TIGON_I
mdefine_line|#define ACE_IS_TIGON_I(ap)&t;0
macro_line|#else
DECL|macro|ACE_IS_TIGON_I
mdefine_line|#define ACE_IS_TIGON_I(ap)&t;(ap-&gt;version == 1)
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_ALTEON
DECL|macro|PCI_VENDOR_ID_ALTEON
mdefine_line|#define PCI_VENDOR_ID_ALTEON&t;&t;0x12ae&t;
DECL|macro|PCI_DEVICE_ID_ALTEON_ACENIC
mdefine_line|#define PCI_DEVICE_ID_ALTEON_ACENIC&t;0x0001
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_3COM_3C985
DECL|macro|PCI_DEVICE_ID_3COM_3C985
mdefine_line|#define PCI_DEVICE_ID_3COM_3C985&t;0x0001
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_NETGEAR
DECL|macro|PCI_VENDOR_ID_NETGEAR
mdefine_line|#define PCI_VENDOR_ID_NETGEAR&t;&t;0x1385
DECL|macro|PCI_DEVICE_ID_NETGEAR_GA620
mdefine_line|#define PCI_DEVICE_ID_NETGEAR_GA620&t;0x620a
macro_line|#endif
multiline_comment|/*&n; * They used the DEC vendor ID by mistake&n; */
macro_line|#ifndef PCI_DEVICE_ID_FARALLON_PN9000SX
DECL|macro|PCI_DEVICE_ID_FARALLON_PN9000SX
mdefine_line|#define PCI_DEVICE_ID_FARALLON_PN9000SX 0x1a
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_SGI
DECL|macro|PCI_VENDOR_ID_SGI
mdefine_line|#define PCI_VENDOR_ID_SGI             0x10a9
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_SGI_ACENIC
DECL|macro|PCI_DEVICE_ID_SGI_ACENIC
mdefine_line|#define PCI_DEVICE_ID_SGI_ACENIC      0x0009
macro_line|#endif
macro_line|#ifndef wmb
DECL|macro|wmb
mdefine_line|#define wmb()&t;mb()
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02030e)
DECL|macro|net_device
mdefine_line|#define net_device device
macro_line|#endif
macro_line|#include &quot;acenic.h&quot;
multiline_comment|/*&n; * These must be defined before the firmware is included.&n; */
DECL|macro|MAX_TEXT_LEN
mdefine_line|#define MAX_TEXT_LEN&t;96*1024
DECL|macro|MAX_RODATA_LEN
mdefine_line|#define MAX_RODATA_LEN&t;8*1024
DECL|macro|MAX_DATA_LEN
mdefine_line|#define MAX_DATA_LEN&t;2*1024
macro_line|#include &quot;acenic_firmware.h&quot;
multiline_comment|/*&n; * This driver currently supports Tigon I and Tigon II based cards&n; * including the Alteon AceNIC and the 3Com 3C985. The driver should&n; * also work on the NetGear GA620, however I have not been able to&n; * test that myself.&n; *&n; * This card is really neat, it supports receive hardware checksumming&n; * and jumbo frames (up to 9000 bytes) and does a lot of work in the&n; * firmware. Also the programming interface is quite neat, except for&n; * the parts dealing with the i2c eeprom on the card ;-)&n; *&n; * Using jumbo frames:&n; *&n; * To enable jumbo frames, simply specify an mtu between 1500 and 9000&n; * bytes to ifconfig. Jumbo frames can be enabled or disabled at any time&n; * by running `ifconfig eth&lt;X&gt; mtu &lt;MTU&gt;&squot; with &lt;X&gt; being the Ethernet&n; * interface number and &lt;MTU&gt; being the MTU value.&n; *&n; * Module parameters:&n; *&n; * When compiled as a loadable module, the driver allows for a number&n; * of module parameters to be specified. The driver supports the&n; * following module parameters:&n; *&n; *  trace=&lt;val&gt; - Firmware trace level. This requires special traced&n; *                firmware to replace the firmware supplied with&n; *                the driver - for debugging purposes only.&n; *&n; *  link=&lt;val&gt;  - Link state. Normally you want to use the default link&n; *                parameters set by the driver. This can be used to&n; *                override these in case your switch doesn&squot;t negotiate&n; *                the link properly. Valid values are:&n; *         0x0001 - Force half duplex link.&n; *         0x0002 - Do not negotiate line speed with the other end.&n; *         0x0010 - 10Mbit/sec link.&n; *         0x0020 - 100Mbit/sec link.&n; *         0x0040 - 1000Mbit/sec link.&n; *         0x0100 - Do not negotiate flow control.&n; *         0x0200 - Enable RX flow control Y&n; *         0x0400 - Enable TX flow control Y (Tigon II NICs only).&n; *                Default value is 0x0270, ie. enable link+flow&n; *                control negotiation. Negotiating the highest&n; *                possible link speed with RX flow control enabled.&n; *&n; *                When disabling link speed negotiation, only one link&n; *                speed is allowed to be specified!&n; *&n; *  tx_coal_tick=&lt;val&gt; - number of coalescing clock ticks (us) allowed&n; *                to wait for more packets to arive before&n; *                interrupting the host, from the time the first&n; *                packet arrives.&n; *&n; *  rx_coal_tick=&lt;val&gt; - number of coalescing clock ticks (us) allowed&n; *                to wait for more packets to arive in the transmit ring,&n; *                before interrupting the host, after transmitting the&n; *                first packet in the ring.&n; *&n; *  max_tx_desc=&lt;val&gt; - maximum number of transmit descriptors&n; *                (packets) transmitted before interrupting the host.&n; *&n; *  max_rx_desc=&lt;val&gt; - maximum number of receive descriptors&n; *                (packets) received before interrupting the host.&n; *&n; *  tx_ratio=&lt;val&gt; - 7 bit value (0 - 63) specifying the split in 64th&n; *                increments of the NIC&squot;s on board memory to be used for&n; *                transmit and receive buffers. For the 1MB NIC app. 800KB&n; *                is available, on the 1/2MB NIC app. 300KB is available.&n; *                68KB will always be available as a minimum for both&n; *                directions. The default value is a 50/50 split.&n; *  dis_pci_mem_inval=&lt;val&gt; - disable PCI memory write and invalidate&n; *                operations, default (1) is to always disable this as&n; *                that is what Alteon does on NT. I have not been able&n; *                to measure any real performance differences with&n; *                this on my systems. Set &lt;val&gt;=0 if you want to&n; *                enable these operations.&n; *&n; * If you use more than one NIC, specify the parameters for the&n; * individual NICs with a comma, ie. trace=0,0x00001fff,0 you want to&n; * run tracing on NIC #2 but not on NIC #1 and #3.&n; *&n; * TODO:&n; *&n; * - Proper multicast support.&n; * - NIC dump support.&n; * - More tuning parameters.&n; *&n; * The mini ring is not used under Linux and I am not sure it makes sense&n; * to actually use it.&n; *&n; * New interrupt handler strategy:&n; *&n; * The old interrupt handler worked using the traditional method of&n; * replacing an skbuff with a new one when a packet arrives. However&n; * the rx rings do not need to contain a static number of buffer&n; * descriptors, thus it makes sense to move the memory allocation out&n; * of the main interrupt handler and do it in a bottom half handler&n; * and only allocate new buffers when the number of buffers in the&n; * ring is below a certain threshold. In order to avoid starving the&n; * NIC under heavy load it is however necessary to force allocation&n; * when hitting a minimum threshold. The strategy for alloction is as&n; * follows:&n; *&n; *     RX_LOW_BUF_THRES    - allocate buffers in the bottom half&n; *     RX_PANIC_LOW_THRES  - we are very low on buffers, allocate&n; *                           the buffers in the interrupt handler&n; *     RX_RING_THRES       - maximum number of buffers in the rx ring&n; *     RX_MINI_THRES       - maximum number of buffers in the mini ring&n; *     RX_JUMBO_THRES      - maximum number of buffers in the jumbo ring&n; *&n; * One advantagous side effect of this allocation approach is that the&n; * entire rx processing can be done without holding any spin lock&n; * since the rx rings and registers are totally independant of the tx&n; * ring and its registers.  This of course includes the kmalloc&squot;s of&n; * new skb&squot;s. Thus start_xmit can run in parallel with rx processing&n; * and the memory allocation on SMP systems.&n; *&n; * Note that running the skb reallocation in a bottom half opens up&n; * another can of races which needs to be handled properly. In&n; * particular it can happen that the interrupt handler tries to run&n; * the reallocation while the bottom half is either running on another&n; * CPU or was interrupted on the same CPU. To get around this the&n; * driver uses bitops to prevent the reallocation routines from being&n; * reentered.&n; *&n; * TX handling can also be done without holding any spin lock, wheee&n; * this is fun! since tx_ret_csm is only written to by the interrupt&n; * handler. The case to be aware of is when shutting down the device&n; * and cleaning up where it is necessary to make sure that&n; * start_xmit() is not running while this is happening. Well DaveM&n; * informs me that this case is already protected against ... bye bye&n; * Mr. Spin Lock, it was nice to know you.&n; *&n; * TX interrupts are now partly disabled so the NIC will only generate&n; * TX interrupts for the number of coal ticks, not for the number of&n; * TX packets in the queue. This should reduce the number of TX only,&n; * ie. when no RX processing is done, interrupts seen.&n; */
multiline_comment|/*&n; * Threshold values for RX buffer allocation - the low water marks for&n; * when to start refilling the rings are set to 75% of the ring&n; * sizes. It seems to make sense to refill the rings entirely from the&n; * intrrupt handler once it gets below the panic threshold, that way&n; * we don&squot;t risk that the refilling is moved to another CPU when the&n; * one running the interrupt handler just got the slab code hot in its&n; * cache.&n; */
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;72
DECL|macro|RX_MINI_SIZE
mdefine_line|#define RX_MINI_SIZE&t;&t;64
DECL|macro|RX_JUMBO_SIZE
mdefine_line|#define RX_JUMBO_SIZE&t;&t;48
DECL|macro|RX_PANIC_STD_THRES
mdefine_line|#define RX_PANIC_STD_THRES&t;16
DECL|macro|RX_PANIC_STD_REFILL
mdefine_line|#define RX_PANIC_STD_REFILL&t;(3*RX_PANIC_STD_THRES)/2
DECL|macro|RX_LOW_STD_THRES
mdefine_line|#define RX_LOW_STD_THRES&t;(3*RX_RING_SIZE)/4
DECL|macro|RX_PANIC_MINI_THRES
mdefine_line|#define RX_PANIC_MINI_THRES&t;12
DECL|macro|RX_PANIC_MINI_REFILL
mdefine_line|#define RX_PANIC_MINI_REFILL&t;(3*RX_PANIC_MINI_THRES)/2
DECL|macro|RX_LOW_MINI_THRES
mdefine_line|#define RX_LOW_MINI_THRES&t;(3*RX_MINI_SIZE)/4
DECL|macro|RX_PANIC_JUMBO_THRES
mdefine_line|#define RX_PANIC_JUMBO_THRES&t;6
DECL|macro|RX_PANIC_JUMBO_REFILL
mdefine_line|#define RX_PANIC_JUMBO_REFILL&t;(3*RX_PANIC_JUMBO_THRES)/2
DECL|macro|RX_LOW_JUMBO_THRES
mdefine_line|#define RX_LOW_JUMBO_THRES&t;(3*RX_JUMBO_SIZE)/4
multiline_comment|/*&n; * Size of the mini ring entries, basically these just should be big&n; * enough to take TCP ACKs&n; */
DECL|macro|ACE_MINI_SIZE
mdefine_line|#define ACE_MINI_SIZE&t;&t;100
DECL|macro|ACE_MINI_BUFSIZE
mdefine_line|#define ACE_MINI_BUFSIZE&t;(ACE_MINI_SIZE + 2 + 16)
DECL|macro|ACE_STD_BUFSIZE
mdefine_line|#define ACE_STD_BUFSIZE&t;&t;(ACE_STD_MTU + ETH_HLEN + 2+4+16)
DECL|macro|ACE_JUMBO_BUFSIZE
mdefine_line|#define ACE_JUMBO_BUFSIZE&t;(ACE_JUMBO_MTU + ETH_HLEN + 2+4+16)
DECL|macro|DEF_TX_RATIO
mdefine_line|#define DEF_TX_RATIO&t;&t;24
DECL|macro|DEF_TX_COAL
mdefine_line|#define DEF_TX_COAL&t;&t;1000
DECL|macro|DEF_TX_MAX_DESC
mdefine_line|#define DEF_TX_MAX_DESC&t;&t;40
DECL|macro|DEF_RX_COAL
mdefine_line|#define DEF_RX_COAL&t;&t;1000
DECL|macro|DEF_RX_MAX_DESC
mdefine_line|#define DEF_RX_MAX_DESC&t;&t;20
DECL|macro|TX_COAL_INTS_ONLY
mdefine_line|#define TX_COAL_INTS_ONLY&t;0&t;/* seems not worth it */
DECL|macro|DEF_TRACE
mdefine_line|#define DEF_TRACE&t;&t;0
DECL|macro|DEF_STAT
mdefine_line|#define DEF_STAT&t;&t;2 * TICKS_PER_SEC
DECL|variable|link
r_static
r_int
id|link
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|trace
r_static
r_int
id|trace
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|tx_coal_tick
r_static
r_int
id|tx_coal_tick
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|rx_coal_tick
r_static
r_int
id|rx_coal_tick
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|max_tx_desc
r_static
r_int
id|max_tx_desc
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|max_rx_desc
r_static
r_int
id|max_rx_desc
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|tx_ratio
r_static
r_int
id|tx_ratio
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dis_pci_mem_inval
r_static
r_int
id|dis_pci_mem_inval
(braket
l_int|8
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|version
r_static
r_const
r_char
id|__initdata
op_star
id|version
op_assign
l_string|&quot;acenic.c: v0.34 09/03/99  Jes Sorensen (Jes.Sorensen@cern.ch)&bslash;n&quot;
suffix:semicolon
DECL|variable|root_dev
r_static
r_struct
id|net_device
op_star
id|root_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|__initdata
r_static
r_int
id|probed
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|function|acenic_probe
r_int
id|__init
id|acenic_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|boards_found
op_assign
l_int|0
suffix:semicolon
r_int
id|version_disp
suffix:semicolon
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|probed
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|probed
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
multiline_comment|/* is PCI support present? */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|version_disp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
id|pdev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_ALTEON
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_ALTEON_ACENIC
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_3COM
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_3COM_3C985
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_NETGEAR
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_NETGEAR_GA620
)paren
)paren
op_logical_and
multiline_comment|/*&n;&t;&t; * Farallon used the DEC vendor ID on their cards by&n;&t;&t; * mistake for a while&n;&t;&t; */
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_DEC
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_FARALLON_PN9000SX
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_ACENIC
)paren
)paren
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|ace_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acenic: Unable to allocate net_device &quot;
l_string|&quot;structure!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acenic: Unable to allocate memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ap-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|dev-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|ace_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|ace_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|ace_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|ace_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|ace_set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|ace_ioctl
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
op_amp
id|ace_set_mac_addr
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
op_amp
id|ace_change_mtu
suffix:semicolon
multiline_comment|/* display version info if adapter is found */
r_if
c_cond
(paren
op_logical_neg
id|version_disp
)paren
(brace
multiline_comment|/* set display flag to TRUE so that */
multiline_comment|/* we only display this string ONCE */
id|version_disp
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|ap-&gt;pci_command
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|ap-&gt;pci_latency
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;pci_latency
op_le
l_int|0x40
)paren
(brace
id|ap-&gt;pci_latency
op_assign
l_int|0x40
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
id|ap-&gt;pci_latency
)paren
suffix:semicolon
)brace
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remap the regs into kernel space - this is abuse of&n;&t;&t; * dev-&gt;base_addr since it was means for I/O port&n;&t;&t; * addresses but who gives a damn.&n;&t;&t; */
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02030d)
id|dev-&gt;base_addr
op_assign
id|pdev-&gt;base_address
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#else
id|dev-&gt;base_addr
op_assign
id|pdev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
macro_line|#endif
id|ap-&gt;regs
op_assign
(paren
r_struct
id|ace_regs
op_star
)paren
id|ioremap
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|0x4000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;regs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s:  Unable to map I/O register, &quot;
l_string|&quot;AceNIC %i will be disabled.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|boards_found
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|pdev-&gt;vendor
)paren
(brace
r_case
id|PCI_VENDOR_ID_ALTEON
suffix:colon
id|sprintf
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;AceNIC Gigabit Ethernet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Alteon AceNIC &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_3COM
suffix:colon
id|sprintf
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;3Com 3C985 Gigabit Ethernet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: 3Com 3C985 &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_NETGEAR
suffix:colon
id|sprintf
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;NetGear GA620 Gigabit Ethernet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: NetGear GA620 &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_DEC
suffix:colon
r_if
c_cond
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_FARALLON_PN9000SX
)paren
(brace
id|sprintf
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;Farallon PN9000-SX &quot;
l_string|&quot;Gigabit Ethernet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Farallon PN9000-SX &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PCI_VENDOR_ID_SGI
suffix:colon
id|sprintf
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;SGI AceNIC Gigabit Ethernet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: SGI AceNIC &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sprintf
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;Unknown AceNIC based Gigabit Ethernet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Unknown AceNIC &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Gigabit Ethernet at 0x%08lx, irq %i&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ACENIC_OMIT_TIGON_I
r_if
c_cond
(paren
(paren
id|readl
c_func
(paren
op_amp
id|ap-&gt;regs-&gt;HostCtrl
)paren
op_rshift
l_int|28
)paren
op_eq
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Driver compiled without Tigon I&quot;
l_string|&quot; support - NIC disabled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|ap-&gt;regs
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|ace_init
c_func
(paren
id|dev
comma
id|boards_found
)paren
)paren
r_continue
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|ace_init
c_func
(paren
id|dev
comma
op_minus
l_int|1
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif
id|boards_found
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re at this point we&squot;re going through ace_probe() for&n;&t; * the first time.  Return success (0) if we&squot;ve initialized 1&n;&t; * or more boards. Otherwise, return failure (-ENODEV).&n;&t; */
macro_line|#ifdef MODULE
r_return
id|boards_found
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|boards_found
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef MODULE
macro_line|#if LINUX_VERSION_CODE &gt; 0x20118
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jes Sorensen &lt;Jes.Sorensen@cern.ch&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;AceNIC/3C985 Gigabit Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|link
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|trace
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tx_coal_tick
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_tx_desc
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rx_coal_tick
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_rx_desc
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|cards
suffix:semicolon
id|root_dev
op_assign
l_int|NULL
suffix:semicolon
id|cards
op_assign
id|acenic_probe
c_func
(paren
)paren
suffix:semicolon
r_return
id|cards
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|net_device
op_star
id|next
suffix:semicolon
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|root_dev
)paren
(brace
id|next
op_assign
(paren
(paren
r_struct
id|ace_private
op_star
)paren
id|root_dev-&gt;priv
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|root_dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuBCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuBCtrl
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This clears any pending interrupts&n;&t;&t; */
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure no other CPUs are processing interrupts&n;&t;&t; * on the card before the buffers are being released.&n;&t;&t; * Otherwise one might experience some `interesting&squot;&n;&t;&t; * effects.&n;&t;&t; *&n;&t;&t; * Then release the RX buffers - jumbo buffers were&n;&t;&t; * already released in ace_close().&n;&t;&t; */
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_STD_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|i
)braket
)paren
(brace
id|ap-&gt;rx_std_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|set_aceaddr_bus
c_func
(paren
op_amp
id|ap-&gt;rx_std_ring
(braket
id|i
)braket
dot
id|addr
comma
l_int|0
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_MINI_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|i
)braket
)paren
(brace
id|ap-&gt;rx_mini_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|set_aceaddr_bus
c_func
(paren
op_amp
id|ap-&gt;rx_mini_ring
(braket
id|i
)braket
dot
id|addr
comma
l_int|0
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
id|iounmap
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;trace_buf
)paren
(brace
id|kfree
c_func
(paren
id|ap-&gt;trace_buf
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ap-&gt;info
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ap-&gt;skb
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|root_dev-&gt;irq
comma
id|root_dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|root_dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|root_dev
)paren
suffix:semicolon
id|root_dev
op_assign
id|next
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Commands are considered to be slow.&n; */
DECL|function|ace_issue_cmd
r_static
r_inline
r_void
id|ace_issue_cmd
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
r_struct
id|cmd
op_star
id|cmd
)paren
(brace
id|u32
id|idx
suffix:semicolon
id|idx
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;CmdPrd
)paren
suffix:semicolon
id|writel
c_func
(paren
op_star
(paren
id|u32
op_star
)paren
(paren
id|cmd
)paren
comma
op_amp
id|regs-&gt;CmdRng
(braket
id|idx
)braket
)paren
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|CMD_RING_ENTRIES
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;CmdPrd
)paren
suffix:semicolon
)brace
DECL|function|ace_init
r_static
r_int
id|__init
id|ace_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|board_idx
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|ace_info
op_star
id|info
suffix:semicolon
r_int
r_int
id|tmp_ptr
comma
id|myjif
suffix:semicolon
id|u32
id|tig_ver
comma
id|mac1
comma
id|mac2
comma
id|tmp
comma
id|pci_state
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t access any other registes before this point!&n;&t; */
macro_line|#ifdef __BIG_ENDIAN
id|writel
c_func
(paren
(paren
(paren
id|BYTE_SWAP
op_or
id|WORD_SWAP
op_or
id|CLR_INT
)paren
op_or
(paren
(paren
id|BYTE_SWAP
op_or
id|WORD_SWAP
op_or
id|CLR_INT
)paren
op_lshift
l_int|24
)paren
)paren
comma
op_amp
id|regs-&gt;HostCtrl
)paren
suffix:semicolon
macro_line|#else
id|writel
c_func
(paren
(paren
id|CLR_INT
op_or
id|WORD_SWAP
op_or
(paren
(paren
id|CLR_INT
op_or
id|WORD_SWAP
)paren
op_lshift
l_int|24
)paren
)paren
comma
op_amp
id|regs-&gt;HostCtrl
)paren
suffix:semicolon
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Stop the NIC CPU and clear pending interrupts&n;&t; */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
id|tig_ver
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;HostCtrl
)paren
op_rshift
l_int|28
suffix:semicolon
r_switch
c_cond
(paren
id|tig_ver
)paren
(brace
macro_line|#ifndef CONFIG_ACENIC_OMIT_TIGON_I
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Tigon I (Rev. 4), Firmware: %i.%i.%i, &quot;
comma
id|tigonFwReleaseMajor
comma
id|tigonFwReleaseMinor
comma
id|tigonFwReleaseFix
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|ap-&gt;version
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|6
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Tigon II (Rev. %i), Firmware: %i.%i.%i, &quot;
comma
id|tig_ver
comma
id|tigon2FwReleaseMajor
comma
id|tigon2FwReleaseMinor
comma
id|tigon2FwReleaseFix
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuBCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuBCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
id|SRAM_BANK_512K
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
id|SYNC_SRAM_TIMING
comma
op_amp
id|regs-&gt;MiscCfg
)paren
suffix:semicolon
id|ap-&gt;version
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Unsupported Tigon version detected (%i), &quot;
comma
id|tig_ver
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ModeStat _must_ be set after the SRAM settings as this change&n;&t; * seems to corrupt the ModeStat and possible other registers.&n;&t; * The SRAM settings survive resets and setting it to the same&n;&t; * value a second time works as well. This is what caused the&n;&t; * `Firmware not running&squot; problem on the Tigon II.&n;&t; */
macro_line|#ifdef __LITTLE_ENDIAN
id|writel
c_func
(paren
id|ACE_BYTE_SWAP_DATA
op_or
id|ACE_WARN
op_or
id|ACE_FATAL
op_or
id|ACE_WORD_SWAP
op_or
id|ACE_NO_JUMBO_FRAG
comma
op_amp
id|regs-&gt;ModeStat
)paren
suffix:semicolon
macro_line|#else
macro_line|#error &quot;this driver doesn&squot;t run on big-endian machines yet!&quot;
macro_line|#endif
id|mac1
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac1
op_assign
id|mac1
op_lshift
l_int|8
suffix:semicolon
id|mac1
op_or_assign
id|read_eeprom_byte
c_func
(paren
id|regs
comma
l_int|0x8c
op_plus
id|i
)paren
suffix:semicolon
)brace
id|mac2
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac2
op_assign
id|mac2
op_lshift
l_int|8
suffix:semicolon
id|mac2
op_or_assign
id|read_eeprom_byte
c_func
(paren
id|regs
comma
l_int|0x8c
op_plus
id|i
)paren
suffix:semicolon
)brace
id|writel
c_func
(paren
id|mac1
comma
op_amp
id|regs-&gt;MacAddrHi
)paren
suffix:semicolon
id|writel
c_func
(paren
id|mac2
comma
op_amp
id|regs-&gt;MacAddrLo
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MAC: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
(paren
id|mac1
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|mac1
op_amp
l_int|0xff
comma
(paren
id|mac2
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
(paren
id|mac2
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
(paren
id|mac2
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|mac2
op_amp
l_int|0xff
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
(paren
id|mac1
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_assign
id|mac1
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_assign
(paren
id|mac2
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
op_assign
(paren
id|mac2
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
op_assign
(paren
id|mac2
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
op_assign
id|mac2
op_amp
l_int|0xff
suffix:semicolon
id|pci_state
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;PciState
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  PCI bus speed: %iMHz, latency: %i clks&bslash;n&quot;
comma
(paren
id|pci_state
op_amp
id|PCI_66MHZ
)paren
ques
c_cond
l_int|66
suffix:colon
l_int|33
comma
id|ap-&gt;pci_latency
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the max DMA transfer size. Seems that for most systems&n;&t; * the performance is better when no MAX parameter is&n;&t; * set. However for systems enabling PCI write and invalidate,&n;&t; * DMA writes must be set to the L1 cache line size to get&n;&t; * optimal performance.&n;&t; *&n;&t; * The default is now to turn the PCI write and invalidate off&n;&t; * - that is what Alteon does for NT.&n;&t; */
id|tmp
op_assign
id|READ_CMD_MEM
op_or
id|WRITE_CMD_MEM
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|tmp
op_or_assign
(paren
id|MEM_READ_MULTIPLE
op_or
(paren
id|pci_state
op_amp
id|PCI_66MHZ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Tuning parameters only supported for 8 cards&n;&t;&t; */
r_if
c_cond
(paren
id|board_idx
OG
l_int|7
op_logical_or
id|dis_pci_mem_inval
(braket
id|board_idx
)braket
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;pci_command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
(brace
id|ap-&gt;pci_command
op_and_assign
op_complement
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_COMMAND
comma
id|ap-&gt;pci_command
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: disabling PCI memory &quot;
l_string|&quot;write and invalidate&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;pci_command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: PCI memory write &amp; invalidate &quot;
l_string|&quot;enabled by BIOS, enabling counter &quot;
l_string|&quot;measures&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|L1_CACHE_BYTES
)paren
(brace
r_case
l_int|16
suffix:colon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_32
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|64
suffix:colon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_64
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Cache line size %i not &quot;
l_string|&quot;supported, PCI write and invalidate &quot;
l_string|&quot;disabled&bslash;n&quot;
comma
id|L1_CACHE_BYTES
)paren
suffix:semicolon
id|ap-&gt;pci_command
op_and_assign
op_complement
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_COMMAND
comma
id|ap-&gt;pci_command
)paren
suffix:semicolon
)brace
)brace
)brace
id|writel
c_func
(paren
id|tmp
comma
op_amp
id|regs-&gt;PciState
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the generic info block and the command+event rings&n;&t; * and the control blocks for the transmit and receive rings&n;&t; * as they need to be setup once and for all.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ace_info
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/*&n;&t; * Get the memory for the skb rings.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;skb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ace_skb
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|ace_interrupt
comma
id|SA_SHIRQ
comma
id|ap-&gt;name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Requested IRQ %d is busy&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register the device here to be able to catch allocated&n;&t; * interrupt handlers in case the firmware doesn&squot;t come up.&n;&t; */
id|ap-&gt;next
op_assign
id|root_dev
suffix:semicolon
id|root_dev
op_assign
id|dev
suffix:semicolon
id|ap-&gt;info
op_assign
id|info
suffix:semicolon
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ace_info
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;skb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ace_skb
)paren
)paren
suffix:semicolon
id|ace_load_firmware
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ap-&gt;fw_running
op_assign
l_int|0
suffix:semicolon
id|tmp_ptr
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|info
)paren
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 64)
id|writel
c_func
(paren
id|tmp_ptr
op_rshift
l_int|32
comma
op_amp
id|regs-&gt;InfoPtrHi
)paren
suffix:semicolon
macro_line|#else
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;InfoPtrHi
)paren
suffix:semicolon
macro_line|#endif
id|writel
c_func
(paren
id|tmp_ptr
op_amp
l_int|0xffffffff
comma
op_amp
id|regs-&gt;InfoPtrLo
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;evt_ring
comma
l_int|0
comma
id|EVT_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|event
)paren
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;evt_ctrl.rngptr
comma
id|ap-&gt;evt_ring
)paren
suffix:semicolon
id|info-&gt;evt_ctrl.flags
op_assign
l_int|0
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;evt_prd_ptr
comma
op_amp
id|ap-&gt;evt_prd
)paren
suffix:semicolon
id|ap-&gt;evt_prd
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;EvtCsm
)paren
suffix:semicolon
id|set_aceaddr_bus
c_func
(paren
op_amp
id|info-&gt;cmd_ctrl.rngptr
comma
(paren
r_void
op_star
)paren
l_int|0x100
)paren
suffix:semicolon
id|info-&gt;cmd_ctrl.flags
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cmd_ctrl.max_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CMD_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;CmdRng
(braket
id|i
)braket
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;CmdPrd
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;CmdCsm
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;stats2_ptr
comma
op_amp
id|info-&gt;s.stats
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_std_ctrl.rngptr
comma
id|ap-&gt;rx_std_ring
)paren
suffix:semicolon
id|info-&gt;rx_std_ctrl.max_len
op_assign
id|ACE_STD_MTU
op_plus
id|ETH_HLEN
op_plus
l_int|4
suffix:semicolon
id|info-&gt;rx_std_ctrl.flags
op_assign
id|RCB_FLG_TCP_UDP_SUM
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_std_ring
comma
l_int|0
comma
id|RX_STD_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_STD_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;rx_std_ring
(braket
id|i
)braket
dot
id|flags
op_assign
id|BD_FLG_TCP_UDP_SUM
suffix:semicolon
id|ap-&gt;rx_std_skbprd
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
comma
l_int|0
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_jumbo_ctrl.rngptr
comma
id|ap-&gt;rx_jumbo_ring
)paren
suffix:semicolon
id|info-&gt;rx_jumbo_ctrl.max_len
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_jumbo_ctrl.flags
op_assign
id|RCB_FLG_TCP_UDP_SUM
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_jumbo_ring
comma
l_int|0
comma
id|RX_JUMBO_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|flags
op_assign
id|BD_FLG_TCP_UDP_SUM
op_or
id|BD_FLG_JUMBO
suffix:semicolon
id|ap-&gt;rx_jumbo_skbprd
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
comma
l_int|0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_mini_ring
comma
l_int|0
comma
id|RX_MINI_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_mini_ctrl.rngptr
comma
id|ap-&gt;rx_mini_ring
)paren
suffix:semicolon
id|info-&gt;rx_mini_ctrl.max_len
op_assign
id|ACE_MINI_SIZE
suffix:semicolon
id|info-&gt;rx_mini_ctrl.flags
op_assign
id|RCB_FLG_TCP_UDP_SUM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_MINI_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;rx_mini_ring
(braket
id|i
)braket
dot
id|flags
op_assign
id|BD_FLG_TCP_UDP_SUM
op_or
id|BD_FLG_MINI
suffix:semicolon
)brace
r_else
(brace
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_mini_ctrl.rngptr
comma
l_int|0
)paren
suffix:semicolon
id|info-&gt;rx_mini_ctrl.flags
op_assign
id|RCB_FLG_RNG_DISABLE
suffix:semicolon
id|info-&gt;rx_mini_ctrl.max_len
op_assign
l_int|0
suffix:semicolon
)brace
id|ap-&gt;rx_mini_skbprd
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
comma
l_int|0
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_return_ctrl.rngptr
comma
id|ap-&gt;rx_return_ring
)paren
suffix:semicolon
id|info-&gt;rx_return_ctrl.flags
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_return_ctrl.max_len
op_assign
id|RX_RETURN_RING_ENTRIES
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_return_ring
comma
l_int|0
comma
id|RX_RETURN_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_ret_prd_ptr
comma
op_amp
id|ap-&gt;rx_ret_prd
)paren
suffix:semicolon
id|writel
c_func
(paren
id|TX_RING_BASE
comma
op_amp
id|regs-&gt;WinBase
)paren
suffix:semicolon
id|ap-&gt;tx_ring
op_assign
(paren
r_struct
id|tx_desc
op_star
)paren
id|regs-&gt;Window
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|TX_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|tx_desc
)paren
op_div
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
)paren
id|ap-&gt;tx_ring
op_plus
id|i
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|set_aceaddr_bus
c_func
(paren
op_amp
id|info-&gt;tx_ctrl.rngptr
comma
(paren
r_void
op_star
)paren
id|TX_RING_BASE
)paren
suffix:semicolon
id|info-&gt;tx_ctrl.max_len
op_assign
id|TX_RING_ENTRIES
suffix:semicolon
macro_line|#if TX_COAL_INTS_ONLY
id|info-&gt;tx_ctrl.flags
op_assign
id|RCB_FLG_COAL_INT_ONLY
suffix:semicolon
macro_line|#else
id|info-&gt;tx_ctrl.flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;tx_csm_ptr
comma
op_amp
id|ap-&gt;tx_csm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Potential item for tuning parameter&n;&t; */
id|writel
c_func
(paren
id|DMA_THRESH_8W
comma
op_amp
id|regs-&gt;DmaReadCfg
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DMA_THRESH_8W
comma
op_amp
id|regs-&gt;DmaWriteCfg
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;MaskInt
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;IfIdx
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;AssistState
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_STAT
comma
op_amp
id|regs-&gt;TuneStatTicks
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_TX_COAL
comma
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_TX_MAX_DESC
comma
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_RX_COAL
comma
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_RX_MAX_DESC
comma
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_TRACE
comma
op_amp
id|regs-&gt;TuneTrace
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_TX_RATIO
comma
op_amp
id|regs-&gt;TxBufRat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|board_idx
op_ge
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: more then 8 NICs detected, &quot;
l_string|&quot;ignoring module parameters!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|board_idx
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|board_idx
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|tx_coal_tick
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_tx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|max_tx_desc
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|rx_coal_tick
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_rx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|max_rx_desc
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trace
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|trace
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneTrace
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tx_ratio
(braket
id|board_idx
)braket
op_ge
l_int|0
)paren
op_logical_and
(paren
id|tx_ratio
(braket
id|board_idx
)braket
OL
l_int|64
)paren
)paren
id|writel
c_func
(paren
id|tx_ratio
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TxBufRat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Default link parameters&n;&t; */
id|tmp
op_assign
id|LNK_ENABLE
op_or
id|LNK_FULL_DUPLEX
op_or
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
op_or
id|LNK_RX_FLOW_CTL_Y
op_or
id|LNK_NEG_FCTL
op_or
id|LNK_NEGOTIATE
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|tmp
op_or_assign
id|LNK_TX_FLOW_CTL_Y
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Override link default parameters&n;&t; */
r_if
c_cond
(paren
(paren
id|board_idx
op_ge
l_int|0
)paren
op_logical_and
id|link
(braket
id|board_idx
)braket
)paren
(brace
r_int
id|option
op_assign
id|link
(braket
id|board_idx
)braket
suffix:semicolon
id|tmp
op_assign
id|LNK_ENABLE
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Setting half duplex link&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|LNK_FULL_DUPLEX
suffix:semicolon
)brace
r_if
c_cond
(paren
id|option
op_amp
l_int|0x02
)paren
id|tmp
op_and_assign
op_complement
id|LNK_NEGOTIATE
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x10
)paren
id|tmp
op_or_assign
id|LNK_10MB
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x20
)paren
id|tmp
op_or_assign
id|LNK_100MB
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x40
)paren
id|tmp
op_or_assign
id|LNK_1000MB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|option
op_amp
l_int|0x70
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No media speed specified, &quot;
l_string|&quot;forcing auto negotiation&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tmp
op_or_assign
id|LNK_NEGOTIATE
op_or
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|option
op_amp
l_int|0x100
)paren
op_eq
l_int|0
)paren
id|tmp
op_or_assign
id|LNK_NEG_FCTL
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Disabling flow control &quot;
l_string|&quot;negotiation&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x200
)paren
id|tmp
op_or_assign
id|LNK_RX_FLOW_CTL_Y
suffix:semicolon
r_if
c_cond
(paren
(paren
id|option
op_amp
l_int|0x400
)paren
op_logical_and
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling TX flow control&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tmp
op_or_assign
id|LNK_TX_FLOW_CTL_Y
suffix:semicolon
)brace
)brace
id|ap-&gt;link
op_assign
id|tmp
suffix:semicolon
id|writel
c_func
(paren
id|tmp
comma
op_amp
id|regs-&gt;TuneLink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
id|writel
c_func
(paren
id|tmp
comma
op_amp
id|regs-&gt;TuneFastLink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|writel
c_func
(paren
id|tigonFwStartAddr
comma
op_amp
id|regs-&gt;Pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_eq
l_int|2
)paren
id|writel
c_func
(paren
id|tigon2FwStartAddr
comma
op_amp
id|regs-&gt;Pc
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set tx_csm before we start receiving interrupts, otherwise&n;&t; * the interrupt handler might think it is supposed to process&n;&t; * tx ints before we are up and running, which may cause a null&n;&t; * pointer access in the int handler.&n;&t; */
id|ap-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;cur_rx
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;tx_prd
op_assign
id|ap-&gt;tx_csm
op_assign
id|ap-&gt;tx_ret_csm
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;TxPrd
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;RxRetCsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start the NIC CPU&n;&t; */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_amp
op_complement
(paren
id|CPU_HALT
op_or
id|CPU_TRACE
)paren
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for the firmware to spin up - max 3 seconds.&n;&t; */
id|myjif
op_assign
id|jiffies
op_plus
l_int|3
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|myjif
)paren
op_logical_and
op_logical_neg
id|ap-&gt;fw_running
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;fw_running
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Firmware NOT running!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ace_dump_trace
c_func
(paren
id|ap
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We load the ring here as there seem to be no way to tell the&n;&t; * firmware to wipe the ring without re-initializing it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
)paren
id|ace_load_std_rx_ring
c_func
(paren
id|ap
comma
id|RX_RING_SIZE
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Someone is busy refilling the RX ring&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
)paren
id|ace_load_mini_rx_ring
c_func
(paren
id|ap
comma
id|RX_MINI_SIZE
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Someone is busy refilling &quot;
l_string|&quot;the RX mini ring&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Monitor the card to detect hangs.&n; */
DECL|function|ace_timer
r_static
r_void
id|ace_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|ace_private
op_star
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
multiline_comment|/*&n;&t; * We haven&squot;t received a stats update event for more than 2.5&n;&t; * seconds and there is data in the transmit queue, thus we&n;&t; * asume the card is stuck.&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;tx_csm
op_ne
id|ap-&gt;tx_ret_csm
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Transmitter is stuck, %08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;HostCtrl
)paren
)paren
suffix:semicolon
)brace
id|ap-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_div
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
)brace
DECL|function|ace_bh
r_static
r_void
id|ace_bh
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|cur_size
suffix:semicolon
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_LOW_STD_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;refilling buffers (current %i)&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_std_rx_ring
c_func
(paren
id|ap
comma
id|RX_RING_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_LOW_MINI_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;refilling mini buffers (current %i)&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_mini_rx_ring
c_func
(paren
id|ap
comma
id|RX_MINI_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
)brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;jumbo
op_logical_and
(paren
id|cur_size
OL
id|RX_LOW_JUMBO_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;refilling jumbo buffers (current %i)&bslash;n&quot;
comma
OG
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
id|ap-&gt;bh_pending
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the contents of the NIC&squot;s trace buffer to kernel memory.&n; */
DECL|function|ace_dump_trace
r_static
r_void
id|ace_dump_trace
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;trace_buf
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;trace_buf
op_assign
id|kmalloc
c_func
(paren
id|ACE_TRACE_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Load the standard rx ring.&n; *&n; * Loading rings is safe without holding the spin lock since this is&n; * done only before the device is enabled, thus no interrupts are&n; * generated and by the interrupt handler/bh handler.&n; */
DECL|function|ace_load_std_rx_ring
r_static
r_void
id|ace_load_std_rx_ring
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
comma
r_int
id|nr_bufs
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|i
comma
id|idx
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|idx
op_assign
id|ap-&gt;rx_std_skbprd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rd
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ACE_STD_BUFSIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure IP header starts on a fresh cache line.&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|idx
)braket
op_assign
id|skb
suffix:semicolon
id|rd
op_assign
op_amp
id|ap-&gt;rx_std_ring
(braket
id|idx
)braket
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|rd-&gt;addr
comma
id|skb-&gt;data
)paren
suffix:semicolon
id|rd-&gt;size
op_assign
id|ACE_STD_MTU
op_plus
id|ETH_HLEN
op_plus
l_int|4
suffix:semicolon
id|rd-&gt;idx
op_assign
id|idx
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_STD_RING_ENTRIES
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|nr_bufs
comma
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
id|ap-&gt;rx_std_skbprd
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_RX_PRD_IDX
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
id|ap-&gt;rx_std_skbprd
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxStdPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ace_load_mini_rx_ring
r_static
r_void
id|ace_load_mini_rx_ring
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
comma
r_int
id|nr_bufs
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|i
comma
id|idx
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|idx
op_assign
id|ap-&gt;rx_mini_skbprd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rd
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ACE_MINI_BUFSIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the IP header ends up on a fresh cache line&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|idx
)braket
op_assign
id|skb
suffix:semicolon
id|rd
op_assign
op_amp
id|ap-&gt;rx_mini_ring
(braket
id|idx
)braket
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|rd-&gt;addr
comma
id|skb-&gt;data
)paren
suffix:semicolon
id|rd-&gt;size
op_assign
id|ACE_MINI_SIZE
suffix:semicolon
id|rd-&gt;idx
op_assign
id|idx
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_MINI_RING_ENTRIES
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|nr_bufs
comma
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
id|ap-&gt;rx_mini_skbprd
op_assign
id|idx
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxMiniPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Load the jumbo rx ring, this may happen at any time if the MTU&n; * is changed to a value &gt; 1500.&n; */
DECL|function|ace_load_jumbo_rx_ring
r_static
r_void
id|ace_load_jumbo_rx_ring
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
comma
r_int
id|nr_bufs
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|i
comma
id|idx
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|idx
op_assign
id|ap-&gt;rx_jumbo_skbprd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rd
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ACE_JUMBO_BUFSIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the IP header ends up on a fresh cache line&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|idx
)braket
op_assign
id|skb
suffix:semicolon
id|rd
op_assign
op_amp
id|ap-&gt;rx_jumbo_ring
(braket
id|idx
)braket
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|rd-&gt;addr
comma
id|skb-&gt;data
)paren
suffix:semicolon
id|rd-&gt;size
op_assign
id|ACE_JUMBO_MTU
op_plus
id|ETH_HLEN
op_plus
l_int|4
suffix:semicolon
id|rd-&gt;idx
op_assign
id|idx
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|nr_bufs
comma
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
id|ap-&gt;rx_jumbo_skbprd
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_RX_JUMBO_PRD_IDX
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
id|ap-&gt;rx_jumbo_skbprd
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxJumboPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell the firmware not to accept jumbos and flush the jumbo ring.&n; */
DECL|function|ace_flush_jumbo_rx_ring
r_static
r_int
id|ace_flush_jumbo_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
(brace
id|cmd.evt
op_assign
id|C_RESET_JUMBO_RNG
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
)paren
(brace
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|set_aceaddr_bus
c_func
(paren
op_amp
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|addr
comma
l_int|0
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Trying to flush Jumbo ring without &quot;
l_string|&quot;Jumbo support enabled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * All events are considered to be slow (RX/TX ints do not generate&n; * events) and are handled here, outside the main interrupt handler,&n; * to reduce the size of the handler.&n; */
DECL|function|ace_handle_event
r_static
id|u32
id|ace_handle_event
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|evtcsm
comma
id|u32
id|evtprd
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_while
c_loop
(paren
id|evtcsm
op_ne
id|evtprd
)paren
(brace
r_switch
c_cond
(paren
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|evt
)paren
(brace
r_case
id|E_FW_RUNNING
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Firmware up and running&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;fw_running
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_STATS_UPDATED
suffix:colon
r_break
suffix:semicolon
r_case
id|E_LNK_STATE
suffix:colon
(brace
id|u16
id|code
op_assign
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|code
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
id|E_C_LINK_UP
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Optical link UP&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|code
op_eq
id|E_C_LINK_DOWN
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Optical link DOWN&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unknown optical link &quot;
l_string|&quot;state %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|code
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|E_ERROR
suffix:colon
r_switch
c_cond
(paren
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|code
)paren
(brace
r_case
id|E_C_ERR_INVAL_CMD
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: invalid command error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_C_ERR_UNIMP_CMD
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unimplemented command &quot;
l_string|&quot;error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_C_ERR_BAD_CFG
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bad config error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unknown error %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|code
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_RESET_JUMBO_RNG
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unhandled event 0x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|evt
)paren
suffix:semicolon
)brace
id|evtcsm
op_assign
(paren
id|evtcsm
op_plus
l_int|1
)paren
op_mod
id|EVT_RING_ENTRIES
suffix:semicolon
)brace
r_return
id|evtcsm
suffix:semicolon
)brace
DECL|function|ace_rx_int
r_static
r_void
id|ace_rx_int
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|rxretprd
comma
id|u32
id|rxretcsm
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u32
id|idx
suffix:semicolon
r_int
id|mini_count
op_assign
l_int|0
comma
id|std_count
op_assign
l_int|0
suffix:semicolon
id|idx
op_assign
id|rxretcsm
suffix:semicolon
r_while
c_loop
(paren
id|idx
op_ne
id|rxretprd
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
op_star
id|oldskb_p
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rxdesc
suffix:semicolon
id|u32
id|skbidx
suffix:semicolon
r_int
id|desc_type
suffix:semicolon
id|u16
id|csum
suffix:semicolon
id|skbidx
op_assign
id|ap-&gt;rx_return_ring
(braket
id|idx
)braket
dot
id|idx
suffix:semicolon
id|desc_type
op_assign
id|ap-&gt;rx_return_ring
(braket
id|idx
)braket
dot
id|flags
op_amp
(paren
id|BD_FLG_JUMBO
op_or
id|BD_FLG_MINI
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|desc_type
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Normal frames do not have any flags set&n;&t;&t;&t; *&n;&t;&t;&t; * Mini and normal frames arrive frequently,&n;&t;&t;&t; * so use a local counter to avoid doing&n;&t;&t;&t; * atomic operations for each packet arriving.&n;&t;&t;&t; */
r_case
l_int|0
suffix:colon
id|oldskb_p
op_assign
op_amp
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|skbidx
)braket
suffix:semicolon
id|rxdesc
op_assign
op_amp
id|ap-&gt;rx_std_ring
(braket
id|skbidx
)braket
suffix:semicolon
id|std_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BD_FLG_JUMBO
suffix:colon
id|oldskb_p
op_assign
op_amp
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|skbidx
)braket
suffix:semicolon
id|rxdesc
op_assign
op_amp
id|ap-&gt;rx_jumbo_ring
(braket
id|skbidx
)braket
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BD_FLG_MINI
suffix:colon
id|oldskb_p
op_assign
op_amp
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|skbidx
)braket
suffix:semicolon
id|rxdesc
op_assign
op_amp
id|ap-&gt;rx_mini_ring
(braket
id|skbidx
)braket
suffix:semicolon
id|mini_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unknown frame type (0x%02x) &quot;
l_string|&quot;returned by NIC&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ap-&gt;rx_return_ring
(braket
id|idx
)braket
dot
id|flags
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|skb
op_assign
op_star
id|oldskb_p
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Mayday! illegal skb received! (idx %i)&bslash;n&quot;
comma
id|skbidx
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
macro_line|#endif
op_star
id|oldskb_p
op_assign
l_int|NULL
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|rxdesc-&gt;size
)paren
suffix:semicolon
id|rxdesc-&gt;size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fly baby, fly!&n;&t;&t; */
id|csum
op_assign
id|ap-&gt;rx_return_ring
(braket
id|idx
)braket
dot
id|tcp_udp_csum
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the checksum is correct and this is not a&n;&t;&t; * fragment, tell the stack that the data is correct.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|csum
op_xor
l_int|0xffff
)paren
op_logical_and
(paren
op_logical_neg
(paren
(paren
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
)paren
op_member_access_from_pointer
id|frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
)paren
)paren
(brace
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
)brace
r_else
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* send it up */
id|ap-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|ap-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_RETURN_RING_ENTRIES
suffix:semicolon
)brace
id|atomic_sub
c_func
(paren
id|std_count
comma
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|atomic_sub
c_func
(paren
id|mini_count
comma
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * According to the documentation RxRetCsm is obsolete with&n;&t; * the 12.3.x Firmware - my Tigon I NICs seem to disagree!&n;&t; */
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxRetCsm
)paren
suffix:semicolon
)brace
id|ap-&gt;cur_rx
op_assign
id|idx
suffix:semicolon
r_return
suffix:semicolon
id|error
suffix:colon
id|idx
op_assign
id|rxretprd
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|ace_interrupt
r_static
r_void
id|ace_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|idx
suffix:semicolon
id|u32
id|txcsm
comma
id|rxretcsm
comma
id|rxretprd
suffix:semicolon
id|u32
id|evtcsm
comma
id|evtprd
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
multiline_comment|/*&n;&t; * In case of PCI shared interrupts or spurious interrupts,&n;&t; * we want to make sure it is actually our interrupt before&n;&t; * spending any time in here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;HostCtrl
)paren
op_amp
id|IN_INT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the card not to generate interrupts while we are in here.&n;&t; */
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no conflict between transmit handling in&n;&t; * start_xmit and receive processing, thus there is no reason&n;&t; * to take a spin lock for RX handling. Wait until we start&n;&t; * working on the other stuff - hey we don&squot;t need a spin lock&n;&t; * anymore.&n;&t; */
id|rxretprd
op_assign
id|ap-&gt;rx_ret_prd
suffix:semicolon
id|rxretcsm
op_assign
id|ap-&gt;cur_rx
suffix:semicolon
r_if
c_cond
(paren
id|rxretprd
op_ne
id|rxretcsm
)paren
id|ace_rx_int
c_func
(paren
id|dev
comma
id|rxretprd
comma
id|rxretcsm
)paren
suffix:semicolon
id|txcsm
op_assign
id|ap-&gt;tx_csm
suffix:semicolon
id|idx
op_assign
id|ap-&gt;tx_ret_csm
suffix:semicolon
r_if
c_cond
(paren
id|txcsm
op_ne
id|idx
)paren
(brace
r_do
(brace
id|ap-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|ap-&gt;stats.tx_bytes
op_add_assign
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
op_member_access_from_pointer
id|len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Question here is whether one should not skip&n;&t;&t;&t; * these writes - I have never seen any errors&n;&t;&t;&t; * caused by the NIC actually trying to access&n;&t;&t;&t; * these incorrectly.&n;&t;&t;&t; */
macro_line|#if (BITS_PER_LONG == 64)
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr.addrhi
)paren
suffix:semicolon
macro_line|#endif
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr.addrlo
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|flagsize
)paren
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|TX_RING_ENTRIES
suffix:semicolon
)brace
r_while
c_loop
(paren
id|idx
op_ne
id|txcsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Once we actually get to this point the tx ring has&n;&t;&t; * already been trimmed thus it cannot be full!&n;&t;&t; * Ie. skip the comparison of the tx producer vs. the&n;&t;&t; * consumer.&n;&t;&t; */
r_if
c_cond
(paren
id|ap-&gt;tx_full
op_logical_and
id|dev-&gt;tbusy
)paren
(brace
id|ap-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This does not need to be atomic (and expensive),&n;&t;&t;&t; * I&squot;ve seen cases where it would fail otherwise ;-(&n;&t;&t;&t; */
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|dev-&gt;tbusy
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * TX ring is no longer full, aka the&n;&t;&t;&t; * transmitter is working fine - kill timer.&n;&t;&t;&t; */
id|del_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
)brace
id|ap-&gt;tx_ret_csm
op_assign
id|txcsm
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|evtcsm
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;EvtCsm
)paren
suffix:semicolon
id|evtprd
op_assign
id|ap-&gt;evt_prd
suffix:semicolon
r_if
c_cond
(paren
id|evtcsm
op_ne
id|evtprd
)paren
(brace
id|evtcsm
op_assign
id|ace_handle_event
c_func
(paren
id|dev
comma
id|evtcsm
comma
id|evtprd
)paren
suffix:semicolon
id|writel
c_func
(paren
id|evtcsm
comma
op_amp
id|regs-&gt;EvtCsm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This has to go last in the interrupt handler and run with&n;&t; * the spin lock released ... what lock?&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;start
)paren
(brace
r_int
id|cur_size
suffix:semicolon
r_int
id|run_bh
op_assign
l_int|0
suffix:semicolon
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_size
OL
id|RX_LOW_STD_THRES
)paren
(brace
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_PANIC_STD_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;low on std buffers %i&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_std_rx_ring
c_func
(paren
id|ap
comma
id|RX_RING_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
id|run_bh
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_size
OL
id|RX_LOW_MINI_THRES
)paren
(brace
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_PANIC_MINI_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;low on mini buffers %i&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_mini_rx_ring
c_func
(paren
id|ap
comma
id|RX_MINI_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_else
id|run_bh
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
(brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_size
OL
id|RX_LOW_JUMBO_THRES
)paren
(brace
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_PANIC_JUMBO_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;low on jumbo buffers %i&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_else
id|run_bh
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|run_bh
op_logical_and
op_logical_neg
id|ap-&gt;bh_pending
)paren
(brace
id|ap-&gt;bh_pending
op_assign
l_int|1
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|ap-&gt;immediate
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allow the card to generate interrupts again&n;&t; */
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
)brace
DECL|function|ace_open
r_static
r_int
id|ace_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;fw_running
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Firmware not running!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|writel
c_func
(paren
id|dev-&gt;mtu
op_plus
id|ETH_HLEN
op_plus
l_int|4
comma
op_amp
id|regs-&gt;IfMtu
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_HOST_STATE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_STACK_UP
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;jumbo
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ap-&gt;promisc
op_assign
l_int|0
suffix:semicolon
)brace
id|ap-&gt;mcast_all
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
id|cmd.evt
op_assign
id|C_LNK_NEGOTIATION
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the timer&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
id|ap-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|ap-&gt;timer.function
op_assign
id|ace_timer
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the bottom half rx ring refill handler&n;&t; */
id|ap-&gt;immediate.next
op_assign
l_int|NULL
suffix:semicolon
id|ap-&gt;immediate.sync
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;immediate.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|ace_bh
suffix:semicolon
id|ap-&gt;immediate.data
op_assign
id|dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_close
r_static
r_int
id|ace_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
id|dev-&gt;tbusy
)paren
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;promisc
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|0
suffix:semicolon
)brace
id|cmd.evt
op_assign
id|C_HOST_STATE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_STACK_DOWN
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure one CPU is not processing packets while&n;&t; * buffers are being released by another.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|i
)braket
)paren
(brace
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|i
)braket
dot
id|addr.addrhi
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|i
)braket
dot
id|addr.addrlo
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|i
)braket
dot
id|flagsize
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
id|ace_flush_jumbo_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_start_xmit
r_static
r_int
id|ace_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
id|u32
id|idx
comma
id|flagsize
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|dev-&gt;tbusy
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|idx
op_assign
id|ap-&gt;tx_prd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|TX_RING_ENTRIES
op_eq
id|ap-&gt;tx_ret_csm
)paren
(brace
id|ap-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: trying to transmit while the tx ring is full &quot;
l_string|&quot;- this should not happen!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
op_assign
id|skb
suffix:semicolon
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 64)
id|writel
c_func
(paren
id|addr
op_rshift
l_int|32
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr.addrhi
)paren
suffix:semicolon
macro_line|#endif
id|writel
c_func
(paren
id|addr
op_amp
l_int|0xffffffff
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr.addrlo
)paren
suffix:semicolon
id|flagsize
op_assign
(paren
id|skb-&gt;len
op_lshift
l_int|16
)paren
op_or
(paren
id|BD_FLG_END
)paren
suffix:semicolon
id|writel
c_func
(paren
id|flagsize
comma
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|flagsize
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|TX_RING_ENTRIES
suffix:semicolon
id|ap-&gt;tx_prd
op_assign
id|idx
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;TxPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * tx_csm is set by the NIC whereas we set tx_ret_csm which&n;&t; * is always trying to catch tx_csm&n;&t; */
r_if
c_cond
(paren
(paren
id|idx
op_plus
l_int|2
)paren
op_mod
id|TX_RING_ENTRIES
op_eq
id|ap-&gt;tx_ret_csm
)paren
(brace
id|ap-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Queue is full, add timer to detect whether the&n;&t;&t; * transmitter is stuck. Use mod_timer as we can get&n;&t;&t; * into the situation where we risk adding several&n;&t;&t; * timers.&n;&t;&t; */
id|mod_timer
c_func
(paren
op_amp
id|ap-&gt;timer
comma
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * No need for it to be atomic - seems it needs to be&n;&t;&t; */
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|dev-&gt;tbusy
)paren
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_change_mtu
r_static
r_int
id|ace_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_mtu
OL
l_int|68
)paren
op_logical_or
(paren
id|new_mtu
OG
id|ACE_JUMBO_MTU
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|writel
c_func
(paren
id|new_mtu
op_plus
id|ETH_HLEN
op_plus
l_int|4
comma
op_amp
id|regs-&gt;IfMtu
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_if
c_cond
(paren
id|new_mtu
OG
id|ACE_STD_MTU
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;jumbo
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling Jumbo frame &quot;
l_string|&quot;support&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;jumbo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
)paren
suffix:semicolon
)brace
id|ap-&gt;jumbo
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
(brace
id|ace_flush_jumbo_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Disabling Jumbo frame support&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|ap-&gt;jumbo
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_ioctl
r_static
r_int
id|ace_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
macro_line|#ifdef ETHTOOL
r_struct
id|ace_private
op_star
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_struct
id|ethtool_cmd
id|ecmd
suffix:semicolon
id|u32
id|link
comma
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|SIOCETHTOOL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ecmd
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.cmd
op_eq
id|ETH_GSET
)paren
(brace
id|ecmd.supported
op_assign
(paren
id|SUPPORTED_10baseT_Half
op_or
id|SUPPORTED_10baseT_Full
op_or
id|SUPPORTED_100baseT_Half
op_or
id|SUPPORTED_100baseT_Full
op_or
id|SUPPORTED_1000baseT_Half
op_or
id|SUPPORTED_1000baseT_Full
op_or
id|SUPPORTED_Autoneg
op_or
id|SUPPORTED_FIBRE
)paren
suffix:semicolon
id|ecmd.port
op_assign
id|PORT_FIBRE
suffix:semicolon
id|ecmd.transceiver
op_assign
id|XCVR_INTERNAL
suffix:semicolon
id|ecmd.phy_address
op_assign
l_int|0
suffix:semicolon
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;GigLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_1000MB
)paren
id|ecmd.speed
op_assign
id|SPEED_1000
suffix:semicolon
r_else
(brace
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;FastLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|ecmd.speed
op_assign
id|SPEED_100
suffix:semicolon
r_else
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|ecmd.speed
op_assign
id|SPEED_10
suffix:semicolon
r_else
id|ecmd.speed
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link
op_amp
id|LNK_FULL_DUPLEX
)paren
id|ecmd.duplex
op_assign
id|DUPLEX_FULL
suffix:semicolon
r_else
id|ecmd.duplex
op_assign
id|DUPLEX_HALF
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_NEGOTIATE
)paren
id|ecmd.autoneg
op_assign
id|AUTONEG_ENABLE
suffix:semicolon
r_else
id|ecmd.autoneg
op_assign
id|AUTONEG_DISABLE
suffix:semicolon
id|ecmd.trace
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneTrace
)paren
suffix:semicolon
id|ecmd.txcoal
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
id|ecmd.rxcoal
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
id|ecmd.maxtxpkt
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
id|ecmd.maxrxpkt
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|ecmd
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ecmd.cmd
op_eq
id|ETH_SSET
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;GigLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_1000MB
)paren
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
r_else
(brace
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;FastLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|speed
op_assign
id|SPEED_100
suffix:semicolon
r_else
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|speed
op_assign
id|SPEED_10
suffix:semicolon
r_else
id|speed
op_assign
id|SPEED_100
suffix:semicolon
)brace
id|link
op_assign
id|LNK_ENABLE
op_or
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
op_or
id|LNK_RX_FLOW_CTL_Y
op_or
id|LNK_NEG_FCTL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|link
op_or_assign
id|LNK_TX_FLOW_CTL_Y
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.autoneg
op_eq
id|AUTONEG_ENABLE
)paren
id|link
op_or_assign
id|LNK_NEGOTIATE
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.speed
op_ne
id|speed
)paren
(brace
id|link
op_and_assign
op_complement
(paren
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
id|SPEED_1000
suffix:colon
id|link
op_or_assign
id|LNK_1000MB
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPEED_100
suffix:colon
id|link
op_or_assign
id|LNK_100MB
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPEED_10
suffix:colon
id|link
op_or_assign
id|LNK_10MB
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ecmd.duplex
op_eq
id|DUPLEX_FULL
)paren
id|link
op_or_assign
id|LNK_FULL_DUPLEX
suffix:semicolon
r_if
c_cond
(paren
id|link
op_ne
id|ap-&gt;link
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Renegotiating link state&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;link
op_assign
id|link
suffix:semicolon
id|writel
c_func
(paren
id|link
comma
op_amp
id|regs-&gt;TuneLink
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|writel
c_func
(paren
id|link
comma
op_amp
id|regs-&gt;TuneFastLink
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_LNK_NEGOTIATION
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the hardware MAC address.&n; */
DECL|function|ace_set_mac_addr
r_static
r_int
id|ace_set_mac_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|sockaddr
op_star
id|addr
op_assign
id|p
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
id|u16
op_star
id|da
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;start
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|da
op_assign
(paren
id|u16
op_star
)paren
id|dev-&gt;dev_addr
suffix:semicolon
id|regs
op_assign
(paren
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|regs
suffix:semicolon
id|writel
c_func
(paren
id|da
(braket
l_int|0
)braket
comma
op_amp
id|regs-&gt;MacAddrHi
)paren
suffix:semicolon
id|writel
c_func
(paren
(paren
id|da
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
id|da
(braket
l_int|2
)braket
comma
op_amp
id|regs-&gt;MacAddrLo
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_MAC_ADDR
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_set_multicast_list
r_static
r_void
id|ace_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
op_logical_neg
(paren
id|ap-&gt;mcast_all
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;mcast_all
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;mcast_all
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;mcast_all
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
op_logical_neg
(paren
id|ap-&gt;promisc
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
id|ap-&gt;promisc
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For the time being multicast relies on the upper layers&n;&t; * filtering it properly. The Firmware does not allow one to&n;&t; * set the entire multicast list at a time and keeping track of&n;&t; * it here is going to be messy.&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;mc_count
)paren
op_logical_and
op_logical_neg
(paren
id|ap-&gt;mcast_all
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;mcast_all
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
)brace
DECL|function|ace_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|ace_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|ap-&gt;stats
suffix:semicolon
)brace
DECL|function|ace_copy
r_void
id|__init
id|ace_copy
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
r_void
op_star
id|src
comma
id|u32
id|dest
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|tdest
suffix:semicolon
id|u32
op_star
id|wsrc
suffix:semicolon
r_int
id|tsize
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|tsize
op_assign
id|min
c_func
(paren
(paren
(paren
op_complement
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
)paren
comma
id|min
c_func
(paren
id|size
comma
id|ACE_WINDOW_SIZE
)paren
)paren
suffix:semicolon
id|tdest
op_assign
(paren
r_int
r_int
)paren
op_amp
id|regs-&gt;Window
op_plus
(paren
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|dest
op_amp
op_complement
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
comma
op_amp
id|regs-&gt;WinBase
)paren
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
macro_line|#error &quot;data must be swapped here&quot;
macro_line|#else
id|wsrc
op_assign
id|src
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|tsize
op_div
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
id|wsrc
(braket
id|i
)braket
comma
id|tdest
op_plus
id|i
op_star
l_int|4
)paren
suffix:semicolon
)brace
macro_line|#endif
id|dest
op_add_assign
id|tsize
suffix:semicolon
id|src
op_add_assign
id|tsize
suffix:semicolon
id|size
op_sub_assign
id|tsize
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|ace_clear
r_void
id|__init
id|ace_clear
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
id|u32
id|dest
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|tdest
suffix:semicolon
r_int
id|tsize
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|tsize
op_assign
id|min
c_func
(paren
(paren
(paren
op_complement
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
)paren
comma
id|min
c_func
(paren
id|size
comma
id|ACE_WINDOW_SIZE
)paren
)paren
suffix:semicolon
id|tdest
op_assign
(paren
r_int
r_int
)paren
op_amp
id|regs-&gt;Window
op_plus
(paren
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|dest
op_amp
op_complement
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
comma
op_amp
id|regs-&gt;WinBase
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|tsize
op_div
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
l_int|0
comma
id|tdest
op_plus
id|i
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|dest
op_add_assign
id|tsize
suffix:semicolon
id|size
op_sub_assign
id|tsize
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Download the firmware into the SRAM on the NIC&n; *&n; * This operation requires the NIC to be halted and is performed with&n; * interrupts disabled and with the spinlock hold.&n; */
DECL|function|ace_load_firmware
r_int
id|__init
id|ace_load_firmware
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_amp
id|CPU_HALTED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: trying to download firmware while the &quot;
l_string|&quot;CPU is running!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do not try to clear more than 512KB or we end up seeing&n;&t; * funny things on NICs with only 512KB SRAM&n;&t; */
id|ace_clear
c_func
(paren
id|regs
comma
l_int|0x2000
comma
l_int|0x80000
op_minus
l_int|0x2000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
id|ace_copy
c_func
(paren
id|regs
comma
id|tigonFwText
comma
id|tigonFwTextAddr
comma
id|tigonFwTextLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigonFwData
comma
id|tigonFwDataAddr
comma
id|tigonFwDataLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigonFwRodata
comma
id|tigonFwRodataAddr
comma
id|tigonFwRodataLen
)paren
suffix:semicolon
id|ace_clear
c_func
(paren
id|regs
comma
id|tigonFwBssAddr
comma
id|tigonFwBssLen
)paren
suffix:semicolon
id|ace_clear
c_func
(paren
id|regs
comma
id|tigonFwSbssAddr
comma
id|tigonFwSbssLen
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;version
op_eq
l_int|2
)paren
(brace
id|ace_clear
c_func
(paren
id|regs
comma
id|tigon2FwBssAddr
comma
id|tigon2FwBssLen
)paren
suffix:semicolon
id|ace_clear
c_func
(paren
id|regs
comma
id|tigon2FwSbssAddr
comma
id|tigon2FwSbssLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigon2FwText
comma
id|tigon2FwTextAddr
comma
id|tigon2FwTextLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigon2FwRodata
comma
id|tigon2FwRodataAddr
comma
id|tigon2FwRodataLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigon2FwData
comma
id|tigon2FwDataAddr
comma
id|tigon2FwDataLen
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The eeprom on the AceNIC is an Atmel i2c EEPROM.&n; *&n; * Accessing the EEPROM is `interesting&squot; to say the least - don&squot;t read&n; * this code right after dinner.&n; *&n; * This is all about black magic and bit-banging the device .... I&n; * wonder in what hospital they have put the guy who designed the i2c&n; * specs.&n; *&n; * Oh yes, this is only the beginning!&n; */
DECL|function|eeprom_start
r_static
r_void
id|__init
id|eeprom_start
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
)paren
(brace
id|u32
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_DATA_OUT
op_or
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|eeprom_prep
r_static
r_void
id|__init
id|eeprom_prep
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
id|u8
id|magic
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|local
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|local
op_or_assign
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|magic
op_lshift_assign
l_int|1
)paren
(brace
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|magic
op_amp
l_int|0x80
)paren
id|local
op_or_assign
id|EEPROM_DATA_OUT
suffix:semicolon
r_else
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
(paren
id|EEPROM_CLK_OUT
op_or
id|EEPROM_DATA_OUT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|eeprom_check_ack
r_static
r_int
id|__init
id|eeprom_check_ack
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
)paren
(brace
r_int
id|state
suffix:semicolon
id|u32
id|local
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* sample data in middle of high clk */
id|state
op_assign
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
id|EEPROM_DATA_IN
)paren
op_ne
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
op_complement
id|EEPROM_CLK_OUT
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|state
suffix:semicolon
)brace
DECL|function|eeprom_stop
r_static
r_void
id|__init
id|eeprom_stop
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
)paren
(brace
id|u32
id|local
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a whole byte from the EEPROM.&n; */
DECL|function|read_eeprom_byte
r_static
id|u8
id|__init
id|read_eeprom_byte
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
r_int
r_int
id|offset
)paren
(brace
id|u32
id|local
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u8
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|regs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No regs!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|eeprom_start
c_func
(paren
id|regs
)paren
suffix:semicolon
id|eeprom_prep
c_func
(paren
id|regs
comma
id|EEPROM_WRITE_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to sync eeprom&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|eeprom_prep
c_func
(paren
id|regs
comma
(paren
id|offset
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|eeprom_prep
c_func
(paren
id|regs
comma
id|offset
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|eeprom_start
c_func
(paren
id|regs
)paren
suffix:semicolon
id|eeprom_prep
c_func
(paren
id|regs
comma
id|EEPROM_READ_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sample data mid high clk */
id|result
op_assign
(paren
id|result
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
id|EEPROM_DATA_IN
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|7
)paren
(brace
id|local
op_or_assign
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|local
op_or_assign
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_or
id|EEPROM_CLK_OUT
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
op_complement
id|EEPROM_CLK_OUT
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|eeprom_stop
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Local variables:&n; * compile-command: &quot;gcc -D__SMP__ -D__KERNEL__ -DMODULE -I../../include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -pipe -fno-strength-reduce -DMODVERSIONS -include ../../include/linux/modversions.h   -c -o acenic.o acenic.c&quot;&n; * End:&n; */
eof
