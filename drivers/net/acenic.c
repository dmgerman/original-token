multiline_comment|/*&n; * acenic.c: Linux driver for the Alteon AceNIC Gigabit Ethernet card&n; *           and other Tigon based cards.&n; *&n; * Copyright 1998-2000 by Jes Sorensen, &lt;jes@linuxcare.com&gt;.&n; *&n; * Thanks to Alteon and 3Com for providing hardware and documentation&n; * enabling me to write this driver.&n; *&n; * A mailing list for discussing the use of this driver has been&n; * setup, please subscribe to the lists if you have any questions&n; * about the driver. Send mail to linux-acenic-help@sunsite.auc.dk to&n; * see how to subscribe.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * Additional credits:&n; *   Pete Wyckoff &lt;wyckoff@ca.sandia.gov&gt;: Initial Linux/Alpha and trace&n; *       dump support. The trace dump support has not been&n; *       integrated yet however.&n; *   Troy Benjegerdes: Big Endian (PPC) patches.&n; *   Nate Stahl: Better out of memory handling and stats support.&n; *   Aman Singla: Nasty race between interrupt handler and tx code dealing&n; *                with &squot;testing the tx_ret_csm and setting tx_full&squot;&n; *   David S. Miller &lt;davem@redhat.com&gt;: conversion to new PCI dma mapping&n; *                                       infrastructure and Sparc support&n; *   Pierrick Pinasseau (CERN): For lending me an Ultra 5 to test the&n; *                              driver under Linux/Sparc64&n; *   Matt Domsch &lt;Matt_Domsch@dell.com&gt;: Detect Alteon 1000baseT cards&n; *   Chip Salzenberg &lt;chip@valinux.com&gt;: Fix race condition between tx&n; *                                       handler and close() cleanup.&n; *   Ken Aaker &lt;kdaaker@rchland.vnet.ibm.com&gt;: Correct check for whether&n; *                                       memory mapped IO is enabled to&n; *                                       make the driver work on RS/6000.&n; *   Takayoshi Kouchi &lt;kouchi@hpc.bs1.fc.nec.co.jp&gt;: Identifying problem&n; *                                       where the driver would disable&n; *                                       bus master mode if it had to disable&n; *                                       write and invalidate.&n; *   Stephen Hack &lt;stephen_hack@hp.com&gt;: Fixed ace_set_mac_addr for little&n; *                                       endian systems.&n; *   Val Henson &lt;vhenson@esscom.com&gt;:    Reset Jumbo skb producer and&n; *                                       rx producer index when&n; *                                       flushing the Jumbo ring.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#ifdef SIOCETHTOOL
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#endif
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|INDEX_DEBUG
macro_line|#undef INDEX_DEBUG
DECL|macro|TX_HOST_RING
mdefine_line|#define TX_HOST_RING&t;1
macro_line|#ifdef CONFIG_ACENIC_OMIT_TIGON_I
DECL|macro|ACE_IS_TIGON_I
mdefine_line|#define ACE_IS_TIGON_I(ap)&t;0
macro_line|#else
DECL|macro|ACE_IS_TIGON_I
mdefine_line|#define ACE_IS_TIGON_I(ap)&t;(ap-&gt;version == 1)
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_ALTEON
DECL|macro|PCI_VENDOR_ID_ALTEON
mdefine_line|#define PCI_VENDOR_ID_ALTEON&t;&t;0x12ae&t;
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_ALTEON_ACENIC_FIBRE
DECL|macro|PCI_DEVICE_ID_ALTEON_ACENIC_FIBRE
mdefine_line|#define PCI_DEVICE_ID_ALTEON_ACENIC_FIBRE  0x0001
DECL|macro|PCI_DEVICE_ID_ALTEON_ACENIC_COPPER
mdefine_line|#define PCI_DEVICE_ID_ALTEON_ACENIC_COPPER 0x0002
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_3COM_3C985
DECL|macro|PCI_DEVICE_ID_3COM_3C985
mdefine_line|#define PCI_DEVICE_ID_3COM_3C985&t;0x0001
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_NETGEAR
DECL|macro|PCI_VENDOR_ID_NETGEAR
mdefine_line|#define PCI_VENDOR_ID_NETGEAR&t;&t;0x1385
DECL|macro|PCI_DEVICE_ID_NETGEAR_GA620
mdefine_line|#define PCI_DEVICE_ID_NETGEAR_GA620&t;0x620a
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_NETGEAR_GA620T
DECL|macro|PCI_DEVICE_ID_NETGEAR_GA620T
mdefine_line|#define PCI_DEVICE_ID_NETGEAR_GA620T&t;0x630a
macro_line|#endif
multiline_comment|/*&n; * Farallon used the DEC vendor ID by mistake and they seem not&n; * to care - stinky!&n; */
macro_line|#ifndef PCI_DEVICE_ID_FARALLON_PN9000SX
DECL|macro|PCI_DEVICE_ID_FARALLON_PN9000SX
mdefine_line|#define PCI_DEVICE_ID_FARALLON_PN9000SX&t;0x1a
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_SGI
DECL|macro|PCI_VENDOR_ID_SGI
mdefine_line|#define PCI_VENDOR_ID_SGI&t;&t;0x10a9
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_SGI_ACENIC
DECL|macro|PCI_DEVICE_ID_SGI_ACENIC
mdefine_line|#define PCI_DEVICE_ID_SGI_ACENIC&t;0x0009
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20400
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|acenic_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_ALTEON
comma
id|PCI_DEVICE_ID_ALTEON_ACENIC_FIBRE
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_ALTEON
comma
id|PCI_DEVICE_ID_ALTEON_ACENIC_COPPER
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_3COM
comma
id|PCI_DEVICE_ID_3COM_3C985
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_NETGEAR
comma
id|PCI_DEVICE_ID_NETGEAR_GA620
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_NETGEAR
comma
id|PCI_DEVICE_ID_NETGEAR_GA620T
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
multiline_comment|/*&n;&t; * Farallon used the DEC vendor ID on their cards incorrectly.&n;&t; */
(brace
id|PCI_VENDOR_ID_DEC
comma
id|PCI_DEVICE_ID_FARALLON_PN9000SX
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_SGI
comma
id|PCI_DEVICE_ID_SGI_ACENIC
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
l_int|0xffff00
comma
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|acenic_pci_tbl
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef wmb
DECL|macro|wmb
mdefine_line|#define wmb()&t;mb()
macro_line|#endif
macro_line|#ifndef __exit
DECL|macro|__exit
mdefine_line|#define __exit
macro_line|#endif
macro_line|#ifndef SMP_CACHE_BYTES
DECL|macro|SMP_CACHE_BYTES
mdefine_line|#define SMP_CACHE_BYTES&t;L1_CACHE_BYTES
macro_line|#endif
macro_line|#if (BITS_PER_LONG == 64)
DECL|macro|ACE_64BIT_PTR
mdefine_line|#define ACE_64BIT_PTR&t;1
macro_line|#endif
macro_line|#ifndef SET_MODULE_OWNER
DECL|macro|SET_MODULE_OWNER
mdefine_line|#define SET_MODULE_OWNER(dev)&t;&t;{do{} while(0);}
DECL|macro|ACE_MOD_INC_USE_COUNT
mdefine_line|#define ACE_MOD_INC_USE_COUNT&t;&t;MOD_INC_USE_COUNT
DECL|macro|ACE_MOD_DEC_USE_COUNT
mdefine_line|#define ACE_MOD_DEC_USE_COUNT&t;&t;MOD_DEC_USE_COUNT
macro_line|#else
DECL|macro|ACE_MOD_INC_USE_COUNT
mdefine_line|#define ACE_MOD_INC_USE_COUNT&t;&t;{do{} while(0);}
DECL|macro|ACE_MOD_DEC_USE_COUNT
mdefine_line|#define ACE_MOD_DEC_USE_COUNT&t;&t;{do{} while(0);}
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02030d)
DECL|macro|pci_resource_start
mdefine_line|#define pci_resource_start(dev, bar)&t;dev-&gt;base_address[bar]
macro_line|#elif (LINUX_VERSION_CODE &lt; 0x02032c)
DECL|macro|pci_resource_start
mdefine_line|#define pci_resource_start(dev, bar)&t;dev-&gt;resource[bar].start
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02030e)
DECL|macro|net_device
mdefine_line|#define net_device device
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02032a)
DECL|typedef|dma_addr_t
r_typedef
id|u32
id|dma_addr_t
suffix:semicolon
DECL|function|pci_alloc_consistent
r_static
r_inline
r_void
op_star
id|pci_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_void
op_star
id|virt_ptr
suffix:semicolon
id|virt_ptr
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
op_star
id|dma_handle
op_assign
id|virt_to_bus
c_func
(paren
id|virt_ptr
)paren
suffix:semicolon
r_return
id|virt_ptr
suffix:semicolon
)brace
DECL|macro|pci_free_consistent
mdefine_line|#define pci_free_consistent(cookie, size, ptr, dma_ptr)&t;kfree(ptr)
DECL|macro|pci_map_single
mdefine_line|#define pci_map_single(cookie, address, size, dir)&t;virt_to_bus(address)
DECL|macro|pci_unmap_single
mdefine_line|#define pci_unmap_single(cookie, address, size, dir)
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02032b)
multiline_comment|/*&n; * SoftNet&n; *&n; * For pre-softnet kernels we need to tell the upper layer not to&n; * re-enter start_xmit() while we are in there. However softnet&n; * guarantees not to enter while we are in there so there is no need&n; * to do the netif_stop_queue() dance unless the transmit queue really&n; * gets stuck. This should also improve performance according to tests&n; * done by Aman Singla.&n; */
DECL|macro|dev_kfree_skb_irq
mdefine_line|#define dev_kfree_skb_irq(a)&t;&t;&t;dev_kfree_skb(a)
DECL|macro|netif_wake_queue
mdefine_line|#define netif_wake_queue(dev)&t;&t;&t;clear_bit(0, &amp;dev-&gt;tbusy)
DECL|macro|netif_stop_queue
mdefine_line|#define netif_stop_queue(dev)&t;&t;&t;set_bit(0, &amp;dev-&gt;tbusy)
DECL|macro|late_stop_netif_stop_queue
mdefine_line|#define late_stop_netif_stop_queue(dev)&t;&t;{do{} while(0);}
DECL|macro|early_stop_netif_stop_queue
mdefine_line|#define early_stop_netif_stop_queue(dev)&t;test_and_set_bit(0,&amp;dev-&gt;tbusy)
DECL|macro|early_stop_netif_wake_queue
mdefine_line|#define early_stop_netif_wake_queue(dev)&t;netif_wake_queue(dev)
DECL|function|netif_start_queue
r_static
r_inline
r_void
id|netif_start_queue
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
)brace
DECL|macro|ace_mark_net_bh
mdefine_line|#define ace_mark_net_bh()&t;&t;&t;mark_bh(NET_BH)
DECL|macro|netif_queue_stopped
mdefine_line|#define netif_queue_stopped(dev)&t;&t;dev-&gt;tbusy
DECL|macro|netif_running
mdefine_line|#define netif_running(dev)&t;&t;&t;dev-&gt;start
DECL|macro|ace_if_down
mdefine_line|#define ace_if_down(dev)&t;&t;&t;{do{dev-&gt;start = 0;} while(0);}
DECL|macro|tasklet_struct
mdefine_line|#define tasklet_struct&t;&t;&t;&t;tq_struct
DECL|function|tasklet_schedule
r_static
r_inline
r_void
id|tasklet_schedule
c_func
(paren
r_struct
id|tasklet_struct
op_star
id|tasklet
)paren
(brace
id|queue_task
c_func
(paren
id|tasklet
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
DECL|function|tasklet_init
r_static
r_inline
r_void
id|tasklet_init
c_func
(paren
r_struct
id|tasklet_struct
op_star
id|tasklet
comma
r_void
(paren
op_star
id|func
)paren
(paren
r_int
r_int
)paren
comma
r_int
r_int
id|data
)paren
(brace
id|tasklet-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tasklet-&gt;sync
op_assign
l_int|0
suffix:semicolon
id|tasklet-&gt;routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|func
suffix:semicolon
id|tasklet-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|data
suffix:semicolon
)brace
DECL|macro|tasklet_kill
mdefine_line|#define tasklet_kill(tasklet)&t;&t;&t;{do{} while(0);}
macro_line|#else
DECL|macro|late_stop_netif_stop_queue
mdefine_line|#define late_stop_netif_stop_queue(dev)&t;&t;netif_stop_queue(dev)
DECL|macro|early_stop_netif_stop_queue
mdefine_line|#define early_stop_netif_stop_queue(dev)&t;0
DECL|macro|early_stop_netif_wake_queue
mdefine_line|#define early_stop_netif_wake_queue(dev)&t;{do{} while(0);}
DECL|macro|ace_mark_net_bh
mdefine_line|#define ace_mark_net_bh()&t;&t;&t;{do{} while(0);}
DECL|macro|ace_if_down
mdefine_line|#define ace_if_down(dev)&t;&t;&t;{do{} while(0);}
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02031b)
DECL|macro|NEW_NETINIT
mdefine_line|#define NEW_NETINIT
DECL|macro|ACE_PROBE_ARG
mdefine_line|#define ACE_PROBE_ARG&t;&t;&t;&t;void
macro_line|#else
DECL|macro|ACE_PROBE_ARG
mdefine_line|#define ACE_PROBE_ARG&t;&t;&t;&t;struct net_device *dev
macro_line|#endif
DECL|macro|ACE_MAX_MOD_PARMS
mdefine_line|#define ACE_MAX_MOD_PARMS&t;8
DECL|macro|BOARD_IDX_STATIC
mdefine_line|#define BOARD_IDX_STATIC&t;0
DECL|macro|BOARD_IDX_OVERFLOW
mdefine_line|#define BOARD_IDX_OVERFLOW&t;-1
macro_line|#include &quot;acenic.h&quot;
multiline_comment|/*&n; * These must be defined before the firmware is included.&n; */
DECL|macro|MAX_TEXT_LEN
mdefine_line|#define MAX_TEXT_LEN&t;96*1024
DECL|macro|MAX_RODATA_LEN
mdefine_line|#define MAX_RODATA_LEN&t;8*1024
DECL|macro|MAX_DATA_LEN
mdefine_line|#define MAX_DATA_LEN&t;2*1024
macro_line|#include &quot;acenic_firmware.h&quot;
multiline_comment|/*&n; * This driver currently supports Tigon I and Tigon II based cards&n; * including the Alteon AceNIC, the 3Com 3C985[B] and NetGear&n; * GA620. The driver should also work on the SGI, DEC and Farallon&n; * versions of the card, however I have not been able to test that&n; * myself.&n; *&n; * This card is really neat, it supports receive hardware checksumming&n; * and jumbo frames (up to 9000 bytes) and does a lot of work in the&n; * firmware. Also the programming interface is quite neat, except for&n; * the parts dealing with the i2c eeprom on the card ;-)&n; *&n; * Using jumbo frames:&n; *&n; * To enable jumbo frames, simply specify an mtu between 1500 and 9000&n; * bytes to ifconfig. Jumbo frames can be enabled or disabled at any time&n; * by running `ifconfig eth&lt;X&gt; mtu &lt;MTU&gt;&squot; with &lt;X&gt; being the Ethernet&n; * interface number and &lt;MTU&gt; being the MTU value.&n; *&n; * Module parameters:&n; *&n; * When compiled as a loadable module, the driver allows for a number&n; * of module parameters to be specified. The driver supports the&n; * following module parameters:&n; *&n; *  trace=&lt;val&gt; - Firmware trace level. This requires special traced&n; *                firmware to replace the firmware supplied with&n; *                the driver - for debugging purposes only.&n; *&n; *  link=&lt;val&gt;  - Link state. Normally you want to use the default link&n; *                parameters set by the driver. This can be used to&n; *                override these in case your switch doesn&squot;t negotiate&n; *                the link properly. Valid values are:&n; *         0x0001 - Force half duplex link.&n; *         0x0002 - Do not negotiate line speed with the other end.&n; *         0x0010 - 10Mbit/sec link.&n; *         0x0020 - 100Mbit/sec link.&n; *         0x0040 - 1000Mbit/sec link.&n; *         0x0100 - Do not negotiate flow control.&n; *         0x0200 - Enable RX flow control Y&n; *         0x0400 - Enable TX flow control Y (Tigon II NICs only).&n; *                Default value is 0x0270, ie. enable link+flow&n; *                control negotiation. Negotiating the highest&n; *                possible link speed with RX flow control enabled.&n; *&n; *                When disabling link speed negotiation, only one link&n; *                speed is allowed to be specified!&n; *&n; *  tx_coal_tick=&lt;val&gt; - number of coalescing clock ticks (us) allowed&n; *                to wait for more packets to arive before&n; *                interrupting the host, from the time the first&n; *                packet arrives.&n; *&n; *  rx_coal_tick=&lt;val&gt; - number of coalescing clock ticks (us) allowed&n; *                to wait for more packets to arive in the transmit ring,&n; *                before interrupting the host, after transmitting the&n; *                first packet in the ring.&n; *&n; *  max_tx_desc=&lt;val&gt; - maximum number of transmit descriptors&n; *                (packets) transmitted before interrupting the host.&n; *&n; *  max_rx_desc=&lt;val&gt; - maximum number of receive descriptors&n; *                (packets) received before interrupting the host.&n; *&n; *  tx_ratio=&lt;val&gt; - 7 bit value (0 - 63) specifying the split in 64th&n; *                increments of the NIC&squot;s on board memory to be used for&n; *                transmit and receive buffers. For the 1MB NIC app. 800KB&n; *                is available, on the 1/2MB NIC app. 300KB is available.&n; *                68KB will always be available as a minimum for both&n; *                directions. The default value is a 50/50 split.&n; *  dis_pci_mem_inval=&lt;val&gt; - disable PCI memory write and invalidate&n; *                operations, default (1) is to always disable this as&n; *                that is what Alteon does on NT. I have not been able&n; *                to measure any real performance differences with&n; *                this on my systems. Set &lt;val&gt;=0 if you want to&n; *                enable these operations.&n; *&n; * If you use more than one NIC, specify the parameters for the&n; * individual NICs with a comma, ie. trace=0,0x00001fff,0 you want to&n; * run tracing on NIC #2 but not on NIC #1 and #3.&n; *&n; * TODO:&n; *&n; * - Proper multicast support.&n; * - NIC dump support.&n; * - More tuning parameters.&n; *&n; * The mini ring is not used under Linux and I am not sure it makes sense&n; * to actually use it.&n; *&n; * New interrupt handler strategy:&n; *&n; * The old interrupt handler worked using the traditional method of&n; * replacing an skbuff with a new one when a packet arrives. However&n; * the rx rings do not need to contain a static number of buffer&n; * descriptors, thus it makes sense to move the memory allocation out&n; * of the main interrupt handler and do it in a bottom half handler&n; * and only allocate new buffers when the number of buffers in the&n; * ring is below a certain threshold. In order to avoid starving the&n; * NIC under heavy load it is however necessary to force allocation&n; * when hitting a minimum threshold. The strategy for alloction is as&n; * follows:&n; *&n; *     RX_LOW_BUF_THRES    - allocate buffers in the bottom half&n; *     RX_PANIC_LOW_THRES  - we are very low on buffers, allocate&n; *                           the buffers in the interrupt handler&n; *     RX_RING_THRES       - maximum number of buffers in the rx ring&n; *     RX_MINI_THRES       - maximum number of buffers in the mini ring&n; *     RX_JUMBO_THRES      - maximum number of buffers in the jumbo ring&n; *&n; * One advantagous side effect of this allocation approach is that the&n; * entire rx processing can be done without holding any spin lock&n; * since the rx rings and registers are totally independant of the tx&n; * ring and its registers.  This of course includes the kmalloc&squot;s of&n; * new skb&squot;s. Thus start_xmit can run in parallel with rx processing&n; * and the memory allocation on SMP systems.&n; *&n; * Note that running the skb reallocation in a bottom half opens up&n; * another can of races which needs to be handled properly. In&n; * particular it can happen that the interrupt handler tries to run&n; * the reallocation while the bottom half is either running on another&n; * CPU or was interrupted on the same CPU. To get around this the&n; * driver uses bitops to prevent the reallocation routines from being&n; * reentered.&n; *&n; * TX handling can also be done without holding any spin lock, wheee&n; * this is fun! since tx_ret_csm is only written to by the interrupt&n; * handler. The case to be aware of is when shutting down the device&n; * and cleaning up where it is necessary to make sure that&n; * start_xmit() is not running while this is happening. Well DaveM&n; * informs me that this case is already protected against ... bye bye&n; * Mr. Spin Lock, it was nice to know you.&n; *&n; * TX interrupts are now partly disabled so the NIC will only generate&n; * TX interrupts for the number of coal ticks, not for the number of&n; * TX packets in the queue. This should reduce the number of TX only,&n; * ie. when no RX processing is done, interrupts seen.&n; */
multiline_comment|/*&n; * Threshold values for RX buffer allocation - the low water marks for&n; * when to start refilling the rings are set to 75% of the ring&n; * sizes. It seems to make sense to refill the rings entirely from the&n; * intrrupt handler once it gets below the panic threshold, that way&n; * we don&squot;t risk that the refilling is moved to another CPU when the&n; * one running the interrupt handler just got the slab code hot in its&n; * cache.&n; */
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;72
DECL|macro|RX_MINI_SIZE
mdefine_line|#define RX_MINI_SIZE&t;&t;64
DECL|macro|RX_JUMBO_SIZE
mdefine_line|#define RX_JUMBO_SIZE&t;&t;48
DECL|macro|RX_PANIC_STD_THRES
mdefine_line|#define RX_PANIC_STD_THRES&t;16
DECL|macro|RX_PANIC_STD_REFILL
mdefine_line|#define RX_PANIC_STD_REFILL&t;(3*RX_PANIC_STD_THRES)/2
DECL|macro|RX_LOW_STD_THRES
mdefine_line|#define RX_LOW_STD_THRES&t;(3*RX_RING_SIZE)/4
DECL|macro|RX_PANIC_MINI_THRES
mdefine_line|#define RX_PANIC_MINI_THRES&t;12
DECL|macro|RX_PANIC_MINI_REFILL
mdefine_line|#define RX_PANIC_MINI_REFILL&t;(3*RX_PANIC_MINI_THRES)/2
DECL|macro|RX_LOW_MINI_THRES
mdefine_line|#define RX_LOW_MINI_THRES&t;(3*RX_MINI_SIZE)/4
DECL|macro|RX_PANIC_JUMBO_THRES
mdefine_line|#define RX_PANIC_JUMBO_THRES&t;6
DECL|macro|RX_PANIC_JUMBO_REFILL
mdefine_line|#define RX_PANIC_JUMBO_REFILL&t;(3*RX_PANIC_JUMBO_THRES)/2
DECL|macro|RX_LOW_JUMBO_THRES
mdefine_line|#define RX_LOW_JUMBO_THRES&t;(3*RX_JUMBO_SIZE)/4
multiline_comment|/*&n; * Size of the mini ring entries, basically these just should be big&n; * enough to take TCP ACKs&n; */
DECL|macro|ACE_MINI_SIZE
mdefine_line|#define ACE_MINI_SIZE&t;&t;100
DECL|macro|ACE_MINI_BUFSIZE
mdefine_line|#define ACE_MINI_BUFSIZE&t;(ACE_MINI_SIZE + 2 + 16)
DECL|macro|ACE_STD_BUFSIZE
mdefine_line|#define ACE_STD_BUFSIZE&t;&t;(ACE_STD_MTU + ETH_HLEN + 2+4+16)
DECL|macro|ACE_JUMBO_BUFSIZE
mdefine_line|#define ACE_JUMBO_BUFSIZE&t;(ACE_JUMBO_MTU + ETH_HLEN + 2+4+16)
multiline_comment|/*&n; * There seems to be a magic difference in the effect between 995 and 996&n; * but little difference between 900 and 995 ... no idea why.&n; *&n; * There is now a default set of tuning parameters which is set, depending&n; * on whether or not the user enables Jumbo frames. It&squot;s assumed that if&n; * Jumbo frames are enabled, the user wants optimal tuning for that case.&n; */
DECL|macro|DEF_TX_COAL
mdefine_line|#define DEF_TX_COAL&t;&t;400 /* 996 */
DECL|macro|DEF_TX_MAX_DESC
mdefine_line|#define DEF_TX_MAX_DESC&t;&t;40
DECL|macro|DEF_RX_COAL
mdefine_line|#define DEF_RX_COAL&t;&t;120 /* 1000 */
DECL|macro|DEF_RX_MAX_DESC
mdefine_line|#define DEF_RX_MAX_DESC&t;&t;25
DECL|macro|DEF_TX_RATIO
mdefine_line|#define DEF_TX_RATIO&t;&t;21 /* 24 */
DECL|macro|DEF_JUMBO_TX_COAL
mdefine_line|#define DEF_JUMBO_TX_COAL&t;20
DECL|macro|DEF_JUMBO_TX_MAX_DESC
mdefine_line|#define DEF_JUMBO_TX_MAX_DESC&t;60
DECL|macro|DEF_JUMBO_RX_COAL
mdefine_line|#define DEF_JUMBO_RX_COAL&t;30
DECL|macro|DEF_JUMBO_RX_MAX_DESC
mdefine_line|#define DEF_JUMBO_RX_MAX_DESC&t;6
DECL|macro|DEF_JUMBO_TX_RATIO
mdefine_line|#define DEF_JUMBO_TX_RATIO&t;21
DECL|macro|TX_COAL_INTS_ONLY
mdefine_line|#define TX_COAL_INTS_ONLY&t;0&t;/* seems not worth it */
DECL|macro|DEF_TRACE
mdefine_line|#define DEF_TRACE&t;&t;0
DECL|macro|DEF_STAT
mdefine_line|#define DEF_STAT&t;&t;(2 * TICKS_PER_SEC)
DECL|variable|link
r_static
r_int
id|link
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|trace
r_static
r_int
id|trace
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|tx_coal_tick
r_static
r_int
id|tx_coal_tick
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|rx_coal_tick
r_static
r_int
id|rx_coal_tick
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|max_tx_desc
r_static
r_int
id|max_tx_desc
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|max_rx_desc
r_static
r_int
id|max_rx_desc
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|tx_ratio
r_static
r_int
id|tx_ratio
(braket
id|ACE_MAX_MOD_PARMS
)braket
suffix:semicolon
DECL|variable|dis_pci_mem_inval
r_static
r_int
id|dis_pci_mem_inval
(braket
id|ACE_MAX_MOD_PARMS
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|version
(braket
)braket
id|__initdata
op_assign
l_string|&quot;acenic.c: v0.49 12/13/2000  Jes Sorensen, linux-acenic@SunSITE.auc.dk&bslash;n&quot;
l_string|&quot;                            http://home.cern.ch/~jes/gige/acenic.html&bslash;n&quot;
suffix:semicolon
DECL|variable|root_dev
r_static
r_struct
id|net_device
op_star
id|root_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|__initdata
r_static
r_int
id|probed
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|function|acenic_probe
r_int
id|__init
id|acenic_probe
(paren
id|ACE_PROBE_ARG
)paren
(brace
macro_line|#ifdef NEW_NETINIT
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
macro_line|#endif
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|boards_found
op_assign
l_int|0
suffix:semicolon
r_int
id|version_disp
suffix:semicolon
r_if
c_cond
(paren
id|probed
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|probed
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
multiline_comment|/* is PCI support present? */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|version_disp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
id|pdev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_ALTEON
)paren
op_logical_and
(paren
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_ALTEON_ACENIC_FIBRE
)paren
op_logical_or
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_ALTEON_ACENIC_COPPER
)paren
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_3COM
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_3COM_3C985
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_NETGEAR
)paren
op_logical_and
(paren
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_NETGEAR_GA620
)paren
op_logical_or
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_NETGEAR_GA620T
)paren
)paren
)paren
op_logical_and
multiline_comment|/*&n;&t;&t; * Farallon used the DEC vendor ID on their cards by&n;&t;&t; * mistake for a while&n;&t;&t; */
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_DEC
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_FARALLON_PN9000SX
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SGI
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_SGI_ACENIC
)paren
)paren
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|ace_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acenic: Unable to allocate &quot;
l_string|&quot;net_device structure!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acenic: Unable to allocate memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ap-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|dev-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|ace_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|ace_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|ace_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|ace_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|ace_set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|ace_ioctl
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
op_amp
id|ace_set_mac_addr
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
op_amp
id|ace_change_mtu
suffix:semicolon
multiline_comment|/* display version info if adapter is found */
r_if
c_cond
(paren
op_logical_neg
id|version_disp
)paren
(brace
multiline_comment|/* set display flag to TRUE so that */
multiline_comment|/* we only display this string ONCE */
id|version_disp
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enable master mode before we start playing with the&n;&t;&t; * pci_command word since pci_set_master() will modify&n;&t;&t; * it.&n;&t;&t; */
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|ap-&gt;pci_command
)paren
suffix:semicolon
multiline_comment|/* OpenFirmware on Mac&squot;s does not set this - DOH.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;pci_command
op_amp
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling PCI Memory Mapped &quot;
l_string|&quot;access - was not enabled by BIOS/Firmware&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;pci_command
op_assign
id|ap-&gt;pci_command
op_or
id|PCI_COMMAND_MEMORY
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_COMMAND
comma
id|ap-&gt;pci_command
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|ap-&gt;pci_latency
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;pci_latency
op_le
l_int|0x40
)paren
(brace
id|ap-&gt;pci_latency
op_assign
l_int|0x40
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
id|ap-&gt;pci_latency
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Remap the regs into kernel space - this is abuse of&n;&t;&t; * dev-&gt;base_addr since it was means for I/O port&n;&t;&t; * addresses but who gives a damn.&n;&t;&t; */
id|dev-&gt;base_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|ap-&gt;regs
op_assign
(paren
r_struct
id|ace_regs
op_star
)paren
id|ioremap
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|0x4000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;regs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s:  Unable to map I/O register, &quot;
l_string|&quot;AceNIC %i will be disabled.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|boards_found
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|pdev-&gt;vendor
)paren
(brace
r_case
id|PCI_VENDOR_ID_ALTEON
suffix:colon
id|strncpy
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;AceNIC Gigabit Ethernet&quot;
comma
r_sizeof
(paren
id|ap-&gt;name
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Alteon AceNIC &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_3COM
suffix:colon
id|strncpy
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;3Com 3C985 Gigabit Ethernet&quot;
comma
r_sizeof
(paren
id|ap-&gt;name
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: 3Com 3C985 &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_NETGEAR
suffix:colon
id|strncpy
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;NetGear GA620 Gigabit Ethernet&quot;
comma
r_sizeof
(paren
id|ap-&gt;name
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: NetGear GA620 &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_VENDOR_ID_DEC
suffix:colon
r_if
c_cond
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_FARALLON_PN9000SX
)paren
(brace
id|strncpy
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;Farallon PN9000-SX &quot;
l_string|&quot;Gigabit Ethernet&quot;
comma
r_sizeof
(paren
id|ap-&gt;name
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Farallon PN9000-SX &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PCI_VENDOR_ID_SGI
suffix:colon
id|strncpy
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;SGI AceNIC Gigabit Ethernet&quot;
comma
r_sizeof
(paren
id|ap-&gt;name
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: SGI AceNIC &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|strncpy
c_func
(paren
id|ap-&gt;name
comma
l_string|&quot;Unknown AceNIC based Gigabit &quot;
l_string|&quot;Ethernet&quot;
comma
r_sizeof
(paren
id|ap-&gt;name
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Unknown AceNIC &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ap-&gt;name
(braket
r_sizeof
(paren
id|ap-&gt;name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Gigabit Ethernet at 0x%08lx, &quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
l_string|&quot;irq %s&bslash;n&quot;
comma
id|__irq_itoa
c_func
(paren
id|dev-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;irq %i&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ACENIC_OMIT_TIGON_I
r_if
c_cond
(paren
(paren
id|readl
c_func
(paren
op_amp
id|ap-&gt;regs-&gt;HostCtrl
)paren
op_rshift
l_int|28
)paren
op_eq
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Driver compiled without Tigon I&quot;
l_string|&quot; support - NIC disabled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ace_init_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ace_allocate_descriptors
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|boards_found
op_ge
id|ACE_MAX_MOD_PARMS
)paren
id|ap-&gt;board_idx
op_assign
id|BOARD_IDX_OVERFLOW
suffix:semicolon
r_else
id|ap-&gt;board_idx
op_assign
id|boards_found
suffix:semicolon
macro_line|#else
id|ap-&gt;board_idx
op_assign
id|BOARD_IDX_STATIC
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ace_init
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|boards_found
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re at this point we&squot;re going through ace_probe() for&n;&t; * the first time.  Return success (0) if we&squot;ve initialized 1&n;&t; * or more boards. Otherwise, return failure (-ENODEV).&n;&t; */
r_if
c_cond
(paren
id|boards_found
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jes Sorensen &lt;jes@linuxcare.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;AceNIC/3C985/GA620 Gigabit Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|link
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|trace
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tx_coal_tick
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_tx_desc
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rx_coal_tick
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_rx_desc
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|function|ace_module_cleanup
r_void
id|__exit
id|ace_module_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|net_device
op_star
id|next
suffix:semicolon
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|root_dev
)paren
(brace
id|ap
op_assign
id|root_dev-&gt;priv
suffix:semicolon
id|next
op_assign
id|ap-&gt;next
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuBCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuBCtrl
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This clears any pending interrupts&n;&t;&t; */
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure no other CPUs are processing interrupts&n;&t;&t; * on the card before the buffers are being released.&n;&t;&t; * Otherwise one might experience some `interesting&squot;&n;&t;&t; * effects.&n;&t;&t; *&n;&t;&t; * Then release the RX buffers - jumbo buffers were&n;&t;&t; * already released in ace_close().&n;&t;&t; */
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_STD_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|i
)braket
dot
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
id|mapping
op_assign
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|i
)braket
dot
id|mapping
suffix:semicolon
id|ap-&gt;rx_std_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ap-&gt;pdev
comma
id|mapping
comma
id|ACE_STD_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_MINI_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|i
)braket
dot
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
id|mapping
op_assign
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|i
)braket
dot
id|mapping
suffix:semicolon
id|ap-&gt;rx_mini_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ap-&gt;pdev
comma
id|mapping
comma
id|ACE_MINI_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
dot
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
id|mapping
op_assign
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
dot
id|mapping
suffix:semicolon
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ap-&gt;pdev
comma
id|mapping
comma
id|ACE_JUMBO_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|ace_init_cleanup
c_func
(paren
id|root_dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|root_dev
)paren
suffix:semicolon
id|root_dev
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|ace_module_init
r_int
id|__init
id|ace_module_init
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|root_dev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef NEW_NETINIT
id|status
op_assign
id|acenic_probe
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|status
op_assign
id|acenic_probe
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_return
id|status
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02032a)
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|ace_module_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|ace_module_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#else
DECL|variable|ace_module_init
id|module_init
c_func
(paren
id|ace_module_init
)paren
suffix:semicolon
DECL|variable|ace_module_cleanup
id|module_exit
c_func
(paren
id|ace_module_cleanup
)paren
suffix:semicolon
macro_line|#endif
DECL|function|ace_free_descriptors
r_static
r_void
id|ace_free_descriptors
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;rx_std_ring
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
(paren
r_sizeof
(paren
r_struct
id|rx_desc
)paren
op_star
(paren
id|RX_STD_RING_ENTRIES
op_plus
id|RX_JUMBO_RING_ENTRIES
op_plus
id|RX_MINI_RING_ENTRIES
op_plus
id|RX_RETURN_RING_ENTRIES
)paren
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|ap-&gt;pdev
comma
id|size
comma
id|ap-&gt;rx_std_ring
comma
id|ap-&gt;rx_ring_base_dma
)paren
suffix:semicolon
id|ap-&gt;rx_std_ring
op_assign
l_int|NULL
suffix:semicolon
id|ap-&gt;rx_jumbo_ring
op_assign
l_int|NULL
suffix:semicolon
id|ap-&gt;rx_mini_ring
op_assign
l_int|NULL
suffix:semicolon
id|ap-&gt;rx_return_ring
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;evt_ring
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
(paren
r_sizeof
(paren
r_struct
id|event
)paren
op_star
id|EVT_RING_ENTRIES
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|ap-&gt;pdev
comma
id|size
comma
id|ap-&gt;evt_ring
comma
id|ap-&gt;evt_ring_dma
)paren
suffix:semicolon
id|ap-&gt;evt_ring
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;evt_prd
op_ne
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
id|u32
)paren
comma
(paren
r_void
op_star
)paren
id|ap-&gt;evt_prd
comma
id|ap-&gt;evt_prd_dma
)paren
suffix:semicolon
id|ap-&gt;evt_prd
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;rx_ret_prd
op_ne
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
id|u32
)paren
comma
(paren
r_void
op_star
)paren
id|ap-&gt;rx_ret_prd
comma
id|ap-&gt;rx_ret_prd_dma
)paren
suffix:semicolon
id|ap-&gt;rx_ret_prd
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;tx_csm
op_ne
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
id|u32
)paren
comma
(paren
r_void
op_star
)paren
id|ap-&gt;tx_csm
comma
id|ap-&gt;tx_csm_dma
)paren
suffix:semicolon
id|ap-&gt;tx_csm
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|ace_allocate_descriptors
r_static
r_int
id|ace_allocate_descriptors
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|size
suffix:semicolon
id|size
op_assign
(paren
r_sizeof
(paren
r_struct
id|rx_desc
)paren
op_star
(paren
id|RX_STD_RING_ENTRIES
op_plus
id|RX_JUMBO_RING_ENTRIES
op_plus
id|RX_MINI_RING_ENTRIES
op_plus
id|RX_RETURN_RING_ENTRIES
)paren
)paren
suffix:semicolon
id|ap-&gt;rx_std_ring
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
id|size
comma
op_amp
id|ap-&gt;rx_ring_base_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;rx_std_ring
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|ap-&gt;rx_jumbo_ring
op_assign
id|ap-&gt;rx_std_ring
op_plus
id|RX_STD_RING_ENTRIES
suffix:semicolon
id|ap-&gt;rx_mini_ring
op_assign
id|ap-&gt;rx_jumbo_ring
op_plus
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
id|ap-&gt;rx_return_ring
op_assign
id|ap-&gt;rx_mini_ring
op_plus
id|RX_MINI_RING_ENTRIES
suffix:semicolon
id|size
op_assign
(paren
r_sizeof
(paren
r_struct
id|event
)paren
op_star
id|EVT_RING_ENTRIES
)paren
suffix:semicolon
id|ap-&gt;evt_ring
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
id|size
comma
op_amp
id|ap-&gt;evt_ring_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;evt_ring
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|size
op_assign
(paren
r_sizeof
(paren
r_struct
id|tx_desc
)paren
op_star
id|TX_RING_ENTRIES
)paren
suffix:semicolon
id|ap-&gt;tx_ring
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
id|size
comma
op_amp
id|ap-&gt;tx_ring_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tx_ring
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|ap-&gt;evt_prd
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
id|u32
)paren
comma
op_amp
id|ap-&gt;evt_prd_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;evt_prd
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|ap-&gt;rx_ret_prd
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
id|u32
)paren
comma
op_amp
id|ap-&gt;rx_ret_prd_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;rx_ret_prd
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|ap-&gt;tx_csm
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
id|u32
)paren
comma
op_amp
id|ap-&gt;tx_csm_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tx_csm
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
multiline_comment|/* Clean up. */
id|ace_init_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic cleanup handling data allocated during init. Used when the&n; * module is unloaded or if an error occurs during initialization&n; */
DECL|function|ace_init_cleanup
r_static
r_void
id|ace_init_cleanup
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ace_free_descriptors
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;info
)paren
id|pci_free_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|ace_info
)paren
comma
id|ap-&gt;info
comma
id|ap-&gt;info_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;skb
)paren
id|kfree
c_func
(paren
id|ap-&gt;skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;trace_buf
)paren
id|kfree
c_func
(paren
id|ap-&gt;trace_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|ap-&gt;regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Commands are considered to be slow.&n; */
DECL|function|ace_issue_cmd
r_static
r_inline
r_void
id|ace_issue_cmd
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
r_struct
id|cmd
op_star
id|cmd
)paren
(brace
id|u32
id|idx
suffix:semicolon
id|idx
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;CmdPrd
)paren
suffix:semicolon
id|writel
c_func
(paren
op_star
(paren
id|u32
op_star
)paren
(paren
id|cmd
)paren
comma
op_amp
id|regs-&gt;CmdRng
(braket
id|idx
)braket
)paren
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|CMD_RING_ENTRIES
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;CmdPrd
)paren
suffix:semicolon
)brace
DECL|function|ace_init
r_static
r_int
id|__init
id|ace_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|ace_info
op_star
id|info
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|tmp_ptr
comma
id|myjif
suffix:semicolon
id|u32
id|tig_ver
comma
id|mac1
comma
id|mac2
comma
id|tmp
comma
id|pci_state
suffix:semicolon
r_int
id|board_idx
comma
id|ecode
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|cache
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|board_idx
op_assign
id|ap-&gt;board_idx
suffix:semicolon
multiline_comment|/*&n;&t; * aman@sgi.com - its useful to do a NIC reset here to&n;&t; * address the `Firmware not running&squot; problem subsequent&n;&t; * to any crashes involving the NIC&n;&t; */
id|writel
c_func
(paren
id|HW_RESET
op_or
(paren
id|HW_RESET
op_lshift
l_int|24
)paren
comma
op_amp
id|regs-&gt;HostCtrl
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t access any other registes before this point!&n;&t; */
macro_line|#ifdef __BIG_ENDIAN
multiline_comment|/*&n;&t; * This will most likely need BYTE_SWAP once we switch&n;&t; * to using __raw_writel()&n;&t; */
id|writel
c_func
(paren
(paren
id|WORD_SWAP
op_or
id|CLR_INT
op_or
(paren
(paren
id|WORD_SWAP
op_or
id|CLR_INT
)paren
op_lshift
l_int|24
)paren
)paren
comma
op_amp
id|regs-&gt;HostCtrl
)paren
suffix:semicolon
macro_line|#else
id|writel
c_func
(paren
(paren
id|CLR_INT
op_or
id|WORD_SWAP
op_or
(paren
(paren
id|CLR_INT
op_or
id|WORD_SWAP
)paren
op_lshift
l_int|24
)paren
)paren
comma
op_amp
id|regs-&gt;HostCtrl
)paren
suffix:semicolon
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Stop the NIC CPU and clear pending interrupts&n;&t; */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
id|tig_ver
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;HostCtrl
)paren
op_rshift
l_int|28
suffix:semicolon
r_switch
c_cond
(paren
id|tig_ver
)paren
(brace
macro_line|#ifndef CONFIG_ACENIC_OMIT_TIGON_I
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Tigon I  (Rev. 4), Firmware: %i.%i.%i, &quot;
comma
id|tigonFwReleaseMajor
comma
id|tigonFwReleaseMinor
comma
id|tigonFwReleaseFix
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|ap-&gt;version
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|6
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Tigon II (Rev. %i), Firmware: %i.%i.%i, &quot;
comma
id|tig_ver
comma
id|tigon2FwReleaseMajor
comma
id|tigon2FwReleaseMinor
comma
id|tigon2FwReleaseFix
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuBCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuBCtrl
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The SRAM bank size does _not_ indicate the amount&n;&t;&t; * of memory on the card, it controls the _bank_ size!&n;&t;&t; * Ie. a 1MB AceNIC will have two banks of 512KB.&n;&t;&t; */
id|writel
c_func
(paren
id|SRAM_BANK_512K
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
id|SYNC_SRAM_TIMING
comma
op_amp
id|regs-&gt;MiscCfg
)paren
suffix:semicolon
id|ap-&gt;version
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Unsupported Tigon version detected (%i), &quot;
comma
id|tig_ver
)paren
suffix:semicolon
id|ecode
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ModeStat _must_ be set after the SRAM settings as this change&n;&t; * seems to corrupt the ModeStat and possible other registers.&n;&t; * The SRAM settings survive resets and setting it to the same&n;&t; * value a second time works as well. This is what caused the&n;&t; * `Firmware not running&squot; problem on the Tigon II.&n;&t; */
macro_line|#ifdef __BIG_ENDIAN
id|writel
c_func
(paren
id|ACE_BYTE_SWAP_DMA
op_or
id|ACE_WARN
op_or
id|ACE_FATAL
op_or
id|ACE_BYTE_SWAP_BD
op_or
id|ACE_WORD_SWAP_BD
op_or
id|ACE_NO_JUMBO_FRAG
comma
op_amp
id|regs-&gt;ModeStat
)paren
suffix:semicolon
macro_line|#else
id|writel
c_func
(paren
id|ACE_BYTE_SWAP_DMA
op_or
id|ACE_WARN
op_or
id|ACE_FATAL
op_or
id|ACE_WORD_SWAP_BD
op_or
id|ACE_NO_JUMBO_FRAG
comma
op_amp
id|regs-&gt;ModeStat
)paren
suffix:semicolon
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
id|mac1
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac1
op_assign
id|mac1
op_lshift
l_int|8
suffix:semicolon
id|tmp
op_assign
id|read_eeprom_byte
c_func
(paren
id|dev
comma
l_int|0x8c
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|ecode
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
r_else
id|mac1
op_or_assign
(paren
id|tmp
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|mac2
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac2
op_assign
id|mac2
op_lshift
l_int|8
suffix:semicolon
id|tmp
op_assign
id|read_eeprom_byte
c_func
(paren
id|dev
comma
l_int|0x8c
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|ecode
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
r_else
id|mac2
op_or_assign
(paren
id|tmp
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|writel
c_func
(paren
id|mac1
comma
op_amp
id|regs-&gt;MacAddrHi
)paren
suffix:semicolon
id|writel
c_func
(paren
id|mac2
comma
op_amp
id|regs-&gt;MacAddrLo
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MAC: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
(paren
id|mac1
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|mac1
op_amp
l_int|0xff
comma
(paren
id|mac2
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
(paren
id|mac2
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
(paren
id|mac2
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|mac2
op_amp
l_int|0xff
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
(paren
id|mac1
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_assign
id|mac1
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_assign
(paren
id|mac2
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
op_assign
(paren
id|mac2
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
op_assign
(paren
id|mac2
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
op_assign
id|mac2
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/*&n;&t; * Looks like this is necessary to deal with on all architectures,&n;&t; * even this %$#%$# N440BX Intel based thing doesn&squot;t get it right.&n;&t; * Ie. having two NICs in the machine, one will have the cache&n;&t; * line set at boot time, the other will not.&n;&t; */
id|pci_read_config_byte
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cache
op_lshift
l_int|2
)paren
op_ne
id|SMP_CACHE_BYTES
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  PCI cache line size set incorrectly &quot;
l_string|&quot;(%i bytes) by BIOS/FW, correcting to %i&bslash;n&quot;
comma
(paren
id|cache
op_lshift
l_int|2
)paren
comma
id|SMP_CACHE_BYTES
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
id|SMP_CACHE_BYTES
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
id|pci_state
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;PciState
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  PCI bus width: %i bits, speed: %iMHz, &quot;
l_string|&quot;latency: %i clks&bslash;n&quot;
comma
(paren
id|pci_state
op_amp
id|PCI_32BIT
)paren
ques
c_cond
l_int|32
suffix:colon
l_int|64
comma
(paren
id|pci_state
op_amp
id|PCI_66MHZ
)paren
ques
c_cond
l_int|66
suffix:colon
l_int|33
comma
id|ap-&gt;pci_latency
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the max DMA transfer size. Seems that for most systems&n;&t; * the performance is better when no MAX parameter is&n;&t; * set. However for systems enabling PCI write and invalidate,&n;&t; * DMA writes must be set to the L1 cache line size to get&n;&t; * optimal performance.&n;&t; *&n;&t; * The default is now to turn the PCI write and invalidate off&n;&t; * - that is what Alteon does for NT.&n;&t; */
id|tmp
op_assign
id|READ_CMD_MEM
op_or
id|WRITE_CMD_MEM
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|tmp
op_or_assign
(paren
id|MEM_READ_MULTIPLE
op_or
(paren
id|pci_state
op_amp
id|PCI_66MHZ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Tuning parameters only supported for 8 cards&n;&t;&t; */
r_if
c_cond
(paren
id|board_idx
op_eq
id|BOARD_IDX_OVERFLOW
op_logical_or
id|dis_pci_mem_inval
(braket
id|board_idx
)braket
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;pci_command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
(brace
id|ap-&gt;pci_command
op_and_assign
op_complement
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_COMMAND
comma
id|ap-&gt;pci_command
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Disabling PCI memory &quot;
l_string|&quot;write and invalidate&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;pci_command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  PCI memory write &amp; invalidate &quot;
l_string|&quot;enabled by BIOS, enabling counter measures&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SMP_CACHE_BYTES
)paren
(brace
r_case
l_int|16
suffix:colon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_32
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|64
suffix:colon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_64
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Cache line size %i not &quot;
l_string|&quot;supported, PCI write and invalidate &quot;
l_string|&quot;disabled&bslash;n&quot;
comma
id|SMP_CACHE_BYTES
)paren
suffix:semicolon
id|ap-&gt;pci_command
op_and_assign
op_complement
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_COMMAND
comma
id|ap-&gt;pci_command
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef __sparc__
multiline_comment|/*&n;&t; * On this platform, we know what the best dma settings&n;&t; * are.  We use 64-byte maximum bursts, because if we&n;&t; * burst larger than the cache line size (or even cross&n;&t; * a 64byte boundry in a single burst) the UltraSparc&n;&t; * PCI controller will disconnect at 64-byte multiples.&n;&t; *&n;&t; * Read-multiple will be properly enabled above, and when&n;&t; * set will give the PCI controller proper hints about&n;&t; * prefetching.&n;&t; */
id|tmp
op_assign
id|tmp
op_amp
op_complement
id|DMA_READ_WRITE_MASK
suffix:semicolon
id|tmp
op_or_assign
id|DMA_READ_MAX_64
suffix:semicolon
id|tmp
op_or_assign
id|DMA_WRITE_MAX_64
suffix:semicolon
macro_line|#endif
id|writel
c_func
(paren
id|tmp
comma
op_amp
id|regs-&gt;PciState
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * I have received reports from people having problems when this&n;&t; * bit is enabled.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;pci_command
op_amp
id|PCI_COMMAND_FAST_BACK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Enabling PCI Fast Back to Back&bslash;n&quot;
)paren
suffix:semicolon
id|ap-&gt;pci_command
op_or_assign
id|PCI_COMMAND_FAST_BACK
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|ap-&gt;pdev
comma
id|PCI_COMMAND
comma
id|ap-&gt;pci_command
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize the generic info block and the command+event rings&n;&t; * and the control blocks for the transmit and receive rings&n;&t; * as they need to be setup once and for all.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|info
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ap-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|ace_info
)paren
comma
op_amp
id|ap-&gt;info_dma
)paren
)paren
)paren
(brace
id|ecode
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
id|ap-&gt;info
op_assign
id|info
suffix:semicolon
multiline_comment|/*&n;&t; * Get the memory for the skb rings.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;skb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ace_skb
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|ecode
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
id|ecode
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|ace_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecode
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Requested IRQ %d is busy&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register the device here to be able to catch allocated&n;&t; * interrupt handlers in case the firmware doesn&squot;t come up.&n;&t; */
id|ap-&gt;next
op_assign
id|root_dev
suffix:semicolon
id|root_dev
op_assign
id|dev
suffix:semicolon
macro_line|#ifdef INDEX_DEBUG
id|spin_lock_init
c_func
(paren
op_amp
id|ap-&gt;debug_lock
)paren
suffix:semicolon
id|ap-&gt;last_tx
op_assign
id|TX_RING_ENTRIES
op_minus
l_int|1
suffix:semicolon
id|ap-&gt;last_std_rx
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;last_mini_rx
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|ap-&gt;info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ace_info
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;skb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ace_skb
)paren
)paren
suffix:semicolon
id|ace_load_firmware
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ap-&gt;fw_running
op_assign
l_int|0
suffix:semicolon
id|tmp_ptr
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;info_dma
suffix:semicolon
macro_line|#ifdef ACE_64BIT_PTR
id|writel
c_func
(paren
id|tmp_ptr
op_rshift
l_int|32
comma
op_amp
id|regs-&gt;InfoPtrHi
)paren
suffix:semicolon
macro_line|#else
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;InfoPtrHi
)paren
suffix:semicolon
macro_line|#endif
id|writel
c_func
(paren
id|tmp_ptr
op_amp
l_int|0xffffffff
comma
op_amp
id|regs-&gt;InfoPtrLo
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;evt_ring
comma
l_int|0
comma
id|EVT_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|event
)paren
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;evt_ctrl.rngptr
comma
id|ap-&gt;evt_ring_dma
)paren
suffix:semicolon
id|info-&gt;evt_ctrl.flags
op_assign
l_int|0
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;evt_prd_ptr
comma
id|ap-&gt;evt_prd_dma
)paren
suffix:semicolon
op_star
(paren
id|ap-&gt;evt_prd
)paren
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;EvtCsm
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;cmd_ctrl.rngptr
comma
l_int|0x100
)paren
suffix:semicolon
id|info-&gt;cmd_ctrl.flags
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cmd_ctrl.max_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CMD_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;CmdRng
(braket
id|i
)braket
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;CmdPrd
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;CmdCsm
)paren
suffix:semicolon
id|tmp_ptr
op_assign
id|ap-&gt;info_dma
suffix:semicolon
id|tmp_ptr
op_add_assign
(paren
r_int
r_int
)paren
op_amp
(paren
(paren
(paren
r_struct
id|ace_info
op_star
)paren
l_int|0
)paren
op_member_access_from_pointer
id|s.stats
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;stats2_ptr
comma
(paren
id|dma_addr_t
)paren
id|tmp_ptr
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_std_ctrl.rngptr
comma
id|ap-&gt;rx_ring_base_dma
)paren
suffix:semicolon
id|info-&gt;rx_std_ctrl.max_len
op_assign
id|ACE_STD_MTU
op_plus
id|ETH_HLEN
op_plus
l_int|4
suffix:semicolon
id|info-&gt;rx_std_ctrl.flags
op_assign
id|RCB_FLG_TCP_UDP_SUM
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_std_ring
comma
l_int|0
comma
id|RX_STD_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_STD_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;rx_std_ring
(braket
id|i
)braket
dot
id|flags
op_assign
id|BD_FLG_TCP_UDP_SUM
suffix:semicolon
id|ap-&gt;rx_std_skbprd
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
comma
l_int|0
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_jumbo_ctrl.rngptr
comma
(paren
id|ap-&gt;rx_ring_base_dma
op_plus
(paren
r_sizeof
(paren
r_struct
id|rx_desc
)paren
op_star
id|RX_STD_RING_ENTRIES
)paren
)paren
)paren
suffix:semicolon
id|info-&gt;rx_jumbo_ctrl.max_len
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_jumbo_ctrl.flags
op_assign
id|RCB_FLG_TCP_UDP_SUM
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_jumbo_ring
comma
l_int|0
comma
id|RX_JUMBO_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|flags
op_assign
id|BD_FLG_TCP_UDP_SUM
op_or
id|BD_FLG_JUMBO
suffix:semicolon
id|ap-&gt;rx_jumbo_skbprd
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
comma
l_int|0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_mini_ring
comma
l_int|0
comma
id|RX_MINI_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_mini_ctrl.rngptr
comma
(paren
id|ap-&gt;rx_ring_base_dma
op_plus
(paren
r_sizeof
(paren
r_struct
id|rx_desc
)paren
op_star
(paren
id|RX_STD_RING_ENTRIES
op_plus
id|RX_JUMBO_RING_ENTRIES
)paren
)paren
)paren
)paren
suffix:semicolon
id|info-&gt;rx_mini_ctrl.max_len
op_assign
id|ACE_MINI_SIZE
suffix:semicolon
id|info-&gt;rx_mini_ctrl.flags
op_assign
id|RCB_FLG_TCP_UDP_SUM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_MINI_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;rx_mini_ring
(braket
id|i
)braket
dot
id|flags
op_assign
id|BD_FLG_TCP_UDP_SUM
op_or
id|BD_FLG_MINI
suffix:semicolon
)brace
r_else
(brace
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_mini_ctrl.rngptr
comma
l_int|0
)paren
suffix:semicolon
id|info-&gt;rx_mini_ctrl.flags
op_assign
id|RCB_FLG_RNG_DISABLE
suffix:semicolon
id|info-&gt;rx_mini_ctrl.max_len
op_assign
l_int|0
suffix:semicolon
)brace
id|ap-&gt;rx_mini_skbprd
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
comma
l_int|0
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_return_ctrl.rngptr
comma
(paren
id|ap-&gt;rx_ring_base_dma
op_plus
(paren
r_sizeof
(paren
r_struct
id|rx_desc
)paren
op_star
(paren
id|RX_STD_RING_ENTRIES
op_plus
id|RX_JUMBO_RING_ENTRIES
op_plus
id|RX_MINI_RING_ENTRIES
)paren
)paren
)paren
)paren
suffix:semicolon
id|info-&gt;rx_return_ctrl.flags
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_return_ctrl.max_len
op_assign
id|RX_RETURN_RING_ENTRIES
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;rx_return_ring
comma
l_int|0
comma
id|RX_RETURN_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|rx_desc
)paren
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;rx_ret_prd_ptr
comma
id|ap-&gt;rx_ret_prd_dma
)paren
suffix:semicolon
op_star
(paren
id|ap-&gt;rx_ret_prd
)paren
op_assign
l_int|0
suffix:semicolon
id|writel
c_func
(paren
id|TX_RING_BASE
comma
op_amp
id|regs-&gt;WinBase
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ap-&gt;tx_ring
comma
l_int|0
comma
id|TX_RING_ENTRIES
op_star
r_sizeof
(paren
r_struct
id|tx_desc
)paren
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;tx_ctrl.rngptr
comma
id|ap-&gt;tx_ring_dma
)paren
suffix:semicolon
id|info-&gt;tx_ctrl.max_len
op_assign
id|TX_RING_ENTRIES
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
macro_line|#if TX_COAL_INTS_ONLY
id|tmp
op_or_assign
id|RCB_FLG_COAL_INT_ONLY
suffix:semicolon
macro_line|#endif
id|tmp
op_or_assign
id|RCB_FLG_TX_HOST_RING
suffix:semicolon
id|info-&gt;tx_ctrl.flags
op_assign
id|tmp
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|info-&gt;tx_csm_ptr
comma
id|ap-&gt;tx_csm_dma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Potential item for tuning parameter&n;&t; */
id|writel
c_func
(paren
id|DMA_THRESH_8W
comma
op_amp
id|regs-&gt;DmaReadCfg
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DMA_THRESH_8W
comma
op_amp
id|regs-&gt;DmaWriteCfg
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;MaskInt
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;IfIdx
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;AssistState
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_STAT
comma
op_amp
id|regs-&gt;TuneStatTicks
)paren
suffix:semicolon
id|writel
c_func
(paren
id|DEF_TRACE
comma
op_amp
id|regs-&gt;TuneTrace
)paren
suffix:semicolon
id|ace_set_rxtx_parms
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|board_idx
op_eq
id|BOARD_IDX_OVERFLOW
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: more then %i NICs detected, &quot;
l_string|&quot;ignoring module parameters!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ACE_MAX_MOD_PARMS
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|board_idx
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|tx_coal_tick
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_tx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|max_tx_desc
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|rx_coal_tick
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_rx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|max_rx_desc
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trace
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|trace
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TuneTrace
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tx_ratio
(braket
id|board_idx
)braket
op_ge
l_int|0
)paren
op_logical_and
(paren
id|tx_ratio
(braket
id|board_idx
)braket
OL
l_int|64
)paren
)paren
id|writel
c_func
(paren
id|tx_ratio
(braket
id|board_idx
)braket
comma
op_amp
id|regs-&gt;TxBufRat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Default link parameters&n;&t; */
id|tmp
op_assign
id|LNK_ENABLE
op_or
id|LNK_FULL_DUPLEX
op_or
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
op_or
id|LNK_RX_FLOW_CTL_Y
op_or
id|LNK_NEG_FCTL
op_or
id|LNK_NEGOTIATE
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|tmp
op_or_assign
id|LNK_TX_FLOW_CTL_Y
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Override link default parameters&n;&t; */
r_if
c_cond
(paren
(paren
id|board_idx
op_ge
l_int|0
)paren
op_logical_and
id|link
(braket
id|board_idx
)braket
)paren
(brace
r_int
id|option
op_assign
id|link
(braket
id|board_idx
)braket
suffix:semicolon
id|tmp
op_assign
id|LNK_ENABLE
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Setting half duplex link&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|LNK_FULL_DUPLEX
suffix:semicolon
)brace
r_if
c_cond
(paren
id|option
op_amp
l_int|0x02
)paren
id|tmp
op_and_assign
op_complement
id|LNK_NEGOTIATE
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x10
)paren
id|tmp
op_or_assign
id|LNK_10MB
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x20
)paren
id|tmp
op_or_assign
id|LNK_100MB
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x40
)paren
id|tmp
op_or_assign
id|LNK_1000MB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|option
op_amp
l_int|0x70
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No media speed specified, &quot;
l_string|&quot;forcing auto negotiation&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tmp
op_or_assign
id|LNK_NEGOTIATE
op_or
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|option
op_amp
l_int|0x100
)paren
op_eq
l_int|0
)paren
id|tmp
op_or_assign
id|LNK_NEG_FCTL
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Disabling flow control &quot;
l_string|&quot;negotiation&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
l_int|0x200
)paren
id|tmp
op_or_assign
id|LNK_RX_FLOW_CTL_Y
suffix:semicolon
r_if
c_cond
(paren
(paren
id|option
op_amp
l_int|0x400
)paren
op_logical_and
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling TX flow control&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tmp
op_or_assign
id|LNK_TX_FLOW_CTL_Y
suffix:semicolon
)brace
)brace
id|ap-&gt;link
op_assign
id|tmp
suffix:semicolon
id|writel
c_func
(paren
id|tmp
comma
op_amp
id|regs-&gt;TuneLink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
id|writel
c_func
(paren
id|tmp
comma
op_amp
id|regs-&gt;TuneFastLink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|writel
c_func
(paren
id|tigonFwStartAddr
comma
op_amp
id|regs-&gt;Pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_eq
l_int|2
)paren
id|writel
c_func
(paren
id|tigon2FwStartAddr
comma
op_amp
id|regs-&gt;Pc
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set tx_csm before we start receiving interrupts, otherwise&n;&t; * the interrupt handler might think it is supposed to process&n;&t; * tx ints before we are up and running, which may cause a null&n;&t; * pointer access in the int handler.&n;&t; */
id|ap-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;cur_rx
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;tx_prd
op_assign
op_star
(paren
id|ap-&gt;tx_csm
)paren
op_assign
id|ap-&gt;tx_ret_csm
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|ace_set_txprd
c_func
(paren
id|regs
comma
id|ap
comma
l_int|0
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;RxRetCsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start the NIC CPU&n;&t; */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_amp
op_complement
(paren
id|CPU_HALT
op_or
id|CPU_TRACE
)paren
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for the firmware to spin up - max 3 seconds.&n;&t; */
id|myjif
op_assign
id|jiffies
op_plus
l_int|3
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|myjif
)paren
op_logical_and
op_logical_neg
id|ap-&gt;fw_running
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;fw_running
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Firmware NOT running!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ace_dump_trace
c_func
(paren
id|ap
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuCtrl
)paren
suffix:semicolon
multiline_comment|/* aman@sgi.com - account for badly behaving firmware/NIC:&n;&t;&t; * - have observed that the NIC may continue to generate&n;&t;&t; *   interrupts for some reason; attempt to stop it - halt&n;&t;&t; *   second CPU for Tigon II cards, and also clear Mb0&n;&t;&t; * - if we&squot;re a module, we&squot;ll fail to load if this was&n;&t;&t; *   the only GbE card in the system =&gt; if the kernel does&n;&t;&t; *   see an interrupt from the NIC, code to handle it is&n;&t;&t; *   gone and OOps! - so free_irq also&n;&t;&t; */
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuBCtrl
)paren
op_or
id|CPU_HALT
comma
op_amp
id|regs-&gt;CpuBCtrl
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
id|ecode
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|init_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We load the ring here as there seem to be no way to tell the&n;&t; * firmware to wipe the ring without re-initializing it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
)paren
id|ace_load_std_rx_ring
c_func
(paren
id|ap
comma
id|RX_RING_SIZE
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Someone is busy refilling the RX ring&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
)paren
id|ace_load_mini_rx_ring
c_func
(paren
id|ap
comma
id|RX_MINI_SIZE
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Someone is busy refilling &quot;
l_string|&quot;the RX mini ring&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|init_error
suffix:colon
id|ace_init_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ecode
suffix:semicolon
)brace
DECL|function|ace_set_rxtx_parms
r_static
r_void
id|ace_set_rxtx_parms
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|jumbo
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|board_idx
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|board_idx
op_assign
id|ap-&gt;board_idx
suffix:semicolon
r_if
c_cond
(paren
id|board_idx
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|jumbo
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_TX_COAL
comma
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_tx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_TX_MAX_DESC
comma
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_RX_COAL
comma
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_rx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_RX_MAX_DESC
comma
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_ratio
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_TX_RATIO
comma
op_amp
id|regs-&gt;TxBufRat
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|tx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_JUMBO_TX_COAL
comma
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_tx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_JUMBO_TX_MAX_DESC
comma
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rx_coal_tick
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_JUMBO_RX_COAL
comma
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_rx_desc
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_JUMBO_RX_MAX_DESC
comma
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_ratio
(braket
id|board_idx
)braket
)paren
id|writel
c_func
(paren
id|DEF_JUMBO_TX_RATIO
comma
op_amp
id|regs-&gt;TxBufRat
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Monitor the card to detect hangs.&n; */
DECL|function|ace_timer
r_static
r_void
id|ace_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
multiline_comment|/*&n;&t; * We haven&squot;t received a stats update event for more than 2.5&n;&t; * seconds and there is data in the transmit queue, thus we&n;&t; * asume the card is stuck.&n;&t; */
r_if
c_cond
(paren
op_star
id|ap-&gt;tx_csm
op_ne
id|ap-&gt;tx_ret_csm
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Transmitter is stuck, %08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;HostCtrl
)paren
)paren
suffix:semicolon
)brace
id|ap-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_div
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
)brace
DECL|function|ace_tasklet
r_static
r_void
id|ace_tasklet
c_func
(paren
r_int
r_int
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
(paren
(paren
r_struct
id|net_device
op_star
)paren
id|dev
)paren
op_member_access_from_pointer
id|priv
suffix:semicolon
r_int
id|cur_size
suffix:semicolon
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_LOW_STD_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;refilling buffers (current %i)&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_std_rx_ring
c_func
(paren
id|ap
comma
id|RX_RING_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;version
op_ge
l_int|2
)paren
(brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_LOW_MINI_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;refilling mini buffers (current %i)&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_mini_rx_ring
c_func
(paren
id|ap
comma
id|RX_MINI_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
)brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;jumbo
op_logical_and
(paren
id|cur_size
OL
id|RX_LOW_JUMBO_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;refilling jumbo buffers (current %i)&bslash;n&quot;
comma
OG
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
id|ap-&gt;tasklet_pending
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the contents of the NIC&squot;s trace buffer to kernel memory.&n; */
DECL|function|ace_dump_trace
r_static
r_void
id|ace_dump_trace
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;trace_buf
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;trace_buf
op_assign
id|kmalloc
c_func
(paren
id|ACE_TRACE_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Load the standard rx ring.&n; *&n; * Loading rings is safe without holding the spin lock since this is&n; * done only before the device is enabled, thus no interrupts are&n; * generated and by the interrupt handler/tasklet handler.&n; */
DECL|function|ace_load_std_rx_ring
r_static
r_void
id|ace_load_std_rx_ring
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
comma
r_int
id|nr_bufs
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|i
comma
id|idx
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|idx
op_assign
id|ap-&gt;rx_std_skbprd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rd
suffix:semicolon
id|dma_addr_t
id|mapping
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ACE_STD_BUFSIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure IP header starts on a fresh cache line.&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|ap-&gt;pdev
comma
id|skb-&gt;data
comma
id|ACE_STD_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|idx
)braket
dot
id|skb
op_assign
id|skb
suffix:semicolon
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|idx
)braket
dot
id|mapping
op_assign
id|mapping
suffix:semicolon
id|rd
op_assign
op_amp
id|ap-&gt;rx_std_ring
(braket
id|idx
)braket
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|rd-&gt;addr
comma
id|mapping
)paren
suffix:semicolon
id|rd-&gt;size
op_assign
id|ACE_STD_MTU
op_plus
id|ETH_HLEN
op_plus
l_int|4
suffix:semicolon
id|rd-&gt;idx
op_assign
id|idx
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_STD_RING_ENTRIES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_goto
id|error_out
suffix:semicolon
id|atomic_add
c_func
(paren
id|i
comma
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
id|ap-&gt;rx_std_skbprd
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_RX_PRD_IDX
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
id|ap-&gt;rx_std_skbprd
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxStdPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
suffix:semicolon
r_return
suffix:semicolon
id|error_out
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Out of memory when allocating &quot;
l_string|&quot;standard receive buffers&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|ace_load_mini_rx_ring
r_static
r_void
id|ace_load_mini_rx_ring
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
comma
r_int
id|nr_bufs
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|i
comma
id|idx
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|idx
op_assign
id|ap-&gt;rx_mini_skbprd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rd
suffix:semicolon
id|dma_addr_t
id|mapping
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ACE_MINI_BUFSIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the IP header ends up on a fresh cache line&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|ap-&gt;pdev
comma
id|skb-&gt;data
comma
id|ACE_MINI_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|idx
)braket
dot
id|skb
op_assign
id|skb
suffix:semicolon
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|idx
)braket
dot
id|mapping
op_assign
id|mapping
suffix:semicolon
id|rd
op_assign
op_amp
id|ap-&gt;rx_mini_ring
(braket
id|idx
)braket
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|rd-&gt;addr
comma
id|mapping
)paren
suffix:semicolon
id|rd-&gt;size
op_assign
id|ACE_MINI_SIZE
suffix:semicolon
id|rd-&gt;idx
op_assign
id|idx
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_MINI_RING_ENTRIES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_goto
id|error_out
suffix:semicolon
id|atomic_add
c_func
(paren
id|i
comma
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
id|ap-&gt;rx_mini_skbprd
op_assign
id|idx
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxMiniPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
suffix:semicolon
r_return
suffix:semicolon
id|error_out
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Out of memory when allocating &quot;
l_string|&quot;mini receive buffers&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Load the jumbo rx ring, this may happen at any time if the MTU&n; * is changed to a value &gt; 1500.&n; */
DECL|function|ace_load_jumbo_rx_ring
r_static
r_void
id|ace_load_jumbo_rx_ring
c_func
(paren
r_struct
id|ace_private
op_star
id|ap
comma
r_int
id|nr_bufs
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
id|i
comma
id|idx
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|idx
op_assign
id|ap-&gt;rx_jumbo_skbprd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rd
suffix:semicolon
id|dma_addr_t
id|mapping
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ACE_JUMBO_BUFSIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the IP header ends up on a fresh cache line&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|ap-&gt;pdev
comma
id|skb-&gt;data
comma
id|ACE_JUMBO_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|idx
)braket
dot
id|skb
op_assign
id|skb
suffix:semicolon
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|idx
)braket
dot
id|mapping
op_assign
id|mapping
suffix:semicolon
id|rd
op_assign
op_amp
id|ap-&gt;rx_jumbo_ring
(braket
id|idx
)braket
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|rd-&gt;addr
comma
id|mapping
)paren
suffix:semicolon
id|rd-&gt;size
op_assign
id|ACE_JUMBO_MTU
op_plus
id|ETH_HLEN
op_plus
l_int|4
suffix:semicolon
id|rd-&gt;idx
op_assign
id|idx
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_goto
id|error_out
suffix:semicolon
id|atomic_add
c_func
(paren
id|i
comma
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
id|ap-&gt;rx_jumbo_skbprd
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_RX_JUMBO_PRD_IDX
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
id|ap-&gt;rx_jumbo_skbprd
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxJumboPrd
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
suffix:semicolon
r_return
suffix:semicolon
id|error_out
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Out of memory when allocating &quot;
l_string|&quot;jumbo receive buffers&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * All events are considered to be slow (RX/TX ints do not generate&n; * events) and are handled here, outside the main interrupt handler,&n; * to reduce the size of the handler.&n; */
DECL|function|ace_handle_event
r_static
id|u32
id|ace_handle_event
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|evtcsm
comma
id|u32
id|evtprd
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_while
c_loop
(paren
id|evtcsm
op_ne
id|evtprd
)paren
(brace
r_switch
c_cond
(paren
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|evt
)paren
(brace
r_case
id|E_FW_RUNNING
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Firmware up and running&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;fw_running
op_assign
l_int|1
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_STATS_UPDATED
suffix:colon
r_break
suffix:semicolon
r_case
id|E_LNK_STATE
suffix:colon
(brace
id|u16
id|code
op_assign
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|code
suffix:semicolon
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|E_C_LINK_UP
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Optical link UP&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_C_LINK_DOWN
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Optical link DOWN&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_C_LINK_10_100
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: 10/100BaseT link &quot;
l_string|&quot;UP&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unknown optical link &quot;
l_string|&quot;state %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|code
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|E_ERROR
suffix:colon
r_switch
c_cond
(paren
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|code
)paren
(brace
r_case
id|E_C_ERR_INVAL_CMD
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: invalid command error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_C_ERR_UNIMP_CMD
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unimplemented command &quot;
l_string|&quot;error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E_C_ERR_BAD_CFG
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bad config error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unknown error %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|code
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E_RESET_JUMBO_RNG
suffix:colon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_JUMBO_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
dot
id|skb
)paren
(brace
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|size
op_assign
l_int|0
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|ap-&gt;rx_jumbo_ring
(braket
id|i
)braket
dot
id|addr
comma
l_int|0
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
dot
id|skb
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_RX_JUMBO_PRD_IDX
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|ap-&gt;regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|writel
c_func
(paren
l_int|0
comma
op_amp
(paren
(paren
id|ap-&gt;regs
)paren
op_member_access_from_pointer
id|RxJumboPrd
)paren
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|ap-&gt;jumbo
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;rx_jumbo_skbprd
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Jumbo ring flushed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;tx_full
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unhandled event 0x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ap-&gt;evt_ring
(braket
id|evtcsm
)braket
dot
id|evt
)paren
suffix:semicolon
)brace
id|evtcsm
op_assign
(paren
id|evtcsm
op_plus
l_int|1
)paren
op_mod
id|EVT_RING_ENTRIES
suffix:semicolon
)brace
r_return
id|evtcsm
suffix:semicolon
)brace
DECL|function|ace_rx_int
r_static
r_void
id|ace_rx_int
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|rxretprd
comma
id|u32
id|rxretcsm
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|u32
id|idx
suffix:semicolon
r_int
id|mini_count
op_assign
l_int|0
comma
id|std_count
op_assign
l_int|0
suffix:semicolon
id|idx
op_assign
id|rxretcsm
suffix:semicolon
r_while
c_loop
(paren
id|idx
op_ne
id|rxretprd
)paren
(brace
r_struct
id|ring_info
op_star
id|rip
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|rx_desc
op_star
id|rxdesc
comma
op_star
id|retdesc
suffix:semicolon
id|u32
id|skbidx
suffix:semicolon
r_int
id|desc_type
comma
id|mapsize
suffix:semicolon
id|u16
id|csum
suffix:semicolon
id|retdesc
op_assign
op_amp
id|ap-&gt;rx_return_ring
(braket
id|idx
)braket
suffix:semicolon
id|skbidx
op_assign
id|retdesc-&gt;idx
suffix:semicolon
id|desc_type
op_assign
id|retdesc-&gt;flags
op_amp
(paren
id|BD_FLG_JUMBO
op_or
id|BD_FLG_MINI
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|desc_type
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Normal frames do not have any flags set&n;&t;&t;&t; *&n;&t;&t;&t; * Mini and normal frames arrive frequently,&n;&t;&t;&t; * so use a local counter to avoid doing&n;&t;&t;&t; * atomic operations for each packet arriving.&n;&t;&t;&t; */
r_case
l_int|0
suffix:colon
id|rip
op_assign
op_amp
id|ap-&gt;skb-&gt;rx_std_skbuff
(braket
id|skbidx
)braket
suffix:semicolon
id|mapsize
op_assign
id|ACE_STD_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|rxdesc
op_assign
op_amp
id|ap-&gt;rx_std_ring
(braket
id|skbidx
)braket
suffix:semicolon
id|std_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BD_FLG_JUMBO
suffix:colon
id|rip
op_assign
op_amp
id|ap-&gt;skb-&gt;rx_jumbo_skbuff
(braket
id|skbidx
)braket
suffix:semicolon
id|mapsize
op_assign
id|ACE_JUMBO_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|rxdesc
op_assign
op_amp
id|ap-&gt;rx_jumbo_ring
(braket
id|skbidx
)braket
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BD_FLG_MINI
suffix:colon
id|rip
op_assign
op_amp
id|ap-&gt;skb-&gt;rx_mini_skbuff
(braket
id|skbidx
)braket
suffix:semicolon
id|mapsize
op_assign
id|ACE_MINI_BUFSIZE
op_minus
(paren
l_int|2
op_plus
l_int|16
)paren
suffix:semicolon
id|rxdesc
op_assign
op_amp
id|ap-&gt;rx_mini_ring
(braket
id|skbidx
)braket
suffix:semicolon
id|mini_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unknown frame type (0x%02x) &quot;
l_string|&quot;returned by NIC&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|retdesc-&gt;flags
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|skb
op_assign
id|rip-&gt;skb
suffix:semicolon
id|rip-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ap-&gt;pdev
comma
id|rip-&gt;mapping
comma
id|mapsize
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|retdesc-&gt;size
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* unncessary */
id|rxdesc-&gt;size
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Fly baby, fly!&n;&t;&t; */
id|csum
op_assign
id|retdesc-&gt;tcp_udp_csum
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the checksum is correct and this is not a&n;&t;&t; * fragment, tell the stack that the data is correct.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|csum
op_xor
l_int|0xffff
)paren
op_logical_and
(paren
op_logical_neg
(paren
(paren
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
)paren
op_member_access_from_pointer
id|frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
)paren
)paren
(brace
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
)brace
r_else
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* send it up */
id|ap-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|ap-&gt;stats.rx_bytes
op_add_assign
id|retdesc-&gt;size
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|RX_RETURN_RING_ENTRIES
suffix:semicolon
)brace
id|atomic_sub
c_func
(paren
id|std_count
comma
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|atomic_sub
c_func
(paren
id|mini_count
comma
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * According to the documentation RxRetCsm is obsolete with&n;&t; * the 12.3.x Firmware - my Tigon I NICs seem to disagree!&n;&t; */
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|writel
c_func
(paren
id|idx
comma
op_amp
id|regs-&gt;RxRetCsm
)paren
suffix:semicolon
)brace
id|ap-&gt;cur_rx
op_assign
id|idx
suffix:semicolon
r_return
suffix:semicolon
id|error
suffix:colon
id|idx
op_assign
id|rxretprd
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|ace_interrupt
r_static
r_void
id|ace_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|idx
suffix:semicolon
id|u32
id|txcsm
comma
id|rxretcsm
comma
id|rxretprd
suffix:semicolon
id|u32
id|evtcsm
comma
id|evtprd
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
multiline_comment|/*&n;&t; * In case of PCI shared interrupts or spurious interrupts,&n;&t; * we want to make sure it is actually our interrupt before&n;&t; * spending any time in here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;HostCtrl
)paren
op_amp
id|IN_INT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the card not to generate interrupts while we are in here.&n;&t; */
id|writel
c_func
(paren
l_int|1
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no conflict between transmit handling in&n;&t; * start_xmit and receive processing, thus there is no reason&n;&t; * to take a spin lock for RX handling. Wait until we start&n;&t; * working on the other stuff - hey we don&squot;t need a spin lock&n;&t; * anymore.&n;&t; */
id|rxretprd
op_assign
op_star
id|ap-&gt;rx_ret_prd
suffix:semicolon
id|rxretcsm
op_assign
id|ap-&gt;cur_rx
suffix:semicolon
r_if
c_cond
(paren
id|rxretprd
op_ne
id|rxretcsm
)paren
id|ace_rx_int
c_func
(paren
id|dev
comma
id|rxretprd
comma
id|rxretcsm
)paren
suffix:semicolon
id|txcsm
op_assign
op_star
id|ap-&gt;tx_csm
suffix:semicolon
id|idx
op_assign
id|ap-&gt;tx_ret_csm
suffix:semicolon
r_if
c_cond
(paren
id|txcsm
op_ne
id|idx
)paren
(brace
r_do
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
dot
id|skb
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Race condition between the code cleaning&n;&t;&t;&t; * the tx queue in the interrupt handler and the&n;&t;&t;&t; * interface close,&n;&t;&t;&t; *&n;&t;&t;&t; * This is a kludge that really should be fixed &n;&t;&t;&t; * by preventing the driver from generating a tx&n;&t;&t;&t; * interrupt when the packet has already been&n;&t;&t;&t; * removed from the tx queue.&n;&t;&t;&t; *&n;&t;&t;&t; * Nailed by Don Dugger and Chip Salzenberg of&n;&t;&t;&t; * VA Linux.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
id|mapping
op_assign
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
dot
id|mapping
suffix:semicolon
id|ap-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|ap-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ap-&gt;pdev
comma
id|mapping
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Question here is whether one should not skip&n;&t;&t;&t; * these writes - I have never seen any errors&n;&t;&t;&t; * caused by the NIC actually trying to access&n;&t;&t;&t; * these incorrectly.&n;&t;&t;&t; */
macro_line|#ifdef ACE_64BIT_PTR
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr.addrhi
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr.addrlo
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|flagsize
op_assign
l_int|0
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|TX_RING_ENTRIES
suffix:semicolon
)brace
r_while
c_loop
(paren
id|idx
op_ne
id|txcsm
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Once we actually get to this point the tx ring has&n;&t;&t; * already been trimmed thus it cannot be full!&n;&t;&t; * Ie. skip the comparison of the tx producer vs. the&n;&t;&t; * consumer.&n;&t;&t; */
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_logical_and
id|xchg
c_func
(paren
op_amp
id|ap-&gt;tx_full
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This does not need to be atomic (and expensive),&n;&t;&t;&t; * I&squot;ve seen cases where it would fail otherwise ;-(&n;&t;&t;&t; */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ace_mark_net_bh
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * TX ring is no longer full, aka the&n;&t;&t;&t; * transmitter is working fine - kill timer.&n;&t;&t;&t; */
id|del_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
)brace
id|ap-&gt;tx_ret_csm
op_assign
id|txcsm
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|evtcsm
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;EvtCsm
)paren
suffix:semicolon
id|evtprd
op_assign
op_star
id|ap-&gt;evt_prd
suffix:semicolon
r_if
c_cond
(paren
id|evtcsm
op_ne
id|evtprd
)paren
(brace
id|evtcsm
op_assign
id|ace_handle_event
c_func
(paren
id|dev
comma
id|evtcsm
comma
id|evtprd
)paren
suffix:semicolon
id|writel
c_func
(paren
id|evtcsm
comma
op_amp
id|regs-&gt;EvtCsm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This has to go last in the interrupt handler and run with&n;&t; * the spin lock released ... what lock?&n;&t; */
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
r_int
id|cur_size
suffix:semicolon
r_int
id|run_tasklet
op_assign
l_int|0
suffix:semicolon
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_size
OL
id|RX_LOW_STD_THRES
)paren
(brace
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_PANIC_STD_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;std_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;low on std buffers %i&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_std_rx_ring
c_func
(paren
id|ap
comma
id|RX_RING_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_else
id|run_tasklet
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_size
OL
id|RX_LOW_MINI_THRES
)paren
(brace
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_PANIC_MINI_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;mini_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;low on mini buffers %i&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_mini_rx_ring
c_func
(paren
id|ap
comma
id|RX_MINI_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_else
id|run_tasklet
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
(brace
id|cur_size
op_assign
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_jumbo_bufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_size
OL
id|RX_LOW_JUMBO_THRES
)paren
(brace
r_if
c_cond
(paren
(paren
id|cur_size
OL
id|RX_PANIC_JUMBO_THRES
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;low on jumbo buffers %i&bslash;n&quot;
comma
id|cur_size
)paren
suffix:semicolon
macro_line|#endif
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
op_minus
id|cur_size
)paren
suffix:semicolon
)brace
r_else
id|run_tasklet
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|run_tasklet
op_logical_and
op_logical_neg
id|ap-&gt;tasklet_pending
)paren
(brace
id|ap-&gt;tasklet_pending
op_assign
l_int|1
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|ap-&gt;ace_tasklet
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allow the card to generate interrupts again&n;&t; */
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|regs-&gt;Mb0Lo
)paren
suffix:semicolon
)brace
DECL|function|ace_open
r_static
r_int
id|ace_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;fw_running
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Firmware not running!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|writel
c_func
(paren
id|dev-&gt;mtu
op_plus
id|ETH_HLEN
op_plus
l_int|4
comma
op_amp
id|regs-&gt;IfMtu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Zero the stats when restarting the interface...&n;&t; */
id|memset
c_func
(paren
op_amp
id|ap-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
id|ap-&gt;stats
)paren
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_CLEAR_STATS
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_HOST_STATE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_STACK_UP
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;jumbo
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ap-&gt;promisc
op_assign
l_int|0
suffix:semicolon
)brace
id|ap-&gt;mcast_all
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
id|cmd.evt
op_assign
id|C_LNK_NEGOTIATION
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ACE_MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the timer&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
id|ap-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|ap-&gt;timer.function
op_assign
id|ace_timer
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the bottom half rx ring refill handler&n;&t; */
id|tasklet_init
c_func
(paren
op_amp
id|ap-&gt;ace_tasklet
comma
id|ace_tasklet
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_close
r_static
r_int
id|ace_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ace_if_down
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;promisc
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|0
suffix:semicolon
)brace
id|cmd.evt
op_assign
id|C_HOST_STATE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_STACK_DOWN
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|ap-&gt;ace_tasklet
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure one CPU is not processing packets while&n;&t; * buffers are being released by another.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|dma_addr_t
id|mapping
suffix:semicolon
id|skb
op_assign
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|i
)braket
dot
id|skb
suffix:semicolon
id|mapping
op_assign
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|i
)braket
dot
id|mapping
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|memset
c_func
(paren
op_amp
id|ap-&gt;tx_ring
(braket
id|i
)braket
dot
id|addr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tx_desc
)paren
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ap-&gt;pdev
comma
id|mapping
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
(brace
id|cmd.evt
op_assign
id|C_RESET_JUMBO_RNG
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ACE_MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_start_xmit
r_static
r_int
id|ace_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
id|u32
id|idx
comma
id|flagsize
suffix:semicolon
multiline_comment|/*&n;&t; * This only happens with pre-softnet, ie. 2.2.x kernels.&n;&t; */
r_if
c_cond
(paren
id|early_stop_netif_stop_queue
c_func
(paren
id|dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|idx
op_assign
id|ap-&gt;tx_prd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|TX_RING_ENTRIES
op_eq
id|ap-&gt;tx_ret_csm
)paren
(brace
id|ap-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: trying to transmit while the tx ring is full &quot;
l_string|&quot;- this should not happen!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
dot
id|skb
op_assign
id|skb
suffix:semicolon
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
dot
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|ap-&gt;pdev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;skb-&gt;tx_skbuff
(braket
id|idx
)braket
dot
id|mapping
suffix:semicolon
id|flagsize
op_assign
(paren
id|skb-&gt;len
op_lshift
l_int|16
)paren
op_or
(paren
id|BD_FLG_END
)paren
suffix:semicolon
id|set_aceaddr
c_func
(paren
op_amp
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|addr
comma
id|addr
)paren
suffix:semicolon
id|ap-&gt;tx_ring
(braket
id|idx
)braket
dot
id|flagsize
op_assign
id|flagsize
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|idx
op_assign
(paren
id|idx
op_plus
l_int|1
)paren
op_mod
id|TX_RING_ENTRIES
suffix:semicolon
id|ap-&gt;tx_prd
op_assign
id|idx
suffix:semicolon
id|ace_set_txprd
c_func
(paren
id|regs
comma
id|ap
comma
id|idx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * tx_csm is set by the NIC whereas we set tx_ret_csm which&n;&t; * is always trying to catch tx_csm&n;&t; */
r_if
c_cond
(paren
(paren
id|idx
op_plus
l_int|2
)paren
op_mod
id|TX_RING_ENTRIES
op_eq
id|ap-&gt;tx_ret_csm
)paren
(brace
id|ap-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Queue is full, add timer to detect whether the&n;&t;&t; * transmitter is stuck. Use mod_timer as we can get&n;&t;&t; * into the situation where we risk adding several&n;&t;&t; * timers.&n;&t;&t; */
id|mod_timer
c_func
(paren
op_amp
id|ap-&gt;timer
comma
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The following check will fix a race between the interrupt&n;&t;&t; * handler increasing the tx_ret_csm and testing for tx_full&n;&t;&t; * and this tx routine&squot;s testing the tx_ret_csm and setting&n;&t;&t; * the tx_full; note that this fix makes assumptions on the&n;&t;&t; * ordering of writes (sequential consistency will fly; TSO&n;&t;&t; * processor order would work too) but that&squot;s what lock-less&n;&t;&t; * programming is all about&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|idx
op_plus
l_int|2
)paren
op_mod
id|TX_RING_ENTRIES
op_ne
id|ap-&gt;tx_ret_csm
)paren
op_logical_and
id|xchg
c_func
(paren
op_amp
id|ap-&gt;tx_full
comma
l_int|0
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|ap-&gt;timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We may not need this one in the post softnet era&n;&t;&t;&t; * in this case this can be changed to a&n;&t;&t;&t; * early_stop_netif_wake_queue(dev);&n;&t;&t;&t; */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|late_stop_netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|early_stop_netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_change_mtu
r_static
r_int
id|ace_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_mtu
OL
l_int|68
)paren
op_logical_or
(paren
id|new_mtu
OG
id|ACE_JUMBO_MTU
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|writel
c_func
(paren
id|new_mtu
op_plus
id|ETH_HLEN
op_plus
l_int|4
comma
op_amp
id|regs-&gt;IfMtu
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_if
c_cond
(paren
id|new_mtu
OG
id|ACE_STD_MTU
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ap-&gt;jumbo
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling Jumbo frame &quot;
l_string|&quot;support&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;jumbo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
id|ace_load_jumbo_rx_ring
c_func
(paren
id|ap
comma
id|RX_JUMBO_SIZE
)paren
suffix:semicolon
id|ace_set_rxtx_parms
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ap-&gt;jumbo_refill_busy
)paren
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|ace_set_rxtx_parms
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;jumbo
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|cmd.evt
op_assign
id|C_RESET_JUMBO_RNG
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_ioctl
r_static
r_int
id|ace_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
macro_line|#ifdef SIOCETHTOOL
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_struct
id|ethtool_cmd
id|ecmd
suffix:semicolon
id|u32
id|link
comma
id|speed
suffix:semicolon
macro_line|#ifdef SPIN_DEBUG
r_if
c_cond
(paren
id|cmd
op_eq
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|0x0e
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: dumping debug info&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: tbusy %li, tx_ret_csm %i, &quot;
l_string|&quot;tx_prd %i&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;tbusy
comma
id|ap-&gt;tx_ret_csm
comma
id|ap-&gt;tx_prd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: cur_rx %i, std_refill %li, &quot;
l_string|&quot;mini_rx %i, mini_refill %li&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_rx_bufs
)paren
comma
id|ap-&gt;std_refill_busy
comma
id|atomic_read
c_func
(paren
op_amp
id|ap-&gt;cur_mini_bufs
)paren
comma
id|ap-&gt;mini_refill_busy
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: CpuCtrl %08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd
op_ne
id|SIOCETHTOOL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ecmd
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.cmd
op_eq
id|ETHTOOL_GSET
)paren
(brace
id|ecmd.supported
op_assign
(paren
id|SUPPORTED_10baseT_Half
op_or
id|SUPPORTED_10baseT_Full
op_or
id|SUPPORTED_100baseT_Half
op_or
id|SUPPORTED_100baseT_Full
op_or
id|SUPPORTED_1000baseT_Half
op_or
id|SUPPORTED_1000baseT_Full
op_or
id|SUPPORTED_Autoneg
op_or
id|SUPPORTED_FIBRE
)paren
suffix:semicolon
id|ecmd.port
op_assign
id|PORT_FIBRE
suffix:semicolon
id|ecmd.transceiver
op_assign
id|XCVR_INTERNAL
suffix:semicolon
id|ecmd.phy_address
op_assign
l_int|0
suffix:semicolon
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;GigLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_1000MB
)paren
id|ecmd.speed
op_assign
id|SPEED_1000
suffix:semicolon
r_else
(brace
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;FastLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|ecmd.speed
op_assign
id|SPEED_100
suffix:semicolon
r_else
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|ecmd.speed
op_assign
id|SPEED_10
suffix:semicolon
r_else
id|ecmd.speed
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link
op_amp
id|LNK_FULL_DUPLEX
)paren
id|ecmd.duplex
op_assign
id|DUPLEX_FULL
suffix:semicolon
r_else
id|ecmd.duplex
op_assign
id|DUPLEX_HALF
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_NEGOTIATE
)paren
id|ecmd.autoneg
op_assign
id|AUTONEG_ENABLE
suffix:semicolon
r_else
id|ecmd.autoneg
op_assign
id|AUTONEG_DISABLE
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t; * Current struct ethtool_cmd is insufficient&n;&t;&t; */
id|ecmd.trace
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneTrace
)paren
suffix:semicolon
id|ecmd.txcoal
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneTxCoalTicks
)paren
suffix:semicolon
id|ecmd.rxcoal
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneRxCoalTicks
)paren
suffix:semicolon
macro_line|#endif
id|ecmd.maxtxpkt
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneMaxTxDesc
)paren
suffix:semicolon
id|ecmd.maxrxpkt
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;TuneMaxRxDesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|ecmd
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ecmd.cmd
op_eq
id|ETHTOOL_SSET
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;GigLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_1000MB
)paren
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
r_else
(brace
id|link
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;FastLnkState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|speed
op_assign
id|SPEED_100
suffix:semicolon
r_else
r_if
c_cond
(paren
id|link
op_amp
id|LNK_100MB
)paren
id|speed
op_assign
id|SPEED_10
suffix:semicolon
r_else
id|speed
op_assign
id|SPEED_100
suffix:semicolon
)brace
id|link
op_assign
id|LNK_ENABLE
op_or
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
op_or
id|LNK_RX_FLOW_CTL_Y
op_or
id|LNK_NEG_FCTL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|link
op_or_assign
id|LNK_TX_FLOW_CTL_Y
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.autoneg
op_eq
id|AUTONEG_ENABLE
)paren
id|link
op_or_assign
id|LNK_NEGOTIATE
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.speed
op_ne
id|speed
)paren
(brace
id|link
op_and_assign
op_complement
(paren
id|LNK_1000MB
op_or
id|LNK_100MB
op_or
id|LNK_10MB
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
id|SPEED_1000
suffix:colon
id|link
op_or_assign
id|LNK_1000MB
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPEED_100
suffix:colon
id|link
op_or_assign
id|LNK_100MB
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPEED_10
suffix:colon
id|link
op_or_assign
id|LNK_10MB
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ecmd.duplex
op_eq
id|DUPLEX_FULL
)paren
id|link
op_or_assign
id|LNK_FULL_DUPLEX
suffix:semicolon
r_if
c_cond
(paren
id|link
op_ne
id|ap-&gt;link
)paren
(brace
r_struct
id|cmd
id|cmd
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Renegotiating link state&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ap-&gt;link
op_assign
id|link
suffix:semicolon
id|writel
c_func
(paren
id|link
comma
op_amp
id|regs-&gt;TuneLink
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
id|writel
c_func
(paren
id|link
comma
op_amp
id|regs-&gt;TuneFastLink
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_LNK_NEGOTIATION
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the hardware MAC address.&n; */
DECL|function|ace_set_mac_addr
r_static
r_int
id|ace_set_mac_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|sockaddr
op_star
id|addr
op_assign
id|p
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
id|u8
op_star
id|da
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|da
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;dev_addr
suffix:semicolon
id|regs
op_assign
(paren
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|regs
suffix:semicolon
id|writel
c_func
(paren
id|da
(braket
l_int|0
)braket
op_lshift
l_int|8
op_or
id|da
(braket
l_int|1
)braket
comma
op_amp
id|regs-&gt;MacAddrHi
)paren
suffix:semicolon
id|writel
c_func
(paren
(paren
id|da
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|da
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|da
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
id|da
(braket
l_int|5
)braket
comma
op_amp
id|regs-&gt;MacAddrLo
)paren
suffix:semicolon
id|cmd.evt
op_assign
id|C_SET_MAC_ADDR
suffix:semicolon
id|cmd.code
op_assign
l_int|0
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ace_set_multicast_list
r_static
r_void
id|ace_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_struct
id|cmd
id|cmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
op_logical_neg
(paren
id|ap-&gt;mcast_all
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;mcast_all
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;mcast_all
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;mcast_all
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
op_logical_neg
(paren
id|ap-&gt;promisc
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
id|ap-&gt;promisc
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_PROMISC_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_PROMISC_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|ap-&gt;promisc
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For the time being multicast relies on the upper layers&n;&t; * filtering it properly. The Firmware does not allow one to&n;&t; * set the entire multicast list at a time and keeping track of&n;&t; * it here is going to be messy.&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;mc_count
)paren
op_logical_and
op_logical_neg
(paren
id|ap-&gt;mcast_all
)paren
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_ENABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;mcast_all
)paren
(brace
id|cmd.evt
op_assign
id|C_SET_MULTICAST_MODE
suffix:semicolon
id|cmd.code
op_assign
id|C_C_MCAST_DISABLE
suffix:semicolon
id|cmd.idx
op_assign
l_int|0
suffix:semicolon
id|ace_issue_cmd
c_func
(paren
id|regs
comma
op_amp
id|cmd
)paren
suffix:semicolon
)brace
)brace
DECL|function|ace_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|ace_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ace_mac_stats
op_star
id|mac_stats
op_assign
(paren
r_struct
id|ace_mac_stats
op_star
)paren
id|ap-&gt;regs-&gt;Stats
suffix:semicolon
id|ap-&gt;stats.rx_missed_errors
op_assign
id|readl
c_func
(paren
op_amp
id|mac_stats-&gt;drop_space
)paren
suffix:semicolon
id|ap-&gt;stats.multicast
op_assign
id|readl
c_func
(paren
op_amp
id|mac_stats-&gt;kept_mc
)paren
suffix:semicolon
id|ap-&gt;stats.collisions
op_assign
id|readl
c_func
(paren
op_amp
id|mac_stats-&gt;coll
)paren
suffix:semicolon
r_return
op_amp
id|ap-&gt;stats
suffix:semicolon
)brace
DECL|function|ace_copy
r_void
id|__init
id|ace_copy
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
r_void
op_star
id|src
comma
id|u32
id|dest
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|tdest
suffix:semicolon
id|u32
op_star
id|wsrc
suffix:semicolon
r_int
id|tsize
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|tsize
op_assign
id|min
c_func
(paren
(paren
(paren
op_complement
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
)paren
comma
id|min
c_func
(paren
id|size
comma
id|ACE_WINDOW_SIZE
)paren
)paren
suffix:semicolon
id|tdest
op_assign
(paren
r_int
r_int
)paren
op_amp
id|regs-&gt;Window
op_plus
(paren
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|dest
op_amp
op_complement
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
comma
op_amp
id|regs-&gt;WinBase
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This requires byte swapping on big endian, however&n;&t;&t; * writel does that for us&n;&t;&t; */
id|wsrc
op_assign
id|src
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|tsize
op_div
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
id|wsrc
(braket
id|i
)braket
comma
id|tdest
op_plus
id|i
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|dest
op_add_assign
id|tsize
suffix:semicolon
id|src
op_add_assign
id|tsize
suffix:semicolon
id|size
op_sub_assign
id|tsize
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|ace_clear
r_void
id|__init
id|ace_clear
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
id|u32
id|dest
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|tdest
suffix:semicolon
r_int
id|tsize
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|tsize
op_assign
id|min
c_func
(paren
(paren
(paren
op_complement
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
)paren
comma
id|min
c_func
(paren
id|size
comma
id|ACE_WINDOW_SIZE
)paren
)paren
suffix:semicolon
id|tdest
op_assign
(paren
r_int
r_int
)paren
op_amp
id|regs-&gt;Window
op_plus
(paren
id|dest
op_amp
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|dest
op_amp
op_complement
(paren
id|ACE_WINDOW_SIZE
op_minus
l_int|1
)paren
comma
op_amp
id|regs-&gt;WinBase
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|tsize
op_div
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
l_int|0
comma
id|tdest
op_plus
id|i
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|dest
op_add_assign
id|tsize
suffix:semicolon
id|size
op_sub_assign
id|tsize
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Download the firmware into the SRAM on the NIC&n; *&n; * This operation requires the NIC to be halted and is performed with&n; * interrupts disabled and with the spinlock hold.&n; */
DECL|function|ace_load_firmware
r_int
id|__init
id|ace_load_firmware
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ace_private
op_star
id|ap
suffix:semicolon
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
id|ap
op_assign
id|dev-&gt;priv
suffix:semicolon
id|regs
op_assign
id|ap-&gt;regs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;CpuCtrl
)paren
op_amp
id|CPU_HALTED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: trying to download firmware while the &quot;
l_string|&quot;CPU is running!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do not try to clear more than 512KB or we end up seeing&n;&t; * funny things on NICs with only 512KB SRAM&n;&t; */
id|ace_clear
c_func
(paren
id|regs
comma
l_int|0x2000
comma
l_int|0x80000
op_minus
l_int|0x2000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACE_IS_TIGON_I
c_func
(paren
id|ap
)paren
)paren
(brace
id|ace_copy
c_func
(paren
id|regs
comma
id|tigonFwText
comma
id|tigonFwTextAddr
comma
id|tigonFwTextLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigonFwData
comma
id|tigonFwDataAddr
comma
id|tigonFwDataLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigonFwRodata
comma
id|tigonFwRodataAddr
comma
id|tigonFwRodataLen
)paren
suffix:semicolon
id|ace_clear
c_func
(paren
id|regs
comma
id|tigonFwBssAddr
comma
id|tigonFwBssLen
)paren
suffix:semicolon
id|ace_clear
c_func
(paren
id|regs
comma
id|tigonFwSbssAddr
comma
id|tigonFwSbssLen
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;version
op_eq
l_int|2
)paren
(brace
id|ace_clear
c_func
(paren
id|regs
comma
id|tigon2FwBssAddr
comma
id|tigon2FwBssLen
)paren
suffix:semicolon
id|ace_clear
c_func
(paren
id|regs
comma
id|tigon2FwSbssAddr
comma
id|tigon2FwSbssLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigon2FwText
comma
id|tigon2FwTextAddr
comma
id|tigon2FwTextLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigon2FwRodata
comma
id|tigon2FwRodataAddr
comma
id|tigon2FwRodataLen
)paren
suffix:semicolon
id|ace_copy
c_func
(paren
id|regs
comma
id|tigon2FwData
comma
id|tigon2FwDataAddr
comma
id|tigon2FwDataLen
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The eeprom on the AceNIC is an Atmel i2c EEPROM.&n; *&n; * Accessing the EEPROM is `interesting&squot; to say the least - don&squot;t read&n; * this code right after dinner.&n; *&n; * This is all about black magic and bit-banging the device .... I&n; * wonder in what hospital they have put the guy who designed the i2c&n; * specs.&n; *&n; * Oh yes, this is only the beginning!&n; *&n; * Thanks to Stevarino Webinski for helping tracking down the bugs in the&n; * code i2c readout code by beta testing all my hacks.&n; */
DECL|function|eeprom_start
r_static
r_void
id|__init
id|eeprom_start
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
)paren
(brace
id|u32
id|local
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_DATA_OUT
op_or
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|eeprom_prep
r_static
r_void
id|__init
id|eeprom_prep
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
comma
id|u8
id|magic
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|local
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|local
op_or_assign
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|magic
op_lshift_assign
l_int|1
)paren
(brace
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|magic
op_amp
l_int|0x80
)paren
id|local
op_or_assign
id|EEPROM_DATA_OUT
suffix:semicolon
r_else
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
(paren
id|EEPROM_CLK_OUT
op_or
id|EEPROM_DATA_OUT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|eeprom_check_ack
r_static
r_int
id|__init
id|eeprom_check_ack
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
)paren
(brace
r_int
id|state
suffix:semicolon
id|u32
id|local
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_LONG_DELAY
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
multiline_comment|/* sample data in middle of high clk */
id|state
op_assign
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
id|EEPROM_DATA_IN
)paren
op_ne
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
op_complement
id|EEPROM_CLK_OUT
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|state
suffix:semicolon
)brace
DECL|function|eeprom_stop
r_static
r_void
id|__init
id|eeprom_stop
c_func
(paren
r_struct
id|ace_regs
op_star
id|regs
)paren
(brace
id|u32
id|local
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_LONG_DELAY
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a whole byte from the EEPROM.&n; */
DECL|function|read_eeprom_byte
r_static
r_int
id|__init
id|read_eeprom_byte
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|ace_regs
op_star
id|regs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|local
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No device!&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|eeprom_read_error
suffix:semicolon
)brace
id|regs
op_assign
(paren
(paren
r_struct
id|ace_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|regs
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t take interrupts on this CPU will bit banging&n;&t; * the %#%#@$ I2C device&n;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|eeprom_start
c_func
(paren
id|regs
)paren
suffix:semicolon
id|eeprom_prep
c_func
(paren
id|regs
comma
id|EEPROM_WRITE_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to sync eeprom&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|eeprom_read_error
suffix:semicolon
)brace
id|eeprom_prep
c_func
(paren
id|regs
comma
(paren
id|offset
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to set address byte 0&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|eeprom_read_error
suffix:semicolon
)brace
id|eeprom_prep
c_func
(paren
id|regs
comma
id|offset
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to set address byte 1&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|eeprom_read_error
suffix:semicolon
)brace
id|eeprom_start
c_func
(paren
id|regs
)paren
suffix:semicolon
id|eeprom_prep
c_func
(paren
id|regs
comma
id|EEPROM_READ_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_check_ack
c_func
(paren
id|regs
)paren
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to set READ_SELECT&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|eeprom_read_error
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_LONG_DELAY
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|local
op_or_assign
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
multiline_comment|/* sample data mid high clk */
id|result
op_assign
(paren
id|result
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
id|EEPROM_DATA_IN
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|local
op_assign
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|local
op_and_assign
op_complement
id|EEPROM_CLK_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|7
)paren
(brace
id|local
op_or_assign
id|EEPROM_WRITE_ENABLE
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
)brace
)brace
id|local
op_or_assign
id|EEPROM_DATA_OUT
suffix:semicolon
id|writel
c_func
(paren
id|local
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_or
id|EEPROM_CLK_OUT
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_LONG_DELAY
)paren
suffix:semicolon
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|regs-&gt;LocalCtrl
)paren
op_amp
op_complement
id|EEPROM_CLK_OUT
comma
op_amp
id|regs-&gt;LocalCtrl
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ACE_SHORT_DELAY
)paren
suffix:semicolon
id|eeprom_stop
c_func
(paren
id|regs
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|eeprom_read_error
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to read eeprom byte 0x%02lx&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|offset
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Local variables:&n; * compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I../../include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -pipe -fno-strength-reduce -DMODVERSIONS -include ../../include/linux/modversions.h   -c -o acenic.o acenic.c&quot;&n; * End:&n; */
eof
