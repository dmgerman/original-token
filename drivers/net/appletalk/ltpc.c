multiline_comment|/***    ltpc.c -- a driver for the LocalTalk PC card.&n; *&n; *      Copyright (c) 1995,1996 Bradford W. Johnson &lt;johns393@maroon.tc.umn.edu&gt;&n; *&n; *      This software may be used and distributed according to the terms&n; *      of the GNU General Public License, incorporated herein by reference.&n; *&n; *      This is ALPHA code at best.  It may not work for you.  It may&n; *      damage your equipment.  It may damage your relations with other&n; *      users of your network.  Use it at your own risk!&n; *&n; *      Based in part on:&n; *      skeleton.c      by Donald Becker&n; *      dummy.c         by Nick Holloway and Alan Cox&n; *      loopback.c      by Ross Biro, Fred van Kampen, Donald Becker&n; *      the netatalk source code (UMICH)&n; *      lots of work on the card...&n; *&n; *      I do not have access to the (proprietary) SDK that goes with the card.&n; *      If you do, I don&squot;t want to know about it, and you can probably write&n; *      a better driver yourself anyway.  This does mean that the pieces that&n; *      talk to the card are guesswork on my part, so use at your own risk!&n; *&n; *      This is my first try at writing Linux networking code, and is also&n; *      guesswork.  Again, use at your own risk!  (Although on this part, I&squot;d&n; *      welcome suggestions)&n; *&n; *      This is a loadable kernel module which seems to work at my site&n; *      consisting of a 1.2.13 linux box running netatalk 1.3.3, and with&n; *      the kernel support from 1.3.3b2 including patches routing.patch&n; *      and ddp.disappears.from.chooser.  In order to run it, you will need&n; *      to patch ddp.c and aarp.c in the kernel, but only a little...&n; *&n; *      I&squot;m fairly confident that while this is arguably badly written, the&n; *      problems that people experience will be &quot;higher level&quot;, that is, with&n; *      complications in the netatalk code.  The driver itself doesn&squot;t do&n; *      anything terribly complicated -- it pretends to be an ether device&n; *      as far as netatalk is concerned, strips the DDP data out of the ether&n; *      frame and builds a LLAP packet to send out the card.  In the other&n; *      direction, it receives LLAP frames from the card and builds a fake&n; *      ether packet that it then tosses up to the networking code.  You can&n; *      argue (correctly) that this is an ugly way to do things, but it&n; *      requires a minimal amount of fooling with the code in ddp.c and aarp.c.&n; *&n; *      The card will do a lot more than is used here -- I *think* it has the&n; *      layers up through ATP.  Even if you knew how that part works (which I&n; *      don&squot;t) it would be a big job to carve up the kernel ddp code to insert&n; *      things at a higher level, and probably a bad idea...&n; *&n; *      There are a number of other cards that do LocalTalk on the PC.  If&n; *      nobody finds any insurmountable (at the netatalk level) problems&n; *      here, this driver should encourage people to put some work into the&n; *      other cards (some of which I gather are still commercially available)&n; *      and also to put hooks for LocalTalk into the official ddp code.&n; *&n; *      I welcome comments and suggestions.  This is my first try at Linux&n; *      networking stuff, and there are probably lots of things that I did&n; *      suboptimally.  &n; *&n; ***/
multiline_comment|/***&n; *&n; * $Log: ltpc.c,v $&n; * Revision 1.1.2.1  2000/03/01 05:35:07  jgarzik&n; * at and tr cleanup&n; *&n; * Revision 1.8  1997/01/28 05:44:54  bradford&n; * Clean up for non-module a little.&n; * Hacked about a bit to clean things up - Alan Cox &n; * Probably broken it from the origina 1.8&n; *&n;&n; * 1998/11/09: David Huggins-Daines &lt;dhd@debian.org&gt;&n; * Cleaned up the initialization code to use the standard autoirq methods,&n;   and to probe for things in the standard order of i/o, irq, dma.  This&n;   removes the &quot;reset the reset&quot; hack, because I couldn&squot;t figure out an&n;   easy way to get the card to trigger an interrupt after it.&n; * Added support for passing configuration parameters on the kernel command&n;   line and through insmod&n; * Changed the device name from &quot;ltalk0&quot; to &quot;lt0&quot;, both to conform with the&n;   other localtalk driver, and to clear up the inconsistency between the&n;   module and the non-module versions of the driver :-)&n; * Added a bunch of comments (I was going to make some enums for the state&n;   codes and the register offsets, but I&squot;m still not sure exactly what their&n;   semantics are)&n; * Don&squot;t poll anymore in interrupt-driven mode&n; * It seems to work as a module now (as of 2.1.127), but I don&squot;t think&n;   I&squot;m responsible for that...&n;&n; *&n; * Revision 1.7  1996/12/12 03:42:33  bradford&n; * DMA alloc cribbed from 3c505.c.&n; *&n; * Revision 1.6  1996/12/12 03:18:58  bradford&n; * Added virt_to_bus; works in 2.1.13.&n; *&n; * Revision 1.5  1996/12/12 03:13:22  root&n; * xmitQel initialization -- think through better though.&n; *&n; * Revision 1.4  1996/06/18 14:55:55  root&n; * Change names to ltpc. Tabs. Took a shot at dma alloc,&n; * although more needs to be done eventually.&n; *&n; * Revision 1.3  1996/05/22 14:59:39  root&n; * Change dev-&gt;open, dev-&gt;close to track dummy.c in 1.99.(around 7)&n; *&n; * Revision 1.2  1996/05/22 14:58:24  root&n; * Change tabs mostly.&n; *&n; * Revision 1.1  1996/04/23 04:45:09  root&n; * Initial revision&n; *&n; * Revision 0.16  1996/03/05 15:59:56  root&n; * Change ARPHRD_LOCALTLK definition to the &quot;real&quot; one.&n; *&n; * Revision 0.15  1996/03/05 06:28:30  root&n; * Changes for kernel 1.3.70.  Still need a few patches to kernel, but&n; * it&squot;s getting closer.&n; *&n; * Revision 0.14  1996/02/25 17:38:32  root&n; * More cleanups.  Removed query to card on get_stats.&n; *&n; * Revision 0.13  1996/02/21  16:27:40  root&n; * Refix debug_print_skb.  Fix mac.raw gotcha that appeared in 1.3.65.&n; * Clean up receive code a little.&n; *&n; * Revision 0.12  1996/02/19  16:34:53  root&n; * Fix debug_print_skb.  Kludge outgoing snet to 0 when using startup&n; * range.  Change debug to mask: 1 for verbose, 2 for higher level stuff&n; * including packet printing, 4 for lower level (card i/o) stuff.&n; *&n; * Revision 0.11  1996/02/12  15:53:38  root&n; * Added router sends (requires new aarp.c patch)&n; *&n; * Revision 0.10  1996/02/11  00:19:35  root&n; * Change source LTALK_LOGGING debug switch to insmod ... debug=2.&n; *&n; * Revision 0.9  1996/02/10  23:59:35  root&n; * Fixed those fixes for 1.2 -- DANGER!  The at.h that comes with netatalk&n; * has a *different* definition of struct sockaddr_at than the Linux kernel&n; * does.  This is an &quot;insidious and invidious&quot; bug...&n; * (Actually the preceding comment is false -- it&squot;s the atalk.h in the&n; * ancient atalk-0.06 that&squot;s the problem)&n; *&n; * Revision 0.8  1996/02/10 19:09:00  root&n; * Merge 1.3 changes.  Tested OK under 1.3.60.&n; *&n; * Revision 0.7  1996/02/10 17:56:56  root&n; * Added debug=1 parameter on insmod for debugging prints.  Tried&n; * to fix timer unload on rmmod, but I don&squot;t think that&squot;s the problem.&n; *&n; * Revision 0.6  1995/12/31  19:01:09  root&n; * Clean up rmmod, irq comments per feedback from Corin Anderson (Thanks Corey!)&n; * Clean up initial probing -- sometimes the card wakes up latched in reset.&n; *&n; * Revision 0.5  1995/12/22  06:03:44  root&n; * Added comments in front and cleaned up a bit.&n; * This version sent out to people.&n; *&n; * Revision 0.4  1995/12/18  03:46:44  root&n; * Return shortDDP to longDDP fake to 0/0.  Added command structs.&n; *&n; ***/
multiline_comment|/* ltpc jumpers are:&n;*&n;*&t;Interrupts -- set at most one.  If none are set, the driver uses&n;*&t;polled mode.  Because the card was developed in the XT era, the&n;*&t;original documentation refers to IRQ2.  Since you&squot;ll be running&n;*&t;this on an AT (or later) class machine, that really means IRQ9.&n;*&n;*&t;SW1&t;IRQ 4&n;*&t;SW2&t;IRQ 3&n;*&t;SW3&t;IRQ 9 (2 in original card documentation only applies to XT)&n;*&n;*&n;*&t;DMA -- choose DMA 1 or 3, and set both corresponding switches.&n;*&n;*&t;SW4&t;DMA 3&n;*&t;SW5&t;DMA 1&n;*&t;SW6&t;DMA 3&n;*&t;SW7&t;DMA 1&n;*&n;*&n;*&t;I/O address -- choose one.  &n;*&n;*&t;SW8&t;220 / 240&n;*/
multiline_comment|/*&t;To have some stuff logged, do &n;*&t;insmod ltpc.o debug=1&n;*&n;*&t;For a whole bunch of stuff, use higher numbers.&n;*&n;*&t;The default is 0, i.e. no messages except for the probe results.&n;*/
multiline_comment|/* insmod-tweakable variables */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|macro|DEBUG_VERBOSE
mdefine_line|#define DEBUG_VERBOSE 1
DECL|macro|DEBUG_UPPER
mdefine_line|#define DEBUG_UPPER 2
DECL|macro|DEBUG_LOWER
mdefine_line|#define DEBUG_LOWER 4
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma
r_static
r_int
id|dma
op_assign
l_int|0
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_ltalk.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/atalk.h&gt;
multiline_comment|/* our stuff */
macro_line|#include &quot;ltpc.h&quot;
multiline_comment|/* function prototypes */
r_static
r_int
id|do_read
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|cbuf
comma
r_int
id|cbuflen
comma
r_void
op_star
id|dbuf
comma
r_int
id|dbuflen
)paren
suffix:semicolon
r_static
r_int
id|sendup_buffer
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Dma Memory related stuff, cribbed directly from 3c505.c */
DECL|function|dma_mem_alloc
r_static
r_int
r_int
id|dma_mem_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
r_return
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
id|order
)paren
suffix:semicolon
)brace
multiline_comment|/* DMA data buffer, DMA command buffer */
DECL|variable|ltdmabuf
r_static
r_int
r_char
op_star
id|ltdmabuf
suffix:semicolon
DECL|variable|ltdmacbuf
r_static
r_int
r_char
op_star
id|ltdmacbuf
suffix:semicolon
multiline_comment|/* private struct, holds our appletalk address */
DECL|struct|ltpc_private
r_struct
id|ltpc_private
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|my_addr
r_struct
id|at_addr
id|my_addr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* transmit queue element struct */
DECL|struct|xmitQel
r_struct
id|xmitQel
(brace
DECL|member|next
r_struct
id|xmitQel
op_star
id|next
suffix:semicolon
multiline_comment|/* command buffer */
DECL|member|cbuf
r_int
r_char
op_star
id|cbuf
suffix:semicolon
DECL|member|cbuflen
r_int
id|cbuflen
suffix:semicolon
multiline_comment|/* data buffer */
DECL|member|dbuf
r_int
r_char
op_star
id|dbuf
suffix:semicolon
DECL|member|dbuflen
r_int
id|dbuflen
suffix:semicolon
DECL|member|QWrite
r_int
r_char
id|QWrite
suffix:semicolon
multiline_comment|/* read or write data */
DECL|member|mailbox
r_int
r_char
id|mailbox
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* the transmit queue itself */
DECL|variable|xmQhd
DECL|variable|xmQtl
r_static
r_struct
id|xmitQel
op_star
id|xmQhd
op_assign
l_int|NULL
comma
op_star
id|xmQtl
op_assign
l_int|NULL
suffix:semicolon
DECL|function|enQ
r_static
r_void
id|enQ
c_func
(paren
r_struct
id|xmitQel
op_star
id|qel
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|qel-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmQtl
)paren
(brace
id|xmQtl-&gt;next
op_assign
id|qel
suffix:semicolon
)brace
r_else
(brace
id|xmQhd
op_assign
id|qel
suffix:semicolon
)brace
id|xmQtl
op_assign
id|qel
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
id|printk
c_func
(paren
l_string|&quot;enqueued a 0x%02x command&bslash;n&quot;
comma
id|qel-&gt;cbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|deQ
r_static
r_struct
id|xmitQel
op_star
id|deQ
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|xmitQel
op_star
id|qel
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmQhd
)paren
(brace
id|qel
op_assign
id|xmQhd
suffix:semicolon
id|xmQhd
op_assign
id|qel-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xmQhd
)paren
(brace
id|xmQtl
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
op_logical_and
id|qel
)paren
(brace
r_int
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ltpc: dequeued command &quot;
)paren
suffix:semicolon
id|n
op_assign
id|qel-&gt;cbuflen
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|100
)paren
id|n
op_assign
l_int|100
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|qel-&gt;cbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|qel
suffix:semicolon
)brace
multiline_comment|/* and... the queue elements we&squot;ll be using */
DECL|variable|qels
r_static
r_struct
id|xmitQel
id|qels
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* and their corresponding mailboxes */
DECL|variable|mailbox
r_static
r_int
r_char
id|mailbox
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|mboxinuse
r_static
r_int
r_char
id|mboxinuse
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|wait_timeout
r_static
r_int
id|wait_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|c
)paren
(brace
multiline_comment|/* returns true if it stayed c */
multiline_comment|/* this uses base+6, but it&squot;s ok */
r_int
id|i
suffix:semicolon
multiline_comment|/* twenty second or so total */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|200000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
id|inb_p
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|6
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* timed out */
)brace
multiline_comment|/* get the first free mailbox */
DECL|function|getmbox
r_static
r_int
id|getmbox
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|mboxinuse
(braket
id|i
)braket
)paren
(brace
id|mboxinuse
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* read a command from the card */
DECL|function|handlefc
r_static
r_void
id|handlefc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* called *only* from idle, non-reentrant */
r_int
id|dma
op_assign
id|dev-&gt;dma
suffix:semicolon
r_int
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma
comma
id|virt_to_bus
c_func
(paren
id|ltdmacbuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma
comma
l_int|50
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|3
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xfc
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;timed out in handlefc&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* read data from the card */
DECL|function|handlefd
r_static
r_void
id|handlefd
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|dma
op_assign
id|dev-&gt;dma
suffix:semicolon
r_int
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma
comma
id|virt_to_bus
c_func
(paren
id|ltdmabuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma
comma
l_int|800
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|3
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xfd
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;timed out in handlefd&bslash;n&quot;
)paren
suffix:semicolon
id|sendup_buffer
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|handlewrite
r_static
r_void
id|handlewrite
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* called *only* from idle, non-reentrant */
multiline_comment|/* on entry, 0xfb and ltdmabuf holds data */
r_int
id|dma
op_assign
id|dev-&gt;dma
suffix:semicolon
r_int
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma
comma
id|virt_to_bus
c_func
(paren
id|ltdmabuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma
comma
l_int|800
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|3
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xfb
)paren
)paren
(brace
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;timed out in handlewrite, dma res %d&bslash;n&quot;
comma
id|get_dma_residue
c_func
(paren
id|dev-&gt;dma
)paren
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|handleread
r_static
r_void
id|handleread
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* on entry, 0xfb */
multiline_comment|/* on exit, ltdmabuf holds data */
r_int
id|dma
op_assign
id|dev-&gt;dma
suffix:semicolon
r_int
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma
comma
id|virt_to_bus
c_func
(paren
id|ltdmabuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma
comma
l_int|800
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|3
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xfb
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;timed out in handleread&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|handlecommand
r_static
r_void
id|handlecommand
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* on entry, 0xfa and ltdmacbuf holds command */
r_int
id|dma
op_assign
id|dev-&gt;dma
suffix:semicolon
r_int
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma
comma
id|virt_to_bus
c_func
(paren
id|ltdmacbuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma
comma
l_int|50
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|3
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xfa
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;timed out in handlecommand&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ready made command for getting the result from the card */
DECL|variable|rescbuf
r_static
r_int
r_char
id|rescbuf
(braket
l_int|2
)braket
op_assign
(brace
id|LT_GETRESULT
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|resdbuf
r_static
r_int
r_char
id|resdbuf
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|QInIdle
r_static
r_int
id|QInIdle
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* idle expects to be called with the IRQ line high -- either because of&n; * an interrupt, or because the line is tri-stated&n; */
DECL|function|idle
r_static
r_void
id|idle
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|state
suffix:semicolon
multiline_comment|/* FIXME This is initialized to shut the warning up, but I need to&n;&t; * think this through again.&n;&t; */
r_struct
id|xmitQel
op_star
id|q
op_assign
l_int|0
suffix:semicolon
r_int
id|oops
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QInIdle
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|QInIdle
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* this tri-states the IRQ line */
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|base
op_plus
l_int|6
)paren
suffix:semicolon
id|oops
op_assign
l_int|100
suffix:semicolon
id|loop
suffix:colon
r_if
c_cond
(paren
l_int|0
OG
id|oops
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;idle: looped too many times&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|state
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|inb_p
c_func
(paren
id|base
op_plus
l_int|6
)paren
)paren
r_goto
id|loop
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
l_int|0xfc
suffix:colon
multiline_comment|/* incoming command */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
id|printk
c_func
(paren
l_string|&quot;idle: fc&bslash;n&quot;
)paren
suffix:semicolon
id|handlefc
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xfd
suffix:colon
multiline_comment|/* incoming data */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;idle: fd&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|handlefd
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf9
suffix:colon
multiline_comment|/* result ready */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
id|printk
c_func
(paren
l_string|&quot;idle: f9&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mboxinuse
(braket
l_int|0
)braket
)paren
(brace
id|mboxinuse
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|cbuf
op_assign
id|rescbuf
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|cbuflen
op_assign
l_int|2
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|dbuf
op_assign
id|resdbuf
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|dbuflen
op_assign
l_int|2
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|QWrite
op_assign
l_int|0
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|mailbox
op_assign
l_int|0
suffix:semicolon
id|enQ
c_func
(paren
op_amp
id|qels
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|inb_p
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|1
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xf9
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;timed out idle f9&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0xf8
suffix:colon
multiline_comment|/* ?? */
r_if
c_cond
(paren
id|xmQhd
)paren
(brace
id|inb_p
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|1
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_timeout
c_func
(paren
id|dev
comma
l_int|0xf8
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;timed out idle f8&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0xfa
suffix:colon
multiline_comment|/* waiting for command */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;idle: fa&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xmQhd
)paren
(brace
id|q
op_assign
id|deQ
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ltdmacbuf
comma
id|q-&gt;cbuf
comma
id|q-&gt;cbuflen
)paren
suffix:semicolon
id|ltdmacbuf
(braket
l_int|1
)braket
op_assign
id|q-&gt;mailbox
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
r_int
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ltpc: sent command     &quot;
)paren
suffix:semicolon
id|n
op_assign
id|q-&gt;cbuflen
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|100
)paren
id|n
op_assign
l_int|100
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|ltdmacbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|handlecommand
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0xfa
op_eq
id|inb_p
c_func
(paren
id|base
op_plus
l_int|6
)paren
)paren
(brace
multiline_comment|/* we timed out, so return */
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we don&squot;t seem to have a command */
r_if
c_cond
(paren
op_logical_neg
id|mboxinuse
(braket
l_int|0
)braket
)paren
(brace
id|mboxinuse
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|cbuf
op_assign
id|rescbuf
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|cbuflen
op_assign
l_int|2
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|dbuf
op_assign
id|resdbuf
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|dbuflen
op_assign
l_int|2
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|QWrite
op_assign
l_int|0
suffix:semicolon
id|qels
(braket
l_int|0
)braket
dot
id|mailbox
op_assign
l_int|0
suffix:semicolon
id|enQ
c_func
(paren
op_amp
id|qels
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;trouble: response command already queued&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|0Xfb
suffix:colon
multiline_comment|/* data transfer ready */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_LOWER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;idle: fb&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;QWrite
)paren
(brace
id|memcpy
c_func
(paren
id|ltdmabuf
comma
id|q-&gt;dbuf
comma
id|q-&gt;dbuflen
)paren
suffix:semicolon
id|handlewrite
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|handleread
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* non-zero mailbox numbers are for&n;&t;&t;&t;&t;   commmands, 0 is for GETRESULT&n;&t;&t;&t;&t;   requests */
r_if
c_cond
(paren
id|q-&gt;mailbox
)paren
(brace
id|memcpy
c_func
(paren
id|q-&gt;dbuf
comma
id|ltdmabuf
comma
id|q-&gt;dbuflen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this was a result */
id|mailbox
(braket
l_int|0x0f
op_amp
id|ltdmabuf
(braket
l_int|0
)braket
)braket
op_assign
id|ltdmabuf
(braket
l_int|1
)braket
suffix:semicolon
id|mboxinuse
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_goto
id|loop
suffix:semicolon
id|done
suffix:colon
id|QInIdle
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* now set the interrupts back as appropriate */
multiline_comment|/* the first read takes it out of tri-state (but still high) */
multiline_comment|/* the second resets it */
multiline_comment|/* note that after this point, any read of base+6 will&n;&t;   trigger an interrupt */
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
(brace
id|inb_p
c_func
(paren
id|base
op_plus
l_int|7
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|base
op_plus
l_int|7
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|do_write
r_static
r_int
id|do_write
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|cbuf
comma
r_int
id|cbuflen
comma
r_void
op_star
id|dbuf
comma
r_int
id|dbuflen
)paren
(brace
r_int
id|i
op_assign
id|getmbox
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|qels
(braket
id|i
)braket
dot
id|cbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|cbuf
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|cbuflen
op_assign
id|cbuflen
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|dbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|dbuf
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|dbuflen
op_assign
id|dbuflen
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|QWrite
op_assign
l_int|1
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|mailbox
op_assign
id|i
suffix:semicolon
multiline_comment|/* this should be initted rather */
id|enQ
c_func
(paren
op_amp
id|qels
(braket
id|i
)braket
)paren
suffix:semicolon
id|idle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ret
op_assign
id|mailbox
(braket
id|i
)braket
suffix:semicolon
id|mboxinuse
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ltpc: could not allocate mbox&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|do_read
r_static
r_int
id|do_read
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|cbuf
comma
r_int
id|cbuflen
comma
r_void
op_star
id|dbuf
comma
r_int
id|dbuflen
)paren
(brace
r_int
id|i
op_assign
id|getmbox
c_func
(paren
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|qels
(braket
id|i
)braket
dot
id|cbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|cbuf
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|cbuflen
op_assign
id|cbuflen
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|dbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|dbuf
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|dbuflen
op_assign
id|dbuflen
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|QWrite
op_assign
l_int|0
suffix:semicolon
id|qels
(braket
id|i
)braket
dot
id|mailbox
op_assign
id|i
suffix:semicolon
multiline_comment|/* this should be initted rather */
id|enQ
c_func
(paren
op_amp
id|qels
(braket
id|i
)braket
)paren
suffix:semicolon
id|idle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ret
op_assign
id|mailbox
(braket
id|i
)braket
suffix:semicolon
id|mboxinuse
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ltpc: could not allocate mbox&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end of idle handlers -- what should be seen is do_read, do_write */
DECL|variable|ltpc_timer
r_static
r_struct
id|timer_list
id|ltpc_timer
suffix:semicolon
r_static
r_int
id|ltpc_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|ltpc_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|function|read_30
r_static
r_int
id|read_30
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|lt_command
id|c
suffix:semicolon
id|c.getflags.command
op_assign
id|LT_GETFLAGS
suffix:semicolon
r_return
id|do_read
c_func
(paren
id|dev
comma
op_amp
id|c
comma
r_sizeof
(paren
id|c.getflags
)paren
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|set_30
r_static
r_int
id|set_30
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|x
)paren
(brace
id|lt_command
id|c
suffix:semicolon
id|c.setflags.command
op_assign
id|LT_SETFLAGS
suffix:semicolon
id|c.setflags.flags
op_assign
id|x
suffix:semicolon
r_return
id|do_write
c_func
(paren
id|dev
comma
op_amp
id|c
comma
r_sizeof
(paren
id|c.setflags
)paren
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* LLAP to DDP translation */
DECL|function|sendup_buffer
r_static
r_int
id|sendup_buffer
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* on entry, command is in ltdmacbuf, data in ltdmabuf */
multiline_comment|/* called from idle, non-reentrant */
r_int
id|dnode
comma
id|snode
comma
id|llaptype
comma
id|len
suffix:semicolon
r_int
id|sklen
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
(paren
(paren
r_struct
id|ltpc_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
r_struct
id|lt_rcvlap
op_star
id|ltc
op_assign
(paren
r_struct
id|lt_rcvlap
op_star
)paren
id|ltdmacbuf
suffix:semicolon
r_if
c_cond
(paren
id|ltc-&gt;command
op_ne
id|LT_RCVLAP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unknown command 0x%02x from ltpc card&bslash;n&quot;
comma
id|ltc-&gt;command
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dnode
op_assign
id|ltc-&gt;dnode
suffix:semicolon
id|snode
op_assign
id|ltc-&gt;snode
suffix:semicolon
id|llaptype
op_assign
id|ltc-&gt;laptype
suffix:semicolon
id|len
op_assign
id|ltc-&gt;length
suffix:semicolon
id|sklen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|llaptype
op_eq
l_int|1
)paren
id|sklen
op_add_assign
l_int|8
suffix:semicolon
multiline_comment|/* correct for short ddp */
r_if
c_cond
(paren
id|sklen
OG
l_int|800
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: nonsense length in ltpc command 0x14: 0x%08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sklen
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|llaptype
op_eq
l_int|0
)paren
op_logical_or
(paren
id|llaptype
OG
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unknown LLAP type: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|llaptype
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|3
op_plus
id|sklen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: dropping packet due to memory squeeze.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|sklen
OG
id|len
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|8
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|len
op_plus
l_int|3
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_LOCALTALK
)paren
suffix:semicolon
multiline_comment|/* add LLAP header */
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|dnode
suffix:semicolon
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|snode
suffix:semicolon
id|skb-&gt;data
(braket
l_int|2
)braket
op_assign
id|llaptype
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* save pointer to llap header */
id|skb_pull
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* copy ddp(s,e)hdr + contents */
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
(paren
r_void
op_star
)paren
id|ltdmabuf
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* toss it onwards */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the handler for the board interrupt */
DECL|function|ltpc_interrupt
r_static
r_void
id|ltpc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|reg_ptr
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ltpc_interrupt: unknown device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|inb_p
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* disable further interrupts from board */
id|idle
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* handle whatever is coming in */
multiline_comment|/* idle re-enables interrupts from board */
r_return
suffix:semicolon
)brace
multiline_comment|/***&n; *&n; *    The ioctls that the driver responds to are:&n; *&n; *    SIOCSIFADDR -- do probe using the passed node hint.&n; *    SIOCGIFADDR -- return net, node.&n; *&n; *    some of this stuff should be done elsewhere.&n; *&n; ***/
DECL|function|ltpc_ioctl
r_static
r_int
id|ltpc_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|sockaddr_at
op_star
id|sa
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|ifr-&gt;ifr_addr
suffix:semicolon
multiline_comment|/* we&squot;ll keep the localtalk node address in dev-&gt;pa_addr */
r_struct
id|at_addr
op_star
id|aa
op_assign
op_amp
(paren
(paren
r_struct
id|ltpc_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|my_addr
suffix:semicolon
r_struct
id|lt_init
id|c
suffix:semicolon
r_int
id|ltflags
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ltpc_ioctl called&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSIFADDR
suffix:colon
id|aa-&gt;s_net
op_assign
id|sa-&gt;sat_addr.s_net
suffix:semicolon
multiline_comment|/* this does the probe and returns the node addr */
id|c.command
op_assign
id|LT_INIT
suffix:semicolon
id|c.hint
op_assign
id|sa-&gt;sat_addr.s_node
suffix:semicolon
id|aa-&gt;s_node
op_assign
id|do_read
c_func
(paren
id|dev
comma
op_amp
id|c
comma
r_sizeof
(paren
id|c
)paren
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* get all llap frames raw */
id|ltflags
op_assign
id|read_30
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ltflags
op_or_assign
id|LT_FLAG_ALLLAP
suffix:semicolon
id|set_30
(paren
id|dev
comma
id|ltflags
)paren
suffix:semicolon
id|dev-&gt;broadcast
(braket
l_int|0
)braket
op_assign
l_int|0xFF
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
id|aa-&gt;s_node
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
id|sa-&gt;sat_addr.s_net
op_assign
id|aa-&gt;s_net
suffix:semicolon
id|sa-&gt;sat_addr.s_node
op_assign
id|aa-&gt;s_node
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* This needs to be present to keep netatalk happy. */
multiline_comment|/* Actually netatalk needs fixing! */
)brace
DECL|function|ltpc_hard_header
r_static
r_int
id|ltpc_hard_header
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ltpc_hard_header called for device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ltpc_init
r_static
r_int
id|ltpc_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Initialize the device structure. */
multiline_comment|/* Fill in the fields of the device structure with ethernet-generic values. */
id|ltalk_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ltpc_xmit
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|ltpc_hard_header
suffix:semicolon
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ltpc_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: could not allocate statistics buffer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ltpc_private
)paren
)paren
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ltpc_get_stats
suffix:semicolon
multiline_comment|/* add the ltpc-specific things */
id|dev-&gt;do_ioctl
op_assign
op_amp
id|ltpc_ioctl
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;mc_list
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ltpc_poll_counter
r_static
r_int
id|ltpc_poll_counter
op_assign
l_int|0
suffix:semicolon
DECL|function|ltpc_poll
r_static
r_void
id|ltpc_poll
c_func
(paren
r_int
r_int
id|l
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|l
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ltpc_poll_counter
)paren
(brace
id|ltpc_poll_counter
op_assign
l_int|50
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ltpc poll is alive&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ltpc_poll_counter
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
multiline_comment|/* we&squot;ve been downed */
id|idle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ltpc_timer.expires
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* DDP to LLAP translation */
DECL|function|ltpc_xmit
r_static
r_int
id|ltpc_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* in kernel 1.3.xx, on entry skb-&gt;data points to ddp header,&n;&t; * and skb-&gt;len is the length of the ddp data + ddp header&n;&t; */
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
(paren
(paren
r_struct
id|ltpc_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|lt_sendlap
id|cbuf
suffix:semicolon
id|cbuf.command
op_assign
id|LT_SENDLAP
suffix:semicolon
id|cbuf.dnode
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|cbuf.laptype
op_assign
id|skb-&gt;data
(braket
l_int|2
)braket
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* skip past LLAP header */
id|cbuf.length
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* this is host order */
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_UPPER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;command &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|cbuf
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|do_write
c_func
(paren
id|dev
comma
op_amp
id|cbuf
comma
r_sizeof
(paren
id|cbuf
)paren
comma
id|skb-&gt;h.raw
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_UPPER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sent %d ddp bytes&bslash;n&quot;
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|skb-&gt;h.raw
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|stats-&gt;tx_packets
op_increment
suffix:semicolon
id|stats-&gt;tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ltpc_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|ltpc_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
(paren
(paren
r_struct
id|ltpc_private
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
r_return
id|stats
suffix:semicolon
)brace
multiline_comment|/* initialization stuff */
DECL|function|ltpc_probe_dma
r_static
r_int
id|__init
id|ltpc_probe_dma
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|dma
op_assign
l_int|0
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_dma
c_func
(paren
l_int|1
comma
l_string|&quot;ltpc&quot;
)paren
)paren
(brace
id|f
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
l_int|1
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
l_int|1
comma
id|virt_to_bus
c_func
(paren
id|ltdmabuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lt_mem
)paren
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
id|dma
op_or_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_dma
c_func
(paren
l_int|3
comma
l_string|&quot;ltpc&quot;
)paren
)paren
(brace
id|f
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
l_int|3
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
l_int|3
comma
id|virt_to_bus
c_func
(paren
id|ltdmabuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
l_int|3
comma
r_sizeof
(paren
r_struct
id|lt_mem
)paren
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
id|dma
op_or_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* set up request */
multiline_comment|/* FIXME -- do timings better! */
id|ltdmabuf
(braket
l_int|0
)braket
op_assign
id|LT_READMEM
suffix:semicolon
id|ltdmabuf
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* mailbox */
id|ltdmabuf
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|ltdmabuf
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* address */
id|ltdmabuf
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|ltdmabuf
(braket
l_int|5
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* read 0x0100 bytes */
id|ltdmabuf
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dunno if this is necessary */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|0
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|100
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_if
c_cond
(paren
l_int|0xfa
op_eq
id|inb_p
c_func
(paren
id|io
op_plus
l_int|6
)paren
)paren
r_break
suffix:semicolon
)brace
id|inb_p
c_func
(paren
id|io
op_plus
l_int|3
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_if
c_cond
(paren
l_int|0xfb
op_eq
id|inb_p
c_func
(paren
id|io
op_plus
l_int|6
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* release the other dma channel (if we opened both of them) */
r_if
c_cond
(paren
(paren
id|dma
op_amp
l_int|0x2
)paren
op_logical_and
(paren
id|get_dma_residue
c_func
(paren
l_int|3
)paren
op_eq
r_sizeof
(paren
r_struct
id|lt_mem
)paren
)paren
)paren
(brace
id|dma
op_and_assign
l_int|1
suffix:semicolon
id|free_dma
c_func
(paren
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dma
op_amp
l_int|0x1
)paren
op_logical_and
(paren
id|get_dma_residue
c_func
(paren
l_int|1
)paren
op_eq
r_sizeof
(paren
r_struct
id|lt_mem
)paren
)paren
)paren
(brace
id|dma
op_and_assign
l_int|0x2
suffix:semicolon
id|free_dma
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* fix up dma number */
id|dma
op_or_assign
l_int|1
suffix:semicolon
r_return
id|dma
suffix:semicolon
)brace
DECL|function|ltpc_probe
r_int
id|__init
id|ltpc_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|x
op_assign
l_int|0
comma
id|y
op_assign
l_int|0
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|autoirq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* probe for the I/O port address */
r_if
c_cond
(paren
id|io
op_ne
l_int|0x240
op_logical_and
op_logical_neg
id|check_region
c_func
(paren
l_int|0x220
comma
l_int|8
)paren
)paren
(brace
id|x
op_assign
id|inb_p
c_func
(paren
l_int|0x220
op_plus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_ne
l_int|0xff
)paren
op_logical_and
(paren
id|x
op_ge
l_int|0xf0
)paren
)paren
id|io
op_assign
l_int|0x220
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io
op_ne
l_int|0x220
op_logical_and
op_logical_neg
id|check_region
c_func
(paren
l_int|0x240
comma
l_int|8
)paren
)paren
(brace
id|y
op_assign
id|inb_p
c_func
(paren
l_int|0x240
op_plus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|y
op_ne
l_int|0xff
)paren
op_logical_and
(paren
id|y
op_ge
l_int|0xf0
)paren
)paren
id|io
op_assign
l_int|0x240
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io
)paren
(brace
multiline_comment|/* found it, now grab it */
id|request_region
c_func
(paren
id|io
comma
l_int|8
comma
l_string|&quot;ltpc&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* give up in despair */
id|printk
(paren
l_string|&quot;LocalTalk card not found; 220 = %02x, 240 = %02x.&bslash;n&quot;
comma
id|x
comma
id|y
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* probe for the IRQ line */
r_if
c_cond
(paren
id|irq
OL
l_int|2
)paren
(brace
id|autoirq_setup
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* reset the interrupt line */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|7
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* trigger an interrupt (I hope) */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|6
)paren
suffix:semicolon
id|autoirq
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autoirq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ltpc: probe at %#x failed to detect IRQ line.&bslash;n&quot;
comma
id|io
)paren
suffix:semicolon
)brace
r_else
(brace
id|irq
op_assign
id|autoirq
suffix:semicolon
)brace
)brace
multiline_comment|/* allocate a DMA buffer */
id|ltdmabuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|dma_mem_alloc
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ltdmabuf
)paren
id|ltdmacbuf
op_assign
op_amp
id|ltdmabuf
(braket
l_int|800
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ltdmabuf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ltpc: mem alloc failed&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ltdmabuf pointer %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ltdmabuf
)paren
suffix:semicolon
)brace
multiline_comment|/* reset the card */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|1
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|3
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* hold it in reset for a coupla jiffies */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|0
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* clear reset */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|4
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|5
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|io
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* enable dma */
id|inb_p
c_func
(paren
id|io
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* tri-state interrupt line */
id|timeout
op_assign
id|jiffies
op_plus
l_int|100
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
multiline_comment|/* wait for the card to complete initialization */
)brace
multiline_comment|/* now, figure out which dma channel we&squot;re using, unless it&squot;s&n;&t;   already been specified */
multiline_comment|/* well, 0 is a legal DMA channel, but the LTPC card doesn&squot;t&n;&t;   use it... */
r_if
c_cond
(paren
id|dma
op_eq
l_int|0
)paren
(brace
id|dma
op_assign
id|ltpc_probe_dma
c_func
(paren
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma
)paren
(brace
multiline_comment|/* no dma channel */
id|printk
c_func
(paren
l_string|&quot;No DMA channel found on ltpc card.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* print out friendly message */
r_if
c_cond
(paren
id|irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Apple/Farallon LocalTalk-PC card at %03x, IR%d, DMA%d.&bslash;n&quot;
comma
id|io
comma
id|irq
comma
id|dma
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Apple/Farallon LocalTalk-PC card at %03x, DMA%d.  Using polled mode.&bslash;n&quot;
comma
id|io
comma
id|dma
)paren
suffix:semicolon
multiline_comment|/* seems more logical to do this *after* probing the card... */
id|err
op_assign
id|ltpc_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|io
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|dev-&gt;dma
op_assign
id|dma
suffix:semicolon
multiline_comment|/* the card will want to send a result at this point */
multiline_comment|/* (I think... leaving out this part makes the kernel crash,&n;           so I put it back in...) */
id|f
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma
comma
id|virt_to_bus
c_func
(paren
id|ltdmabuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma
comma
l_int|0x100
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|io
op_plus
l_int|3
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|io
op_plus
l_int|2
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|100
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_if
c_cond
(paren
l_int|0xf9
op_eq
id|inb_p
c_func
(paren
id|io
op_plus
l_int|6
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;setting up timer and irq&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
)paren
(brace
multiline_comment|/* grab it and don&squot;t let go :-) */
(paren
r_void
)paren
id|request_irq
c_func
(paren
id|irq
comma
op_amp
id|ltpc_interrupt
comma
l_int|0
comma
l_string|&quot;ltpc&quot;
comma
id|dev
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|io
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* enable interrupts from board */
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|io
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* and reset irq line */
)brace
r_else
(brace
multiline_comment|/* polled mode -- 20 times per second */
multiline_comment|/* this is really, really slow... should it poll more often? */
id|init_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
suffix:semicolon
id|ltpc_timer.function
op_assign
id|ltpc_poll
suffix:semicolon
id|ltpc_timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|ltpc_timer.expires
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/* handles &quot;ltpc=io,irq,dma&quot; kernel command lines */
DECL|function|ltpc_setup
r_static
r_int
id|__init
id|ltpc_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|5
)braket
suffix:semicolon
id|str
op_assign
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|str
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;auto&quot;
comma
l_int|4
)paren
)paren
(brace
multiline_comment|/* do nothing :-) */
)brace
r_else
(brace
multiline_comment|/* usage message */
id|printk
(paren
id|KERN_ERR
l_string|&quot;ltpc: usage: ltpc=auto|iobase[,irq[,dma]]&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|io
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
(brace
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
(brace
id|dma
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
)brace
multiline_comment|/* ignore any other paramters */
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;ltpc=&quot;
comma
id|ltpc_setup
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
DECL|variable|dev_ltpc
r_static
r_struct
id|net_device
id|dev_ltpc
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|__init
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
comma
id|result
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ltpc: Autoprobing is not recommended for modules&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Find a name for this unit */
id|dev_ltpc.init
op_assign
id|ltpc_probe
suffix:semicolon
id|err
op_assign
id|dev_alloc_name
c_func
(paren
op_amp
id|dev_ltpc
comma
l_string|&quot;lt%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|dev_ltpc
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;could not register Localtalk-PC device&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0 from register_netdev&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|ltpc_cleanup
r_static
r_void
id|__exit
id|ltpc_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|timeout
suffix:semicolon
id|ltpc_timer.data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* signal the poll routine that we&squot;re done */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;freeing irq&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_ltpc.irq
)paren
(brace
id|free_irq
c_func
(paren
id|dev_ltpc.irq
comma
op_amp
id|dev_ltpc
)paren
suffix:semicolon
id|dev_ltpc.irq
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
)paren
(brace
multiline_comment|/* either the poll was never started, or a poll is in process */
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;waiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s in process, wait a bit for it to finish */
id|timeout
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|del_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
op_logical_and
id|time_after
c_func
(paren
id|timeout
comma
id|jiffies
)paren
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|ltpc_timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;freeing dma&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_ltpc.dma
)paren
(brace
id|free_dma
c_func
(paren
id|dev_ltpc.dma
)paren
suffix:semicolon
id|dev_ltpc.dma
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;freeing ioaddr&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_ltpc.base_addr
)paren
(brace
id|release_region
c_func
(paren
id|dev_ltpc.base_addr
comma
l_int|8
)paren
suffix:semicolon
id|dev_ltpc.base_addr
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_pages&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ltdmabuf
comma
id|get_order
c_func
(paren
l_int|1000
)paren
)paren
suffix:semicolon
id|ltdmabuf
op_assign
l_int|NULL
suffix:semicolon
id|ltdmacbuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unregister_netdev&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|unregister_netdev
c_func
(paren
op_amp
id|dev_ltpc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
id|DEBUG_VERBOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;returning from cleanup_module&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|variable|ltpc_cleanup
id|module_exit
c_func
(paren
id|ltpc_cleanup
)paren
suffix:semicolon
eof
