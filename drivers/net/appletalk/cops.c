multiline_comment|/*      cops.c: LocalTalk driver for Linux.&n; *&n; *&t;Authors:&n; *      - Jay Schulist &lt;jschlst@turbolinux.com&gt;&n; *&n; *&t;With more than a little help from;&n; *&t;- Alan Cox &lt;Alan.Cox@linux.org&gt; &n; *&n; *      Derived from:&n; *      - skeleton.c: A network driver outline for linux.&n; *        Written 1993-94 by Donald Becker.&n; *&t;- ltpc.c: A driver for the LocalTalk PC card.&n; *&t;  Written by Bradford W. Johnson.&n; *&n; *      Copyright 1993 United States Government as represented by the&n; *      Director, National Security Agency.&n; *&n; *      This software may be used and distributed according to the terms&n; *      of the GNU Public License, incorporated herein by reference.&n; *&n; *&t;Changes:&n; *&t;19970608&t;Alan Cox&t;Allowed dual card type support&n; *&t;&t;&t;&t;&t;Can set board type in insmod&n; *&t;&t;&t;&t;&t;Hooks for cops_setup routine&n; *&t;&t;&t;&t;&t;(not yet implemented).&n; *&t;19971101&t;Jay Schulist&t;Fixes for multiple lt* devices.&n; *&t;19980607&t;Steven Hirsch&t;Fixed the badly broken support&n; *&t;&t;&t;&t;&t;for Tangent type cards. Only&n; *                                      tested on Daystar LT200. Some&n; *                                      cleanup of formatting and program&n; *                                      logic.  Added emacs &squot;local-vars&squot;&n; *                                      setup for Jay&squot;s brace style.&n; *&t;20000211&t;Alan Cox&t;Cleaned up for softnet&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;cops.c:v0.04 6/7/98 Jay Schulist &lt;jschlst@turbolinux.com&gt;&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; *  Sources:&n; *      COPS Localtalk SDK. This provides almost all of the information&n; *      needed.&n; */
multiline_comment|/*&n; * insmod/modprobe configurable stuff.&n; *&t;- IO Port, choose one your card supports or 0 if you dare.&n; *&t;- IRQ, also choose one your card supports or nothing and let&n; *&t;  the driver figure it out.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_ltalk.h&gt;&t;/* For ltalk_setup() */
macro_line|#include &lt;linux/delay.h&gt;&t;/* For udelay() */
macro_line|#include &lt;linux/atalk.h&gt;
macro_line|#include &quot;cops.h&quot;&t;&t;/* Our Stuff */
macro_line|#include &quot;cops_ltdrv.h&quot;&t;&t;/* Firmware code for Tangent type cards. */
macro_line|#include &quot;cops_ffdrv.h&quot;&t;&t;/* Firmware code for Dayna type cards. */
multiline_comment|/*&n; *      The name of the card. Is used for messages and in the requests for&n; *      io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;cops&quot;
suffix:semicolon
macro_line|#ifdef CONFIG_COPS_DAYNA
DECL|variable|board_type
r_static
r_int
id|board_type
op_assign
id|DAYNA
suffix:semicolon
multiline_comment|/* Module exported */
macro_line|#else
DECL|variable|board_type
r_static
r_int
id|board_type
op_assign
id|TANGENT
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x240
suffix:semicolon
multiline_comment|/* Default IO for Dayna */
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* Default IRQ */
macro_line|#else
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default IO for Dayna */
macro_line|#endif
multiline_comment|/*&n; *&t;COPS Autoprobe information.&n; *&t;Right now if port address is right but IRQ is not 5 this will&n; *      return a 5 no matter what since we will still get a status response.&n; *      Need one more additional check to narrow down after we have gotten&n; *      the ioaddr. But since only other possible IRQs is 3 and 4 so no real&n; *&t;hurry on this. I *STRONGLY* recommend using IRQ 5 for your card with&n; *&t;this driver.&n; * &n; *&t;This driver has 2 modes and they are: Dayna mode and Tangent mode.&n; *&t;Each mode corresponds with the type of card. It has been found&n; *&t;that there are 2 main types of cards and all other cards are&n; *&t;the same and just have different names or only have minor differences&n; *&t;such as more IO ports. As this driver is tested it will&n; *&t;become more clear on exactly what cards are supported. The driver&n; *&t;defaults to using Dayna mode. To change the drivers mode, simply&n; *&t;select Dayna or Tangent mode when configuring the kernel.&n; *&n; *      This driver should support:&n; *      TANGENT driver mode:&n; *              Tangent ATB-II, Novell NL-1000, Daystar Digital LT-200,&n; *&t;&t;COPS LT-1&n; *      DAYNA driver mode:&n; *              Dayna DL2000/DaynaTalk PC (Half Length), COPS LT-95, &n; *&t;&t;Farallon PhoneNET PC III, Farallon PhoneNET PC II&n; *&t;Other cards possibly supported mode unkown though:&n; *&t;&t;Dayna DL2000 (Full length), COPS LT/M (Micro-Channel)&n; *&n; *&t;Cards NOT supported by this driver but supported by the ltpc.c&n; *&t;driver written by Bradford W. Johnson &lt;johns393@maroon.tc.umn.edu&gt;&n; *&t;&t;Farallon PhoneNET PC&n; *&t;&t;Original Apple LocalTalk PC card&n; * &n; *      N.B.&n; *&n; *      The Daystar Digital LT200 boards do not support interrupt-driven&n; *      IO.  You must specify &squot;irq=0xff&squot; as a module parameter to invoke&n; *      polled mode.  I also believe that the port probing logic is quite&n; *      dangerous at best and certainly hopeless for a polled card.  Best to &n; *      specify both. - Steve H.&n; *&n; */
multiline_comment|/*&n; * Zero terminated list of IO ports to probe.&n; */
DECL|variable|cops_portlist
r_static
r_int
r_int
id|cops_portlist
(braket
)braket
op_assign
(brace
l_int|0x240
comma
l_int|0x340
comma
l_int|0x200
comma
l_int|0x210
comma
l_int|0x220
comma
l_int|0x230
comma
l_int|0x260
comma
l_int|0x2A0
comma
l_int|0x300
comma
l_int|0x310
comma
l_int|0x320
comma
l_int|0x330
comma
l_int|0x350
comma
l_int|0x360
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Zero terminated list of IRQ ports to probe.&n; */
DECL|variable|cops_irqlist
r_static
r_int
id|cops_irqlist
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|4
comma
l_int|3
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|cops_timer
r_static
r_struct
id|timer_list
id|cops_timer
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, 2 for debug, 3 for verbose debug */
macro_line|#ifndef COPS_DEBUG
DECL|macro|COPS_DEBUG
mdefine_line|#define COPS_DEBUG 1 
macro_line|#endif
DECL|variable|cops_debug
r_static
r_int
r_int
id|cops_debug
op_assign
id|COPS_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the card. */
DECL|macro|COPS_IO_EXTENT
mdefine_line|#define COPS_IO_EXTENT       8
multiline_comment|/* Information that needs to be kept for each board. */
DECL|struct|cops_local
r_struct
id|cops_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|board
r_int
id|board
suffix:semicolon
multiline_comment|/* Holds what board type is. */
DECL|member|nodeid
r_int
id|nodeid
suffix:semicolon
multiline_comment|/* Set to 1 once have nodeid. */
DECL|member|node_acquire
r_int
r_char
id|node_acquire
suffix:semicolon
multiline_comment|/* Node ID when acquired. */
DECL|member|node_addr
r_struct
id|at_addr
id|node_addr
suffix:semicolon
multiline_comment|/* Full node addres */
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|cops_probe
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cops_probe1
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|cops_irq
(paren
r_int
id|ioaddr
comma
r_int
id|board
)paren
suffix:semicolon
r_static
r_int
id|cops_open
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cops_jumpstart
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|cops_reset
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|sleep
)paren
suffix:semicolon
r_static
r_void
id|cops_load
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cops_nodeid
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|nodeid
)paren
suffix:semicolon
r_static
r_void
id|cops_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|cops_poll
(paren
r_int
r_int
id|ltdev
)paren
suffix:semicolon
r_static
r_void
id|cops_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|cops_rx
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cops_send_packet
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|cops_hard_header
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|cops_ioctl
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|cops_close
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|cops_get_stats
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; *      Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n; *      If dev-&gt;base_addr == 0, probe all likely locations.&n; *      If dev-&gt;base_addr in [1..0x1ff], always return failure.&n; *        otherwise go with what we pass in.&n; */
DECL|function|cops_probe
r_int
id|__init
id|cops_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
op_eq
l_int|0
op_logical_and
id|io
)paren
(brace
id|base_addr
op_assign
id|io
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
(brace
multiline_comment|/* Check a single specified location. */
r_return
id|cops_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* FIXME  Does this really work for cards which generate irq?&n;&t; * It&squot;s definitely N.G. for polled Tangent. sh&n;&t; * Dayna cards don&squot;t autoprobe well at all, but if your card is&n;&t; * at IRQ 5 &amp; IO 0x240 we find it every time. ;) JS&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cops_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cops_probe1
c_func
(paren
id|dev
comma
id|cops_portlist
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; *      This is the real probe routine. Linux has a history of friendly device&n; *      probes on the ISA bus. A good device probes avoids doing writes, and&n; *      verifies that the correct device exists and functions.&n; */
DECL|function|cops_probe1
r_static
r_int
id|__init
id|cops_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
suffix:semicolon
r_static
r_int
id|version_printed
suffix:semicolon
r_int
id|board
op_assign
id|board_type
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|cops_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* Grab the region so no one else tries to probe our ioports. */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|COPS_IO_EXTENT
comma
id|dev-&gt;name
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;         * Since this board has jumpered interrupts, allocate the interrupt&n;         * vector now. There is no point in waiting since no other device&n;         * can use the interrupt, and this marks the irq as busy. Jumpered&n;         * interrupts are typically not reported by the boards, and we must&n;         * used AutoIRQ to find them.&n;&t; */
r_switch
c_cond
(paren
id|dev-&gt;irq
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* COPS AutoIRQ routine */
id|dev-&gt;irq
op_assign
id|cops_irq
c_func
(paren
id|ioaddr
comma
id|board
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* No IRQ found on this port */
r_goto
id|err_out
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Fixup for users that don&squot;t know that IRQ 2 is really&n;&t;&t; * IRQ 9, or don&squot;t know which one to set.&n;&t;&t; */
r_case
l_int|2
suffix:colon
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Polled operation requested. Although irq of zero passed as&n;&t;&t; * a parameter tells the init routines to probe, we&squot;ll&n;&t;&t; * overload it to denote polled operation at runtime.&n;&t;&t; */
r_case
l_int|0xff
suffix:colon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Reserve any actual interrupt. */
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
(brace
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|cops_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|err_out
suffix:semicolon
)brace
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* Initialize the private device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cops_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|lp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cops_local
)paren
)paren
suffix:semicolon
multiline_comment|/* Copy local board variable to lp struct. */
id|lp-&gt;board
op_assign
id|board
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with LocalTalk values. */
id|ltalk_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|cops_send_packet
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|cops_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
op_star
l_int|2
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|cops_hard_header
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|cops_get_stats
suffix:semicolon
id|dev-&gt;open
op_assign
id|cops_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|cops_close
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|cops_ioctl
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;mc_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Tell the user where the card is and what mode we&squot;re in. */
r_if
c_cond
(paren
id|board
op_eq
id|DAYNA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x, using IRQ %d, in Dayna mode.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|ioaddr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|board
op_eq
id|TANGENT
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x, IRQ %d, in Tangent mode&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|ioaddr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x, using polled IO, in Tangent mode.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|release_region
c_func
(paren
id|ioaddr
comma
id|COPS_IO_EXTENT
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|cops_irq
r_static
r_int
id|__init
id|cops_irq
(paren
r_int
id|ioaddr
comma
r_int
id|board
)paren
(brace
multiline_comment|/*&n;         * This does not use the IRQ to determine where the IRQ is. We just&n;         * assume that when we get a correct status response that it&squot;s the IRQ.&n;         * This really just verifies the IO port but since we only have access&n;         * to such a small number of IRQs (5, 4, 3) this is not bad.&n;         * This will probably not work for more than one card.&n;         */
r_int
id|irqaddr
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|board
op_eq
id|DAYNA
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DAYNA_RESET
)paren
suffix:semicolon
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_RESET
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|333
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|board
op_eq
id|TANGENT
)paren
(brace
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|TANG_RESET
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cops_irqlist
(braket
id|i
)braket
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irqaddr
op_assign
id|cops_irqlist
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0xFFFF
suffix:semicolon
id|x
OG
l_int|0
suffix:semicolon
id|x
op_decrement
)paren
multiline_comment|/* wait for response */
(brace
r_if
c_cond
(paren
id|board
op_eq
id|DAYNA
)paren
(brace
id|status
op_assign
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|1
)paren
(brace
r_return
id|irqaddr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|board
op_eq
id|TANGENT
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
op_amp
id|TANG_TX_READY
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|irqaddr
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no IRQ found */
)brace
multiline_comment|/*&n; * Open/initialize the board. This is called (in the current kernel)&n; * sometime after booting when the &squot;ifconfig&squot; program is run.&n; */
DECL|function|cops_open
r_static
r_int
id|cops_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * I don&squot;t know if the Dayna-style boards support polled &n;&t;&t; * operation.  For now, only allow it for Tangent.&n;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
multiline_comment|/* Poll 20 times per second */
(brace
id|init_timer
c_func
(paren
op_amp
id|cops_timer
)paren
suffix:semicolon
id|cops_timer.function
op_assign
id|cops_poll
suffix:semicolon
id|cops_timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|cops_timer.expires
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|cops_timer
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No irq line set&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|cops_jumpstart
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Start the card up. */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This allows for a dynamic start/restart of the entire card.&n; */
DECL|function|cops_jumpstart
r_static
r_int
id|cops_jumpstart
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;         *      Once the card has the firmware loaded and has acquired&n;         *      the nodeid, if it is reset it will lose it all.&n;         */
id|cops_reset
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Need to reset card before load firmware. */
id|cops_load
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Load the firmware. */
multiline_comment|/*&n;&t; *&t;If atalkd already gave us a nodeid we will use that&n;&t; *&t;one again, else we wait for atalkd to give us a nodeid&n;&t; *&t;in cops_ioctl. This may cause a problem if someone steals&n;&t; *&t;our nodeid while we are resetting.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;nodeid
op_eq
l_int|1
)paren
(brace
id|cops_nodeid
c_func
(paren
id|dev
comma
id|lp-&gt;node_acquire
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tangent_wait_reset
r_static
r_void
id|tangent_wait_reset
c_func
(paren
r_int
id|ioaddr
)paren
(brace
r_int
id|timeout
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_increment
OL
l_int|5
op_logical_and
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
op_amp
id|TANG_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait 1 second */
)brace
multiline_comment|/*&n; *      Reset the LocalTalk board.&n; */
DECL|function|cops_reset
r_static
r_void
id|cops_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|sleep
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
(brace
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Clear request latch. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Clear the TANG_TX_READY flop. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|TANG_RESET
)paren
suffix:semicolon
multiline_comment|/* Reset the adapter. */
id|tangent_wait_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|TANG_CLEAR_INT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DAYNA_RESET
)paren
suffix:semicolon
multiline_comment|/* Assert the reset port */
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_RESET
)paren
suffix:semicolon
multiline_comment|/* Clear the reset */
r_if
c_cond
(paren
id|sleep
)paren
(brace
r_int
id|snap
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Let card finish initializing, about 1/3 second */
r_while
c_loop
(paren
id|jiffies
op_minus
id|snap
OL
id|HZ
op_div
l_int|3
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|mdelay
c_func
(paren
l_int|333
)paren
suffix:semicolon
)brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|cops_load
r_static
r_void
id|cops_load
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|ltfirmware
op_star
id|ltf
op_assign
(paren
r_struct
id|ltfirmware
op_star
)paren
op_amp
id|ifr.ifr_data
suffix:semicolon
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|length
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
l_string|&quot;lt0&quot;
)paren
suffix:semicolon
multiline_comment|/* Get card&squot;s firmware code and do some checks on it. */
macro_line|#ifdef CONFIG_COPS_DAYNA        
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
id|ltf-&gt;length
op_assign
r_sizeof
(paren
id|ffdrv_code
)paren
suffix:semicolon
id|ltf-&gt;data
op_assign
id|ffdrv_code
suffix:semicolon
)brace
r_else
macro_line|#endif        
macro_line|#ifdef CONFIG_COPS_TANGENT
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
(brace
id|ltf-&gt;length
op_assign
r_sizeof
(paren
id|ltdrv_code
)paren
suffix:semicolon
id|ltf-&gt;data
op_assign
id|ltdrv_code
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s; unsupported board type.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check to make sure firmware is correct length. */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
op_logical_and
id|ltf-&gt;length
op_ne
l_int|5983
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Firmware is not length of FFDRV.BIN.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
op_logical_and
id|ltf-&gt;length
op_ne
l_int|2501
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Firmware is not length of DRVCODE.BIN.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
multiline_comment|/*&n;                 *      We must wait for a status response&n;                 *      with the DAYNA board.&n;                 */
r_while
c_loop
(paren
op_increment
id|i
OL
l_int|65536
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|65536
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;         *      Upload the firmware and kick. Byte-by-byte works nicely here.&n;         */
id|i
op_assign
l_int|0
suffix:semicolon
id|length
op_assign
id|ltf-&gt;length
suffix:semicolon
r_while
c_loop
(paren
id|length
op_decrement
)paren
(brace
id|outb
c_func
(paren
id|ltf-&gt;data
(braket
id|i
)braket
comma
id|ioaddr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cops_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Uploaded firmware - %d bytes of %d bytes.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
comma
id|ltf-&gt;length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
multiline_comment|/* Tell Dayna to run the firmware code. */
id|outb
c_func
(paren
l_int|1
comma
id|ioaddr
op_plus
id|DAYNA_INT_CARD
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Tell Tang to run the firmware code. */
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
(brace
id|tangent_wait_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Clear initial ready signal. */
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Get the LocalTalk Nodeid from the card. We can suggest&n; *&t;any nodeid 1-254. The card will try and get that exact&n; *&t;address else we can specify 0 as the nodeid and the card&n; *&t;will autoprobe for a nodeid.&n; */
DECL|function|cops_nodeid
r_static
r_int
id|cops_nodeid
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|nodeid
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
multiline_comment|/* Empty any pending adapter responses. */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
id|DAYNA_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|COPS_CLEAR_INT
)paren
suffix:semicolon
multiline_comment|/* Clear interrupts. */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
l_int|0x03
)paren
op_eq
id|DAYNA_RX_REQUEST
)paren
(brace
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Kick any packets waiting. */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|2
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Output command packet length as 2. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|LAP_INIT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Send LAP_INIT command byte. */
id|outb
c_func
(paren
id|nodeid
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Suggest node address. */
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
(brace
multiline_comment|/* Empty any pending adapter responses. */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
op_amp
id|TANG_RX_READY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|COPS_CLEAR_INT
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt. */
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Kick out packets waiting. */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Not sure what Tangent does if nodeid picked is used. */
r_if
c_cond
(paren
id|nodeid
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Seed. */
id|nodeid
op_assign
id|jiffies
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/* Get a random try */
id|outb
c_func
(paren
l_int|2
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Command length LSB */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Command length MSB */
id|outb
c_func
(paren
id|LAP_INIT
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Send LAP_INIT byte */
id|outb
c_func
(paren
id|nodeid
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* LAP address hint. */
id|outb
c_func
(paren
l_int|0xFF
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Int. level to use */
)brace
id|lp-&gt;node_acquire
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set nodeid holder to 0. */
r_while
c_loop
(paren
id|lp-&gt;node_acquire
op_eq
l_int|0
)paren
multiline_comment|/* Get *True* nodeid finally. */
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|COPS_CLEAR_INT
)paren
suffix:semicolon
multiline_comment|/* Clear any interrupt. */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
l_int|0x03
)paren
op_eq
id|DAYNA_RX_REQUEST
)paren
(brace
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Grab the nodeid put in lp-&gt;node_acquire. */
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
op_amp
id|TANG_RX_READY
)paren
(brace
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Grab the nodeid put in lp-&gt;node_acquire. */
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cops_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Node ID %d has been acquired.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;node_acquire
)paren
suffix:semicolon
)brace
id|lp-&gt;nodeid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set got nodeid to 1. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Poll the Tangent type cards to see if we have work.&n; */
DECL|function|cops_poll
r_static
r_void
id|cops_poll
c_func
(paren
r_int
r_int
id|ltdev
)paren
(brace
r_int
id|ioaddr
comma
id|status
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|ltdev
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|cops_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve been downed */
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TANG_RX_READY
)paren
(brace
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TANG_TX_READY
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_increment
id|boguscount
OL
l_int|20
)paren
op_logical_and
(paren
id|status
op_amp
(paren
id|TANG_RX_READY
op_or
id|TANG_TX_READY
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
id|cops_timer.expires
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|cops_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *      The typical workload of the driver:&n; *      Handle the network interface interrupts.&n; */
DECL|function|cops_interrupt
r_static
r_void
id|cops_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|cops_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|0
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
r_do
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|COPS_CLEAR_INT
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x03
)paren
op_eq
id|DAYNA_RX_REQUEST
)paren
(brace
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|boguscount
OL
l_int|20
)paren
(brace
suffix:semicolon
)brace
)brace
r_else
(brace
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TANG_RX_READY
)paren
(brace
id|cops_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TANG_TX_READY
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_increment
id|boguscount
OL
l_int|20
)paren
op_logical_and
(paren
id|status
op_amp
(paren
id|TANG_RX_READY
op_or
id|TANG_TX_READY
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *      We have a good packet(s), get it/them out of the buffers.&n; */
DECL|function|cops_rx
r_static
r_void
id|cops_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|pkt_len
op_assign
l_int|0
suffix:semicolon
r_int
id|rsp_type
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts. */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Send out Zero length. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DATA_READ
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Send read command out. */
multiline_comment|/* Wait for DMA to turn around. */
r_while
c_loop
(paren
op_increment
id|boguscount
OL
l_int|1000000
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
l_int|0x03
)paren
op_eq
id|DAYNA_RX_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|boguscount
op_eq
l_int|1000000
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA timed out.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Get response length. */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
id|pkt_len
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
r_else
id|pkt_len
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
op_amp
l_int|0x00FF
suffix:semicolon
id|pkt_len
op_or_assign
(paren
id|inb
c_func
(paren
id|ioaddr
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Input IO code. */
id|rsp_type
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Malloc up new buffer. */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|pkt_len
op_decrement
)paren
(brace
multiline_comment|/* Discard packet */
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_LOCALTALK
)paren
suffix:semicolon
id|insb
c_func
(paren
id|ioaddr
comma
id|skb-&gt;data
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Eat the Data */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
id|outb
c_func
(paren
l_int|1
comma
id|ioaddr
op_plus
id|DAYNA_INT_CARD
)paren
suffix:semicolon
)brace
multiline_comment|/* Interrupt the card */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Restore interrupts. */
multiline_comment|/* Check for bad response length */
r_if
c_cond
(paren
id|pkt_len
template_param
id|MAX_LLAP_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Bad packet length of %d bytes.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Set nodeid and then get out. */
r_if
c_cond
(paren
id|rsp_type
op_eq
id|LAP_INIT_RSP
)paren
(brace
multiline_comment|/* Nodeid taken from received packet. */
id|lp-&gt;node_acquire
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* One last check to make sure we have a good packet. */
r_if
c_cond
(paren
id|rsp_type
op_ne
id|LAP_RESPONSE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Bad packet type %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rsp_type
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Point to entire packet. */
id|skb_pull
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Point to data (Skip header). */
multiline_comment|/* Update the counters. */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Send packet to a higher place. */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|cops_timeout
r_static
r_void
id|cops_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
op_amp
id|TANG_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No TX complete interrupt.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Transmit timed out.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cops_jumpstart
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Restart the card. */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Make the card transmit a LocalTalk packet.&n; */
DECL|function|cops_send_packet
r_static
r_int
id|cops_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;         * Block a timer-based transmit from overlapping. &n;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts. */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
multiline_comment|/* Wait for adapter transmit buffer. */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
id|DAYNA_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
)paren
multiline_comment|/* Wait for adapter transmit buffer. */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|TANG_CARD_STATUS
)paren
op_amp
id|TANG_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Output IO length. */
id|outb
c_func
(paren
id|skb-&gt;len
comma
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
id|outb
c_func
(paren
id|skb-&gt;len
op_rshift
l_int|8
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
id|outb
c_func
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0x0FF
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Output IO code. */
id|outb
c_func
(paren
id|LAP_WRITE
comma
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
multiline_comment|/* Check the transmit buffer again. */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DAYNA_CARD_STATUS
)paren
op_amp
id|DAYNA_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|outsb
c_func
(paren
id|ioaddr
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Send out the data. */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|DAYNA
)paren
(brace
multiline_comment|/* Dayna requires you kick the card */
id|outb
c_func
(paren
l_int|1
comma
id|ioaddr
op_plus
id|DAYNA_INT_CARD
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Restore interrupts. */
multiline_comment|/* Done sending packet, update counters and cleanup. */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Dummy function to keep the Appletalk layer happy.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|cops_debug
op_ge
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: set_multicast_list executed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      Another Dummy function to keep the Appletalk layer happy.&n; */
DECL|function|cops_hard_header
r_static
r_int
id|cops_hard_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|cops_debug
op_ge
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cops_hard_header executed. Wow!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      System ioctls for the COPS LocalTalk card.&n; */
DECL|function|cops_ioctl
r_static
r_int
id|cops_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|sa
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|ifr-&gt;ifr_addr
suffix:semicolon
r_struct
id|at_addr
op_star
id|aa
op_assign
(paren
r_struct
id|at_addr
op_star
)paren
op_amp
id|lp-&gt;node_addr
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSIFADDR
suffix:colon
multiline_comment|/* Get and set the nodeid and network # atalkd wants. */
id|cops_nodeid
c_func
(paren
id|dev
comma
id|sa-&gt;sat_addr.s_node
)paren
suffix:semicolon
id|aa-&gt;s_net
op_assign
id|sa-&gt;sat_addr.s_net
suffix:semicolon
id|aa-&gt;s_node
op_assign
id|lp-&gt;node_acquire
suffix:semicolon
multiline_comment|/* Set broardcast address. */
id|dev-&gt;broadcast
(braket
l_int|0
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Set hardware address. */
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
id|aa-&gt;s_node
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
id|sa-&gt;sat_addr.s_net
op_assign
id|aa-&gt;s_net
suffix:semicolon
id|sa-&gt;sat_addr.s_node
op_assign
id|aa-&gt;s_node
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;The inverse routine to cops_open().&n; */
DECL|function|cops_close
r_static
r_int
id|cops_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* If we were running polled, yank the timer.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;board
op_eq
id|TANGENT
op_logical_and
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|cops_timer
)paren
suffix:semicolon
)brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      Get the current statistics.&n; *      This may be called with the card open or closed.&n; */
DECL|function|cops_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|cops_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|cops_local
op_star
id|lp
op_assign
(paren
r_struct
id|cops_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|cops0_dev
r_static
r_struct
id|net_device
id|cops0_dev
op_assign
(brace
id|init
suffix:colon
id|cops_probe
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|board_type
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: You shouldn&squot;t autoprobe with insmod&bslash;n&quot;
comma
id|cardname
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy the parameters from insmod into the device structure. */
id|cops0_dev.base_addr
op_assign
id|io
suffix:semicolon
id|cops0_dev.irq
op_assign
id|irq
suffix:semicolon
id|err
op_assign
id|dev_alloc_name
c_func
(paren
op_amp
id|cops0_dev
comma
l_string|&quot;lt%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|cops0_dev
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
id|unregister_netdev
c_func
(paren
op_amp
id|cops0_dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cops0_dev.priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cops0_dev.irq
)paren
(brace
id|free_irq
c_func
(paren
id|cops0_dev.irq
comma
op_amp
id|cops0_dev
)paren
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|cops0_dev.base_addr
comma
id|COPS_IO_EXTENT
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -DMODVERSIONS -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O2 -c cops.c&quot;&n; *  c-basic-offset: 4&n; *  c-file-offsets: ((substatement-open . 0))&n; * End:&n; */
eof
