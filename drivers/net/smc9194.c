multiline_comment|/*------------------------------------------------------------------------&n; . smc9194.c&n; . This is a driver for SMC&squot;s 9000 series of Ethernet cards.&n; .&n; . Copyright (C) 1996 by Erik Stahlman&n; . This software may be used and distributed according to the terms&n; . of the GNU Public License, incorporated herein by reference.&n; .&n; . &quot;Features&quot; of the SMC chip:&n; .   4608 byte packet memory. ( for the 91C92.  Others have more )&n; .   EEPROM for configuration&n; .   AUI/TP selection  ( mine has 10Base2/10BaseT select )&n; .&n; . Arguments:&n; . &t;io&t;&t; = for the base address&n; .&t;irq&t; = for the IRQ&n; .&t;ifport = 0 for autodetect, 1 for TP, 2 for AUI ( or 10base2 )&n; .&n; . author:&n; . &t;Erik Stahlman&t;&t;&t;&t;( erik@vt.edu )&n; . contributors:&n; .      Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; .&n; . Hardware multicast code from Peter Cammaert ( pc@denkart.be )&n; .&n; . Sources:&n; .    o   SMC databook&n; .    o   skeleton.c by Donald Becker ( becker@cesdis.gsfc.nasa.gov )&n; .    o   ( a LOT of advice from Becker as well )&n; .&n; . History:&n; .&t;12/07/95  Erik Stahlman  written, got receive/xmit handled&n; . &t;01/03/96  Erik Stahlman  worked out some bugs, actually usable!!! :-)&n; .&t;01/06/96  Erik Stahlman&t; cleaned up some, better testing, etc&n; .&t;01/29/96  Erik Stahlman&t; fixed autoirq, added multicast&n; . &t;02/01/96  Erik Stahlman&t; 1. disabled all interrupts in smc_reset&n; .&t;&t;   &t;&t; 2. got rid of post-decrementing bug -- UGH.&n; .&t;02/13/96  Erik Stahlman  Tried to fix autoirq failure.  Added more&n; .&t;&t;&t;&t; descriptive error messages.&n; .&t;02/15/96  Erik Stahlman  Fixed typo that caused detection failure&n; . &t;02/23/96  Erik Stahlman&t; Modified it to fit into kernel tree&n; .&t;&t;&t;&t; Added support to change hardware address&n; .&t;&t;&t;&t; Cleared stats on opens&n; .&t;02/26/96  Erik Stahlman&t; Trial support for Kernel 1.2.13&n; .&t;&t;&t;&t; Kludge for automatic IRQ detection&n; .&t;03/04/96  Erik Stahlman&t; Fixed kernel 1.3.70 +&n; .&t;&t;&t;&t; Fixed bug reported by Gardner Buchanan in&n; .&t;&t;&t;&t;   smc_enable, with outw instead of outb&n; .&t;03/06/96  Erik Stahlman  Added hardware multicast from Peter Cammaert&n; .&t;04/14/00  Heiko Pruessing (SMA Regelsysteme)  Fixed bug in chip memory&n; .&t;&t;&t;&t; allocation&n; .      08/20/00  Arnaldo Melo   fix kfree(skb) in smc_hardware_send_packet&n; .      12/15/00  Christian Jullien fix &quot;Warning: kfree_skb on hard IRQ&quot;&n; ----------------------------------------------------------------------------*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;smc9194.c:v0.14 12/15/00 by Erik Stahlman (erik@vt.edu)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;smc9194.h&quot;
multiline_comment|/*------------------------------------------------------------------------&n; .&n; . Configuration options, for the experienced user to change.&n; .&n; -------------------------------------------------------------------------*/
multiline_comment|/*&n; . Do you want to use 32 bit xfers?  This should work on all chips, as&n; . the chipset is designed to accommodate them.&n;*/
DECL|macro|USE_32_BIT
mdefine_line|#define USE_32_BIT 1
multiline_comment|/*&n; .the SMC9194 can be at any of the following port addresses.  To change,&n; .for a slightly different card, you can add it to the array.  Keep in&n; .mind that the array must end in zero.&n;*/
DECL|variable|__initdata
r_static
r_int
r_int
id|smc_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x200
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2A0
comma
l_int|0x2C0
comma
l_int|0x2E0
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0x380
comma
l_int|0x3A0
comma
l_int|0x3C0
comma
l_int|0x3E0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; . Wait time for memory to be free.  This probably shouldn&squot;t be&n; . tuned that much, as waiting for this means nothing else happens&n; . in the system&n;*/
DECL|macro|MEMORY_WAIT_TIME
mdefine_line|#define MEMORY_WAIT_TIME 16
multiline_comment|/*&n; . DEBUGGING LEVELS&n; .&n; . 0 for normal operation&n; . 1 for slightly more details&n; . &gt;2 for various levels of increasingly useless information&n; .    2 for interrupt tracking, status flags&n; .    3 for packet dumps, etc.&n;*/
DECL|macro|SMC_DEBUG
mdefine_line|#define SMC_DEBUG 0
macro_line|#if (SMC_DEBUG &gt; 2 )
DECL|macro|PRINTK3
mdefine_line|#define PRINTK3(x) printk x
macro_line|#else
DECL|macro|PRINTK3
mdefine_line|#define PRINTK3(x)
macro_line|#endif
macro_line|#if SMC_DEBUG &gt; 1
DECL|macro|PRINTK2
mdefine_line|#define PRINTK2(x) printk x
macro_line|#else
DECL|macro|PRINTK2
mdefine_line|#define PRINTK2(x)
macro_line|#endif
macro_line|#ifdef SMC_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) printk x
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
macro_line|#endif
multiline_comment|/*------------------------------------------------------------------------&n; .&n; . The internal workings of the driver.  If you are changing anything&n; . here with the SMC stuff, you should have the datasheet and known&n; . what you are doing.&n; .&n; -------------------------------------------------------------------------*/
DECL|macro|CARDNAME
mdefine_line|#define CARDNAME &quot;SMC9194&quot;
multiline_comment|/* store this information for the driver.. */
DECL|struct|smc_local
r_struct
id|smc_local
(brace
multiline_comment|/*&n; &t;   these are things that the kernel wants me to keep, so users&n;&t;   can find out semi-useless statistics of how well the card is&n;&t;   performing&n; &t;*/
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/*&n;&t;   If I have to wait until memory is available to send&n;&t;   a packet, I will store the skbuff here, until I get the&n;&t;   desired memory.  Then, I&squot;ll send it out and free it.&n;&t;*/
DECL|member|saved_skb
r_struct
id|sk_buff
op_star
id|saved_skb
suffix:semicolon
multiline_comment|/*&n; &t; . This keeps track of how many packets that I have&n; &t; . sent out.  When an TX_EMPTY interrupt comes, I know&n;&t; . that all of these have been sent.&n;&t;*/
DECL|member|packets_waiting
r_int
id|packets_waiting
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*-----------------------------------------------------------------&n; .&n; .  The driver can be entered at any of the following entry points.&n; .&n; .------------------------------------------------------------------  */
multiline_comment|/*&n; . This is called by  register_netdev().  It is responsible for&n; . checking the portlist for the SMC9000 series chipset.  If it finds&n; . one, then it will initialize the device, find the hardware information,&n; . and sets up the appropriate device parameters.&n; . NOTE: Interrupts are *OFF* when this procedure is called.&n; .&n; . NB:This shouldn&squot;t be static since it is referred to externally.&n;*/
r_int
id|smc_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . The kernel calls this function when someone wants to use the device,&n; . typically &squot;ifconfig ethX up&squot;.&n;*/
r_static
r_int
id|smc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . Our watchdog timed out. Called by the networking layer&n;*/
r_static
r_void
id|smc_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This is called by the kernel in response to &squot;ifconfig ethX down&squot;.  It&n; . is responsible for cleaning up everything that the open routine&n; . does, and maybe putting the card into a powerdown state.&n;*/
r_static
r_int
id|smc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This routine allows the proc file system to query the driver&squot;s&n; . statistics.&n;*/
r_static
r_struct
id|net_device_stats
op_star
id|smc_query_statistics
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . Finally, a call to set promiscuous mode ( for TCPDUMP and related&n; . programs ) and multicast modes.&n;*/
r_static
r_void
id|smc_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . CRC compute&n; */
r_static
r_int
id|crc32
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|length
)paren
suffix:semicolon
multiline_comment|/*---------------------------------------------------------------&n; .&n; . Interrupt level calls..&n; .&n; ----------------------------------------------------------------*/
multiline_comment|/*&n; . Handles the actual interrupt&n;*/
r_static
r_void
id|smc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; . This is a separate procedure to handle the receipt of a packet, to&n; . leave the interrupt code looking slightly cleaner&n;*/
r_inline
r_static
r_void
id|smc_rcv
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; . This handles a TX interrupt, which is only called when an error&n; . relating to a packet is sent.&n;*/
r_inline
r_static
r_void
id|smc_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; ------------------------------------------------------------&n; .&n; . Internal routines&n; .&n; ------------------------------------------------------------&n;*/
multiline_comment|/*&n; . Test if a given location contains a chip, trying to cause as&n; . little damage as possible if it&squot;s not a SMC chip.&n;*/
r_static
r_int
id|smc_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/*&n; . A rather simple routine to print out a packet for debugging purposes.&n;*/
macro_line|#if SMC_DEBUG &gt; 2
r_static
r_void
id|print_packet
c_func
(paren
id|byte
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) 1
multiline_comment|/* this is called to actually send the packet to the chip */
r_static
r_void
id|smc_hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Since I am not sure if I will have enough room in the chip&squot;s ram&n; . to store the packet, I call this routine, which either sends it&n; . now, or generates an interrupt when the card is ready for the&n; . packet */
r_static
r_int
id|smc_wait_to_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* this does a soft reset on the device */
r_static
r_void
id|smc_reset
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Enable Interrupts, Receive, and Transmit */
r_static
r_void
id|smc_enable
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* this puts the device in an inactive state */
r_static
r_void
id|smc_shutdown
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* This routine will find the IRQ of the driver if one is not&n; . specified in the input to the device.  */
r_static
r_int
id|smc_findirq
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/*&n; . Function: smc_reset( int ioaddr )&n; . Purpose:&n; .  &t;This sets the SMC91xx chip to its normal state, hopefully from whatever&n; . &t;mess that any other DOS driver has put it in.&n; .&n; . Maybe I should reset more registers to defaults in here?  SOFTRESET  should&n; . do that for me.&n; .&n; . Method:&n; .&t;1.  send a SOFT RESET&n; .&t;2.  wait for it to finish&n; .&t;3.  enable autorelease mode&n; .&t;4.  reset the memory management unit&n; .&t;5.  clear all interrupts&n; .&n;*/
DECL|function|smc_reset
r_static
r_void
id|smc_reset
c_func
(paren
r_int
id|ioaddr
)paren
(brace
multiline_comment|/* This resets the registers mostly to defaults, but doesn&squot;t&n;&t;   affect EEPROM.  That seems unnecessary */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
id|RCR_SOFTRESET
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
multiline_comment|/* this should pause enough for the chip to be happy */
id|SMC_DELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set the transmit and receive configuration registers to&n;&t;   default values */
id|outw
c_func
(paren
id|RCR_CLEAR
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TCR_CLEAR
comma
id|ioaddr
op_plus
id|TCR
)paren
suffix:semicolon
multiline_comment|/* set the control register to automatically&n;&t;   release successfully transmitted packets, to make the best&n;&t;   use out of our limited memory */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONTROL
)paren
op_or
id|CTL_AUTO_RELEASE
comma
id|ioaddr
op_plus
id|CONTROL
)paren
suffix:semicolon
multiline_comment|/* Reset the MMU */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_RESET
comma
id|ioaddr
op_plus
id|MMU_CMD
)paren
suffix:semicolon
multiline_comment|/* Note:  It doesn&squot;t seem that waiting for the MMU busy is needed here,&n;&t;   but this is a place where future chipsets _COULD_ break.  Be wary&n; &t;   of issuing another MMU command right after this */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; . Function: smc_enable&n; . Purpose: let the chip talk to the outside work&n; . Method:&n; .&t;1.  Enable the transmitter&n; .&t;2.  Enable the receiver&n; .&t;3.  Enable interrupts&n;*/
DECL|function|smc_enable
r_static
r_void
id|smc_enable
c_func
(paren
r_int
id|ioaddr
)paren
(brace
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* see the header file for options in TCR/RCR NORMAL*/
id|outw
c_func
(paren
id|TCR_NORMAL
comma
id|ioaddr
op_plus
id|TCR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|RCR_NORMAL
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
multiline_comment|/* now, enable interrupts */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SMC_INTERRUPT_MASK
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; . Function: smc_shutdown&n; . Purpose:  closes down the SMC91xxx chip.&n; . Method:&n; .&t;1. zero the interrupt mask&n; .&t;2. clear the enable receive flag&n; .&t;3. clear the enable xmit flags&n; .&n; . TODO:&n; .   (1) maybe utilize power down mode.&n; .&t;Why not yet?  Because while the chip will go into power down mode,&n; .&t;the manual says that it will wake up in response to any I/O requests&n; .&t;in the register space.   Empirical results do not show this working.&n;*/
DECL|function|smc_shutdown
r_static
r_void
id|smc_shutdown
c_func
(paren
r_int
id|ioaddr
)paren
(brace
multiline_comment|/* no more interrupts for me */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
multiline_comment|/* and tell the card to stay away from that nasty outside world */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RCR_CLEAR
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|TCR_CLEAR
comma
id|ioaddr
op_plus
id|TCR
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* finally, shut the chip down */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONTROL
)paren
comma
id|CTL_POWERDOWN
comma
id|ioaddr
op_plus
id|CONTROL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )&n; . Purpose:&n; .    This sets the internal hardware table to filter out unwanted multicast&n; .    packets before they take up memory.&n; .&n; .    The SMC chip uses a hash table where the high 6 bits of the CRC of&n; .    address are the offset into the table.  If that bit is 1, then the&n; .    multicast packet is accepted.  Otherwise, it&squot;s dropped silently.&n; .&n; .    To use the 6 bits as an offset into the table, the high 3 bits are the&n; .    number of the 8 bit register, while the low 3 bits are the bit within&n; .    that register.&n; .&n; . This routine is based very heavily on the one provided by Peter Cammaert.&n;*/
DECL|function|smc_setmulticast
r_static
r_void
id|smc_setmulticast
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|count
comma
r_struct
id|dev_mc_list
op_star
id|addrs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|multicast_table
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|cur_addr
suffix:semicolon
multiline_comment|/* table for flipping the order of 3 bits */
r_int
r_char
id|invert3
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|4
comma
l_int|2
comma
l_int|6
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|7
)brace
suffix:semicolon
multiline_comment|/* start with a table of all zeros: reject all */
id|memset
c_func
(paren
id|multicast_table
comma
l_int|0
comma
r_sizeof
(paren
id|multicast_table
)paren
)paren
suffix:semicolon
id|cur_addr
op_assign
id|addrs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|cur_addr
op_assign
id|cur_addr-&gt;next
)paren
(brace
r_int
id|position
suffix:semicolon
multiline_comment|/* do we have a pointer here? */
r_if
c_cond
(paren
op_logical_neg
id|cur_addr
)paren
r_break
suffix:semicolon
multiline_comment|/* make sure this is a multicast address - shouldn&squot;t this&n;&t;&t;   be a given if we have it here ? */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|cur_addr-&gt;dmi_addr
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* only use the low order bits */
id|position
op_assign
id|crc32
c_func
(paren
id|cur_addr-&gt;dmi_addr
comma
l_int|6
)paren
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* do some messy swapping to put the bit in the right spot */
id|multicast_table
(braket
id|invert3
(braket
id|position
op_amp
l_int|7
)braket
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|invert3
(braket
(paren
id|position
op_rshift
l_int|3
)paren
op_amp
l_int|7
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* now, the table can be loaded into the chipset */
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|multicast_table
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|MULTICAST1
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  Finds the CRC32 of a set of bytes.&n;  Again, from Peter Cammaert&squot;s code.&n;*/
DECL|function|crc32
r_static
r_int
id|crc32
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|length
)paren
(brace
multiline_comment|/* indices */
r_int
id|perByte
suffix:semicolon
r_int
id|perBit
suffix:semicolon
multiline_comment|/* crc polynomial for Ethernet */
r_const
r_int
r_int
id|poly
op_assign
l_int|0xedb88320
suffix:semicolon
multiline_comment|/* crc value - preinitialized to all 1&squot;s */
r_int
r_int
id|crc_value
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|perByte
op_assign
l_int|0
suffix:semicolon
id|perByte
OL
id|length
suffix:semicolon
id|perByte
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
id|c
op_assign
op_star
(paren
id|s
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|perBit
op_assign
l_int|0
suffix:semicolon
id|perBit
OL
l_int|8
suffix:semicolon
id|perBit
op_increment
)paren
(brace
id|crc_value
op_assign
(paren
id|crc_value
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
(paren
id|crc_value
op_xor
id|c
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
id|poly
suffix:colon
l_int|0
)paren
suffix:semicolon
id|c
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|crc_value
suffix:semicolon
)brace
multiline_comment|/*&n; . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )&n; . Purpose:&n; .    Attempt to allocate memory for a packet, if chip-memory is not&n; .    available, then tell the card to generate an interrupt when it&n; .    is available.&n; .&n; . Algorithm:&n; .&n; . o&t;if the saved_skb is not currently null, then drop this packet&n; .&t;on the floor.  This should never happen, because of TBUSY.&n; . o&t;if the saved_skb is null, then replace it with the current packet,&n; . o&t;See if I can sending it now.&n; . o &t;(NO): Enable interrupts and let the interrupt handler deal with it.&n; . o&t;(YES):Send it now.&n;*/
DECL|function|smc_wait_to_send_packet
r_static
r_int
id|smc_wait_to_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|word
id|length
suffix:semicolon
r_int
r_int
id|numPages
suffix:semicolon
id|word
id|time_out
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Well, I want to send the packet.. but I don&squot;t know&n;&t;   if I can send it right now...  */
r_if
c_cond
(paren
id|lp-&gt;saved_skb
)paren
(brace
multiline_comment|/* THIS SHOULD NEVER HAPPEN. */
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|CARDNAME
l_string|&quot;: Bad Craziness - sent packet while busy.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lp-&gt;saved_skb
op_assign
id|skb
suffix:semicolon
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
multiline_comment|/*&n;&t;** The MMU wants the number of pages to be the number of 256 bytes&n;&t;** &squot;pages&squot;, minus 1 ( since a packet can&squot;t ever have 0 pages :) )&n;&t;**&n;&t;** Pkt size for allocating is data length +6 (for additional status words,&n;&t;** length and ctl!) If odd size last byte is included in this header.&n;&t;*/
id|numPages
op_assign
(paren
(paren
id|length
op_amp
l_int|0xfffe
)paren
op_plus
l_int|6
)paren
op_div
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|numPages
OG
l_int|7
)paren
(brace
id|printk
c_func
(paren
id|CARDNAME
l_string|&quot;: Far too big packet error. &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* freeing the packet is a good thing here... but should&n;&t;&t; . any packets of this size get down here?   */
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;saved_skb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* this IS an error, but, i don&squot;t want the skb saved */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* either way, a packet is waiting now */
id|lp-&gt;packets_waiting
op_increment
suffix:semicolon
multiline_comment|/* now, try to allocate the memory */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_ALLOC
op_or
id|numPages
comma
id|ioaddr
op_plus
id|MMU_CMD
)paren
suffix:semicolon
multiline_comment|/*&n; &t;. Performance Hack&n;&t;.&n; &t;. wait a short amount of time.. if I can send a packet now, I send&n;&t;. it now.  Otherwise, I enable an interrupt and wait for one to be&n;&t;. available.&n;&t;.&n;&t;. I could have handled this a slightly different way, by checking to&n;&t;. see if any memory was available in the FREE MEMORY register.  However,&n;&t;. either way, I need to generate an allocation, and the allocation works&n;&t;. no matter what, so I saw no point in checking free memory.&n;&t;*/
id|time_out
op_assign
id|MEMORY_WAIT_TIME
suffix:semicolon
r_do
(brace
id|word
id|status
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
(brace
multiline_comment|/* acknowledge the interrupt */
id|outb
c_func
(paren
id|IM_ALLOC_INT
comma
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|time_out
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|time_out
)paren
(brace
multiline_comment|/* oh well, wait until the chip finds memory later */
id|SMC_ENABLE_INT
c_func
(paren
id|IM_ALLOC_INT
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: memory allocation deferred. &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* it&squot;s deferred, but I&squot;ll handle it later */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* or YES! I can send the packet now.. */
id|smc_hardware_send_packet
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; . Function:  smc_hardware_send_packet(struct net_device * )&n; . Purpose:&n; .&t;This sends the actual packet to the SMC9xxx chip.&n; .&n; . Algorithm:&n; . &t;First, see if a saved_skb is available.&n; .&t;&t;( this should NOT be called if there is no &squot;saved_skb&squot;&n; .&t;Now, find the packet number that the chip allocated&n; .&t;Point the data pointers at it in memory&n; .&t;Set the length word in the chip&squot;s memory&n; .&t;Dump the packet to chip memory&n; .&t;Check if a last byte is needed ( odd length packet )&n; .&t;&t;if so, set the control flag right&n; . &t;Tell the card to send it&n; .&t;Enable the transmit interrupt, so I know if it failed&n; . &t;Free the kernel data if I actually sent it.&n;*/
DECL|function|smc_hardware_send_packet
r_static
r_void
id|smc_hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|packet_no
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|lp-&gt;saved_skb
suffix:semicolon
id|word
id|length
suffix:semicolon
r_int
r_int
id|ioaddr
suffix:semicolon
id|byte
op_star
id|buf
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|PRINTK
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: In XMIT with no packet to send &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* If I get here, I _know_ there is a packet slot waiting for me */
id|packet_no
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PNR_ARR
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet_no
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* or isn&squot;t there?  BAD CHIP! */
id|printk
c_func
(paren
id|KERN_DEBUG
id|CARDNAME
l_string|&quot;: Memory allocation failed. &bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;saved_skb
op_assign
l_int|NULL
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* we have a packet address, so tell the card to use it */
id|outb
c_func
(paren
id|packet_no
comma
id|ioaddr
op_plus
id|PNR_ARR
)paren
suffix:semicolon
multiline_comment|/* point to the beginning of the packet */
id|outw
c_func
(paren
id|PTR_AUTOINC
comma
id|ioaddr
op_plus
id|POINTER
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: Trying to xmit packet of length %x&bslash;n&quot;
comma
id|length
)paren
)paren
suffix:semicolon
macro_line|#if SMC_DEBUG &gt; 2
id|print_packet
c_func
(paren
id|buf
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* send the packet length ( +6 for status, length and ctl byte )&n; &t;   and the status word ( set to zeros ) */
macro_line|#ifdef USE_32_BIT
id|outl
c_func
(paren
(paren
id|length
op_plus
l_int|6
)paren
op_lshift
l_int|16
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
macro_line|#else
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
multiline_comment|/* send the packet length ( +6 for status words, length, and ctl*/
id|outb
c_func
(paren
(paren
id|length
op_plus
l_int|6
)paren
op_amp
l_int|0xFF
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|length
op_plus
l_int|6
)paren
op_rshift
l_int|8
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* send the actual data&n;&t; . I _think_ it&squot;s faster to send the longs first, and then&n;&t; . mop up by sending the last word.  It depends heavily&n; &t; . on alignment, at least on the 486.  Maybe it would be&n; &t; . a good idea to check which is optimal?  But that could take&n;&t; . almost as much time as is saved?&n;&t;*/
macro_line|#ifdef USE_32_BIT
r_if
c_cond
(paren
id|length
op_amp
l_int|0x2
)paren
(brace
id|outsl
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
comma
id|buf
comma
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
op_star
(paren
(paren
id|word
op_star
)paren
(paren
id|buf
op_plus
(paren
id|length
op_amp
l_int|0xFFFFFFFC
)paren
)paren
)paren
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
)brace
r_else
id|outsl
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
comma
id|buf
comma
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#else
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
comma
id|buf
comma
(paren
id|length
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Send the last byte, if there is one.   */
r_if
c_cond
(paren
(paren
id|length
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|buf
(braket
id|length
op_minus
l_int|1
)braket
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
)brace
multiline_comment|/* enable the interrupts */
id|SMC_ENABLE_INT
c_func
(paren
(paren
id|IM_TX_INT
op_or
id|IM_TX_EMPTY_INT
)paren
)paren
suffix:semicolon
multiline_comment|/* and let the chipset deal with it */
id|outw
c_func
(paren
id|MC_ENQUEUE
comma
id|ioaddr
op_plus
id|MMU_CMD
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: Sent packet of length %d &bslash;n&quot;
comma
id|length
)paren
)paren
suffix:semicolon
id|lp-&gt;saved_skb
op_assign
l_int|NULL
suffix:semicolon
id|dev_kfree_skb_irq
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* we can send another packet */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------&n; |&n; | smc_init( struct net_device * dev )&n; |   Input parameters:&n; |&t;dev-&gt;base_addr == 0, try to find all possible locations&n; |&t;dev-&gt;base_addr == 1, return failure code&n; |&t;dev-&gt;base_addr == 2, always allocate space,  and return success&n; |&t;dev-&gt;base_addr == &lt;anything else&gt;   this is the address to check&n; |&n; |   Output:&n; |&t;0 --&gt; there is a device&n; |&t;anything else, error&n; |&n; ---------------------------------------------------------------------------&n;*/
DECL|function|smc_init
r_int
id|__init
id|smc_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*  try a specific location */
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
r_return
id|smc_probe
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* check every ethernet address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|smc_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smc_probe
c_func
(paren
id|dev
comma
id|smc_portlist
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* couldn&squot;t find anything */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------&n; . smc_findirq&n; .&n; . This routine has a simple purpose -- make the SMC chip generate an&n; . interrupt, so an auto-detect routine can detect it, and find the IRQ,&n; ------------------------------------------------------------------------&n;*/
DECL|function|smc_findirq
r_int
id|__init
id|smc_findirq
c_func
(paren
r_int
id|ioaddr
)paren
(brace
r_int
id|timeout
op_assign
l_int|20
suffix:semicolon
r_int
r_int
id|cookie
suffix:semicolon
multiline_comment|/* I have to do a STI() here, because this is called from&n;&t;   a routine that does an CLI during this process, making it&n;&t;   rather difficult to get interrupts for auto detection */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|cookie
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What I try to do here is trigger an ALLOC_INT. This is done&n;&t; * by allocating a small chunk of memory, which will give an interrupt&n;&t; * when done.&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* enable ALLOCation interrupts ONLY */
id|outb
c_func
(paren
id|IM_ALLOC_INT
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
multiline_comment|/*&n; &t; . Allocate 512 bytes of memory.  Note that the chip was just&n;&t; . reset so all the memory is available&n;&t;*/
id|outw
c_func
(paren
id|MC_ALLOC
op_or
l_int|1
comma
id|ioaddr
op_plus
id|MMU_CMD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . Wait until positive that the interrupt has been generated&n;&t;*/
r_while
c_loop
(paren
id|timeout
)paren
(brace
id|byte
id|int_status
suffix:semicolon
id|int_status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|int_status
op_amp
id|IM_ALLOC_INT
)paren
r_break
suffix:semicolon
multiline_comment|/* got the interrupt */
id|timeout
op_decrement
suffix:semicolon
)brace
multiline_comment|/* there is really nothing that I can do here if timeout fails,&n;&t;   as autoirq_report will return a 0 anyway, which is what I&n;&t;   want in this case.   Plus, the clean up is needed in both&n;&t;   cases.  */
multiline_comment|/* DELAY HERE!&n;&t;   On a fast machine, the status might change before the interrupt&n;&t;   is given to the processor.  This means that the interrupt was&n;&t;   never detected, and autoirq_report fails to report anything.&n;&t;   This should fix autoirq_* problems.&n;&t;*/
id|SMC_DELAY
c_func
(paren
)paren
suffix:semicolon
id|SMC_DELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* and disable all interrupts again */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
multiline_comment|/* clear hardware interrupts again, because that&squot;s how it&n;&t;   was when I was called... */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* and return what I found */
r_return
id|probe_irq_off
c_func
(paren
id|cookie
)paren
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------&n; . Function: smc_probe( int ioaddr )&n; .&n; . Purpose:&n; .&t;Tests to see if a given ioaddr points to an SMC9xxx chip.&n; .&t;Returns a 0 on success&n; .&n; . Algorithm:&n; .&t;(1) see if the high byte of BANK_SELECT is 0x33&n; . &t;(2) compare the ioaddr with the base register&squot;s address&n; .&t;(3) see if I recognize the chip ID in the appropriate register&n; .&n; .---------------------------------------------------------------------&n; */
multiline_comment|/*---------------------------------------------------------------&n; . Here I do typical initialization tasks.&n; .&n; . o  Initialize the structure if needed&n; . o  print out my vanity message if not done so already&n; . o  print out what type of hardware is detected&n; . o  print out the ethernet address&n; . o  find the IRQ&n; . o  set up my private data&n; . o  configure the dev structure with my subroutines&n; . o  actually GRAB the irq.&n; . o  GRAB the region&n; .-----------------------------------------------------------------&n;*/
DECL|function|smc_probe
r_static
r_int
id|__init
id|smc_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|memory
comma
id|retval
suffix:semicolon
r_static
r_int
id|version_printed
suffix:semicolon
r_int
r_int
id|bank
suffix:semicolon
r_const
r_char
op_star
id|version_string
suffix:semicolon
r_const
r_char
op_star
id|if_string
suffix:semicolon
multiline_comment|/* registers */
id|word
id|revision_register
suffix:semicolon
id|word
id|base_address_register
suffix:semicolon
id|word
id|configuration_register
suffix:semicolon
id|word
id|memory_info_register
suffix:semicolon
id|word
id|memory_cfg_register
suffix:semicolon
multiline_comment|/* Grab the region so that no one else tries to probe our ioports. */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|SMC_IO_EXTENT
comma
id|dev-&gt;name
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* First, see if the high byte is 0x33 */
id|bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bank
op_amp
l_int|0xFF00
)paren
op_ne
l_int|0x3300
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* The above MIGHT indicate a device, but I need to write to further&n; &t; &t;test this.  */
id|outw
c_func
(paren
l_int|0x0
comma
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
id|bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bank
op_amp
l_int|0xFF00
)paren
op_ne
l_int|0x3300
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* well, we&squot;ve already written once, so hopefully another time won&squot;t&n; &t;   hurt.  This time, I need to switch the bank register to bank 1,&n;&t;   so I can access the base address register */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|base_address_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_ne
(paren
id|base_address_register
op_rshift
l_int|3
op_amp
l_int|0x3E0
)paren
)paren
(brace
id|printk
c_func
(paren
id|CARDNAME
l_string|&quot;: IOADDR %x doesn&squot;t match configuration (%x).&quot;
l_string|&quot;Probably not a SMC chip&bslash;n&quot;
comma
id|ioaddr
comma
id|base_address_register
op_rshift
l_int|3
op_amp
l_int|0x3E0
)paren
suffix:semicolon
multiline_comment|/* well, the base address register didn&squot;t match.  Must not have&n;&t;&t;   been a SMC chip after all. */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*  check if the revision register is something that I recognize.&n;&t;    These might need to be added to later, as future revisions&n;&t;    could be added.  */
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|revision_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|REVISION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip_ids
(braket
(paren
id|revision_register
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)braket
)paren
(brace
multiline_comment|/* I don&squot;t recognize this chip, so... */
id|printk
c_func
(paren
id|CARDNAME
l_string|&quot;: IO %x: Unrecognized revision register:&quot;
l_string|&quot; %x, Contact author. &bslash;n&quot;
comma
id|ioaddr
comma
id|revision_register
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* at this point I&squot;ll assume that the chip is an SMC9xxx.&n;&t;   It might be prudent to check a listing of MAC addresses&n;&t;   against the hardware address, or do some other tests. */
r_if
c_cond
(paren
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/* fill in some of the fields */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/*&n; &t; . Get the MAC address ( bank 1, regs 4 - 9 )&n;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|word
id|address
suffix:semicolon
id|address
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|ADDR0
op_plus
id|i
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|address
op_rshift
l_int|8
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|address
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/* get the memory information */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|memory_info_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MIR
)paren
suffix:semicolon
id|memory_cfg_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|MCR
)paren
suffix:semicolon
id|memory
op_assign
(paren
id|memory_cfg_register
op_rshift
l_int|9
)paren
op_amp
l_int|0x7
suffix:semicolon
multiline_comment|/* multiplier */
id|memory
op_mul_assign
l_int|256
op_star
(paren
id|memory_info_register
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; Now, I want to find out more about the chip.  This is sort of&n; &t; redundant, but it&squot;s cleaner to have it in both, rather than having&n; &t; one VERY long probe procedure.&n;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|revision_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|REVISION
)paren
suffix:semicolon
id|version_string
op_assign
id|chip_ids
(braket
(paren
id|revision_register
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|version_string
)paren
(brace
multiline_comment|/* I shouldn&squot;t get here because this call was done before.... */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* is it using AUI or 10BaseT ? */
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|0
)paren
(brace
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|configuration_register
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|configuration_register
op_amp
id|CFG_AUI_SELECT
)paren
id|dev-&gt;if_port
op_assign
l_int|2
suffix:semicolon
r_else
id|dev-&gt;if_port
op_assign
l_int|1
suffix:semicolon
)brace
id|if_string
op_assign
id|interfaces
(braket
id|dev-&gt;if_port
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* now, reset the chip, and put it into a known state */
id|smc_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . If dev-&gt;irq is 0, then the device has to be banged on to see&n;&t; . what the IRQ is.&n; &t; .&n;&t; . This banging doesn&squot;t always detect the IRQ, for unknown reasons.&n;&t; . a workaround is to reset the chip and try again.&n;&t; .&n;&t; . Interestingly, the DOS packet driver *SETS* the IRQ on the card to&n;&t; . be what is requested on the command line.   I don&squot;t do that, mostly&n;&t; . because the card that I have uses a non-standard method of accessing&n;&t; . the IRQs, and because this _should_ work in most configurations.&n;&t; .&n;&t; . Specifying an IRQ is done with the assumption that the user knows&n;&t; . what (s)he is doing.  No checking is done!!!!&n; &t; .&n;&t;*/
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
r_int
id|trials
suffix:semicolon
id|trials
op_assign
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|trials
op_decrement
)paren
(brace
id|dev-&gt;irq
op_assign
id|smc_findirq
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
r_break
suffix:semicolon
multiline_comment|/* kick the card and try again */
id|smc_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|CARDNAME
l_string|&quot;: Couldn&squot;t autodetect your IRQ. Use irq=xx.&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Fixup for users that don&squot;t know that IRQ 2 is really IRQ 9,&n;&t;&t; * or don&squot;t know which one to set.&n;&t;&t; */
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
)brace
multiline_comment|/* now, print out the card info, in a short format.. */
id|printk
c_func
(paren
l_string|&quot;%s: %s(r:%d) at %#3x IRQ:%d INTF:%s MEM:%db &quot;
comma
id|dev-&gt;name
comma
id|version_string
comma
id|revision_register
op_amp
l_int|0xF
comma
id|ioaddr
comma
id|dev-&gt;irq
comma
id|if_string
comma
id|memory
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . Print the Ethernet address&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;ADDR: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%2.2x &bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* Initialize the private structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|smc_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* set the private data to zero by default */
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|smc_local
)paren
)paren
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Grab the IRQ */
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|smc_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|retval
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|dev-&gt;open
op_assign
id|smc_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|smc_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|smc_wait_to_send_packet
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|smc_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
op_div
l_int|20
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|smc_query_statistics
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|smc_set_multicast_list
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|release_region
c_func
(paren
id|ioaddr
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#if SMC_DEBUG &gt; 2
DECL|function|print_packet
r_static
r_void
id|print_packet
c_func
(paren
id|byte
op_star
id|buf
comma
r_int
id|length
)paren
(brace
macro_line|#if 0
r_int
id|i
suffix:semicolon
r_int
id|remainder
suffix:semicolon
r_int
id|lines
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Packet of length %d &bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
id|lines
op_assign
id|length
op_div
l_int|16
suffix:semicolon
id|remainder
op_assign
id|length
op_mod
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lines
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cur
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
l_int|0
suffix:semicolon
id|cur
OL
l_int|8
suffix:semicolon
id|cur
op_increment
)paren
(brace
id|byte
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|b
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x%02x &quot;
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remainder
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|byte
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|b
op_assign
op_star
(paren
id|buf
op_increment
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x%02x &quot;
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/*&n; * Open and Initialize the board&n; *&n; * Set up everything, reset the card, etc ..&n; *&n; */
DECL|function|smc_open
r_static
r_int
id|smc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* used to set hw ethernet address */
multiline_comment|/* clear out all the junk that was put here before... */
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|smc_local
)paren
)paren
suffix:semicolon
multiline_comment|/* reset the hardware */
id|smc_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Select which interface to use */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|1
)paren
(brace
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG
)paren
op_amp
op_complement
id|CFG_AUI_SELECT
comma
id|ioaddr
op_plus
id|CONFIG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|2
)paren
(brace
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG
)paren
op_or
id|CFG_AUI_SELECT
comma
id|ioaddr
op_plus
id|CONFIG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  &t;&t;According to Becker, I have to set the hardware address&n;&t;&t;at this point, because the (l)user can set it with an&n;&t;&t;ioctl.  Easily done...&n;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|word
id|address
suffix:semicolon
id|address
op_assign
id|dev-&gt;dev_addr
(braket
id|i
op_plus
l_int|1
)braket
op_lshift
l_int|8
suffix:semicolon
id|address
op_or_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
id|outw
c_func
(paren
id|address
comma
id|ioaddr
op_plus
id|ADDR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------&n; . Called by the kernel to send a packet out into the void&n; . of the net.  This routine is largely based on&n; . skeleton.c, from Becker.&n; .--------------------------------------------------------&n;*/
DECL|function|smc_timeout
r_static
r_void
id|smc_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;   There should really be a &quot;kick me&quot; function call instead. */
id|printk
c_func
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: transmit timed out, %s?&bslash;n&quot;
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* &quot;kick&quot; the adaptor */
id|smc_reset
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* clear anything saved */
(paren
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|saved_skb
op_assign
l_int|NULL
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------&n; .&n; . This is the main routine of the driver, to handle the device when&n; . it needs some attention.&n; .&n; . So:&n; .   first, save state of the chipset&n; .   branch off into routines to handle each case, and acknowledge&n; .&t;    each to the interrupt register&n; .   and finally restore state.&n; .&n; ---------------------------------------------------------------------*/
DECL|function|smc_interrupt
r_static
r_void
id|smc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|status
suffix:semicolon
id|word
id|card_stats
suffix:semicolon
id|byte
id|mask
suffix:semicolon
r_int
id|timeout
suffix:semicolon
multiline_comment|/* state registers */
id|word
id|saved_bank
suffix:semicolon
id|word
id|saved_pointer
suffix:semicolon
id|PRINTK3
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: SMC interrupt started &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|saved_bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|BANK_SELECT
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|saved_pointer
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|POINTER
)paren
suffix:semicolon
id|mask
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
multiline_comment|/* clear all interrupts */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
multiline_comment|/* set a timeout value, so I don&squot;t stay here forever */
id|timeout
op_assign
l_int|4
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: MASK IS %x &bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* read the status flag, and mask it */
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|INTERRUPT
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_break
suffix:semicolon
id|PRINTK3
c_func
(paren
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: Handling interrupt status %x &bslash;n&quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IM_RCV_INT
)paren
(brace
multiline_comment|/* Got a packet(s). */
id|PRINTK2
c_func
(paren
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: Receive Interrupt&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|smc_rcv
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_TX_INT
)paren
(brace
id|PRINTK2
c_func
(paren
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: TX ERROR handled&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|smc_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|IM_TX_INT
comma
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_TX_EMPTY_INT
)paren
(brace
multiline_comment|/* update stats */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|card_stats
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|COUNTER
)paren
suffix:semicolon
multiline_comment|/* single collisions */
id|lp-&gt;stats.collisions
op_add_assign
id|card_stats
op_amp
l_int|0xF
suffix:semicolon
id|card_stats
op_rshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* multiple collisions */
id|lp-&gt;stats.collisions
op_add_assign
id|card_stats
op_amp
l_int|0xF
suffix:semicolon
multiline_comment|/* these are for when linux supports these statistics */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: TX_BUFFER_EMPTY handled&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|IM_TX_EMPTY_INT
comma
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
id|IM_TX_EMPTY_INT
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_add_assign
id|lp-&gt;packets_waiting
suffix:semicolon
id|lp-&gt;packets_waiting
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
(brace
id|PRINTK2
c_func
(paren
(paren
id|KERN_DEBUG
id|CARDNAME
l_string|&quot;: Allocation interrupt &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* clear this interrupt so it doesn&squot;t happen again */
id|mask
op_and_assign
op_complement
id|IM_ALLOC_INT
suffix:semicolon
id|smc_hardware_send_packet
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* enable xmit interrupts based on this */
id|mask
op_or_assign
(paren
id|IM_TX_EMPTY_INT
op_or
id|IM_TX_INT
)paren
suffix:semicolon
multiline_comment|/* and let the card send more packets to me */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|PRINTK2
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: Handoff done successfully.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_RX_OVRN_INT
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
id|outb
c_func
(paren
id|IM_RX_OVRN_INT
comma
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_EPH_INT
)paren
(brace
id|PRINTK
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: UNSUPPORTED: EPH INTERRUPT &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_ERCV_INT
)paren
(brace
id|PRINTK
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: UNSUPPORTED: ERCV INTERRUPT &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|IM_ERCV_INT
comma
id|ioaddr
op_plus
id|INTERRUPT
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|timeout
op_decrement
)paren
suffix:semicolon
multiline_comment|/* restore state register */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mask
comma
id|ioaddr
op_plus
id|INT_MASK
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: MASK is now %x &bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|saved_pointer
comma
id|ioaddr
op_plus
id|POINTER
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
id|saved_bank
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: Interrupt done&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------&n; .&n; . smc_rcv -  receive a packet from the card&n; .&n; . There is ( at least ) a packet waiting to be read from&n; . chip-memory.&n; .&n; . o Read the status&n; . o If an error, record it&n; . o otherwise, read in the packet&n; --------------------------------------------------------------&n;*/
DECL|function|smc_rcv
r_static
r_void
id|smc_rcv
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|packet_number
suffix:semicolon
id|word
id|status
suffix:semicolon
id|word
id|packet_length
suffix:semicolon
multiline_comment|/* assume bank 2 */
id|packet_number
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|FIFO_PORTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet_number
op_amp
id|FP_RXEMPTY
)paren
(brace
multiline_comment|/* we got called , but nothing was on the FIFO */
id|PRINTK
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: WARNING: smc_rcv with nothing on FIFO. &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t need to restore anything */
r_return
suffix:semicolon
)brace
multiline_comment|/*  start reading from the start of the packet */
id|outw
c_func
(paren
id|PTR_READ
op_or
id|PTR_RCV
op_or
id|PTR_AUTOINC
comma
id|ioaddr
op_plus
id|POINTER
)paren
suffix:semicolon
multiline_comment|/* First two words are status and packet_length */
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
id|packet_length
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
id|packet_length
op_and_assign
l_int|0x07ff
suffix:semicolon
multiline_comment|/* mask off top bits */
id|PRINTK2
c_func
(paren
(paren
l_string|&quot;RCV: STATUS %4x LENGTH %4x&bslash;n&quot;
comma
id|status
comma
id|packet_length
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; . the packet length contains 3 extra words :&n;&t; . status, length, and an extra word with an odd byte .&n;&t;*/
id|packet_length
op_sub_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|RS_ERRORS
)paren
)paren
(brace
multiline_comment|/* do stuff to make a new packet */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|byte
op_star
id|data
suffix:semicolon
multiline_comment|/* read one extra byte */
r_if
c_cond
(paren
id|status
op_amp
id|RS_ODDFRAME
)paren
id|packet_length
op_increment
suffix:semicolon
multiline_comment|/* set multicast stats */
r_if
c_cond
(paren
id|status
op_amp
id|RS_MULTICAST
)paren
id|lp-&gt;stats.multicast
op_increment
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|packet_length
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
id|CARDNAME
l_string|&quot;: Low memory, packet dropped.&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; ! This should work without alignment, but it could be&n;&t;&t; ! in the worse case&n;&t;&t;*/
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 16 bit alignment */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|packet_length
)paren
suffix:semicolon
macro_line|#ifdef USE_32_BIT
multiline_comment|/* QUESTION:  Like in the TX routine, do I want&n;&t;&t;   to send the DWORDs or the bytes first, or some&n;&t;&t;   mixture.  A mixture might improve already slow PIO&n;&t;&t;   performance  */
id|PRINTK3
c_func
(paren
(paren
l_string|&quot; Reading %d dwords (and %d bytes) &bslash;n&quot;
comma
id|packet_length
op_rshift
l_int|2
comma
id|packet_length
op_amp
l_int|3
)paren
)paren
suffix:semicolon
id|insl
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
comma
id|data
comma
id|packet_length
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* read the left over bytes */
id|insb
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
comma
id|data
op_plus
(paren
id|packet_length
op_amp
l_int|0xFFFFFC
)paren
comma
id|packet_length
op_amp
l_int|0x3
)paren
suffix:semicolon
macro_line|#else
id|PRINTK3
(paren
(paren
l_string|&quot; Reading %d words and %d byte(s) &bslash;n&quot;
comma
(paren
id|packet_length
op_rshift
l_int|1
)paren
comma
id|packet_length
op_amp
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet_length
op_amp
l_int|1
)paren
op_star
(paren
id|data
op_increment
)paren
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
comma
id|data
comma
(paren
id|packet_length
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet_length
op_amp
l_int|1
)paren
(brace
id|data
op_add_assign
id|packet_length
op_amp
op_complement
l_int|1
suffix:semicolon
op_star
(paren
(paren
id|data
op_increment
)paren
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if&t;SMC_DEBUG &gt; 2
id|print_packet
c_func
(paren
id|data
comma
id|packet_length
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* error ... */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_ALGNERR
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RS_TOOSHORT
op_or
id|RS_TOOLONG
)paren
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_BADCRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/*  error or good, tell the card to get rid of this packet */
id|outw
c_func
(paren
id|MC_RELEASE
comma
id|ioaddr
op_plus
id|MMU_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*************************************************************************&n; . smc_tx&n; .&n; . Purpose:  Handle a transmit error message.   This will only be called&n; .   when an error, because of the AUTO_RELEASE mode.&n; .&n; . Algorithm:&n; .&t;Save pointer and packet no&n; .&t;Get the packet no from the top of the queue&n; .&t;check if it&squot;s valid ( if not, is this an error??? )&n; .&t;read the status word&n; .&t;record the error&n; .&t;( resend?  Not really, since we don&squot;t want old packets around )&n; .&t;Restore saved values&n; ************************************************************************/
DECL|function|smc_tx
r_static
r_void
id|smc_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|byte
id|saved_packet
suffix:semicolon
id|byte
id|packet_no
suffix:semicolon
id|word
id|tx_status
suffix:semicolon
multiline_comment|/* assume bank 2  */
id|saved_packet
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PNR_ARR
)paren
suffix:semicolon
id|packet_no
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|FIFO_PORTS
)paren
suffix:semicolon
id|packet_no
op_and_assign
l_int|0x7F
suffix:semicolon
multiline_comment|/* select this as the packet to read from */
id|outb
c_func
(paren
id|packet_no
comma
id|ioaddr
op_plus
id|PNR_ARR
)paren
suffix:semicolon
multiline_comment|/* read the first word from this packet */
id|outw
c_func
(paren
id|PTR_AUTOINC
op_or
id|PTR_READ
comma
id|ioaddr
op_plus
id|POINTER
)paren
suffix:semicolon
id|tx_status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATA_1
)paren
suffix:semicolon
id|PRINTK3
c_func
(paren
(paren
id|CARDNAME
l_string|&quot;: TX DONE STATUS: %4x &bslash;n&quot;
comma
id|tx_status
)paren
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_LOSTCAR
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_LATCOL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
id|CARDNAME
l_string|&quot;: Late collision occurred on last xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_16COL
)paren
(brace
dot
dot
dot
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_SUCCESS
)paren
(brace
id|printk
c_func
(paren
id|CARDNAME
l_string|&quot;: Successful packet caused interrupt &bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* re-enable transmit */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|TCR
)paren
op_or
id|TCR_ENABLE
comma
id|ioaddr
op_plus
id|TCR
)paren
suffix:semicolon
multiline_comment|/* kill the packet */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|MC_FREEPKT
comma
id|ioaddr
op_plus
id|MMU_CMD
)paren
suffix:semicolon
multiline_comment|/* one less packet waiting for me */
id|lp-&gt;packets_waiting
op_decrement
suffix:semicolon
id|outb
c_func
(paren
id|saved_packet
comma
id|ioaddr
op_plus
id|PNR_ARR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n; . smc_close&n; .&n; . this makes the board clean up everything that it can&n; . and not talk to the outside world.   Caused by&n; . an &squot;ifconfig ethX down&squot;&n; .&n; -----------------------------------------------------*/
DECL|function|smc_close
r_static
r_int
id|smc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* clear everything */
id|smc_shutdown
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------&n; . Get the current statistics.&n; . This may be called with the card open or closed.&n; .-------------------------------------------------------------*/
DECL|function|smc_query_statistics
r_static
r_struct
id|net_device_stats
op_star
id|smc_query_statistics
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
(paren
r_struct
id|smc_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------&n; . smc_set_multicast_list&n; .&n; . This routine will, depending on the values passed to it,&n; . either make it accept multicast packets, go into&n; . promiscuous mode ( for TCPDUMP and cousins ) or accept&n; . a select set of multicast packets&n;*/
DECL|function|smc_set_multicast_list
r_static
r_void
id|smc_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR
)paren
op_or
id|RCR_PROMISC
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
multiline_comment|/* BUG?  I never disable promiscuous mode if multicasting was turned on.&n;   Now, I turn off promiscuous mode, but I don&squot;t do anything to multicasting&n;   when promiscuous mode is turned on.&n;*/
multiline_comment|/* Here, I am setting this to accept all multicast packets.&n;&t;   I don&squot;t need to zero the multicast table, because the flag is&n;&t;   checked before the table is&n;&t;*/
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR
)paren
op_or
id|RCR_ALMUL
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
multiline_comment|/* We just get all multicast packets even if we only want them&n;&t; . from one source.  This will be changed at some future&n;&t; . point. */
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
multiline_comment|/* support hardware multicasting */
multiline_comment|/* be sure I get rid of flags I might have set */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR
)paren
op_amp
op_complement
(paren
id|RCR_PROMISC
op_or
id|RCR_ALMUL
)paren
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
multiline_comment|/* NOTE: this has to set the bank, so make sure it is the&n;&t;&t;   last thing called.  The bank is set to zero at the top */
id|smc_setmulticast
c_func
(paren
id|ioaddr
comma
id|dev-&gt;mc_count
comma
id|dev-&gt;mc_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|outw
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|RCR
)paren
op_amp
op_complement
(paren
id|RCR_PROMISC
op_or
id|RCR_ALMUL
)paren
comma
id|ioaddr
op_plus
id|RCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;  since I&squot;m disabling all multicast entirely, I need to&n;&t;&t;  clear the multicast list&n;&t;&t;*/
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MULTICAST1
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MULTICAST2
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MULTICAST3
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|MULTICAST4
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|variable|devSMC9194
r_static
r_struct
id|net_device
id|devSMC9194
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
suffix:semicolon
DECL|variable|ifport
r_static
r_int
id|ifport
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ifport
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|CARDNAME
l_string|&quot;: You shouldn&squot;t use auto-probing with insmod!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* copy the parameters from insmod into the device structure */
id|devSMC9194.base_addr
op_assign
id|io
suffix:semicolon
id|devSMC9194.irq
op_assign
id|irq
suffix:semicolon
id|devSMC9194.if_port
op_assign
id|ifport
suffix:semicolon
id|devSMC9194.init
op_assign
id|smc_init
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|devSMC9194
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
id|unregister_netdev
c_func
(paren
op_amp
id|devSMC9194
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|devSMC9194.irq
comma
op_amp
id|devSMC9194
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|devSMC9194.base_addr
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devSMC9194.priv
)paren
id|kfree
c_func
(paren
id|devSMC9194.priv
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
