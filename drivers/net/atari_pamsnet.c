multiline_comment|/* atari_pamsnet.c     PAMsNet device driver for linux68k.&n; *&n; * Version:&t;@(#)PAMsNet.c&t;0.2&#xfffd;&t;03/31/96&n; *&n; * Author:  Torsten Lang &lt;Torsten.Lang@ap.physik.uni-giessen.de&gt;&n; *                       &lt;Torsten.Lang@jung.de&gt;&n; *&n; * This driver is based on my driver PAMSDMA.c for MiNT-Net and&n; * on the driver bionet.c written by&n; *          Hartmut Laue &lt;laue@ifk-mp.uni-kiel.de&gt;&n; * and      Torsten Narjes &lt;narjes@ifk-mp.uni-kiel.de&gt;&n; *&n; * Little adaptions for integration into pl7 by Roman Hodek&n; *&n;&t;What is it ?&n;&t;------------&n;&t;This driver controls the PAMsNet LAN-Adapter which connects&n;&t;an ATARI ST/TT via the ACSI-port to an Ethernet-based network.&n;&n;&t;This version can be compiled as a loadable module (See the&n;&t;compile command at the bottom of this file).&n;&t;At load time, you can optionally set the debugging level and the&n;&t;fastest response time on the command line of &squot;insmod&squot;.&n;&n;&t;&squot;pamsnet_debug&squot;&n;&t;&t;controls the amount of diagnostic messages:&n;&t;  0  : no messages&n;&t;  &gt;0 : see code for meaning of printed messages&n;&n;&t;&squot;pamsnet_min_poll_time&squot; (always &gt;=1)&n;&t;&t;gives the time (in jiffies) between polls. Low values&n;&t;&t;increase the system load (beware!)&n;&n;&t;When loaded, a net device with the name &squot;eth?&squot; becomes available,&n;&t;which can be controlled with the usual &squot;ifconfig&squot; command.&n;&n;&t;It is possible to compile this driver into the kernel like other&n;&t;(net) drivers. For this purpose, some source files (e.g. config-files&n;&t;makefiles, Space.c) must be changed accordingly. (You may refer to&n;&t;other drivers how to do it.) In this case, the device will be detected&n;&t;at boot time and (probably) appear as &squot;eth0&squot;.&n;&n;&t;Theory of Operation&n;&t;-------------------&n;&t;Because the ATARI DMA port is usually shared between several&n;&t;devices (eg. harddisk, floppy) we cannot block the ACSI bus&n;&t;while waiting for interrupts. Therefore we use a polling mechanism&n;&t;to fetch packets from the adapter. For the same reason, we send&n;&t;packets without checking that the previous packet has been sent to&n;&t;the LAN. We rely on the higher levels of the networking code to detect&n;&t;missing packets and resend them.&n;&n;&t;Before we access the ATARI DMA controller, we check if another&n;&t;process is using the DMA. If not, we lock the DMA, perform one or&n;&t;more packet transfers and unlock the DMA before returning.&n;&t;We do not use &squot;stdma_lock&squot; unconditionally because it is unclear&n;&t;if the networking code can be set to sleep, which will happen if&n;&t;another (possibly slow) device is using the DMA controller.&n;&n;&t;The polling is done via timer interrupts which periodically&n;&t;&squot;simulate&squot; an interrupt from the Ethernet adapter. The time (in jiffies)&n;&t;between polls varies depending on an estimate of the net activity.&n;&t;The allowed range is given by the variable &squot;bionet_min_poll_time&squot;&n;&t;for the lower (fastest) limit and the constant &squot;MAX_POLL_TIME&squot;&n;&t;for the higher (slowest) limit.&n;&n;&t;Whenever a packet arrives, we switch to fastest response by setting&n;&t;the polling time to its lowest limit. If the following poll fails,&n;&t;because no packets have arrived, we increase the time for the next&n;&t;poll. When the net activity is low, the polling time effectively&n;&t;stays at its maximum value, resulting in the lowest load for the&n;&t;machine.&n; */
DECL|macro|MAX_POLL_TIME
mdefine_line|#define MAX_POLL_TIME&t;10
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;pamsnet.c:v0.2beta 30-mar-96 (c) Torsten Lang.&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/atari_stdma.h&gt;
macro_line|#include &lt;asm/atari_acsi.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
DECL|macro|READ
macro_line|#undef READ
DECL|macro|WRITE
macro_line|#undef WRITE
r_extern
r_struct
id|net_device
op_star
id|init_etherdev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|sizeof_private
)paren
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug&n; */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 0
macro_line|#endif
multiline_comment|/*&n; * Global variable &squot;pamsnet_debug&squot;. Can be set at load time by &squot;insmod&squot;&n; */
DECL|variable|pamsnet_debug
r_int
r_int
id|pamsnet_debug
op_assign
id|NET_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|pamsnet_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|pamsnet_min_poll_time
r_static
r_int
r_int
id|pamsnet_min_poll_time
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board.&n; */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|open_time
r_int
id|open_time
suffix:semicolon
multiline_comment|/* for debugging */
DECL|member|poll_time
r_int
id|poll_time
suffix:semicolon
multiline_comment|/* polling time varies with net load */
)brace
suffix:semicolon
DECL|struct|nic_pkt_s
r_static
r_struct
id|nic_pkt_s
(brace
multiline_comment|/* packet format */
DECL|member|buffer
r_int
r_char
id|buffer
(braket
l_int|2048
)braket
suffix:semicolon
DECL|variable|nic_packet
)brace
op_star
id|nic_packet
op_assign
l_int|0
suffix:semicolon
DECL|variable|phys_nic_packet
r_int
r_char
op_star
id|phys_nic_packet
suffix:semicolon
DECL|typedef|HADDR
r_typedef
r_int
r_char
id|HADDR
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* 6-byte hardware address of lance */
multiline_comment|/* Index to functions, as function prototypes.&n; */
r_static
r_void
id|start
(paren
r_int
id|target
)paren
suffix:semicolon
r_static
r_int
id|stop
(paren
r_int
id|target
)paren
suffix:semicolon
r_static
r_int
id|testpkt
(paren
r_int
id|target
)paren
suffix:semicolon
r_static
r_int
id|sendpkt
(paren
r_int
id|target
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_int
id|receivepkt
(paren
r_int
id|target
comma
r_int
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|inquiry
(paren
r_int
id|target
comma
r_int
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
id|HADDR
op_star
id|read_hw_addr
c_func
(paren
r_int
id|target
comma
r_int
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_void
id|setup_dma
(paren
r_void
op_star
id|address
comma
r_int
id|rw_flag
comma
r_int
id|num_blocks
)paren
suffix:semicolon
r_static
r_int
id|send_first
(paren
r_int
id|target
comma
r_int
r_char
id|byte
)paren
suffix:semicolon
r_static
r_int
id|send_1_5
(paren
r_int
id|lun
comma
r_int
r_char
op_star
id|command
comma
r_int
id|dma
)paren
suffix:semicolon
r_static
r_int
id|get_status
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|calc_received
(paren
r_void
op_star
id|start_address
)paren
suffix:semicolon
r_extern
r_int
id|pamsnet_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|pamsnet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|pamsnet_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|pamsnet_poll_rx
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|pamsnet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|pamsnet_tick
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|pamsnet_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
DECL|variable|pamsnet_timer
r_static
r_struct
id|timer_list
id|pamsnet_timer
op_assign
(brace
id|function
suffix:colon
id|amsnet_tick
)brace
suffix:semicolon
DECL|macro|STRAM_ADDR
mdefine_line|#define STRAM_ADDR(a)&t;(((a) &amp; 0xff000000) == 0)
r_typedef
r_struct
(brace
DECL|member|reserved1
r_int
r_char
id|reserved1
(braket
l_int|0x38
)braket
suffix:semicolon
DECL|member|hwaddr
id|HADDR
id|hwaddr
suffix:semicolon
DECL|member|reserved2
r_int
r_char
id|reserved2
(braket
l_int|0x1c2
)braket
suffix:semicolon
DECL|typedef|DMAHWADDR
)brace
id|DMAHWADDR
suffix:semicolon
multiline_comment|/*&n; * Definitions of commands understood by the PAMs DMA adaptor.&n; *&n; * In general the DMA adaptor uses LUN 0, 5, 6 and 7 on one ID changeable&n; * by the PAM&squot;s Net software.&n; *&n; * LUN 0 works as a harddisk. You can boot the PAM&squot;s Net driver there.&n; * LUN 5 works as a harddisk and lets you access the RAM and some I/O HW&n; *       area. In sector 0, bytes 0x38-0x3d you find the ethernet HW address&n; *       of the adaptor.&n; * LUN 6 works as a harddisk and lets you access the firmware ROM.&n; * LUN 7 lets you send and receive packets.&n; *&n; * Some commands like the INQUIRY command work identical on all used LUNs.&n; *&n; * UNKNOWN1 seems to read some data.&n; *          Command length is 6 bytes.&n; * UNKNOWN2 seems to read some data (command byte 1 must be !=0). The&n; *          following bytes seem to be something like an allocation length.&n; *          Command length is 6 bytes.&n; * READPKT  reads a packet received by the DMA adaptor.&n; *          Command length is 6 bytes.&n; * WRITEPKT sends a packet transferred by the following DMA phase. The length&n; *          of the packet is transferred in command bytes 3 and 4.&n; *          The adaptor automatically replaces the src hw address in an ethernet&n; *          packet by its own hw address.&n; *          Command length is 6 bytes.&n; * INQUIRY  has the same function as the INQUIRY command supported by harddisks&n; *          and other SCSI devices. It lets you detect which device you found&n; *          at a given address.&n; *          Command length is 6 bytes.&n; * START    initializes the DMA adaptor. After this command it is able to send&n; *          and receive packets. There is no status byte returned!&n; *          Command length is 1 byte.&n; * NUMPKTS  gives back the number of received packets waiting in the queue in&n; *          the status byte.&n; *          Command length is 1 byte.&n; * UNKNOWN3&n; * UNKNOWN4 Function of these three commands is unknown.&n; * UNKNOWN5 The command length of these three commands is 1 byte.&n; * DESELECT immediately deselects the DMA adaptor. May important with interrupt&n; *          driven operation.&n; *          Command length is 1 byte.&n; * STOP     resets the DMA adaptor. After this command packets can no longer&n; *          be received or transferred.&n; *          Command length is 6 byte.&n; */
DECL|enumerator|UNKNOWN1
DECL|enumerator|READPKT
DECL|enumerator|UNKNOWN2
DECL|enumerator|WRITEPKT
DECL|enumerator|INQUIRY
DECL|enumerator|START
r_enum
(brace
id|UNKNOWN1
op_assign
l_int|3
comma
id|READPKT
op_assign
l_int|8
comma
id|UNKNOWN2
comma
id|WRITEPKT
op_assign
l_int|10
comma
id|INQUIRY
op_assign
l_int|18
comma
id|START
comma
DECL|enumerator|NUMPKTS
DECL|enumerator|UNKNOWN3
DECL|enumerator|UNKNOWN4
DECL|enumerator|UNKNOWN5
DECL|enumerator|DESELECT
DECL|enumerator|STOP
id|NUMPKTS
op_assign
l_int|22
comma
id|UNKNOWN3
comma
id|UNKNOWN4
comma
id|UNKNOWN5
comma
id|DESELECT
comma
id|STOP
)brace
suffix:semicolon
DECL|macro|READSECTOR
mdefine_line|#define READSECTOR  READPKT
DECL|macro|WRITESECTOR
mdefine_line|#define WRITESECTOR WRITEPKT
DECL|variable|inquire8
id|u_char
op_star
id|inquire8
op_assign
l_string|&quot;MV      PAM&squot;s NET/GK&quot;
suffix:semicolon
DECL|macro|DMALOW
mdefine_line|#define DMALOW   dma_wd.dma_lo
DECL|macro|DMAMID
mdefine_line|#define DMAMID   dma_wd.dma_md
DECL|macro|DMAHIGH
mdefine_line|#define DMAHIGH  dma_wd.dma_hi
DECL|macro|DACCESS
mdefine_line|#define DACCESS  dma_wd.fdc_acces_seccount
DECL|macro|MFP_GPIP
mdefine_line|#define MFP_GPIP mfp.par_dt_reg
multiline_comment|/* Some useful functions */
DECL|macro|INT
mdefine_line|#define INT      (!(MFP_GPIP &amp; 0x20))
DECL|macro|DELAY
mdefine_line|#define DELAY ({MFP_GPIP; MFP_GPIP; MFP_GPIP;})
DECL|macro|WRITEMODE
mdefine_line|#define WRITEMODE(value)&t;&t;&t;&t;&t;&bslash;&n;&t;({&t;u_short dummy = value;&t;&t;&t;&t;&bslash;&n;&t;&t;__asm__ volatile(&quot;movew %0, 0xFFFF8606&quot; : : &quot;d&quot;(dummy));&t;&bslash;&n;&t;&t;DELAY;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;})
DECL|macro|WRITEBOTH
mdefine_line|#define WRITEBOTH(value1, value2)&t;&t;&t;&t;&bslash;&n;&t;({&t;u_long dummy = (u_long)(value1)&lt;&lt;16 | (u_short)(value2);&t;&bslash;&n;&t;&t;__asm__ volatile(&quot;movel %0, 0xFFFF8604&quot; : : &quot;d&quot;(dummy));&t;&bslash;&n;&t;&t;DELAY;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;})
multiline_comment|/* Definitions for DMODE */
DECL|macro|READ
mdefine_line|#define READ        0x000
DECL|macro|WRITE
mdefine_line|#define WRITE       0x100
DECL|macro|DMA_FDC
mdefine_line|#define DMA_FDC     0x080
DECL|macro|DMA_ACSI
mdefine_line|#define DMA_ACSI    0x000
DECL|macro|DMA_DISABLE
mdefine_line|#define DMA_DISABLE 0x040
DECL|macro|SEC_COUNT
mdefine_line|#define SEC_COUNT   0x010
DECL|macro|DMA_WINDOW
mdefine_line|#define DMA_WINDOW  0x000
DECL|macro|REG_ACSI
mdefine_line|#define REG_ACSI    0x008
DECL|macro|REG_FDC
mdefine_line|#define REG_FDC     0x000
DECL|macro|A1
mdefine_line|#define A1          0x002
multiline_comment|/* Timeout constants */
DECL|macro|TIMEOUTCMD
mdefine_line|#define TIMEOUTCMD HZ/2   /* ca. 500ms */
DECL|macro|TIMEOUTDMA
mdefine_line|#define TIMEOUTDMA HZ     /* ca. 1s */
DECL|macro|COMMAND_DELAY
mdefine_line|#define COMMAND_DELAY 500 /* ca. 0.5ms */
DECL|variable|rw
r_int
id|rw
suffix:semicolon
DECL|variable|lance_target
r_int
id|lance_target
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|if_up
r_int
id|if_up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The following routines access the ethernet board connected to the&n; * ACSI port via the st_dma chip.&n; */
multiline_comment|/* The following lowlevel routines work on physical addresses only and assume&n; * that eventually needed buffers are&n; * - completely located in ST RAM&n; * - are contigous in the physical address space&n; */
multiline_comment|/* Setup the DMA counter */
r_static
r_void
DECL|function|setup_dma
id|setup_dma
(paren
id|address
comma
id|rw_flag
comma
id|num_blocks
)paren
r_void
op_star
id|address
suffix:semicolon
r_int
id|rw_flag
suffix:semicolon
r_int
id|num_blocks
suffix:semicolon
(brace
id|WRITEMODE
c_func
(paren
(paren
r_int
)paren
id|rw_flag
op_or
id|DMA_FDC
op_or
id|SEC_COUNT
op_or
id|REG_ACSI
op_or
id|A1
)paren
suffix:semicolon
id|WRITEMODE
c_func
(paren
(paren
r_int
)paren
(paren
id|rw_flag
op_xor
id|WRITE
)paren
op_or
id|DMA_FDC
op_or
id|SEC_COUNT
op_or
id|REG_ACSI
op_or
id|A1
)paren
suffix:semicolon
id|WRITEMODE
c_func
(paren
(paren
r_int
)paren
id|rw_flag
op_or
id|DMA_FDC
op_or
id|SEC_COUNT
op_or
id|REG_ACSI
op_or
id|A1
)paren
suffix:semicolon
id|DMALOW
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
r_int
r_int
)paren
id|address
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|DMAMID
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|address
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|DMAHIGH
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|address
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|WRITEBOTH
c_func
(paren
(paren
r_int
)paren
id|num_blocks
op_amp
l_int|0xFF
comma
id|rw_flag
op_or
id|DMA_FDC
op_or
id|DMA_WINDOW
op_or
id|REG_ACSI
op_or
id|A1
)paren
suffix:semicolon
id|rw
op_assign
id|rw_flag
suffix:semicolon
)brace
multiline_comment|/* Send the first byte of an command block */
r_static
r_int
DECL|function|send_first
id|send_first
(paren
id|target
comma
id|byte
)paren
r_int
id|target
suffix:semicolon
r_int
r_char
id|byte
suffix:semicolon
(brace
id|rw
op_assign
id|READ
suffix:semicolon
id|acsi_delay_end
c_func
(paren
id|COMMAND_DELAY
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wake up ACSI&n;&t; */
id|WRITEMODE
c_func
(paren
id|DMA_FDC
op_or
id|DMA_WINDOW
op_or
id|REG_ACSI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * write command byte&n;&t; */
id|WRITEBOTH
c_func
(paren
(paren
id|target
op_lshift
l_int|5
)paren
op_or
(paren
id|byte
op_amp
l_int|0x1F
)paren
comma
id|DMA_FDC
op_or
id|DMA_WINDOW
op_or
id|REG_ACSI
op_or
id|A1
)paren
suffix:semicolon
r_return
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTCMD
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send the rest of an command block */
r_static
r_int
DECL|function|send_1_5
id|send_1_5
(paren
id|lun
comma
id|command
comma
id|dma
)paren
r_int
id|lun
suffix:semicolon
r_int
r_char
op_star
id|command
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|WRITEBOTH
c_func
(paren
(paren
op_logical_neg
id|i
ques
c_cond
(paren
(paren
(paren
id|lun
op_amp
l_int|0x7
)paren
op_lshift
l_int|5
)paren
op_or
(paren
id|command
(braket
id|i
)braket
op_amp
l_int|0x1F
)paren
)paren
suffix:colon
id|command
(braket
id|i
)braket
)paren
comma
id|rw
op_or
id|REG_ACSI
op_or
id|DMA_WINDOW
op_or
(paren
(paren
id|i
OL
l_int|4
)paren
ques
c_cond
id|DMA_FDC
suffix:colon
(paren
id|dma
ques
c_cond
id|DMA_ACSI
suffix:colon
id|DMA_FDC
)paren
)paren
op_or
id|A1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|4
op_logical_and
(paren
id|j
op_assign
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTCMD
)paren
)paren
)paren
r_return
(paren
id|j
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Read a status byte */
r_static
r_int
DECL|function|get_status
id|get_status
(paren
r_void
)paren
(brace
id|WRITEMODE
c_func
(paren
id|DMA_FDC
op_or
id|DMA_WINDOW
op_or
id|REG_ACSI
op_or
id|A1
)paren
suffix:semicolon
id|acsi_delay_start
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
(paren
r_int
)paren
(paren
id|DACCESS
op_amp
l_int|0xFF
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Calculate the number of received bytes */
r_static
r_int
DECL|function|calc_received
id|calc_received
(paren
id|start_address
)paren
r_void
op_star
id|start_address
suffix:semicolon
(brace
r_return
(paren
r_int
)paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|DMAHIGH
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_int
)paren
id|DMAMID
op_lshift
l_int|8
)paren
op_or
id|DMALOW
)paren
op_minus
(paren
r_int
r_int
)paren
id|start_address
)paren
suffix:semicolon
)brace
multiline_comment|/* The following midlevel routines still work on physical addresses ... */
multiline_comment|/* start() starts the PAM&squot;s DMA adaptor */
r_static
r_void
DECL|function|start
id|start
(paren
id|target
)paren
r_int
id|target
suffix:semicolon
(brace
id|send_first
c_func
(paren
id|target
comma
id|START
)paren
suffix:semicolon
)brace
multiline_comment|/* stop() stops the PAM&squot;s DMA adaptor and returns a value of zero in case of success */
r_static
r_int
DECL|function|stop
id|stop
(paren
id|target
)paren
r_int
id|target
suffix:semicolon
(brace
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
id|cmd_buffer
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|send_first
c_func
(paren
id|target
comma
id|STOP
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|cmd_buffer
(braket
l_int|0
)braket
op_assign
id|cmd_buffer
(braket
l_int|1
)braket
op_assign
id|cmd_buffer
(braket
l_int|2
)braket
op_assign
id|cmd_buffer
(braket
l_int|3
)braket
op_assign
id|cmd_buffer
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|send_1_5
c_func
(paren
l_int|7
comma
id|cmd_buffer
comma
l_int|0
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTDMA
)paren
op_logical_or
id|get_status
c_func
(paren
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|bad
suffix:colon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* testpkt() returns the number of received packets waiting in the queue */
r_static
r_int
DECL|function|testpkt
id|testpkt
c_func
(paren
id|target
)paren
r_int
id|target
suffix:semicolon
(brace
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|send_first
c_func
(paren
id|target
comma
id|NUMPKTS
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|ret
op_assign
id|get_status
c_func
(paren
)paren
suffix:semicolon
id|bad
suffix:colon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* inquiry() returns 0 when PAM&squot;s DMA found, -1 when timeout, -2 otherwise */
multiline_comment|/* Please note: The buffer is for internal use only but must be defined!   */
r_static
r_int
DECL|function|inquiry
id|inquiry
(paren
id|target
comma
id|buffer
)paren
r_int
id|target
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
(brace
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
op_star
id|vbuffer
op_assign
id|phys_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_int
r_char
id|cmd_buffer
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|send_first
c_func
(paren
id|target
comma
id|INQUIRY
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|setup_dma
c_func
(paren
id|buffer
comma
id|READ
comma
l_int|1
)paren
suffix:semicolon
id|vbuffer
(braket
l_int|8
)braket
op_assign
id|vbuffer
(braket
l_int|27
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Avoid confusion with previous read data */
id|cmd_buffer
(braket
l_int|0
)braket
op_assign
id|cmd_buffer
(braket
l_int|1
)braket
op_assign
id|cmd_buffer
(braket
l_int|2
)braket
op_assign
id|cmd_buffer
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd_buffer
(braket
l_int|3
)braket
op_assign
l_int|48
suffix:semicolon
r_if
c_cond
(paren
id|send_1_5
c_func
(paren
l_int|5
comma
id|cmd_buffer
comma
l_int|1
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTDMA
)paren
op_logical_or
id|get_status
c_func
(paren
)paren
op_logical_or
(paren
id|calc_received
c_func
(paren
id|buffer
)paren
OL
l_int|32
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|buffer
op_plus
l_int|8
)paren
comma
l_int|20
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|inquire8
comma
id|vbuffer
op_plus
l_int|8
comma
l_int|20
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|bad
suffix:colon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|NET_DEBUG
)paren
(brace
id|vbuffer
(braket
l_int|8
op_plus
l_int|20
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;inquiry of target %d: %s&bslash;n&quot;
comma
id|target
comma
id|vbuffer
op_plus
l_int|8
)paren
suffix:semicolon
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * read_hw_addr() reads the sector containing the hwaddr and returns&n; * a pointer to it (virtual address!) or 0 in case of an error&n; */
r_static
id|HADDR
DECL|function|read_hw_addr
op_star
id|read_hw_addr
c_func
(paren
id|target
comma
id|buffer
)paren
r_int
id|target
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
(brace
id|HADDR
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|cmd_buffer
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|send_first
c_func
(paren
id|target
comma
id|READSECTOR
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|setup_dma
c_func
(paren
id|buffer
comma
id|READ
comma
l_int|1
)paren
suffix:semicolon
id|cmd_buffer
(braket
l_int|0
)braket
op_assign
id|cmd_buffer
(braket
l_int|1
)braket
op_assign
id|cmd_buffer
(braket
l_int|2
)braket
op_assign
id|cmd_buffer
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd_buffer
(braket
l_int|3
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|send_1_5
c_func
(paren
l_int|5
comma
id|cmd_buffer
comma
l_int|1
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTDMA
)paren
op_logical_or
id|get_status
c_func
(paren
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|ret
op_assign
id|phys_to_virt
c_func
(paren
op_amp
(paren
(paren
(paren
id|DMAHWADDR
op_star
)paren
id|buffer
)paren
op_member_access_from_pointer
id|hwaddr
)paren
)paren
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
comma
l_int|512
comma
l_int|0
)paren
suffix:semicolon
id|bad
suffix:colon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pamsnet_intr
id|pamsnet_intr
c_func
(paren
id|irq
comma
id|data
comma
id|fp
)paren
r_int
id|irq
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_struct
id|pt_regs
op_star
id|fp
suffix:semicolon
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* receivepkt() loads a packet to a given buffer and returns its length */
r_static
r_int
DECL|function|receivepkt
id|receivepkt
(paren
id|target
comma
id|buffer
)paren
r_int
id|target
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
(brace
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
id|cmd_buffer
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|send_first
c_func
(paren
id|target
comma
id|READPKT
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|setup_dma
c_func
(paren
id|buffer
comma
id|READ
comma
l_int|3
)paren
suffix:semicolon
id|cmd_buffer
(braket
l_int|0
)braket
op_assign
id|cmd_buffer
(braket
l_int|1
)braket
op_assign
id|cmd_buffer
(braket
l_int|2
)braket
op_assign
id|cmd_buffer
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd_buffer
(braket
l_int|3
)braket
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|send_1_5
c_func
(paren
l_int|7
comma
id|cmd_buffer
comma
l_int|1
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTDMA
)paren
op_logical_or
id|get_status
c_func
(paren
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|ret
op_assign
id|calc_received
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|bad
suffix:colon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* sendpkt() sends a packet and returns a value of zero when the packet was sent&n;             successfully */
r_static
r_int
DECL|function|sendpkt
id|sendpkt
(paren
id|target
comma
id|buffer
comma
id|length
)paren
r_int
id|target
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|length
suffix:semicolon
(brace
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
id|cmd_buffer
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|send_first
c_func
(paren
id|target
comma
id|WRITEPKT
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|setup_dma
c_func
(paren
id|buffer
comma
id|WRITE
comma
l_int|3
)paren
suffix:semicolon
id|cmd_buffer
(braket
l_int|0
)braket
op_assign
id|cmd_buffer
(braket
l_int|1
)braket
op_assign
id|cmd_buffer
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd_buffer
(braket
l_int|2
)braket
op_assign
id|length
op_rshift
l_int|8
suffix:semicolon
id|cmd_buffer
(braket
l_int|3
)braket
op_assign
id|length
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|send_1_5
c_func
(paren
l_int|7
comma
id|cmd_buffer
comma
l_int|1
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|TIMEOUTDMA
)paren
op_logical_or
id|get_status
c_func
(paren
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|bad
suffix:colon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* The following higher level routines work on virtual addresses and convert them to&n; * physical addresses when passed to the lowlevel routines. It&squot;s up to the higher level&n; * routines to copy data from Alternate RAM to ST RAM if neccesary!&n; */
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; if one exists.&n; */
r_int
id|__init
DECL|function|pamsnet_probe
id|pamsnet_probe
(paren
id|dev
)paren
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|HADDR
op_star
id|hwaddr
suffix:semicolon
r_int
r_char
id|station_addr
(braket
l_int|6
)braket
suffix:semicolon
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid &quot;Probing for...&quot; printed 4 times - the driver is supporting only one adapter now! */
r_static
r_int
id|no_more_found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|no_more_found
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|no_more_found
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Probing for PAM&squot;s Net/GK Adapter...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate the DMA buffer here since we need it for probing! */
id|nic_packet
op_assign
(paren
r_struct
id|nic_pkt_s
op_star
)paren
id|acsi_buffer
suffix:semicolon
id|phys_nic_packet
op_assign
(paren
r_int
r_char
op_star
)paren
id|phys_acsi_buffer
suffix:semicolon
r_if
c_cond
(paren
id|pamsnet_debug
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nic_packet at 0x%p, phys at 0x%p&bslash;n&quot;
comma
id|nic_packet
comma
id|phys_nic_packet
)paren
suffix:semicolon
)brace
id|stdma_lock
c_func
(paren
id|pamsnet_intr
comma
l_int|NULL
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Do two inquiries to cover cases with strange equipment on previous ID */
multiline_comment|/* blocking the ACSI bus (like the SLMC804 laser printer controller...   */
id|inquiry
c_func
(paren
id|i
comma
id|phys_nic_packet
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inquiry
c_func
(paren
id|i
comma
id|phys_nic_packet
)paren
)paren
(brace
id|lance_target
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|NET_DEBUG
)paren
id|printk
c_func
(paren
l_string|&quot;ID: %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lance_target
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwaddr
op_assign
id|read_hw_addr
c_func
(paren
id|lance_target
comma
id|phys_nic_packet
)paren
)paren
)paren
id|lance_target
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|memcpy
(paren
id|station_addr
comma
id|hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lance_target
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;No PAM&squot;s Net/GK found.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|lance_target
OL
l_int|0
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|pamsnet_debug
OG
l_int|0
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s found on target %01d, eth-addr: %02x:%02x:%02x:%02x:%02x:%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_string|&quot;PAM&squot;s Net/GK&quot;
comma
id|lance_target
comma
id|station_addr
(braket
l_int|0
)braket
comma
id|station_addr
(braket
l_int|1
)braket
comma
id|station_addr
(braket
l_int|2
)braket
comma
id|station_addr
(braket
l_int|3
)braket
comma
id|station_addr
(braket
l_int|4
)braket
comma
id|station_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|pamsnet_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|pamsnet_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|pamsnet_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet-generic&n;&t; * values. This should be in a common file instead of per-driver.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if 0
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#endif
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|station_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n; */
r_static
r_int
DECL|function|pamsnet_open
id|pamsnet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pamsnet_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;pamsnet_open&bslash;n&quot;
)paren
suffix:semicolon
id|stdma_lock
c_func
(paren
id|pamsnet_intr
comma
l_int|NULL
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Reset the hardware here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|if_up
)paren
id|start
c_func
(paren
id|lance_target
)paren
suffix:semicolon
id|if_up
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;open_time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*jiffies*/
id|lp-&gt;poll_time
op_assign
id|MAX_POLL_TIME
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
id|pamsnet_timer.data
op_assign
(paren
r_int
)paren
id|dev
suffix:semicolon
id|pamsnet_timer.expires
op_assign
id|jiffies
op_plus
id|lp-&gt;poll_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|pamsnet_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pamsnet_send_packet
id|pamsnet_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Block a timer-based transmit from overlapping.  This could better be&n;&t; * done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stdma_islocked
c_func
(paren
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_int
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stdma_lock
c_func
(paren
id|pamsnet_intr
comma
l_int|NULL
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|buf
op_plus
id|length
op_minus
l_int|1
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|nic_packet-&gt;buffer
comma
id|skb-&gt;data
comma
id|length
)paren
suffix:semicolon
id|buf
op_assign
(paren
r_int
r_int
)paren
id|phys_nic_packet
suffix:semicolon
)brace
id|dma_cache_maintenance
c_func
(paren
id|buf
comma
id|length
comma
l_int|1
)paren
suffix:semicolon
id|stat
op_assign
id|sendpkt
c_func
(paren
id|lance_target
comma
(paren
r_int
r_char
op_star
)paren
id|buf
comma
id|length
)paren
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|length
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers.&n; */
r_static
r_void
DECL|function|pamsnet_poll_rx
id|pamsnet_poll_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|boguscount
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ++roman: Take care at locking the ST-DMA... This must be done with ints&n;&t; * off, since otherwise an int could slip in between the question and the&n;&t; * locking itself, and then we&squot;d go to sleep... And locking itself is&n;&t; * necessary to keep the floppy_change timer from working with ST-DMA&n;&t; * registers. */
r_if
c_cond
(paren
id|stdma_islocked
c_func
(paren
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stdma_lock
c_func
(paren
id|pamsnet_intr
comma
l_int|NULL
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|boguscount
op_assign
id|testpkt
c_func
(paren
id|lance_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;poll_time
OL
id|MAX_POLL_TIME
)paren
(brace
id|lp-&gt;poll_time
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|boguscount
op_decrement
)paren
(brace
id|pkt_len
op_assign
id|receivepkt
c_func
(paren
id|lance_target
comma
id|phys_nic_packet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_len
OL
l_int|60
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Good packet... */
id|dma_cache_maintenance
c_func
(paren
(paren
r_int
r_int
)paren
id|phys_nic_packet
comma
id|pkt_len
comma
l_int|0
)paren
suffix:semicolon
id|lp-&gt;poll_time
op_assign
id|pamsnet_min_poll_time
suffix:semicolon
multiline_comment|/* fast poll */
r_if
c_cond
(paren
id|pkt_len
op_ge
l_int|60
op_logical_and
id|pkt_len
op_le
l_int|2048
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OG
l_int|1514
)paren
id|pkt_len
op_assign
l_int|1514
suffix:semicolon
multiline_comment|/* Malloc up new buffer.&n;&t;&t;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* &squot;skb-&gt;data&squot; points to the start of sk_buff data area.&n;&t;&t;&t; */
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|nic_packet-&gt;buffer
comma
id|pkt_len
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
)brace
multiline_comment|/* If any worth-while packets have been received, dev_rint()&n;&t;   has done a mark_bh(INET_BH) for us and will work on them&n;&t;   when we get to the bottom-half routine.&n;&t; */
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pamsnet_tick: called by pamsnet_timer. Reads packets from the adapter,&n; * passes them to the higher layers and restarts the timer.&n; */
r_static
r_void
DECL|function|pamsnet_tick
id|pamsnet_tick
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pamsnet_debug
OG
l_int|0
op_logical_and
(paren
id|lp-&gt;open_time
op_increment
op_amp
l_int|7
)paren
op_eq
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pamsnet_tick: %ld&bslash;n&quot;
comma
id|lp-&gt;open_time
)paren
suffix:semicolon
)brace
id|pamsnet_poll_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pamsnet_timer.expires
op_assign
id|jiffies
op_plus
id|lp-&gt;poll_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|pamsnet_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to pamsnet_open().&n; */
r_static
r_int
DECL|function|pamsnet_close
id|pamsnet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pamsnet_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;pamsnet_close, open_time=%ld&bslash;n&quot;
comma
id|lp-&gt;open_time
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|pamsnet_timer
)paren
suffix:semicolon
id|stdma_lock
c_func
(paren
id|pamsnet_intr
comma
l_int|NULL
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|if_up
)paren
id|stop
c_func
(paren
id|lance_target
)paren
suffix:semicolon
id|if_up
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;open_time
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&n;   This may be called with the card open or closed.&n; */
DECL|function|net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|pam_dev
r_static
r_struct
id|net_device
id|pam_dev
suffix:semicolon
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|pam_dev.init
op_assign
id|pamsnet_probe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|register_netdev
c_func
(paren
op_amp
id|pam_dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EEXIST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PAM&squot;s Net/GK: devices already present. Module not loaded.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|pam_dev
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/* Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/include&n;&t;-b m68k-linuxaout -Wall -Wstrict-prototypes -O2&n;&t;-fomit-frame-pointer -pipe -DMODULE -I../../net/inet -c atari_pamsnet.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 8&n; * End:&n; */
eof
