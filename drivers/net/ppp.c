multiline_comment|/*  PPP for Linux&n; *&n; *  Michael Callahan &lt;callahan@maths.ox.ac.uk&gt;&n; *  Al Longyear &lt;longyear@netcom.com&gt;&n; *  Extensively rewritten by Paul Mackerras &lt;paulus@cs.anu.edu.au&gt;&n; *&n; *  ==FILEVERSION 990510==&n; *&n; *  NOTE TO MAINTAINERS:&n; *     If you modify this file at all, please set the number above to the&n; *     date of the modification as YYMMDD (year month day).&n; *     ppp.c is shipped with a PPP distribution as well as with the kernel;&n; *     if everyone increases the FILEVERSION number above, then scripts&n; *     can do the right thing when deciding whether to install a new ppp.c&n; *     file.  Don&squot;t change the format of that line otherwise, so the&n; *     installation script can recognize it.&n; */
multiline_comment|/*&n;   Sources:&n;&n;   slip.c&n;&n;   RFC1331: The Point-to-Point Protocol (PPP) for the Transmission of&n;   Multi-protocol Datagrams over Point-to-Point Links&n;&n;   RFC1332: IPCP&n;&n;   ppp-2.0&n;&n;   Flags for this module (any combination is acceptable for testing.):&n;&n;   OPTIMIZE_FLAG_TIME - Number of jiffies to force sending of leading flag&n;&t;&t;&t;character. This is normally set to ((HZ * 3) / 2).&n;&t;&t;&t;This is 1.5 seconds. If zero then the leading&n;&t;&t;&t;flag is always sent.&n;&n;   CHECK_CHARACTERS   - Enable the checking on all received characters for&n;&t;&t;&t;8 data bits, no parity. This adds a small amount of&n;&t;&t;&t;processing for each received character.&n;*/
DECL|macro|OPTIMIZE_FLAG_TIME
mdefine_line|#define OPTIMIZE_FLAG_TIME&t;((HZ * 3)/2)
DECL|macro|CHECK_CHARACTERS
mdefine_line|#define CHECK_CHARACTERS&t;1
DECL|macro|PPP_MAX_RCV_QLEN
mdefine_line|#define PPP_MAX_RCV_QLEN&t;32&t;/* max # frames we queue up for pppd */
multiline_comment|/* $Id: ppp.c,v 1.24 1999/03/31 06:07:57 paulus Exp $ */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;linux/signal.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;net/slhc_vj.h&gt;
DECL|macro|fcstab
mdefine_line|#define fcstab&t;ppp_crc16_table&t;&t;/* Name of the table in the kernel */
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/if_ppp.h&gt;
macro_line|#include &lt;linux/if_pppvar.h&gt;
macro_line|#include &lt;linux/ppp-comp.h&gt;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Local functions&n; */
macro_line|#ifdef CONFIG_MODULES
r_static
r_int
id|ppp_register_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ppp_unregister_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ppp_async_init
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_async_release
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_sync_push
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_push
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_encode
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_send
c_func
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_sync_send
c_func
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_flush_output
c_func
(paren
r_struct
id|ppp
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_ioctl
c_func
(paren
r_struct
id|ppp
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|ppp_set_compression
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_option_data
op_star
id|odp
)paren
suffix:semicolon
r_static
r_void
id|ppp_proto_ccp
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|dp
comma
r_int
id|len
comma
r_int
id|rcvd
)paren
suffix:semicolon
r_static
r_void
id|ppp_ccp_closed
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_int
id|ppp_receive_frame
c_func
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppp_receive_error
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_output_wakeup
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_send_ctrl
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|ppp_send_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|ppp_send_frames
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_struct
id|sk_buff
op_star
id|ppp_vj_compress
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_struct
id|ppp
op_star
id|ppp_find
(paren
r_int
id|pid_value
)paren
suffix:semicolon
r_static
r_struct
id|ppp
op_star
id|ppp_alloc
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|ppp_generic_init
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_release
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_print_buffer
(paren
r_const
r_char
op_star
comma
r_const
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_struct
id|compressor
op_star
id|find_compressor
(paren
r_int
id|type
)paren
suffix:semicolon
macro_line|#ifndef OPTIMIZE_FLAG_TIME
DECL|macro|OPTIMIZE_FLAG_TIME
mdefine_line|#define OPTIMIZE_FLAG_TIME&t;0
macro_line|#endif
multiline_comment|/*&n; * Parameters which may be changed via insmod.&n; */
DECL|variable|flag_time
r_static
r_int
id|flag_time
op_assign
id|OPTIMIZE_FLAG_TIME
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flag_time
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|CHECK_PPP_MAGIC
mdefine_line|#define CHECK_PPP_MAGIC(ppp)&t;do { &bslash;&n;&t;if (ppp-&gt;magic != PPP_MAGIC) { &bslash;&n;&t;&t;printk(ppp_magic_warn, ppp, __FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;} while (0)
DECL|macro|CHECK_PPP
mdefine_line|#define CHECK_PPP(a)&t;do { &bslash;&n;&t;CHECK_PPP_MAGIC(ppp); &bslash;&n;&t;if (!ppp-&gt;inuse) { &bslash;&n;&t;&t;printk(ppp_warning, __LINE__); &bslash;&n;&t;&t;return a; &bslash;&n;&t;} &bslash;&n;} while (0)
DECL|macro|CHECK_PPP_VOID
mdefine_line|#define CHECK_PPP_VOID() do { &bslash;&n;&t;CHECK_PPP_MAGIC(ppp); &bslash;&n;&t;if (!ppp-&gt;inuse) { &bslash;&n;&t;&t;printk(ppp_warning, __LINE__); &bslash;&n;&t;&t;return; &bslash;&n;&t;} &bslash;&n;} while (0)
DECL|macro|tty2ppp
mdefine_line|#define tty2ppp(tty)&t;((struct ppp *) ((tty)-&gt;disc_data))
DECL|macro|dev2ppp
mdefine_line|#define dev2ppp(dev)&t;((struct ppp *) ((dev)-&gt;priv))
DECL|macro|ppp2tty
mdefine_line|#define ppp2tty(ppp)&t;((ppp)-&gt;tty)
DECL|macro|ppp2dev
mdefine_line|#define ppp2dev(ppp)&t;(&amp;(ppp)-&gt;dev)
DECL|variable|ppp_list
r_static
r_struct
id|ppp
op_star
id|ppp_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ppp_last
r_static
r_struct
id|ppp
op_star
id|ppp_last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Define these strings only once for all macro invocations */
DECL|variable|ppp_warning
r_static
r_char
id|ppp_warning
(braket
)braket
op_assign
id|KERN_WARNING
l_string|&quot;PPP: ALERT! not INUSE! %d&bslash;n&quot;
suffix:semicolon
DECL|variable|ppp_magic_warn
r_static
r_char
id|ppp_magic_warn
(braket
)braket
op_assign
id|KERN_WARNING
l_string|&quot;bad magic for ppp %p at %s:%d&bslash;n&quot;
suffix:semicolon
DECL|variable|szVersion
r_static
r_char
id|szVersion
(braket
)braket
op_assign
id|PPP_VERSION
suffix:semicolon
DECL|variable|ppp_register_compressor
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_register_compressor
)paren
suffix:semicolon
DECL|variable|ppp_unregister_compressor
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_unregister_compressor
)paren
suffix:semicolon
multiline_comment|/*************************************************************&n; * LINE DISCIPLINE SUPPORT&n; *    The following code implements the PPP line discipline&n; *    and supports using PPP on an async serial line.&n; *************************************************************/
DECL|macro|in_xmap
mdefine_line|#define in_xmap(ppp,c)&t;(ppp-&gt;xmit_async_map[(c) &gt;&gt; 5] &amp; (1 &lt;&lt; ((c) &amp; 0x1f)))
DECL|macro|in_rmap
mdefine_line|#define in_rmap(ppp,c)&t;((((unsigned int) (__u8) (c)) &lt; 0x20) &amp;&amp; &bslash;&n;&t;&t;&t;ppp-&gt;recv_async_map &amp; (1 &lt;&lt; (c)))
multiline_comment|/*&n; * TTY callbacks&n; */
r_static
id|ssize_t
id|ppp_tty_read
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
id|ssize_t
id|ppp_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_const
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|ppp_tty_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_open
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_close
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_receive
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_wakeup
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|variable|ppp_crc16_table
id|__u16
id|ppp_crc16_table
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
DECL|variable|ppp_crc16_table
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_crc16_table
)paren
suffix:semicolon
macro_line|#ifdef CHECK_CHARACTERS
DECL|variable|paritytab
r_static
id|__u32
id|paritytab
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x96696996
comma
l_int|0x69969669
comma
l_int|0x69969669
comma
l_int|0x96696996
comma
l_int|0x69969669
comma
l_int|0x96696996
comma
l_int|0x96696996
comma
l_int|0x69969669
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * This procedure is called at initialization time to register&n; * the PPP line discipline.&n; */
r_static
r_int
DECL|function|ppp_first_time
id|ppp_first_time
c_func
(paren
r_void
)paren
(brace
r_static
r_struct
id|tty_ldisc
id|ppp_ldisc
suffix:semicolon
r_int
id|status
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PPP: version %s (demand dialling)&quot;
l_string|&quot;&bslash;n&quot;
comma
id|szVersion
)paren
suffix:semicolon
macro_line|#ifndef MODULE /* slhc module logic has its own copyright announcement */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TCP compression code copyright 1989 Regents of the &quot;
l_string|&quot;University of California&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Register the tty discipline&n;&t; */
(paren
r_void
)paren
id|memset
(paren
op_amp
id|ppp_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|ppp_ldisc
)paren
)paren
suffix:semicolon
id|ppp_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|ppp_ldisc.name
op_assign
l_string|&quot;ppp&quot;
suffix:semicolon
id|ppp_ldisc.open
op_assign
id|ppp_tty_open
suffix:semicolon
id|ppp_ldisc.close
op_assign
id|ppp_tty_close
suffix:semicolon
id|ppp_ldisc.read
op_assign
id|ppp_tty_read
suffix:semicolon
id|ppp_ldisc.write
op_assign
id|ppp_tty_write
suffix:semicolon
id|ppp_ldisc.ioctl
op_assign
id|ppp_tty_ioctl
suffix:semicolon
id|ppp_ldisc.poll
op_assign
id|ppp_tty_poll
suffix:semicolon
id|ppp_ldisc.receive_room
op_assign
id|ppp_tty_room
suffix:semicolon
id|ppp_ldisc.receive_buf
op_assign
id|ppp_tty_receive
suffix:semicolon
id|ppp_ldisc.write_wakeup
op_assign
id|ppp_tty_wakeup
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
(paren
id|N_PPP
comma
op_amp
id|ppp_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PPP line discipline registered.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;error registering line discipline: %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * Called at boot time if the PPP driver is compiled into the kernel.&n; */
r_int
DECL|function|ppp_init
id|ppp_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
r_int
id|answer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|first_time
op_assign
l_int|0
suffix:semicolon
id|answer
op_assign
id|ppp_first_time
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|answer
op_eq
l_int|0
)paren
id|answer
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
id|answer
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Initialize the async-specific parts of the ppp structure.&n; */
r_static
r_void
DECL|function|ppp_async_init
id|ppp_async_init
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|0xE0
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|ppp-&gt;xmit_async_map
comma
l_int|0
comma
r_sizeof
(paren
id|ppp-&gt;xmit_async_map
)paren
)paren
suffix:semicolon
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
id|ppp-&gt;xmit_async_map
(braket
l_int|3
)braket
op_assign
l_int|0x60000000
suffix:semicolon
id|ppp-&gt;recv_async_map
op_assign
l_int|0xffffffff
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;tfcs
op_assign
id|PPP_INITFCS
suffix:semicolon
id|ppp-&gt;optr
op_assign
id|ppp-&gt;obuf
suffix:semicolon
id|ppp-&gt;olim
op_assign
id|ppp-&gt;obuf
suffix:semicolon
id|ppp-&gt;rpkt
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;rfcs
op_assign
id|PPP_INITFCS
suffix:semicolon
id|ppp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;backup_tty
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;bytes_sent
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;bytes_rcvd
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean up the async-specific parts of the ppp structure.&n; */
r_static
r_void
DECL|function|ppp_async_release
id|ppp_async_release
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|ppp-&gt;rpkt
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;rpkt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|ppp-&gt;tpkt
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * TTY callback.&n; *&n; * Called when the tty discipline is switched to PPP.&n; */
r_static
r_int
DECL|function|ppp_tty_open
id|ppp_tty_open
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a ppp structure to use.&n;&t; */
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
id|ppp
op_assign
id|ppp_find
c_func
(paren
id|current-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we are taking over a ppp unit which is currently&n;&t;&t; * connected to a loopback pty, there&squot;s not much to do.&n;&t;&t; */
id|CHECK_PPP
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
(brace
id|ppp
op_assign
id|ppp_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_alloc failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Initialize the control block&n;&t;&t; */
id|ppp_generic_init
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp_async_init
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
id|tty-&gt;disc_data
op_assign
id|ppp
suffix:semicolon
id|ppp-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/*&n;&t; * Flush any pending characters in the driver&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver.flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_return
id|ppp-&gt;line
suffix:semicolon
)brace
multiline_comment|/*&n; * TTY callback.&n; *&n; * Called when the line discipline is changed to something&n; * else, the tty is closed, or the tty detects a hangup.&n; */
r_static
r_void
DECL|function|ppp_tty_close
id|ppp_tty_close
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ppp_tty_close: bogus&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;inuse
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ppp_tty_close: not inuse&bslash;n&quot;
)paren
suffix:semicolon
id|ppp-&gt;tty
op_assign
id|ppp-&gt;backup_tty
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty
op_eq
id|ppp-&gt;backup_tty
)paren
id|ppp-&gt;backup_tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;backup_tty
)paren
(brace
id|ppp-&gt;tty
op_assign
id|ppp-&gt;backup_tty
suffix:semicolon
r_if
c_cond
(paren
id|ppp_tty_push
c_func
(paren
id|ppp
)paren
)paren
id|ppp_output_wakeup
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|ppp-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;sc_xfer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp: channel %s closing.&bslash;n&quot;
comma
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|ppp_async_release
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp_release
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read a PPP frame from the rcv_q list,&n; * waiting if necessary&n; */
r_static
id|ssize_t
DECL|function|ppp_tty_read
id|ppp_tty_read
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|__u8
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ssize_t
id|len
comma
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the pointers&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|CHECK_PPP
c_func
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Before we attempt to write the frame to the user, ensure that the&n;&t; * user has access to the pages for the total buffer length.&n;&t; */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for a frame to arrive if necessary.&n;&t; * We increment the module use count so that the module&n;&t; * can&squot;t go away while we&squot;re sleeping.&n;&t; */
id|MOD_INC_USE_COUNT
suffix:semicolon
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ppp
op_assign
id|tty2ppp
c_func
(paren
id|tty
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp
op_logical_or
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
op_logical_or
op_logical_neg
id|ppp-&gt;inuse
op_logical_or
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If no frame is available, return -EAGAIN or wait.&n;&t;&t; */
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_break
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the frame will fit within the caller&squot;s buffer.&n;&t; * If not, just discard the frame.&n;&t; */
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|nr
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: read of %lu bytes too small for %ld &quot;
l_string|&quot;frame&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|nr
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
id|ppp-&gt;stats.ppp_ierrors
op_increment
suffix:semicolon
id|err
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy the received data from the buffer to the caller&squot;s area.&n;&t; */
id|err
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|len
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|out
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Writing to a tty in ppp line discipline sends a PPP frame.&n; * Used by pppd to send control packets (LCP, etc.).&n; */
r_static
id|ssize_t
DECL|function|ppp_tty_write
id|ppp_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
id|__u8
op_star
id|new_data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the pointers.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|CHECK_PPP
c_func
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the caller does not wish to send too much.&n;&t; */
r_if
c_cond
(paren
id|count
OG
id|PPP_MTU
op_plus
id|PPP_HDRLEN
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ppp_tty_write: truncating user packet &quot;
l_string|&quot;from %lu to mtu %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|count
comma
id|PPP_MTU
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
id|count
op_assign
id|PPP_MTU
op_plus
id|PPP_HDRLEN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a buffer for the data and fetch it from the user space.&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_tty_write: no memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|new_data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Retrieve the user&squot;s buffer&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|new_data
comma
id|data
comma
id|count
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Send the frame&n;&t; */
id|ppp_send_ctrl
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_return
(paren
id|ssize_t
)paren
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the IOCTL call for the tty device.&n; * Only the ioctls that relate to using ppp on async serial lines&n; * are processed here; the rest are handled by ppp_ioctl.&n; */
r_static
r_int
DECL|function|ppp_tty_ioctl
id|ppp_tty_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|param2
comma
r_int
r_int
id|param3
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_register
r_int
id|temp_i
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the status of the PPP device.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ppp
op_logical_or
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
op_logical_or
op_logical_neg
id|ppp-&gt;inuse
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t; * The user must have an euid of root to do these requests.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|param2
)paren
(brace
r_case
id|PPPIOCGASYNCMAP
suffix:colon
multiline_comment|/*&n;&t;&t; * Retrieve the transmit async map&n;&t;&t; */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSASYNCMAP
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the transmit async map&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
op_assign
id|temp_i
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set xmit asyncmap %x&bslash;n&quot;
comma
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the receive async map&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|ppp-&gt;recv_async_map
op_assign
id|temp_i
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set rcv asyncmap %x&bslash;n&quot;
comma
id|ppp-&gt;recv_async_map
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
multiline_comment|/*&n;&t;&t; * Get the map of characters to be escaped on transmission.&n;&t;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param3
comma
id|ppp-&gt;xmit_async_map
comma
r_sizeof
(paren
id|ppp-&gt;xmit_async_map
)paren
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the map of characters to be escaped on transmission.&n;&t;&t; */
(brace
id|__u32
id|temp_tbl
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|temp_tbl
comma
(paren
r_void
op_star
)paren
id|param3
comma
r_sizeof
(paren
id|temp_tbl
)paren
)paren
)paren
r_break
suffix:semicolon
id|temp_tbl
(braket
l_int|1
)braket
op_assign
l_int|0x00000000
suffix:semicolon
id|temp_tbl
(braket
l_int|2
)braket
op_and_assign
op_complement
l_int|0x40000000
suffix:semicolon
id|temp_tbl
(braket
l_int|3
)braket
op_or_assign
l_int|0x60000000
suffix:semicolon
id|memcpy
c_func
(paren
id|ppp-&gt;xmit_async_map
comma
id|temp_tbl
comma
r_sizeof
(paren
id|ppp-&gt;xmit_async_map
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set xasyncmap&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PPPIOCXFERUNIT
suffix:colon
multiline_comment|/*&n;&t;&t; * Set up this PPP unit to be used next time this&n;&t;&t; * process sets a tty to PPP line discipline.&n;&t;&t; */
id|ppp-&gt;backup_tty
op_assign
id|tty
suffix:semicolon
id|ppp-&gt;sc_xfer
op_assign
id|current-&gt;pid
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
multiline_comment|/*&n;&t;&t; * Allow users to read, but not set, the serial port parameters&n;&t;&t; */
id|error
op_assign
id|n_tty_ioctl
(paren
id|tty
comma
id|file
comma
id|param2
comma
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCFLSH
suffix:colon
multiline_comment|/*&n;&t;&t; * Flush our buffers, then call the generic code to&n;&t;&t; * flush the serial port&squot;s buffer.&n;&t;&t; */
r_if
c_cond
(paren
id|param3
op_eq
id|TCIFLUSH
op_logical_or
id|param3
op_eq
id|TCIOFLUSH
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|param3
op_eq
id|TCIOFLUSH
op_logical_or
id|param3
op_eq
id|TCOFLUSH
)paren
id|ppp_tty_flush_output
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|error
op_assign
id|n_tty_ioctl
(paren
id|tty
comma
id|file
comma
id|param2
comma
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIONREAD
suffix:colon
multiline_comment|/*&n;&t;&t; * Returns how many bytes are available for a read().&n;&t;&t; */
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|0
)paren
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|count
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t; *  All other ioctl() events will come here.&n;&t;&t; */
id|error
op_assign
id|ppp_ioctl
c_func
(paren
id|ppp
comma
id|param2
comma
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * TTY callback.&n; *&n; * Process the poll() statement for the PPP device.&n; */
r_static
r_int
r_int
DECL|function|ppp_tty_poll
id|ppp_tty_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_logical_and
id|ppp-&gt;magic
op_eq
id|PPP_MAGIC
op_logical_and
id|tty
op_eq
id|ppp-&gt;tty
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|ppp-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
op_ne
l_int|NULL
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_OTHER_CLOSED
)paren
op_logical_or
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called by the tty driver when the transmit buffer has&n; * additional space. It is used by the ppp code to continue to transmit&n; * the current buffer should the buffer have been partially sent.&n; */
r_static
r_void
DECL|function|ppp_tty_wakeup
id|ppp_tty_wakeup
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_return
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppp_tty_push
c_func
(paren
id|ppp
)paren
)paren
id|ppp_output_wakeup
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a packet to the peer over a synchronous tty line.&n; * All encoding and FCS are handled by hardware.&n; * Addr/Ctrl and Protocol field compression implemented.&n; * Returns -1 iff the packet could not be accepted at present,&n; * 0 if the packet was accepted but we can&squot;t accept another yet, or&n; * 1 if we can accept another packet immediately.&n; * If this procedure returns 0, ppp_output_wakeup will be called&n; * exactly once.&n; */
r_static
r_int
DECL|function|ppp_sync_send
id|ppp_sync_send
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|islcp
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tpkt
op_ne
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
id|skb
suffix:semicolon
id|data
op_assign
id|ppp-&gt;tpkt-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * LCP packets with code values between 1 (configure-reqest)&n;&t; * and 7 (code-reject) must be sent as though no options&n;&t; * had been negotiated.&n;&t; */
id|islcp
op_assign
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
op_eq
id|PPP_LCP
op_logical_and
l_int|1
op_le
id|data
(braket
id|PPP_HDRLEN
)braket
op_logical_and
id|data
(braket
id|PPP_HDRLEN
)braket
op_le
l_int|7
suffix:semicolon
multiline_comment|/* only reset idle time for data packets */
r_if
c_cond
(paren
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
OL
l_int|0x8000
)paren
id|ppp-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_opackets
suffix:semicolon
id|ppp-&gt;stats.ppp_ooctects
op_add_assign
id|ppp-&gt;tpkt-&gt;len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
(braket
l_int|2
)braket
)paren
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
)paren
(brace
multiline_comment|/* compress protocol field */
id|data
(braket
l_int|2
)braket
op_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
id|skb_pull
c_func
(paren
id|ppp-&gt;tpkt
comma
l_int|1
)paren
suffix:semicolon
id|data
op_assign
id|ppp-&gt;tpkt-&gt;data
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do address/control compression&n;&t; */
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_logical_and
op_logical_neg
id|islcp
op_logical_and
id|PPP_ADDRESS
c_func
(paren
id|data
)paren
op_eq
id|PPP_ALLSTATIONS
op_logical_and
id|PPP_CONTROL
c_func
(paren
id|data
)paren
op_eq
id|PPP_UI
)paren
(brace
multiline_comment|/* strip addr and control field */
id|skb_pull
c_func
(paren
id|ppp-&gt;tpkt
comma
l_int|2
)paren
suffix:semicolon
)brace
r_return
id|ppp_tty_sync_push
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Push a synchronous frame out to the tty.&n; * Returns 1 if frame accepted (or discarded), 0 otherwise.&n; */
r_static
r_int
DECL|function|ppp_tty_sync_push
id|ppp_tty_sync_push
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_int
id|sent
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ppp2tty
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tpkt
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* prevent reentrancy with tty_pushing flag */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tty_pushing
)paren
(brace
multiline_comment|/* record wakeup attempt so we don&squot;t lose */
multiline_comment|/* a wakeup call while doing push processing */
id|ppp-&gt;woke_up
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ppp-&gt;tty_pushing
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
l_int|NULL
op_logical_or
id|tty-&gt;disc_data
op_ne
(paren
r_void
op_star
)paren
id|ppp
)paren
r_goto
id|flush
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ppp-&gt;woke_up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Note: Sync driver accepts complete frame or nothing */
id|tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|sent
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|ppp-&gt;tpkt-&gt;data
comma
id|ppp-&gt;tpkt-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
l_int|0
)paren
(brace
multiline_comment|/* write error (possible loss of CD) */
multiline_comment|/* record error and discard current packet */
id|ppp-&gt;stats.ppp_oerrors
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ppp-&gt;stats.ppp_obytes
op_add_assign
id|sent
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
id|ppp-&gt;tpkt-&gt;len
)paren
(brace
multiline_comment|/* driver unable to accept frame just yet */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;woke_up
)paren
(brace
multiline_comment|/* wake up called while processing */
multiline_comment|/* try to send the frame again */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* wait for wakeup callback to try send again */
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|flush
suffix:colon
multiline_comment|/* done with current packet (sent or discarded) */
id|kfree_skb
c_func
(paren
id|ppp-&gt;tpkt
)paren
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a packet to the peer over an async tty line.&n; * Returns -1 iff the packet could not be accepted at present,&n; * 0 if the packet was accepted but we can&squot;t accept another yet, or&n; * 1 if we can accept another packet immediately.&n; * If this procedure returns 0, ppp_output_wakeup will be called&n; * exactly once.&n; */
r_static
r_int
DECL|function|ppp_async_send
id|ppp_async_send
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ppp_tty_push
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tpkt
op_ne
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
id|skb
suffix:semicolon
id|ppp-&gt;tpkt_pos
op_assign
l_int|0
suffix:semicolon
r_return
id|ppp_tty_push
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Push as much data as possible out to the tty.&n; * Returns 1 if we finished encoding the current frame, 0 otherwise.&n; */
r_static
r_int
DECL|function|ppp_tty_push
id|ppp_tty_push
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_int
id|avail
comma
id|sent
comma
id|done
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ppp2tty
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_SYNC
)paren
r_return
id|ppp_tty_sync_push
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tty_pushing
)paren
(brace
id|ppp-&gt;woke_up
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty
op_eq
l_int|NULL
op_logical_or
id|tty-&gt;disc_data
op_ne
(paren
r_void
op_star
)paren
id|ppp
)paren
r_goto
id|flush
suffix:semicolon
r_while
c_loop
(paren
id|ppp-&gt;optr
OL
id|ppp-&gt;olim
op_logical_or
id|ppp-&gt;tpkt
op_ne
l_int|0
)paren
(brace
id|ppp-&gt;tty_pushing
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;woke_up
op_assign
l_int|0
suffix:semicolon
id|avail
op_assign
id|ppp-&gt;olim
op_minus
id|ppp-&gt;optr
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
l_int|0
)paren
(brace
id|tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|sent
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|ppp-&gt;optr
comma
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
l_int|0
)paren
r_goto
id|flush
suffix:semicolon
multiline_comment|/* error, e.g. loss of CD */
id|ppp-&gt;stats.ppp_obytes
op_add_assign
id|sent
suffix:semicolon
id|ppp-&gt;optr
op_add_assign
id|sent
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
id|avail
)paren
(brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;woke_up
)paren
r_continue
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ppp-&gt;tpkt
op_ne
l_int|0
)paren
id|done
op_assign
id|ppp_async_encode
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|done
suffix:semicolon
id|flush
suffix:colon
id|ppp-&gt;tty_pushing
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;stats.ppp_oerrors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tpkt
op_ne
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|ppp-&gt;tpkt
)paren
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|ppp-&gt;optr
op_assign
id|ppp-&gt;olim
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedure to encode the data for async serial transmission.&n; * Does octet stuffing (escaping) and address/control&n; * and protocol compression.&n; * Assumes ppp-&gt;opkt != 0 on entry.&n; * Returns 1 if we finished the current frame, 0 otherwise.&n; */
r_static
r_int
DECL|function|ppp_async_encode
id|ppp_async_encode
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_int
id|fcs
comma
id|i
comma
id|count
comma
id|c
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
op_star
id|buflim
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|islcp
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|buf
op_assign
id|ppp-&gt;obuf
suffix:semicolon
id|ppp-&gt;olim
op_assign
id|buf
suffix:semicolon
id|ppp-&gt;optr
op_assign
id|buf
suffix:semicolon
id|i
op_assign
id|ppp-&gt;tpkt_pos
suffix:semicolon
id|data
op_assign
id|ppp-&gt;tpkt-&gt;data
suffix:semicolon
id|count
op_assign
id|ppp-&gt;tpkt-&gt;len
suffix:semicolon
id|fcs
op_assign
id|ppp-&gt;tfcs
suffix:semicolon
multiline_comment|/*&n;&t; * LCP packets with code values between 1 (configure-reqest)&n;&t; * and 7 (code-reject) must be sent as though no options&n;&t; * had been negotiated.&n;&t; */
id|islcp
op_assign
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
op_eq
id|PPP_LCP
op_logical_and
l_int|1
op_le
id|data
(braket
id|PPP_HDRLEN
)braket
op_logical_and
id|data
(braket
id|PPP_HDRLEN
)braket
op_le
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Start of a new packet - insert the leading FLAG&n;&t;&t; * character if necessary.&n;&t;&t; */
r_if
c_cond
(paren
id|islcp
op_logical_or
id|flag_time
op_eq
l_int|0
op_logical_or
id|jiffies
op_minus
id|ppp-&gt;last_xmit
op_ge
id|flag_time
)paren
op_star
id|buf
op_increment
op_assign
id|PPP_FLAG
suffix:semicolon
multiline_comment|/* only reset idle time for data packets */
r_if
c_cond
(paren
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
OL
l_int|0x8000
)paren
id|ppp-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
id|fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_opackets
suffix:semicolon
id|ppp-&gt;stats.ppp_ooctects
op_add_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do address/control compression&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_ne
l_int|0
op_logical_and
op_logical_neg
id|islcp
op_logical_and
id|PPP_ADDRESS
c_func
(paren
id|data
)paren
op_eq
id|PPP_ALLSTATIONS
op_logical_and
id|PPP_CONTROL
c_func
(paren
id|data
)paren
op_eq
id|PPP_UI
)paren
id|i
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Once we put in the last byte, we need to put in the FCS&n;&t; * and closing flag, so make sure there is at least 7 bytes&n;&t; * of free space in the output buffer.&n;&t; */
id|buflim
op_assign
id|buf
op_plus
id|OBUFSIZE
op_minus
l_int|6
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|count
op_logical_and
id|buf
OL
id|buflim
)paren
(brace
id|c
op_assign
id|data
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|3
op_logical_and
id|c
op_eq
l_int|0
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* compress protocol field */
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_xmap
c_func
(paren
id|ppp
comma
id|c
)paren
op_logical_or
(paren
id|islcp
op_logical_and
id|c
OL
l_int|0x20
)paren
)paren
(brace
op_star
id|buf
op_increment
op_assign
id|PPP_ESCAPE
suffix:semicolon
id|c
op_xor_assign
l_int|0x20
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; * We have finished the packet.  Add the FCS and flag.&n;&t;&t; */
id|fcs
op_assign
op_complement
id|fcs
suffix:semicolon
id|c
op_assign
id|fcs
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|in_xmap
c_func
(paren
id|ppp
comma
id|c
)paren
op_logical_or
(paren
id|islcp
op_logical_and
id|c
OL
l_int|0x20
)paren
)paren
(brace
op_star
id|buf
op_increment
op_assign
id|PPP_ESCAPE
suffix:semicolon
id|c
op_xor_assign
l_int|0x20
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
id|c
suffix:semicolon
id|c
op_assign
(paren
id|fcs
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|in_xmap
c_func
(paren
id|ppp
comma
id|c
)paren
op_logical_or
(paren
id|islcp
op_logical_and
id|c
OL
l_int|0x20
)paren
)paren
(brace
op_star
id|buf
op_increment
op_assign
id|PPP_ESCAPE
suffix:semicolon
id|c
op_xor_assign
l_int|0x20
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
id|c
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|PPP_FLAG
suffix:semicolon
id|ppp-&gt;olim
op_assign
id|buf
suffix:semicolon
id|kfree_skb
c_func
(paren
id|ppp-&gt;tpkt
)paren
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remember where we are up to in this packet.&n;&t; */
id|ppp-&gt;olim
op_assign
id|buf
suffix:semicolon
id|ppp-&gt;tpkt_pos
op_assign
id|i
suffix:semicolon
id|ppp-&gt;tfcs
op_assign
id|fcs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush output from our internal buffers.&n; * Called for the TCFLSH ioctl.&n; */
r_static
r_void
DECL|function|ppp_tty_flush_output
id|ppp_tty_flush_output
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;xmt_q
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;optr
op_assign
id|ppp-&gt;olim
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tpkt
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|ppp-&gt;tpkt
)paren
suffix:semicolon
id|ppp-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;tty_pushing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
id|ppp_output_wakeup
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback function from tty driver. Return the amount of space left&n; * in the receiver&squot;s buffer to decide if remote transmitter is to be&n; * throttled.&n; */
r_static
r_int
DECL|function|ppp_tty_room
id|ppp_tty_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65536
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/*&n; * Callback function when data is available at the tty driver.&n; */
r_static
r_void
DECL|function|ppp_tty_receive
id|ppp_tty_receive
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|data
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_register
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|chr
comma
id|flg
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|0
)paren
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can happen if stuff comes in on the backup tty.&n;&t; */
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
op_logical_or
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the table pointer and ensure that the line is&n;&t; * still in PPP discipline.&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;PPP: tty_receive called but couldn&squot;t find &quot;
l_string|&quot;PPP struct.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Print the buffer if desired&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOG_RAWIN
)paren
id|ppp_print_buffer
(paren
l_string|&quot;receive buffer&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
id|ppp-&gt;stats.ppp_ibytes
op_add_assign
id|count
suffix:semicolon
id|skb
op_assign
id|ppp-&gt;rpkt
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_SYNC
)paren
(brace
multiline_comment|/* synchronous mode */
r_if
c_cond
(paren
id|ppp-&gt;toss
op_eq
l_int|0xE0
)paren
(brace
multiline_comment|/* this is the 1st frame, reset vj comp */
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Allocate an skbuff for frame.&n;&t;&t; * The 128 is room for VJ header expansion.&n;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ppp-&gt;mru
op_plus
l_int|128
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;couldn&squot;t &quot;
l_string|&quot;alloc skb for recv&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Decompress A/C and protocol compression here.&n;&t;&t;&t; */
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|p
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
r_if
c_cond
(paren
op_star
id|data
op_eq
id|PPP_ALLSTATIONS
)paren
(brace
id|data
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|data
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
id|p
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* copy frame to socket buffer */
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check if we&squot;ve overflowed the MRU&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
op_plus
l_int|2
op_logical_or
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_le
l_int|0
)paren
(brace
op_increment
id|ppp-&gt;estats.rx_length_errors
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;rcv frame too long: &quot;
l_string|&quot;len=%d mru=%d hroom=%d troom=%d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|ppp-&gt;mru
comma
id|skb_headroom
c_func
(paren
id|skb
)paren
comma
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|ppp_receive_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset for the next frame */
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ppp-&gt;rpkt
op_assign
id|skb
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Collect the character and error condition for the character.&n;&t;&t; * Set the toss flag for the first character error.&n;&t;&t; */
id|chr
op_assign
op_star
id|data
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
(brace
id|flg
op_assign
op_star
id|flags
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|flg
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;toss
op_eq
l_int|0
)paren
id|ppp-&gt;toss
op_assign
id|flg
suffix:semicolon
r_switch
c_cond
(paren
id|flg
)paren
(brace
r_case
id|TTY_OVERRUN
suffix:colon
op_increment
id|ppp-&gt;estats.rx_fifo_errors
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_FRAME
suffix:colon
r_case
id|TTY_BREAK
suffix:colon
op_increment
id|ppp-&gt;estats.rx_frame_errors
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Set the flags for d7 being 0/1 and parity being&n;&t;&t; * even/odd so that the normal processing would have&n;&t;&t; * all flags set at the end of the session.  A&n;&t;&t; * missing flag bit indicates an error condition.&n;&t;&t; */
macro_line|#ifdef CHECK_CHARACTERS
r_if
c_cond
(paren
id|chr
op_amp
l_int|0x80
)paren
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_B7_1
suffix:semicolon
r_else
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_B7_0
suffix:semicolon
r_if
c_cond
(paren
id|paritytab
(braket
id|chr
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|chr
op_amp
l_int|0x1F
)paren
)paren
)paren
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_ODDP
suffix:semicolon
r_else
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_EVNP
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|chr
op_eq
id|PPP_FLAG
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * FLAG. This is the end of the block. If the block&n;&t;&t;&t; * ends with ESC FLAG, then the block is to be ignored.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;escape
)paren
id|ppp-&gt;toss
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Process the frame if it was received correctly.&n;&t;&t;&t; * If there was an error, let the VJ decompressor know.&n;&t;&t;&t; * There are 4 cases here:&n;&t;&t;&t; * skb != NULL, toss != 0: error in frame&n;&t;&t;&t; * skb != NULL, toss == 0: frame ok&n;&t;&t;&t; * skb == NULL, toss != 0: very first frame,&n;&t;&t;&t; *&t;error on 1st char, or alloc_skb failed&n;&t;&t;&t; * skb == NULL, toss == 0: empty frame (~~)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;toss
op_logical_or
op_logical_neg
id|ppp_receive_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;toss
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: tossing frame (%x)&bslash;n&quot;
comma
id|ppp-&gt;toss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ppp-&gt;toss
op_eq
l_int|0xE0
op_logical_or
id|ppp-&gt;toss
op_eq
l_int|0x80
)paren
)paren
op_increment
id|ppp-&gt;stats.ppp_ierrors
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Reset for the next frame.&n;&t;&t;&t; */
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;rfcs
op_assign
id|PPP_INITFCS
suffix:semicolon
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re tossing, look no further. */
r_if
c_cond
(paren
id|ppp-&gt;toss
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* If this is a control char to be ignored, do so */
r_if
c_cond
(paren
id|in_rmap
c_func
(paren
id|ppp
comma
id|chr
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Modify the next character if preceded by escape.&n;&t;&t; * The escape character (0x7d) could be an escaped&n;&t;&t; * 0x5d, if it follows an escape :-)&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;escape
)paren
(brace
id|chr
op_xor_assign
id|PPP_TRANS
suffix:semicolon
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|chr
op_eq
id|PPP_ESCAPE
)paren
(brace
id|ppp-&gt;escape
op_assign
id|PPP_TRANS
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Allocate an skbuff on the first character received.&n;&t;&t; * The 128 is room for VJ header expansion and FCS.&n;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ppp-&gt;mru
op_plus
l_int|128
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;couldn&squot;t &quot;
l_string|&quot;alloc skb for recv&bslash;n&quot;
)paren
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Decompress A/C and protocol compression here.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
id|chr
op_ne
id|PPP_ALLSTATIONS
)paren
(brace
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|p
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|2
op_logical_and
(paren
id|chr
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
id|p
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check if we&squot;ve overflowed the MRU&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
op_plus
l_int|2
op_logical_or
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_le
l_int|0
)paren
(brace
op_increment
id|ppp-&gt;estats.rx_length_errors
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|0xC0
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;rcv frame too long: &quot;
l_string|&quot;len=%d mru=%d hroom=%d troom=%d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|ppp-&gt;mru
comma
id|skb_headroom
c_func
(paren
id|skb
)paren
comma
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Store the character and update the FCS.&n;&t;&t; */
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
op_star
id|p
op_assign
id|chr
suffix:semicolon
id|ppp-&gt;rfcs
op_assign
id|PPP_FCS
c_func
(paren
id|ppp-&gt;rfcs
comma
id|chr
)paren
suffix:semicolon
)brace
id|ppp-&gt;rpkt
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * PPP NETWORK INTERFACE SUPPORT&n; *&t;The following code implements the PPP network&n; *&t;interface device and handles those parts of&n; *&t;the PPP processing which are independent of the&n; *&t;type of hardware link being used, including&n; *&t;VJ and packet compression.&n; *************************************************************/
multiline_comment|/*&n; * Network device driver callback routines&n; */
r_static
r_int
id|ppp_init_dev
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_open
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_close
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
comma
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|ppp_dev_stats
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Information for the protocol decoder&n; */
DECL|typedef|pfn_proto
r_typedef
r_int
(paren
op_star
id|pfn_proto
)paren
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
DECL|struct|ppp_proto_struct
r_typedef
r_struct
id|ppp_proto_struct
(brace
DECL|member|proto
r_int
id|proto
suffix:semicolon
DECL|member|func
id|pfn_proto
id|func
suffix:semicolon
DECL|typedef|ppp_proto_type
)brace
id|ppp_proto_type
suffix:semicolon
r_static
r_int
id|rcv_proto_ip
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_ipv6
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_ipx
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_at
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_vjc_comp
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_vjc_uncomp
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_ccp
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_unknown
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
DECL|variable|proto_list
id|ppp_proto_type
id|proto_list
(braket
)braket
op_assign
(brace
(brace
id|PPP_IP
comma
id|rcv_proto_ip
)brace
comma
(brace
id|PPP_IPV6
comma
id|rcv_proto_ipv6
)brace
comma
(brace
id|PPP_IPX
comma
id|rcv_proto_ipx
)brace
comma
(brace
id|PPP_AT
comma
id|rcv_proto_at
)brace
comma
(brace
id|PPP_VJC_COMP
comma
id|rcv_proto_vjc_comp
)brace
comma
(brace
id|PPP_VJC_UNCOMP
comma
id|rcv_proto_vjc_uncomp
)brace
comma
(brace
id|PPP_CCP
comma
id|rcv_proto_ccp
)brace
comma
(brace
l_int|0
comma
id|rcv_proto_unknown
)brace
multiline_comment|/* !!! MUST BE LAST !!! */
)brace
suffix:semicolon
multiline_comment|/*&n; * Called when the PPP network interface device is actually created.&n; */
r_static
r_int
DECL|function|ppp_init_dev
id|ppp_init_dev
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;hard_header_len
op_assign
id|PPP_HDRLEN
suffix:semicolon
multiline_comment|/* device INFO */
id|dev-&gt;mtu
op_assign
id|PPP_MTU
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ppp_dev_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|ppp_dev_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|ppp_dev_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ppp_dev_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|ppp_dev_ioctl
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|10
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_PPP
suffix:semicolon
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
op_or
id|IFF_MULTICAST
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback from the network layer when the device goes up.&n; */
r_static
r_int
DECL|function|ppp_dev_open
id|ppp_dev_open
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;inuse
op_logical_or
id|ppp2tty
c_func
(paren
id|ppp
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: %s not active&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback from the network layer when the ppp device goes down.&n; */
r_static
r_int
DECL|function|ppp_dev_close
id|ppp_dev_close
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
id|CHECK_PPP_MAGIC
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|get_vj_stats
id|get_vj_stats
c_func
(paren
r_struct
id|vjstat
op_star
id|vj
comma
r_struct
id|slcompress
op_star
id|slc
)paren
(brace
id|vj-&gt;vjs_packets
op_assign
id|slc-&gt;sls_o_compressed
op_plus
id|slc-&gt;sls_o_uncompressed
suffix:semicolon
id|vj-&gt;vjs_compressed
op_assign
id|slc-&gt;sls_o_compressed
suffix:semicolon
id|vj-&gt;vjs_searches
op_assign
id|slc-&gt;sls_o_searches
suffix:semicolon
id|vj-&gt;vjs_misses
op_assign
id|slc-&gt;sls_o_misses
suffix:semicolon
id|vj-&gt;vjs_errorin
op_assign
id|slc-&gt;sls_i_error
suffix:semicolon
id|vj-&gt;vjs_tossed
op_assign
id|slc-&gt;sls_i_tossed
suffix:semicolon
id|vj-&gt;vjs_uncompressedin
op_assign
id|slc-&gt;sls_i_uncompressed
suffix:semicolon
id|vj-&gt;vjs_compressedin
op_assign
id|slc-&gt;sls_i_compressed
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback from the network layer to process the sockioctl functions.&n; */
r_static
r_int
DECL|function|ppp_dev_ioctl
id|ppp_dev_ioctl
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|nb
suffix:semicolon
r_union
(brace
r_struct
id|ppp_stats
id|stats
suffix:semicolon
r_struct
id|ppp_comp_stats
id|cstats
suffix:semicolon
r_char
id|vers
(braket
l_int|32
)braket
suffix:semicolon
)brace
id|u
suffix:semicolon
id|CHECK_PPP_MAGIC
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|u
comma
l_int|0
comma
r_sizeof
(paren
id|u
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGPPPSTATS
suffix:colon
id|u.stats.p
op_assign
id|ppp-&gt;stats
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_ne
l_int|NULL
)paren
id|get_vj_stats
c_func
(paren
op_amp
id|u.stats.vj
comma
id|ppp-&gt;slcomp
)paren
suffix:semicolon
id|nb
op_assign
r_sizeof
(paren
id|u.stats
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGPPPCSTATS
suffix:colon
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_stat
)paren
(paren
id|ppp-&gt;sc_xc_state
comma
op_amp
id|u.cstats.c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_stat
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
op_amp
id|u.cstats.d
)paren
suffix:semicolon
id|nb
op_assign
r_sizeof
(paren
id|u.cstats
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGPPPVER
suffix:colon
id|strcpy
c_func
(paren
id|u.vers
comma
id|szVersion
)paren
suffix:semicolon
id|nb
op_assign
id|strlen
c_func
(paren
id|u.vers
)paren
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|ifr-&gt;ifr_ifru.ifru_data
comma
op_amp
id|u
comma
id|nb
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the generic PPP ioctls, i.e. those which are not specific&n; * to any particular type of hardware link.&n; */
r_static
r_int
DECL|function|ppp_ioctl
id|ppp_ioctl
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_int
r_int
id|param2
comma
r_int
r_int
id|param3
)paren
(brace
r_register
r_int
id|temp_i
op_assign
l_int|0
comma
id|oldflags
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ppp_idle
id|cur_ddinfo
suffix:semicolon
r_struct
id|npioctl
id|npi
suffix:semicolon
id|CHECK_PPP
c_func
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The user must have an euid of root to do these requests.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|param2
)paren
(brace
r_case
id|PPPIOCSMRU
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the MRU value&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|temp_i
OL
id|PPP_MRU
)paren
id|temp_i
op_assign
id|PPP_MRU
suffix:semicolon
id|ppp-&gt;mru
op_assign
id|temp_i
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_ioctl: set mru to %x&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGFLAGS
suffix:colon
multiline_comment|/*&n;&t;&t; * Fetch the current flags&n;&t;&t; */
id|temp_i
op_assign
id|ppp-&gt;flags
op_amp
id|SC_MASK
suffix:semicolon
macro_line|#ifndef CHECK_CHARACTERS /* Don&squot;t generate errors if we don&squot;t check chars. */
id|temp_i
op_or_assign
id|SC_RCV_B7_1
op_or
id|SC_RCV_B7_0
op_or
id|SC_RCV_ODDP
op_or
id|SC_RCV_EVNP
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSFLAGS
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the flags for the various options&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
op_complement
id|temp_i
op_amp
id|SC_CCP_OPEN
)paren
id|ppp_ccp_closed
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oldflags
op_assign
id|ppp-&gt;flags
suffix:semicolon
id|temp_i
op_assign
(paren
id|temp_i
op_amp
id|SC_MASK
)paren
op_or
(paren
id|oldflags
op_amp
op_complement
id|SC_MASK
)paren
suffix:semicolon
id|ppp-&gt;flags
op_assign
id|temp_i
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldflags
op_or
id|temp_i
)paren
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_ioctl: set flags to %x&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSCOMPRESS
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the compression mode&n;&t;&t; */
id|error
op_assign
id|ppp_set_compression
(paren
id|ppp
comma
(paren
r_struct
id|ppp_option_data
op_star
)paren
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGUNIT
suffix:colon
multiline_comment|/*&n;&t;&t; * Obtain the unit number for this device.&n;&t;&t; */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp-&gt;line
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_ioctl: get unit: %d&bslash;n&quot;
comma
id|ppp-&gt;line
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSDEBUG
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the debug level&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|temp_i
op_assign
(paren
id|temp_i
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_or
id|temp_i
)paren
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_ioctl: set dbg flags to %x&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_assign
(paren
id|ppp-&gt;flags
op_amp
op_complement
l_int|0x1F0000
)paren
op_or
id|temp_i
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGDEBUG
suffix:colon
multiline_comment|/*&n;&t;&t; * Get the debug level&n;&t;&t; */
id|temp_i
op_assign
(paren
id|ppp-&gt;flags
op_rshift
l_int|16
)paren
op_amp
l_int|0x1F
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGIDLE
suffix:colon
multiline_comment|/*&n;&t;&t; * Get the times since the last send/receive frame operation&n;&t;&t; */
multiline_comment|/* change absolute times to relative times. */
id|cur_ddinfo.xmit_idle
op_assign
(paren
id|jiffies
op_minus
id|ppp-&gt;last_xmit
)paren
op_div
id|HZ
suffix:semicolon
id|cur_ddinfo.recv_idle
op_assign
(paren
id|jiffies
op_minus
id|ppp-&gt;last_recv
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param3
comma
op_amp
id|cur_ddinfo
comma
r_sizeof
(paren
id|cur_ddinfo
)paren
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMAXCID
suffix:colon
multiline_comment|/*&n;&t;&t; * Set the maximum VJ header compression slot number.&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|temp_i
template_param
l_int|255
)paren
r_break
suffix:semicolon
op_increment
id|temp_i
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ppp_ioctl: set maxcid to %d&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_ne
l_int|NULL
)paren
id|slhc_free
c_func
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
id|slhc_init
c_func
(paren
l_int|16
comma
id|temp_i
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: no memory for VJ compression&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGNPMODE
suffix:colon
r_case
id|PPPIOCSNPMODE
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|npi
comma
(paren
r_void
op_star
)paren
id|param3
comma
r_sizeof
(paren
id|npi
)paren
)paren
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
id|npi.protocol
)paren
(brace
r_case
id|PPP_IP
suffix:colon
id|npi.protocol
op_assign
id|NP_IP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPP_IPX
suffix:colon
id|npi.protocol
op_assign
id|NP_IPX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPP_AT
suffix:colon
id|npi.protocol
op_assign
id|NP_AT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pppioc[gs]npmode: &quot;
l_string|&quot;invalid proto %d&bslash;n&quot;
comma
id|npi.protocol
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|param2
op_eq
id|PPPIOCGNPMODE
)paren
(brace
id|npi.mode
op_assign
id|ppp-&gt;sc_npmode
(braket
id|npi.protocol
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param3
comma
op_amp
id|npi
comma
r_sizeof
(paren
id|npi
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|ppp-&gt;sc_npmode
(braket
id|npi.protocol
)braket
op_assign
id|npi.mode
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: set np %d to %d&bslash;n&quot;
comma
id|npi.protocol
comma
id|npi.mode
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; *  All other ioctl() events will come here.&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_ioctl: invalid ioctl: %x, addr %lx&bslash;n&quot;
comma
id|param2
comma
id|param3
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the set-compression ioctl.&n; */
r_static
r_int
DECL|function|ppp_set_compression
id|ppp_set_compression
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_option_data
op_star
id|odp
)paren
(brace
r_struct
id|compressor
op_star
id|cp
suffix:semicolon
r_int
id|error
comma
id|nb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u8
op_star
id|ptr
suffix:semicolon
id|__u8
id|ccp_option
(braket
id|CCP_MAX_OPTION_LENGTH
)braket
suffix:semicolon
r_struct
id|ppp_option_data
id|data
suffix:semicolon
multiline_comment|/*&n;&t; * Fetch the compression parameters&n;&t; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|data
comma
id|odp
comma
r_sizeof
(paren
id|data
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|nb
op_assign
id|data.length
suffix:semicolon
id|ptr
op_assign
id|data.ptr
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|nb
op_ge
id|CCP_MAX_OPTION_LENGTH
)paren
id|nb
op_assign
id|CCP_MAX_OPTION_LENGTH
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|ccp_option
comma
id|ptr
comma
id|nb
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ccp_option
(braket
l_int|1
)braket
OL
l_int|2
)paren
multiline_comment|/* preliminary check on the length byte */
r_goto
id|out
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|data.transmit
ques
c_cond
id|SC_COMP_RUN
suffix:colon
id|SC_DECOMP_RUN
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cp
op_assign
id|find_compressor
(paren
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
r_char
id|modname
(braket
l_int|32
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|modname
comma
l_string|&quot;ppp-compress-%d&quot;
comma
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|request_module
c_func
(paren
id|modname
)paren
suffix:semicolon
id|cp
op_assign
id|find_compressor
c_func
(paren
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KMOD */
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: no compressor for [%x %x %x], %x&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|ccp_option
(braket
l_int|0
)braket
comma
id|ccp_option
(braket
l_int|1
)braket
comma
id|ccp_option
(braket
l_int|2
)braket
comma
id|nb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/* compressor not loaded */
)brace
multiline_comment|/*&n;&t; * Found a handler for the protocol - try to allocate&n;&t; * a compressor or decompressor.&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data.transmit
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_free
)paren
(paren
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_xc_state
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;sc_xcomp
op_assign
id|cp
suffix:semicolon
id|ppp-&gt;sc_xc_state
op_assign
id|cp
op_member_access_from_pointer
id|comp_alloc
c_func
(paren
id|ccp_option
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: comp_alloc failed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_free
)paren
(paren
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;sc_rcomp
op_assign
id|cp
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
id|cp
op_member_access_from_pointer
id|decomp_alloc
c_func
(paren
id|ccp_option
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: decomp_alloc failed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle a CCP packet.&n; *&n; * The CCP packet is passed along to the pppd process just like any&n; * other PPP frame. The difference is that some processing needs to be&n; * immediate or the compressors will become confused on the peer.&n; */
DECL|function|ppp_proto_ccp
r_static
r_void
id|ppp_proto_ccp
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|dp
comma
r_int
id|len
comma
r_int
id|rcvd
)paren
(brace
r_int
id|slen
op_assign
id|CCP_LENGTH
c_func
(paren
id|dp
)paren
suffix:semicolon
id|__u8
op_star
id|opt
op_assign
id|dp
op_plus
id|CCP_HDRLEN
suffix:semicolon
r_int
id|opt_len
op_assign
id|slen
op_minus
id|CCP_HDRLEN
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|slen
OG
id|len
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp_proto_ccp rcvd=%d code=%x flags=%x&bslash;n&quot;
comma
id|rcvd
comma
id|CCP_CODE
c_func
(paren
id|dp
)paren
comma
id|ppp-&gt;flags
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|CCP_CODE
c_func
(paren
id|dp
)paren
)paren
(brace
r_case
id|CCP_CONFREQ
suffix:colon
r_case
id|CCP_TERMREQ
suffix:colon
r_case
id|CCP_TERMACK
suffix:colon
multiline_comment|/*&n;&t;&t; * CCP must be going down - disable compression&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_CCP_UP
op_or
id|SC_COMP_RUN
op_or
id|SC_DECOMP_RUN
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CCP_CONFACK
suffix:colon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_OPEN
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|slen
OL
(paren
id|CCP_HDRLEN
op_plus
id|CCP_OPT_MINLEN
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|slen
OL
(paren
id|CCP_OPT_LENGTH
(paren
id|opt
)paren
op_plus
id|CCP_HDRLEN
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcvd
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * we&squot;re agreeing to send compressed packets.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_init
)paren
(paren
id|ppp-&gt;sc_xc_state
comma
id|opt
comma
id|opt_len
comma
id|ppp-&gt;line
comma
l_int|0
comma
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: comp running&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_or_assign
id|SC_COMP_RUN
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * peer is agreeing to send compressed packets.&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_init
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
id|opt
comma
id|opt_len
comma
id|ppp-&gt;line
comma
l_int|0
comma
id|ppp-&gt;mru
comma
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: decomp running&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_or_assign
id|SC_DECOMP_RUN
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_DC_ERROR
op_or
id|SC_DC_FERROR
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CCP_RESETACK
suffix:colon
multiline_comment|/*&n;&t;&t; * CCP Reset-ack resets compressors and decompressors&n;&t;&t; * as it passes through.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcvd
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_RUN
)paren
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_reset
)paren
(paren
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: comp reset&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DECOMP_RUN
)paren
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_reset
)paren
(paren
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: decomp reset&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_DC_ERROR
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * CCP is down; free (de)compressor state if necessary.&n; */
r_static
r_void
DECL|function|ppp_ccp_closed
id|ppp_ccp_closed
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_CCP_OPEN
op_or
id|SC_CCP_UP
op_or
id|SC_COMP_RUN
op_or
id|SC_DECOMP_RUN
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: ccp closed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_free
)paren
(paren
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_xc_state
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_free
)paren
(paren
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*************************************************************&n; * RECEIVE-SIDE ROUTINES&n; *************************************************************/
multiline_comment|/*&n; * On entry, a received frame is in skb.&n; * Check it and dispose as appropriate.&n; */
r_static
r_int
DECL|function|ppp_receive_frame
id|ppp_receive_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__u8
op_star
id|data
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|proto
suffix:semicolon
r_int
id|new_count
suffix:semicolon
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
id|ppp_proto_type
op_star
id|proto_ptr
suffix:semicolon
multiline_comment|/*&n;&t; * An empty frame is ignored. This occurs if the FLAG sequence&n;&t; * precedes and follows each frame.&n;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t; * Generate an error if the frame is too small.&n;&t; */
r_if
c_cond
(paren
id|count
OL
id|PPP_HDRLEN
op_plus
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: got runt ppp frame, %d chars&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
op_increment
id|ppp-&gt;estats.rx_length_errors
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ppp-&gt;flags
op_amp
id|SC_SYNC
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Verify the FCS of the frame and discard the FCS characters&n;&t;&t; * from the end of the buffer.&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;rfcs
op_ne
id|PPP_GOODFCS
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: frame with bad fcs, length = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|ppp_print_buffer
c_func
(paren
l_string|&quot;bad frame&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
)brace
op_increment
id|ppp-&gt;estats.rx_crc_errors
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* ignore the fcs characters */
id|skb_trim
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Process the active decompressor.&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_ne
l_int|NULL
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DECOMP_RUN
)paren
op_logical_and
(paren
(paren
id|ppp-&gt;flags
op_amp
(paren
id|SC_DC_FERROR
op_or
id|SC_DC_ERROR
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
op_eq
id|PPP_COMP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the frame is compressed then decompress it.&n;&t;&t;&t; */
id|new_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ppp-&gt;mru
op_plus
l_int|128
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_recv_frame: no memory&bslash;n&quot;
)paren
suffix:semicolon
id|new_count
op_assign
id|DECOMP_ERROR
suffix:semicolon
)brace
r_else
(brace
id|new_count
op_assign
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decompress
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
id|data
comma
id|count
comma
id|new_skb-&gt;data
comma
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_count
OG
l_int|0
)paren
(brace
multiline_comment|/* Frame was decompressed OK */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|new_skb
suffix:semicolon
id|count
op_assign
id|new_count
suffix:semicolon
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * On a decompression error, we pass the&n;&t;&t;&t;&t; * compressed frame up to pppd as an&n;&t;&t;&t;&t; * error indication.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: decomp err %d&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|new_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|new_skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_ne
l_int|0
)paren
id|slhc_toss
c_func
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_ierrors
suffix:semicolon
r_if
c_cond
(paren
id|new_count
op_eq
id|DECOMP_FATALERROR
)paren
(brace
id|ppp-&gt;flags
op_or_assign
id|SC_DC_FERROR
suffix:semicolon
)brace
r_else
(brace
id|ppp-&gt;flags
op_or_assign
id|SC_DC_ERROR
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The frame is not compressed. Pass it to the&n;&t;&t;&t; * decompression code so it can update its&n;&t;&t;&t; * dictionary if necessary.&n;&t;&t;&t; */
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;incomp
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
id|data
comma
id|count
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
op_eq
id|PPP_COMP
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: not decomp, rc_state=%p flags=%x&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|ppp-&gt;sc_rc_state
comma
id|ppp-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Count the frame and print it&n;&t; */
op_increment
id|ppp-&gt;stats.ppp_ipackets
suffix:semicolon
id|ppp-&gt;stats.ppp_ioctects
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOG_INPKT
)paren
id|ppp_print_buffer
(paren
l_string|&quot;receive frame&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the procedure to handle this protocol.&n;&t; * The last one is marked as protocol 0 which is the &squot;catch-all&squot;&n;&t; * to feed it to the pppd daemon.&n;&t; */
id|proto
op_assign
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
suffix:semicolon
id|proto_ptr
op_assign
id|proto_list
suffix:semicolon
r_while
c_loop
(paren
id|proto_ptr-&gt;proto
op_ne
l_int|0
op_logical_and
id|proto_ptr-&gt;proto
op_ne
id|proto
)paren
op_increment
id|proto_ptr
suffix:semicolon
multiline_comment|/*&n;&t; * Update the appropriate statistic counter.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|proto_ptr-&gt;func
)paren
(paren
id|ppp
comma
id|skb
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_discards
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * An input error has been detected, so we need to inform&n; * the VJ decompressor.&n; */
r_static
r_void
DECL|function|ppp_receive_error
id|ppp_receive_error
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_ne
l_int|0
)paren
id|slhc_toss
c_func
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Put the input frame into the networking system for the indicated protocol&n; */
r_static
r_int
DECL|function|ppp_rcv_rx
id|ppp_rcv_rx
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/*&n;&t; * Fill in a few fields of the skb and give it to netif_rx().&n;&t; */
id|skb-&gt;dev
op_assign
id|ppp2dev
c_func
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/* We are the device */
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|proto
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|PPP_HDRLEN
)paren
suffix:semicolon
multiline_comment|/* pull off ppp header */
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|ppp-&gt;last_recv
op_assign
id|jiffies
suffix:semicolon
id|netif_rx
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an IP frame&n; */
r_static
r_int
DECL|function|rcv_proto_ip
id|rcv_proto_ip
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|skb-&gt;len
OG
l_int|0
)paren
op_logical_and
id|ppp-&gt;sc_npmode
(braket
id|NP_IP
)braket
op_eq
id|NPMODE_PASS
)paren
r_return
id|ppp_rcv_rx
c_func
(paren
id|ppp
comma
id|ETH_P_IP
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an IPv6 frame&n; */
r_static
r_int
DECL|function|rcv_proto_ipv6
id|rcv_proto_ipv6
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|skb-&gt;len
OG
l_int|0
)paren
op_logical_and
id|ppp-&gt;sc_npmode
(braket
id|NP_IPV6
)braket
op_eq
id|NPMODE_PASS
)paren
r_return
id|ppp_rcv_rx
c_func
(paren
id|ppp
comma
id|ETH_P_IPV6
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an IPX frame&n; */
r_static
r_int
DECL|function|rcv_proto_ipx
id|rcv_proto_ipx
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IFF_UP
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|skb-&gt;len
OG
l_int|0
)paren
op_logical_and
id|ppp-&gt;sc_npmode
(braket
id|NP_IPX
)braket
op_eq
id|NPMODE_PASS
)paren
r_return
id|ppp_rcv_rx
c_func
(paren
id|ppp
comma
id|ETH_P_IPX
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an Appletalk frame&n; */
r_static
r_int
DECL|function|rcv_proto_at
id|rcv_proto_at
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|skb-&gt;len
OG
l_int|0
)paren
op_logical_and
id|ppp-&gt;sc_npmode
(braket
id|NP_AT
)braket
op_eq
id|NPMODE_PASS
)paren
r_return
id|ppp_rcv_rx
c_func
(paren
id|ppp
comma
id|ETH_P_PPPTALK
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an VJ Compressed frame&n; */
r_static
r_int
DECL|function|rcv_proto_vjc_comp
id|rcv_proto_vjc_comp
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|new_count
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_REJ_COMP_TCP
)paren
op_logical_or
id|ppp-&gt;slcomp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|new_count
op_assign
id|slhc_uncompress
c_func
(paren
id|ppp-&gt;slcomp
comma
id|skb-&gt;data
op_plus
id|PPP_HDRLEN
comma
id|skb-&gt;len
op_minus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_count
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ppp: error in VJ decompression&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|new_count
op_add_assign
id|PPP_HDRLEN
suffix:semicolon
r_if
c_cond
(paren
id|new_count
OG
id|skb-&gt;len
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|new_count
op_minus
id|skb-&gt;len
)paren
suffix:semicolon
r_else
id|skb_trim
c_func
(paren
id|skb
comma
id|new_count
)paren
suffix:semicolon
r_return
id|rcv_proto_ip
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an VJ Un-compressed frame&n; */
r_static
r_int
DECL|function|rcv_proto_vjc_uncomp
id|rcv_proto_vjc_uncomp
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_REJ_COMP_TCP
)paren
op_logical_or
id|ppp-&gt;slcomp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|slhc_remember
c_func
(paren
id|ppp-&gt;slcomp
comma
id|skb-&gt;data
op_plus
id|PPP_HDRLEN
comma
id|skb-&gt;len
op_minus
id|PPP_HDRLEN
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ppp: error in VJ memorizing&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|rcv_proto_ip
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|rcv_proto_ccp
id|rcv_proto_ccp
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ppp_proto_ccp
(paren
id|ppp
comma
id|skb-&gt;data
op_plus
id|PPP_HDRLEN
comma
id|skb-&gt;len
op_minus
id|PPP_HDRLEN
comma
l_int|1
)paren
suffix:semicolon
r_return
id|rcv_proto_unknown
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive all unclassified protocols.&n; */
r_static
r_int
DECL|function|rcv_proto_unknown
id|rcv_proto_unknown
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Limit queue length by dropping old frames.&n;&t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
comma
id|skb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ppp-&gt;rcv_q.qlen
OG
id|PPP_MAX_RCV_QLEN
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tty-&gt;fasync
op_ne
l_int|NULL
)paren
id|kill_fasync
(paren
id|ppp-&gt;tty-&gt;fasync
comma
id|SIGIO
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * TRANSMIT-SIDE ROUTINES&n; *************************************************************/
multiline_comment|/* local function to store a value into the LQR frame */
DECL|function|store_long
r_extern
r_inline
id|__u8
op_star
id|store_long
(paren
r_register
id|__u8
op_star
id|p
comma
r_register
r_int
id|value
)paren
(brace
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
(paren
id|value
op_rshift
l_int|24
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
(paren
id|value
op_rshift
l_int|16
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
(paren
id|value
op_rshift
l_int|8
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
id|value
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * Compress and send an frame to the peer.&n; * Should be called with xmit_busy == 1, having been set by the caller.&n; * That is, we use xmit_busy as a lock to prevent reentry of this&n; * procedure.&n; */
r_static
r_void
DECL|function|ppp_send_frame
id|ppp_send_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|proto
suffix:semicolon
id|__u8
op_star
id|data
suffix:semicolon
r_int
id|count
suffix:semicolon
id|__u8
op_star
id|p
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* dump the buffer */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOG_OUTPKT
)paren
id|ppp_print_buffer
(paren
l_string|&quot;write frame&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Handle various types of protocol-specific compression&n;&t; * and other processing, including:&n;&t; * - VJ TCP header compression&n;&t; * - updating LQR packets&n;&t; * - updating CCP state on CCP packets&n;&t; */
id|proto
op_assign
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|PPP_IP
suffix:colon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_TCP
)paren
op_logical_and
id|ppp-&gt;slcomp
op_ne
l_int|NULL
)paren
id|skb
op_assign
id|ppp_vj_compress
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPP_LQR
suffix:colon
multiline_comment|/*&n;&t;&t; * Update the LQR frame with the current MIB information.&n;&t;&t; * This way the information is accurate and up-to-date.&n;&t;&t; */
r_if
c_cond
(paren
id|count
OL
l_int|48
)paren
r_break
suffix:semicolon
id|p
op_assign
id|data
op_plus
l_int|40
suffix:semicolon
multiline_comment|/* Point to last two items. */
id|p
op_assign
id|store_long
c_func
(paren
id|p
comma
id|ppp-&gt;stats.ppp_opackets
op_plus
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|store_long
c_func
(paren
id|p
comma
id|ppp-&gt;stats.ppp_ooctects
op_plus
id|count
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_olqrs
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPP_CCP
suffix:colon
multiline_comment|/*&n;&t;&t; * Outbound compression control frames&n;&t;&t; */
id|ppp_proto_ccp
c_func
(paren
id|ppp
comma
id|data
op_plus
id|PPP_HDRLEN
comma
id|count
op_minus
id|PPP_HDRLEN
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t; * Compress the whole frame if possible.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_RUN
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ppp-&gt;sc_xc_state
op_ne
(paren
r_void
op_star
)paren
l_int|0
)paren
op_logical_and
(paren
id|proto
op_ne
id|PPP_LCP
)paren
op_logical_and
(paren
id|proto
op_ne
id|PPP_CCP
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
r_int
id|new_count
suffix:semicolon
multiline_comment|/* Allocate an skb for the compressed frame. */
id|new_skb
op_assign
id|alloc_skb
c_func
(paren
id|ppp-&gt;mtu
op_plus
id|PPP_HDRLEN
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_send_frame: no memory&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;xmit_busy
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Compress the frame. */
id|new_count
op_assign
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;compress
)paren
(paren
id|ppp-&gt;sc_xc_state
comma
id|data
comma
id|new_skb-&gt;data
comma
id|count
comma
id|ppp-&gt;mtu
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
multiline_comment|/* Did it compress? */
r_if
c_cond
(paren
id|new_count
OG
l_int|0
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
)paren
(brace
id|skb_put
c_func
(paren
id|new_skb
comma
id|new_count
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|new_skb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The frame could not be compressed, or it could not&n;&t;&t;&t; * be sent in compressed form because CCP is down.&n;&t;&t;&t; */
id|kfree_skb
c_func
(paren
id|new_skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Send the frame&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_SYNC
)paren
id|ret
op_assign
id|ppp_sync_send
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|ppp_async_send
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
(brace
multiline_comment|/* we can release the lock */
id|ppp-&gt;xmit_busy
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* can&squot;t happen, since the caller got the xmit_busy lock */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: ppp_async_send didn&squot;t accept pkt&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Apply VJ TCP header compression to a packet.&n; */
r_static
r_struct
id|sk_buff
op_star
DECL|function|ppp_vj_compress
id|ppp_vj_compress
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__u8
op_star
id|orig_data
comma
op_star
id|data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
r_int
id|len
comma
id|proto
suffix:semicolon
id|new_skb
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: no memory for vj compression&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
id|orig_data
op_assign
id|data
op_assign
id|skb-&gt;data
op_plus
id|PPP_HDRLEN
suffix:semicolon
id|len
op_assign
id|slhc_compress
c_func
(paren
id|ppp-&gt;slcomp
comma
id|data
comma
id|skb-&gt;len
op_minus
id|PPP_HDRLEN
comma
id|new_skb-&gt;data
op_plus
id|PPP_HDRLEN
comma
op_amp
id|data
comma
(paren
id|ppp-&gt;flags
op_amp
id|SC_NO_TCP_CCID
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|orig_data
)paren
(brace
multiline_comment|/* Couldn&squot;t compress the data */
id|kfree_skb
c_func
(paren
id|new_skb
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/* The data has been changed */
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_amp
id|SL_TYPE_COMPRESSED_TCP
)paren
(brace
id|proto
op_assign
id|PPP_VJC_COMP
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_xor_assign
id|SL_TYPE_COMPRESSED_TCP
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_ge
id|SL_TYPE_UNCOMPRESSED_TCP
)paren
id|proto
op_assign
id|PPP_VJC_UNCOMP
suffix:semicolon
r_else
id|proto
op_assign
id|PPP_IP
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|orig_data
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|data
op_assign
id|skb_put
c_func
(paren
id|new_skb
comma
id|len
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|proto
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|new_skb
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|ppp_send_frames
id|ppp_send_frames
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;xmit_busy
)paren
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;xmt_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|ppp-&gt;xmit_busy
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ppp_send_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;xmit_busy
op_logical_and
id|ppp-&gt;dev.tbusy
)paren
(brace
id|ppp-&gt;dev.tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Called from the hardware (tty) layer when it can accept&n; * another packet.&n; */
r_static
r_void
DECL|function|ppp_output_wakeup
id|ppp_output_wakeup
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;xmit_busy
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_output_wakeup called but xmit_busy==0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ppp-&gt;xmit_busy
op_assign
l_int|0
suffix:semicolon
id|ppp_send_frames
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a control frame (from pppd).&n; */
r_static
r_void
DECL|function|ppp_send_ctrl
id|ppp_send_ctrl
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put the packet on the queue, then send as many as we can.&n;&t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|ppp-&gt;xmt_q
comma
id|skb
)paren
suffix:semicolon
id|ppp_send_frames
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * NETWORK OUTPUT&n; *    This routine accepts requests from the network layer&n; *    and attempts to deliver the packets.&n; *************************************************************/
multiline_comment|/*&n; * Send a frame to the peer.&n; * Returns 1 iff the frame was not accepted.&n; */
r_static
r_int
DECL|function|ppp_dev_xmit
id|ppp_dev_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ppp2tty
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_enum
id|NPmode
id|npmode
suffix:semicolon
r_int
id|proto
suffix:semicolon
r_int
r_char
op_star
id|hdr
suffix:semicolon
multiline_comment|/* just a little sanity check. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Avoid timing problem should tty hangup while data is&n;&t; * queued to be sent.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;inuse
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Validate the tty interface&n;&t; */
r_if
c_cond
(paren
id|tty
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_dev_xmit: %s not connected to a TTY!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Work out the appropriate network-protocol mode for this packet.&n;&t; */
id|npmode
op_assign
id|NPMODE_PASS
suffix:semicolon
multiline_comment|/* default */
r_switch
c_cond
(paren
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
)paren
(brace
r_case
id|ETH_P_IP
suffix:colon
id|proto
op_assign
id|PPP_IP
suffix:semicolon
id|npmode
op_assign
id|ppp-&gt;sc_npmode
(braket
id|NP_IP
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_IPV6
suffix:colon
id|proto
op_assign
id|PPP_IPV6
suffix:semicolon
id|npmode
op_assign
id|ppp-&gt;sc_npmode
(braket
id|NP_IPV6
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_IPX
suffix:colon
id|proto
op_assign
id|PPP_IPX
suffix:semicolon
id|npmode
op_assign
id|ppp-&gt;sc_npmode
(braket
id|NP_IPX
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_PPPTALK
suffix:colon
r_case
id|ETH_P_ATALK
suffix:colon
id|proto
op_assign
id|PPP_AT
suffix:semicolon
id|npmode
op_assign
id|ppp-&gt;sc_npmode
(braket
id|NP_AT
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: packet for unknown proto %x&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Drop, accept or reject the packet depending on the mode.&n;&t; */
r_switch
c_cond
(paren
id|npmode
)paren
(brace
r_case
id|NPMODE_PASS
suffix:colon
r_break
suffix:semicolon
r_case
id|NPMODE_QUEUE
suffix:colon
multiline_comment|/*&n;&t;&t; * We may not send the packet now, so drop it.&n;&t;&t; * XXX It would be nice to be able to return it to the&n;&t;&t; * network system to be queued and retransmitted later.&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: returning frame&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|NPMODE_ERROR
suffix:colon
r_case
id|NPMODE_DROP
suffix:colon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp_dev_xmit: dropping (npmode = %d) on %s&bslash;n&quot;
comma
id|npmode
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The dev-&gt;tbusy field acts as a lock to allow only&n;&t; * one packet to be processed at a time.  If we can&squot;t&n;&t; * get the lock, try again later.&n;&t; * We deliberately queue as little as possible inside&n;&t; * the ppp driver in order to minimize the latency&n;&t; * for high-priority packets.&n;&t; */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;xmit_busy
)paren
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* can&squot;t take it now */
r_return
l_int|1
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Put the 4-byte PPP header on the packet.&n;&t; * If there isn&squot;t room for it, we have to copy the packet.&n;&t; */
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|PPP_HDRLEN
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
id|new_skb
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
id|PPP_HDRLEN
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: skb hdr alloc failed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;xmit_busy
op_assign
l_int|0
suffix:semicolon
id|ppp_send_frames
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|new_skb
comma
id|PPP_HDRLEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|new_skb
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|new_skb
suffix:semicolon
)brace
id|hdr
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|PPP_HDRLEN
)paren
suffix:semicolon
id|hdr
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|hdr
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
id|hdr
(braket
l_int|2
)braket
op_assign
id|proto
op_rshift
l_int|8
suffix:semicolon
id|hdr
(braket
l_int|3
)braket
op_assign
id|proto
suffix:semicolon
id|ppp_send_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;xmit_busy
)paren
id|ppp_send_frames
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate the statistic information for the /proc/net/dev listing.&n; */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|ppp_dev_stats
id|ppp_dev_stats
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
id|ppp-&gt;estats.rx_packets
op_assign
id|ppp-&gt;stats.ppp_ipackets
suffix:semicolon
id|ppp-&gt;estats.rx_errors
op_assign
id|ppp-&gt;stats.ppp_ierrors
suffix:semicolon
id|ppp-&gt;estats.tx_packets
op_assign
id|ppp-&gt;stats.ppp_opackets
suffix:semicolon
id|ppp-&gt;estats.tx_errors
op_assign
id|ppp-&gt;stats.ppp_oerrors
suffix:semicolon
id|ppp-&gt;estats.rx_bytes
op_assign
id|ppp-&gt;stats.ppp_ibytes
suffix:semicolon
id|ppp-&gt;estats.tx_bytes
op_assign
id|ppp-&gt;stats.ppp_obytes
suffix:semicolon
r_return
op_amp
id|ppp-&gt;estats
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * UTILITIES&n; *    Miscellany called by various functions above.&n; *************************************************************/
multiline_comment|/* Locate the previous instance of the PPP channel */
r_static
r_struct
id|ppp
op_star
DECL|function|ppp_find
id|ppp_find
c_func
(paren
r_int
id|pid_value
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
multiline_comment|/* try to find the device which this pid is already using */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;inuse
op_logical_and
id|ppp-&gt;sc_xfer
op_eq
id|pid_value
)paren
(brace
id|ppp-&gt;sc_xfer
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ppp
suffix:semicolon
)brace
multiline_comment|/* allocate or create a PPP channel */
r_static
r_struct
id|ppp
op_star
DECL|function|ppp_alloc
id|ppp_alloc
c_func
(paren
r_void
)paren
(brace
r_int
id|if_num
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
multiline_comment|/* try to find an free device */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;inuse
)paren
)paren
(brace
id|dev
op_assign
id|ppp2dev
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;inuse
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Reregister device */
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
r_return
id|ppp
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;could not reregister ppp device&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* leave inuse set in this case */
)brace
)brace
multiline_comment|/*&n;&t; * There are no available units, so make a new one.&n;&t; */
id|ppp
op_assign
(paren
r_struct
id|ppp
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ppp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: struct ppp allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ppp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ppp
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize channel control data */
id|ppp-&gt;magic
op_assign
id|PPP_MAGIC
suffix:semicolon
id|ppp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make up a suitable name for this device&n;&t; */
id|dev
op_assign
id|ppp2dev
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|dev-&gt;name
op_assign
id|ppp-&gt;name
suffix:semicolon
id|if_num
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
l_string|&quot;ppp%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|if_num
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: dev_alloc_name failed (%d)&bslash;n&quot;
comma
id|if_num
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ppp-&gt;line
op_assign
id|if_num
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;init
op_assign
id|ppp_init_dev
suffix:semicolon
id|dev-&gt;name
op_assign
id|ppp-&gt;name
suffix:semicolon
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|ppp
suffix:semicolon
multiline_comment|/* register device so that we can be ifconfig&squot;d */
multiline_comment|/* ppp_init_dev() will be called as a side-effect */
id|status
op_assign
id|register_netdev
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;registered device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_alloc - register_netdev(%s) = %d failure.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* link this unit into our list */
r_if
c_cond
(paren
id|ppp_list
op_eq
l_int|0
)paren
id|ppp_list
op_assign
id|ppp
suffix:semicolon
r_else
id|ppp_last-&gt;next
op_assign
id|ppp
suffix:semicolon
id|ppp_last
op_assign
id|ppp
suffix:semicolon
r_return
id|ppp
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the generic parts of the ppp structure.&n; */
r_static
r_void
DECL|function|ppp_generic_init
id|ppp_generic_init
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_int
id|indx
suffix:semicolon
id|ppp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;mtu
op_assign
id|PPP_MTU
suffix:semicolon
id|ppp-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ppp-&gt;xmt_q
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
suffix:semicolon
id|ppp-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
id|ppp-&gt;last_recv
op_assign
id|jiffies
suffix:semicolon
id|ppp-&gt;xmit_busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear statistics */
id|memset
c_func
(paren
op_amp
id|ppp-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pppstat
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ppp-&gt;estats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
multiline_comment|/* PPP compression data */
id|ppp-&gt;sc_xc_state
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|indx
op_assign
l_int|0
suffix:semicolon
id|indx
OL
id|NUM_NP
suffix:semicolon
op_increment
id|indx
)paren
id|ppp-&gt;sc_npmode
(braket
id|indx
)braket
op_assign
id|NPMODE_PASS
suffix:semicolon
)brace
multiline_comment|/*&n; * Called to clean up the generic parts of the ppp structure.&n; */
r_static
r_void
DECL|function|ppp_release
id|ppp_release
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|CHECK_PPP_MAGIC
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s released&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|ppp_ccp_closed
c_func
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/* Ensure that the pppd process is not hanging on select()/poll() */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
)paren
(brace
id|slhc_free
c_func
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;rcv_q
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;xmt_q
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;inuse
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;dev.tbusy
)paren
(brace
id|ppp-&gt;dev.tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Utility procedures to print a buffer in hex/ascii&n; */
r_static
r_void
DECL|function|ppp_print_hex
id|ppp_print_hex
(paren
r_register
id|__u8
op_star
id|out
comma
r_const
id|__u8
op_star
id|in
comma
r_int
id|count
)paren
(brace
r_register
id|__u8
id|next_ch
suffix:semicolon
r_static
r_char
id|hex
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|next_ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|hex
(braket
(paren
id|next_ch
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)braket
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|hex
(braket
id|next_ch
op_amp
l_int|0x0F
)braket
suffix:semicolon
op_increment
id|out
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ppp_print_char
id|ppp_print_char
(paren
r_register
id|__u8
op_star
id|out
comma
r_const
id|__u8
op_star
id|in
comma
r_int
id|count
)paren
(brace
r_register
id|__u8
id|next_ch
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|next_ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|next_ch
template_param
l_int|0x7e
)paren
op_star
id|out
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
r_else
(brace
op_star
id|out
op_increment
op_assign
id|next_ch
suffix:semicolon
r_if
c_cond
(paren
id|next_ch
op_eq
l_char|&squot;%&squot;
)paren
multiline_comment|/* printk/syslogd has a bug !! */
op_star
id|out
op_increment
op_assign
l_char|&squot;%&squot;
suffix:semicolon
)brace
)brace
op_star
id|out
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_print_buffer
id|ppp_print_buffer
(paren
r_const
r_char
op_star
id|name
comma
r_const
id|__u8
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|__u8
id|line
(braket
l_int|44
)braket
suffix:semicolon
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: %s, count = %d&bslash;n&quot;
comma
id|name
comma
id|count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|8
)paren
(brace
id|memset
(paren
id|line
comma
l_int|32
comma
l_int|44
)paren
suffix:semicolon
id|ppp_print_hex
(paren
id|line
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
id|ppp_print_char
(paren
op_amp
id|line
(braket
l_int|8
op_star
l_int|3
)braket
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
id|count
op_sub_assign
l_int|8
suffix:semicolon
id|buf
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|memset
(paren
id|line
comma
l_int|32
comma
l_int|44
)paren
suffix:semicolon
id|ppp_print_hex
(paren
id|line
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|ppp_print_char
(paren
op_amp
id|line
(braket
l_int|8
op_star
l_int|3
)braket
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*************************************************************&n; * Compressor module interface&n; *************************************************************/
DECL|struct|compressor_link
r_struct
id|compressor_link
(brace
DECL|member|next
r_struct
id|compressor_link
op_star
id|next
suffix:semicolon
DECL|member|comp
r_struct
id|compressor
op_star
id|comp
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ppp_compressors
r_static
r_struct
id|compressor_link
op_star
id|ppp_compressors
op_assign
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
suffix:semicolon
DECL|function|find_compressor
r_static
r_struct
id|compressor
op_star
id|find_compressor
(paren
r_int
id|type
)paren
(brace
r_struct
id|compressor_link
op_star
id|lnk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|lnk
op_assign
id|ppp_compressors
suffix:semicolon
r_while
c_loop
(paren
id|lnk
op_ne
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|__u8
)paren
id|lnk-&gt;comp-&gt;compress_proto
op_eq
id|type
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|lnk-&gt;comp
suffix:semicolon
)brace
id|lnk
op_assign
id|lnk-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
r_struct
id|compressor
op_star
)paren
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODULES
DECL|function|ppp_register_compressor
r_static
r_int
id|ppp_register_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
(brace
r_struct
id|compressor_link
op_star
r_new
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|compressor_link
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|compressor_link
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_compressor
(paren
id|cp-&gt;compress_proto
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|next
op_assign
id|ppp_compressors
suffix:semicolon
r_new
op_member_access_from_pointer
id|comp
op_assign
id|cp
suffix:semicolon
id|ppp_compressors
op_assign
r_new
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppp_unregister_compressor
r_static
r_void
id|ppp_unregister_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
(brace
r_struct
id|compressor_link
op_star
id|prev
op_assign
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
suffix:semicolon
r_struct
id|compressor_link
op_star
id|lnk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|lnk
op_assign
id|ppp_compressors
suffix:semicolon
r_while
c_loop
(paren
id|lnk
op_ne
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lnk-&gt;comp
op_eq
id|cp
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|lnk-&gt;next
suffix:semicolon
r_else
id|ppp_compressors
op_assign
id|lnk-&gt;next
suffix:semicolon
id|kfree
(paren
id|lnk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|lnk
suffix:semicolon
id|lnk
op_assign
id|lnk-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*************************************************************&n; * Module support routines&n; *************************************************************/
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* register our line disciplines */
id|status
op_assign
id|ppp_first_time
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PPP: ppp_init() failure %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
comma
op_star
id|next_ppp
suffix:semicolon
r_int
id|busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the devices are not in operation.&n;&t; */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
id|CHECK_PPP_MAGIC
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;inuse
op_logical_or
(paren
id|ppp-&gt;dev.flags
op_amp
id|IFF_UP
)paren
)paren
op_increment
id|busy
suffix:semicolon
)brace
r_if
c_cond
(paren
id|busy
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;PPP: removing despite %d units in use!&bslash;n&quot;
comma
id|busy
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Release the tty registration of the line discipline so that&n;&t; * ttys can no longer be put into PPP line discipline.&n;&t; */
id|status
op_assign
id|tty_register_ldisc
(paren
id|N_PPP
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: Unable to unregister ppp line discipline &quot;
l_string|&quot;(err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PPP: ppp line discipline successfully unregistered&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * De-register the devices so that there is no problem with them&n;&t; */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|next_ppp
)paren
(brace
id|next_ppp
op_assign
id|ppp-&gt;next
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|ppp-&gt;dev
)paren
suffix:semicolon
id|kfree
(paren
id|ppp
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
