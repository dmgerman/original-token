multiline_comment|/*  PPP for Linux&n; *&n; *  Michael Callahan &lt;callahan@maths.ox.ac.uk&gt;&n; *  Al Longyear &lt;longyear@netcom.com&gt;&n; *  Paul Mackerras &lt;Paul.Mackerras@cs.anu.edu.au&gt;&n; *  Cyrus Durgin &lt;cider@speakeasy.org&gt; (changes for kmod)&n; *&n; *  Dynamic PPP devices by Jim Freeman &lt;jfree@caldera.com&gt;.&n; *  ppp_tty_receive ``noisy-raise-bug&squot;&squot; fixed by Ove Ewerlid &lt;ewerlid@syscon.uu.se&gt;&n; *&n; *  ==FILEVERSION 980319==&n; *&n; *  NOTE TO MAINTAINERS:&n; *     If you modify this file at all, please set the number above to the&n; *     date of the modification as YYMMDD (year month day).&n; *     ppp.c is shipped with a PPP distribution as well as with the kernel;&n; *     if everyone increases the FILEVERSION number above, then scripts&n; *     can do the right thing when deciding whether to install a new ppp.c&n; *     file.  Don&squot;t change the format of that line otherwise, so the&n; *     installation script can recognize it.&n; */
multiline_comment|/*&n;   Sources:&n;&n;   slip.c&n;&n;   RFC1331: The Point-to-Point Protocol (PPP) for the Transmission of&n;   Multi-protocol Datagrams over Point-to-Point Links&n;&n;   RFC1332: IPCP&n;&n;   ppp-2.0&n;&n;   Flags for this module (any combination is acceptable for testing.):&n;&n;   OPTIMIZE_FLAG_TIME - Number of jiffies to force sending of leading flag&n;&t;&t;&t;character. This is normally set to ((HZ * 3) / 2).&n;&t;&t;&t;This is 1.5 seconds. If zero then the leading&n;&t;&t;&t;flag is always sent.&n;&n;   CHECK_CHARACTERS   - Enable the checking on all received characters for&n;&t;&t;&t;8 data bits, no parity. This adds a small amount of&n;&t;&t;&t;processing for each received character.&n;*/
DECL|macro|OPTIMIZE_FLAG_TIME
mdefine_line|#define OPTIMIZE_FLAG_TIME&t;((HZ * 3)/2)
DECL|macro|CHECK_CHARACTERS
mdefine_line|#define CHECK_CHARACTERS&t;1
DECL|macro|PPP_COMPRESS
mdefine_line|#define PPP_COMPRESS&t;&t;1
multiline_comment|/* $Id: ppp.c,v 1.14 1997/11/27 06:04:45 paulus Exp $ */
macro_line|#include &lt;linux/config.h&gt; /* for CONFIG_KMOD */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;&t;/* to get the struct task_struct */
macro_line|#include &lt;linux/string.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;linux/signal.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|typedef|sk_buff
r_typedef
r_struct
id|sk_buff
id|sk_buff
suffix:semicolon
DECL|macro|skb_data
mdefine_line|#define skb_data(skb)&t;     ((__u8 *) (skb)-&gt;data)
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;net/slhc_vj.h&gt;
DECL|macro|fcstab
mdefine_line|#define fcstab&t;ppp_crc16_table&t;&t;/* Name of the table in the kernel */
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/if_ppp.h&gt;
macro_line|#include &lt;linux/if_pppvar.h&gt;
macro_line|#include &lt;linux/ppp-comp.h&gt;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
macro_line|#ifndef PPP_IPX
DECL|macro|PPP_IPX
mdefine_line|#define PPP_IPX 0x2b  /* IPX protocol over PPP */
macro_line|#endif
macro_line|#ifndef PPP_LQR
DECL|macro|PPP_LQR
mdefine_line|#define PPP_LQR 0xc025&t;/* Link Quality Reporting Protocol */
macro_line|#endif
r_static
r_int
id|ppp_register_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ppp_unregister_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n; * Local functions&n; */
r_static
r_struct
id|compressor
op_star
id|find_compressor
(paren
r_int
id|type
)paren
suffix:semicolon
r_static
r_void
id|ppp_init_ctrl_blk
(paren
r_register
r_struct
id|ppp
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppp_kick_tty
(paren
r_struct
id|ppp
op_star
comma
r_struct
id|ppp_buffer
op_star
id|bfr
)paren
suffix:semicolon
r_static
r_struct
id|ppp
op_star
id|ppp_alloc
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|ppp
op_star
id|ppp_find
(paren
r_int
id|pid_value
)paren
suffix:semicolon
r_static
r_void
id|ppp_print_buffer
(paren
r_const
id|__u8
op_star
comma
r_const
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_inline
r_void
id|ppp_stuff_char
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_register
r_struct
id|ppp_buffer
op_star
id|buf
comma
r_register
id|__u8
id|chr
)paren
suffix:semicolon
r_extern
r_inline
r_int
id|lock_buffer
(paren
r_register
r_struct
id|ppp_buffer
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_xmit_ip
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_buffer
op_star
id|buf
comma
id|__u8
op_star
id|data
comma
r_int
id|len
comma
r_enum
id|NPmode
id|npmode
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_ip
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_ipx
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_vjc_comp
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_vjc_uncomp
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_unknown
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_lqr
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|ppp_doframe_lower
(paren
r_struct
id|ppp
op_star
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|ppp_doframe
(paren
r_struct
id|ppp
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppp_proto_ccp
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|dp
comma
r_int
id|len
comma
r_int
id|rcvd
)paren
suffix:semicolon
r_static
r_int
id|rcv_proto_ccp
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
DECL|macro|ins_char
mdefine_line|#define ins_char(pbuf,c) (buf_base(pbuf) [(pbuf)-&gt;count++] = (__u8)(c))
macro_line|#ifndef OPTIMIZE_FLAG_TIME
DECL|macro|OPTIMIZE_FLAG_TIME
mdefine_line|#define OPTIMIZE_FLAG_TIME&t;0
macro_line|#endif
multiline_comment|/*&n; * Parameters which may be changed via insmod.&n; */
DECL|variable|flag_time
r_static
r_int
id|flag_time
op_assign
id|OPTIMIZE_FLAG_TIME
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flag_time
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * The &quot;main&quot; procedure to the ppp device&n; */
r_int
id|ppp_init
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Network device driver callback routines&n; */
r_static
r_int
id|ppp_dev_open
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_ioctl
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_close
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_dev_xmit
(paren
id|sk_buff
op_star
comma
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|ppp_dev_stats
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * TTY callbacks&n; */
r_static
id|ssize_t
id|ppp_tty_read
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
id|ssize_t
id|ppp_tty_write
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_const
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_ioctl
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|ppp_tty_poll
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_open
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_close
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_tty_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_receive
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|ppp_tty_wakeup
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|macro|CHECK_PPP_MAGIC
mdefine_line|#define CHECK_PPP_MAGIC(ppp)&t;do { &bslash;&n;&t;if (ppp-&gt;magic != PPP_MAGIC) { &bslash;&n;&t;&t;printk(KERN_WARNING &quot;bad magic for ppp %p at %s:%d&bslash;n&quot;, &bslash;&n;&t;&t;       ppp, __FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;} while (0)
DECL|macro|CHECK_PPP
mdefine_line|#define CHECK_PPP(a)&t;do { &bslash;&n;&t;CHECK_PPP_MAGIC(ppp); &bslash;&n;&t;if (!ppp-&gt;inuse) { &bslash;&n;&t;&t;printk (ppp_warning, __LINE__); &bslash;&n;&t;&t;return a; &bslash;&n;&t;} &bslash;&n;} while (0)
DECL|macro|CHECK_PPP_VOID
mdefine_line|#define CHECK_PPP_VOID() do { &bslash;&n;&t;CHECK_PPP_MAGIC(ppp); &bslash;&n;&t;if (!ppp-&gt;inuse) { &bslash;&n;&t;&t;printk (ppp_warning, __LINE__); &bslash;&n;&t;} &bslash;&n;} while (0)
DECL|macro|in_xmap
mdefine_line|#define in_xmap(ppp,c)&t;(ppp-&gt;xmit_async_map[(c) &gt;&gt; 5] &amp; (1 &lt;&lt; ((c) &amp; 0x1f)))
DECL|macro|in_rmap
mdefine_line|#define in_rmap(ppp,c)&t;((((unsigned int) (__u8) (c)) &lt; 0x20) &amp;&amp; &bslash;&n;&t;&t;&t;ppp-&gt;recv_async_map &amp; (1 &lt;&lt; (c)))
DECL|macro|bset
mdefine_line|#define bset(p,b)&t;((p)[(b) &gt;&gt; 5] |= (1 &lt;&lt; ((b) &amp; 0x1f)))
DECL|macro|tty2ppp
mdefine_line|#define tty2ppp(tty)&t;((struct ppp *) ((tty)-&gt;disc_data))
DECL|macro|dev2ppp
mdefine_line|#define dev2ppp(dev)&t;((struct ppp *) ((dev)-&gt;priv))
DECL|macro|ppp2tty
mdefine_line|#define ppp2tty(ppp)&t;((ppp)-&gt;tty)
DECL|macro|ppp2dev
mdefine_line|#define ppp2dev(ppp)&t;(&amp;(ppp)-&gt;dev)
DECL|variable|ppp_list
r_static
r_struct
id|ppp
op_star
id|ppp_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ppp_last
r_static
r_struct
id|ppp
op_star
id|ppp_last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Buffer types */
DECL|macro|BUFFER_TYPE_DEV_RD
mdefine_line|#define BUFFER_TYPE_DEV_RD&t;0  /* ppp read buffer&t;    */
DECL|macro|BUFFER_TYPE_TTY_WR
mdefine_line|#define BUFFER_TYPE_TTY_WR&t;1  /* tty write buffer&t;    */
DECL|macro|BUFFER_TYPE_DEV_WR
mdefine_line|#define BUFFER_TYPE_DEV_WR&t;2  /* ppp write buffer&t;    */
DECL|macro|BUFFER_TYPE_TTY_RD
mdefine_line|#define BUFFER_TYPE_TTY_RD&t;3  /* tty read buffer&t;    */
DECL|macro|BUFFER_TYPE_VJ
mdefine_line|#define BUFFER_TYPE_VJ&t;&t;4  /* vj compression buffer */
multiline_comment|/* Define this string only once for all macro invocations */
DECL|variable|ppp_warning
r_static
r_char
id|ppp_warning
(braket
)braket
op_assign
id|KERN_WARNING
l_string|&quot;PPP: ALERT! not INUSE! %d&bslash;n&quot;
suffix:semicolon
DECL|variable|szVersion
r_static
r_char
id|szVersion
(braket
)braket
op_assign
id|PPP_VERSION
suffix:semicolon
multiline_comment|/*&n; * Information for the protocol decoder&n; */
DECL|typedef|pfn_proto
r_typedef
r_int
(paren
op_star
id|pfn_proto
)paren
(paren
r_struct
id|ppp
op_star
comma
id|__u16
comma
id|__u8
op_star
comma
r_int
)paren
suffix:semicolon
DECL|struct|ppp_proto_struct
r_typedef
r_struct
id|ppp_proto_struct
(brace
DECL|member|proto
r_int
id|proto
suffix:semicolon
DECL|member|func
id|pfn_proto
id|func
suffix:semicolon
DECL|typedef|ppp_proto_type
)brace
id|ppp_proto_type
suffix:semicolon
r_static
DECL|variable|proto_list
id|ppp_proto_type
id|proto_list
(braket
)braket
op_assign
(brace
(brace
id|PPP_IP
comma
id|rcv_proto_ip
)brace
comma
(brace
id|PPP_IPX
comma
id|rcv_proto_ipx
)brace
comma
(brace
id|PPP_VJC_COMP
comma
id|rcv_proto_vjc_comp
)brace
comma
(brace
id|PPP_VJC_UNCOMP
comma
id|rcv_proto_vjc_uncomp
)brace
comma
(brace
id|PPP_LQR
comma
id|rcv_proto_lqr
)brace
comma
(brace
id|PPP_CCP
comma
id|rcv_proto_ccp
)brace
comma
(brace
l_int|0
comma
id|rcv_proto_unknown
)brace
multiline_comment|/* !!! MUST BE LAST !!! */
)brace
suffix:semicolon
DECL|variable|ppp_crc16_table
id|__u16
id|ppp_crc16_table
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
macro_line|#ifdef CHECK_CHARACTERS
DECL|variable|paritytab
r_static
id|__u32
id|paritytab
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x96696996
comma
l_int|0x69969669
comma
l_int|0x69969669
comma
l_int|0x96696996
comma
l_int|0x69969669
comma
l_int|0x96696996
comma
l_int|0x96696996
comma
l_int|0x69969669
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* local function to store a value into the LQR frame */
DECL|function|store_long
r_extern
r_inline
id|__u8
op_star
id|store_long
(paren
r_register
id|__u8
op_star
id|p
comma
r_register
r_int
id|value
)paren
(brace
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
(paren
id|value
op_rshift
l_int|24
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
(paren
id|value
op_rshift
l_int|16
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
(paren
id|value
op_rshift
l_int|8
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|__u8
)paren
id|value
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * INITIALIZATION&n; *************************************************************/
multiline_comment|/* This procedure is called once and once only to define who we are to&n; * the operating system and the various procedures that it may use in&n; * accessing the ppp protocol.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ppp_first_time
(paren
r_void
)paren
)paren
(brace
r_static
r_struct
id|tty_ldisc
id|ppp_ldisc
suffix:semicolon
r_int
id|status
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP: version %s (demand dialling)&quot;
l_string|&quot;&bslash;n&quot;
comma
id|szVersion
)paren
suffix:semicolon
macro_line|#ifndef MODULE /* slhc module logic has its own copyright announcement */
id|printk
(paren
id|KERN_INFO
l_string|&quot;TCP compression code copyright 1989 Regents of the &quot;
l_string|&quot;University of California&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Register the tty discipline&n; */
(paren
r_void
)paren
id|memset
(paren
op_amp
id|ppp_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|ppp_ldisc
)paren
)paren
suffix:semicolon
id|ppp_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|ppp_ldisc.name
op_assign
l_string|&quot;ppp&quot;
suffix:semicolon
id|ppp_ldisc.open
op_assign
id|ppp_tty_open
suffix:semicolon
id|ppp_ldisc.close
op_assign
id|ppp_tty_close
suffix:semicolon
id|ppp_ldisc.read
op_assign
id|ppp_tty_read
suffix:semicolon
id|ppp_ldisc.write
op_assign
id|ppp_tty_write
suffix:semicolon
id|ppp_ldisc.ioctl
op_assign
id|ppp_tty_ioctl
suffix:semicolon
id|ppp_ldisc.poll
op_assign
id|ppp_tty_poll
suffix:semicolon
id|ppp_ldisc.receive_room
op_assign
id|ppp_tty_room
suffix:semicolon
id|ppp_ldisc.receive_buf
op_assign
id|ppp_tty_receive
suffix:semicolon
id|ppp_ldisc.write_wakeup
op_assign
id|ppp_tty_wakeup
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
(paren
id|N_PPP
comma
op_amp
id|ppp_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP line discipline registered.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
id|KERN_ERR
l_string|&quot;error registering line discipline: %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * INITIALIZATION&n; *************************************************************/
multiline_comment|/* called when the device is actually created */
r_static
r_int
DECL|function|ppp_init_dev
id|ppp_init_dev
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;hard_header_len
op_assign
id|PPP_HDRLEN
suffix:semicolon
multiline_comment|/* device INFO */
id|dev-&gt;mtu
op_assign
id|PPP_MTU
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ppp_dev_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|ppp_dev_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|ppp_dev_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ppp_dev_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|ppp_dev_ioctl
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|10
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_PPP
suffix:semicolon
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* New-style flags */
id|dev-&gt;flags
op_assign
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
op_or
id|IFF_MULTICAST
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Local procedure to initialize the ppp structure&n; */
r_static
r_void
DECL|function|ppp_init_ctrl_blk
id|ppp_init_ctrl_blk
(paren
r_register
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|ppp-&gt;magic
op_assign
id|PPP_MAGIC
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|0xE0
suffix:semicolon
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;mtu
op_assign
id|PPP_MTU
suffix:semicolon
id|ppp-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|memset
(paren
id|ppp-&gt;xmit_async_map
comma
l_int|0
comma
r_sizeof
(paren
id|ppp-&gt;xmit_async_map
)paren
)paren
suffix:semicolon
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
id|ppp-&gt;xmit_async_map
(braket
l_int|3
)braket
op_assign
l_int|0x60000000
suffix:semicolon
id|ppp-&gt;recv_async_map
op_assign
l_int|0x00000000
suffix:semicolon
id|ppp-&gt;rbuf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;wbuf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;ubuf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;cbuf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;read_wait
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;write_wait
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;last_xmit
op_assign
id|jiffies
op_minus
id|flag_time
suffix:semicolon
id|ppp-&gt;last_recv
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* clear statistics */
id|memset
c_func
(paren
op_amp
id|ppp-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pppstat
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ppp-&gt;estats
comma
l_int|0
comma
r_sizeof
(paren
id|ppp-&gt;estats
)paren
)paren
suffix:semicolon
multiline_comment|/* PPP compression data */
id|ppp-&gt;sc_xc_state
op_assign
id|ppp-&gt;sc_rc_state
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|ppp_register_compressor
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_register_compressor
)paren
suffix:semicolon
DECL|variable|ppp_unregister_compressor
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_unregister_compressor
)paren
suffix:semicolon
DECL|variable|ppp_crc16_table
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_crc16_table
)paren
suffix:semicolon
multiline_comment|/* called at boot/load time for each ppp device defined in the kernel */
macro_line|#ifndef MODULE
r_int
DECL|function|ppp_init
id|ppp_init
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
r_int
id|answer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|first_time
op_assign
l_int|0
suffix:semicolon
id|answer
op_assign
id|ppp_first_time
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|answer
op_eq
l_int|0
)paren
id|answer
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
id|answer
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|BUFFER_MAGIC
mdefine_line|#define BUFFER_MAGIC&t;0x1d10
DECL|macro|CHECK_BUF_MAGIC
mdefine_line|#define CHECK_BUF_MAGIC(buf)&t;do { &bslash;&n;&t;if (buf-&gt;magic != BUFFER_MAGIC) { &bslash;&n;&t;&t;printk(KERN_WARNING &quot;bad magic for ppp buffer %p at %s:%d&bslash;n&quot;, &bslash;&n;&t;&t;       buf, __FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;} while (0)
multiline_comment|/*&n; * Routine to allocate a buffer for later use by the driver.&n; */
r_static
r_struct
id|ppp_buffer
op_star
DECL|function|ppp_alloc_buf
id|ppp_alloc_buf
(paren
r_int
id|size
comma
r_int
id|type
)paren
(brace
r_struct
id|ppp_buffer
op_star
id|buf
suffix:semicolon
id|buf
op_assign
(paren
r_struct
id|ppp_buffer
op_star
)paren
id|kmalloc
(paren
id|size
op_plus
r_sizeof
(paren
r_struct
id|ppp_buffer
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ne
l_int|NULL
)paren
(brace
id|buf-&gt;size
op_assign
id|size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Mask for the buffer size */
id|buf-&gt;type
op_assign
id|type
suffix:semicolon
id|buf-&gt;locked
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;head
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
id|buf-&gt;magic
op_assign
id|BUFFER_MAGIC
suffix:semicolon
)brace
r_return
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to release the allocated buffer.&n; */
r_static
r_void
DECL|function|ppp_free_buf
id|ppp_free_buf
(paren
r_struct
id|ppp_buffer
op_star
id|ptr
)paren
(brace
r_if
c_cond
(paren
id|ptr
op_ne
l_int|NULL
)paren
(brace
id|CHECK_BUF_MAGIC
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|kfree
(paren
id|ptr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Lock the indicated transmit buffer&n; */
r_extern
r_inline
r_int
DECL|function|lock_buffer
id|lock_buffer
(paren
r_register
r_struct
id|ppp_buffer
op_star
id|buf
)paren
(brace
r_int
r_int
id|state
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n; * Save the current state and if free then set it to the &quot;busy&quot; state&n; */
id|CHECK_BUF_MAGIC
c_func
(paren
id|buf
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|state
op_assign
id|buf-&gt;locked
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|0
)paren
id|buf-&gt;locked
op_assign
l_int|2
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * MTU has been changed by the IP layer. Unfortunately we are not told&n; * about this, but we spot it ourselves and fix things up. We could be&n; * in an upcall from the tty driver, or in an ip packet queue.&n; */
r_static
r_int
DECL|function|ppp_changedmtu
id|ppp_changedmtu
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_int
id|new_mtu
comma
r_int
id|new_mru
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|new_rbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|new_wbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|new_cbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|new_tbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|old_rbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|old_wbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|old_cbuf
suffix:semicolon
r_struct
id|ppp_buffer
op_star
id|old_tbuf
suffix:semicolon
r_int
id|mtu
comma
id|mru
suffix:semicolon
multiline_comment|/*&n; *  Allocate the buffer from the kernel for the data&n; */
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|dev
op_assign
id|ppp2dev
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: changedmtu %d %d&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|new_mtu
comma
id|new_mru
)paren
suffix:semicolon
id|mru
op_assign
id|new_mru
suffix:semicolon
multiline_comment|/* allow for possible escaping of every character */
id|mtu
op_assign
(paren
id|new_mtu
op_star
l_int|2
)paren
op_plus
l_int|20
suffix:semicolon
multiline_comment|/* RFC 1331, section 7.2 says the minimum value is 1500 bytes */
r_if
c_cond
(paren
id|mru
OL
id|PPP_MRU
)paren
id|mru
op_assign
id|PPP_MRU
suffix:semicolon
id|mru
op_add_assign
l_int|10
suffix:semicolon
id|new_wbuf
op_assign
id|ppp_alloc_buf
(paren
id|mtu
op_plus
id|PPP_HDRLEN
comma
id|BUFFER_TYPE_DEV_WR
)paren
suffix:semicolon
id|new_tbuf
op_assign
id|ppp_alloc_buf
(paren
(paren
id|PPP_MTU
op_star
l_int|2
)paren
op_plus
l_int|24
comma
id|BUFFER_TYPE_TTY_WR
)paren
suffix:semicolon
id|new_rbuf
op_assign
id|ppp_alloc_buf
(paren
id|mru
op_plus
l_int|84
comma
id|BUFFER_TYPE_DEV_RD
)paren
suffix:semicolon
id|new_cbuf
op_assign
id|ppp_alloc_buf
(paren
id|mru
op_plus
id|PPP_HDRLEN
comma
id|BUFFER_TYPE_VJ
)paren
suffix:semicolon
multiline_comment|/*&n; *  If the buffers failed to allocate then complain and release the partial&n; *  allocations.&n; */
r_if
c_cond
(paren
id|new_wbuf
op_eq
l_int|NULL
op_logical_or
id|new_tbuf
op_eq
l_int|NULL
op_logical_or
id|new_rbuf
op_eq
l_int|NULL
op_logical_or
id|new_cbuf
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp: failed to allocate new buffers&bslash;n&quot;
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|new_wbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|new_tbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|new_rbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|new_cbuf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Update the pointers to the new buffer structures.&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|old_wbuf
op_assign
id|ppp-&gt;wbuf
suffix:semicolon
id|old_rbuf
op_assign
id|ppp-&gt;rbuf
suffix:semicolon
id|old_cbuf
op_assign
id|ppp-&gt;cbuf
suffix:semicolon
id|old_tbuf
op_assign
id|ppp-&gt;tbuf
suffix:semicolon
id|ppp-&gt;wbuf
op_assign
id|new_wbuf
suffix:semicolon
id|ppp-&gt;rbuf
op_assign
id|new_rbuf
suffix:semicolon
id|ppp-&gt;cbuf
op_assign
id|new_cbuf
suffix:semicolon
id|ppp-&gt;tbuf
op_assign
id|new_tbuf
suffix:semicolon
r_if
c_cond
(paren
id|old_wbuf
)paren
id|new_wbuf-&gt;locked
op_assign
id|old_wbuf-&gt;locked
suffix:semicolon
id|ppp-&gt;rbuf-&gt;size
op_sub_assign
l_int|80
suffix:semicolon
multiline_comment|/* reserve space for vj header expansion */
id|dev-&gt;mem_start
op_assign
(paren
r_int
r_int
)paren
id|buf_base
(paren
id|new_wbuf
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
(paren
r_int
r_int
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|mtu
)paren
suffix:semicolon
id|dev-&gt;rmem_start
op_assign
(paren
r_int
r_int
)paren
id|buf_base
(paren
id|new_rbuf
)paren
suffix:semicolon
id|dev-&gt;rmem_end
op_assign
(paren
r_int
r_int
)paren
(paren
id|dev-&gt;rmem_start
op_plus
id|mru
)paren
suffix:semicolon
multiline_comment|/*&n; *  Update the parameters for the new buffer sizes&n; */
id|ppp-&gt;toss
op_assign
l_int|0xE0
suffix:semicolon
multiline_comment|/* To ignore characters until new FLAG */
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No pending escape character */
id|dev-&gt;mtu
op_assign
id|ppp-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
id|ppp-&gt;mru
op_assign
id|new_mru
suffix:semicolon
id|ppp-&gt;s1buf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;s2buf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;xbuf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_XMIT_BUSY
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; *  Release old buffer pointers&n; */
id|ppp_free_buf
(paren
id|old_rbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|old_wbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|old_cbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|old_tbuf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * CCP is down; free (de)compressor state if necessary.&n; */
r_static
r_void
DECL|function|ppp_ccp_closed
id|ppp_ccp_closed
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_CCP_OPEN
op_or
id|SC_CCP_UP
op_or
id|SC_COMP_RUN
op_or
id|SC_DECOMP_RUN
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: ccp closed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_free
)paren
(paren
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_xc_state
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_free
)paren
(paren
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Called to release all of the information in the current PPP structure.&n; *&n; * It is called when the ppp device goes down or if it is unable to go&n; * up.&n; */
r_static
r_void
DECL|function|ppp_release
id|ppp_release
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|CHECK_PPP_MAGIC
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|tty
op_assign
id|ppp2tty
(paren
id|ppp
)paren
suffix:semicolon
id|dev
op_assign
id|ppp2dev
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s released&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|ppp_ccp_closed
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/* Ensure that the pppd process is not hanging on poll() */
id|wake_up_interruptible
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|ppp-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
l_int|NULL
op_logical_and
id|tty-&gt;disc_data
op_eq
id|ppp
)paren
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Break the tty-&gt;ppp link */
id|ppp_free_buf
(paren
id|ppp-&gt;rbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|ppp-&gt;wbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|ppp-&gt;cbuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|ppp-&gt;ubuf
)paren
suffix:semicolon
id|ppp_free_buf
(paren
id|ppp-&gt;tbuf
)paren
suffix:semicolon
id|ppp-&gt;rbuf
op_assign
id|ppp-&gt;wbuf
op_assign
id|ppp-&gt;cbuf
op_assign
id|ppp-&gt;tbuf
op_assign
id|ppp-&gt;xbuf
op_assign
id|ppp-&gt;s1buf
op_assign
id|ppp-&gt;s2buf
op_assign
id|ppp-&gt;ubuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
)paren
(brace
id|slhc_free
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ppp-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;backup_tty
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * TTY callback.&n; *&n; * Called when the line discipline is changed to something&n; * else, the tty is closed, or the tty detects a hangup.&n; */
r_static
r_void
DECL|function|ppp_tty_close
id|ppp_tty_close
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ppp: trying to close unopened tty!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|ppp-&gt;backup_tty
)paren
id|ppp-&gt;backup_tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;backup_tty
)paren
(brace
id|ppp-&gt;tty
op_assign
id|ppp-&gt;backup_tty
suffix:semicolon
)brace
r_else
(brace
id|ppp-&gt;sc_xfer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp: channel %s closing.&bslash;n&quot;
comma
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|ppp_release
(paren
id|ppp
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * TTY callback.&n; *&n; * Called when the tty discipline is switched to PPP.&n; */
r_static
r_int
DECL|function|ppp_tty_open
id|ppp_tty_open
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_int
id|indx
suffix:semicolon
multiline_comment|/*&n; * There should not be an existing table for this slot.&n; */
r_if
c_cond
(paren
id|ppp
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_tty_open: gack! tty already associated to %s!&bslash;n&quot;
comma
id|ppp-&gt;magic
op_eq
id|PPP_MAGIC
ques
c_cond
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|name
suffix:colon
l_string|&quot;unknown&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate the structure from the system&n; */
id|ppp
op_assign
id|ppp_find
c_func
(paren
id|current-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we are taking over a ppp unit which is currently&n;&t;&t; * connected to a loopback pty, there&squot;s not much to do.&n;&t;&t; */
id|CHECK_PPP
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|ppp
suffix:semicolon
id|ppp-&gt;tty
op_assign
id|tty
suffix:semicolon
)brace
r_else
(brace
id|ppp
op_assign
id|ppp_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_alloc failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the control block&n; */
id|ppp_init_ctrl_blk
(paren
id|ppp
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|ppp
suffix:semicolon
id|ppp-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/*&n; * Allocate space for the default VJ header compression slots&n; */
id|ppp-&gt;slcomp
op_assign
id|slhc_init
(paren
l_int|16
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_tty_open: &quot;
l_string|&quot;no space for compression buffers!&bslash;n&quot;
)paren
suffix:semicolon
id|ppp_release
(paren
id|ppp
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space for the MTU and MRU buffers&n; */
r_if
c_cond
(paren
id|ppp_changedmtu
(paren
id|ppp
comma
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|mtu
comma
id|ppp-&gt;mru
)paren
op_eq
l_int|0
)paren
(brace
id|ppp_release
(paren
id|ppp
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space for a user level buffer&n; */
id|ppp-&gt;ubuf
op_assign
id|ppp_alloc_buf
(paren
id|RBUFSIZE
comma
id|BUFFER_TYPE_TTY_RD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;ubuf
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_tty_open: &quot;
l_string|&quot;no space for user receive buffer&bslash;n&quot;
)paren
suffix:semicolon
id|ppp_release
(paren
id|ppp
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp: channel %s open&bslash;n&quot;
comma
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|indx
op_assign
l_int|0
suffix:semicolon
id|indx
OL
id|NUM_NP
suffix:semicolon
op_increment
id|indx
)paren
id|ppp-&gt;sc_npmode
(braket
id|indx
)braket
op_assign
id|NPMODE_PASS
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush any pending characters in the driver and discipline.&n; */
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc.flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver.flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_return
(paren
id|ppp-&gt;line
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Local function to send the next portion of the buffer.&n; *&n; * Called by the tty driver&squot;s tty_wakeup function should it be entered&n; * because the partial buffer was transmitted.&n; *&n; * Called by kick_tty to send the initial portion of the buffer.&n; *&n; * Completion processing of the buffer transmission is handled here.&n; */
r_static
r_void
DECL|function|ppp_tty_wakeup_code
id|ppp_tty_wakeup_code
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|ppp_buffer
op_star
id|xbuf
)paren
(brace
r_register
r_int
id|count
comma
id|actual
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
id|CHECK_BUF_MAGIC
c_func
(paren
id|xbuf
)paren
suffix:semicolon
multiline_comment|/*&n; * Prevent re-entrancy by ensuring that this routine is called only once.&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_XMIT_BUSY
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ppp-&gt;flags
op_or_assign
id|SC_XMIT_BUSY
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * Send the next block of data to the modem&n; */
id|count
op_assign
id|xbuf-&gt;count
op_minus
id|xbuf-&gt;tail
suffix:semicolon
id|actual
op_assign
id|tty-&gt;driver.write
(paren
id|tty
comma
l_int|0
comma
id|buf_base
(paren
id|xbuf
)paren
op_plus
id|xbuf-&gt;tail
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Terminate transmission of any block which may have an error.&n; * This could occur should the carrier drop.&n; */
r_if
c_cond
(paren
id|actual
OL
l_int|0
)paren
(brace
id|ppp-&gt;stats.ppp_oerrors
op_increment
suffix:semicolon
id|actual
op_assign
id|count
suffix:semicolon
)brace
r_else
id|ppp-&gt;bytes_sent
op_add_assign
id|actual
suffix:semicolon
multiline_comment|/*&n; * If the buffer has been transmitted then clear the indicators.&n; */
id|xbuf-&gt;tail
op_add_assign
id|actual
suffix:semicolon
r_if
c_cond
(paren
id|actual
op_eq
id|count
)paren
(brace
id|xbuf
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_XMIT_BUSY
suffix:semicolon
multiline_comment|/*&n; * Complete the transmission on the current buffer.&n; */
id|xbuf
op_assign
id|ppp-&gt;xbuf
suffix:semicolon
r_if
c_cond
(paren
id|xbuf
op_ne
l_int|NULL
)paren
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|xbuf-&gt;locked
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;xbuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * If the completed buffer came from the device write, then complete the&n; * transmission block.&n; */
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
(paren
id|NET_BH
)paren
suffix:semicolon
multiline_comment|/*&n; * Wake up the transmission queue for all completion events.&n; */
id|wake_up_interruptible
(paren
op_amp
id|ppp-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/*&n; * Look at the priorities. Choose a daemon write over the device driver.&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|xbuf
op_assign
id|ppp-&gt;s1buf
suffix:semicolon
id|ppp-&gt;s1buf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|xbuf
op_eq
l_int|NULL
)paren
(brace
id|xbuf
op_assign
id|ppp-&gt;s2buf
suffix:semicolon
id|ppp-&gt;s2buf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * If there is a pending buffer then transmit it now.&n; */
r_if
c_cond
(paren
id|xbuf
op_ne
l_int|NULL
)paren
(brace
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_XMIT_BUSY
suffix:semicolon
id|ppp_kick_tty
(paren
id|ppp
comma
id|xbuf
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear the re-entry flag&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* &amp;=~ may not be atomic */
id|cli
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_XMIT_BUSY
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called by the tty driver when the transmit buffer has&n; * additional space. It is used by the ppp code to continue to transmit&n; * the current buffer should the buffer have been partially sent.&n; *&n; * In addition, it is used to send the first part of the buffer since the&n; * logic and the inter-locking would be identical.&n; */
r_static
r_void
DECL|function|ppp_tty_wakeup
id|ppp_tty_wakeup
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ppp_buffer
op_star
id|xbuf
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_return
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|ppp-&gt;tty
)paren
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Ensure that there is a transmission pending. Clear the re-entry flag if&n; * there is no pending buffer. Otherwise, send the buffer.&n; */
id|xbuf
op_assign
id|ppp-&gt;xbuf
suffix:semicolon
r_if
c_cond
(paren
id|xbuf
op_eq
l_int|NULL
)paren
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_else
id|ppp_tty_wakeup_code
(paren
id|ppp
comma
id|tty
comma
id|xbuf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to transmit a buffer to the remote. The buffer&n; * is placed on the pending queue if there is presently a buffer being&n; * sent or it is transmitted with the aid of ppp_tty_wakeup.&n; */
r_static
r_void
DECL|function|ppp_kick_tty
id|ppp_kick_tty
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_buffer
op_star
id|xbuf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
id|CHECK_BUF_MAGIC
c_func
(paren
id|xbuf
)paren
suffix:semicolon
multiline_comment|/*&n; * Hold interrupts.&n; */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Control the flags which are best performed with the interrupts masked.&n; */
id|xbuf-&gt;locked
op_assign
l_int|1
suffix:semicolon
id|xbuf-&gt;tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * If the transmitter is busy then place the buffer on the appropriate&n; * priority queue.&n; */
r_if
c_cond
(paren
id|ppp-&gt;xbuf
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|xbuf-&gt;type
op_eq
id|BUFFER_TYPE_TTY_WR
)paren
id|ppp-&gt;s1buf
op_assign
id|xbuf
suffix:semicolon
r_else
id|ppp-&gt;s2buf
op_assign
id|xbuf
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * If the transmitter is not busy then this is the highest priority frame&n; */
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_XMIT_BUSY
suffix:semicolon
id|ppp-&gt;tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|ppp-&gt;xbuf
op_assign
id|xbuf
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * Do the &quot;tty wakeup_code&quot; to actually send this buffer.&n; */
id|ppp_tty_wakeup_code
(paren
id|ppp
comma
id|ppp2tty
(paren
id|ppp
)paren
comma
id|xbuf
)paren
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * TTY INPUT&n; *    The following functions handle input that arrives from&n; *    the TTY.&t;It recognizes PPP frames and either hands them&n; *    to the network layer or queues them for delivery to a&n; *    user process reading this TTY.&n; *************************************************************/
multiline_comment|/*&n; * Callback function from tty driver. Return the amount of space left&n; * in the receiver&squot;s buffer to decide if remote transmitter is to be&n; * throttled.&n; */
r_static
r_int
DECL|function|ppp_tty_room
id|ppp_tty_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65536
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/*&n; * Callback function when data is available at the tty driver.&n; */
r_static
r_void
DECL|function|ppp_tty_receive
id|ppp_tty_receive
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|data
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_register
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_register
r_struct
id|ppp_buffer
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
id|__u8
id|chr
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|0
)paren
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can happen if stuff comes in on the backup tty.&n;&t; */
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
op_logical_or
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; * Fetch the pointer to the buffer. Be careful about race conditions.&n; */
id|buf
op_assign
id|ppp-&gt;rbuf
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; * Verify the table pointer and ensure that the line is&n; * still in PPP discipline.&n; */
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;PPP: tty_receive called but couldn&squot;t find &quot;
l_string|&quot;PPP struct.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CHECK_PPP_VOID
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Print the buffer if desired&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOG_RAWIN
)paren
id|ppp_print_buffer
(paren
l_string|&quot;receive buffer&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Collect the character and error condition for the character. Set the toss&n; * flag for the first character error.&n; */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|ppp-&gt;bytes_rcvd
op_increment
suffix:semicolon
id|chr
op_assign
op_star
id|data
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
(brace
r_if
c_cond
(paren
op_star
id|flags
op_logical_and
id|ppp-&gt;toss
op_eq
l_int|0
)paren
(brace
id|ppp-&gt;toss
op_assign
op_star
id|flags
suffix:semicolon
r_switch
c_cond
(paren
id|ppp-&gt;toss
)paren
(brace
r_case
id|TTY_OVERRUN
suffix:colon
op_increment
id|ppp-&gt;estats.rx_fifo_errors
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_FRAME
suffix:colon
r_case
id|TTY_BREAK
suffix:colon
op_increment
id|ppp-&gt;estats.rx_frame_errors
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_increment
id|flags
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the flags for d7 being 0/1 and parity being even/odd so that&n; * the normal processing would have all flags set at the end of the&n; * session.  A missing flag bit indicates an error condition.&n; */
macro_line|#ifdef CHECK_CHARACTERS
r_if
c_cond
(paren
id|chr
op_amp
l_int|0x80
)paren
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_B7_1
suffix:semicolon
r_else
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_B7_0
suffix:semicolon
r_if
c_cond
(paren
id|paritytab
(braket
id|chr
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|chr
op_amp
l_int|0x1F
)paren
)paren
)paren
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_ODDP
suffix:semicolon
r_else
id|ppp-&gt;flags
op_or_assign
id|SC_RCV_EVNP
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Branch on the character.&n; */
r_switch
c_cond
(paren
id|chr
)paren
(brace
multiline_comment|/*&n; * FLAG. This is the end of the block. If the block terminated by ESC FLAG,&n; * then the block is to be ignored. In addition, characters before the very&n; * first FLAG are also tossed by this procedure.&n; */
r_case
id|PPP_FLAG
suffix:colon
multiline_comment|/* PPP_FLAG: end of frame */
id|ppp-&gt;stats.ppp_ibytes
op_add_assign
id|ppp-&gt;rbuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;escape
)paren
id|ppp-&gt;toss
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/*&n; * Process frames which are not to be ignored. If the processing failed,&n; * then clean up the VJ tables.&n; */
r_if
c_cond
(paren
id|ppp_doframe
(paren
id|ppp
)paren
op_eq
l_int|0
)paren
(brace
op_increment
id|ppp-&gt;stats.ppp_ierrors
suffix:semicolon
id|slhc_toss
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset all indicators for the new frame to follow.&n; */
id|buf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|ppp-&gt;toss
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * All other characters in the data come here. If the character is in the&n; * receive mask then ignore the character.&n; */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* If we&squot;re tossing, look no further. */
r_if
c_cond
(paren
id|ppp-&gt;toss
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* If this is a control char to be ignored, do so */
r_if
c_cond
(paren
id|in_rmap
(paren
id|ppp
comma
id|chr
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Modify the next character if preceded by escape.&n;&t;&t;&t; * The escape character (0x7d) could be an escaped&n;&t;&t;&t; * 0x5d, if it follows an escape :-)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;escape
)paren
(brace
id|chr
op_xor_assign
id|PPP_TRANS
suffix:semicolon
id|ppp-&gt;escape
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|chr
op_eq
id|PPP_ESCAPE
)paren
(brace
id|ppp-&gt;escape
op_assign
id|PPP_TRANS
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Decompress A/C and protocol compression here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|buf-&gt;count
op_eq
l_int|0
op_logical_and
id|chr
op_ne
id|PPP_ALLSTATIONS
)paren
(brace
id|buf_base
c_func
(paren
id|buf
)paren
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|buf_base
c_func
(paren
id|buf
)paren
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
id|buf-&gt;count
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf-&gt;count
op_eq
l_int|2
op_logical_and
(paren
id|chr
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|buf_base
c_func
(paren
id|buf
)paren
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;count
op_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n; * If the count sent is within reason then store the character, bump the&n; * count, and update the FCS for the character.&n; */
r_if
c_cond
(paren
id|buf-&gt;count
OL
id|buf-&gt;size
)paren
(brace
id|buf_base
(paren
id|buf
)paren
(braket
id|buf-&gt;count
op_increment
)braket
op_assign
id|chr
suffix:semicolon
id|buf-&gt;fcs
op_assign
id|PPP_FCS
(paren
id|buf-&gt;fcs
comma
id|chr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; * The peer sent too much data. Set the flags to discard the current frame&n; * and wait for the re-synchronization FLAG to be sent.&n; */
op_increment
id|ppp-&gt;estats.rx_length_errors
suffix:semicolon
id|ppp-&gt;toss
op_or_assign
l_int|0xC0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* on entry, a received frame is in ppp-&gt;rbuf.bufr&n;   check it and dispose as appropriate */
r_static
r_int
DECL|function|ppp_doframe
id|ppp_doframe
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|__u8
op_star
id|data
op_assign
id|buf_base
(paren
id|ppp-&gt;rbuf
)paren
suffix:semicolon
r_int
id|count
op_assign
id|ppp-&gt;rbuf-&gt;count
suffix:semicolon
r_int
id|proto
suffix:semicolon
r_int
id|new_count
suffix:semicolon
id|__u8
op_star
id|new_data
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|CHECK_BUF_MAGIC
c_func
(paren
id|ppp-&gt;rbuf
)paren
suffix:semicolon
multiline_comment|/*&n; * If there is a pending error from the receiver then log it and discard&n; * the damaged frame.&n; */
r_if
c_cond
(paren
id|ppp-&gt;toss
)paren
(brace
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
op_logical_and
id|count
OG
l_int|0
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp_toss: tossing frame, reason = %x&bslash;n&quot;
comma
id|ppp-&gt;toss
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * An empty frame is ignored. This occurs if the FLAG sequence precedes and&n; * follows each frame.&n; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Generate an error if the frame is too small.&n; */
r_if
c_cond
(paren
id|count
OL
id|PPP_HDRLEN
op_plus
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: got runt ppp frame, %d chars&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
op_increment
id|ppp-&gt;estats.rx_length_errors
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify the CRC of the frame and discard the CRC characters from the&n; * end of the buffer.&n; */
r_if
c_cond
(paren
id|ppp-&gt;rbuf-&gt;fcs
op_ne
id|PPP_GOODFCS
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: frame with bad fcs, length = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|ppp_print_buffer
c_func
(paren
l_string|&quot;bad frame&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
)brace
op_increment
id|ppp-&gt;estats.rx_crc_errors
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* ignore the fcs characters */
multiline_comment|/*&n; * Obtain the protocol from the frame&n; */
id|proto
op_assign
id|PPP_PROTOCOL
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; * Process the active decompressor.&n; */
r_if
c_cond
(paren
(paren
id|ppp-&gt;sc_rc_state
op_ne
(paren
r_void
op_star
)paren
l_int|0
)paren
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DECOMP_RUN
)paren
op_logical_and
(paren
(paren
id|ppp-&gt;flags
op_amp
(paren
id|SC_DC_FERROR
op_or
id|SC_DC_ERROR
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|proto
op_eq
id|PPP_COMP
)paren
(brace
multiline_comment|/*&n; * If the frame is compressed then decompress it.&n; */
id|new_data
op_assign
id|kmalloc
(paren
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_doframe: no memory&bslash;n&quot;
)paren
suffix:semicolon
id|new_count
op_assign
id|DECOMP_ERROR
suffix:semicolon
)brace
r_else
(brace
id|new_count
op_assign
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decompress
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
id|data
comma
id|count
comma
id|new_data
comma
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|new_count
)paren
(brace
r_default
suffix:colon
id|ppp_doframe_lower
(paren
id|ppp
comma
id|new_data
comma
id|new_count
)paren
suffix:semicolon
id|kfree
(paren
id|new_data
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|DECOMP_ERROR
suffix:colon
id|ppp-&gt;flags
op_or_assign
id|SC_DC_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DECOMP_FATALERROR
suffix:colon
id|ppp-&gt;flags
op_or_assign
id|SC_DC_FERROR
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp: fatal decomp error&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the error condition and discard the frame.&n; */
r_if
c_cond
(paren
id|new_data
op_ne
l_int|0
)paren
id|kfree
(paren
id|new_data
)paren
suffix:semicolon
id|slhc_toss
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_ierrors
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n; * The frame is not special. Pass it through the compressor without&n; * actually compressing the data&n; */
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;incomp
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
id|data
comma
id|count
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|proto
op_eq
id|PPP_COMP
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: frame not decompressed: &quot;
l_string|&quot;flags=%x, count=%d, sc_rc_state=%p&bslash;n&quot;
comma
id|ppp-&gt;flags
comma
id|count
comma
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the uncompressed frame.&n; */
id|ppp_doframe_lower
(paren
id|ppp
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ppp_doframe_lower
r_static
r_void
id|ppp_doframe_lower
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
id|__u16
id|proto
op_assign
id|PPP_PROTOCOL
(paren
id|data
)paren
suffix:semicolon
id|ppp_proto_type
op_star
id|proto_ptr
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Ignore empty frames&n; */
r_if
c_cond
(paren
id|count
op_le
id|PPP_HDRLEN
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; * Count the frame and print it&n; */
op_increment
id|ppp-&gt;stats.ppp_ipackets
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOG_INPKT
)paren
id|ppp_print_buffer
(paren
l_string|&quot;receive frame&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Find the procedure to handle this protocol. The last one is marked&n; * as a protocol 0 which is the &squot;catch-all&squot; to feed it to the pppd daemon.&n; */
id|proto_ptr
op_assign
id|proto_list
suffix:semicolon
r_while
c_loop
(paren
id|proto_ptr-&gt;proto
op_ne
l_int|0
op_logical_and
id|proto_ptr-&gt;proto
op_ne
id|proto
)paren
op_increment
id|proto_ptr
suffix:semicolon
multiline_comment|/*&n; * Update the appropriate statistic counter.&n; */
r_if
c_cond
(paren
(paren
op_star
id|proto_ptr-&gt;func
)paren
(paren
id|ppp
comma
id|proto
comma
op_amp
id|data
(braket
id|PPP_HDRLEN
)braket
comma
id|count
op_minus
id|PPP_HDRLEN
)paren
)paren
id|ppp-&gt;stats.ppp_ioctects
op_add_assign
id|count
suffix:semicolon
r_else
op_increment
id|ppp-&gt;stats.ppp_discards
suffix:semicolon
)brace
multiline_comment|/*&n; * Put the input frame into the networking system for the indicated protocol&n; */
r_static
r_int
DECL|function|ppp_rcv_rx
id|ppp_rcv_rx
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
(paren
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Generate a skb buffer for the new frame.&n; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_do_ip: packet dropped on %s (no memory)!&bslash;n&quot;
comma
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move the received data from the input buffer to the skb buffer.&n; */
id|skb-&gt;dev
op_assign
id|ppp2dev
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/* We are the device */
id|skb-&gt;protocol
op_assign
id|proto
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb_data
c_func
(paren
id|skb
)paren
suffix:semicolon
id|memcpy
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* move data */
multiline_comment|/*&n; * Tag the frame and kick it to the proper receive routine&n; */
id|ppp-&gt;last_recv
op_assign
id|jiffies
suffix:semicolon
id|netif_rx
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an IP frame&n; */
r_static
r_int
DECL|function|rcv_proto_ip
id|rcv_proto_ip
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|count
OG
l_int|0
)paren
)paren
r_if
c_cond
(paren
id|ppp-&gt;sc_npmode
(braket
id|NP_IP
)braket
op_eq
id|NPMODE_PASS
)paren
r_return
id|ppp_rcv_rx
(paren
id|ppp
comma
id|htons
(paren
id|ETH_P_IP
)paren
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an IPX frame&n; */
r_static
r_int
DECL|function|rcv_proto_ipx
id|rcv_proto_ipx
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IFF_UP
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|count
OG
l_int|0
)paren
)paren
r_return
id|ppp_rcv_rx
(paren
id|ppp
comma
id|htons
(paren
id|ETH_P_IPX
)paren
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an VJ Compressed frame&n; */
r_static
r_int
DECL|function|rcv_proto_vjc_comp
id|rcv_proto_vjc_comp
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_REJ_COMP_TCP
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|new_count
op_assign
id|slhc_uncompress
(paren
id|ppp-&gt;slcomp
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_count
op_ge
l_int|0
)paren
(brace
r_return
id|rcv_proto_ip
(paren
id|ppp
comma
id|PPP_IP
comma
id|data
comma
id|new_count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;ppp: error in VJ decompression&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the receipt of an VJ Un-compressed frame&n; */
r_static
r_int
DECL|function|rcv_proto_vjc_uncomp
id|rcv_proto_vjc_uncomp
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_REJ_COMP_TCP
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|slhc_remember
(paren
id|ppp-&gt;slcomp
comma
id|data
comma
id|count
)paren
OG
l_int|0
)paren
(brace
r_return
id|rcv_proto_ip
(paren
id|ppp
comma
id|PPP_IP
comma
id|data
comma
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;ppp: error in VJ memorizing&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive all unclassified protocols.&n; */
r_static
r_int
DECL|function|rcv_proto_unknown
id|rcv_proto_unknown
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_int
id|totlen
suffix:semicolon
r_register
r_int
id|current_idx
suffix:semicolon
DECL|macro|PUTC
mdefine_line|#define PUTC(c)&t;&t;&t;&t;&t;&t; &bslash;&n;{&t;&t;&t;&t;&t;&t;&t; &bslash;&n;    buf_base (ppp-&gt;ubuf) [current_idx++] = (__u8) (c); &bslash;&n;    current_idx &amp;= ppp-&gt;ubuf-&gt;size;&t;&t;&t; &bslash;&n;    if (current_idx == ppp-&gt;ubuf-&gt;tail)&t;&t;&t; &bslash;&n;&t;    goto failure;&t;&t;&t;&t; &bslash;&n;}
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * The total length includes the protocol data.&n; * Lock the user information buffer.&n; */
r_if
c_cond
(paren
id|test_and_set_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: rcv_proto_unknown: can&squot;t get lock&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|CHECK_BUF_MAGIC
c_func
(paren
id|ppp-&gt;ubuf
)paren
suffix:semicolon
id|current_idx
op_assign
id|ppp-&gt;ubuf-&gt;head
suffix:semicolon
multiline_comment|/*&n; * Insert the buffer length (not counted), the protocol, and the data&n; */
id|totlen
op_assign
id|len
op_plus
l_int|2
suffix:semicolon
id|PUTC
(paren
id|totlen
op_rshift
l_int|8
)paren
suffix:semicolon
id|PUTC
(paren
id|totlen
)paren
suffix:semicolon
id|PUTC
(paren
id|proto
op_rshift
l_int|8
)paren
suffix:semicolon
id|PUTC
(paren
id|proto
)paren
suffix:semicolon
id|totlen
op_sub_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|totlen
op_decrement
OG
l_int|0
)paren
(brace
id|PUTC
(paren
op_star
id|data
op_increment
)paren
suffix:semicolon
)brace
DECL|macro|PUTC
macro_line|#undef PUTC
multiline_comment|/*&n; * The frame is complete. Update the head pointer and wakeup the pppd&n; * process.&n; */
id|ppp-&gt;ubuf-&gt;head
op_assign
id|current_idx
suffix:semicolon
id|clear_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tty-&gt;fasync
op_ne
l_int|NULL
)paren
id|kill_fasync
(paren
id|ppp-&gt;tty-&gt;fasync
comma
id|SIGIO
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n; * The buffer is full. Unlock the header&n; */
id|failure
suffix:colon
id|clear_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: rcv_proto_unknown: buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Discard the frame. There are no takers for this protocol.&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: rcv_proto_unknown: dropping packet&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle a CCP packet.&n; *&n; * The CCP packet is passed along to the pppd process just like any&n; * other PPP frame. The difference is that some processing needs to be&n; * immediate or the compressors will become confused on the peer.&n; */
DECL|function|ppp_proto_ccp
r_static
r_void
id|ppp_proto_ccp
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|dp
comma
r_int
id|len
comma
r_int
id|rcvd
)paren
(brace
r_int
id|slen
op_assign
id|CCP_LENGTH
c_func
(paren
id|dp
)paren
suffix:semicolon
id|__u8
op_star
id|opt
op_assign
id|dp
op_plus
id|CCP_HDRLEN
suffix:semicolon
r_int
id|opt_len
op_assign
id|slen
op_minus
id|CCP_HDRLEN
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|slen
OG
id|len
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|CCP_CODE
c_func
(paren
id|dp
)paren
)paren
(brace
r_case
id|CCP_CONFREQ
suffix:colon
r_case
id|CCP_TERMREQ
suffix:colon
r_case
id|CCP_TERMACK
suffix:colon
multiline_comment|/*&n; * CCP must be going down - disable compression&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_CCP_UP
op_or
id|SC_COMP_RUN
op_or
id|SC_DECOMP_RUN
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CCP_CONFACK
suffix:colon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_OPEN
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|slen
OL
(paren
id|CCP_HDRLEN
op_plus
id|CCP_OPT_MINLEN
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|slen
OL
(paren
id|CCP_OPT_LENGTH
(paren
id|opt
)paren
op_plus
id|CCP_HDRLEN
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n; * we&squot;re agreeing to send compressed packets.&n; */
r_if
c_cond
(paren
op_logical_neg
id|rcvd
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_init
)paren
(paren
id|ppp-&gt;sc_xc_state
comma
id|opt
comma
id|opt_len
comma
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|base_addr
comma
l_int|0
comma
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: comp running&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_or_assign
id|SC_COMP_RUN
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; * peer is agreeing to send compressed packets.&n; */
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_init
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
id|opt
comma
id|opt_len
comma
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|base_addr
comma
l_int|0
comma
id|ppp-&gt;mru
comma
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: decomp running&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_or_assign
id|SC_DECOMP_RUN
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_DC_ERROR
op_or
id|SC_DC_FERROR
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n; * CCP Reset-ack resets compressors and decompressors as it passes through.&n; */
r_case
id|CCP_RESETACK
suffix:colon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcvd
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_RUN
)paren
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_reset
)paren
(paren
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: comp reset&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_DECOMP_RUN
)paren
)paren
(brace
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_reset
)paren
(paren
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: decomp reset&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
id|SC_DC_ERROR
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp_proto_ccp: %s code %d, flags=%x&bslash;n&quot;
comma
(paren
id|rcvd
ques
c_cond
l_string|&quot;rcvd&quot;
suffix:colon
l_string|&quot;sent&quot;
)paren
comma
id|CCP_CODE
c_func
(paren
id|dp
)paren
comma
id|ppp-&gt;flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|rcv_proto_ccp
id|rcv_proto_ccp
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|dp
comma
r_int
id|len
)paren
(brace
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ppp_proto_ccp
(paren
id|ppp
comma
id|dp
comma
id|len
comma
l_int|1
)paren
suffix:semicolon
r_return
id|rcv_proto_unknown
(paren
id|ppp
comma
id|proto
comma
id|dp
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle a LQR packet.&n; */
r_static
r_int
DECL|function|rcv_proto_lqr
id|rcv_proto_lqr
(paren
r_struct
id|ppp
op_star
id|ppp
comma
id|__u16
id|proto
comma
id|__u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_return
id|rcv_proto_unknown
(paren
id|ppp
comma
id|proto
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * LINE DISCIPLINE SUPPORT&n; *    The following functions form support user programs&n; *    which read and write data on a TTY with the PPP line&n; *    discipline.  Reading is done from a circular queue,&n; *    filled by the lower TTY levels.&n; *************************************************************/
multiline_comment|/* read a PPP frame from the us_rbuff circular buffer,&n;   waiting if necessary&n;*/
r_static
id|ssize_t
DECL|function|ppp_tty_read
id|ppp_tty_read
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|__u8
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
id|__u8
id|c
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ssize_t
id|len
comma
id|ret
suffix:semicolon
DECL|macro|GETC
mdefine_line|#define GETC(c)&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;c = buf_base (ppp-&gt;ubuf) [ppp-&gt;ubuf-&gt;tail++];&t;&bslash;&n;&t;ppp-&gt;ubuf-&gt;tail &amp;= ppp-&gt;ubuf-&gt;size;&t;&t;&bslash;&n;}
multiline_comment|/*&n; * Validate the pointers&n; */
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* if (ppp-&gt;magic != PPP_MAGIC)&n;&t;&t;return -EIO; */
id|CHECK_PPP
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
multiline_comment|/*&n; * Before we attempt to write the frame to the user, ensure that the&n; * user has access to the pages for the total buffer length.&n; */
id|error
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n; * Acquire the read lock.&n; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp
op_logical_or
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
op_logical_or
op_logical_neg
id|ppp-&gt;inuse
op_logical_or
id|tty
op_ne
id|ppp-&gt;tty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp_tty_read: sleeping(ubuf)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch the length of the buffer from the first two bytes.&n; */
r_if
c_cond
(paren
id|ppp-&gt;ubuf-&gt;head
op_eq
id|ppp-&gt;ubuf-&gt;tail
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|GETC
(paren
id|c
)paren
suffix:semicolon
id|len
op_assign
id|c
op_lshift
l_int|8
suffix:semicolon
id|GETC
(paren
id|c
)paren
suffix:semicolon
id|len
op_add_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; * If there is no length then wait for the data to arrive.&n; */
multiline_comment|/* no data */
id|clear_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp_tty_read: sleeping(read_wait)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|interruptible_sleep_on
(paren
op_amp
id|ppp-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/*&n; * Ensure that the frame will fit within the caller&squot;s buffer. If not, then&n; * discard the frame from the input buffer.&n; */
r_if
c_cond
(paren
id|len
op_plus
l_int|2
OG
id|nr
)paren
(brace
multiline_comment|/* Can&squot;t copy it, update us_rbuff_head */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: read of %lu bytes too small for %ld &quot;
l_string|&quot;frame&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|nr
comma
(paren
r_int
)paren
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|ppp-&gt;stats.ppp_ierrors
op_increment
suffix:semicolon
id|error
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Fake the insertion of the ADDRESS and CONTROL information because these&n; * were not saved in the buffer.&n; */
id|error
op_assign
id|put_user
c_func
(paren
(paren
id|u_char
)paren
id|PPP_ALLSTATIONS
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|buf
suffix:semicolon
id|error
op_assign
id|put_user
c_func
(paren
(paren
id|u_char
)paren
id|PPP_UI
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|buf
suffix:semicolon
multiline_comment|/*&n; * Copy the received data from the buffer to the caller&squot;s area.&n; */
id|ret
op_assign
id|len
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* Account for ADDRESS and CONTROL bytes */
r_while
c_loop
(paren
id|len
op_decrement
OG
l_int|0
)paren
(brace
id|GETC
(paren
id|c
)paren
suffix:semicolon
id|error
op_assign
id|put_user
c_func
(paren
id|c
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|buf
suffix:semicolon
)brace
id|clear_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|out
suffix:colon
id|ppp-&gt;ubuf-&gt;tail
op_add_assign
id|len
suffix:semicolon
id|ppp-&gt;ubuf-&gt;tail
op_and_assign
id|ppp-&gt;ubuf-&gt;size
suffix:semicolon
id|clear_bit
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
DECL|macro|GETC
macro_line|#undef GETC
)brace
multiline_comment|/* stuff a character into the transmit buffer, using PPP&squot;s way of escaping&n;   special characters.&n;   also, update fcs to take account of new character */
r_extern
r_inline
r_void
DECL|function|ppp_stuff_char
id|ppp_stuff_char
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_register
r_struct
id|ppp_buffer
op_star
id|buf
comma
r_register
id|__u8
id|chr
)paren
(brace
multiline_comment|/*&n; * The buffer should not be full.&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
(brace
r_if
c_cond
(paren
(paren
id|buf-&gt;count
OL
l_int|0
)paren
op_logical_or
(paren
id|buf-&gt;count
OG
l_int|3000
)paren
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp_stuff_char: %d %x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|buf-&gt;count
comma
(paren
r_int
r_int
)paren
id|chr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the FCS and if the character needs to be escaped, do it.&n; */
id|buf-&gt;fcs
op_assign
id|PPP_FCS
(paren
id|buf-&gt;fcs
comma
id|chr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_xmap
(paren
id|ppp
comma
id|chr
)paren
)paren
(brace
id|chr
op_xor_assign
id|PPP_TRANS
suffix:semicolon
id|ins_char
(paren
id|buf
comma
id|PPP_ESCAPE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the character to the buffer.&n; */
id|ins_char
(paren
id|buf
comma
id|chr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedure to encode the data with the proper escaping and send the&n; * data to the remote system.&n; */
r_static
r_void
DECL|function|ppp_dev_xmit_lower
id|ppp_dev_xmit_lower
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_buffer
op_star
id|buf
comma
id|__u8
op_star
id|data
comma
r_int
id|count
comma
r_int
id|non_ip
)paren
(brace
id|__u16
id|write_fcs
suffix:semicolon
r_int
id|address
comma
id|control
suffix:semicolon
r_int
id|proto
suffix:semicolon
id|CHECK_PPP_VOID
c_func
(paren
)paren
suffix:semicolon
id|CHECK_BUF_MAGIC
c_func
(paren
id|buf
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.ppp_opackets
suffix:semicolon
id|ppp-&gt;stats.ppp_ooctects
op_add_assign
id|count
suffix:semicolon
multiline_comment|/*&n; * Insert the leading FLAG character&n; */
id|buf-&gt;count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|non_ip
op_logical_or
id|flag_time
op_eq
l_int|0
)paren
id|ins_char
(paren
id|buf
comma
id|PPP_FLAG
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|jiffies
op_minus
id|ppp-&gt;last_xmit
op_ge
id|flag_time
)paren
id|ins_char
(paren
id|buf
comma
id|PPP_FLAG
)paren
suffix:semicolon
)brace
id|ppp-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
id|buf-&gt;fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
multiline_comment|/*&n; * Emit the address/control information if needed&n; */
id|address
op_assign
id|PPP_ADDRESS
(paren
id|data
)paren
suffix:semicolon
id|control
op_assign
id|PPP_CONTROL
(paren
id|data
)paren
suffix:semicolon
id|proto
op_assign
id|PPP_PROTOCOL
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ne
id|PPP_ALLSTATIONS
op_logical_or
id|control
op_ne
id|PPP_UI
op_logical_or
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_eq
l_int|0
)paren
(brace
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
id|address
)paren
suffix:semicolon
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
id|control
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Emit the protocol (compressed if possible)&n; */
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
op_eq
l_int|0
op_logical_or
(paren
id|proto
op_amp
l_int|0xFF00
)paren
)paren
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
id|proto
op_rshift
l_int|8
)paren
suffix:semicolon
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
id|proto
)paren
suffix:semicolon
multiline_comment|/*&n; * Insert the data&n; */
id|data
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
op_star
id|data
op_increment
)paren
suffix:semicolon
multiline_comment|/*&n; * Add the trailing CRC and the final flag character&n; */
id|write_fcs
op_assign
id|buf-&gt;fcs
op_xor
l_int|0xFFFF
suffix:semicolon
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
id|write_fcs
)paren
suffix:semicolon
id|ppp_stuff_char
(paren
id|ppp
comma
id|buf
comma
id|write_fcs
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n; * Add the trailing flag character&n; */
id|ins_char
(paren
id|buf
comma
id|PPP_FLAG
)paren
suffix:semicolon
multiline_comment|/*&n; * Send the block to the tty driver.&n; */
id|ppp-&gt;stats.ppp_obytes
op_add_assign
id|buf-&gt;count
suffix:semicolon
id|ppp_kick_tty
(paren
id|ppp
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Compress and send an frame to the peer.&n; *&n; * Return 0 if frame was queued for transmission.&n; *&t;  1 if frame must be re-queued for later driver support.&n; */
r_static
r_int
DECL|function|ppp_dev_xmit_frame
id|ppp_dev_xmit_frame
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_buffer
op_star
id|buf
comma
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
r_int
id|proto
suffix:semicolon
r_int
id|address
comma
id|control
suffix:semicolon
id|__u8
op_star
id|new_data
suffix:semicolon
r_int
id|new_count
suffix:semicolon
id|CHECK_PPP
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|CHECK_BUF_MAGIC
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/*&n; * Print the buffer&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOG_OUTPKT
)paren
id|ppp_print_buffer
(paren
l_string|&quot;write frame&quot;
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Determine if the frame may be compressed. Attempt to compress the&n; * frame if possible.&n; */
id|proto
op_assign
id|PPP_PROTOCOL
(paren
id|data
)paren
suffix:semicolon
id|address
op_assign
id|PPP_ADDRESS
(paren
id|data
)paren
suffix:semicolon
id|control
op_assign
id|PPP_CONTROL
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_RUN
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ppp-&gt;sc_xc_state
op_ne
(paren
r_void
op_star
)paren
l_int|0
)paren
op_logical_and
(paren
id|address
op_eq
id|PPP_ALLSTATIONS
)paren
op_logical_and
(paren
id|control
op_eq
id|PPP_UI
)paren
op_logical_and
(paren
id|proto
op_ne
id|PPP_LCP
)paren
op_logical_and
(paren
id|proto
op_ne
id|PPP_CCP
)paren
)paren
(brace
id|new_data
op_assign
id|kmalloc
(paren
id|ppp-&gt;mtu
op_plus
id|PPP_HDRLEN
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_dev_xmit_frame: no memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|new_count
op_assign
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;compress
)paren
(paren
id|ppp-&gt;sc_xc_state
comma
id|data
comma
id|new_data
comma
id|count
comma
id|ppp-&gt;mtu
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_count
OG
l_int|0
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
)paren
(brace
id|ppp_dev_xmit_lower
(paren
id|ppp
comma
id|buf
comma
id|new_data
comma
id|new_count
comma
l_int|0
)paren
suffix:semicolon
id|kfree
(paren
id|new_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The frame could not be compressed, or it could not be sent in&n; * compressed form because CCP is not yet up.&n; */
id|kfree
(paren
id|new_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Go to the escape encoding&n; */
id|ppp_dev_xmit_lower
(paren
id|ppp
comma
id|buf
comma
id|data
comma
id|count
comma
op_logical_neg
op_logical_neg
(paren
id|proto
op_amp
l_int|0xFF00
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Revise the tty frame for specific protocols.&n; */
r_static
r_int
DECL|function|send_revise_frame
id|send_revise_frame
(paren
r_register
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
id|__u8
op_star
id|p
suffix:semicolon
r_switch
c_cond
(paren
id|PPP_PROTOCOL
(paren
id|data
)paren
)paren
(brace
multiline_comment|/*&n; * Update the LQR frame with the current MIB information. This saves having&n; * the daemon read old MIB data from the driver.&n; */
r_case
id|PPP_LQR
suffix:colon
id|len
op_assign
l_int|48
suffix:semicolon
multiline_comment|/* total size of this frame */
id|p
op_assign
(paren
id|__u8
op_star
)paren
op_amp
id|data
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* Point to last two items. */
id|p
op_assign
id|store_long
(paren
id|p
comma
id|ppp-&gt;stats.ppp_opackets
op_plus
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|store_long
(paren
id|p
comma
id|ppp-&gt;stats.ppp_ooctects
op_plus
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Outbound compression frames&n; */
r_case
id|PPP_CCP
suffix:colon
id|ppp_proto_ccp
(paren
id|ppp
comma
id|data
op_plus
id|PPP_HDRLEN
comma
id|len
op_minus
id|PPP_HDRLEN
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * write a frame with NR chars from BUF to TTY&n; * we have to put the FCS field on ourselves&n; */
r_static
id|ssize_t
DECL|function|ppp_tty_write
id|ppp_tty_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
id|__u8
op_star
id|data
comma
r_int
id|count
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
id|__u8
op_star
id|new_data
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Verify the pointers.&n; */
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
r_goto
id|out
suffix:semicolon
id|CHECK_PPP
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
multiline_comment|/*&n; * Ensure that the caller does not wish to send too much.&n; */
r_if
c_cond
(paren
id|count
OG
id|PPP_MTU
op_plus
id|PPP_HDRLEN
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ppp_tty_write: truncating user packet &quot;
l_string|&quot;from %lu to mtu %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|count
comma
id|PPP_MTU
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
id|count
op_assign
id|PPP_MTU
op_plus
id|PPP_HDRLEN
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a buffer for the data and fetch it from the user space.&n; */
id|new_data
op_assign
id|kmalloc
(paren
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_tty_write: no memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Retrieve the user&squot;s buffer&n; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|new_data
comma
id|data
comma
id|count
)paren
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/*&n; * Lock this PPP unit so we will be the only writer,&n; * sleeping if necessary.&n; *&n; * Note that we add our task to the wait queue before&n; * attempting to lock, as the lock flag may be cleared&n; * from an interrupt.&n; */
id|add_wait_queue
c_func
(paren
op_amp
id|ppp-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|lock_buffer
c_func
(paren
id|ppp-&gt;tbuf
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppp
op_logical_or
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
op_logical_or
op_logical_neg
id|ppp-&gt;inuse
op_logical_or
id|tty
op_ne
id|ppp-&gt;tty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppp_tty_write: %p invalid after wait!&bslash;n&quot;
comma
id|ppp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ppp-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/*&n; * Change the LQR frame&n; */
id|count
op_assign
id|send_revise_frame
(paren
id|ppp
comma
id|new_data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Send the data&n; */
r_if
c_cond
(paren
id|PPP_PROTOCOL
c_func
(paren
id|new_data
)paren
op_eq
id|PPP_IP
)paren
(brace
multiline_comment|/*&n;&t;&t; * IP frames can be sent by pppd when we&squot;re doing&n;&t;&t; * demand-dialling.  We send them via ppp_dev_xmit_ip&n;&t;&t; * to make sure that VJ compression happens properly.&n;&t;&t; */
id|ppp_dev_xmit_ip
c_func
(paren
id|ppp
comma
id|ppp-&gt;tbuf
comma
id|new_data
op_plus
id|PPP_HDRLEN
comma
id|count
op_minus
id|PPP_HDRLEN
comma
id|NPMODE_PASS
)paren
suffix:semicolon
)brace
r_else
(brace
id|ppp_dev_xmit_frame
(paren
id|ppp
comma
id|ppp-&gt;tbuf
comma
id|new_data
comma
id|count
)paren
suffix:semicolon
)brace
id|error
op_assign
id|count
suffix:semicolon
id|out_free
suffix:colon
id|kfree
(paren
id|new_data
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the set-compression ioctl.&n; */
r_static
r_int
DECL|function|ppp_set_compression
id|ppp_set_compression
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_option_data
op_star
id|odp
)paren
(brace
r_struct
id|compressor
op_star
id|cp
suffix:semicolon
r_int
id|error
comma
id|nb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u8
op_star
id|ptr
suffix:semicolon
id|__u8
id|ccp_option
(braket
id|CCP_MAX_OPTION_LENGTH
)braket
suffix:semicolon
r_struct
id|ppp_option_data
id|data
suffix:semicolon
multiline_comment|/*&n; * Fetch the compression parameters&n; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|data
comma
id|odp
comma
r_sizeof
(paren
id|data
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|nb
op_assign
id|data.length
suffix:semicolon
id|ptr
op_assign
id|data.ptr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__u32
)paren
id|nb
op_ge
(paren
id|__u32
)paren
id|CCP_MAX_OPTION_LENGTH
)paren
id|nb
op_assign
id|CCP_MAX_OPTION_LENGTH
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|ccp_option
comma
id|ptr
comma
id|nb
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ccp_option
(braket
l_int|1
)braket
OL
l_int|2
)paren
multiline_comment|/* preliminary check on the length byte */
r_goto
id|out
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|data.transmit
ques
c_cond
id|SC_COMP_RUN
suffix:colon
id|SC_DECOMP_RUN
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cp
op_assign
id|find_compressor
(paren
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
r_char
id|modname
(braket
l_int|32
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|modname
comma
l_string|&quot;ppp-compress-%d&quot;
comma
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|request_module
c_func
(paren
id|modname
)paren
suffix:semicolon
id|cp
op_assign
id|find_compressor
c_func
(paren
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KMOD */
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_goto
id|out_no_comp
suffix:semicolon
multiline_comment|/*&n;&t; * Found a handler for the protocol - try to allocate&n;&t; * a compressor or decompressor.&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data.transmit
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_free
)paren
(paren
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_xc_state
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;sc_xcomp
op_assign
id|cp
suffix:semicolon
id|ppp-&gt;sc_xc_state
op_assign
id|cp
op_member_access_from_pointer
id|comp_alloc
c_func
(paren
id|ccp_option
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: comp_alloc failed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: comp_alloc -&gt; %p&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|ppp-&gt;sc_xc_state
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_free
)paren
(paren
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;sc_rcomp
op_assign
id|cp
suffix:semicolon
id|ppp-&gt;sc_rc_state
op_assign
id|cp
op_member_access_from_pointer
id|decomp_alloc
c_func
(paren
id|ccp_option
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: decomp_alloc failed&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: decomp_alloc -&gt; %p&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|ppp-&gt;sc_rc_state
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|out_no_comp
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* no handler found */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: no compressor for [%x %x %x], %x&bslash;n&quot;
comma
id|ppp-&gt;name
comma
id|ccp_option
(braket
l_int|0
)braket
comma
id|ccp_option
(braket
l_int|1
)braket
comma
id|ccp_option
(braket
l_int|2
)braket
comma
id|nb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the IOCTL event for the tty device.&n; */
r_static
r_int
DECL|function|ppp_tty_ioctl
id|ppp_tty_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|param2
comma
r_int
r_int
id|param3
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_register
r_int
id|temp_i
op_assign
l_int|0
comma
id|oldflags
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n; * Verify the status of the PPP device.&n; */
r_if
c_cond
(paren
op_logical_neg
id|ppp
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;magic
op_ne
id|PPP_MAGIC
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|CHECK_PPP
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
multiline_comment|/*&n; * The user must have an euid of root to do these requests.&n; */
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n; * Set the MRU value&n; */
r_switch
c_cond
(paren
id|param2
)paren
(brace
r_case
id|PPPIOCSMRU
suffix:colon
id|error
op_assign
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set mru to %x&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;mru
op_ne
id|temp_i
)paren
id|ppp_changedmtu
(paren
id|ppp
comma
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|mtu
comma
id|temp_i
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Fetch the flags&n; */
r_case
id|PPPIOCGFLAGS
suffix:colon
id|temp_i
op_assign
(paren
id|ppp-&gt;flags
op_amp
id|SC_MASK
)paren
suffix:semicolon
macro_line|#ifndef CHECK_CHARACTERS /* Don&squot;t generate errors if we don&squot;t check chars. */
id|temp_i
op_or_assign
id|SC_RCV_B7_1
op_or
id|SC_RCV_B7_0
op_or
id|SC_RCV_ODDP
op_or
id|SC_RCV_EVNP
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|put_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the flags for the various options&n; */
r_case
id|PPPIOCSFLAGS
suffix:colon
id|error
op_assign
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|temp_i
op_and_assign
id|SC_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_OPEN
)paren
op_logical_and
(paren
id|temp_i
op_amp
id|SC_CCP_OPEN
)paren
op_eq
l_int|0
)paren
id|ppp_ccp_closed
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oldflags
op_assign
id|ppp-&gt;flags
suffix:semicolon
id|ppp-&gt;flags
op_assign
id|temp_i
op_or_assign
(paren
id|ppp-&gt;flags
op_amp
op_complement
id|SC_MASK
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldflags
op_or
id|temp_i
)paren
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set flags to %x&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the compression mode&n; */
r_case
id|PPPIOCSCOMPRESS
suffix:colon
id|error
op_assign
id|ppp_set_compression
(paren
id|ppp
comma
(paren
r_struct
id|ppp_option_data
op_star
)paren
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Retrieve the transmit async map&n; */
r_case
id|PPPIOCGASYNCMAP
suffix:colon
id|error
op_assign
id|put_user
c_func
(paren
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the transmit async map&n; */
r_case
id|PPPIOCSASYNCMAP
suffix:colon
id|error
op_assign
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
op_assign
id|temp_i
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set xmit asyncmap %x&bslash;n&quot;
comma
id|ppp-&gt;xmit_async_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the receive async map&n; */
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
id|error
op_assign
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|ppp-&gt;recv_async_map
op_assign
id|temp_i
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set rcv asyncmap %x&bslash;n&quot;
comma
id|ppp-&gt;recv_async_map
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Obtain the unit number for this device.&n; */
r_case
id|PPPIOCGUNIT
suffix:colon
id|error
op_assign
id|put_user
c_func
(paren
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|base_addr
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: get unit: %ld&bslash;n&quot;
comma
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|base_addr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the debug level&n; */
r_case
id|PPPIOCSDEBUG
suffix:colon
id|error
op_assign
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|temp_i
op_assign
(paren
id|temp_i
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
suffix:semicolon
id|temp_i
op_or_assign
(paren
id|ppp-&gt;flags
op_amp
op_complement
l_int|0x1F0000
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_or
id|temp_i
)paren
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set flags to %x&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
id|ppp-&gt;flags
op_assign
id|temp_i
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Get the debug level&n; */
r_case
id|PPPIOCGDEBUG
suffix:colon
id|temp_i
op_assign
(paren
id|ppp-&gt;flags
op_rshift
l_int|16
)paren
op_amp
l_int|0x1F
suffix:semicolon
id|error
op_assign
id|put_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Get the times since the last send/receive frame operation&n; */
r_case
id|PPPIOCGIDLE
suffix:colon
(brace
r_struct
id|ppp_idle
id|cur_ddinfo
suffix:semicolon
multiline_comment|/* change absolute times to relative times. */
id|cur_ddinfo.xmit_idle
op_assign
(paren
id|jiffies
op_minus
id|ppp-&gt;last_xmit
)paren
op_div
id|HZ
suffix:semicolon
id|cur_ddinfo.recv_idle
op_assign
(paren
id|jiffies
op_minus
id|ppp-&gt;last_recv
)paren
op_div
id|HZ
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param3
comma
op_amp
id|cur_ddinfo
comma
r_sizeof
(paren
id|cur_ddinfo
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n; * Retrieve the extended async map&n; */
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param3
comma
id|ppp-&gt;xmit_async_map
comma
r_sizeof
(paren
id|ppp-&gt;xmit_async_map
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the async extended map&n; */
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
(brace
id|__u32
id|temp_tbl
(braket
l_int|8
)braket
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|temp_tbl
comma
(paren
r_void
op_star
)paren
id|param3
comma
r_sizeof
(paren
id|temp_tbl
)paren
)paren
)paren
r_break
suffix:semicolon
id|temp_tbl
(braket
l_int|1
)braket
op_assign
l_int|0x00000000
suffix:semicolon
id|temp_tbl
(braket
l_int|2
)braket
op_and_assign
op_complement
l_int|0x40000000
suffix:semicolon
id|temp_tbl
(braket
l_int|3
)braket
op_or_assign
l_int|0x60000000
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_tbl
(braket
l_int|2
)braket
op_amp
id|temp_tbl
(braket
l_int|3
)braket
)paren
op_ne
l_int|0
op_logical_or
(paren
id|temp_tbl
(braket
l_int|4
)braket
op_amp
id|temp_tbl
(braket
l_int|5
)braket
)paren
op_ne
l_int|0
op_logical_or
(paren
id|temp_tbl
(braket
l_int|6
)braket
op_amp
id|temp_tbl
(braket
l_int|7
)braket
)paren
op_ne
l_int|0
)paren
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
id|memcpy
(paren
id|ppp-&gt;xmit_async_map
comma
id|temp_tbl
comma
r_sizeof
(paren
id|ppp-&gt;xmit_async_map
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set xasyncmap&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/*&n; * Set the maximum VJ header compression slot number.&n; */
r_case
id|PPPIOCSMAXCID
suffix:colon
id|error
op_assign
id|get_user
c_func
(paren
id|temp_i
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|temp_i
op_assign
(paren
id|temp_i
op_amp
l_int|255
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp_tty_ioctl: set maxcid to %d&bslash;n&quot;
comma
id|temp_i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_ne
l_int|NULL
)paren
id|slhc_free
(paren
id|ppp-&gt;slcomp
)paren
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;slcomp
op_assign
id|slhc_init
(paren
l_int|16
comma
id|temp_i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_tty_ioctl: &quot;
l_string|&quot;no space for compression buffers!&bslash;n&quot;
)paren
suffix:semicolon
id|ppp_release
(paren
id|ppp
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PPPIOCXFERUNIT
suffix:colon
id|ppp-&gt;backup_tty
op_assign
id|tty
suffix:semicolon
id|ppp-&gt;sc_xfer
op_assign
id|current-&gt;pid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGNPMODE
suffix:colon
r_case
id|PPPIOCSNPMODE
suffix:colon
(brace
r_struct
id|npioctl
id|npi
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|npi
comma
(paren
r_void
op_star
)paren
id|param3
comma
r_sizeof
(paren
id|npi
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|npi.protocol
op_ne
id|PPP_IP
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pppioc[gs]npmode: &quot;
l_string|&quot;invalid protocol %d&bslash;n&quot;
comma
id|npi.protocol
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|npi.protocol
op_assign
id|NP_IP
suffix:semicolon
r_if
c_cond
(paren
id|param2
op_eq
id|PPPIOCGNPMODE
)paren
(brace
id|npi.mode
op_assign
id|ppp-&gt;sc_npmode
(braket
id|npi.protocol
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param3
comma
op_amp
id|npi
comma
r_sizeof
(paren
id|npi
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|ppp-&gt;sc_npmode
(braket
id|npi.protocol
)braket
op_assign
id|npi.mode
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp: set np %d to %d&bslash;n&quot;
comma
id|npi.protocol
comma
id|npi.mode
)paren
suffix:semicolon
multiline_comment|/* N.B. Why is the busy flag cleared here? */
id|ppp2dev
c_func
(paren
id|ppp
)paren
op_member_access_from_pointer
id|tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n; * Allow users to read, but not set, the serial port parameters&n; */
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
id|error
op_assign
id|n_tty_ioctl
(paren
id|tty
comma
id|file
comma
id|param2
comma
id|param3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIONREAD
suffix:colon
(brace
r_int
id|count
op_assign
id|ppp-&gt;ubuf-&gt;tail
op_minus
id|ppp-&gt;ubuf-&gt;head
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|count
op_add_assign
(paren
id|ppp-&gt;ubuf-&gt;size
op_plus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|put_user
c_func
(paren
id|count
comma
(paren
r_int
op_star
)paren
id|param3
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n; *  All other ioctl() events will come here.&n; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ppp_tty_ioctl: &quot;
l_string|&quot;invalid ioctl=%x, addr=%lx&bslash;n&quot;
comma
id|param2
comma
id|param3
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * TTY callback.&n; *&n; * Process the poll() statement for the PPP device.&n; */
r_static
r_int
r_int
DECL|function|ppp_tty_poll
id|ppp_tty_poll
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|tty2ppp
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_logical_and
id|ppp-&gt;magic
op_eq
id|PPP_MAGIC
op_logical_and
id|tty
op_eq
id|ppp-&gt;tty
)paren
(brace
id|CHECK_PPP
(paren
l_int|0
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|ppp-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|ppp-&gt;write_wait
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* Must lock the user buffer area while checking. */
id|CHECK_BUF_MAGIC
c_func
(paren
id|ppp-&gt;ubuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;ubuf-&gt;head
op_ne
id|ppp-&gt;ubuf-&gt;tail
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;ubuf-&gt;locked
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_OTHER_CLOSED
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;tbuf-&gt;locked
op_eq
l_int|0
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * NETWORK OUTPUT&n; *    This routine accepts requests from the network layer&n; *    and attempts to deliver the packets.&n; *    It also includes various routines we are compelled to&n; *    have to make the network layer work (arp, etc...).&n; *************************************************************/
multiline_comment|/*&n; * Callback from the network layer when the device goes up.&n; */
r_static
r_int
DECL|function|ppp_dev_open
id|ppp_dev_open
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp2tty
(paren
id|ppp
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp: %s not connected to a TTY! can&squot;t go open!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp: channel %s going up for IP packets!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|CHECK_PPP
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback from the network layer when the ppp device goes down.&n; */
r_static
r_int
DECL|function|ppp_dev_close
id|ppp_dev_close
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp2tty
(paren
id|ppp
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n; * We don&squot;t do anything about the device going down. It is not important&n; * for us.&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ppp: channel %s going down for IP packets!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|CHECK_PPP
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * IOCTL operation to read the version of the driver.&n; */
r_static
r_int
DECL|function|ppp_dev_ioctl_version
id|ppp_dev_ioctl_version
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|result
op_assign
(paren
r_char
op_star
)paren
id|ifr-&gt;ifr_ifru.ifru_data
suffix:semicolon
r_int
id|len
op_assign
id|strlen
(paren
id|szVersion
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Move the version data&n; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|result
comma
id|szVersion
comma
id|len
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * IOCTL to read the statistics for the pppstats program.&n; */
r_static
r_int
DECL|function|ppp_dev_ioctl_stats
id|ppp_dev_ioctl_stats
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp_stats
op_star
id|result
comma
id|temp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n; * Supply the information for the caller. First move the version data&n; * then move the ppp stats; and finally the vj stats.&n; */
id|memset
(paren
op_amp
id|temp
comma
l_int|0
comma
r_sizeof
(paren
id|temp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|memcpy
(paren
op_amp
id|temp.p
comma
op_amp
id|ppp-&gt;stats
comma
r_sizeof
(paren
r_struct
id|pppstat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;slcomp
op_ne
l_int|NULL
)paren
(brace
id|temp.vj.vjs_packets
op_assign
id|ppp-&gt;slcomp-&gt;sls_o_compressed
op_plus
id|ppp-&gt;slcomp-&gt;sls_o_uncompressed
suffix:semicolon
id|temp.vj.vjs_compressed
op_assign
id|ppp-&gt;slcomp-&gt;sls_o_compressed
suffix:semicolon
id|temp.vj.vjs_searches
op_assign
id|ppp-&gt;slcomp-&gt;sls_o_searches
suffix:semicolon
id|temp.vj.vjs_misses
op_assign
id|ppp-&gt;slcomp-&gt;sls_o_misses
suffix:semicolon
id|temp.vj.vjs_errorin
op_assign
id|ppp-&gt;slcomp-&gt;sls_i_error
suffix:semicolon
id|temp.vj.vjs_tossed
op_assign
id|ppp-&gt;slcomp-&gt;sls_i_tossed
suffix:semicolon
id|temp.vj.vjs_uncompressedin
op_assign
id|ppp-&gt;slcomp-&gt;sls_i_uncompressed
suffix:semicolon
id|temp.vj.vjs_compressedin
op_assign
id|ppp-&gt;slcomp-&gt;sls_i_compressed
suffix:semicolon
)brace
)brace
id|result
op_assign
(paren
r_struct
id|ppp_stats
op_star
)paren
id|ifr-&gt;ifr_ifru.ifru_data
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|result
comma
op_amp
id|temp
comma
r_sizeof
(paren
id|temp
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * IOCTL to read the compression statistics for the pppstats program.&n; */
r_static
r_int
DECL|function|ppp_dev_ioctl_comp_stats
id|ppp_dev_ioctl_comp_stats
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp_comp_stats
op_star
id|result
comma
id|temp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n; * Supply the information for the caller.&n; */
id|memset
(paren
op_amp
id|temp
comma
l_int|0
comma
r_sizeof
(paren
id|temp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;sc_xc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_xcomp-&gt;comp_stat
)paren
(paren
id|ppp-&gt;sc_xc_state
comma
op_amp
id|temp.c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;sc_rc_state
op_ne
l_int|NULL
)paren
(paren
op_star
id|ppp-&gt;sc_rcomp-&gt;decomp_stat
)paren
(paren
id|ppp-&gt;sc_rc_state
comma
op_amp
id|temp.d
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Move the data to the caller&squot;s buffer&n; */
id|result
op_assign
(paren
r_struct
id|ppp_comp_stats
op_star
)paren
id|ifr-&gt;ifr_ifru.ifru_data
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|result
comma
op_amp
id|temp
comma
r_sizeof
(paren
id|temp
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback from the network layer to process the sockioctl functions.&n; */
r_static
r_int
DECL|function|ppp_dev_ioctl
id|ppp_dev_ioctl
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|CHECK_PPP_MAGIC
c_func
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/*&n; * Process the requests&n; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGPPPSTATS
suffix:colon
id|error
op_assign
id|ppp_dev_ioctl_stats
(paren
id|ppp
comma
id|ifr
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGPPPCSTATS
suffix:colon
id|error
op_assign
id|ppp_dev_ioctl_comp_stats
(paren
id|ppp
comma
id|ifr
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGPPPVER
suffix:colon
id|error
op_assign
id|ppp_dev_ioctl_version
(paren
id|ppp
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Send an IP frame to the remote with vj header compression.&n; *&n; * Return 0 if frame was queued for transmission.&n; *&t;  1 if frame must be re-queued for later driver support.&n; *&t;  -1 if frame should be dropped.&n; */
r_static
r_int
DECL|function|ppp_dev_xmit_ip
id|ppp_dev_xmit_ip
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_buffer
op_star
id|buf
comma
id|__u8
op_star
id|data
comma
r_int
id|len
comma
r_enum
id|NPmode
id|npmode
)paren
(brace
r_int
id|proto
op_assign
id|PPP_IP
suffix:semicolon
id|__u8
op_star
id|hdr
suffix:semicolon
multiline_comment|/*&n; * Branch on the type of processing for the IP frame.&n; */
r_switch
c_cond
(paren
id|npmode
)paren
(brace
r_case
id|NPMODE_PASS
suffix:colon
r_break
suffix:semicolon
r_case
id|NPMODE_QUEUE
suffix:colon
multiline_comment|/*&n;&t;&t; * We may not send the packet now, so drop it.&n;&t;&t; * XXX It would be nice to be able to return it to the&n;&t;&t; * network system to be queued and retransmitted later.&n;&t;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: returning frame&bslash;n&quot;
comma
id|ppp-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
r_case
id|NPMODE_ERROR
suffix:colon
r_case
id|NPMODE_DROP
suffix:colon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp_dev_xmit: npmode = %d on %s&bslash;n&quot;
comma
id|ppp-&gt;sc_npmode
(braket
id|NP_IP
)braket
comma
id|ppp-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ppp_dev_xmit: unknown npmode %d on %s&bslash;n&quot;
comma
id|ppp-&gt;sc_npmode
(braket
id|NP_IP
)braket
comma
id|ppp-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * At this point, the buffer will be transmitted. There is no other exit.&n; *&n; * Try to compress the header.&n; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_TCP
)paren
(brace
id|len
op_assign
id|slhc_compress
(paren
id|ppp-&gt;slcomp
comma
id|data
comma
id|len
comma
id|buf_base
(paren
id|ppp-&gt;cbuf
)paren
op_plus
id|PPP_HDRLEN
comma
op_amp
id|data
comma
(paren
id|ppp-&gt;flags
op_amp
id|SC_NO_TCP_CCID
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_amp
id|SL_TYPE_COMPRESSED_TCP
)paren
(brace
id|proto
op_assign
id|PPP_VJC_COMP
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_xor_assign
id|SL_TYPE_COMPRESSED_TCP
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_ge
id|SL_TYPE_UNCOMPRESSED_TCP
)paren
id|proto
op_assign
id|PPP_VJC_UNCOMP
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
(paren
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_or
l_int|0x40
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Send the frame&n; */
id|len
op_add_assign
id|PPP_HDRLEN
suffix:semicolon
id|hdr
op_assign
id|data
op_minus
id|PPP_HDRLEN
suffix:semicolon
id|hdr
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|hdr
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
id|hdr
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|hdr
(braket
l_int|3
)braket
op_assign
id|proto
suffix:semicolon
r_return
id|ppp_dev_xmit_frame
(paren
id|ppp
comma
id|buf
comma
id|hdr
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a non-IP data frame (such as an IPX frame) to the remote.&n; *&n; * Return 0 if frame was queued for transmission.&n; *&t;  1 if frame must be re-queued for later driver support.&n; */
r_static
r_int
DECL|function|ppp_dev_xmit_other
id|ppp_dev_xmit_other
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ppp
op_star
id|ppp
comma
id|__u8
op_star
id|data
comma
r_int
id|len
comma
r_int
id|proto
)paren
(brace
id|__u8
op_star
id|hdr
suffix:semicolon
multiline_comment|/*&n; * Send the frame&n; */
id|len
op_add_assign
id|PPP_HDRLEN
suffix:semicolon
id|hdr
op_assign
id|data
op_minus
id|PPP_HDRLEN
suffix:semicolon
id|hdr
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|hdr
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
id|hdr
(braket
l_int|2
)braket
op_assign
id|proto
op_rshift
l_int|8
suffix:semicolon
id|hdr
(braket
l_int|3
)braket
op_assign
id|proto
suffix:semicolon
r_return
id|ppp_dev_xmit_frame
(paren
id|ppp
comma
id|ppp-&gt;wbuf
comma
id|hdr
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a frame to the remote.&n; */
r_static
r_int
DECL|function|ppp_dev_xmit
id|ppp_dev_xmit
(paren
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|answer
comma
id|len
suffix:semicolon
id|__u8
op_star
id|data
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ppp2tty
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/*&n; * just a little sanity check.&n; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;ppp_dev_xmit: null packet!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Avoid timing problem should tty hangup while data is queued to be sent&n; */
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;inuse
)paren
(brace
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Validate the tty interface&n; */
r_if
c_cond
(paren
id|tty
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_dev_xmit: %s not connected to a TTY!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch the pointer to the data&n; */
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
id|data
op_assign
id|skb_data
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
(paren
id|__u8
op_star
)paren
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
(paren
id|KERN_CRIT
l_string|&quot;ppp_dev_xmit: %s Null skb data&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Detect a change in the transfer size&n; */
r_if
c_cond
(paren
id|ppp-&gt;mtu
op_ne
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|mtu
)paren
(brace
id|ppp_changedmtu
(paren
id|ppp
comma
id|ppp2dev
(paren
id|ppp
)paren
op_member_access_from_pointer
id|mtu
comma
id|ppp-&gt;mru
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Acquire the lock on the transmission buffer. If the buffer was busy then&n; * mark the device as busy.&n; * We also require that ppp-&gt;tbuf be unlocked, in order to serialize&n; * calls to ppp_dev_xmit_frame (which does compression) and the output&n; * of frames w.r.t. tty writes from pppd.&n; */
id|CHECK_BUF_MAGIC
c_func
(paren
id|ppp-&gt;wbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;tbuf-&gt;locked
op_logical_or
id|lock_buffer
(paren
id|ppp-&gt;wbuf
)paren
op_ne
l_int|0
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_DEBUG
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dev_xmit blocked, t=%lu w=%lu&bslash;n&quot;
comma
id|ppp-&gt;tbuf-&gt;locked
comma
id|ppp-&gt;wbuf-&gt;locked
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Look at the protocol in the skb to determine the difference between&n; * an IP frame and an IPX frame.&n; */
r_switch
c_cond
(paren
id|ntohs
(paren
id|skb-&gt;protocol
)paren
)paren
(brace
r_case
id|ETH_P_IPX
suffix:colon
id|answer
op_assign
id|ppp_dev_xmit_other
(paren
id|dev
comma
id|ppp
comma
id|data
comma
id|len
comma
id|PPP_IPX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_IP
suffix:colon
id|answer
op_assign
id|ppp_dev_xmit_ip
(paren
id|ppp
comma
id|ppp-&gt;wbuf
comma
id|data
comma
id|len
comma
id|ppp-&gt;sc_npmode
(braket
id|NP_IP
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* All others have no support at this time. */
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the end of the transmission. Release the buffer if it was sent.&n; */
r_if
c_cond
(paren
id|answer
op_eq
l_int|0
)paren
(brace
multiline_comment|/* packet queued OK */
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|ppp-&gt;wbuf-&gt;locked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|answer
OL
l_int|0
)paren
(brace
multiline_comment|/* packet should be dropped */
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|answer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* packet should be queued for later */
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|answer
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate the statistic information for the /proc/net/dev listing.&n; */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|ppp_dev_stats
id|ppp_dev_stats
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev2ppp
(paren
id|dev
)paren
suffix:semicolon
id|ppp-&gt;estats.rx_packets
op_assign
id|ppp-&gt;stats.ppp_ipackets
suffix:semicolon
id|ppp-&gt;estats.rx_errors
op_assign
id|ppp-&gt;stats.ppp_ierrors
suffix:semicolon
id|ppp-&gt;estats.tx_packets
op_assign
id|ppp-&gt;stats.ppp_opackets
suffix:semicolon
id|ppp-&gt;estats.tx_errors
op_assign
id|ppp-&gt;stats.ppp_oerrors
suffix:semicolon
id|ppp-&gt;estats.rx_bytes
op_assign
id|ppp-&gt;stats.ppp_ibytes
suffix:semicolon
id|ppp-&gt;estats.tx_bytes
op_assign
id|ppp-&gt;stats.ppp_obytes
suffix:semicolon
r_return
op_amp
id|ppp-&gt;estats
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * UTILITIES&n; *    Miscellany called by various functions above.&n; *************************************************************/
multiline_comment|/* Locate the previous instance of the PPP channel */
r_static
r_struct
id|ppp
op_star
DECL|function|ppp_find
id|ppp_find
(paren
r_int
id|pid_value
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
multiline_comment|/* try to find the device which this pid is already using */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;inuse
op_logical_and
id|ppp-&gt;sc_xfer
op_eq
id|pid_value
)paren
(brace
id|ppp-&gt;sc_xfer
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ppp
suffix:semicolon
)brace
multiline_comment|/* Collect hanged up channels */
DECL|function|ppp_sync
r_static
r_void
id|ppp_sync
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ppp-&gt;inuse
)paren
(brace
id|dev
op_assign
id|ppp2dev
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate or create a PPP channel */
r_static
r_struct
id|ppp
op_star
DECL|function|ppp_alloc
id|ppp_alloc
(paren
r_void
)paren
(brace
r_int
id|if_num
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
id|ppp_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* try to find an free device */
id|if_num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;inuse
)paren
)paren
(brace
multiline_comment|/* Reregister device */
id|dev
op_assign
id|ppp2dev
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|unregister_netdev
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cannot reregister ppp device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|ppp
suffix:semicolon
)brace
op_increment
id|if_num
suffix:semicolon
)brace
multiline_comment|/*&n; * There are no available units, so make a new one.&n; */
id|ppp
op_assign
(paren
r_struct
id|ppp
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|ppp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|ppp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ppp
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize channel control data */
id|set_bit
c_func
(paren
l_int|0
comma
op_amp
id|ppp-&gt;inuse
)paren
suffix:semicolon
id|ppp-&gt;line
op_assign
id|if_num
suffix:semicolon
id|ppp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|ppp-&gt;backup_tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ppp_last
op_eq
l_int|0
)paren
id|ppp_list
op_assign
id|ppp
suffix:semicolon
r_else
id|ppp_last-&gt;next
op_assign
id|ppp
suffix:semicolon
id|ppp_last
op_assign
id|ppp
suffix:semicolon
id|ppp-&gt;next
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|ppp2dev
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;init
op_assign
id|ppp_init_dev
suffix:semicolon
id|dev-&gt;name
op_assign
id|ppp-&gt;name
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;ppp%d&quot;
comma
id|if_num
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
(paren
id|__u32
)paren
id|if_num
suffix:semicolon
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|ppp
suffix:semicolon
multiline_comment|/* register device so that we can be ifconfig&squot;d */
multiline_comment|/* ppp_init_dev() will be called as a side-effect */
id|status
op_assign
id|register_netdev
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;registered device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ppp_alloc - register_netdev(%s) = %d failure.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
id|ppp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This one will forever be busy as it is not initialized */
)brace
r_return
id|ppp
suffix:semicolon
)brace
multiline_comment|/*&n; * Utility procedures to print a buffer in hex/ascii&n; */
r_static
r_void
DECL|function|ppp_print_hex
id|ppp_print_hex
(paren
r_register
id|__u8
op_star
id|out
comma
r_const
id|__u8
op_star
id|in
comma
r_int
id|count
)paren
(brace
r_register
id|__u8
id|next_ch
suffix:semicolon
r_static
r_char
id|hex
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|next_ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|hex
(braket
(paren
id|next_ch
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)braket
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|hex
(braket
id|next_ch
op_amp
l_int|0x0F
)braket
suffix:semicolon
op_increment
id|out
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ppp_print_char
id|ppp_print_char
(paren
r_register
id|__u8
op_star
id|out
comma
r_const
id|__u8
op_star
id|in
comma
r_int
id|count
)paren
(brace
r_register
id|__u8
id|next_ch
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|next_ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|next_ch
template_param
l_int|0x7e
)paren
op_star
id|out
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
r_else
(brace
op_star
id|out
op_increment
op_assign
id|next_ch
suffix:semicolon
r_if
c_cond
(paren
id|next_ch
op_eq
l_char|&squot;%&squot;
)paren
multiline_comment|/* printk/syslogd has a bug !! */
op_star
id|out
op_increment
op_assign
l_char|&squot;%&squot;
suffix:semicolon
)brace
)brace
op_star
id|out
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_print_buffer
id|ppp_print_buffer
(paren
r_const
id|__u8
op_star
id|name
comma
r_const
id|__u8
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|__u8
id|line
(braket
l_int|44
)braket
suffix:semicolon
r_if
c_cond
(paren
id|name
op_ne
(paren
id|__u8
op_star
)paren
l_int|NULL
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;ppp: %s, count = %d&bslash;n&quot;
comma
id|name
comma
id|count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|8
)paren
(brace
id|memset
(paren
id|line
comma
l_int|32
comma
l_int|44
)paren
suffix:semicolon
id|ppp_print_hex
(paren
id|line
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
id|ppp_print_char
(paren
op_amp
id|line
(braket
l_int|8
op_star
l_int|3
)braket
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
id|count
op_sub_assign
l_int|8
suffix:semicolon
id|buf
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|memset
(paren
id|line
comma
l_int|32
comma
l_int|44
)paren
suffix:semicolon
id|ppp_print_hex
(paren
id|line
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|ppp_print_char
(paren
op_amp
id|line
(braket
l_int|8
op_star
l_int|3
)braket
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*************************************************************&n; * Compressor module interface&n; *************************************************************/
DECL|struct|compressor_link
r_struct
id|compressor_link
(brace
DECL|member|next
r_struct
id|compressor_link
op_star
id|next
suffix:semicolon
DECL|member|comp
r_struct
id|compressor
op_star
id|comp
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ppp_compressors
r_static
r_struct
id|compressor_link
op_star
id|ppp_compressors
op_assign
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
suffix:semicolon
DECL|function|find_compressor
r_static
r_struct
id|compressor
op_star
id|find_compressor
(paren
r_int
id|type
)paren
(brace
r_struct
id|compressor_link
op_star
id|lnk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|lnk
op_assign
id|ppp_compressors
suffix:semicolon
r_while
c_loop
(paren
id|lnk
op_ne
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|__u8
)paren
id|lnk-&gt;comp-&gt;compress_proto
op_eq
id|type
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|lnk-&gt;comp
suffix:semicolon
)brace
id|lnk
op_assign
id|lnk-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
r_struct
id|compressor
op_star
)paren
l_int|0
suffix:semicolon
)brace
DECL|function|ppp_register_compressor
r_static
r_int
id|ppp_register_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
(brace
r_struct
id|compressor_link
op_star
r_new
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|compressor_link
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|compressor_link
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_compressor
(paren
id|cp-&gt;compress_proto
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|next
op_assign
id|ppp_compressors
suffix:semicolon
r_new
op_member_access_from_pointer
id|comp
op_assign
id|cp
suffix:semicolon
id|ppp_compressors
op_assign
r_new
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppp_unregister_compressor
r_static
r_void
id|ppp_unregister_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
(brace
r_struct
id|compressor_link
op_star
id|prev
op_assign
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
suffix:semicolon
r_struct
id|compressor_link
op_star
id|lnk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|lnk
op_assign
id|ppp_compressors
suffix:semicolon
r_while
c_loop
(paren
id|lnk
op_ne
(paren
r_struct
id|compressor_link
op_star
)paren
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lnk-&gt;comp
op_eq
id|cp
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|lnk-&gt;next
suffix:semicolon
r_else
id|ppp_compressors
op_assign
id|lnk-&gt;next
suffix:semicolon
id|kfree
(paren
id|lnk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|lnk
suffix:semicolon
id|lnk
op_assign
id|lnk-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * Module support routines&n; *************************************************************/
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* register our line disciplines */
id|status
op_assign
id|ppp_first_time
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP: ppp_init() failure %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
comma
op_star
id|next_ppp
suffix:semicolon
r_int
id|busy_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Ensure that the devices are not in operation.&n; */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|ppp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;inuse
op_logical_and
id|ppp-&gt;tty
op_ne
l_int|NULL
)paren
(brace
id|busy_flag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev
op_assign
id|ppp2dev
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;start
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|busy_flag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Ensure that there are no compressor modules registered&n; */
r_if
c_cond
(paren
id|ppp_compressors
op_ne
l_int|NULL
)paren
id|busy_flag
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|busy_flag
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP: device busy, remove delayed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the tty registration of the line discipline so that no new entries&n; * may be created.&n; */
id|status
op_assign
id|tty_register_ldisc
(paren
id|N_PPP
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP: Unable to unregister ppp line discipline &quot;
l_string|&quot;(err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_else
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP: ppp line discipline successfully unregistered&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * De-register the devices so that there is no problem with them&n; */
r_for
c_loop
(paren
id|ppp
op_assign
id|ppp_list
suffix:semicolon
id|ppp
op_ne
l_int|0
suffix:semicolon
id|ppp
op_assign
id|next_ppp
)paren
(brace
id|next_ppp
op_assign
id|ppp-&gt;next
suffix:semicolon
id|ppp_release
(paren
id|ppp
)paren
suffix:semicolon
id|unregister_netdev
(paren
op_amp
id|ppp-&gt;dev
)paren
suffix:semicolon
id|kfree
(paren
id|ppp
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
