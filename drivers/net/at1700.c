multiline_comment|/* at1700.c: A network device driver for  the Allied Telesis AT1700.&n;&n;&t;Written 1993-98 by Donald Becker.&n;&n;&t;Copyright 1993 United States Government as represented by the&n;&t;Director, National Security Agency.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;&t;The author may be reached as becker@CESDIS.gsfc.nasa.gov, or C/O&n;&t;Center of Excellence in Space Data and Information Sciences&n;&t;   Code 930.5, Goddard Space Flight Center, Greenbelt MD 20771&n;&n;&t;This is a device driver for the Allied Telesis AT1700, and&n;        Fujitsu FMV-181/182/181A/182A/183/184/183A/184A, which are&n;&t;straight-forward Fujitsu MB86965 implementations.&n;&n;&t;Modification for Fujitsu FMV-18X cards is done by Yutaka Tamiya&n;&t;(tamy@flab.fujitsu.co.jp). &n;&n;  Sources:&n;    The Fujitsu MB86965 datasheet.&n;&n;&t;After the initial version of this driver was written Gerry Sawkins of&n;&t;ATI provided their EEPROM configuration code header file.&n;    Thanks to NIIBE Yutaka &lt;gniibe@mri.co.jp&gt; for bug fixes.&n;&n;    MCA bus (AT1720) support by Rene Schmit &lt;rene@bss.lu&gt;&n;&n;  Bugs:&n;&t;The MB86965 has a design flaw that makes all probes unreliable.  Not&n;&t;only is it difficult to detect, it also moves around in I/O space in&n;&t;response to inb()s from other device probes!&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;at1700.c:v1.15 4/7/98  Donald Becker (becker@cesdis.gsfc.nasa.gov)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
multiline_comment|/* Tunable parameters. */
multiline_comment|/* When to switch from the 64-entry multicast filter to Rx-all-multicast. */
DECL|macro|MC_FILTERBREAK
mdefine_line|#define MC_FILTERBREAK 64
multiline_comment|/* These unusual address orders are used to verify the CONFIG register. */
DECL|variable|fmv18x_probe_list
r_static
r_int
id|fmv18x_probe_list
(braket
)braket
op_assign
(brace
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2a0
comma
l_int|0x2c0
comma
l_int|0x300
comma
l_int|0x340
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;ISA&n; */
DECL|variable|at1700_probe_list
r_static
r_int
id|at1700_probe_list
(braket
)braket
op_assign
(brace
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2a0
comma
l_int|0x240
comma
l_int|0x340
comma
l_int|0x320
comma
l_int|0x380
comma
l_int|0x300
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;MCA&n; */
macro_line|#ifdef CONFIG_MCA&t;
DECL|variable|at1700_ioaddr_pattern
r_static
r_int
id|at1700_ioaddr_pattern
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x04
comma
l_int|0x01
comma
l_int|0x05
comma
l_int|0x02
comma
l_int|0x06
comma
l_int|0x03
comma
l_int|0x07
)brace
suffix:semicolon
DECL|variable|at1700_mca_probe_list
r_static
r_int
id|at1700_mca_probe_list
(braket
)braket
op_assign
(brace
l_int|0x400
comma
l_int|0x1400
comma
l_int|0x2400
comma
l_int|0x3400
comma
l_int|0x4400
comma
l_int|0x5400
comma
l_int|0x6400
comma
l_int|0x7400
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|at1700_irq_pattern
r_static
r_int
id|at1700_irq_pattern
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x30
comma
l_int|0x70
comma
l_int|0xb0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xf0
comma
l_int|0x34
comma
l_int|0x74
comma
l_int|0xb4
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xf4
comma
l_int|0x00
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 1
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
DECL|typedef|uchar
r_typedef
r_int
r_char
id|uchar
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|mc_filter
r_int
r_char
id|mc_filter
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|jumpered
id|uint
id|jumpered
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Set iff the board has jumper config. */
DECL|member|tx_started
id|uint
id|tx_started
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Packets are on the Tx queue. */
DECL|member|tx_queue_ready
id|uint
id|tx_queue_ready
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Tx queue is ready to be sent. */
DECL|member|rx_started
id|uint
id|rx_started
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Packets are Rxing. */
DECL|member|tx_queue
id|uchar
id|tx_queue
suffix:semicolon
multiline_comment|/* Number of packet on the Tx queue. */
DECL|member|mca_slot
r_char
id|mca_slot
suffix:semicolon
multiline_comment|/* -1 means ISA */
DECL|member|tx_queue_len
id|ushort
id|tx_queue_len
suffix:semicolon
multiline_comment|/* Current length of the Tx queue. */
)brace
suffix:semicolon
multiline_comment|/* Offsets from the base address. */
DECL|macro|STATUS
mdefine_line|#define STATUS&t;&t;&t;0
DECL|macro|TX_STATUS
mdefine_line|#define TX_STATUS&t;&t;0
DECL|macro|RX_STATUS
mdefine_line|#define RX_STATUS&t;&t;1
DECL|macro|TX_INTR
mdefine_line|#define TX_INTR&t;&t;&t;2&t;&t;/* Bit-mapped interrupt enable registers. */
DECL|macro|RX_INTR
mdefine_line|#define RX_INTR&t;&t;&t;3
DECL|macro|TX_MODE
mdefine_line|#define TX_MODE&t;&t;&t;4
DECL|macro|RX_MODE
mdefine_line|#define RX_MODE&t;&t;&t;5
DECL|macro|CONFIG_0
mdefine_line|#define CONFIG_0&t;&t;6&t;&t;/* Misc. configuration settings. */
DECL|macro|CONFIG_1
mdefine_line|#define CONFIG_1&t;&t;7
multiline_comment|/* Run-time register bank 2 definitions. */
DECL|macro|DATAPORT
mdefine_line|#define DATAPORT&t;&t;8&t;&t;/* Word-wide DMA or programmed-I/O dataport. */
DECL|macro|TX_START
mdefine_line|#define TX_START&t;&t;10
DECL|macro|COL16CNTL
mdefine_line|#define COL16CNTL&t;&t;11&t;&t;/* Controll Reg for 16 collisions */
DECL|macro|MODE13
mdefine_line|#define MODE13&t;&t;&t;13
multiline_comment|/* Configuration registers only on the &squot;865A/B chips. */
DECL|macro|EEPROM_Ctrl
mdefine_line|#define EEPROM_Ctrl &t;16
DECL|macro|EEPROM_Data
mdefine_line|#define EEPROM_Data &t;17
DECL|macro|CARDSTATUS
mdefine_line|#define CARDSTATUS&t;16&t;&t;&t;/* FMV-18x Card Status */
DECL|macro|CARDSTATUS1
mdefine_line|#define CARDSTATUS1&t;17&t;&t;&t;/* FMV-18x Card Status */
DECL|macro|IOCONFIG
mdefine_line|#define IOCONFIG&t;&t;18&t;&t;/* Either read the jumper, or move the I/O. */
DECL|macro|IOCONFIG1
mdefine_line|#define IOCONFIG1&t;&t;19
DECL|macro|SAPROM
mdefine_line|#define&t;SAPROM&t;&t;&t;20&t;&t;/* The station address PROM, if no EEPROM. */
DECL|macro|RESET
mdefine_line|#define RESET&t;&t;&t;31&t;&t;/* Write to reset some parts of the chip. */
DECL|macro|AT1700_IO_EXTENT
mdefine_line|#define AT1700_IO_EXTENT&t;32
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT&t;&t;10
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|at1700_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|at1700_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
suffix:semicolon
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
macro_line|#ifdef CONFIG_MCA
DECL|struct|at1720_mca_adapters_struct
r_struct
id|at1720_mca_adapters_struct
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|id
r_int
id|id
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* rEnE : maybe there are others I don&squot;t know off... */
DECL|variable|at1720_mca_adapters
r_struct
id|at1720_mca_adapters_struct
id|at1720_mca_adapters
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Allied Telesys AT1720AT&quot;
comma
l_int|0x6410
)brace
comma
(brace
l_string|&quot;Allied Telesys AT1720BT&quot;
comma
l_int|0x6413
)brace
comma
(brace
l_string|&quot;Allied Telesys AT1720T&quot;
comma
l_int|0x6416
)brace
comma
(brace
l_int|NULL
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   */
DECL|function|at1700_probe
r_int
id|__init
id|at1700_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|at1700_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|at1700_probe_list
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
id|at1700_probe_list
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|at1700_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* The Fujitsu datasheet suggests that the NIC be probed for by checking its&n;   &quot;signature&quot;, the default bit pattern after a reset.  This *doesn&squot;t* work --&n;   there is no way to reset the bus interface without a complete power-cycle!&n;&n;   It turns out that ATI came to the same conclusion I did: the only thing&n;   that can be done is checking a few bits and then diving right into an&n;   EEPROM read. */
DECL|function|at1700_probe1
r_static
r_int
id|at1700_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_char
id|fmv_irqmap
(braket
l_int|4
)braket
op_assign
(brace
l_int|3
comma
l_int|7
comma
l_int|10
comma
l_int|15
)brace
suffix:semicolon
r_char
id|fmv_irqmap_pnp
(braket
l_int|8
)braket
op_assign
(brace
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|15
)brace
suffix:semicolon
r_char
id|at1700_irqmap
(braket
l_int|8
)braket
op_assign
(brace
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|14
comma
l_int|15
)brace
suffix:semicolon
r_int
r_int
id|i
comma
id|irq
comma
id|is_fmv18x
op_assign
l_int|0
comma
id|is_at1700
op_assign
l_int|0
suffix:semicolon
r_int
id|slot
comma
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|AT1700_IO_EXTENT
comma
id|dev-&gt;name
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Resetting the chip doesn&squot;t reset the ISA interface, so don&squot;t bother.&n;&t;   That means we have to be careful with the register values we probe for.&n;&t;   */
macro_line|#ifdef notdef
id|printk
c_func
(paren
l_string|&quot;at1700 probe at %#x, eeprom is %4.4x %4.4x %4.4x ctrl %4.4x.&bslash;n&quot;
comma
id|ioaddr
comma
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
)paren
comma
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
)paren
comma
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|6
)paren
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MCA
multiline_comment|/* rEnE (rene@bss.lu): got this from 3c509 driver source , adapted for AT1720 */
multiline_comment|/* Based on Erik Nygren&squot;s (nygren@mit.edu) 3c529 patch, heavily&n;&t;modified by Chris Beauregard (cpbeaure@csclub.uwaterloo.ca)&n;&t;to support standard MCA probing. */
multiline_comment|/* redone for multi-card detection by ZP Gu (zpg@castle.net) */
multiline_comment|/* now works as a module */
r_if
c_cond
(paren
id|MCA_bus
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|l_i
suffix:semicolon
id|u_char
id|pos3
comma
id|pos4
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|at1720_mca_adapters
(braket
id|j
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|j
op_increment
)paren
(brace
id|slot
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_ne
id|MCA_NOTFOUND
)paren
(brace
id|slot
op_assign
id|mca_find_unused_adapter
c_func
(paren
id|at1720_mca_adapters
(braket
id|j
)braket
dot
id|id
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|MCA_NOTFOUND
)paren
r_break
suffix:semicolon
multiline_comment|/* if we get this far, an adapter has been detected and is&n;&t;&t;&t;&t;enabled */
id|pos3
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
suffix:semicolon
id|pos4
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l_i
op_assign
l_int|0
suffix:semicolon
id|l_i
OL
l_int|0x09
suffix:semicolon
id|l_i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pos3
op_amp
l_int|0x07
)paren
op_eq
id|at1700_ioaddr_pattern
(braket
id|l_i
)braket
)paren
r_break
suffix:semicolon
id|ioaddr
op_assign
id|at1700_mca_probe_list
(braket
id|l_i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
l_int|0x10
suffix:semicolon
id|irq
op_increment
)paren
r_if
c_cond
(paren
(paren
(paren
(paren
(paren
id|pos4
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_or
(paren
id|pos3
op_amp
l_int|0xf0
)paren
)paren
op_amp
l_int|0xff
)paren
op_eq
id|at1700_irq_pattern
(braket
id|irq
)braket
)paren
r_break
suffix:semicolon
multiline_comment|/* probing for a card at a particular IO/IRQ */
r_if
c_cond
(paren
id|dev
op_logical_and
(paren
(paren
id|dev-&gt;irq
op_logical_and
id|dev-&gt;irq
op_ne
id|irq
)paren
op_logical_or
(paren
id|dev-&gt;base_addr
op_logical_and
id|dev-&gt;base_addr
op_ne
id|ioaddr
)paren
)paren
)paren
(brace
id|slot
op_increment
suffix:semicolon
multiline_comment|/* probing next slot */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
)paren
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
multiline_comment|/* claim the slot */
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
id|at1720_mca_adapters
(braket
id|j
)braket
dot
id|name
)paren
suffix:semicolon
id|mca_mark_as_used
c_func
(paren
id|slot
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
)brace
multiline_comment|/* if we get here, we didn&squot;t find an MCA adapter - try ISA */
)brace
macro_line|#endif
id|slot
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We must check for the EEPROM-config boards first, else accessing&n;&t;   IOCONFIG0 will move the board! */
r_if
c_cond
(paren
id|at1700_probe_list
(braket
id|inb
c_func
(paren
id|ioaddr
op_plus
id|IOCONFIG1
)paren
op_amp
l_int|0x07
)braket
op_eq
id|ioaddr
op_logical_and
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
)paren
op_eq
l_int|0x0000
op_logical_and
(paren
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
)paren
op_amp
l_int|0xff00
)paren
op_eq
l_int|0xF400
)paren
id|is_at1700
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SAPROM
)paren
op_eq
l_int|0x00
op_logical_and
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SAPROM
op_plus
l_int|1
)paren
op_eq
l_int|0x00
op_logical_and
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SAPROM
op_plus
l_int|2
)paren
op_eq
l_int|0x0e
)paren
id|is_fmv18x
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MCA
id|found
suffix:colon
macro_line|#endif
multiline_comment|/* Reset the internal state machines. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_at1700
)paren
id|irq
op_assign
id|at1700_irqmap
(braket
(paren
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|12
)paren
op_amp
l_int|0x04
)paren
op_or
(paren
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|0
)paren
op_rshift
l_int|14
)paren
)braket
suffix:semicolon
r_else
(brace
multiline_comment|/* Check PnP mode for FMV-183/184/183A/184A. */
multiline_comment|/* This PnP routine is very poor. IO and IRQ should be known. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|CARDSTATUS1
)paren
op_amp
l_int|0x20
)paren
(brace
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq
op_eq
id|fmv_irqmap_pnp
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|8
)paren
(brace
r_goto
id|err_out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|fmv18x_probe_list
(braket
id|inb
c_func
(paren
id|ioaddr
op_plus
id|IOCONFIG
)paren
op_amp
l_int|0x07
)braket
op_ne
id|ioaddr
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|irq
op_assign
id|fmv_irqmap
(braket
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|IOCONFIG
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
)braket
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;%s: %s found at %#3x, IRQ %d, address &quot;
comma
id|dev-&gt;name
comma
id|is_at1700
ques
c_cond
l_string|&quot;AT1700&quot;
suffix:colon
l_string|&quot;FMV-18X&quot;
comma
id|ioaddr
comma
id|irq
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|is_at1700
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|eeprom_val
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
op_plus
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%04x&quot;
comma
id|eeprom_val
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
)paren
(braket
id|i
)braket
op_assign
id|ntohs
c_func
(paren
id|eeprom_val
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|val
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SAPROM
op_plus
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|val
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
)brace
)brace
multiline_comment|/* The EEPROM word 12 bit 0x0400 means use regular 100 ohm 10baseT signals,&n;&t;   rather than 150 ohm shielded twisted pair compensation.&n;&t;   0x0000 == auto-sense the interface&n;&t;   0x0800 == use TP interface&n;&t;   0x1800 == use coax interface&n;&t;   */
(brace
r_const
r_char
op_star
id|porttype
(braket
)braket
op_assign
(brace
l_string|&quot;auto-sense&quot;
comma
l_string|&quot;10baseT&quot;
comma
l_string|&quot;auto-sense&quot;
comma
l_string|&quot;10base2&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|is_at1700
)paren
(brace
id|ushort
id|setup_value
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|12
)paren
suffix:semicolon
id|dev-&gt;if_port
op_assign
id|setup_value
op_rshift
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|ushort
id|setup_value
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|CARDSTATUS
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|setup_value
op_amp
l_int|0x07
)paren
(brace
r_case
l_int|0x01
suffix:colon
multiline_comment|/* 10base5 */
r_case
l_int|0x02
suffix:colon
multiline_comment|/* 10base2 */
id|dev-&gt;if_port
op_assign
l_int|0x18
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
multiline_comment|/* 10baseT */
id|dev-&gt;if_port
op_assign
l_int|0x08
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* auto-sense */
id|dev-&gt;if_port
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; %s interface.&bslash;n&quot;
comma
id|porttype
(braket
(paren
id|dev-&gt;if_port
op_rshift
l_int|3
)paren
op_amp
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the configuration register 0 to 32K 100ns. byte-wide memory, 16 bit&n;&t;   bus access, two 4K Tx queues, and disabled Tx and Rx. */
id|outb
c_func
(paren
l_int|0xda
comma
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
multiline_comment|/* Set the station address in bank zero. */
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|CONFIG_1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|ioaddr
op_plus
l_int|8
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Switch to bank 1 and set the multicast table to accept none. */
id|outb
c_func
(paren
l_int|0x04
comma
id|ioaddr
op_plus
id|CONFIG_1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
l_int|8
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Switch to bank 2 */
multiline_comment|/* Lock our I/O address, and set manual processing mode for 16 collisions. */
id|outb
c_func
(paren
l_int|0x08
comma
id|ioaddr
op_plus
id|CONFIG_1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;if_port
comma
id|ioaddr
op_plus
id|MODE13
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|COL16CNTL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|net_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|net_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_rx_mode
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|net_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Fill in the fields of &squot;dev&squot; with ethernet-generic values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;jumpered
op_assign
id|is_fmv18x
suffix:semicolon
id|lp-&gt;mca_slot
op_assign
id|slot
suffix:semicolon
multiline_comment|/* Snarf the interrupt vector now. */
id|ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
op_amp
id|net_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
(paren
l_string|&quot;  AT1700 at %#3x is unusable due to a conflict on&quot;
l_string|&quot;IRQ %d.&bslash;n&quot;
comma
id|ioaddr
comma
id|irq
)paren
suffix:semicolon
r_goto
id|err_out_priv
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_out_priv
suffix:colon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|err_out
suffix:colon
id|release_region
c_func
(paren
id|ioaddr
comma
id|AT1700_IO_EXTENT
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
"&f;"
multiline_comment|/*  EEPROM_Ctrl bits. */
DECL|macro|EE_SHIFT_CLK
mdefine_line|#define EE_SHIFT_CLK&t;0x40&t;/* EEPROM shift clock, in reg. 16. */
DECL|macro|EE_CS
mdefine_line|#define EE_CS&t;&t;&t;0x20&t;/* EEPROM chip select, in reg. 16. */
DECL|macro|EE_DATA_WRITE
mdefine_line|#define EE_DATA_WRITE&t;0x80&t;/* EEPROM chip data in, in reg. 17. */
DECL|macro|EE_DATA_READ
mdefine_line|#define EE_DATA_READ&t;0x80&t;/* EEPROM chip data out, in reg. 17. */
multiline_comment|/* Delay between EEPROM clock transitions. */
DECL|macro|eeprom_delay
mdefine_line|#define eeprom_delay()&t;do {} while (0);
multiline_comment|/* The EEPROM commands include the alway-set leading bit. */
DECL|macro|EE_WRITE_CMD
mdefine_line|#define EE_WRITE_CMD&t;(5 &lt;&lt; 6)
DECL|macro|EE_READ_CMD
mdefine_line|#define EE_READ_CMD&t;&t;(6 &lt;&lt; 6)
DECL|macro|EE_ERASE_CMD
mdefine_line|#define EE_ERASE_CMD&t;(7 &lt;&lt; 6)
DECL|function|read_eeprom
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|ee_addr
op_assign
id|ioaddr
op_plus
id|EEPROM_Ctrl
suffix:semicolon
r_int
id|ee_daddr
op_assign
id|ioaddr
op_plus
id|EEPROM_Data
suffix:semicolon
r_int
id|read_cmd
op_assign
id|location
op_or
id|EE_READ_CMD
suffix:semicolon
multiline_comment|/* Shift the read command bits out. */
r_for
c_loop
(paren
id|i
op_assign
l_int|9
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|dataval
op_assign
(paren
id|read_cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|EE_DATA_WRITE
suffix:colon
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|EE_CS
comma
id|ee_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dataval
comma
id|ee_daddr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|EE_CS
op_or
id|EE_SHIFT_CLK
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* EEPROM clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|EE_DATA_WRITE
comma
id|ee_daddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outb
c_func
(paren
id|EE_CS
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|EE_CS
op_or
id|EE_SHIFT_CLK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|inb
c_func
(paren
id|ee_daddr
)paren
op_amp
id|EE_DATA_READ
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate the EEPROM access. */
id|outb
c_func
(paren
id|EE_CS
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|EE_SHIFT_CLK
comma
id|ee_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ee_addr
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
"&f;"
DECL|function|net_open
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* Set the configuration register 0 to 32K 100ns. byte-wide memory, 16 bit&n;&t;   bus access, and two 4K Tx queues. */
id|outb
c_func
(paren
l_int|0x5a
comma
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
multiline_comment|/* Powerup, switch to register bank 2, and enable the Rx and Tx. */
id|outb
c_func
(paren
l_int|0xe8
comma
id|ioaddr
op_plus
id|CONFIG_1
)paren
suffix:semicolon
id|lp-&gt;tx_started
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue_ready
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;rx_started
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn on hardware Tx and Rx interrupts. */
id|outb
c_func
(paren
l_int|0x82
comma
id|ioaddr
op_plus
id|TX_INTR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x81
comma
id|ioaddr
op_plus
id|RX_INTR
)paren
suffix:semicolon
multiline_comment|/* Enable the IRQ on boards of fmv18x it is feasible. */
r_if
c_cond
(paren
id|lp-&gt;jumpered
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
comma
id|ioaddr
op_plus
id|IOCONFIG1
)paren
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|net_tx_timeout
r_static
r_void
id|net_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: transmit timed out with status %04x, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
(paren
id|ioaddr
op_plus
id|STATUS
)paren
comma
id|inb
(paren
id|ioaddr
op_plus
id|TX_STATUS
)paren
op_amp
l_int|0x80
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: timeout registers: %04x %04x %04x %04x %04x %04x %04x %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|0
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|2
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|4
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|6
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|8
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|10
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|12
)paren
comma
id|inw
(paren
id|ioaddr
op_plus
l_int|14
)paren
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* ToDo: We should try to restart the adaptor... */
id|outw
(paren
l_int|0xffff
comma
id|ioaddr
op_plus
l_int|24
)paren
suffix:semicolon
id|outw
(paren
l_int|0xffff
comma
id|ioaddr
op_plus
id|TX_STATUS
)paren
suffix:semicolon
id|outb
(paren
l_int|0x5a
comma
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
id|outb
(paren
l_int|0xe8
comma
id|ioaddr
op_plus
id|CONFIG_1
)paren
suffix:semicolon
id|outw
(paren
l_int|0x8182
comma
id|ioaddr
op_plus
id|TX_INTR
)paren
suffix:semicolon
id|outb
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|TX_START
)paren
suffix:semicolon
id|outb
(paren
l_int|0x03
comma
id|ioaddr
op_plus
id|COL16CNTL
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;tx_started
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue_ready
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;rx_started
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|net_send_packet
r_static
r_int
id|net_send_packet
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* We may not start transmitting unless we finish transferring&n;&t;   a packet into the Tx queue. During executing the following&n;&t;   codes we possibly catch a Tx interrupt. Thus we flag off&n;&t;   tx_queue_ready, so that we prevent the interrupt routine&n;&t;   (net_interrupt) to start transmitting. */
id|lp-&gt;tx_queue_ready
op_assign
l_int|0
suffix:semicolon
(brace
id|outw
(paren
id|length
comma
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
id|outsw
(paren
id|ioaddr
op_plus
id|DATAPORT
comma
id|buf
comma
(paren
id|length
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|lp-&gt;tx_queue
op_increment
suffix:semicolon
id|lp-&gt;tx_queue_len
op_add_assign
id|length
op_plus
l_int|2
suffix:semicolon
)brace
id|lp-&gt;tx_queue_ready
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_started
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If the Tx is idle, always trigger a transmit. */
id|outb
(paren
l_int|0x80
op_or
id|lp-&gt;tx_queue
comma
id|ioaddr
op_plus
id|TX_START
)paren
suffix:semicolon
id|lp-&gt;tx_queue
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;tx_started
op_assign
l_int|1
suffix:semicolon
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;tx_queue_len
OL
l_int|4096
op_minus
l_int|1502
)paren
multiline_comment|/* Yes, there is room for one more packet. */
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
r_static
r_void
DECL|function|net_interrupt
id|net_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;at1700_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|TX_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status
comma
id|ioaddr
op_plus
id|TX_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Interrupt with status %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_started
op_eq
l_int|0
op_logical_and
(paren
id|status
op_amp
l_int|0xff00
op_logical_or
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|RX_MODE
)paren
op_amp
l_int|0x40
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Got a packet(s).&n;&t;&t;   We cannot execute net_rx more than once at the same time for&n;&t;&t;   the same device. During executing net_rx, we possibly catch a&n;&t;&t;   Tx interrupt. Thus we flag on rx_started, so that we prevent&n;&t;&t;   the interrupt routine (net_interrupt) to dive into net_rx&n;&t;&t;   again. */
id|lp-&gt;rx_started
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|RX_INTR
)paren
suffix:semicolon
multiline_comment|/* Disable RX intr. */
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x81
comma
id|ioaddr
op_plus
id|RX_INTR
)paren
suffix:semicolon
multiline_comment|/* Enable  RX intr. */
id|lp-&gt;rx_started
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x00ff
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x02
)paren
(brace
multiline_comment|/* More than 16 collisions occurred */
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: 16 Collision occur during Txing.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Cancel sending a packet. */
id|outb
c_func
(paren
l_int|0x03
comma
id|ioaddr
op_plus
id|COL16CNTL
)paren
suffix:semicolon
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x82
)paren
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* The Tx queue has any packets and is not being&n;&t;&t;&t;   transferred a packet from the host, start&n;&t;&t;&t;   transmitting. */
r_if
c_cond
(paren
id|lp-&gt;tx_queue
op_logical_and
id|lp-&gt;tx_queue_ready
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
op_or
id|lp-&gt;tx_queue
comma
id|ioaddr
op_plus
id|TX_START
)paren
suffix:semicolon
id|lp-&gt;tx_queue
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;tx_started
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
r_static
r_void
DECL|function|net_rx
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|5
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|RX_MODE
)paren
op_amp
l_int|0x40
)paren
op_eq
l_int|0
)paren
(brace
id|ushort
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
id|ushort
id|pkt_len
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Rxing packet mode %02x status %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|ioaddr
op_plus
id|RX_MODE
)paren
comma
id|status
)paren
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|outb
c_func
(paren
l_int|0x05
comma
id|ioaddr
op_plus
l_int|14
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0xF0
)paren
op_ne
l_int|0x20
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x08
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x04
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x02
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|pkt_len
OG
l_int|1550
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: The AT1700 claimed a very large packet, size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Prime the FIFO and then flush the packet. */
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x05
comma
id|ioaddr
op_plus
l_int|14
)paren
suffix:semicolon
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet (len %d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Prime the FIFO and then flush the packet. */
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x05
comma
id|ioaddr
op_plus
l_int|14
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
(paren
id|pkt_len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|boguscount
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* If any worth-while packets have been received, dev_rint()&n;&t;   has done a mark_bh(NET_BH) for us and will work on them&n;&t;   when we get to the bottom-half routine. */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|RX_MODE
)paren
op_amp
l_int|0x40
)paren
op_eq
l_int|0x40
)paren
r_break
suffix:semicolon
id|inw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
)paren
suffix:semicolon
multiline_comment|/* dummy status read */
id|outb
c_func
(paren
l_int|0x05
comma
id|ioaddr
op_plus
l_int|14
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Exint Rx packet with mode %02x after %d ticks.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|ioaddr
op_plus
id|RX_MODE
)paren
comma
id|i
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
DECL|function|net_close
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set configuration register 0 to disable Tx and Rx. */
id|outb
c_func
(paren
l_int|0xda
comma
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
multiline_comment|/* No statistic counters on the chip to update. */
multiline_comment|/* Disable the IRQ on boards of fmv18x where it is feasible. */
r_if
c_cond
(paren
id|lp-&gt;jumpered
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|IOCONFIG1
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Power-down the chip.  Green, green, green! */
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|CONFIG_1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&n;   This may be called with the card open or closed.&n;   There are no on-chip counters, so this function is trivial.&n;*/
r_static
r_struct
id|net_device_stats
op_star
DECL|function|net_get_stats
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n;  Set the multicast/promiscuous mode for this adaptor.&n;*/
multiline_comment|/* The little-endian AUTODIN II ethernet CRC calculation.&n;   N.B. Do not use for bulk data, use a table-based routine instead.&n;   This is common code and should be moved to net/core/crc.c */
DECL|variable|ethernet_polynomial_le
r_static
r_int
r_const
id|ethernet_polynomial_le
op_assign
l_int|0xedb88320U
suffix:semicolon
DECL|function|ether_crc_le
r_static
r_inline
r_int
id|ether_crc_le
c_func
(paren
r_int
id|length
comma
r_int
r_char
op_star
id|data
)paren
(brace
r_int
r_int
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Initial value. */
r_while
c_loop
(paren
op_decrement
id|length
op_ge
l_int|0
)paren
(brace
r_int
r_char
id|current_octet
op_assign
op_star
id|data
op_increment
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|8
suffix:semicolon
op_decrement
id|bit
op_ge
l_int|0
suffix:semicolon
id|current_octet
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|crc
op_xor
id|current_octet
)paren
op_amp
l_int|1
)paren
(brace
id|crc
op_rshift_assign
l_int|1
suffix:semicolon
id|crc
op_xor_assign
id|ethernet_polynomial_le
suffix:semicolon
)brace
r_else
id|crc
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|crc
suffix:semicolon
)brace
r_static
r_void
DECL|function|set_rx_mode
id|set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_char
id|mc_filter
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Multicast hash filter */
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Unconditionally log net taps. */
id|printk
c_func
(paren
l_string|&quot;%s: Promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|memset
c_func
(paren
id|mc_filter
comma
l_int|0xff
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|ioaddr
op_plus
id|RX_MODE
)paren
suffix:semicolon
multiline_comment|/* Enable promiscuous mode */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
OG
id|MC_FILTERBREAK
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
multiline_comment|/* Too many to filter perfectly -- accept all multicasts. */
id|memset
c_func
(paren
id|mc_filter
comma
l_int|0xff
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|ioaddr
op_plus
id|RX_MODE
)paren
suffix:semicolon
multiline_comment|/* Use normal mode. */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|mc_filter
comma
l_int|0x00
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|ioaddr
op_plus
id|RX_MODE
)paren
suffix:semicolon
multiline_comment|/* Ignore almost all multicasts. */
)brace
r_else
(brace
r_struct
id|dev_mc_list
op_star
id|mclist
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|mc_filter
comma
l_int|0
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mclist
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mclist
op_logical_and
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
comma
id|mclist
op_assign
id|mclist-&gt;next
)paren
id|set_bit
c_func
(paren
id|ether_crc_le
c_func
(paren
id|ETH_ALEN
comma
id|mclist-&gt;dmi_addr
)paren
op_rshift
l_int|26
comma
id|mc_filter
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mc_filter
comma
id|lp-&gt;mc_filter
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
)paren
(brace
r_int
id|saved_bank
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
multiline_comment|/* Switch to bank 1 and set the multicast table. */
id|outw
c_func
(paren
(paren
id|saved_bank
op_amp
op_complement
l_int|0x0C00
)paren
op_or
l_int|0x0480
comma
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|mc_filter
(braket
id|i
)braket
comma
id|ioaddr
op_plus
l_int|8
op_plus
id|i
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|lp-&gt;mc_filter
comma
id|mc_filter
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|saved_bank
comma
id|ioaddr
op_plus
id|CONFIG_0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|dev_at1700
r_static
r_struct
id|net_device
id|dev_at1700
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x260
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|net_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|io
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;at1700: You should not use auto-probing with insmod!&bslash;n&quot;
)paren
suffix:semicolon
id|dev_at1700.base_addr
op_assign
id|io
suffix:semicolon
id|dev_at1700.irq
op_assign
id|irq
suffix:semicolon
id|dev_at1700.init
op_assign
id|at1700_probe
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_at1700
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;at1700: register_netdev() returned non-zero.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_MCA&t;
r_struct
id|net_local
op_star
id|lp
op_assign
id|dev_at1700.priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;mca_slot
)paren
(brace
id|mca_mark_as_unused
c_func
(paren
id|lp-&gt;mca_slot
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
id|unregister_netdev
c_func
(paren
op_amp
id|dev_at1700
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev_at1700.priv
)paren
suffix:semicolon
id|dev_at1700.priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If we don&squot;t do this, we can&squot;t re-insmod it later. */
id|free_irq
c_func
(paren
id|dev_at1700.irq
comma
l_int|NULL
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev_at1700.base_addr
comma
id|AT1700_IO_EXTENT
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -c at1700.c&quot;&n; *  alt-compile-command: &quot;gcc -DMODVERSIONS -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -c at1700.c&quot;&n; *  tab-width: 4&n; *  c-basic-offset: 4&n; *  c-indent-level: 4&n; * End:&n; */
eof
