multiline_comment|/* atp.c: Attached (pocket) ethernet adapter driver for linux. */
multiline_comment|/*&n;&t;This is a driver for commonly OEM pocket (parallel port)&n;&t;ethernet adapters based on the Realtek RTL8002 and RTL8012 chips.&n;&n;&t;Written 1993-2000 by Donald Becker.&n;&n;&t;This software may be used and distributed according to the terms of&n;&t;the GNU General Public License (GPL), incorporated herein by reference.&n;&t;Drivers based on or derived from this code fall under the GPL and must&n;&t;retain the authorship, copyright and license notice.  This file is not&n;&t;a complete program and may only be used when the entire operating&n;&t;system is licensed under the GPL.&n;&n;&t;Copyright 1993 United States Government as represented by the Director,&n;&t;National Security Agency.  Copyright 1994-2000 retained by the original&n;&t;author, Donald Becker. The timer-based reset code was supplied in 1995&n;&t;by Bill Carlson, wwc@super.org.&n;&n;&t;The author may be reached as becker@scyld.com, or C/O&n;&t;Scyld Computing Corporation&n;&t;410 Severn Ave., Suite 210&n;&t;Annapolis MD 21403&n;&n;&t;Support information and updates available at&n;&t;http://www.scyld.com/network/atp.html&n;&n;&n;&t;Modular support/softnet added by Alan Cox.&n;&n;*/
DECL|variable|versionA
r_static
r_const
r_char
id|versionA
(braket
)braket
op_assign
l_string|&quot;atp.c:v1.09 8/9/2000 Donald Becker &lt;becker@scyld.com&gt;&bslash;n&quot;
suffix:semicolon
DECL|variable|versionB
r_static
r_const
r_char
id|versionB
(braket
)braket
op_assign
l_string|&quot;  http://www.scyld.com/network/atp.html&bslash;n&quot;
suffix:semicolon
multiline_comment|/* The user-configurable values.&n;   These may be modified when a driver module is loaded.*/
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 normal messages, 0 quiet .. 7 verbose. */
DECL|macro|net_debug
mdefine_line|#define net_debug debug
multiline_comment|/* Maximum events (Rx packets, etc.) to handle at each interrupt. */
DECL|variable|max_interrupt_work
r_static
r_int
id|max_interrupt_work
op_assign
l_int|15
suffix:semicolon
DECL|macro|NUM_UNITS
mdefine_line|#define NUM_UNITS 2
multiline_comment|/* The standard set of ISA module parameters. */
DECL|variable|io
r_static
r_int
id|io
(braket
id|NUM_UNITS
)braket
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|NUM_UNITS
)braket
suffix:semicolon
DECL|variable|xcvr
r_static
r_int
id|xcvr
(braket
id|NUM_UNITS
)braket
suffix:semicolon
multiline_comment|/* The data transfer mode. */
multiline_comment|/* Operational parameters that are set at compile time. */
multiline_comment|/* Time in jiffies before concluding the transmitter is hung. */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT  (400*HZ/1000)
multiline_comment|/*&n;&t;This file is a device driver for the RealTek (aka AT-Lan-Tec) pocket&n;&t;ethernet adapter.  This is a common low-cost OEM pocket ethernet&n;&t;adapter, sold under many names.&n;&n;  Sources:&n;&t;This driver was written from the packet driver assembly code provided by&n;&t;Vincent Bono of AT-Lan-Tec.&t; Ever try to figure out how a complicated&n;&t;device works just from the assembly code?  It ain&squot;t pretty.  The following&n;&t;description is written based on guesses and writing lots of special-purpose&n;&t;code to test my theorized operation.&n;&n;&t;In 1997 Realtek made available the documentation for the second generation&n;&t;RTL8012 chip, which has lead to several driver improvements.&n;&t;  http://www.realtek.com.tw/cn/cn.html&n;&n;&t;&t;&t;&t;&t;Theory of Operation&n;&n;&t;The RTL8002 adapter seems to be built around a custom spin of the SEEQ&n;&t;controller core.  It probably has a 16K or 64K internal packet buffer, of&n;&t;which the first 4K is devoted to transmit and the rest to receive.&n;&t;The controller maintains the queue of received packet and the packet buffer&n;&t;access pointer internally, with only &squot;reset to beginning&squot; and &squot;skip to next&n;&t;packet&squot; commands visible.  The transmit packet queue holds two (or more?)&n;&t;packets: both &squot;retransmit this packet&squot; (due to collision) and &squot;transmit next&n;&t;packet&squot; commands must be started by hand.&n;&n;&t;The station address is stored in a standard bit-serial EEPROM which must be&n;&t;read (ughh) by the device driver.  (Provisions have been made for&n;&t;substituting a 74S288 PROM, but I haven&squot;t gotten reports of any models&n;&t;using it.)  Unlike built-in devices, a pocket adapter can temporarily lose&n;&t;power without indication to the device driver.  The major effect is that&n;&t;the station address, receive filter (promiscuous, etc.) and transceiver&n;&t;must be reset.&n;&n;&t;The controller itself has 16 registers, some of which use only the lower&n;&t;bits.  The registers are read and written 4 bits at a time.  The four bit&n;&t;register address is presented on the data lines along with a few additional&n;&t;timing and control bits.  The data is then read from status port or written&n;&t;to the data port.&n;&n;&t;Correction: the controller has two banks of 16 registers.  The second&n;&t;bank contains only the multicast filter table (now used) and the EEPROM&n;&t;access registers.&n;&n;&t;Since the bulk data transfer of the actual packets through the slow&n;&t;parallel port dominates the driver&squot;s running time, four distinct data&n;&t;(non-register) transfer modes are provided by the adapter, two in each&n;&t;direction.  In the first mode timing for the nibble transfers is&n;&t;provided through the data port.  In the second mode the same timing is&n;&t;provided through the control port.  In either case the data is read from&n;&t;the status port and written to the data port, just as it is accessing&n;&t;registers.&n;&n;&t;In addition to the basic data transfer methods, several more are modes are&n;&t;created by adding some delay by doing multiple reads of the data to allow&n;&t;it to stabilize.  This delay seems to be needed on most machines.&n;&n;&t;The data transfer mode is stored in the &squot;dev-&gt;if_port&squot; field.  Its default&n;&t;value is &squot;4&squot;.  It may be overridden at boot-time using the third parameter&n;&t;to the &quot;ether=...&quot; initialization.&n;&n;&t;The header file &lt;atp.h&gt; provides inline functions that encapsulate the&n;&t;register and data access methods.  These functions are hand-tuned to&n;&t;generate reasonable object code.  This header file also documents my&n;&t;interpretations of the device registers.&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &quot;atp.h&quot;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Donald Becker &lt;becker@scyld.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;RealTek RTL8002/8012 parallel port Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_interrupt_work
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|xcvr
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|RUN_AT
mdefine_line|#define RUN_AT(x) (jiffies + (x))
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|ETHERCARD_TOTAL_SIZE
mdefine_line|#define ETHERCARD_TOTAL_SIZE&t;3
multiline_comment|/* Sequence to switch an 8012 from printer mux to ethernet mode. */
DECL|variable|mux_8012
r_static
r_char
id|mux_8012
(braket
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xf7
comma
l_int|0xff
comma
l_int|0xfb
comma
l_int|0xf3
comma
l_int|0xfb
comma
l_int|0xff
comma
l_int|0xf7
comma
)brace
suffix:semicolon
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|next_module
r_struct
id|net_device
op_star
id|next_module
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Media selection timer. */
DECL|member|last_rx_time
r_int
id|last_rx_time
suffix:semicolon
multiline_comment|/* Last Rx, in jiffies, to handle Rx hang. */
DECL|member|saved_tx_size
r_int
id|saved_tx_size
suffix:semicolon
DECL|member|tx_unit_busy
r_int
r_int
id|tx_unit_busy
suffix:colon
l_int|1
suffix:semicolon
DECL|member|re_tx
r_int
r_char
id|re_tx
comma
multiline_comment|/* Number of packet retransmissions. */
DECL|member|addr_mode
id|addr_mode
comma
multiline_comment|/* Current Rx filter e.g. promiscuous, etc. */
DECL|member|pac_cnt_in_tx_buf
id|pac_cnt_in_tx_buf
comma
DECL|member|chip_type
id|chip_type
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* This code, written by wwc@super.org, resets the adapter every&n;   TIMED_CHECKER ticks.  This recovers from an unknown error which&n;   hangs the device. */
DECL|macro|TIMED_CHECKER
mdefine_line|#define TIMED_CHECKER (HZ/4)
macro_line|#ifdef TIMED_CHECKER
macro_line|#include &lt;linux/timer.h&gt;
r_static
r_void
id|atp_timed_checker
c_func
(paren
r_int
r_int
id|ignored
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Index to functions, as function prototypes. */
r_static
r_int
id|atp_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|get_node_ID
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
r_int
id|eeprom_op
c_func
(paren
r_int
id|ioaddr
comma
r_int
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hardware_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|write_packet
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|packet
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_void
id|trigger_send
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_int
id|atp_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|atp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|read_block
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|data_mode
)paren
suffix:semicolon
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_rx_mode_8002
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_rx_mode_8012
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* A list of all installed ATP devices, for removing the driver module. */
DECL|variable|root_atp_dev
r_static
r_struct
id|net_device
op_star
id|root_atp_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check for a network adapter of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   */
DECL|function|atp_init
r_static
r_int
id|__init
id|atp_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
l_int|0x378
comma
l_int|0x278
comma
l_int|0x3bc
comma
l_int|0
)brace
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev
ques
c_cond
id|dev-&gt;base_addr
suffix:colon
id|io
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|atp_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_eq
l_int|1
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|ports
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
op_star
id|port
suffix:semicolon
id|outb
c_func
(paren
l_int|0x57
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PAR_DATA
)paren
op_ne
l_int|0x57
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|atp_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|atp_probe1
r_static
r_int
id|__init
id|atp_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|saved_ctrl_reg
comma
id|status
comma
id|i
suffix:semicolon
id|outb
c_func
(paren
l_int|0xff
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Save the original value of the Control register, in case we guessed&n;&t;   wrong. */
id|saved_ctrl_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;atp: Control register was %#2.2x.&bslash;n&quot;
comma
id|saved_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* IRQEN=0, SLCTB=high INITB=high, AUTOFDB=high, STBB=high. */
id|outb
c_func
(paren
l_int|0x04
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
multiline_comment|/* Turn off the printer multiplexer on the 8012. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|mux_8012
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|MODSEL
comma
l_int|0x00
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;atp: Registers are &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Turn off the printer multiplexer on the 8012. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|mux_8012
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
)paren
suffix:semicolon
multiline_comment|/* udelay() here? */
id|status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;atp: Status nibble was %#2.2x..&quot;
comma
id|status
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x78
)paren
op_ne
l_int|0x08
)paren
(brace
multiline_comment|/* The pocket adapter probe failed, restore the control register. */
id|outb
c_func
(paren
id|saved_ctrl_reg
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR2_h
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x78
)paren
op_ne
l_int|0x10
)paren
(brace
id|outb
c_func
(paren
id|saved_ctrl_reg
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|init_etherdev
c_func
(paren
id|dev
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Find the IRQ used by triggering an interrupt. */
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* No accept mode, IRQ out. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RxENABLE
op_or
id|CMR1h_TxENABLE
)paren
suffix:semicolon
multiline_comment|/* Enable Tx and Rx. */
multiline_comment|/* Omit autoIRQ routine for now. Use &quot;table lookup&quot; instead.  Uhgggh. */
r_if
c_cond
(paren
id|irq
(braket
l_int|0
)braket
)paren
id|dev-&gt;irq
op_assign
id|irq
(braket
l_int|0
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0x378
)paren
id|dev-&gt;irq
op_assign
l_int|7
suffix:semicolon
r_else
id|dev-&gt;irq
op_assign
l_int|5
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_TxRxOFF
)paren
suffix:semicolon
multiline_comment|/* Disable Tx and Rx units. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_NULL
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* Read the station address PROM.  */
id|get_node_ID
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifndef MODULE
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|versionA
comma
id|versionB
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Pocket adapter found at %#3lx, IRQ %d, SAPROM &quot;
l_string|&quot;%02X:%02X:%02X:%02X:%02X:%02X.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* Reset the ethernet hardware and activate the printer pass-through. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
op_or
id|CMR1h_MUX
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;chip_type
op_assign
id|RTL8002
suffix:semicolon
id|lp-&gt;addr_mode
op_assign
id|CMR2h_Normal
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|lp-&gt;next_module
op_assign
id|root_atp_dev
suffix:semicolon
id|root_atp_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* For the ATP adapter the &quot;if_port&quot; is really the data transfer mode. */
r_if
c_cond
(paren
id|xcvr
(braket
l_int|0
)braket
)paren
id|dev-&gt;if_port
op_assign
id|xcvr
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|dev-&gt;if_port
op_assign
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
ques
c_cond
(paren
id|dev-&gt;mem_start
op_amp
l_int|0x7
)paren
suffix:colon
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mem_end
op_amp
l_int|0xf
)paren
id|net_debug
op_assign
id|dev-&gt;mem_end
op_amp
l_int|7
suffix:semicolon
id|dev-&gt;open
op_assign
id|net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|net_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|atp_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|lp-&gt;chip_type
op_eq
id|RTL8002
ques
c_cond
op_amp
id|set_rx_mode_8002
suffix:colon
op_amp
id|set_rx_mode_8012
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the station address PROM, usually a word-wide EEPROM. */
DECL|function|get_node_ID
r_static
r_void
id|__init
id|get_node_ID
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|sa_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_EEPROM
)paren
suffix:semicolon
multiline_comment|/* Point to the EEPROM control registers. */
multiline_comment|/* Some adapters have the station address at offset 15 instead of offset&n;&t;   zero.  Check for it, and fix it if needed. */
r_if
c_cond
(paren
id|eeprom_op
c_func
(paren
id|ioaddr
comma
id|EE_READ
c_func
(paren
l_int|0
)paren
)paren
op_eq
l_int|0xffff
)paren
id|sa_offset
op_assign
l_int|15
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
id|u16
op_star
)paren
id|dev-&gt;dev_addr
)paren
(braket
id|i
)braket
op_assign
id|be16_to_cpu
c_func
(paren
id|eeprom_op
c_func
(paren
id|ioaddr
comma
id|EE_READ
c_func
(paren
id|sa_offset
op_plus
id|i
)paren
)paren
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  An EEPROM read command starts by shifting out 0x60+address, and then&n;  shifting in the serial data. See the NatSemi databook for details.&n; *&t;&t;   ________________&n; * CS : __|&n; *&t;&t;&t;   ___&t;   ___&n; * CLK: ______|&t;  |___|&t;  |&n; *&t;&t; __ _______ _______&n; * DI :&t; __X_______X_______X&n; * DO :&t; _________X_______X&n; */
DECL|function|eeprom_op
r_static
r_int
r_int
id|__init
id|eeprom_op
c_func
(paren
r_int
id|ioaddr
comma
r_int
r_int
id|cmd
)paren
(brace
r_int
id|eedata_out
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bits
op_assign
id|EE_CMD_SIZE
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|num_bits
op_ge
l_int|0
)paren
(brace
r_char
id|outval
op_assign
id|test_bit
c_func
(paren
id|num_bits
comma
op_amp
id|cmd
)paren
ques
c_cond
id|EE_DATA_WRITE
suffix:colon
l_int|0
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|PROM_CMD
comma
id|outval
op_or
id|EE_CLK_LOW
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|PROM_CMD
comma
id|outval
op_or
id|EE_CLK_HIGH
)paren
suffix:semicolon
id|eedata_out
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|PROM_DATA
)paren
op_amp
id|EE_DATA_READ
)paren
id|eedata_out
op_increment
suffix:semicolon
)brace
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|PROM_CMD
comma
id|EE_CLK_LOW
op_amp
op_complement
id|EE_CS
)paren
suffix:semicolon
r_return
id|eedata_out
suffix:semicolon
)brace
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine sets everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;&n;   This is an attachable device: if there is no dev-&gt;priv entry then it wasn&squot;t&n;   probed for at boot-time, and we need to probe for it again.&n;   */
DECL|function|net_open
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* The interrupt line is turned off (tri-stated) when the device isn&squot;t in&n;&t;   use.  That&squot;s especially important for &quot;attached&quot; interfaces where the&n;&t;   port or interrupt may be shared. */
id|ret
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|atp_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
id|lp-&gt;timer.expires
op_assign
id|RUN_AT
c_func
(paren
id|TIMED_CHECKER
)paren
suffix:semicolon
id|lp-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|lp-&gt;timer.function
op_assign
op_amp
id|atp_timed_checker
suffix:semicolon
multiline_comment|/* timer handler */
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine resets the hardware.  We initialize everything, assuming that&n;   the hardware may have been temporarily detached. */
DECL|function|hardware_init
r_static
r_void
id|hardware_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Turn off the printer multiplexer on the 8012. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|mux_8012
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Reset: current Rx mode %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR2_h
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_IRQOUT
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RxENABLE
op_or
id|CMR1h_TxENABLE
)paren
suffix:semicolon
multiline_comment|/* Enable the interrupt line from the serial port. */
id|outb
c_func
(paren
id|Ctrl_SelData
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Unmask the interesting interrupts. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISR_RxOK
op_or
id|ISR_TxErr
op_or
id|ISR_TxOK
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
id|lp-&gt;tx_unit_busy
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;pac_cnt_in_tx_buf
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;saved_tx_size
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|trigger_send
r_static
r_void
id|trigger_send
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
)paren
(brace
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|TxCNT0
comma
id|length
op_amp
l_int|0xff
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|TxCNT1
comma
id|length
op_rshift
l_int|8
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1_Xmit
)paren
suffix:semicolon
)brace
DECL|function|write_packet
r_static
r_void
id|write_packet
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|packet
comma
r_int
id|data_mode
)paren
(brace
id|length
op_assign
(paren
id|length
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
suffix:semicolon
multiline_comment|/* Round up to word length. */
id|outb
c_func
(paren
id|EOC
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data_mode
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Write the packet out, starting with the write addr. */
id|outb
c_func
(paren
id|WrAddr
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_do
(brace
id|write_byte_mode0
c_func
(paren
id|ioaddr
comma
op_star
id|packet
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Write the packet out in slow mode. */
r_int
r_char
id|outbyte
op_assign
op_star
id|packet
op_increment
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_LNibWrite
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|WrAddr
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|outbyte
op_amp
l_int|0x0f
)paren
op_or
l_int|0x40
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outbyte
op_amp
l_int|0x0f
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outbyte
op_rshift_assign
l_int|4
suffix:semicolon
id|outb
c_func
(paren
id|outbyte
op_amp
l_int|0x0f
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_HNibWrite
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
id|write_byte_mode1
c_func
(paren
id|ioaddr
comma
op_star
id|packet
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate the Tx frame.  End of write: ECB. */
id|outb
c_func
(paren
l_int|0xff
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_HNibWrite
op_or
id|Ctrl_SelData
op_or
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
)brace
DECL|function|tx_timeout
r_static
r_void
id|tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|np
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
op_amp
l_int|0x10
ques
c_cond
l_string|&quot;network cable problem&quot;
suffix:colon
l_string|&quot;IRQ conflict&quot;
)paren
suffix:semicolon
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* Try to restart the adapter. */
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|np-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|atp_send_packet
r_static
r_int
id|atp_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts by writing 0x00 to the Interrupt Mask Register.&n;&t;   This sequence must not be interrupted by an incoming packet. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
l_int|0
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|write_packet
c_func
(paren
id|ioaddr
comma
id|length
comma
id|skb-&gt;data
comma
id|dev-&gt;if_port
)paren
suffix:semicolon
id|lp-&gt;pac_cnt_in_tx_buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_unit_busy
op_eq
l_int|0
)paren
(brace
id|trigger_send
c_func
(paren
id|ioaddr
comma
id|length
)paren
suffix:semicolon
id|lp-&gt;saved_tx_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Redundant */
id|lp-&gt;re_tx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_unit_busy
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|lp-&gt;saved_tx_size
op_assign
id|length
suffix:semicolon
multiline_comment|/* Re-enable the LPT interrupts. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISR_RxOK
op_or
id|ISR_TxErr
op_or
id|ISR_TxOK
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
DECL|function|atp_interrupt
r_static
r_void
id|atp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_instance
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
suffix:semicolon
r_static
r_int
id|num_tx_since_rx
op_assign
l_int|0
suffix:semicolon
r_int
id|boguscount
op_assign
id|max_interrupt_work
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ATP_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Disable additional spurious interrupts. */
id|outb
c_func
(paren
id|Ctrl_SelData
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* The adapter&squot;s output is currently the IRQ line, switch it to data. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_NULL
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: In interrupt &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|boguscount
OG
l_int|0
)paren
(brace
r_int
id|status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|ISR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;loop status %02x..&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|ISR_RxOK
op_lshift
l_int|3
)paren
)paren
(brace
id|write_reg
c_func
(paren
id|ioaddr
comma
id|ISR
comma
id|ISR_RxOK
)paren
suffix:semicolon
multiline_comment|/* Clear the Rx interrupt. */
r_do
(brace
r_int
id|read_status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot;handling Rx packet %02x..&quot;
comma
id|read_status
)paren
suffix:semicolon
multiline_comment|/* We acknowledged the normal Rx interrupt, so if the interrupt&n;&t;&t;&t;&t;   is still outstanding we must have a Rx error. */
r_if
c_cond
(paren
id|read_status
op_amp
(paren
id|CMR1_IRQ
op_lshift
l_int|3
)paren
)paren
(brace
multiline_comment|/* Overrun. */
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
multiline_comment|/* Set to no-accept mode long enough to remove a packet. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2h_OFF
)paren
suffix:semicolon
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt and return to normal Rx mode. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|ISR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|read_status
op_amp
(paren
id|CMR1_BufEnb
op_lshift
l_int|3
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|num_tx_since_rx
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|boguscount
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
(paren
(paren
id|ISR_TxErr
op_plus
id|ISR_TxOK
)paren
op_lshift
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot;handling Tx done..&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear the Tx interrupt.  We should check for too many failures&n;&t;&t;&t;   and reinitialize the adapter. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|ISR
comma
id|ISR_TxErr
op_plus
id|ISR_TxOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|ISR_TxErr
op_lshift
l_int|3
)paren
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|lp-&gt;re_tx
OG
l_int|15
)paren
(brace
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Attempt to retransmit. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot;attempting to ReTx&quot;
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1_ReXmit
op_plus
id|CMR1_Xmit
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Finish up the transmit. */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;pac_cnt_in_tx_buf
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;saved_tx_size
)paren
(brace
id|trigger_send
c_func
(paren
id|ioaddr
comma
id|lp-&gt;saved_tx_size
)paren
suffix:semicolon
id|lp-&gt;saved_tx_size
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;re_tx
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|lp-&gt;tx_unit_busy
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
id|num_tx_since_rx
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num_tx_since_rx
OG
l_int|8
op_logical_and
id|jiffies
OG
id|dev-&gt;last_rx
op_plus
id|HZ
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Missed packet? No Rx after %d Tx and &quot;
l_string|&quot;%ld jiffies status %02x  CMR1 %02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|num_tx_since_rx
comma
id|jiffies
op_minus
id|dev-&gt;last_rx
comma
id|status
comma
(paren
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR1
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|15
)paren
suffix:semicolon
id|lp-&gt;stats.rx_missed_errors
op_increment
suffix:semicolon
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|num_tx_since_rx
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* This following code fixes a rare (and very difficult to track down)&n;&t;   problem where the adapter forgets its ethernet address. */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#if 0 &amp;&amp; defined(TIMED_CHECKER)
id|mod_timer
c_func
(paren
op_amp
id|lp-&gt;timer
comma
id|RUN_AT
c_func
(paren
id|TIMED_CHECKER
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Tell the adapter that it can go back to using the output line as IRQ. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_IRQOUT
)paren
suffix:semicolon
multiline_comment|/* Enable the physical interrupt line, which is sure to be low until.. */
id|outb
c_func
(paren
id|Ctrl_SelData
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* .. we enable the interrupt sources. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISR_RxOK
op_or
id|ISR_TxErr
op_or
id|ISR_TxOK
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
multiline_comment|/* Hmmm, really needed? */
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;exiting interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef TIMED_CHECKER
multiline_comment|/* This following code fixes a rare (and very difficult to track down)&n;   problem where the adapter forgets its ethernet address. */
DECL|function|atp_timed_checker
r_static
r_void
id|atp_timed_checker
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|lp-&gt;last_rx_time
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OG
l_int|2
op_star
id|HZ
)paren
(brace
macro_line|#if 1
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;last_rx_time
op_assign
id|jiffies
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|read_cmd_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
)paren
op_ne
id|atp_timed_dev-&gt;dev_addr
(braket
id|i
)braket
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|atp_timed_dev-&gt;priv
suffix:semicolon
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
comma
id|atp_timed_dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|2
)paren
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_eq
l_int|3
)paren
id|lp-&gt;stats.tx_dropped
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_eq
l_int|4
)paren
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
r_else
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|lp-&gt;timer.expires
op_assign
id|RUN_AT
c_func
(paren
id|TIMED_CHECKER
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
DECL|function|net_rx
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|rx_header
id|rx_head
suffix:semicolon
multiline_comment|/* Process the received packet. */
id|outb
c_func
(paren
id|EOC
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|read_block
c_func
(paren
id|ioaddr
comma
l_int|8
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|rx_head
comma
id|dev-&gt;if_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; rx_count %04x %04x %04x %04x..&quot;
comma
id|rx_head.pad
comma
id|rx_head.rx_count
comma
id|rx_head.rx_status
comma
id|rx_head.cur_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rx_head.rx_status
op_amp
l_int|0x77
)paren
op_ne
l_int|0x01
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_head.rx_status
op_amp
l_int|0x0004
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rx_head.rx_status
op_amp
l_int|0x0002
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Unknown ATP Rx error %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_head.rx_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rx_head.rx_status
op_amp
l_int|0x0020
)paren
(brace
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_TxENABLE
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RxENABLE
op_or
id|CMR1h_TxENABLE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rx_head.rx_status
op_amp
l_int|0x0050
)paren
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. The &quot;-4&quot; omits the FCS (CRC). */
r_int
id|pkt_len
op_assign
(paren
id|rx_head.rx_count
op_amp
l_int|0x7ff
)paren
op_minus
l_int|4
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align IP on 16 byte boundaries */
id|read_block
c_func
(paren
id|ioaddr
comma
id|pkt_len
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
id|dev-&gt;if_port
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
id|done
suffix:colon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1_NextPkt
)paren
suffix:semicolon
id|lp-&gt;last_rx_time
op_assign
id|jiffies
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|read_block
r_static
r_void
id|read_block
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|p
comma
r_int
id|data_mode
)paren
(brace
r_if
c_cond
(paren
id|data_mode
op_le
l_int|3
)paren
(brace
multiline_comment|/* Mode 0 or 1 */
id|outb
c_func
(paren
id|Ctrl_LNibRead
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|length
op_eq
l_int|8
ques
c_cond
id|RdAddr
op_or
id|HNib
op_or
id|MAR
suffix:colon
id|RdAddr
op_or
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_mode
op_le
l_int|1
)paren
(brace
multiline_comment|/* Mode 0 or 1 */
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Mode 2 or 3 */
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data_mode
op_le
l_int|5
)paren
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode4
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
r_else
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode6
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|EOC
op_plus
id|HNib
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_SelData
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|net_close
id|net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here. */
id|lp-&gt;addr_mode
op_assign
id|CMR2h_OFF
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2h_OFF
)paren
suffix:semicolon
multiline_comment|/* Free the IRQ line. */
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reset the ethernet hardware and activate the printer pass-through. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
op_or
id|CMR1h_MUX
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|net_device_stats
op_star
DECL|function|net_get_stats
id|net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set or clear the multicast filter for this adapter.&n; */
multiline_comment|/* The little-endian AUTODIN32 ethernet CRC calculation.&n;   This is common code and should be moved to net/core/crc.c */
DECL|variable|ethernet_polynomial_le
r_static
r_int
r_const
id|ethernet_polynomial_le
op_assign
l_int|0xedb88320U
suffix:semicolon
DECL|function|ether_crc_le
r_static
r_inline
r_int
id|ether_crc_le
c_func
(paren
r_int
id|length
comma
r_int
r_char
op_star
id|data
)paren
(brace
r_int
r_int
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Initial value. */
r_while
c_loop
(paren
op_decrement
id|length
op_ge
l_int|0
)paren
(brace
r_int
r_char
id|current_octet
op_assign
op_star
id|data
op_increment
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|8
suffix:semicolon
op_decrement
id|bit
op_ge
l_int|0
suffix:semicolon
id|current_octet
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|crc
op_xor
id|current_octet
)paren
op_amp
l_int|1
)paren
(brace
id|crc
op_rshift_assign
l_int|1
suffix:semicolon
id|crc
op_xor_assign
id|ethernet_polynomial_le
suffix:semicolon
)brace
r_else
id|crc
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|crc
suffix:semicolon
)brace
DECL|function|set_rx_mode_8002
r_static
r_void
id|set_rx_mode_8002
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mc_count
OG
l_int|0
op_logical_or
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_ALLMULTI
op_or
id|IFF_PROMISC
)paren
)paren
)paren
(brace
multiline_comment|/* We must make the kernel realise we had to move&n;&t;&t; *&t;into promisc mode or we start all out war on&n;&t;&t; *&t;the cable. - AC&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|lp-&gt;addr_mode
op_assign
id|CMR2h_PROMISC
suffix:semicolon
)brace
r_else
id|lp-&gt;addr_mode
op_assign
id|CMR2h_Normal
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
)brace
DECL|function|set_rx_mode_8012
r_static
r_void
id|set_rx_mode_8012
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|new_mode
comma
id|mc_filter
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Multicast hash filter */
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Set promiscuous. */
id|new_mode
op_assign
id|CMR2h_PROMISC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;mc_count
OG
l_int|1000
)paren
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
multiline_comment|/* Too many to filter perfectly -- accept all multicasts. */
id|memset
c_func
(paren
id|mc_filter
comma
l_int|0xff
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
id|new_mode
op_assign
id|CMR2h_Normal
suffix:semicolon
)brace
r_else
(brace
r_struct
id|dev_mc_list
op_star
id|mclist
suffix:semicolon
id|memset
c_func
(paren
id|mc_filter
comma
l_int|0
comma
r_sizeof
(paren
id|mc_filter
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mclist
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mclist
op_logical_and
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
comma
id|mclist
op_assign
id|mclist-&gt;next
)paren
id|set_bit
c_func
(paren
id|ether_crc_le
c_func
(paren
id|ETH_ALEN
comma
id|mclist-&gt;dmi_addr
)paren
op_amp
l_int|0x3f
comma
id|mc_filter
)paren
suffix:semicolon
id|new_mode
op_assign
id|CMR2h_Normal
suffix:semicolon
)brace
id|lp-&gt;addr_mode
op_assign
id|new_mode
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_IRQOUT
op_or
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* Switch to page 1. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|i
comma
id|mc_filter
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
op_logical_or
l_int|1
)paren
(brace
id|lp-&gt;addr_mode
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Mode %d, setting multicast filter to&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|mc_filter
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_IRQOUT
)paren
suffix:semicolon
multiline_comment|/* Switch back to page 0 */
)brace
DECL|function|atp_init_module
r_static
r_int
id|__init
id|atp_init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
multiline_comment|/* Emit version even if no cards detected. */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|versionA
comma
id|versionB
)paren
suffix:semicolon
r_return
id|atp_init
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|atp_cleanup_module
r_static
r_void
id|__exit
id|atp_cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|next_dev
suffix:semicolon
r_while
c_loop
(paren
id|root_atp_dev
)paren
(brace
id|next_dev
op_assign
(paren
(paren
r_struct
id|net_local
op_star
)paren
id|root_atp_dev-&gt;priv
)paren
op_member_access_from_pointer
id|next_module
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|root_atp_dev
)paren
suffix:semicolon
multiline_comment|/* No need to release_region(), since we never snarf it. */
id|kfree
c_func
(paren
id|root_atp_dev
)paren
suffix:semicolon
id|root_atp_dev
op_assign
id|next_dev
suffix:semicolon
)brace
)brace
DECL|variable|atp_init_module
id|module_init
c_func
(paren
id|atp_init_module
)paren
suffix:semicolon
DECL|variable|atp_cleanup_module
id|module_exit
c_func
(paren
id|atp_cleanup_module
)paren
suffix:semicolon
eof
