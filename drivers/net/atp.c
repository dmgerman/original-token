multiline_comment|/* atp.c: Attached (pocket) ethernet adaptor driver for linux. */
multiline_comment|/*&n;&t;Written 1993 by Donald Becker.&n;&t;Copyright 1993 United States Government as represented by the Director,&n;&t;National Security Agency.  This software may only be used and distributed&n;&t;according to the terms of the GNU Public License as modified by SRC,&n;&t;incorported herein by reference.&n;&n;&t;The author may be reached as becker@super.org or&n;&t;C/O Supercomputing Research Ctr., 17100 Science Dr., Bowie MD 20715&n;&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;atp.c:v0.04 2/25/94 Donald Becker (becker@super.org)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n;&t;This file is a device driver for the RealTek (aka AT-Lan-Tec) pocket&n;&t;ethernet adaptor.  This is a common low-cost OEM pocket ethernet&n;&t;adaptor, sold under many names.&n;&n;  Sources:&n;&t;This driver was written from the packet driver assembly code provided by&n;&t;Vincent Bono of AT-Lan-Tec.&t; Ever try to figure out how a complicated&n;&t;device works just from the assembly code?  It ain&squot;t pretty.  The following&n;&t;description is written based on guesses and writing lots of special-purpose&n;&t;code to test my theorized operation.&n;&n;&t;&t;&t;&t;&t;Theory of Operation&n;&t;&n;&t;The RTL8002 adaptor seems to be built around a custom spin of the SEEQ&n;&t;controller core.  It probably has a 16K or 64K internal packet buffer, of&n;&t;which the first 4K is devoted to transmit and the rest to receive.&n;&t;The controller maintains the queue of received packet and the packet buffer&n;&t;access pointer internally, with only &squot;reset to beginning&squot; and &squot;skip to next&n;&t;packet&squot; commands visible.  The transmit packet queue holds two (or more?)&n;&t;packets: both &squot;retransmit this packet&squot; (due to collision) and &squot;transmit next&n;&t;packet&squot; commands must be started by hand.&n;&n;&t;The station address is stored in a standard bit-serial EEPROM which must be&n;&t;read (ughh) by the device driver.  (Provisions have been made for&n;&t;substituting a 74S288 PROM, but I haven&squot;t gotten reports of any models&n;&t;using it.)  Unlike built-in devices, a pocket adaptor can temporarily lose&n;&t;power without indication to the device driver.  The major effect is that&n;&t;the station address, receive filter (promiscuous, etc.) and transceiver&n;&t;must be reset.&n;&n;&t;The controller itself has 16 registers, some of which use only the lower&n;&t;bits.  The registers are read and written 4 bits at a time.  The four bit&n;&t;register address is presented on the data lines along with a few additional&n;&t;timing and control bits.  The data is then read from status port or written&n;&t;to the data port.&n;&n;&t;Since the bulk data transfer of the actual packets through the slow&n;&t;parallel port dominates the driver&squot;s running time, four distinct data&n;&t;(non-register) transfer modes are provided by the adaptor, two in each&n;&t;direction.  In the first mode timing for the nibble transfers is&n;&t;provided through the data port.  In the second mode the same timing is&n;&t;provided through the control port.  In either case the data is read from&n;&t;the status port and written to the data port, just as it is accessing&n;&t;registers.&n;&n;&t;In addition to the basic data transfer methods, several more are modes are&n;&t;created by adding some delay by doing multiple reads of the data to allow&n;&t;it to stabilize.  This delay seems to be needed on most machines.&n;&n;&t;The data transfer mode is stored in the &squot;dev-&gt;if_port&squot; field.  Its default&n;&t;value is &squot;4&squot;.  It may be overriden at boot-time using the third parameter&n;&t;to the &quot;ether=...&quot; initialization.&n;&n;&t;The header file &lt;atp.h&gt; provides inline functions that encapsulate the&n;&t;register and data access methods.  These functions are hand-tuned to&n;&t;generate reasonable object code.  This header file also documents my&n;&t;interpretations of the device registers.&n;*/
macro_line|#include &lt;linux/config.h&gt;&t;&t;/* Used only to override default values. */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;atp.h&quot;
multiline_comment|/* Compatibility definitions for earlier kernel versions. */
macro_line|#ifndef HAVE_AUTOIRQ
multiline_comment|/* From auto_irq.c, in ioport.h for later versions. */
r_extern
r_void
id|autoirq_setup
c_func
(paren
r_int
id|waittime
)paren
suffix:semicolon
r_extern
r_int
id|autoirq_report
c_func
(paren
r_int
id|waittime
)paren
suffix:semicolon
multiline_comment|/* The map from IRQ number (as passed to the interrupt handler) to&n;   &squot;struct device&squot;. */
r_extern
r_struct
id|device
op_star
id|irq2dev_map
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifndef HAVE_ALLOC_SKB
DECL|macro|alloc_skb
mdefine_line|#define alloc_skb(size, priority) (struct sk_buff *) kmalloc(size,priority)
DECL|macro|kfree_skbmem
mdefine_line|#define kfree_skbmem(addr, size) kfree_s(addr,size);
macro_line|#endif
macro_line|#ifndef HAVE_PORTRESERVE
DECL|macro|check_region
mdefine_line|#define check_region(ioaddr, size)&t;&t;0
DECL|macro|snarf_region
mdefine_line|#define snarf_region(ioaddr, size);&t;&t;do ; while (0)
macro_line|#endif
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 4
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|ETHERCARD_TOTAL_SIZE
mdefine_line|#define ETHERCARD_TOTAL_SIZE&t;3
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|atp_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|atp_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|get_node_ID
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
r_int
id|eeprom_op
c_func
(paren
r_int
id|ioaddr
comma
r_int
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hardware_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|write_packet
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|packet
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_void
id|trigger_send
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_int
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|net_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|read_block
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|data_mode
)paren
suffix:semicolon
r_static
r_int
id|net_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|net_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, alloate space for the device and return success&n;   (detachable devices only).&n;   */
r_int
DECL|function|atp_init
id|atp_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
l_int|0x378
comma
l_int|0x278
comma
l_int|0x3bc
comma
l_int|0
)brace
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|atp_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_eq
l_int|1
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|ports
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
op_star
id|port
suffix:semicolon
id|outb
c_func
(paren
l_int|0x57
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PAR_DATA
)paren
op_ne
l_int|0x57
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|atp_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ENODEV
suffix:semicolon
)brace
DECL|function|atp_probe1
r_static
r_int
id|atp_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
id|saved_ctrl_reg
comma
id|status
suffix:semicolon
id|outb
c_func
(paren
l_int|0xff
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Save the original value of the Control register, in case we guessed&n;&t;   wrong. */
id|saved_ctrl_reg
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* IRQEN=0, SLCTB=high INITB=high, AUTOFDB=high, STBB=high. */
id|outb
c_func
(paren
l_int|0x04
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
l_int|2048
)paren
suffix:semicolon
id|status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x78
)paren
op_ne
l_int|0x08
)paren
(brace
multiline_comment|/* The pocket adaptor probe failed, restore the control register. */
id|outb
c_func
(paren
id|saved_ctrl_reg
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR2_h
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x78
)paren
op_ne
l_int|0x10
)paren
(brace
id|outb
c_func
(paren
id|saved_ctrl_reg
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Find the IRQ used by triggering an interrupt. */
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* No accept mode, IRQ out. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RxENABLE
op_or
id|CMR1h_TxENABLE
)paren
suffix:semicolon
multiline_comment|/* Enable Tx and Rx. */
multiline_comment|/* Omit autoIRQ routine for now. Use &quot;table lookup&quot; instead.  Uhgggh. */
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0x378
)paren
id|dev-&gt;irq
op_assign
l_int|7
suffix:semicolon
r_else
id|dev-&gt;irq
op_assign
l_int|5
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_TxRxOFF
)paren
suffix:semicolon
multiline_comment|/* Diable Tx and Rx units. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_NULL
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* Read the station address PROM.  */
id|get_node_ID
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Pocket adaptor found at %#3x, IRQ %d, SAPROM &quot;
l_string|&quot;%02X:%02X:%02X:%02X:%02X:%02X.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* Leave the hardware in a reset state. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;addr_mode
op_assign
id|CMR2h_Normal
suffix:semicolon
)brace
multiline_comment|/* For the ATP adaptor the &quot;if_port&quot; is really the data transfer mode. */
id|dev-&gt;if_port
op_assign
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
ques
c_cond
id|dev-&gt;mem_start
op_amp
l_int|0x7
suffix:colon
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mem_end
op_amp
l_int|0xf
)paren
id|net_debug
op_assign
id|dev-&gt;mem_end
op_amp
l_int|7
suffix:semicolon
id|dev-&gt;open
op_assign
id|net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|net_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|net_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the station address PROM, usually a word-wide EEPROM. */
DECL|function|get_node_ID
r_static
r_void
id|get_node_ID
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|sa_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_EEPROM
)paren
suffix:semicolon
multiline_comment|/* Point to the EEPROM control registers. */
multiline_comment|/* Some adaptors have the station address at offset 15 instead of offset&n;&t;   zero.  Check for it, and fix it if needed. */
r_if
c_cond
(paren
id|eeprom_op
c_func
(paren
id|ioaddr
comma
id|EE_READ
c_func
(paren
l_int|0
)paren
)paren
op_eq
l_int|0xffff
)paren
id|sa_offset
op_assign
l_int|15
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
)paren
(braket
id|i
)braket
op_assign
id|ntohs
c_func
(paren
id|eeprom_op
c_func
(paren
id|ioaddr
comma
id|EE_READ
c_func
(paren
id|sa_offset
op_plus
id|i
)paren
)paren
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  An EEPROM read command starts by shifting out 0x60+address, and then&n;  shifting in the serial data. See the NatSemi databook for details.&n; *&t;&t;   ________________&n; * CS : __|&n; *&t;&t;&t;   ___&t;   ___&n; * CLK: ______|&t;  |___|&t;  |&n; *&t;&t; __ _______ _______&n; * DI :&t; __X_______X_______X&n; * DO :&t; _________X_______X&n; */
DECL|function|eeprom_op
r_static
r_int
r_int
id|eeprom_op
c_func
(paren
r_int
id|ioaddr
comma
r_int
r_int
id|cmd
)paren
(brace
r_int
id|eedata_out
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bits
op_assign
id|EE_CMD_SIZE
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|num_bits
op_ge
l_int|0
)paren
(brace
r_char
id|outval
op_assign
id|test_bit
c_func
(paren
id|num_bits
comma
op_amp
id|cmd
)paren
ques
c_cond
id|EE_DATA_WRITE
suffix:colon
l_int|0
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|PROM_CMD
comma
id|outval
op_or
id|EE_CLK_LOW
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|PROM_CMD
comma
id|outval
op_or
id|EE_CLK_HIGH
)paren
suffix:semicolon
id|eedata_out
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|PROM_DATA
)paren
op_amp
id|EE_DATA_READ
)paren
id|eedata_out
op_increment
suffix:semicolon
id|eeprom_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|PROM_CMD
comma
id|EE_CLK_LOW
op_amp
op_complement
id|EE_CS
)paren
suffix:semicolon
r_return
id|eedata_out
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine sets everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;&n;   This is an attachable device: if there is no dev-&gt;priv entry then it wasn&squot;t&n;   probed for at boot-time, and we need to probe for it again.&n;   */
DECL|function|net_open
r_static
r_int
id|net_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* The interrupt line is turned off (tri-stated) when the device isn&squot;t in&n;&t;   use.  That&squot;s especially important for &quot;attached&quot; interfaces where the&n;&t;   port or interrupt may be shared. */
r_if
c_cond
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_ne
l_int|0
op_logical_or
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
)paren
op_eq
l_int|0
op_logical_or
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|net_interrupt
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine resets the hardware.  We initialize everything, assuming that&n;   the hardware may have been temporarily detacted. */
DECL|function|hardware_init
r_static
r_void
id|hardware_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Reset: current Rx mode %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR2_h
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_IRQOUT
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RxENABLE
op_or
id|CMR1h_TxENABLE
)paren
suffix:semicolon
multiline_comment|/* Enable the interrupt line from the serial port. */
id|outb
c_func
(paren
id|Ctrl_SelData
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Unmask the interesting interrupts. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISR_RxOK
op_or
id|ISR_TxErr
op_or
id|ISR_TxOK
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
id|lp-&gt;tx_unit_busy
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;pac_cnt_in_tx_buf
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;saved_tx_size
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|trigger_send
r_static
r_void
id|trigger_send
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
)paren
(brace
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|TxCNT0
comma
id|length
op_amp
l_int|0xff
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|TxCNT1
comma
id|length
op_rshift
l_int|8
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1_Xmit
)paren
suffix:semicolon
)brace
DECL|function|write_packet
r_static
r_void
id|write_packet
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|packet
comma
r_int
id|data_mode
)paren
(brace
id|length
op_assign
(paren
id|length
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
suffix:semicolon
multiline_comment|/* Round up to word length. */
id|outb
c_func
(paren
id|EOC
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data_mode
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Write the packet out, starting with the write addr. */
id|outb
c_func
(paren
id|WrAddr
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_do
(brace
id|write_byte_mode0
c_func
(paren
id|ioaddr
comma
op_star
id|packet
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Write the packet out in slow mode. */
r_int
r_char
id|outbyte
op_assign
op_star
id|packet
op_increment
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_LNibWrite
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|WrAddr
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|outbyte
op_amp
l_int|0x0f
)paren
op_or
l_int|0x40
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outbyte
op_amp
l_int|0x0f
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outbyte
op_rshift_assign
l_int|4
suffix:semicolon
id|outb
c_func
(paren
id|outbyte
op_amp
l_int|0x0f
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_HNibWrite
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
id|write_byte_mode1
c_func
(paren
id|ioaddr
comma
op_star
id|packet
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate the Tx frame.  End of write: ECB. */
id|outb
c_func
(paren
l_int|0xff
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_HNibWrite
op_or
id|Ctrl_SelData
op_or
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|net_send_packet
id|net_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
op_amp
l_int|0x10
ques
c_cond
l_string|&quot;network cable problem&quot;
suffix:colon
l_string|&quot;IRQ conflict&quot;
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* If some higher layer thinks we&squot;ve missed an tx-done interrupt&n;&t;   we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;&t;   itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping.  This could better be&n;&t;   done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
(brace
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
r_int
id|flags
suffix:semicolon
multiline_comment|/* Disable interrupts by writing 0x00 to the Interrupt Mask Register.&n;&t;&t;   This sequence must not be interrupted by an incoming packet. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
l_int|0
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|write_packet
c_func
(paren
id|ioaddr
comma
id|length
comma
id|buf
comma
id|dev-&gt;if_port
)paren
suffix:semicolon
id|lp-&gt;pac_cnt_in_tx_buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_unit_busy
op_eq
l_int|0
)paren
(brace
id|trigger_send
c_func
(paren
id|ioaddr
comma
id|length
)paren
suffix:semicolon
id|lp-&gt;saved_tx_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Redundent */
id|lp-&gt;re_tx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_unit_busy
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|lp-&gt;saved_tx_size
op_assign
id|length
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Re-enable the LPT interrupts. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISR_RxOK
op_or
id|ISR_TxErr
op_or
id|ISR_TxOK
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;free
)paren
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
r_static
r_void
DECL|function|net_interrupt
id|net_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|20
suffix:semicolon
r_static
r_int
id|num_tx_since_rx
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ATP_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Disable additional spurious interrupts. */
id|outb
c_func
(paren
id|Ctrl_SelData
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* The adaptor&squot;s output is currently the IRQ line, switch it to data. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_NULL
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: In interrupt &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|boguscount
OG
l_int|0
)paren
(brace
id|status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|ISR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;loop status %02x..&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|ISR_RxOK
op_lshift
l_int|3
)paren
)paren
(brace
id|write_reg
c_func
(paren
id|ioaddr
comma
id|ISR
comma
id|ISR_RxOK
)paren
suffix:semicolon
multiline_comment|/* Clear the Rx interrupt. */
r_do
(brace
r_int
id|read_status
op_assign
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot;handling Rx packet %02x..&quot;
comma
id|read_status
)paren
suffix:semicolon
multiline_comment|/* We acknowledged the normal Rx interrupt, so if the interrupt&n;&t;&t;&t;&t;   is still outstanding we must have a Rx error. */
r_if
c_cond
(paren
id|read_status
op_amp
(paren
id|CMR1_IRQ
op_lshift
l_int|3
)paren
)paren
(brace
multiline_comment|/* Overrun. */
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
multiline_comment|/* Set to no-accept mode long enough to remove a packet. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2h_OFF
)paren
suffix:semicolon
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt and return to normal Rx mode. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|ISR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|read_status
op_amp
(paren
id|CMR1_BufEnb
op_lshift
l_int|3
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|net_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|num_tx_since_rx
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|boguscount
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
(paren
(paren
id|ISR_TxErr
op_plus
id|ISR_TxOK
)paren
op_lshift
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot;handling Tx done..&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear the Tx interrupt.  We should check for too many failures&n;&t;&t;&t;   and reinitialize the adaptor. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|ISR
comma
id|ISR_TxErr
op_plus
id|ISR_TxOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|ISR_TxErr
op_lshift
l_int|3
)paren
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|lp-&gt;re_tx
OG
l_int|15
)paren
(brace
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Attempt to retransmit. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot;attempting to ReTx&quot;
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1_ReXmit
op_plus
id|CMR1_Xmit
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Finish up the transmit. */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;pac_cnt_in_tx_buf
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;saved_tx_size
)paren
(brace
id|trigger_send
c_func
(paren
id|ioaddr
comma
id|lp-&gt;saved_tx_size
)paren
suffix:semicolon
id|lp-&gt;saved_tx_size
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;re_tx
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|lp-&gt;tx_unit_busy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|INET_BH
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
id|num_tx_since_rx
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num_tx_since_rx
OG
l_int|8
op_logical_and
id|jiffies
OG
id|dev-&gt;last_rx
op_plus
l_int|100
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Missed packet? No Rx after %d Tx and %ld jiffies&quot;
l_string|&quot; status %02x  CMR1 %02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|num_tx_since_rx
comma
id|jiffies
op_minus
id|dev-&gt;last_rx
comma
id|status
comma
(paren
id|read_nibble
c_func
(paren
id|ioaddr
comma
id|CMR1
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|15
)paren
suffix:semicolon
id|lp-&gt;stats.rx_missed_errors
op_increment
suffix:semicolon
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|num_tx_since_rx
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* This following code fixes a rare (and very difficult to track down)&n;&t;   problem where the adaptor forgets its ethernet address. */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|write_reg_byte
c_func
(paren
id|ioaddr
comma
id|PAR0
op_plus
id|i
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Tell the adaptor that it can go back to using the output line as IRQ. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2_IRQOUT
)paren
suffix:semicolon
multiline_comment|/* Enable the physical interrupt line, which is sure to be low until.. */
id|outb
c_func
(paren
id|Ctrl_SelData
op_plus
id|Ctrl_IRQEN
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* .. we enable the interrupt sources. */
id|write_reg
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISR_RxOK
op_or
id|ISR_TxErr
op_or
id|ISR_TxOK
)paren
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|IMR
comma
id|ISRh_RxErr
)paren
suffix:semicolon
multiline_comment|/* Hmmm, really needed? */
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;exiting interrupt.&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
DECL|function|net_rx
r_static
r_void
id|net_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef notdef
id|ushort
id|header
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
r_struct
id|rx_header
id|rx_head
suffix:semicolon
macro_line|#endif
multiline_comment|/* Process the received packet. */
id|outb
c_func
(paren
id|EOC
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|read_block
c_func
(paren
id|ioaddr
comma
l_int|8
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|rx_head
comma
id|dev-&gt;if_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot; rx_count %04x %04x %04x %04x..&quot;
comma
id|rx_head.pad
comma
id|rx_head.rx_count
comma
id|rx_head.rx_status
comma
id|rx_head.cur_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rx_head.rx_status
op_amp
l_int|0x77
)paren
op_ne
l_int|0x01
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Ackkk!  I don&squot;t have any documentation on what the error bits mean!&n;&t;&t;   The best I can do is slap the device around a bit. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Unknown ATP Rx error %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_head.rx_status
)paren
suffix:semicolon
id|hardware_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. */
r_int
id|pkt_len
op_assign
(paren
id|rx_head.rx_count
op_amp
l_int|0x7ff
)paren
op_minus
l_int|4
suffix:semicolon
multiline_comment|/* The &quot;-4&quot; is omits the FCS (CRC). */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|read_block
c_func
(paren
id|ioaddr
comma
id|pkt_len
comma
id|skb-&gt;data
comma
id|dev-&gt;if_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|6
)paren
(brace
r_int
r_char
op_star
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; data %02x%02x%02x %02x%02x%02x %02x%02x%02x&quot;
l_string|&quot;%02x%02x%02x %02x%02x..&quot;
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
comma
id|data
(braket
l_int|2
)braket
comma
id|data
(braket
l_int|3
)braket
comma
id|data
(braket
l_int|4
)braket
comma
id|data
(braket
l_int|5
)braket
comma
id|data
(braket
l_int|6
)braket
comma
id|data
(braket
l_int|7
)braket
comma
id|data
(braket
l_int|8
)braket
comma
id|data
(braket
l_int|9
)braket
comma
id|data
(braket
l_int|10
)braket
comma
id|data
(braket
l_int|11
)braket
comma
id|data
(braket
l_int|12
)braket
comma
id|data
(braket
l_int|13
)braket
)paren
suffix:semicolon
)brace
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
id|done
suffix:colon
id|write_reg
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1_NextPkt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|read_block
r_static
r_void
id|read_block
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|length
comma
r_int
r_char
op_star
id|p
comma
r_int
id|data_mode
)paren
(brace
r_if
c_cond
(paren
id|data_mode
op_le
l_int|3
)paren
(brace
multiline_comment|/* Mode 0 or 1 */
id|outb
c_func
(paren
id|Ctrl_LNibRead
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|length
op_eq
l_int|8
ques
c_cond
id|RdAddr
op_or
id|HNib
op_or
id|MAR
suffix:colon
id|RdAddr
op_or
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_mode
op_le
l_int|1
)paren
(brace
multiline_comment|/* Mode 0 or 1 */
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode0
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Mode 2 or 3 */
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode2
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data_mode
op_le
l_int|5
)paren
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode4
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
r_else
r_do
op_star
id|p
op_increment
op_assign
id|read_byte_mode6
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|length
OG
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|EOC
op_plus
id|HNib
op_plus
id|MAR
comma
id|ioaddr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|Ctrl_SelData
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
r_static
r_int
DECL|function|net_close
id|net_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here. */
id|lp-&gt;addr_mode
op_assign
id|CMR2h_OFF
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|CMR2h_OFF
)paren
suffix:semicolon
multiline_comment|/* Free the IRQ line. */
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Leave the hardware in a reset state. */
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR1
comma
id|CMR1h_RESET
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|enet_statistics
op_star
DECL|function|net_get_stats
id|net_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n;   num_addrs == -1&t;Promiscuous mode, receive all packets&n;   num_addrs == 0&t;Normal mode, clear multicast list&n;   num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;&t;&t;&t;best-effort filtering.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;addr_mode
op_assign
id|num_addrs
ques
c_cond
id|CMR2h_PROMISC
suffix:colon
id|CMR2h_Normal
suffix:semicolon
id|write_reg_high
c_func
(paren
id|ioaddr
comma
id|CMR2
comma
id|lp-&gt;addr_mode
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c atp.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 4&n; * End:&n; */
eof
