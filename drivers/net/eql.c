multiline_comment|/*&n; * Equalizer Load-balancer for serial network interfaces.&n; *&n; * (c) Copyright 1995 Simon &quot;Guru Aleph-Null&quot; Janes&n; * NCM: Network and Communications Mangement, Inc.&n; *&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU Public License, incorporated herein by reference.&n; * &n; * The author may be reached as simon@ncm.com, or C/O&n; *    NCM&n; *    Attn: Simon Janes&n; *    6803 Whittier Ave&n; *    McLean VA 22101&n; *    Phone: 1-703-847-0040 ext 103&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;Equalizer: $Revision: 3.12 $ $Date: 1995/01/19 $ Simon Janes (simon@ncm.com)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Sources:&n; *   skeleton.c by Donald Becker.&n; * Inspirations:&n; *   The Harried and Overworked Alan Cox&n; * Conspiracies:&n; *   The Alan Cox and Mike McLagan plot to get someone else to do the code, which&n; *   turned out to be me.&n; */
multiline_comment|/*&n; * $Log: eql.c,v $&n; * Revision 3.12  1995/03/22  21:07:51  anarchy&n; * Added suser() checks on configuration.&n; * Moved header file.&n; *&n; * Revision 3.11  1995/01/19  23:14:31  guru&n; * &t;&t;      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued * 8;&n; *&n; * Revision 3.10  1995/01/19  23:07:53  guru&n; * back to&n; * &t;&t;      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued;&n; *&n; * Revision 3.9  1995/01/19  22:38:20  guru&n; * &t;&t;      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued * 4;&n; *&n; * Revision 3.8  1995/01/19  22:30:55  guru&n; *       slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued * 2;&n; *&n; * Revision 3.7  1995/01/19  21:52:35  guru&n; * printk&squot;s trimmed out.&n; *&n; * Revision 3.6  1995/01/19  21:49:56  guru&n; * This is working pretty well. I gained 1 K/s in speed.. now its just&n; * robustness and printk&squot;s to be diked out.&n; *&n; * Revision 3.5  1995/01/18  22:29:59  guru&n; * still crashes the kernel when the lock_wait thing is woken up.&n; *&n; * Revision 3.4  1995/01/18  21:59:47  guru&n; * Broken set-bit locking snapshot&n; *&n; * Revision 3.3  1995/01/17  22:09:18  guru&n; * infinite sleep in a lock somewhere..&n; *&n; * Revision 3.2  1995/01/15  16:46:06  guru&n; * Log trimmed of non-pertinant 1.x branch messages&n; *&n; * Revision 3.1  1995/01/15  14:41:45  guru&n; * New Scheduler and timer stuff...&n; *&n; * Revision 1.15  1995/01/15  14:29:02  guru&n; * Will make 1.14 (now 1.15) the 3.0 branch, and the 1.12 the 2.0 branch, the one&n; * with the dumber scheduler&n; *&n; * Revision 1.14  1995/01/15  02:37:08  guru&n; * shock.. the kept-new-versions could have zonked working&n; * stuff.. shudder&n; *&n; * Revision 1.13  1995/01/15  02:36:31  guru&n; * big changes&n; *&n; * &t;scheduler was torn out and replaced with something smarter&n; *&n; * &t;global names not prefixed with eql_ were renamed to protect&n; * &t;against namespace collisions&n; *&n; * &t;a few more abstract interfaces were added to facilitate any&n; * &t;potential change of datastructure.  the driver is still using&n; * &t;a linked list of slaves.  going to a heap would be a bit of&n; * &t;an overkill.&n; *&n; * &t;this compiles fine with no warnings.&n; *&n; * &t;the locking mechanism and timer stuff must be written however,&n; * &t;this version will not work otherwise&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;              
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/if_eql.h&gt;
macro_line|#ifndef EQL_DEBUG
multiline_comment|/* #undef EQL_DEBUG      -* print nothing at all, not even a boot-banner */
multiline_comment|/* #define EQL_DEBUG 1   -* print only the boot-banner */
multiline_comment|/* #define EQL_DEBUG 5   -* print major function entries */
multiline_comment|/* #define EQL_DEBUG 20  -* print subfunction entries */
multiline_comment|/* #define EQL_DEBUG 50  -* print utility entries */
multiline_comment|/* #define EQL_DEBUG 100 -* print voluminous function entries */
DECL|macro|EQL_DEBUG
mdefine_line|#define EQL_DEBUG 1
macro_line|#endif
DECL|variable|eql_debug
r_static
r_int
r_int
id|eql_debug
op_assign
id|EQL_DEBUG
suffix:semicolon
r_int
id|eql_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_slave_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_struct
id|enet_statistics
op_star
id|eql_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_rebuild_header
c_func
(paren
r_void
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|raddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* ioctl() handlers&n;   ---------------- */
r_static
r_int
id|eql_enslave
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srq
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_emancipate
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srq
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_g_slave_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slave_config_t
op_star
id|sc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_s_slave_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slave_config_t
op_star
id|sc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_g_master_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|master_config_t
op_star
id|mc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_s_master_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|master_config_t
op_star
id|mc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_slave
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_master
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_t
op_star
id|eql_new_slave
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_void
id|eql_delete_slave
c_func
(paren
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* static long eql_slave_priority(slave_t *slave); -*  */
r_static
r_inline
r_int
id|eql_number_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_empty
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_full
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_queue_t
op_star
id|eql_new_slave_queue
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_void
id|eql_delete_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_insert_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_t
op_star
id|eql_remove_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* static int eql_insert_slave_dev(slave_queue_t *queue, struct device *dev); -*  */
r_static
r_int
id|eql_remove_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_struct
id|device
op_star
id|eql_best_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
id|slave_t
op_star
id|eql_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
id|slave_t
op_star
id|eql_first_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
id|slave_t
op_star
id|eql_next_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_void
id|eql_set_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_void
id|eql_schedule_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_t
op_star
id|eql_find_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* static inline eql_lock_slave_queue(slave_queue_t *queue); -*  */
multiline_comment|/* static inline eql_unlock_slave_queue(slave_queue_t *queue); -*  */
r_static
r_void
id|eql_timer
c_func
(paren
r_int
r_int
id|param
)paren
suffix:semicolon
multiline_comment|/*  */
"&f;"
multiline_comment|/* struct device * interface functions &n;   ---------------------------------------------------------&n;   */
r_int
DECL|function|eql_init
id|eql_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* static unsigned num_masters     = 0; */
id|equalizer_t
op_star
id|eql
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|version_printed
op_increment
op_eq
l_int|0
op_logical_and
id|eql_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|equalizer_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
id|equalizer_t
)paren
)paren
suffix:semicolon
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|eql-&gt;stats
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|enet_statistics
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql-&gt;stats
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|eql-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|enet_statistics
)paren
)paren
suffix:semicolon
id|init_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
id|eql-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev-&gt;priv
suffix:semicolon
id|eql-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|EQL_DEFAULT_RESCHED_IVAL
suffix:semicolon
id|eql-&gt;timer.function
op_assign
op_amp
id|eql_timer
suffix:semicolon
id|eql-&gt;timer_on
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;open
op_assign
id|eql_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|eql_close
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|eql_ioctl
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|eql_slave_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|eql_get_stats
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet-generic values.&n;     This should be in a common file instead of per-driver.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|eql_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|eql_rebuild_header
suffix:semicolon
multiline_comment|/* now we undo some of the things that eth_setup does that we don&squot;t like */
id|dev-&gt;mtu
op_assign
id|EQL_DEFAULT_MTU
suffix:semicolon
multiline_comment|/* set to 576 in eql.h */
id|dev-&gt;flags
op_assign
id|IFF_MASTER
suffix:semicolon
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_alen
op_assign
l_int|4
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_SLIP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_open
id|eql_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|slave_queue_t
op_star
id|new_queue
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|5
)paren
id|printk
(paren
l_string|&quot;%s: open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|new_queue
op_assign
id|eql_new_slave_queue
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_queue
op_ne
l_int|0
)paren
(brace
id|new_queue-&gt;master_dev
op_assign
id|dev
suffix:semicolon
id|eql-&gt;queue
op_assign
id|new_queue
suffix:semicolon
id|eql-&gt;queue-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|eql-&gt;min_slaves
op_assign
l_int|1
suffix:semicolon
id|eql-&gt;max_slaves
op_assign
id|EQL_DEFAULT_MAX_SLAVES
suffix:semicolon
multiline_comment|/* 4 usually... */
id|printk
(paren
l_string|&quot;%s: adding timer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|eql-&gt;timer_on
op_assign
l_int|1
suffix:semicolon
id|add_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|eql_close
id|eql_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|5
)paren
id|printk
(paren
l_string|&quot;%s: close&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The timer has to be stopped first before we start hacking away&n;     at the data structure it scans every so often... */
id|printk
(paren
l_string|&quot;%s: stopping timer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|eql-&gt;timer_on
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
id|eql_delete_slave_queue
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_ioctl
id|eql_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
op_logical_and
id|cmd
op_ne
id|EQL_GETMASTRCFG
op_logical_and
id|cmd
op_ne
id|EQL_GETSLAVECFG
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|EQL_ENSLAVE
suffix:colon
r_return
id|eql_enslave
(paren
id|dev
comma
(paren
id|slaving_request_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_EMANCIPATE
suffix:colon
r_return
id|eql_emancipate
(paren
id|dev
comma
(paren
id|slaving_request_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_GETSLAVECFG
suffix:colon
r_return
id|eql_g_slave_cfg
(paren
id|dev
comma
(paren
id|slave_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_SETSLAVECFG
suffix:colon
r_return
id|eql_s_slave_cfg
(paren
id|dev
comma
(paren
id|slave_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_GETMASTRCFG
suffix:colon
r_return
id|eql_g_master_cfg
(paren
id|dev
comma
(paren
id|master_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_SETMASTRCFG
suffix:colon
r_return
id|eql_s_master_cfg
(paren
id|dev
comma
(paren
id|master_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
"&f;"
r_static
r_int
DECL|function|eql_slave_xmit
id|eql_slave_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|device
op_star
id|slave_dev
op_assign
l_int|0
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|eql_schedule_slaves
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|slave_dev
op_assign
id|eql_best_slave_dev
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|slave
op_assign
id|eql_best_slave
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|100
)paren
id|printk
(paren
l_string|&quot;%s: %d slaves xmitng %ld B %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|eql_number_slaves
(paren
id|eql-&gt;queue
)paren
comma
id|skb-&gt;len
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|dev_queue_xmit
(paren
id|skb
comma
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
id|eql-&gt;stats-&gt;tx_packets
op_increment
suffix:semicolon
id|slave-&gt;bytes_queued
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The alternative for this is the return 1 and have&n;         dev_queue_xmit just queue it up on the eql&squot;s queue. */
id|eql-&gt;stats-&gt;tx_dropped
op_increment
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
r_struct
id|enet_statistics
op_star
DECL|function|eql_get_stats
id|eql_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
id|eql-&gt;stats
suffix:semicolon
)brace
r_static
r_int
DECL|function|eql_header
id|eql_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|eql_rebuild_header
id|eql_rebuild_header
c_func
(paren
r_void
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|raddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* private ioctl functions&n;   -----------------------------------------------------------------&n;   */
r_static
r_int
DECL|function|eql_enslave
id|eql_enslave
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srqp
)paren
(brace
r_struct
id|device
op_star
id|master_dev
suffix:semicolon
r_struct
id|device
op_star
id|slave_dev
suffix:semicolon
id|slaving_request_t
id|srq
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|srqp
comma
r_sizeof
(paren
id|slaving_request_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|srq
comma
id|srqp
comma
r_sizeof
(paren
id|slaving_request_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: enslave &squot;%s&squot; %ld bps&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|srq.slave_name
comma
id|srq.priority
)paren
suffix:semicolon
macro_line|#endif
id|master_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* for &quot;clarity&quot; */
id|slave_dev
op_assign
id|dev_get
(paren
id|srq.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master_dev
op_ne
l_int|0
op_logical_and
id|slave_dev
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|eql_is_master
(paren
id|slave_dev
)paren
op_logical_and
multiline_comment|/* slave is not a master */
op_logical_neg
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
multiline_comment|/* slave is not already a slave */
(brace
id|slave_t
op_star
id|s
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
id|s-&gt;dev
op_assign
id|slave_dev
suffix:semicolon
id|s-&gt;priority
op_assign
id|srq.priority
suffix:semicolon
id|s-&gt;priority_bps
op_assign
id|srq.priority
suffix:semicolon
id|s-&gt;priority_Bps
op_assign
id|srq.priority
op_div
l_int|8
suffix:semicolon
id|slave_dev-&gt;flags
op_or_assign
id|IFF_SLAVE
suffix:semicolon
id|eql_insert_slave
(paren
id|eql-&gt;queue
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_emancipate
id|eql_emancipate
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srqp
)paren
(brace
r_struct
id|device
op_star
id|master_dev
suffix:semicolon
r_struct
id|device
op_star
id|slave_dev
suffix:semicolon
id|slaving_request_t
id|srq
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|srqp
comma
r_sizeof
(paren
id|slaving_request_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|srq
comma
id|srqp
comma
r_sizeof
(paren
id|slaving_request_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: emancipate `%s`&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|srq.slave_name
)paren
suffix:semicolon
macro_line|#endif
id|master_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* for &quot;clarity&quot; */
id|slave_dev
op_assign
id|dev_get
(paren
id|srq.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
multiline_comment|/* really is a slave */
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
id|slave_dev-&gt;flags
op_assign
id|slave_dev-&gt;flags
op_amp
op_complement
id|IFF_SLAVE
suffix:semicolon
id|eql_remove_slave_dev
(paren
id|eql-&gt;queue
comma
id|slave_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_g_slave_cfg
id|eql_g_slave_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slave_config_t
op_star
id|scp
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|equalizer_t
op_star
id|eql
suffix:semicolon
r_struct
id|device
op_star
id|slave_dev
suffix:semicolon
id|slave_config_t
id|sc
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|sc
comma
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: get config for slave `%s&squot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sc.slave_name
)paren
suffix:semicolon
macro_line|#endif
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|slave_dev
op_assign
id|dev_get
(paren
id|sc.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
(brace
id|slave
op_assign
id|eql_find_slave_dev
(paren
id|eql-&gt;queue
comma
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
id|sc.priority
op_assign
id|slave-&gt;priority
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_tofs
(paren
id|scp
comma
op_amp
id|sc
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_s_slave_cfg
id|eql_s_slave_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|slave_config_t
op_star
id|scp
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|equalizer_t
op_star
id|eql
suffix:semicolon
r_struct
id|device
op_star
id|slave_dev
suffix:semicolon
id|slave_config_t
id|sc
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: set config for slave `%s&squot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sc.slave_name
)paren
suffix:semicolon
macro_line|#endif
id|memcpy_fromfs
(paren
op_amp
id|sc
comma
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
suffix:semicolon
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|slave_dev
op_assign
id|dev_get
(paren
id|sc.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
(brace
id|slave
op_assign
id|eql_find_slave_dev
(paren
id|eql-&gt;queue
comma
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
id|slave-&gt;priority
op_assign
id|sc.priority
suffix:semicolon
id|slave-&gt;priority_bps
op_assign
id|sc.priority
suffix:semicolon
id|slave-&gt;priority_Bps
op_assign
id|sc.priority
op_div
l_int|8
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_g_master_cfg
id|eql_g_master_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|master_config_t
op_star
id|mcp
)paren
(brace
id|equalizer_t
op_star
id|eql
suffix:semicolon
id|master_config_t
id|mc
suffix:semicolon
macro_line|#if EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: get master config&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|eql_is_master
(paren
id|dev
)paren
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|mcp
comma
r_sizeof
(paren
id|master_config_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mc.max_slaves
op_assign
id|eql-&gt;max_slaves
suffix:semicolon
id|mc.min_slaves
op_assign
id|eql-&gt;min_slaves
suffix:semicolon
id|memcpy_tofs
(paren
id|mcp
comma
op_amp
id|mc
comma
r_sizeof
(paren
id|master_config_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_int
DECL|function|eql_s_master_cfg
id|eql_s_master_cfg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|master_config_t
op_star
id|mcp
)paren
(brace
id|equalizer_t
op_star
id|eql
suffix:semicolon
id|master_config_t
id|mc
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|mcp
comma
r_sizeof
(paren
id|master_config_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
macro_line|#if EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: set master config&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|memcpy_fromfs
(paren
op_amp
id|mc
comma
id|mcp
comma
r_sizeof
(paren
id|master_config_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_master
(paren
id|dev
)paren
)paren
(brace
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|eql-&gt;max_slaves
op_assign
id|mc.max_slaves
suffix:semicolon
id|eql-&gt;min_slaves
op_assign
id|mc.min_slaves
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
"&f;"
multiline_comment|/* private device support functions&n;   ------------------------------------------------------------------&n;   */
r_static
r_inline
r_int
DECL|function|eql_is_slave
id|eql_is_slave
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_eq
id|IFF_SLAVE
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|eql_is_master
id|eql_is_master
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_MASTER
)paren
op_eq
id|IFF_MASTER
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
id|slave_t
op_star
DECL|function|eql_new_slave
id|eql_new_slave
c_func
(paren
r_void
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|slave_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
)paren
(brace
id|memset
c_func
(paren
id|slave
comma
l_int|0
comma
r_sizeof
(paren
id|slave_t
)paren
)paren
suffix:semicolon
r_return
id|slave
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|eql_delete_slave
id|eql_delete_slave
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|kfree
(paren
id|slave
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;&t;&t;&t;/* not currently used, will be used&n;&t;&t;&t;&t;   when we realy use a priority queue */
r_static
r_int
id|slave_Bps
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
r_return
(paren
id|slave-&gt;priority_Bps
)paren
suffix:semicolon
)brace
r_static
r_int
id|slave_bps
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
r_return
(paren
id|slave-&gt;priority_bps
)paren
suffix:semicolon
)brace
macro_line|#endif
"&f;"
r_static
r_inline
r_int
DECL|function|eql_number_slaves
id|eql_number_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|queue-&gt;num_slaves
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|eql_is_empty
id|eql_is_empty
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_if
c_cond
(paren
id|eql_number_slaves
(paren
id|queue
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|eql_is_full
id|eql_is_full
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|queue-&gt;master_dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|eql_number_slaves
(paren
id|queue
)paren
op_eq
id|eql-&gt;max_slaves
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
id|slave_queue_t
op_star
DECL|function|eql_new_slave_queue
id|eql_new_slave_queue
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|slave_queue_t
op_star
id|queue
suffix:semicolon
id|slave_t
op_star
id|head_slave
suffix:semicolon
id|slave_t
op_star
id|tail_slave
suffix:semicolon
id|queue
op_assign
(paren
id|slave_queue_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|slave_queue_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|memset
(paren
id|queue
comma
l_int|0
comma
r_sizeof
(paren
id|slave_queue_t
)paren
)paren
suffix:semicolon
id|head_slave
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
id|tail_slave
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_slave
op_ne
l_int|0
op_logical_and
id|tail_slave
op_ne
l_int|0
)paren
(brace
id|head_slave-&gt;next
op_assign
id|tail_slave
suffix:semicolon
id|tail_slave-&gt;next
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;head
op_assign
id|head_slave
suffix:semicolon
id|queue-&gt;num_slaves
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;master_dev
op_assign
id|dev
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|head_slave
)paren
id|kfree
c_func
(paren
id|head_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail_slave
)paren
id|kfree
c_func
(paren
id|tail_slave
)paren
suffix:semicolon
id|kfree
(paren
id|queue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|queue
suffix:semicolon
)brace
r_static
r_void
DECL|function|eql_delete_slave_queue
id|eql_delete_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
id|slave_t
op_star
id|zapped
suffix:semicolon
multiline_comment|/* this should only be called when there isn&squot;t a timer running that scans&n;     the data periodicaly.. dev_close stops the timer... */
r_while
c_loop
(paren
op_logical_neg
id|eql_is_empty
(paren
id|queue
)paren
)paren
(brace
id|zapped
op_assign
id|eql_remove_slave
(paren
id|queue
comma
id|queue-&gt;head-&gt;next
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|zapped
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|queue-&gt;head-&gt;next
)paren
suffix:semicolon
id|kfree
(paren
id|queue-&gt;head
)paren
suffix:semicolon
id|kfree
(paren
id|queue
)paren
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|eql_insert_slave
id|eql_insert_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eql_is_full
(paren
id|queue
)paren
)paren
(brace
id|slave_t
op_star
id|duplicate_slave
op_assign
l_int|0
suffix:semicolon
id|duplicate_slave
op_assign
id|eql_find_slave_dev
(paren
id|queue
comma
id|slave-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|duplicate_slave
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&t;  printk (&quot;%s: found a duplicate, killing it and replacing&bslash;n&quot;,&n;&t;&t;  queue-&gt;master_dev-&gt;name); */
id|eql_delete_slave
(paren
id|eql_remove_slave
(paren
id|queue
comma
id|duplicate_slave
)paren
)paren
suffix:semicolon
)brace
id|slave-&gt;next
op_assign
id|queue-&gt;head-&gt;next
suffix:semicolon
id|queue-&gt;head-&gt;next
op_assign
id|slave
suffix:semicolon
id|queue-&gt;num_slaves
op_increment
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
id|slave_t
op_star
DECL|function|eql_remove_slave
id|eql_remove_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
id|slave_t
op_star
id|prev
suffix:semicolon
id|slave_t
op_star
id|curr
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|prev
op_assign
id|queue-&gt;head
suffix:semicolon
id|curr
op_assign
id|queue-&gt;head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|slave
op_logical_and
id|curr-&gt;dev
op_ne
l_int|0
)paren
(brace
multiline_comment|/* printk (&quot;%s: remove_slave; searching...&bslash;n&quot;, queue-&gt;master_dev-&gt;name); */
id|prev
op_assign
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curr
op_eq
id|slave
)paren
(brace
id|prev-&gt;next
op_assign
id|curr-&gt;next
suffix:semicolon
id|queue-&gt;num_slaves
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|curr
suffix:semicolon
)brace
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not found */
)brace
"&f;"
macro_line|#if 0
r_static
r_int
id|eql_insert_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eql_is_full
(paren
id|queue
)paren
)paren
(brace
id|slave
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
id|slave-&gt;dev
op_assign
id|dev
suffix:semicolon
id|slave-&gt;priority
op_assign
id|EQL_DEFAULT_SLAVE_PRIORITY
suffix:semicolon
id|slave-&gt;priority_bps
op_assign
id|EQL_DEFAULT_SLAVE_PRIORITY
suffix:semicolon
id|slave-&gt;priority_Bps
op_assign
id|EQL_DEFAULT_SLAVE_PRIORITY
op_div
l_int|8
suffix:semicolon
id|slave-&gt;next
op_assign
id|queue-&gt;head-&gt;next
suffix:semicolon
id|queue-&gt;head-&gt;next
op_assign
id|slave
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|eql_remove_slave_dev
id|eql_remove_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|prev
suffix:semicolon
id|slave_t
op_star
id|curr
suffix:semicolon
id|slave_t
op_star
id|target
suffix:semicolon
id|target
op_assign
id|eql_find_slave_dev
(paren
id|queue
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
l_int|0
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
id|prev
op_assign
id|queue-&gt;head
suffix:semicolon
id|curr
op_assign
id|prev-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|target
)paren
(brace
id|prev
op_assign
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
)brace
id|prev-&gt;next
op_assign
id|curr-&gt;next
suffix:semicolon
id|queue-&gt;num_slaves
op_decrement
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|curr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
"&f;"
r_static
r_inline
r_struct
id|device
op_star
DECL|function|eql_best_slave_dev
id|eql_best_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;best_slave
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;best_slave-&gt;dev
op_ne
l_int|0
)paren
r_return
id|queue-&gt;best_slave-&gt;dev
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
id|slave_t
op_star
DECL|function|eql_best_slave
id|eql_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|queue-&gt;best_slave
suffix:semicolon
)brace
"&f;"
r_static
r_inline
r_void
DECL|function|eql_schedule_slaves
id|eql_schedule_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_struct
id|device
op_star
id|master_dev
op_assign
id|queue-&gt;master_dev
suffix:semicolon
id|slave_t
op_star
id|best_slave
op_assign
l_int|0
suffix:semicolon
id|slave_t
op_star
id|slave_corpse
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|100
)paren
id|printk
(paren
l_string|&quot;%s: schedule %d slaves&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|eql_number_slaves
(paren
id|queue
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|eql_is_empty
(paren
id|queue
)paren
)paren
(brace
multiline_comment|/* no slaves to play with */
id|eql_set_best_slave
(paren
id|queue
comma
(paren
id|slave_t
op_star
)paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make a pass to set the best slave */
r_int
r_int
id|best_load
op_assign
(paren
r_int
r_int
)paren
id|ULONG_MAX
suffix:semicolon
id|slave_t
op_star
id|slave
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|slave
op_assign
id|eql_first_slave
(paren
id|queue
)paren
suffix:semicolon
id|i
op_le
id|eql_number_slaves
(paren
id|queue
)paren
suffix:semicolon
id|i
op_increment
comma
id|slave
op_assign
id|eql_next_slave
(paren
id|queue
comma
id|slave
)paren
)paren
(brace
multiline_comment|/* go through the slave list once, updating best_slave &n;&t;     whenever a new best_load is found, whenever a dead&n;&t;     slave is found, it is marked to be pulled out of the &n;&t;     queue */
r_int
r_int
id|slave_load
suffix:semicolon
r_int
r_int
id|bytes_queued
suffix:semicolon
r_int
r_int
id|priority_Bps
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
id|bytes_queued
op_assign
id|slave-&gt;bytes_queued
suffix:semicolon
id|priority_Bps
op_assign
id|slave-&gt;priority_Bps
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;dev
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|slave-&gt;dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
id|IFF_UP
)paren
(brace
id|slave_load
op_assign
(paren
id|ULONG_MAX
op_minus
(paren
id|ULONG_MAX
op_div
l_int|2
)paren
)paren
op_minus
(paren
id|priority_Bps
)paren
op_plus
id|bytes_queued
op_star
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|slave_load
OL
id|best_load
)paren
(brace
id|best_load
op_assign
id|slave_load
suffix:semicolon
id|best_slave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* we found a dead slave */
(brace
multiline_comment|/* we only bury one slave at a time, if more than&n;&t;&t;&t; one slave dies, we will bury him on the next &n;&t;&t;&t; reschedule. slaves don&squot;t die all at once that much&n;&t;&t;&t; anyway */
id|slave_corpse
op_assign
id|slave
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* for */
id|sti
(paren
)paren
suffix:semicolon
id|eql_set_best_slave
(paren
id|queue
comma
id|best_slave
)paren
suffix:semicolon
)brace
multiline_comment|/* else */
r_if
c_cond
(paren
id|slave_corpse
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;eql: scheduler found dead slave, burying...&bslash;n&quot;
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|eql_remove_slave
(paren
id|queue
comma
id|slave_corpse
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
"&f;"
r_static
id|slave_t
op_star
DECL|function|eql_find_slave_dev
id|eql_find_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
op_assign
l_int|0
suffix:semicolon
id|slave
op_assign
id|eql_first_slave
c_func
(paren
id|queue
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slave
op_ne
l_int|0
op_logical_and
id|slave-&gt;dev
op_ne
id|dev
op_logical_and
id|slave
op_ne
l_int|0
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|slave-&gt;dev
op_ne
l_int|0
)paren
id|printk
(paren
l_string|&quot;eql: find_slave_dev; looked at &squot;%s&squot;...&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;eql: find_slave_dev; looked at nothing...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|slave
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
r_return
id|slave
suffix:semicolon
)brace
"&f;"
r_static
r_inline
id|slave_t
op_star
DECL|function|eql_first_slave
id|eql_first_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|queue-&gt;head-&gt;next
suffix:semicolon
)brace
r_static
r_inline
id|slave_t
op_star
DECL|function|eql_next_slave
id|eql_next_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
r_return
id|slave-&gt;next
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|eql_set_best_slave
id|eql_set_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
id|queue-&gt;best_slave
op_assign
id|slave
suffix:semicolon
)brace
"&f;"
macro_line|#if 0
r_static
r_inline
r_int
id|eql_lock_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;eql: lock == %d&bslash;n&quot;
comma
id|queue-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;lock
)paren
(brace
id|printk
(paren
l_string|&quot;eql: lock_slave-q sleeping for lock&bslash;n&quot;
)paren
suffix:semicolon
id|sleep_on
(paren
op_amp
id|eql_queue_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;eql: lock_slave-q woken up&bslash;n&quot;
)paren
suffix:semicolon
id|queue-&gt;lock
op_assign
l_int|1
suffix:semicolon
)brace
id|queue-&gt;lock
op_assign
l_int|1
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_inline
r_int
id|eql_unlock_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;lock
op_ne
l_int|0
)paren
(brace
id|queue-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;eql: unlock_slave-q waking up lock waiters&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
(paren
op_amp
id|eql_queue_lock
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif 
r_static
r_inline
r_int
DECL|function|eql_is_locked_slave_queue
id|eql_is_locked_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|test_bit
c_func
(paren
l_int|1
comma
(paren
r_void
op_star
)paren
op_amp
id|queue-&gt;lock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|eql_timer
id|eql_timer
c_func
(paren
r_int
r_int
id|param
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|param
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
id|slave_t
op_star
id|slave_corpse
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eql_is_empty
(paren
id|eql-&gt;queue
)paren
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|slave
op_assign
id|eql_first_slave
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|i
op_le
id|eql_number_slaves
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|i
op_increment
comma
id|slave
op_assign
id|eql_next_slave
(paren
id|eql-&gt;queue
comma
id|slave
)paren
)paren
(brace
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|slave-&gt;dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
id|IFF_UP
)paren
(brace
id|slave-&gt;bytes_queued
op_sub_assign
id|slave-&gt;priority_Bps
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;bytes_queued
OL
l_int|0
)paren
id|slave-&gt;bytes_queued
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|slave_corpse
op_assign
id|slave
suffix:semicolon
)brace
)brace
)brace
id|sti
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave_corpse
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;eql: timer found dead slave, burying...&bslash;n&quot;
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|eql_remove_slave
(paren
id|eql-&gt;queue
comma
id|slave_corpse
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|eql-&gt;timer_on
op_ne
l_int|0
)paren
(brace
id|eql-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|EQL_DEFAULT_RESCHED_IVAL
suffix:semicolon
id|add_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|variable|dev_eql
r_static
r_struct
id|device
id|dev_eql
op_assign
(brace
l_string|&quot;eql&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|eql_init
)brace
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_eql
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eql: register_netdev() returned non-zero.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|dev_eql
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Local Variables: &n; * compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c eql.c&quot;&n; * version-control: t&n; * kept-new-versions: 20&n; * End:&n; */
eof
