multiline_comment|/*&n; * Equalizer Load-balancer for serial network interfaces.&n; *&n; * (c) Copyright 1995 Simon &quot;Guru Aleph-Null&quot; Janes&n; * NCM: Network and Communications Management, Inc.&n; *&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU Public License, incorporated herein by reference.&n; * &n; * The author may be reached as simon@ncm.com, or C/O&n; *    NCM&n; *    Attn: Simon Janes&n; *    6803 Whittier Ave&n; *    McLean VA 22101&n; *    Phone: 1-703-847-0040 ext 103&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;Equalizer1996: $Revision: 1.2.1 $ $Date: 1996/09/22 13:52:00 $ Simon Janes (simon@ncm.com)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Sources:&n; *   skeleton.c by Donald Becker.&n; * Inspirations:&n; *   The Harried and Overworked Alan Cox&n; * Conspiracies:&n; *   The Alan Cox and Mike McLagan plot to get someone else to do the code, &n; *   which turned out to be me.&n; */
multiline_comment|/*&n; * $Log: eql.c,v $&n; * Revision 1.2  1996/04/11 17:51:52  guru&n; * Added one-line eql_remove_slave patch.&n; *&n; * Revision 1.1  1996/04/11 17:44:17  guru&n; * Initial revision&n; *&n; * Revision 3.13  1996/01/21  15:17:18  alan&n; * tx_queue_len changes.&n; * reformatted.&n; *&n; * Revision 3.12  1995/03/22  21:07:51  anarchy&n; * Added capable() checks on configuration.&n; * Moved header file.&n; *&n; * Revision 3.11  1995/01/19  23:14:31  guru&n; * &t;&t;      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued * 8;&n; *&n; * Revision 3.10  1995/01/19  23:07:53  guru&n; * back to&n; * &t;&t;      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued;&n; *&n; * Revision 3.9  1995/01/19  22:38:20  guru&n; * &t;&t;      slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued * 4;&n; *&n; * Revision 3.8  1995/01/19  22:30:55  guru&n; *       slave_load = (ULONG_MAX - (ULONG_MAX / 2)) -&n; * &t;&t;&t;(priority_Bps) + bytes_queued * 2;&n; *&n; * Revision 3.7  1995/01/19  21:52:35  guru&n; * printk&squot;s trimmed out.&n; *&n; * Revision 3.6  1995/01/19  21:49:56  guru&n; * This is working pretty well. I gained 1 K/s in speed.. now it&squot;s just&n; * robustness and printk&squot;s to be diked out.&n; *&n; * Revision 3.5  1995/01/18  22:29:59  guru&n; * still crashes the kernel when the lock_wait thing is woken up.&n; *&n; * Revision 3.4  1995/01/18  21:59:47  guru&n; * Broken set-bit locking snapshot&n; *&n; * Revision 3.3  1995/01/17  22:09:18  guru&n; * infinite sleep in a lock somewhere..&n; *&n; * Revision 3.2  1995/01/15  16:46:06  guru&n; * Log trimmed of non-pertinent 1.x branch messages&n; *&n; * Revision 3.1  1995/01/15  14:41:45  guru&n; * New Scheduler and timer stuff...&n; *&n; * Revision 1.15  1995/01/15  14:29:02  guru&n; * Will make 1.14 (now 1.15) the 3.0 branch, and the 1.12 the 2.0 branch, the one&n; * with the dumber scheduler&n; *&n; * Revision 1.14  1995/01/15  02:37:08  guru&n; * shock.. the kept-new-versions could have zonked working&n; * stuff.. shudder&n; *&n; * Revision 1.13  1995/01/15  02:36:31  guru&n; * big changes&n; *&n; * &t;scheduler was torn out and replaced with something smarter&n; *&n; * &t;global names not prefixed with eql_ were renamed to protect&n; * &t;against namespace collisions&n; *&n; * &t;a few more abstract interfaces were added to facilitate any&n; * &t;potential change of datastructure.  the driver is still using&n; * &t;a linked list of slaves.  going to a heap would be a bit of&n; * &t;an overkill.&n; *&n; * &t;this compiles fine with no warnings.&n; *&n; * &t;the locking mechanism and timer stuff must be written however,&n; * &t;this version will not work otherwise&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_eql.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifndef EQL_DEBUG
multiline_comment|/* #undef EQL_DEBUG      -* print nothing at all, not even a boot-banner */
multiline_comment|/* #define EQL_DEBUG 1   -* print only the boot-banner */
multiline_comment|/* #define EQL_DEBUG 5   -* print major function entries */
multiline_comment|/* #define EQL_DEBUG 20  -* print subfunction entries */
multiline_comment|/* #define EQL_DEBUG 50  -* print utility entries */
multiline_comment|/* #define EQL_DEBUG 100 -* print voluminous function entries */
DECL|macro|EQL_DEBUG
mdefine_line|#define EQL_DEBUG 1
macro_line|#endif
DECL|variable|eql_debug
r_static
r_int
r_int
id|eql_debug
op_assign
id|EQL_DEBUG
suffix:semicolon
r_static
r_int
id|eql_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_slave_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_struct
id|net_device_stats
op_star
id|eql_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* ioctl() handlers&n;   ---------------- */
r_static
r_int
id|eql_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srq
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_emancipate
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srq
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_g_slave_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slave_config_t
op_star
id|sc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_s_slave_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slave_config_t
op_star
id|sc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_g_master_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|master_config_t
op_star
id|mc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_s_master_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|master_config_t
op_star
id|mc
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_slave
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_master
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_t
op_star
id|eql_new_slave
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_void
id|eql_delete_slave
c_func
(paren
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* static long eql_slave_priority(slave_t *slave); -*  */
r_static
r_inline
r_int
id|eql_number_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_empty
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_int
id|eql_is_full
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_queue_t
op_star
id|eql_new_slave_queue
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_void
id|eql_delete_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_int
id|eql_insert_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_t
op_star
id|eql_remove_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* static int eql_insert_slave_dev(slave_queue_t *queue, struct net_device *dev); -*  */
r_static
r_int
id|eql_remove_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_struct
id|net_device
op_star
id|eql_best_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
id|slave_t
op_star
id|eql_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
id|slave_t
op_star
id|eql_first_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
id|slave_t
op_star
id|eql_next_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_void
id|eql_set_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
r_inline
r_void
id|eql_schedule_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
suffix:semicolon
multiline_comment|/*  */
r_static
id|slave_t
op_star
id|eql_find_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*  */
multiline_comment|/* static inline eql_lock_slave_queue(slave_queue_t *queue); -*  */
multiline_comment|/* static inline eql_unlock_slave_queue(slave_queue_t *queue); -*  */
r_static
r_void
id|eql_timer
c_func
(paren
r_int
r_int
id|param
)paren
suffix:semicolon
multiline_comment|/*  */
"&f;"
multiline_comment|/* struct net_device * interface functions &n;   ---------------------------------------------------------&n;   */
DECL|function|eql_init
r_static
r_int
id|__init
id|eql_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* static unsigned num_masters     = 0; */
id|equalizer_t
op_star
id|eql
op_assign
l_int|0
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|version_printed
op_increment
op_eq
l_int|0
op_logical_and
id|eql_debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialize the device structure. &n;&t; */
id|dev-&gt;priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|equalizer_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
id|equalizer_t
)paren
)paren
suffix:semicolon
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|eql-&gt;stats
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql-&gt;stats
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|eql-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|init_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
id|eql-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev-&gt;priv
suffix:semicolon
id|eql-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|EQL_DEFAULT_RESCHED_IVAL
suffix:semicolon
id|eql-&gt;timer.function
op_assign
op_amp
id|eql_timer
suffix:semicolon
id|eql-&gt;timer_on
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;open
op_assign
id|eql_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|eql_close
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|eql_ioctl
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|eql_slave_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|eql_get_stats
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;Fill in the fields of the device structure with &n;&t; *&t;eql-generic values. &n;&t; */
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now we undo some of the things that eth_setup does&n;&t; * &t;that we don&squot;t like &n;&t; */
id|dev-&gt;mtu
op_assign
id|EQL_DEFAULT_MTU
suffix:semicolon
multiline_comment|/* set to 576 in eql.h */
id|dev-&gt;flags
op_assign
id|IFF_MASTER
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_SLIP
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* Hands them off fast */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_open
r_static
r_int
id|eql_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|slave_queue_t
op_star
id|new_queue
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|5
)paren
id|printk
(paren
l_string|&quot;%s: open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|printk
(paren
l_string|&quot;%s: remember to turn off Van-Jacobson compression on your slave devices.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|new_queue
op_assign
id|eql_new_slave_queue
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_queue
op_ne
l_int|0
)paren
(brace
id|new_queue-&gt;master_dev
op_assign
id|dev
suffix:semicolon
id|eql-&gt;queue
op_assign
id|new_queue
suffix:semicolon
id|eql-&gt;queue-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|eql-&gt;min_slaves
op_assign
l_int|1
suffix:semicolon
id|eql-&gt;max_slaves
op_assign
id|EQL_DEFAULT_MAX_SLAVES
suffix:semicolon
multiline_comment|/* 4 usually... */
id|printk
(paren
l_string|&quot;%s: adding timer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|eql-&gt;timer_on
op_assign
l_int|1
suffix:semicolon
id|add_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|eql_close
r_static
r_int
id|eql_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|5
)paren
id|printk
(paren
l_string|&quot;%s: close&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;The timer has to be stopped first before we start hacking away&n;&t; *&t;at the data structure it scans every so often... &n;&t; */
macro_line|#ifdef EQL_DEBUG
id|printk
(paren
l_string|&quot;%s: stopping timer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif&t;
id|eql-&gt;timer_on
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
id|eql_delete_slave_queue
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_ioctl
r_static
r_int
id|eql_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_ne
id|EQL_GETMASTRCFG
op_logical_and
id|cmd
op_ne
id|EQL_GETSLAVECFG
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|EQL_ENSLAVE
suffix:colon
r_return
id|eql_enslave
(paren
id|dev
comma
(paren
id|slaving_request_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_EMANCIPATE
suffix:colon
r_return
id|eql_emancipate
(paren
id|dev
comma
(paren
id|slaving_request_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_GETSLAVECFG
suffix:colon
r_return
id|eql_g_slave_cfg
(paren
id|dev
comma
(paren
id|slave_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_SETSLAVECFG
suffix:colon
r_return
id|eql_s_slave_cfg
(paren
id|dev
comma
(paren
id|slave_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_GETMASTRCFG
suffix:colon
r_return
id|eql_g_master_cfg
(paren
id|dev
comma
(paren
id|master_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_case
id|EQL_SETMASTRCFG
suffix:colon
r_return
id|eql_s_master_cfg
(paren
id|dev
comma
(paren
id|master_config_t
op_star
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
DECL|function|eql_slave_xmit
r_static
r_int
id|eql_slave_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
op_assign
l_int|0
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|eql_schedule_slaves
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|slave
op_assign
id|eql_best_slave
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|slave_dev
op_assign
id|slave
ques
c_cond
id|slave-&gt;dev
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|100
)paren
id|printk
(paren
l_string|&quot;%s: %d slaves xmitng %d B %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|eql_number_slaves
(paren
id|eql-&gt;queue
)paren
comma
id|skb-&gt;len
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;dev
op_assign
id|slave_dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
(paren
id|skb
)paren
suffix:semicolon
id|eql-&gt;stats-&gt;tx_packets
op_increment
suffix:semicolon
id|slave-&gt;bytes_queued
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;The alternative for this is the return 1 and have&n;&t;&t; *&t;dev_queue_xmit just queue it up on the eql&squot;s queue. &n;&t;&t; */
id|eql-&gt;stats-&gt;tx_dropped
op_increment
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|eql_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
id|eql-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Private ioctl functions&n; */
DECL|function|eql_enslave
r_static
r_int
id|eql_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srqp
)paren
(brace
r_struct
id|net_device
op_star
id|master_dev
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
id|slaving_request_t
id|srq
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|srq
comma
id|srqp
comma
r_sizeof
(paren
id|slaving_request_t
)paren
)paren
)paren
(brace
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;EQL enslave: error detected by copy_from_user&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif  
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: enslave &squot;%s&squot; %ld bps&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|srq.slave_name
comma
id|srq.priority
)paren
suffix:semicolon
macro_line|#endif  
id|master_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* for &quot;clarity&quot; */
id|slave_dev
op_assign
id|__dev_get_by_name
(paren
id|srq.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master_dev
op_ne
l_int|0
op_logical_and
id|slave_dev
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
id|IFF_UP
)paren
(brace
multiline_comment|/*slave is not a master &amp; not already a slave:*/
r_if
c_cond
(paren
op_logical_neg
id|eql_is_master
(paren
id|slave_dev
)paren
op_logical_and
op_logical_neg
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
(brace
id|slave_t
op_star
id|s
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
id|s-&gt;dev
op_assign
id|slave_dev
suffix:semicolon
id|s-&gt;priority
op_assign
id|srq.priority
suffix:semicolon
id|s-&gt;priority_bps
op_assign
id|srq.priority
suffix:semicolon
id|s-&gt;priority_Bps
op_assign
id|srq.priority
op_div
l_int|8
suffix:semicolon
id|slave_dev-&gt;flags
op_or_assign
id|IFF_SLAVE
suffix:semicolon
id|eql_insert_slave
(paren
id|eql-&gt;queue
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef EQL_DEBUG
r_else
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;EQL enslave: slave is master or slave is already slave&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif  
)brace
macro_line|#ifdef EQL_DEBUG
r_else
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;EQL enslave: master device not up!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif  
)brace
macro_line|#ifdef EQL_DEBUG
r_else
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;EQL enslave: master or slave are NULL&quot;
)paren
suffix:semicolon
macro_line|#endif  
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|eql_emancipate
r_static
r_int
id|eql_emancipate
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slaving_request_t
op_star
id|srqp
)paren
(brace
r_struct
id|net_device
op_star
id|master_dev
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
id|slaving_request_t
id|srq
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|srq
comma
id|srqp
comma
r_sizeof
(paren
id|slaving_request_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: emancipate `%s`&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|srq.slave_name
)paren
suffix:semicolon
macro_line|#endif
id|master_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* for &quot;clarity&quot; */
id|slave_dev
op_assign
id|__dev_get_by_name
(paren
id|srq.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
multiline_comment|/* really is a slave */
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
id|slave_dev-&gt;flags
op_assign
id|slave_dev-&gt;flags
op_amp
op_complement
id|IFF_SLAVE
suffix:semicolon
id|eql_remove_slave_dev
(paren
id|eql-&gt;queue
comma
id|slave_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|eql_g_slave_cfg
r_static
r_int
id|eql_g_slave_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slave_config_t
op_star
id|scp
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|equalizer_t
op_star
id|eql
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
id|slave_config_t
id|sc
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sc
comma
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: get config for slave `%s&squot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sc.slave_name
)paren
suffix:semicolon
macro_line|#endif
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|slave_dev
op_assign
id|__dev_get_by_name
(paren
id|sc.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
(brace
id|slave
op_assign
id|eql_find_slave_dev
(paren
id|eql-&gt;queue
comma
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
id|sc.priority
op_assign
id|slave-&gt;priority
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|scp
comma
op_amp
id|sc
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|eql_s_slave_cfg
r_static
r_int
id|eql_s_slave_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|slave_config_t
op_star
id|scp
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|equalizer_t
op_star
id|eql
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
id|slave_config_t
id|sc
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sc
comma
id|scp
comma
r_sizeof
(paren
id|slave_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: set config for slave `%s&squot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sc.slave_name
)paren
suffix:semicolon
macro_line|#endif
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|slave_dev
op_assign
id|__dev_get_by_name
(paren
id|sc.slave_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eql_is_slave
(paren
id|slave_dev
)paren
)paren
(brace
id|slave
op_assign
id|eql_find_slave_dev
(paren
id|eql-&gt;queue
comma
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
id|slave-&gt;priority
op_assign
id|sc.priority
suffix:semicolon
id|slave-&gt;priority_bps
op_assign
id|sc.priority
suffix:semicolon
id|slave-&gt;priority_Bps
op_assign
id|sc.priority
op_div
l_int|8
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|eql_g_master_cfg
r_static
r_int
id|eql_g_master_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|master_config_t
op_star
id|mcp
)paren
(brace
id|equalizer_t
op_star
id|eql
suffix:semicolon
id|master_config_t
id|mc
suffix:semicolon
macro_line|#if EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: get master config&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|eql_is_master
(paren
id|dev
)paren
)paren
(brace
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mc.max_slaves
op_assign
id|eql-&gt;max_slaves
suffix:semicolon
id|mc.min_slaves
op_assign
id|eql-&gt;min_slaves
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|mcp
comma
op_amp
id|mc
comma
r_sizeof
(paren
id|master_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|eql_s_master_cfg
r_static
r_int
id|eql_s_master_cfg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|master_config_t
op_star
id|mcp
)paren
(brace
id|equalizer_t
op_star
id|eql
suffix:semicolon
id|master_config_t
id|mc
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|mc
comma
id|mcp
comma
r_sizeof
(paren
id|master_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#if EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|20
)paren
id|printk
(paren
l_string|&quot;%s: set master config&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|eql_is_master
(paren
id|dev
)paren
)paren
(brace
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|eql-&gt;max_slaves
op_assign
id|mc.max_slaves
suffix:semicolon
id|eql-&gt;min_slaves
op_assign
id|mc.min_slaves
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Private device support functions&n; */
DECL|function|eql_is_slave
r_static
r_inline
r_int
id|eql_is_slave
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_eq
id|IFF_SLAVE
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_is_master
r_static
r_inline
r_int
id|eql_is_master
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_MASTER
)paren
op_eq
id|IFF_MASTER
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_new_slave
r_static
id|slave_t
op_star
id|eql_new_slave
c_func
(paren
r_void
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|slave_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
)paren
id|memset
c_func
(paren
id|slave
comma
l_int|0
comma
r_sizeof
(paren
id|slave_t
)paren
)paren
suffix:semicolon
r_return
id|slave
suffix:semicolon
)brace
DECL|function|eql_delete_slave
r_static
r_void
id|eql_delete_slave
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|kfree
(paren
id|slave
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;&t;&t;&t;/* not currently used, will be used&n;&t;&t;&t;&t;   when we really use a priority queue */
r_static
r_int
id|slave_Bps
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
r_return
(paren
id|slave-&gt;priority_Bps
)paren
suffix:semicolon
)brace
r_static
r_int
id|slave_bps
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
r_return
(paren
id|slave-&gt;priority_bps
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|eql_number_slaves
r_static
r_inline
r_int
id|eql_number_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|queue-&gt;num_slaves
suffix:semicolon
)brace
DECL|function|eql_is_empty
r_static
r_inline
r_int
id|eql_is_empty
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_if
c_cond
(paren
id|eql_number_slaves
(paren
id|queue
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_is_full
r_static
r_inline
r_int
id|eql_is_full
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|queue-&gt;master_dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|eql_number_slaves
(paren
id|queue
)paren
op_eq
id|eql-&gt;max_slaves
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_new_slave_queue
r_static
id|slave_queue_t
op_star
id|eql_new_slave_queue
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_queue_t
op_star
id|queue
suffix:semicolon
id|slave_t
op_star
id|head_slave
suffix:semicolon
id|slave_t
op_star
id|tail_slave
suffix:semicolon
id|queue
op_assign
(paren
id|slave_queue_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|slave_queue_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|queue
)paren
r_goto
id|err_out
suffix:semicolon
id|head_slave
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head_slave
)paren
r_goto
id|err_out_queue
suffix:semicolon
id|tail_slave
op_assign
id|eql_new_slave
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail_slave
)paren
r_goto
id|err_out_hs
suffix:semicolon
id|memset
(paren
id|queue
comma
l_int|0
comma
r_sizeof
(paren
id|slave_queue_t
)paren
)paren
suffix:semicolon
id|head_slave-&gt;next
op_assign
id|tail_slave
suffix:semicolon
id|tail_slave-&gt;next
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;head
op_assign
id|head_slave
suffix:semicolon
id|queue-&gt;num_slaves
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;master_dev
op_assign
id|dev
suffix:semicolon
r_return
id|queue
suffix:semicolon
id|err_out_hs
suffix:colon
id|kfree
(paren
id|head_slave
)paren
suffix:semicolon
id|err_out_queue
suffix:colon
id|kfree
(paren
id|queue
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|eql_delete_slave_queue
r_static
r_void
id|eql_delete_slave_queue
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
id|slave_t
op_star
id|zapped
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This should only be called when there isn&squot;t a&n;&t; *&t;timer running that scans the data periodically.. &n;&t; *&t;dev_close stops the timer... &n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|eql_is_empty
(paren
id|queue
)paren
)paren
(brace
id|zapped
op_assign
id|eql_remove_slave
(paren
id|queue
comma
id|queue-&gt;head-&gt;next
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|zapped
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|queue-&gt;head-&gt;next
)paren
suffix:semicolon
id|kfree
(paren
id|queue-&gt;head
)paren
suffix:semicolon
id|kfree
(paren
id|queue
)paren
suffix:semicolon
)brace
DECL|function|eql_insert_slave
r_static
r_int
id|eql_insert_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eql_is_full
(paren
id|queue
)paren
)paren
(brace
id|slave_t
op_star
id|duplicate_slave
op_assign
l_int|0
suffix:semicolon
id|duplicate_slave
op_assign
id|eql_find_slave_dev
(paren
id|queue
comma
id|slave-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|duplicate_slave
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&t;&t;&t;  printk (&quot;%s: found a duplicate, killing it and replacing&bslash;n&quot;,&n;&t;&t;&t;&t;  queue-&gt;master_dev-&gt;name); */
id|eql_delete_slave
(paren
id|eql_remove_slave
(paren
id|queue
comma
id|duplicate_slave
)paren
)paren
suffix:semicolon
)brace
id|slave-&gt;next
op_assign
id|queue-&gt;head-&gt;next
suffix:semicolon
id|queue-&gt;head-&gt;next
op_assign
id|slave
suffix:semicolon
id|queue-&gt;num_slaves
op_increment
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|eql_remove_slave
r_static
id|slave_t
op_star
id|eql_remove_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
id|slave_t
op_star
id|prev
suffix:semicolon
id|slave_t
op_star
id|curr
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|prev
op_assign
id|queue-&gt;head
suffix:semicolon
id|curr
op_assign
id|queue-&gt;head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|slave
op_logical_and
id|curr-&gt;dev
op_ne
l_int|0
)paren
(brace
multiline_comment|/* &t;&t;printk (&quot;%s: remove_slave; searching...&bslash;n&quot;, queue-&gt;master_dev-&gt;name); */
id|prev
op_assign
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curr
op_eq
id|slave
)paren
(brace
id|prev-&gt;next
op_assign
id|curr-&gt;next
suffix:semicolon
id|queue-&gt;num_slaves
op_decrement
suffix:semicolon
id|curr-&gt;dev-&gt;flags
op_assign
id|curr-&gt;dev-&gt;flags
op_amp
op_complement
id|IFF_SLAVE
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|curr
suffix:semicolon
)brace
id|sti
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not found */
)brace
DECL|function|eql_remove_slave_dev
r_static
r_int
id|eql_remove_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|prev
suffix:semicolon
id|slave_t
op_star
id|curr
suffix:semicolon
id|slave_t
op_star
id|target
suffix:semicolon
id|target
op_assign
id|eql_find_slave_dev
(paren
id|queue
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
l_int|0
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
id|prev
op_assign
id|queue-&gt;head
suffix:semicolon
id|curr
op_assign
id|prev-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|target
)paren
(brace
id|prev
op_assign
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
)brace
id|prev-&gt;next
op_assign
id|curr-&gt;next
suffix:semicolon
id|queue-&gt;num_slaves
op_decrement
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|curr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|eql_best_slave_dev
r_static
r_inline
r_struct
id|net_device
op_star
id|eql_best_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;best_slave
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;best_slave-&gt;dev
op_ne
l_int|0
)paren
r_return
id|queue-&gt;best_slave-&gt;dev
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_best_slave
r_static
r_inline
id|slave_t
op_star
id|eql_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|queue-&gt;best_slave
suffix:semicolon
)brace
DECL|function|eql_schedule_slaves
r_static
r_inline
r_void
id|eql_schedule_slaves
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_struct
id|net_device
op_star
id|master_dev
op_assign
id|queue-&gt;master_dev
suffix:semicolon
id|slave_t
op_star
id|best_slave
op_assign
l_int|0
suffix:semicolon
id|slave_t
op_star
id|slave_corpse
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef EQL_DEBUG
r_if
c_cond
(paren
id|eql_debug
op_ge
l_int|100
)paren
id|printk
(paren
l_string|&quot;%s: schedule %d slaves&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|eql_number_slaves
(paren
id|queue
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|eql_is_empty
(paren
id|queue
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;No slaves to play with &n;&t;&t; */
id|eql_set_best_slave
(paren
id|queue
comma
(paren
id|slave_t
op_star
)paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;Make a pass to set the best slave &n;&t;&t; */
r_int
r_int
id|best_load
op_assign
(paren
r_int
r_int
)paren
id|ULONG_MAX
suffix:semicolon
id|slave_t
op_star
id|slave
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|slave
op_assign
id|eql_first_slave
(paren
id|queue
)paren
suffix:semicolon
id|i
op_le
id|eql_number_slaves
(paren
id|queue
)paren
suffix:semicolon
id|i
op_increment
comma
id|slave
op_assign
id|eql_next_slave
(paren
id|queue
comma
id|slave
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Go through the slave list once, updating best_slave &n;&t;&t;&t; *      whenever a new best_load is found, whenever a dead&n;&t;&t;&t; *&t;slave is found, it is marked to be pulled out of the &n;&t;&t;&t; *&t;queue &n;&t;&t;&t; */
r_int
r_int
id|slave_load
suffix:semicolon
r_int
r_int
id|bytes_queued
suffix:semicolon
r_int
r_int
id|priority_Bps
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
id|bytes_queued
op_assign
id|slave-&gt;bytes_queued
suffix:semicolon
id|priority_Bps
op_assign
id|slave-&gt;priority_Bps
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;dev
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|slave-&gt;dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
id|IFF_UP
)paren
(brace
id|slave_load
op_assign
(paren
id|ULONG_MAX
op_minus
(paren
id|ULONG_MAX
op_div
l_int|2
)paren
)paren
op_minus
(paren
id|priority_Bps
)paren
op_plus
id|bytes_queued
op_star
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|slave_load
OL
id|best_load
)paren
(brace
id|best_load
op_assign
id|slave_load
suffix:semicolon
id|best_slave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* we found a dead slave */
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; *&t;We only bury one slave at a time, if more than&n;&t;&t;&t;&t;&t;&t; *&t;one slave dies, we will bury him on the next &n;&t;&t;&t;&t;&t;&t; *&t;reschedule. slaves don&squot;t die all at once that &n;&t;&t;&t;&t;&t;&t; *&t;much anyway &n;&t;&t;&t;&t;&t;&t; */
id|slave_corpse
op_assign
id|slave
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* for */
id|sti
(paren
)paren
suffix:semicolon
id|eql_set_best_slave
(paren
id|queue
comma
id|best_slave
)paren
suffix:semicolon
)brace
multiline_comment|/* else */
r_if
c_cond
(paren
id|slave_corpse
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;eql: scheduler found dead slave, burying...&bslash;n&quot;
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|eql_remove_slave
(paren
id|queue
comma
id|slave_corpse
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|eql_find_slave_dev
r_static
id|slave_t
op_star
id|eql_find_slave_dev
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
op_assign
l_int|0
suffix:semicolon
id|slave
op_assign
id|eql_first_slave
c_func
(paren
id|queue
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slave
op_ne
l_int|0
op_logical_and
id|slave-&gt;dev
op_ne
id|dev
op_logical_and
id|slave
op_ne
l_int|0
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|slave-&gt;dev
op_ne
l_int|0
)paren
id|printk
(paren
l_string|&quot;eql: find_slave_dev; looked at &squot;%s&squot;...&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;eql: find_slave_dev; looked at nothing...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|slave
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
r_return
id|slave
suffix:semicolon
)brace
"&f;"
DECL|function|eql_first_slave
r_static
r_inline
id|slave_t
op_star
id|eql_first_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
)paren
(brace
r_return
id|queue-&gt;head-&gt;next
suffix:semicolon
)brace
DECL|function|eql_next_slave
r_static
r_inline
id|slave_t
op_star
id|eql_next_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
r_return
id|slave-&gt;next
suffix:semicolon
)brace
DECL|function|eql_set_best_slave
r_static
r_inline
r_void
id|eql_set_best_slave
c_func
(paren
id|slave_queue_t
op_star
id|queue
comma
id|slave_t
op_star
id|slave
)paren
(brace
id|queue-&gt;best_slave
op_assign
id|slave
suffix:semicolon
)brace
DECL|function|eql_timer
r_static
r_void
id|eql_timer
c_func
(paren
r_int
r_int
id|param
)paren
(brace
id|equalizer_t
op_star
id|eql
op_assign
(paren
id|equalizer_t
op_star
)paren
id|param
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
id|slave_t
op_star
id|slave_corpse
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eql_is_empty
(paren
id|eql-&gt;queue
)paren
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|slave
op_assign
id|eql_first_slave
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|i
op_le
id|eql_number_slaves
(paren
id|eql-&gt;queue
)paren
suffix:semicolon
id|i
op_increment
comma
id|slave
op_assign
id|eql_next_slave
(paren
id|eql-&gt;queue
comma
id|slave
)paren
)paren
(brace
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|slave-&gt;dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
id|IFF_UP
)paren
(brace
id|slave-&gt;bytes_queued
op_sub_assign
id|slave-&gt;priority_Bps
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;bytes_queued
OL
l_int|0
)paren
id|slave-&gt;bytes_queued
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|slave_corpse
op_assign
id|slave
suffix:semicolon
)brace
)brace
id|sti
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave_corpse
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;eql: timer found dead slave, burying...&bslash;n&quot;
)paren
suffix:semicolon
id|eql_delete_slave
(paren
id|eql_remove_slave
(paren
id|eql-&gt;queue
comma
id|slave_corpse
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|eql-&gt;timer_on
op_ne
l_int|0
)paren
(brace
id|eql-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|EQL_DEFAULT_RESCHED_IVAL
suffix:semicolon
id|add_timer
(paren
op_amp
id|eql-&gt;timer
)paren
suffix:semicolon
)brace
)brace
DECL|variable|dev_eql
r_static
r_struct
id|net_device
id|dev_eql
suffix:semicolon
DECL|function|eql_init_module
r_static
r_int
id|__init
id|eql_init_module
c_func
(paren
r_void
)paren
(brace
id|strcpy
c_func
(paren
id|dev_eql.name
comma
l_string|&quot;eql&quot;
)paren
suffix:semicolon
id|dev_eql.init
op_assign
id|eql_init
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_eql
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eql: register_netdev() returned non-zero.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eql_cleanup_module
r_static
r_void
id|__exit
id|eql_cleanup_module
c_func
(paren
r_void
)paren
(brace
id|kfree
c_func
(paren
(paren
(paren
id|equalizer_t
op_star
)paren
id|dev_eql.priv
)paren
op_member_access_from_pointer
id|stats
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev_eql.priv
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|dev_eql
)paren
suffix:semicolon
)brace
DECL|variable|eql_init_module
id|module_init
c_func
(paren
id|eql_init_module
)paren
suffix:semicolon
DECL|variable|eql_cleanup_module
id|module_exit
c_func
(paren
id|eql_cleanup_module
)paren
suffix:semicolon
multiline_comment|/*&n; * Local Variables: &n; * compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c eql.c&quot;&n; * version-control: t&n; * kept-new-versions: 20&n; * End:&n; */
eof
