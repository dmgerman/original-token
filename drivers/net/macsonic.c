multiline_comment|/*&n; * macsonic.c&n; *&n; * (C) 1998 Alan Cox&n; *&n; * Debugging Andreas Ehliar, Michael Schmitz&n; *&n; * Based on code&n; * (C) 1996 by Thomas Bogendoerfer (tsbogend@bigbug.franken.de)&n; * &n; * This driver is based on work from Andreas Busse, but most of&n; * the code is rewritten.&n; * &n; * (C) 1995 by Andreas Busse (andy@waldorf-gmbh.de)&n; *&n; * A driver for the Mac onboard Sonic ethernet chip.&n; *&n; * 98/12/21 MSch: judged from tests on Q800, it&squot;s basically working, &n; *&t;&t;  but eating up both receive and transmit resources&n; *&t;&t;  and duplicating packets. Needs more testing.&n; *&n; * 99/01/03 MSch: upgraded to version 0.92 of the core driver, fixed.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/nubus.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;config/macsonic.h&gt;
DECL|macro|SREGS_PAD
mdefine_line|#define SREGS_PAD(n)    u16 n;
macro_line|#include &quot;sonic.h&quot;
r_extern
r_int
id|mac_onboard_sonic_probe
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|setup_debug
r_static
r_int
id|setup_debug
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_offset
r_static
r_int
id|setup_offset
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_shift
r_static
r_int
id|setup_shift
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * This seems to be the right default for the Q800&n; */
DECL|variable|reg_offset
r_static
r_int
id|reg_offset
op_assign
l_int|0
suffix:semicolon
DECL|variable|reg_shift
r_static
r_int
id|reg_shift
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Macros to access SONIC registers&n; */
DECL|macro|MAC_SONIC_REGISTERS
mdefine_line|#define MAC_SONIC_REGISTERS&t;0x50F0A000
DECL|macro|MAC_SONIC_PROM_BASE
mdefine_line|#define MAC_SONIC_PROM_BASE&t;0x50f08000
DECL|macro|MAC_SONIC_IRQ
mdefine_line|#define MAC_SONIC_IRQ&t;&t;9&t;/* Nubus 9 */
multiline_comment|/*&n; *    FIXME: We may need to invert the byte ordering. These should&n; *      be ok for other aspects as they are uncached spaces.&n; *      The original macros from jazzsonic.c works for me&n; *      on my LC 630, YMMV /Andreas Ehliar&n; */
macro_line|#if 0
mdefine_line|#define SONIC_READ(reg) &bslash;&n;&t;*((volatile unsigned int *)base_addr+((reg)&lt;&lt;2)+2)
mdefine_line|#define SONIC_WRITE(reg,val) &bslash;&n;&t;*((volatile unsigned int *)base_addr+((reg)&lt;&lt;2)+2) = val
macro_line|#else
DECL|macro|SONIC_READ
mdefine_line|#define SONIC_READ(reg) &bslash;&n;&t;*((volatile unsigned int *)base_addr+reg)
DECL|macro|SONIC_WRITE
mdefine_line|#define SONIC_WRITE(reg,val) &bslash;&n;&t;*((volatile unsigned int *)base_addr+reg) = val
macro_line|#endif
DECL|macro|SONIC_READ_PROM
mdefine_line|#define SONIC_READ_PROM(addr) &bslash;&n;&t;*((volatile unsigned char *)prom_addr+addr)
multiline_comment|/*&n; * Function : mac_sonic_setup(char *str, int *ints)&n; *&n; * Purpose : booter command line initialization of the overrides array,&n; *&n; * Inputs : str - unused, ints - array of integer parameters with ints[0]&n; *&t;equal to the number of ints.&n; *&n; * Currently unused in the new driver; need to add settable parameters to the &n; * detect function.&n; *&n; */
DECL|function|mac_sonic_setup
r_void
id|mac_sonic_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* Format of macsonic parameter is:&n;&t; *   macsonic=&lt;debug&gt;,&lt;offset&gt;,&lt;shift&gt;&n;&t; * Negative values mean don&squot;t change.&n;&t; */
multiline_comment|/* Grmbl... the standard parameter parsing can&squot;t handle negative numbers&n;&t; * :-( So let&squot;s do it ourselves!&n;&t; */
r_int
id|i
op_assign
id|ints
(braket
l_int|0
)braket
op_plus
l_int|1
comma
id|fact
suffix:semicolon
r_while
c_loop
(paren
id|str
op_logical_and
(paren
id|isdigit
c_func
(paren
op_star
id|str
)paren
op_logical_or
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|i
op_le
l_int|10
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
id|fact
op_assign
op_minus
l_int|1
comma
op_increment
id|str
suffix:semicolon
r_else
id|fact
op_assign
l_int|1
suffix:semicolon
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_star
id|fact
suffix:semicolon
r_if
c_cond
(paren
(paren
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|str
suffix:semicolon
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_sonic_setup: no arguments!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
)paren
(brace
multiline_comment|/* 0 &lt;= n &lt;= 2 */
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|1
)braket
op_le
l_int|8
)paren
id|setup_debug
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;mac_sonic_setup: invalid debug level %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
(brace
multiline_comment|/* 0 &lt;= n &lt;= 2 */
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|2
)braket
op_le
l_int|16
)paren
id|setup_offset
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;mac_sonic_setup: invalid offset %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|3
)paren
(brace
multiline_comment|/* 0 &lt;= n &lt;= 2 */
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|3
)braket
op_le
l_int|16
)paren
id|setup_shift
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
OG
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;mac_sonic_setup: invalid shift %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|variable|sonic_debug
r_static
r_int
id|sonic_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * For reversing the PROM address&n; */
DECL|variable|nibbletab
r_static
r_int
r_char
id|nibbletab
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|8
comma
l_int|4
comma
l_int|12
comma
l_int|2
comma
l_int|10
comma
l_int|6
comma
l_int|14
comma
l_int|1
comma
l_int|9
comma
l_int|5
comma
l_int|13
comma
l_int|3
comma
l_int|11
comma
l_int|7
comma
l_int|15
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|mac_onboard_sonic_probe
c_func
(paren
r_void
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|silicon_revision
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_struct
id|sonic_local
op_star
id|lp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|MAC_SONIC_REGISTERS
suffix:semicolon
r_int
id|prom_addr
op_assign
id|MAC_SONIC_PROM_BASE
suffix:semicolon
r_static
r_int
id|one
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_MAC
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|one
op_ne
l_int|1
)paren
(brace
multiline_comment|/* Only one is allowed */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking for internal Macintosh ethernet (SONIC).. &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;ether_type
op_ne
id|MAC_ETHER_SONIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;none.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;yes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_debug
op_ge
l_int|0
)paren
id|sonic_debug
op_assign
id|setup_debug
suffix:semicolon
multiline_comment|/*&n;&t; * This may depend on the actual Mac model ... works for me.&n;&t; */
id|reg_offset
op_assign
(paren
id|setup_offset
op_ge
l_int|0
)paren
ques
c_cond
id|setup_offset
suffix:colon
l_int|0
suffix:semicolon
id|reg_shift
op_assign
(paren
id|setup_shift
op_ge
l_int|0
)paren
ques
c_cond
id|setup_shift
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * get the Silicon Revision ID. If this is one of the known&n;&t; * one assume that we found a SONIC ethernet controller at&n;&t; * the expected location.&n;&t; * (This is not implemented in the Macintosh driver yet; need&n;&t; * to collect values from various sources. Mine is 0x4 ...)&n;&t; */
id|silicon_revision
op_assign
id|SONIC_READ
c_func
(paren
id|SONIC_SR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;SONIC Silicon Revision = 0x%04x&bslash;n&quot;
comma
id|silicon_revision
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to allocate sonic_local later on, making sure it&squot;s&n;&t; * aligned on a 64k boundary. So, no space for dev-&gt;priv allocated&n;&t; * here ...&n;&t; */
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: %s found at 0x%08x, &quot;
comma
id|dev-&gt;name
comma
l_string|&quot;SONIC ethernet&quot;
comma
id|base_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;using offset %d shift %d,&quot;
comma
id|reg_offset
comma
id|reg_shift
)paren
suffix:semicolon
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|base_addr
suffix:semicolon
id|dev-&gt;irq
op_assign
id|MAC_SONIC_IRQ
suffix:semicolon
multiline_comment|/*&n;&t; * Put the sonic into software reset, then&n;&t; * retrieve and print the ethernet address.&n;&t; */
id|SONIC_WRITE
c_func
(paren
id|SONIC_CMD
comma
id|SONIC_CR_RST
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *        We can&squot;t trust MacOS to initialise things it seems.&n;&t; */
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;SONIC_DCR was %X&bslash;n&quot;
comma
id|SONIC_READ
c_func
(paren
id|SONIC_DCR
)paren
)paren
suffix:semicolon
id|SONIC_WRITE
c_func
(paren
id|SONIC_DCR
comma
id|SONIC_DCR_RFT1
op_or
id|SONIC_DCR_TFT0
op_or
id|SONIC_DCR_EXBUS
op_or
id|SONIC_DCR_DW
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  We don&squot;t want floating spare IRQ&squot;s around, not on&n;&t; *  level triggered systems!&n;&t; *  Strange though - writing to the ISR only clears currently&n;&t; *  pending IRQs, but doesn&squot;t disable them... Does this make &n;&t; *  a difference?? Seems it does ...&n;&t; */
macro_line|#if 1
id|SONIC_WRITE
c_func
(paren
id|SONIC_ISR
comma
l_int|0x7fff
)paren
suffix:semicolon
id|SONIC_WRITE
c_func
(paren
id|SONIC_IMR
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|SONIC_WRITE
c_func
(paren
id|SONIC_ISR
comma
id|SONIC_IMR_DEFAULT
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This is how it is done in jazzsonic.c&n;&t; * It doesn&squot;t seem to work here though.&n;&t; */
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Retreiving CAM entry 0. This should be the HW address.&bslash;n&quot;
)paren
suffix:semicolon
id|SONIC_WRITE
c_func
(paren
id|SONIC_CEP
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|SONIC_READ
c_func
(paren
id|SONIC_CAP0
op_minus
id|i
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_assign
id|val
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|val
op_rshift
l_int|8
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;HW Address from CAM 0: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Retreiving CAM entry 15. Another candidate...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * MacOS seems to use CAM entry 15 ...&n;&t;&t; */
id|SONIC_WRITE
c_func
(paren
id|SONIC_CEP
comma
l_int|15
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|SONIC_READ
c_func
(paren
id|SONIC_CAP0
op_minus
id|i
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
)braket
op_assign
id|val
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|val
op_rshift
l_int|8
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;HW Address from CAM 15: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if we can read the PROM, we&squot;re safe :-)&n;&t; */
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Retreiving HW address from the PROM: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|SONIC_READ_PROM
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *                If its not one of these we have&n;&t; *          screwed up on this Mac model&n;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
l_string|&quot;&bslash;x08&bslash;x00&bslash;x07&quot;
comma
l_int|3
)paren
op_logical_and
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
l_string|&quot;&bslash;x00&bslash;xA0&bslash;x40&quot;
comma
l_int|3
)paren
op_logical_and
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
l_string|&quot;&bslash;x00&bslash;x05&bslash;x02&quot;
comma
l_int|3
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try bit reversed&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|SONIC_READ_PROM
c_func
(paren
id|i
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|nibbletab
(braket
id|val
op_amp
l_int|0xf
)braket
op_lshift
l_int|4
)paren
op_or
id|nibbletab
(braket
(paren
id|val
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying bit reversed:  &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
l_string|&quot;&bslash;x08&bslash;x00&bslash;x07&quot;
comma
l_int|3
)paren
op_logical_and
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
l_string|&quot;&bslash;x00&bslash;xA0&bslash;x40&quot;
comma
l_int|3
)paren
op_logical_and
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
l_string|&quot;&bslash;x00&bslash;x05&bslash;x02&quot;
comma
l_int|3
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Still nonsense ... messed up someplace!&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;ERROR (INVALID MAC)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; MAC &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; IRQ %d&bslash;n&quot;
comma
id|MAC_SONIC_IRQ
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Allocating memory for dev-&gt;priv aka lp&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Memory to allocate: %d&bslash;n&quot;
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * the memory be located in the same 64kb segment&n;&t;&t; */
id|lp
op_assign
l_int|NULL
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|lp
op_assign
(paren
r_struct
id|sonic_local
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|lp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|lp
op_rshift
l_int|16
op_ne
(paren
(paren
r_int
r_int
)paren
id|lp
op_plus
r_sizeof
(paren
op_star
id|lp
)paren
)paren
op_rshift
l_int|16
)paren
(brace
multiline_comment|/* FIXME, free the memory later */
id|kfree
c_func
(paren
id|lp
)paren
suffix:semicolon
id|lp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|lp
op_eq
l_int|NULL
op_logical_and
id|i
op_increment
OL
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: couldn&squot;t allocate memory for descriptors&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Memory allocated after %d tries&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX sonic_local has the TDA, RRA, RDA, don&squot;t cache */
id|kernel_set_cachemode
c_func
(paren
(paren
id|u32
)paren
id|lp
comma
l_int|8192
comma
id|IOMAP_NOCACHE_SER
)paren
suffix:semicolon
id|memset
c_func
(paren
id|lp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sonic_local
)paren
)paren
suffix:semicolon
id|lp-&gt;cda_laddr
op_assign
(paren
id|u32
)paren
id|lp
suffix:semicolon
r_if
c_cond
(paren
id|sonic_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;memory allocated for sonic at 0x%x&bslash;n&quot;
comma
id|lp
)paren
suffix:semicolon
)brace
id|lp-&gt;tda_laddr
op_assign
id|lp-&gt;cda_laddr
op_plus
r_sizeof
(paren
id|lp-&gt;cda
)paren
suffix:semicolon
id|lp-&gt;rra_laddr
op_assign
id|lp-&gt;tda_laddr
op_plus
r_sizeof
(paren
id|lp-&gt;tda
)paren
suffix:semicolon
id|lp-&gt;rda_laddr
op_assign
id|lp-&gt;rra_laddr
op_plus
r_sizeof
(paren
id|lp-&gt;rra
)paren
suffix:semicolon
multiline_comment|/* allocate receive buffer area */
multiline_comment|/* FIXME, maybe we should use skbs */
r_if
c_cond
(paren
(paren
id|lp-&gt;rba
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|SONIC_NUM_RRS
op_star
id|SONIC_RBSIZE
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: couldn&squot;t allocate receive buffers&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* XXX RBA written by Sonic, not cached either */
id|kernel_set_cachemode
c_func
(paren
(paren
id|u32
)paren
id|lp-&gt;rba
comma
l_int|6
op_star
l_int|8192
comma
id|IOMAP_NOCACHE_SER
)paren
suffix:semicolon
id|lp-&gt;rba_laddr
op_assign
(paren
id|u32
)paren
id|lp-&gt;rba
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
(paren
r_struct
id|sonic_local
op_star
)paren
id|lp
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|sonic_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|dev-&gt;open
op_assign
id|sonic_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|sonic_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|sonic_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|sonic_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|sonic_multicast_list
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *    SONIC uses a nubus IRQ&n; */
DECL|macro|sonic_request_irq
mdefine_line|#define sonic_request_irq(irq, vec, flags, name, dev) &bslash;&n;&t;&t;nubus_request_irq(irq, dev, vec)
DECL|macro|sonic_free_irq
mdefine_line|#define sonic_free_irq(irq,id)&t;nubus_free_irq(irq)
multiline_comment|/*&n; *    No funnies on memory mapping.&n; */
DECL|macro|sonic_chiptomem
mdefine_line|#define sonic_chiptomem(x)&t;(x)
multiline_comment|/*&n; *    No VDMA on a Macintosh. So we need request no such facility.&n; */
DECL|macro|vdma_alloc
mdefine_line|#define vdma_alloc(x,y)&t;&t;((u32)(x))
DECL|macro|vdma_free
mdefine_line|#define vdma_free(x)
DECL|macro|PHYSADDR
mdefine_line|#define PHYSADDR(x)&t;&t;(x)
macro_line|#include &quot;sonic.c&quot;
eof
