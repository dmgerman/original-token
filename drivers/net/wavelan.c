multiline_comment|/*&n; *&t;WaveLAN ISA driver&n; *&n; *&t;&t;Jean II - HPLB &squot;96&n; *&n; * Reorganisation and extension of the driver.&n; * Original copyright follows (also see the end of this file).&n; * See wavelan.p.h for details.&n; *&n; *&n; *&n; * AT&amp;T GIS (nee NCR) WaveLAN card:&n; *&t;An Ethernet-like radio transceiver&n; *&t;controlled by an Intel 82586 coprocessor.&n; */
macro_line|#include &quot;wavelan.p.h&quot;&t;&t;/* Private header */
multiline_comment|/************************* MISC SUBROUTINES **************************/
multiline_comment|/*&n; * Subroutines which won&squot;t fit in one of the following category&n; * (WaveLAN modem or i82586)&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Wrapper for disabling interrupts and locking the driver.&n; * (note : inline, so optimised away)&n; */
DECL|function|wv_splhi
r_static
r_inline
r_void
id|wv_splhi
c_func
(paren
id|net_local
op_star
id|lp
comma
r_int
r_int
op_star
id|pflags
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;spinlock
comma
op_star
id|pflags
)paren
suffix:semicolon
multiline_comment|/* Note : above does the cli(); itself */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Wrapper for re-enabling interrupts and un-locking the driver.&n; */
DECL|function|wv_splx
r_static
r_inline
r_void
id|wv_splx
c_func
(paren
id|net_local
op_star
id|lp
comma
r_int
r_int
op_star
id|pflags
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;spinlock
comma
op_star
id|pflags
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Translate irq number to PSA irq parameter&n; */
DECL|function|wv_irq_to_psa
r_static
id|u8
id|wv_irq_to_psa
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
OL
l_int|0
op_logical_or
id|irq
op_ge
id|NELS
c_func
(paren
id|irqvals
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|irqvals
(braket
id|irq
)braket
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Translate PSA irq parameter to irq number &n; */
DECL|function|wv_psa_to_irq
r_static
r_int
id|__init
id|wv_psa_to_irq
c_func
(paren
id|u8
id|irqval
)paren
(brace
r_int
id|irq
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
id|NELS
c_func
(paren
id|irqvals
)paren
suffix:semicolon
id|irq
op_increment
)paren
r_if
c_cond
(paren
id|irqvals
(braket
id|irq
)braket
op_eq
id|irqval
)paren
r_return
id|irq
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef STRUCT_CHECK
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Sanity routine to verify the sizes of the various WaveLAN interface&n; * structures.&n; */
DECL|function|wv_struct_check
r_static
r_char
op_star
id|wv_struct_check
c_func
(paren
r_void
)paren
(brace
DECL|macro|SC
mdefine_line|#define&t;SC(t,s,n)&t;if (sizeof(t) != s) return(n);
id|SC
c_func
(paren
id|psa_t
comma
id|PSA_SIZE
comma
l_string|&quot;psa_t&quot;
)paren
suffix:semicolon
id|SC
c_func
(paren
id|mmw_t
comma
id|MMW_SIZE
comma
l_string|&quot;mmw_t&quot;
)paren
suffix:semicolon
id|SC
c_func
(paren
id|mmr_t
comma
id|MMR_SIZE
comma
l_string|&quot;mmr_t&quot;
)paren
suffix:semicolon
id|SC
c_func
(paren
id|ha_t
comma
id|HA_SIZE
comma
l_string|&quot;ha_t&quot;
)paren
suffix:semicolon
DECL|macro|SC
macro_line|#undef&t;SC
r_return
(paren
(paren
r_char
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_struct_check */
macro_line|#endif&t;&t;&t;&t;/* STRUCT_CHECK */
multiline_comment|/********************* HOST ADAPTER SUBROUTINES *********************/
multiline_comment|/*&n; * Useful subroutines to manage the WaveLAN ISA interface&n; *&n; * One major difference with the PCMCIA hardware (except the port mapping)&n; * is that we have to keep the state of the Host Control Register&n; * because of the interrupt enable &amp; bus size flags.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read from card&squot;s Host Adaptor Status Register.&n; */
DECL|function|hasr_read
r_static
r_inline
id|u16
id|hasr_read
c_func
(paren
r_int
r_int
id|ioaddr
)paren
(brace
r_return
(paren
id|inw
c_func
(paren
id|HASR
c_func
(paren
id|ioaddr
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* hasr_read */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write to card&squot;s Host Adapter Command Register.&n; */
DECL|function|hacr_write
r_static
r_inline
r_void
id|hacr_write
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
)paren
(brace
id|outw
c_func
(paren
id|hacr
comma
id|HACR
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* hacr_write */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write to card&squot;s Host Adapter Command Register. Include a delay for&n; * those times when it is needed.&n; */
DECL|function|hacr_write_slow
r_static
r_inline
r_void
id|hacr_write_slow
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
)paren
(brace
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
multiline_comment|/* delay might only be needed sometimes */
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* hacr_write_slow */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set the channel attention bit.&n; */
DECL|function|set_chan_attn
r_static
r_inline
r_void
id|set_chan_attn
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
)paren
(brace
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|hacr
op_or
id|HACR_CA
)paren
suffix:semicolon
)brace
multiline_comment|/* set_chan_attn */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Reset, and then set host adaptor into default mode.&n; */
DECL|function|wv_hacr_reset
r_static
r_inline
r_void
id|wv_hacr_reset
c_func
(paren
r_int
r_int
id|ioaddr
)paren
(brace
id|hacr_write_slow
c_func
(paren
id|ioaddr
comma
id|HACR_RESET
)paren
suffix:semicolon
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_hacr_reset */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set the I/O transfer over the ISA bus to 8-bit mode&n; */
DECL|function|wv_16_off
r_static
r_inline
r_void
id|wv_16_off
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
)paren
(brace
id|hacr
op_and_assign
op_complement
id|HACR_16BITS
suffix:semicolon
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_16_off */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set the I/O transfer over the ISA bus to 8-bit mode&n; */
DECL|function|wv_16_on
r_static
r_inline
r_void
id|wv_16_on
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
)paren
(brace
id|hacr
op_or_assign
id|HACR_16BITS
suffix:semicolon
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_16_on */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Disable interrupts on the WaveLAN hardware.&n; * (called by wv_82586_stop())&n; */
DECL|function|wv_ints_off
r_static
r_inline
r_void
id|wv_ints_off
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;hacr
op_and_assign
op_complement
id|HACR_INTRON
suffix:semicolon
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_ints_off */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Enable interrupts on the WaveLAN hardware.&n; * (called by wv_hw_reset())&n; */
DECL|function|wv_ints_on
r_static
r_inline
r_void
id|wv_ints_on
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;hacr
op_or_assign
id|HACR_INTRON
suffix:semicolon
id|hacr_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_ints_on */
multiline_comment|/******************* MODEM MANAGEMENT SUBROUTINES *******************/
multiline_comment|/*&n; * Useful subroutines to manage the modem of the WaveLAN&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read the Parameter Storage Area from the WaveLAN card&squot;s memory&n; */
multiline_comment|/*&n; * Read bytes from the PSA.&n; */
DECL|function|psa_read
r_static
r_void
id|psa_read
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
comma
r_int
id|o
comma
multiline_comment|/* offset in PSA */
id|u8
op_star
id|b
comma
multiline_comment|/* buffer to fill */
r_int
id|n
)paren
(brace
multiline_comment|/* size to read */
id|wv_16_off
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
id|outw
c_func
(paren
id|o
comma
id|PIOR2
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
id|o
op_increment
suffix:semicolon
op_star
id|b
op_increment
op_assign
id|inb
c_func
(paren
id|PIOP2
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
)brace
id|wv_16_on
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
)brace
multiline_comment|/* psa_read */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write the Parameter Storage Area to the WaveLAN card&squot;s memory.&n; */
DECL|function|psa_write
r_static
r_void
id|psa_write
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
comma
r_int
id|o
comma
multiline_comment|/* Offset in PSA */
id|u8
op_star
id|b
comma
multiline_comment|/* Buffer in memory */
r_int
id|n
)paren
(brace
multiline_comment|/* Length of buffer */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|wv_16_off
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
id|outw
c_func
(paren
id|o
comma
id|PIOR2
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
id|o
op_increment
suffix:semicolon
id|outb
c_func
(paren
op_star
id|b
comma
id|PIOP2
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
id|b
op_increment
suffix:semicolon
multiline_comment|/* Wait for the memory to finish its write cycle */
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|count
op_increment
OL
l_int|100
)paren
op_logical_and
(paren
id|hasr_read
c_func
(paren
id|ioaddr
)paren
op_amp
id|HASR_PSA_BUSY
)paren
)paren
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|wv_16_on
c_func
(paren
id|ioaddr
comma
id|hacr
)paren
suffix:semicolon
)brace
multiline_comment|/* psa_write */
macro_line|#ifdef SET_PSA_CRC
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Calculate the PSA CRC&n; * Thanks to Valster, Nico &lt;NVALSTER@wcnd.nl.lucent.com&gt; for the code&n; * NOTE: By specifying a length including the CRC position the&n; * returned value should be zero. (i.e. a correct checksum in the PSA)&n; *&n; * The Windows drivers don&squot;t use the CRC, but the AP and the PtP tool&n; * depend on it.&n; */
DECL|function|psa_crc
r_static
r_inline
id|u16
id|psa_crc
c_func
(paren
id|u8
op_star
id|psa
comma
multiline_comment|/* The PSA */
r_int
id|size
)paren
(brace
multiline_comment|/* Number of short for CRC */
r_int
id|byte_cnt
suffix:semicolon
multiline_comment|/* Loop on the PSA */
id|u16
id|crc_bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Data in the PSA */
r_int
id|bit_cnt
suffix:semicolon
multiline_comment|/* Loop on the bits of the short */
r_for
c_loop
(paren
id|byte_cnt
op_assign
l_int|0
suffix:semicolon
id|byte_cnt
OL
id|size
suffix:semicolon
id|byte_cnt
op_increment
)paren
(brace
id|crc_bytes
op_xor_assign
id|psa
(braket
id|byte_cnt
)braket
suffix:semicolon
multiline_comment|/* Its an xor */
r_for
c_loop
(paren
id|bit_cnt
op_assign
l_int|1
suffix:semicolon
id|bit_cnt
OL
l_int|9
suffix:semicolon
id|bit_cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|crc_bytes
op_amp
l_int|0x0001
)paren
id|crc_bytes
op_assign
(paren
id|crc_bytes
op_rshift
l_int|1
)paren
op_xor
l_int|0xA001
suffix:semicolon
r_else
id|crc_bytes
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|crc_bytes
suffix:semicolon
)brace
multiline_comment|/* psa_crc */
macro_line|#endif&t;&t;&t;&t;/* SET_PSA_CRC */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * update the checksum field in the Wavelan&squot;s PSA&n; */
DECL|function|update_psa_checksum
r_static
r_void
id|update_psa_checksum
c_func
(paren
id|device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
comma
id|u16
id|hacr
)paren
(brace
macro_line|#ifdef SET_PSA_CRC
id|psa_t
id|psa
suffix:semicolon
id|u16
id|crc
suffix:semicolon
multiline_comment|/* read the parameter storage area */
id|psa_read
c_func
(paren
id|ioaddr
comma
id|hacr
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
multiline_comment|/* update the checksum */
id|crc
op_assign
id|psa_crc
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc
(braket
l_int|0
)braket
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc
(braket
l_int|1
)braket
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc_status
)paren
)paren
suffix:semicolon
id|psa.psa_crc
(braket
l_int|0
)braket
op_assign
id|crc
op_amp
l_int|0xFF
suffix:semicolon
id|psa.psa_crc
(braket
l_int|1
)braket
op_assign
(paren
id|crc
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* Write it ! */
id|psa_write
c_func
(paren
id|ioaddr
comma
id|hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_crc
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_crc
comma
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: update_psa_checksum(): crc = 0x%02x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|psa.psa_crc
(braket
l_int|0
)braket
comma
id|psa.psa_crc
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Check again (luxury !) */
id|crc
op_assign
id|psa_crc
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
op_minus
r_sizeof
(paren
id|psa.psa_crc_status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: update_psa_checksum(): CRC does not agree with PSA data (even after recalculating)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_IOCTL_INFO */
macro_line|#endif&t;&t;&t;&t;/* SET_PSA_CRC */
)brace
multiline_comment|/* update_psa_checksum */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write 1 byte to the MMC.&n; */
DECL|function|mmc_out
r_static
r_inline
r_void
id|mmc_out
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|o
comma
id|u8
id|d
)paren
(brace
multiline_comment|/* Wait for MMC to go idle */
r_while
c_loop
(paren
id|inw
c_func
(paren
id|HASR
c_func
(paren
id|ioaddr
)paren
)paren
op_amp
id|HASR_MMC_BUSY
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|u16
)paren
(paren
(paren
(paren
id|u16
)paren
id|d
op_lshift
l_int|8
)paren
op_or
(paren
id|o
op_lshift
l_int|1
)paren
op_or
l_int|1
)paren
comma
id|MMCR
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to write bytes to the Modem Management Controller.&n; * We start at the end because it is the way it should be!&n; */
DECL|function|mmc_write
r_static
r_inline
r_void
id|mmc_write
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u8
id|o
comma
id|u8
op_star
id|b
comma
r_int
id|n
)paren
(brace
id|o
op_add_assign
id|n
suffix:semicolon
id|b
op_add_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
id|mmc_out
c_func
(paren
id|ioaddr
comma
op_decrement
id|o
comma
op_star
(paren
op_decrement
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* mmc_write */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read a byte from the MMC.&n; * Optimised version for 1 byte, avoid using memory.&n; */
DECL|function|mmc_in
r_static
r_inline
id|u8
id|mmc_in
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|o
)paren
(brace
r_while
c_loop
(paren
id|inw
c_func
(paren
id|HASR
c_func
(paren
id|ioaddr
)paren
)paren
op_amp
id|HASR_MMC_BUSY
)paren
suffix:semicolon
id|outw
c_func
(paren
id|o
op_lshift
l_int|1
comma
id|MMCR
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inw
c_func
(paren
id|HASR
c_func
(paren
id|ioaddr
)paren
)paren
op_amp
id|HASR_MMC_BUSY
)paren
suffix:semicolon
r_return
(paren
id|u8
)paren
(paren
id|inw
c_func
(paren
id|MMCR
c_func
(paren
id|ioaddr
)paren
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to read bytes from the Modem Management Controller.&n; * The implementation is complicated by a lack of address lines,&n; * which prevents decoding of the low-order bit.&n; * (code has just been moved in the above function)&n; * We start at the end because it is the way it should be!&n; */
DECL|function|mmc_read
r_static
r_inline
r_void
id|mmc_read
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u8
id|o
comma
id|u8
op_star
id|b
comma
r_int
id|n
)paren
(brace
id|o
op_add_assign
id|n
suffix:semicolon
id|b
op_add_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
op_star
(paren
op_decrement
id|b
)paren
op_assign
id|mmc_in
c_func
(paren
id|ioaddr
comma
op_decrement
id|o
)paren
suffix:semicolon
)brace
multiline_comment|/* mmc_read */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get the type of encryption available.&n; */
DECL|function|mmc_encr
r_static
r_inline
r_int
id|mmc_encr
c_func
(paren
r_int
r_int
id|ioaddr
)paren
(brace
multiline_comment|/* I/O port of the card */
r_int
id|temp
suffix:semicolon
id|temp
op_assign
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_des_avail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_ne
id|MMR_DES_AVAIL_DES
)paren
op_logical_and
(paren
id|temp
op_ne
id|MMR_DES_AVAIL_AES
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|temp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Wait for the frequency EEPROM to complete a command.&n; * I hope this one will be optimally inlined.&n; */
DECL|function|fee_wait
r_static
r_inline
r_void
id|fee_wait
c_func
(paren
r_int
r_int
id|ioaddr
comma
multiline_comment|/* I/O port of the card */
r_int
id|delay
comma
multiline_comment|/* Base delay to wait for */
r_int
id|number
)paren
(brace
multiline_comment|/* Number of time to wait */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait only a limited time */
r_while
c_loop
(paren
(paren
id|count
op_increment
OL
id|number
)paren
op_logical_and
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
id|MMR_FEE_STATUS_BUSY
)paren
)paren
id|udelay
c_func
(paren
id|delay
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read bytes from the Frequency EEPROM (frequency select cards).&n; */
DECL|function|fee_read
r_static
r_void
id|fee_read
c_func
(paren
r_int
r_int
id|ioaddr
comma
multiline_comment|/* I/O port of the card */
id|u16
id|o
comma
multiline_comment|/* destination offset */
id|u16
op_star
id|b
comma
multiline_comment|/* data buffer */
r_int
id|n
)paren
(brace
multiline_comment|/* number of registers */
id|b
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Position at the end of the area */
multiline_comment|/* Write the address */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|o
op_plus
id|n
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Loop on all buffer */
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* Write the read command */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_READ
)paren
suffix:semicolon
multiline_comment|/* Wait until EEPROM is ready (should be quick). */
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the value. */
op_star
op_decrement
id|b
op_assign
(paren
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_h
)paren
)paren
op_lshift
l_int|8
)paren
op_or
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_l
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef WIRELESS_EXT&t;&t;/* if the wireless extension exists in the kernel */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write bytes from the Frequency EEPROM (frequency select cards).&n; * This is a bit complicated, because the frequency EEPROM has to&n; * be unprotected and the write enabled.&n; * Jean II&n; */
DECL|function|fee_write
r_static
r_void
id|fee_write
c_func
(paren
r_int
r_int
id|ioaddr
comma
multiline_comment|/* I/O port of the card */
id|u16
id|o
comma
multiline_comment|/* destination offset */
id|u16
op_star
id|b
comma
multiline_comment|/* data buffer */
r_int
id|n
)paren
(brace
multiline_comment|/* number of registers */
id|b
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Position at the end of the area. */
macro_line|#ifdef EEPROM_IS_PROTECTED&t;/* disabled */
macro_line|#ifdef DOESNT_SEEM_TO_WORK&t;/* disabled */
multiline_comment|/* Ask to read the protected register */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRREAD
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the protected register. */
id|printk
c_func
(paren
l_string|&quot;Protected 2:  %02X-%02X&bslash;n&quot;
comma
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_h
)paren
)paren
comma
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_data_l
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DOESNT_SEEM_TO_WORK */
multiline_comment|/* Enable protected register. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|MMW_FEE_ADDR_EN
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PREN
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Unprotect area. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|o
op_plus
id|n
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRWRITE
)paren
suffix:semicolon
macro_line|#ifdef DOESNT_SEEM_TO_WORK&t;/* disabled */
multiline_comment|/* or use: */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRCLEAR
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DOESNT_SEEM_TO_WORK */
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* EEPROM_IS_PROTECTED */
multiline_comment|/* Write enable. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|MMW_FEE_ADDR_EN
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_WREN
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Write the EEPROM address. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|o
op_plus
id|n
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Loop on all buffer */
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* Write the value. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_data_h
)paren
comma
(paren
op_star
op_decrement
id|b
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_data_l
)paren
comma
op_star
id|b
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* Write the write command. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_WRITE
)paren
suffix:semicolon
multiline_comment|/* WaveLAN documentation says to wait at least 10 ms for EEBUSY = 0 */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* Write disable. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
id|MMW_FEE_ADDR_DS
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_WDS
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef EEPROM_IS_PROTECTED&t;/* disabled */
multiline_comment|/* Reprotect EEPROM. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
l_int|0x00
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_PRWRITE
)paren
suffix:semicolon
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|10
comma
l_int|100
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* EEPROM_IS_PROTECTED */
)brace
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_EXT */
multiline_comment|/************************ I82586 SUBROUTINES *************************/
multiline_comment|/*&n; * Useful subroutines to manage the Ethernet controller&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read bytes from the on-board RAM.&n; * Why does inlining this function make it fail?&n; */
DECL|function|obram_read
r_static
multiline_comment|/*inline */
r_void
id|obram_read
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|o
comma
id|u8
op_star
id|b
comma
r_int
id|n
)paren
(brace
id|outw
c_func
(paren
id|o
comma
id|PIOR1
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
id|insw
c_func
(paren
id|PIOP1
c_func
(paren
id|ioaddr
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|b
comma
(paren
id|n
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write bytes to the on-board RAM.&n; */
DECL|function|obram_write
r_static
r_inline
r_void
id|obram_write
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u16
id|o
comma
id|u8
op_star
id|b
comma
r_int
id|n
)paren
(brace
id|outw
c_func
(paren
id|o
comma
id|PIOR1
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|PIOP1
c_func
(paren
id|ioaddr
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|b
comma
(paren
id|n
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Acknowledge the reading of the status issued by the i82586.&n; */
DECL|function|wv_ack
r_static
r_void
id|wv_ack
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|scb_cs
suffix:semicolon
r_int
id|i
suffix:semicolon
id|obram_read
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
id|scb_cs
op_and_assign
id|SCB_ST_INT
suffix:semicolon
r_if
c_cond
(paren
id|scb_cs
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_cs
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_ERROR
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_ack(): board not accepting command.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set channel attention bit and busy wait until command has&n; * completed, then acknowledge completion of the command.&n; */
DECL|function|wv_synchronous_cmd
r_static
r_inline
r_int
id|wv_synchronous_cmd
c_func
(paren
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|str
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|scb_cmd
suffix:semicolon
id|ach_t
id|cb
suffix:semicolon
r_int
id|i
suffix:semicolon
id|scb_cmd
op_assign
id|SCB_CMD_CUC
op_amp
id|SCB_CMD_CUC_GO
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cmd
comma
r_sizeof
(paren
id|scb_cmd
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|OFFSET_CU
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|cb
comma
r_sizeof
(paren
id|cb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb.ac_status
op_amp
id|AC_SFLD_C
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
l_int|0
op_logical_or
op_logical_neg
(paren
id|cb.ac_status
op_amp
id|AC_SFLD_OK
)paren
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s failed; status = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|str
comma
id|cb.ac_status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_I82586_SHOW
id|wv_scb_show
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Ack the status */
id|wv_ack
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Configuration commands completion interrupt.&n; * Check if done, and if OK.&n; */
r_static
r_inline
r_int
DECL|function|wv_config_complete
id|wv_config_complete
c_func
(paren
id|device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
comma
id|net_local
op_star
id|lp
)paren
(brace
r_int
r_int
id|mcs_addr
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_config_complete()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|mcs_addr
op_assign
id|lp-&gt;tx_first_in_use
op_plus
r_sizeof
(paren
id|ac_tx_t
)paren
op_plus
r_sizeof
(paren
id|ac_nop_t
)paren
op_plus
r_sizeof
(paren
id|tbd_t
)paren
op_plus
r_sizeof
(paren
id|ac_cfg_t
)paren
op_plus
r_sizeof
(paren
id|ac_ias_t
)paren
suffix:semicolon
multiline_comment|/* Read the status of the last command (set mc list). */
id|obram_read
c_func
(paren
id|ioaddr
comma
id|acoff
c_func
(paren
id|mcs_addr
comma
id|ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|status
comma
r_sizeof
(paren
id|status
)paren
)paren
suffix:semicolon
multiline_comment|/* If not completed -&gt; exit */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|AC_SFLD_C
)paren
op_eq
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not ready to be scrapped */
r_else
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
r_int
r_int
id|cfg_addr
suffix:semicolon
r_int
r_int
id|ias_addr
suffix:semicolon
multiline_comment|/* Check mc_config command */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|AC_SFLD_OK
)paren
op_ne
id|AC_SFLD_OK
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_config_complete(): set_multicast_address failed; status = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* check ia-config command */
id|ias_addr
op_assign
id|mcs_addr
op_minus
r_sizeof
(paren
id|ac_ias_t
)paren
suffix:semicolon
id|obram_read
c_func
(paren
id|ioaddr
comma
id|acoff
c_func
(paren
id|ias_addr
comma
id|ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|status
comma
r_sizeof
(paren
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|AC_SFLD_OK
)paren
op_ne
id|AC_SFLD_OK
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_config_complete(): set_MAC_address failed; status = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* Check config command. */
id|cfg_addr
op_assign
id|ias_addr
op_minus
r_sizeof
(paren
id|ac_cfg_t
)paren
suffix:semicolon
id|obram_read
c_func
(paren
id|ioaddr
comma
id|acoff
c_func
(paren
id|cfg_addr
comma
id|ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|status
comma
r_sizeof
(paren
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|AC_SFLD_OK
)paren
op_ne
id|AC_SFLD_OK
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_config_complete(): configure failed; status = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_CONFIG_ERROR */
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ready to be scrapped */
)brace
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_config_complete() - %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Command completion interrupt.&n; * Reclaim as many freed tx buffers as we can.&n; * (called in wavelan_interrupt()).&n; * Note : the spinlock is already grabbed for us.&n; */
DECL|function|wv_complete
r_static
r_int
id|wv_complete
c_func
(paren
id|device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
comma
id|net_local
op_star
id|lp
)paren
(brace
r_int
id|nreaped
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_complete()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Loop on all the transmit buffers */
r_while
c_loop
(paren
id|lp-&gt;tx_first_in_use
op_ne
id|I82586NULL
)paren
(brace
r_int
r_int
id|tx_status
suffix:semicolon
multiline_comment|/* Read the first transmit buffer */
id|obram_read
c_func
(paren
id|ioaddr
comma
id|acoff
c_func
(paren
id|lp-&gt;tx_first_in_use
comma
id|ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|tx_status
comma
r_sizeof
(paren
id|tx_status
)paren
)paren
suffix:semicolon
multiline_comment|/* If not completed -&gt; exit */
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|AC_SFLD_C
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Hack for reconfiguration */
r_if
c_cond
(paren
id|tx_status
op_eq
l_int|0xFFFF
)paren
r_if
c_cond
(paren
op_logical_neg
id|wv_config_complete
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Not completed */
multiline_comment|/* We now remove this buffer */
id|nreaped
op_increment
suffix:semicolon
op_decrement
id|lp-&gt;tx_n_in_use
suffix:semicolon
multiline_comment|/*&n;if (lp-&gt;tx_n_in_use &gt; 0)&n;&t;printk(&quot;%c&quot;, &quot;0123456789abcdefghijk&quot;[lp-&gt;tx_n_in_use]);&n;*/
multiline_comment|/* Was it the last one? */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
op_le
l_int|0
)paren
id|lp-&gt;tx_first_in_use
op_assign
id|I82586NULL
suffix:semicolon
r_else
(brace
multiline_comment|/* Next one in the chain */
id|lp-&gt;tx_first_in_use
op_add_assign
id|TXBLOCKZ
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_first_in_use
op_ge
id|OFFSET_CU
op_plus
id|NTXBLOCKS
op_star
id|TXBLOCKZ
)paren
id|lp-&gt;tx_first_in_use
op_sub_assign
id|NTXBLOCKS
op_star
id|TXBLOCKZ
suffix:semicolon
)brace
multiline_comment|/* Hack for reconfiguration */
r_if
c_cond
(paren
id|tx_status
op_eq
l_int|0xFFFF
)paren
r_continue
suffix:semicolon
multiline_comment|/* Now, check status of the finished command */
r_if
c_cond
(paren
id|tx_status
op_amp
id|AC_SFLD_OK
)paren
(brace
r_int
id|ncollisions
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|ncollisions
op_assign
id|tx_status
op_amp
id|AC_SFLD_MAXCOL
suffix:semicolon
id|lp-&gt;stats.collisions
op_add_assign
id|ncollisions
suffix:semicolon
macro_line|#ifdef DEBUG_TX_INFO
r_if
c_cond
(paren
id|ncollisions
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx completed after %d collisions.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ncollisions
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|AC_SFLD_S10
)paren
(brace
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx error: no CS.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|AC_SFLD_S9
)paren
(brace
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx error: lost CTS.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|AC_SFLD_S8
)paren
(brace
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx error: slow DMA.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|AC_SFLD_S6
)paren
(brace
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx error: heart beat.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
id|AC_SFLD_S5
)paren
(brace
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_TX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx error: too many collisions.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef DEBUG_TX_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): tx completed, tx_status 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_status
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_INTERRUPT_INFO
r_if
c_cond
(paren
id|nreaped
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_complete(): reaped %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|nreaped
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Inform upper layers.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
OL
id|NTXBLOCKS
op_minus
l_int|1
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_complete()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|nreaped
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Reconfigure the i82586, or at least ask for it.&n; * Because wv_82586_config uses a transmission buffer, we must do it&n; * when we are sure that there is one left, so we do it now&n; * or in wavelan_packet_xmit() (I can&squot;t find any better place,&n; * wavelan_interrupt is not an option), so you may experience&n; * delays sometimes.&n; */
DECL|function|wv_82586_reconfig
r_static
r_inline
r_void
id|wv_82586_reconfig
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Arm the flag, will be cleard in wv_82586_config() */
id|lp-&gt;reconfig_82586
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Check if we can do it now ! */
r_if
c_cond
(paren
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* May fail */
id|wv_82586_config
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_82586_reconfig(): delayed (state = %lX)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;state
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/********************* DEBUG &amp; INFO SUBROUTINES *********************/
multiline_comment|/*&n; * This routine is used in the code to show information for debugging.&n; * Most of the time, it dumps the contents of hardware structures.&n; */
macro_line|#ifdef DEBUG_PSA_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted contents of the Parameter Storage Area.&n; */
DECL|function|wv_psa_show
r_static
r_void
id|wv_psa_show
c_func
(paren
id|psa_t
op_star
id|p
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### WaveLAN PSA contents: #####&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_io_base_addr_1: 0x%02X %02X %02X %02X&bslash;n&quot;
comma
id|p-&gt;psa_io_base_addr_1
comma
id|p-&gt;psa_io_base_addr_2
comma
id|p-&gt;psa_io_base_addr_3
comma
id|p-&gt;psa_io_base_addr_4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_rem_boot_addr_1: 0x%02X %02X %02X&bslash;n&quot;
comma
id|p-&gt;psa_rem_boot_addr_1
comma
id|p-&gt;psa_rem_boot_addr_2
comma
id|p-&gt;psa_rem_boot_addr_3
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_holi_params: 0x%02x, &quot;
comma
id|p-&gt;psa_holi_params
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_int_req_no: %d&bslash;n&quot;
comma
id|p-&gt;psa_int_req_no
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_unused0[]: %02X:%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|p-&gt;psa_unused0
(braket
l_int|0
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|1
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|2
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|3
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|4
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|5
)braket
comma
id|p-&gt;psa_unused0
(braket
l_int|6
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_univ_mac_addr[]: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|0
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|1
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|2
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|3
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|4
)braket
comma
id|p-&gt;psa_univ_mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_local_mac_addr[]: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|0
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|1
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|2
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|3
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|4
)braket
comma
id|p-&gt;psa_local_mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_univ_local_sel: %d, &quot;
comma
id|p-&gt;psa_univ_local_sel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_comp_number: %d, &quot;
comma
id|p-&gt;psa_comp_number
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_thr_pre_set: 0x%02x&bslash;n&quot;
comma
id|p-&gt;psa_thr_pre_set
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_feature_select/decay_prm: 0x%02x, &quot;
comma
id|p-&gt;psa_feature_select
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_subband/decay_update_prm: %d&bslash;n&quot;
comma
id|p-&gt;psa_subband
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_quality_thr: 0x%02x, &quot;
comma
id|p-&gt;psa_quality_thr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_mod_delay: 0x%02x&bslash;n&quot;
comma
id|p-&gt;psa_mod_delay
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_nwid: 0x%02x%02x, &quot;
comma
id|p-&gt;psa_nwid
(braket
l_int|0
)braket
comma
id|p-&gt;psa_nwid
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_nwid_select: %d&bslash;n&quot;
comma
id|p-&gt;psa_nwid_select
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_encryption_select: %d, &quot;
comma
id|p-&gt;psa_encryption_select
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;psa_encryption_key[]: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|p-&gt;psa_encryption_key
(braket
l_int|0
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|1
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|2
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|3
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|4
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|5
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|6
)braket
comma
id|p-&gt;psa_encryption_key
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_databus_width: %d&bslash;n&quot;
comma
id|p-&gt;psa_databus_width
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_call_code/auto_squelch: 0x%02x, &quot;
comma
id|p-&gt;psa_call_code
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;psa_call_code[]: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|p-&gt;psa_call_code
(braket
l_int|0
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|1
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|2
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|3
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|4
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|5
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|6
)braket
comma
id|p-&gt;psa_call_code
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_reserved[]: %02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|p-&gt;psa_reserved
(braket
l_int|0
)braket
comma
id|p-&gt;psa_reserved
(braket
l_int|1
)braket
comma
id|p-&gt;psa_reserved
(braket
l_int|2
)braket
comma
id|p-&gt;psa_reserved
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;psa_conf_status: %d, &quot;
comma
id|p-&gt;psa_conf_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_crc: 0x%02x%02x, &quot;
comma
id|p-&gt;psa_crc
(braket
l_int|0
)braket
comma
id|p-&gt;psa_crc
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;psa_crc_status: 0x%02x&bslash;n&quot;
comma
id|p-&gt;psa_crc_status
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_psa_show */
macro_line|#endif&t;&t;&t;&t;/* DEBUG_PSA_SHOW */
macro_line|#ifdef DEBUG_MMC_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the Modem Management Controller.&n; * This function needs to be completed.&n; */
DECL|function|wv_mmc_show
r_static
r_void
id|wv_mmc_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mmr_t
id|m
suffix:semicolon
multiline_comment|/* Basic check */
r_if
c_cond
(paren
id|hasr_read
c_func
(paren
id|ioaddr
)paren
op_amp
id|HASR_NO_CLK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wv_mmc_show: modem not connected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read the mmc */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|ioaddr
comma
l_int|0
comma
(paren
id|u8
op_star
)paren
op_amp
id|m
comma
r_sizeof
(paren
id|m
)paren
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef WIRELESS_EXT&t;&t;/* if wireless extension exists in the kernel */
multiline_comment|/* Don&squot;t forget to update statistics */
id|lp-&gt;wstats.discard.nwid
op_add_assign
(paren
id|m.mmr_wrong_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_wrong_nwid_l
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_EXT */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### WaveLAN modem status registers: #####&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmc_unused0[]: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|m.mmr_unused0
(braket
l_int|0
)braket
comma
id|m.mmr_unused0
(braket
l_int|1
)braket
comma
id|m.mmr_unused0
(braket
l_int|2
)braket
comma
id|m.mmr_unused0
(braket
l_int|3
)braket
comma
id|m.mmr_unused0
(braket
l_int|4
)braket
comma
id|m.mmr_unused0
(braket
l_int|5
)braket
comma
id|m.mmr_unused0
(braket
l_int|6
)braket
comma
id|m.mmr_unused0
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Encryption algorithm: %02X - Status: %02X&bslash;n&quot;
comma
id|m.mmr_des_avail
comma
id|m.mmr_des_status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmc_unused1[]: %02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|m.mmr_unused1
(braket
l_int|0
)braket
comma
id|m.mmr_unused1
(braket
l_int|1
)braket
comma
id|m.mmr_unused1
(braket
l_int|2
)braket
comma
id|m.mmr_unused1
(braket
l_int|3
)braket
comma
id|m.mmr_unused1
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dce_status: 0x%x [%s%s%s%s]&bslash;n&quot;
comma
id|m.mmr_dce_status
comma
(paren
id|m
dot
id|mmr_dce_status
op_amp
id|MMR_DCE_STATUS_RX_BUSY
)paren
ques
c_cond
l_string|&quot;energy detected,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|m
dot
id|mmr_dce_status
op_amp
id|MMR_DCE_STATUS_LOOPT_IND
)paren
ques
c_cond
l_string|&quot;loop test indicated,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|m
dot
id|mmr_dce_status
op_amp
id|MMR_DCE_STATUS_TX_BUSY
)paren
ques
c_cond
l_string|&quot;transmitter on,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|m
dot
id|mmr_dce_status
op_amp
id|MMR_DCE_STATUS_JBR_EXPIRED
)paren
ques
c_cond
l_string|&quot;jabber timer expired,&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Dsp ID: %02X&bslash;n&quot;
comma
id|m.mmr_dsp_id
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmc_unused2[]: %02X:%02X&bslash;n&quot;
comma
id|m.mmr_unused2
(braket
l_int|0
)braket
comma
id|m.mmr_unused2
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_SHOW_UNUSED */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;# correct_nwid: %d, # wrong_nwid: %d&bslash;n&quot;
comma
(paren
id|m.mmr_correct_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_correct_nwid_l
comma
(paren
id|m.mmr_wrong_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_wrong_nwid_l
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;thr_pre_set: 0x%x [current signal %s]&bslash;n&quot;
comma
id|m.mmr_thr_pre_set
op_amp
id|MMR_THR_PRE_SET
comma
(paren
id|m
dot
id|mmr_thr_pre_set
op_amp
id|MMR_THR_PRE_SET_CUR
)paren
ques
c_cond
l_string|&quot;above&quot;
suffix:colon
l_string|&quot;below&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;signal_lvl: %d [%s], &quot;
comma
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL
comma
(paren
id|m
dot
id|mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL_VALID
)paren
ques
c_cond
l_string|&quot;new msg&quot;
suffix:colon
l_string|&quot;no new msg&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;silence_lvl: %d [%s], &quot;
comma
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL
comma
(paren
id|m
dot
id|mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL_VALID
)paren
ques
c_cond
l_string|&quot;update done&quot;
suffix:colon
l_string|&quot;no new update&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sgnl_qual: 0x%x [%s]&bslash;n&quot;
comma
id|m.mmr_sgnl_qual
op_amp
id|MMR_SGNL_QUAL
comma
(paren
id|m
dot
id|mmr_sgnl_qual
op_amp
id|MMR_SGNL_QUAL_ANT
)paren
ques
c_cond
l_string|&quot;Antenna 1&quot;
suffix:colon
l_string|&quot;Antenna 0&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SHOW_UNUSED
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;netw_id_l: %x&bslash;n&quot;
comma
id|m.mmr_netw_id_l
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_SHOW_UNUSED */
)brace
multiline_comment|/* wv_mmc_show */
macro_line|#endif&t;&t;&t;&t;/* DEBUG_MMC_SHOW */
macro_line|#ifdef DEBUG_I82586_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the last block of the i82586 memory.&n; */
DECL|function|wv_scb_show
r_static
r_void
id|wv_scb_show
c_func
(paren
r_int
r_int
id|ioaddr
)paren
(brace
id|scb_t
id|scb
suffix:semicolon
id|obram_read
c_func
(paren
id|ioaddr
comma
id|OFFSET_SCB
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb
comma
r_sizeof
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### WaveLAN system control block: #####&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;status: &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;stat 0x%x[%s%s%s%s] &quot;
comma
(paren
id|scb
dot
id|scb_status
op_amp
(paren
id|SCB_ST_CX
op_or
id|SCB_ST_FR
op_or
id|SCB_ST_CNA
op_or
id|SCB_ST_RNR
)paren
)paren
op_rshift
l_int|12
comma
(paren
id|scb
dot
id|scb_status
op_amp
id|SCB_ST_CX
)paren
ques
c_cond
l_string|&quot;command completion interrupt,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|scb.scb_status
op_amp
id|SCB_ST_FR
)paren
ques
c_cond
l_string|&quot;frame received,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|scb
dot
id|scb_status
op_amp
id|SCB_ST_CNA
)paren
ques
c_cond
l_string|&quot;command unit not active,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|scb
dot
id|scb_status
op_amp
id|SCB_ST_RNR
)paren
ques
c_cond
l_string|&quot;receiving unit not ready,&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cus 0x%x[%s%s%s] &quot;
comma
(paren
id|scb.scb_status
op_amp
id|SCB_ST_CUS
)paren
op_rshift
l_int|8
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_CUS
)paren
op_eq
id|SCB_ST_CUS_IDLE
)paren
ques
c_cond
l_string|&quot;idle&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_CUS
)paren
op_eq
id|SCB_ST_CUS_SUSP
)paren
ques
c_cond
l_string|&quot;suspended&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_CUS
)paren
op_eq
id|SCB_ST_CUS_ACTV
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rus 0x%x[%s%s%s%s]&bslash;n&quot;
comma
(paren
id|scb.scb_status
op_amp
id|SCB_ST_RUS
)paren
op_rshift
l_int|4
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_RUS
)paren
op_eq
id|SCB_ST_RUS_IDLE
)paren
ques
c_cond
l_string|&quot;idle&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_RUS
)paren
op_eq
id|SCB_ST_RUS_SUSP
)paren
ques
c_cond
l_string|&quot;suspended&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_RUS
)paren
op_eq
id|SCB_ST_RUS_NRES
)paren
ques
c_cond
l_string|&quot;no resources&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_status
op_amp
id|SCB_ST_RUS
)paren
op_eq
id|SCB_ST_RUS_RDY
)paren
ques
c_cond
l_string|&quot;ready&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;command: &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ack 0x%x[%s%s%s%s] &quot;
comma
(paren
id|scb
dot
id|scb_command
op_amp
(paren
id|SCB_CMD_ACK_CX
op_or
id|SCB_CMD_ACK_FR
op_or
id|SCB_CMD_ACK_CNA
op_or
id|SCB_CMD_ACK_RNR
)paren
)paren
op_rshift
l_int|12
comma
(paren
id|scb
dot
id|scb_command
op_amp
id|SCB_CMD_ACK_CX
)paren
ques
c_cond
l_string|&quot;ack cmd completion,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|scb
dot
id|scb_command
op_amp
id|SCB_CMD_ACK_FR
)paren
ques
c_cond
l_string|&quot;ack frame received,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|scb
dot
id|scb_command
op_amp
id|SCB_CMD_ACK_CNA
)paren
ques
c_cond
l_string|&quot;ack CU not active,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|scb
dot
id|scb_command
op_amp
id|SCB_CMD_ACK_RNR
)paren
ques
c_cond
l_string|&quot;ack RU not ready,&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cuc 0x%x[%s%s%s%s%s] &quot;
comma
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_CUC
)paren
op_rshift
l_int|8
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_CUC
)paren
op_eq
id|SCB_CMD_CUC_NOP
)paren
ques
c_cond
l_string|&quot;nop&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_CUC
)paren
op_eq
id|SCB_CMD_CUC_GO
)paren
ques
c_cond
l_string|&quot;start cbl_offset&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_CUC
)paren
op_eq
id|SCB_CMD_CUC_RES
)paren
ques
c_cond
l_string|&quot;resume execution&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_CUC
)paren
op_eq
id|SCB_CMD_CUC_SUS
)paren
ques
c_cond
l_string|&quot;suspend execution&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_CUC
)paren
op_eq
id|SCB_CMD_CUC_ABT
)paren
ques
c_cond
l_string|&quot;abort execution&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ruc 0x%x[%s%s%s%s%s]&bslash;n&quot;
comma
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_RUC
)paren
op_rshift
l_int|4
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_RUC
)paren
op_eq
id|SCB_CMD_RUC_NOP
)paren
ques
c_cond
l_string|&quot;nop&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_RUC
)paren
op_eq
id|SCB_CMD_RUC_GO
)paren
ques
c_cond
l_string|&quot;start rfa_offset&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_RUC
)paren
op_eq
id|SCB_CMD_RUC_RES
)paren
ques
c_cond
l_string|&quot;resume reception&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_RUC
)paren
op_eq
id|SCB_CMD_RUC_SUS
)paren
ques
c_cond
l_string|&quot;suspend reception&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|scb.scb_command
op_amp
id|SCB_CMD_RUC
)paren
op_eq
id|SCB_CMD_RUC_ABT
)paren
ques
c_cond
l_string|&quot;abort reception&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cbl_offset 0x%x &quot;
comma
id|scb.scb_cbl_offset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rfa_offset 0x%x&bslash;n&quot;
comma
id|scb.scb_rfa_offset
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;crcerrs %d &quot;
comma
id|scb.scb_crcerrs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;alnerrs %d &quot;
comma
id|scb.scb_alnerrs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rscerrs %d &quot;
comma
id|scb.scb_rscerrs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ovrnerrs %d&bslash;n&quot;
comma
id|scb.scb_ovrnerrs
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the i82586&squot;s receive unit.&n; */
DECL|function|wv_ru_show
r_static
r_void
id|wv_ru_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* net_local *lp = (net_local *) dev-&gt;priv; */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### WaveLAN i82586 receiver unit status: #####&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ru:&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Not implemented yet&n;&t; */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_ru_show */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Display info about one control block of the i82586 memory.&n; */
DECL|function|wv_cu_show_one
r_static
r_void
id|wv_cu_show_one
c_func
(paren
id|device
op_star
id|dev
comma
id|net_local
op_star
id|lp
comma
r_int
id|i
comma
id|u16
id|p
)paren
(brace
r_int
r_int
id|ioaddr
suffix:semicolon
id|ac_tx_t
id|actx
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: 0x%x:&quot;
comma
id|i
comma
id|p
)paren
suffix:semicolon
id|obram_read
c_func
(paren
id|ioaddr
comma
id|p
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|actx
comma
r_sizeof
(paren
id|actx
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; status=0x%x,&quot;
comma
id|actx.tx_h.ac_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; command=0x%x,&quot;
comma
id|actx.tx_h.ac_command
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   {&n;&t;   tbd_t      tbd;&n;&n;&t;   obram_read(ioaddr, actx.tx_tbd_offset, (unsigned char *)&amp;tbd, sizeof(tbd));&n;&t;   printk(&quot; tbd_status=0x%x,&quot;, tbd.tbd_status);&n;&t;   }&n;&t; */
id|printk
c_func
(paren
l_string|&quot;|&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print status of the command unit of the i82586.&n; */
DECL|function|wv_cu_show
r_static
r_void
id|wv_cu_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|u16
id|p
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;##### WaveLAN i82586 command unit status: #####&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
id|lp-&gt;tx_first_in_use
suffix:semicolon
id|i
OL
id|NTXBLOCKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wv_cu_show_one
c_func
(paren
id|dev
comma
id|lp
comma
id|i
comma
id|p
)paren
suffix:semicolon
id|p
op_add_assign
id|TXBLOCKZ
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|OFFSET_CU
op_plus
id|NTXBLOCKS
op_star
id|TXBLOCKZ
)paren
id|p
op_sub_assign
id|NTXBLOCKS
op_star
id|TXBLOCKZ
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DEBUG_I82586_SHOW */
macro_line|#ifdef DEBUG_DEVICE_SHOW
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the WaveLAN PCMCIA device driver.&n; */
DECL|function|wv_dev_show
r_static
r_void
id|wv_dev_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dev:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; state=%lX,&quot;
comma
id|dev-&gt;state
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; trans_start=%ld,&quot;
comma
id|dev-&gt;trans_start
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; flags=0x%x,&quot;
comma
id|dev-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_dev_show */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Print the formatted status of the WaveLAN PCMCIA device driver&squot;s&n; * private information.&n; */
DECL|function|wv_local_show
r_static
r_void
id|wv_local_show
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
suffix:semicolon
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;local:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; tx_n_in_use=%d,&quot;
comma
id|lp-&gt;tx_n_in_use
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; hacr=0x%x,&quot;
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; rx_head=0x%x,&quot;
comma
id|lp-&gt;rx_head
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; rx_last=0x%x,&quot;
comma
id|lp-&gt;rx_last
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; tx_first_free=0x%x,&quot;
comma
id|lp-&gt;tx_first_free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; tx_first_in_use=0x%x,&quot;
comma
id|lp-&gt;tx_first_in_use
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wv_local_show */
macro_line|#endif&t;&t;&t;&t;/* DEBUG_DEVICE_SHOW */
macro_line|#if defined(DEBUG_RX_INFO) || defined(DEBUG_TX_INFO)
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Dump packet header (and content if necessary) on the screen&n; */
DECL|function|wv_packet_info
r_static
r_inline
r_void
id|wv_packet_info
c_func
(paren
id|u8
op_star
id|p
comma
multiline_comment|/* Packet to dump */
r_int
id|length
comma
multiline_comment|/* Length of the packet */
r_char
op_star
id|msg1
comma
multiline_comment|/* Name of the device */
r_char
op_star
id|msg2
)paren
(brace
multiline_comment|/* Name of the function */
r_int
id|i
suffix:semicolon
r_int
id|maxi
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s(): dest %02X:%02X:%02X:%02X:%02X:%02X, length %d&bslash;n&quot;
comma
id|msg1
comma
id|msg2
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
comma
id|p
(braket
l_int|2
)braket
comma
id|p
(braket
l_int|3
)braket
comma
id|p
(braket
l_int|4
)braket
comma
id|p
(braket
l_int|5
)braket
comma
id|length
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s(): src %02X:%02X:%02X:%02X:%02X:%02X, type 0x%02X%02X&bslash;n&quot;
comma
id|msg1
comma
id|msg2
comma
id|p
(braket
l_int|6
)braket
comma
id|p
(braket
l_int|7
)braket
comma
id|p
(braket
l_int|8
)braket
comma
id|p
(braket
l_int|9
)braket
comma
id|p
(braket
l_int|10
)braket
comma
id|p
(braket
l_int|11
)braket
comma
id|p
(braket
l_int|12
)braket
comma
id|p
(braket
l_int|13
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PACKET_DUMP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;data=&bslash;&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|maxi
op_assign
id|length
)paren
OG
id|DEBUG_PACKET_DUMP
)paren
id|maxi
op_assign
id|DEBUG_PACKET_DUMP
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|14
suffix:semicolon
id|i
OL
id|maxi
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
op_ge
l_char|&squot; &squot;
op_logical_and
id|p
(braket
id|i
)braket
op_le
l_char|&squot;~&squot;
)paren
id|printk
c_func
(paren
l_string|&quot; %c&quot;
comma
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%02X&quot;
comma
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxi
OL
id|length
)paren
id|printk
c_func
(paren
l_string|&quot;..&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_PACKET_DUMP */
)brace
macro_line|#endif&t;&t;&t;&t;/* defined(DEBUG_RX_INFO) || defined(DEBUG_TX_INFO) */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This is the information which is displayed by the driver at startup.&n; * There are lots of flags for configuring it to your liking.&n; */
DECL|function|wv_init_info
r_static
r_inline
r_void
id|wv_init_info
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|psa_t
id|psa
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Read the parameter storage area */
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PSA_SHOW
id|wv_psa_show
c_func
(paren
op_amp
id|psa
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_MMC_SHOW
id|wv_mmc_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_I82586_SHOW
id|wv_cu_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_BASIC_SHOW
multiline_comment|/* Now, let&squot;s go for the basic stuff. */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: WaveLAN at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WAVELAN_ADDR_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s%02X&quot;
comma
(paren
id|i
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, IRQ %d&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* Print current network ID. */
r_if
c_cond
(paren
id|psa.psa_nwid_select
)paren
id|printk
c_func
(paren
l_string|&quot;, nwid 0x%02X-%02X&quot;
comma
id|psa.psa_nwid
(braket
l_int|0
)braket
comma
id|psa.psa_nwid
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, nwid off&quot;
)paren
suffix:semicolon
multiline_comment|/* If 2.00 card */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
r_int
r_int
id|freq
suffix:semicolon
multiline_comment|/* Ask the EEPROM to read the frequency from the first area. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x00
comma
op_amp
id|freq
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Print frequency */
id|printk
c_func
(paren
l_string|&quot;, 2.00, %ld&quot;
comma
(paren
id|freq
op_rshift
l_int|6
)paren
op_plus
l_int|2400L
)paren
suffix:semicolon
multiline_comment|/* Hack! */
r_if
c_cond
(paren
id|freq
op_amp
l_int|0x20
)paren
id|printk
c_func
(paren
l_string|&quot;.5&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, PC&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|psa.psa_comp_number
)paren
(brace
r_case
id|PSA_COMP_PC_AT_915
suffix:colon
r_case
id|PSA_COMP_PC_AT_2400
suffix:colon
id|printk
c_func
(paren
l_string|&quot;-AT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_COMP_PC_MC_915
suffix:colon
r_case
id|PSA_COMP_PC_MC_2400
suffix:colon
id|printk
c_func
(paren
l_string|&quot;-MC&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_COMP_PCMCIA_915
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MCIA&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;?&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|psa.psa_subband
)paren
(brace
r_case
id|PSA_SUBBAND_915
suffix:colon
id|printk
c_func
(paren
l_string|&quot;915&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2425
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2425&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2460
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2460&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2484
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2484&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSA_SUBBAND_2430_5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;2430.5&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;?&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; MHz&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_BASIC_SHOW */
macro_line|#ifdef DEBUG_VERSION_SHOW
multiline_comment|/* Print version information */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* wv_init_info */
multiline_comment|/********************* IOCTL, STATS &amp; RECONFIG *********************/
multiline_comment|/*&n; * We found here routines that are called by Linux on different&n; * occasions after the configuration and not for transmitting data&n; * These may be called when the user use ifconfig, /proc/net/dev&n; * or wireless extensions&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get the current Ethernet statistics. This may be called with the&n; * card open or closed.&n; * Used when the user read /proc/net/dev&n; */
DECL|function|wavelan_get_stats
r_static
id|en_stats
op_star
id|wavelan_get_stats
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;&gt;wavelan_get_stats()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
op_amp
(paren
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set or clear the multicast filter for this adaptor.&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
DECL|function|wavelan_set_multicast_list
r_static
r_void
id|wavelan_set_multicast_list
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_set_multicast_list()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_set_multicast_list(): setting Rx mode %02X to %d addresses.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;flags
comma
id|dev-&gt;mc_count
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Are we asking for promiscuous mode,&n;&t; * or all multicast addresses (we don&squot;t have that!)&n;&t; * or too many multicast addresses for the hardware filter? */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
(paren
id|dev-&gt;mc_count
OG
id|I82586_MAX_MULTICAST_ADDRESSES
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Enable promiscuous mode: receive all packets.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;promiscuous
)paren
(brace
id|lp-&gt;promiscuous
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
id|wv_82586_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Tell the kernel that we are doing a really bad job. */
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* Are there multicast addresses to send? */
r_if
c_cond
(paren
id|dev-&gt;mc_list
op_ne
(paren
r_struct
id|dev_mc_list
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Disable promiscuous mode, but receive all packets&n;&t;&t; * in multicast list&n;&t;&t; */
macro_line|#ifdef MULTICAST_AVOID
r_if
c_cond
(paren
id|lp-&gt;promiscuous
op_logical_or
(paren
id|dev-&gt;mc_count
op_ne
id|lp-&gt;mc_count
)paren
)paren
macro_line|#endif
(brace
id|lp-&gt;promiscuous
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mc_count
op_assign
id|dev-&gt;mc_count
suffix:semicolon
id|wv_82586_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Switch to normal mode: disable promiscuous mode and &n;&t;&t; * clear the multicast list.&n;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;promiscuous
op_logical_or
id|lp-&gt;mc_count
op_eq
l_int|0
)paren
(brace
id|lp-&gt;promiscuous
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
id|wv_82586_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_set_multicast_list()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This function doesn&squot;t exist.&n; * (Note : it was a nice way to test the reconfigure stuff...)&n; */
macro_line|#ifdef SET_MAC_ADDRESS
DECL|function|wavelan_set_mac_address
r_static
r_int
id|wavelan_set_mac_address
c_func
(paren
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|sockaddr
op_star
id|mac
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Copy the address. */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|mac-&gt;sa_data
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
multiline_comment|/* Reconfigure the beast. */
id|wv_82586_reconfig
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* SET_MAC_ADDRESS */
macro_line|#ifdef WIRELESS_EXT&t;&t;/* if wireless extensions exist in the kernel */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Frequency setting (for hardware capable of it)&n; * It&squot;s a bit complicated and you don&squot;t really want to look into it.&n; * (called in wavelan_ioctl)&n; */
DECL|function|wv_set_frequency
r_static
r_inline
r_int
id|wv_set_frequency
c_func
(paren
r_int
r_int
id|ioaddr
comma
multiline_comment|/* I/O port of the card */
id|iw_freq
op_star
id|frequency
)paren
(brace
r_const
r_int
id|BAND_NUM
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Number of bands */
r_int
id|freq
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* offset to 2.4 GHz in .5 MHz */
macro_line|#ifdef DEBUG_IOCTL_INFO
r_int
id|i
suffix:semicolon
macro_line|#endif
multiline_comment|/* Setting by frequency */
multiline_comment|/* Theoretically, you may set any frequency between&n;&t; * the two limits with a 0.5 MHz precision. In practice,&n;&t; * I don&squot;t want you to have trouble with local regulations.&n;&t; */
r_if
c_cond
(paren
(paren
id|frequency-&gt;e
op_eq
l_int|1
)paren
op_logical_and
(paren
id|frequency-&gt;m
op_ge
(paren
r_int
)paren
l_float|2.412e8
)paren
op_logical_and
(paren
id|frequency-&gt;m
op_le
(paren
r_int
)paren
l_float|2.487e8
)paren
)paren
(brace
id|freq
op_assign
(paren
(paren
id|frequency-&gt;m
op_div
l_int|10000
)paren
op_minus
l_int|24000L
)paren
op_div
l_int|5
suffix:semicolon
)brace
multiline_comment|/* Setting by channel (same as wfreqsel) */
multiline_comment|/* Warning: each channel is 22 MHz wide, so some of the channels&n;&t; * will interfere. */
r_if
c_cond
(paren
(paren
id|frequency-&gt;e
op_eq
l_int|0
)paren
op_logical_and
(paren
id|frequency-&gt;m
op_ge
l_int|0
)paren
op_logical_and
(paren
id|frequency-&gt;m
OL
id|BAND_NUM
)paren
)paren
(brace
multiline_comment|/* Get frequency offset. */
id|freq
op_assign
id|channel_bands
(braket
id|frequency-&gt;m
)braket
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Verify that the frequency is allowed. */
r_if
c_cond
(paren
id|freq
op_ne
l_int|0L
)paren
(brace
id|u16
id|table
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Authorized frequency table */
multiline_comment|/* Read the frequency table. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x71
comma
id|table
comma
l_int|10
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Frequency table: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %04X&quot;
comma
id|table
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Look in the table to see whether the frequency is allowed. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|table
(braket
l_int|9
op_minus
(paren
(paren
id|freq
op_minus
l_int|24
)paren
op_div
l_int|16
)paren
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
(paren
id|freq
op_minus
l_int|24
)paren
op_mod
l_int|16
)paren
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* not allowed */
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* if we get a usable frequency */
r_if
c_cond
(paren
id|freq
op_ne
l_int|0L
)paren
(brace
r_int
r_int
id|area
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|dac
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|area_verify
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|dac_verify
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Corresponding gain (in the power adjust value table)&n;&t;&t; * See AT&amp;T WaveLAN Data Manual, REF 407-024689/E, page 3-8&n;&t;&t; * and WCIN062D.DOC, page 6.2.9. */
r_int
r_int
id|power_limit
(braket
)braket
op_assign
(brace
l_int|40
comma
l_int|80
comma
l_int|120
comma
l_int|160
comma
l_int|0
)brace
suffix:semicolon
r_int
id|power_band
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Selected band */
r_int
r_int
id|power_adjust
suffix:semicolon
multiline_comment|/* Correct value */
multiline_comment|/* Search for the gain. */
id|power_band
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|freq
OG
id|power_limit
(braket
id|power_band
)braket
)paren
op_logical_and
(paren
id|power_limit
(braket
op_increment
id|power_band
)braket
op_ne
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the first area. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x00
comma
id|area
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Read the DAC. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x60
comma
id|dac
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Read the new power adjust value. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x6B
op_minus
(paren
id|power_band
op_rshift
l_int|1
)paren
comma
op_amp
id|power_adjust
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|power_band
op_amp
l_int|0x1
)paren
id|power_adjust
op_rshift_assign
l_int|8
suffix:semicolon
r_else
id|power_adjust
op_and_assign
l_int|0xFF
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN EEPROM Area 1: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %04X&quot;
comma
id|area
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN EEPROM DAC: %04X %04X&bslash;n&quot;
comma
id|dac
(braket
l_int|0
)braket
comma
id|dac
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Frequency offset (for info only) */
id|area
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|freq
op_lshift
l_int|5
)paren
op_amp
l_int|0xFFE0
)paren
op_or
(paren
id|area
(braket
l_int|0
)braket
op_amp
l_int|0x1F
)paren
suffix:semicolon
multiline_comment|/* Receiver Principle main divider coefficient */
id|area
(braket
l_int|3
)braket
op_assign
(paren
id|freq
op_rshift
l_int|1
)paren
op_plus
l_int|2400L
op_minus
l_int|352L
suffix:semicolon
id|area
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|freq
op_amp
l_int|0x1
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|area
(braket
l_int|2
)braket
op_amp
l_int|0xFFEF
)paren
suffix:semicolon
multiline_comment|/* Transmitter Main divider coefficient */
id|area
(braket
l_int|13
)braket
op_assign
(paren
id|freq
op_rshift
l_int|1
)paren
op_plus
l_int|2400L
suffix:semicolon
id|area
(braket
l_int|12
)braket
op_assign
(paren
(paren
id|freq
op_amp
l_int|0x1
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|area
(braket
l_int|2
)braket
op_amp
l_int|0xFFEF
)paren
suffix:semicolon
multiline_comment|/* Other parts of the area are flags, bit streams or unused. */
multiline_comment|/* Set the value in the DAC. */
id|dac
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|power_adjust
op_rshift
l_int|1
)paren
op_amp
l_int|0x7F
)paren
op_or
(paren
id|dac
(braket
l_int|1
)braket
op_amp
l_int|0xFF80
)paren
suffix:semicolon
id|dac
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|power_adjust
op_amp
l_int|0x1
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|dac
(braket
l_int|0
)braket
op_amp
l_int|0xFFEF
)paren
suffix:semicolon
multiline_comment|/* Write the first area. */
id|fee_write
c_func
(paren
id|ioaddr
comma
l_int|0x00
comma
id|area
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Write the DAC. */
id|fee_write
c_func
(paren
id|ioaddr
comma
l_int|0x60
comma
id|dac
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* We now should verify here that the writing of the EEPROM went OK. */
multiline_comment|/* Reread the first area. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x00
comma
id|area_verify
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Reread the DAC. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x60
comma
id|dac_verify
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Compare. */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|area
comma
id|area_verify
comma
l_int|16
op_star
l_int|2
)paren
op_logical_or
id|memcmp
c_func
(paren
id|dac
comma
id|dac_verify
comma
l_int|2
op_star
l_int|2
)paren
)paren
(brace
macro_line|#ifdef DEBUG_IOCTL_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;WaveLAN: wv_set_frequency: unable to write new frequency to EEPROM(?).&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* We must download the frequency parameters to the&n;&t;&t; * synthesizers (from the EEPROM - area 1)&n;&t;&t; * Note: as the EEPROM is automatically decremented, we set the end&n;&t;&t; * if the area... */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
l_int|0x0F
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished. */
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|100
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/* We must now download the power adjust value (gain) to&n;&t;&t; * the synthesizers (from the EEPROM - area 7 - DAC). */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_addr
)paren
comma
l_int|0x61
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_fee_ctrl
)paren
comma
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
)paren
suffix:semicolon
multiline_comment|/* Wait for the download to finish. */
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|100
comma
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
multiline_comment|/* Verification of what we have done */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN EEPROM Area 1: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %04X&quot;
comma
id|area_verify
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WaveLAN EEPROM DAC:  %04X %04X&bslash;n&quot;
comma
id|dac_verify
(braket
l_int|0
)braket
comma
id|dac_verify
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Bah, never get there... */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Give the list of available frequencies.&n; */
DECL|function|wv_frequency_list
r_static
r_inline
r_int
id|wv_frequency_list
c_func
(paren
r_int
r_int
id|ioaddr
comma
multiline_comment|/* I/O port of the card */
id|iw_freq
op_star
id|list
comma
multiline_comment|/* List of frequencies to fill */
r_int
id|max
)paren
(brace
multiline_comment|/* Maximum number of frequencies */
id|u16
id|table
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Authorized frequency table */
r_int
id|freq
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* offset to 2.4 GHz in .5 MHz + 12 MHz */
r_int
id|i
suffix:semicolon
multiline_comment|/* index in the table */
r_int
id|c
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Channel number */
multiline_comment|/* Read the frequency table. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x71
multiline_comment|/* frequency table */
comma
id|table
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Check all frequencies. */
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|freq
op_assign
l_int|0
suffix:semicolon
id|freq
OL
l_int|150
suffix:semicolon
id|freq
op_increment
)paren
multiline_comment|/* Look in the table if the frequency is allowed */
r_if
c_cond
(paren
id|table
(braket
l_int|9
op_minus
(paren
id|freq
op_div
l_int|16
)paren
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|freq
op_mod
l_int|16
)paren
)paren
)paren
(brace
multiline_comment|/* Compute approximate channel number */
r_while
c_loop
(paren
(paren
(paren
(paren
id|channel_bands
(braket
id|c
)braket
op_rshift
l_int|1
)paren
op_minus
l_int|24
)paren
OL
id|freq
)paren
op_logical_and
(paren
id|c
OL
id|NELS
c_func
(paren
id|channel_bands
)paren
)paren
)paren
id|c
op_increment
suffix:semicolon
id|list
(braket
id|i
)braket
dot
id|i
op_assign
id|c
suffix:semicolon
multiline_comment|/* Set the list index */
multiline_comment|/* put in the list */
id|list
(braket
id|i
)braket
dot
id|m
op_assign
(paren
(paren
(paren
id|freq
op_plus
l_int|24
)paren
op_star
l_int|5
)paren
op_plus
l_int|24000L
)paren
op_star
l_int|10000
suffix:semicolon
id|list
(braket
id|i
op_increment
)braket
dot
id|e
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Check number. */
r_if
c_cond
(paren
id|i
op_ge
id|max
)paren
r_return
(paren
id|i
)paren
suffix:semicolon
)brace
r_return
(paren
id|i
)paren
suffix:semicolon
)brace
macro_line|#ifdef WIRELESS_SPY
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Gather wireless spy statistics:  for each packet, compare the source&n; * address with our list, and if they match, get the statistics.&n; * Sorry, but this function really needs the wireless extensions.&n; */
DECL|function|wl_spy_gather
r_static
r_inline
r_void
id|wl_spy_gather
c_func
(paren
id|device
op_star
id|dev
comma
id|u8
op_star
id|mac
comma
multiline_comment|/* MAC address */
id|u8
op_star
id|stats
)paren
(brace
multiline_comment|/* Statistics to gather */
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check all addresses. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* If match */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|mac
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
comma
id|WAVELAN_ADDR_SIZE
)paren
)paren
(brace
multiline_comment|/* Update statistics */
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|qual
op_assign
id|stats
(braket
l_int|2
)braket
op_amp
id|MMR_SGNL_QUAL
suffix:semicolon
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|level
op_assign
id|stats
(braket
l_int|0
)braket
op_amp
id|MMR_SIGNAL_LVL
suffix:semicolon
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|noise
op_assign
id|stats
(braket
l_int|1
)braket
op_amp
id|MMR_SILENCE_LVL
suffix:semicolon
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|updated
op_assign
l_int|0x7
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_SPY */
macro_line|#ifdef HISTOGRAM
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This function calculates a histogram of the signal level.&n; * As the noise is quite constant, it&squot;s like doing it on the SNR.&n; * We have defined a set of interval (lp-&gt;his_range), and each time&n; * the level goes in that interval, we increment the count (lp-&gt;his_sum).&n; * With this histogram you may detect if one WaveLAN is really weak,&n; * or you may also calculate the mean and standard deviation of the level.&n; */
DECL|function|wl_his_gather
r_static
r_inline
r_void
id|wl_his_gather
c_func
(paren
id|device
op_star
id|dev
comma
id|u8
op_star
id|stats
)paren
(brace
multiline_comment|/* Statistics to gather */
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u8
id|level
op_assign
id|stats
(braket
l_int|0
)braket
op_amp
id|MMR_SIGNAL_LVL
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Find the correct interval. */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
OL
(paren
id|lp-&gt;his_number
op_minus
l_int|1
)paren
)paren
op_logical_and
(paren
id|level
op_ge
id|lp-&gt;his_range
(braket
id|i
op_increment
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Increment interval counter. */
(paren
id|lp-&gt;his_sum
(braket
id|i
)braket
)paren
op_increment
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* HISTOGRAM */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Perform ioctl for configuration and information.&n; * It is here that the wireless extensions are treated (iwconfig).&n; */
DECL|function|wavelan_ioctl
r_static
r_int
id|wavelan_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
multiline_comment|/* device on which the ioctl is applied */
r_struct
id|ifreq
op_star
id|rq
comma
multiline_comment|/* data passed */
r_int
id|cmd
)paren
(brace
multiline_comment|/* ioctl number */
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* lp is not unused */
r_struct
id|iwreq
op_star
id|wrq
op_assign
(paren
r_struct
id|iwreq
op_star
)paren
id|rq
suffix:semicolon
id|psa_t
id|psa
suffix:semicolon
id|mm_t
id|m
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_ioctl(cmd=0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable interrupts and save flags. */
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* Look what is the request */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* --------------- WIRELESS EXTENSIONS --------------- */
r_case
id|SIOCGIWNAME
suffix:colon
id|strcpy
c_func
(paren
id|wrq-&gt;u.name
comma
l_string|&quot;WaveLAN&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIWNWID
suffix:colon
multiline_comment|/* Set NWID in WaveLAN. */
r_if
c_cond
(paren
op_logical_neg
id|wrq-&gt;u.nwid.disabled
)paren
(brace
multiline_comment|/* Set NWID in psa */
id|psa.psa_nwid
(braket
l_int|0
)braket
op_assign
(paren
id|wrq-&gt;u.nwid.value
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
suffix:semicolon
id|psa.psa_nwid
(braket
l_int|1
)braket
op_assign
id|wrq-&gt;u.nwid.value
op_amp
l_int|0xFF
suffix:semicolon
id|psa.psa_nwid_select
op_assign
l_int|0x01
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
id|psa.psa_nwid
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
id|psa.psa_nwid
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Set NWID in mmc. */
id|m.w.mmw_netw_id_l
op_assign
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|m.w.mmw_netw_id_h
op_assign
id|psa.psa_nwid
(braket
l_int|0
)braket
suffix:semicolon
id|mmc_write
c_func
(paren
id|ioaddr
comma
(paren
r_char
op_star
)paren
op_amp
id|m.w.mmw_netw_id_l
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.w.mmw_netw_id_l
comma
l_int|2
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_loopt_sel
)paren
comma
l_int|0x00
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable NWID in the psa. */
id|psa.psa_nwid_select
op_assign
l_int|0x00
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_nwid_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_nwid_select
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Disable NWID in the mmc (no filtering). */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_loopt_sel
)paren
comma
id|MMW_LOOPT_SEL_DIS_NWID
)paren
suffix:semicolon
)brace
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWNWID
suffix:colon
multiline_comment|/* Read the NWID. */
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
id|psa.psa_nwid
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
id|psa.psa_nwid
comma
l_int|3
)paren
suffix:semicolon
id|wrq-&gt;u.nwid.value
op_assign
(paren
id|psa.psa_nwid
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|wrq-&gt;u.nwid.disabled
op_assign
op_logical_neg
(paren
id|psa.psa_nwid_select
)paren
suffix:semicolon
id|wrq-&gt;u.nwid.fixed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Superfluous */
r_break
suffix:semicolon
r_case
id|SIOCSIWFREQ
suffix:colon
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable). */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
id|ret
op_assign
id|wv_set_frequency
c_func
(paren
id|ioaddr
comma
op_amp
(paren
id|wrq-&gt;u.freq
)paren
)paren
suffix:semicolon
r_else
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWFREQ
suffix:colon
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable).&n;&t;&t; * Does it work for everybody, especially old cards? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
r_int
r_int
id|freq
suffix:semicolon
multiline_comment|/* Ask the EEPROM to read the frequency from the first area. */
id|fee_read
c_func
(paren
id|ioaddr
comma
l_int|0x00
comma
op_amp
id|freq
comma
l_int|1
)paren
suffix:semicolon
id|wrq-&gt;u.freq.m
op_assign
(paren
(paren
id|freq
op_rshift
l_int|5
)paren
op_star
l_int|5
op_plus
l_int|24000L
)paren
op_star
l_int|10000
suffix:semicolon
id|wrq-&gt;u.freq.e
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_subband
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_subband
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psa.psa_subband
op_le
l_int|4
)paren
(brace
id|wrq-&gt;u.freq.m
op_assign
id|fixed_bands
(braket
id|psa.psa_subband
)braket
suffix:semicolon
id|wrq-&gt;u.freq.e
op_assign
(paren
id|psa.psa_subband
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCSIWSENS
suffix:colon
multiline_comment|/* Set the level threshold. */
multiline_comment|/* We should complain loudly if wrq-&gt;u.sens.fixed = 0, because we&n;&t;&t; * can&squot;t set auto mode... */
id|psa.psa_thr_pre_set
op_assign
id|wrq-&gt;u.sens.value
op_amp
l_int|0x3F
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_thr_pre_set
)paren
comma
id|psa.psa_thr_pre_set
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWSENS
suffix:colon
multiline_comment|/* Read the level threshold. */
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
comma
l_int|1
)paren
suffix:semicolon
id|wrq-&gt;u.sens.value
op_assign
id|psa.psa_thr_pre_set
op_amp
l_int|0x3F
suffix:semicolon
id|wrq-&gt;u.sens.fixed
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIWENCODE
suffix:colon
multiline_comment|/* Set encryption key */
r_if
c_cond
(paren
op_logical_neg
id|mmc_encr
c_func
(paren
id|ioaddr
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
multiline_comment|/* Check the size of the key */
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.length
op_ne
l_int|8
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Copy the key in the driver */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|copy_from_user
c_func
(paren
id|psa.psa_encryption_key
comma
id|wrq-&gt;u.encoding.pointer
comma
id|wrq-&gt;u.encoding.length
)paren
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|psa.psa_encryption_select
op_assign
l_int|1
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
dot
id|psa_encryption_select
comma
l_int|8
op_plus
l_int|1
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_encr_enable
)paren
comma
id|MMW_ENCR_ENABLE_EN
op_or
id|MMW_ENCR_ENABLE_MODE
)paren
suffix:semicolon
id|mmc_write
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_encr_key
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
dot
id|psa_encryption_key
comma
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.flags
op_amp
id|IW_ENCODE_DISABLED
)paren
(brace
multiline_comment|/* disable encryption */
id|psa.psa_encryption_select
op_assign
l_int|0
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
dot
id|psa_encryption_select
comma
l_int|1
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_encr_enable
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIWENCODE
suffix:colon
multiline_comment|/* Read the encryption key */
r_if
c_cond
(paren
op_logical_neg
id|mmc_encr
c_func
(paren
id|ioaddr
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* only super-user can see encryption key */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Basic checking... */
r_if
c_cond
(paren
id|wrq-&gt;u.encoding.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
multiline_comment|/* Verify the user buffer */
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|wrq-&gt;u.encoding.pointer
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_encryption_select
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
dot
id|psa_encryption_select
comma
l_int|1
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* encryption is enabled ? */
r_if
c_cond
(paren
id|psa.psa_encryption_select
)paren
id|wrq-&gt;u.encoding.flags
op_assign
id|IW_ENCODE_ENABLED
suffix:semicolon
r_else
id|wrq-&gt;u.encoding.flags
op_assign
id|IW_ENCODE_DISABLED
suffix:semicolon
id|wrq-&gt;u.encoding.flags
op_or_assign
id|mmc_encr
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Copy the key to the user buffer */
id|wrq-&gt;u.encoding.length
op_assign
l_int|8
suffix:semicolon
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.encoding.pointer
comma
id|psa.psa_encryption_key
comma
l_int|8
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWRANGE
suffix:colon
multiline_comment|/* basic checking */
r_if
c_cond
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
r_struct
id|iw_range
id|range
suffix:semicolon
multiline_comment|/* Set the length (useless:  it&squot;s constant). */
id|wrq-&gt;u.data.length
op_assign
r_sizeof
(paren
r_struct
id|iw_range
)paren
suffix:semicolon
multiline_comment|/* Set information in the range struct.  */
id|range.throughput
op_assign
l_float|1.6
op_star
l_int|1000
op_star
l_int|1000
suffix:semicolon
multiline_comment|/* don&squot;t argue on this ! */
id|range.min_nwid
op_assign
l_int|0x0000
suffix:semicolon
id|range.max_nwid
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable). */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
id|range.num_channels
op_assign
l_int|10
suffix:semicolon
id|range.num_frequency
op_assign
id|wv_frequency_list
c_func
(paren
id|ioaddr
comma
id|range.freq
comma
id|IW_MAX_FREQUENCIES
)paren
suffix:semicolon
)brace
r_else
id|range.num_channels
op_assign
id|range.num_frequency
op_assign
l_int|0
suffix:semicolon
id|range.sensitivity
op_assign
l_int|0x3F
suffix:semicolon
id|range.max_qual.qual
op_assign
id|MMR_SGNL_QUAL
suffix:semicolon
id|range.max_qual.level
op_assign
id|MMR_SIGNAL_LVL
suffix:semicolon
id|range.max_qual.noise
op_assign
id|MMR_SILENCE_LVL
suffix:semicolon
id|range.num_bitrates
op_assign
l_int|1
suffix:semicolon
id|range.bitrate
(braket
l_int|0
)braket
op_assign
l_int|2000000
suffix:semicolon
multiline_comment|/* 2 Mb/s */
multiline_comment|/* Encryption supported ? */
r_if
c_cond
(paren
id|mmc_encr
c_func
(paren
id|ioaddr
)paren
)paren
(brace
id|range.encoding_size
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* DES = 64 bits key */
id|range.num_encoding_sizes
op_assign
l_int|1
suffix:semicolon
id|range.max_encoding_tokens
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Only one key possible */
)brace
r_else
(brace
id|range.num_encoding_sizes
op_assign
l_int|0
suffix:semicolon
id|range.max_encoding_tokens
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Copy structure to the user buffer. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
op_amp
id|range
comma
r_sizeof
(paren
r_struct
id|iw_range
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWPRIV
suffix:colon
multiline_comment|/* Basic checking */
r_if
c_cond
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
(brace
r_struct
id|iw_priv_args
id|priv
(braket
)braket
op_assign
(brace
multiline_comment|/* { cmd,&n;&t;&t;&t;&t;     set_args,&n;&t;&t;&t;&t;     get_args,&n;&t;&t;&t;&t;     name } */
(brace
id|SIOCSIPQTHR
comma
id|IW_PRIV_TYPE_BYTE
op_or
id|IW_PRIV_SIZE_FIXED
op_or
l_int|1
comma
l_int|0
comma
l_string|&quot;setqualthr&quot;
)brace
comma
(brace
id|SIOCGIPQTHR
comma
l_int|0
comma
id|IW_PRIV_TYPE_BYTE
op_or
id|IW_PRIV_SIZE_FIXED
op_or
l_int|1
comma
l_string|&quot;getqualthr&quot;
)brace
comma
(brace
id|SIOCSIPHISTO
comma
id|IW_PRIV_TYPE_BYTE
op_or
l_int|16
comma
l_int|0
comma
l_string|&quot;sethisto&quot;
)brace
comma
(brace
id|SIOCGIPHISTO
comma
l_int|0
comma
id|IW_PRIV_TYPE_INT
op_or
l_int|16
comma
l_string|&quot;gethisto&quot;
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Set the number of available ioctls. */
id|wrq-&gt;u.data.length
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Copy structure to the user buffer. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
(paren
id|u8
op_star
)paren
id|priv
comma
r_sizeof
(paren
id|priv
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#ifdef WIRELESS_SPY
r_case
id|SIOCSIWSPY
suffix:colon
multiline_comment|/* Set the spy list */
multiline_comment|/* Check the number of addresses. */
r_if
c_cond
(paren
id|wrq-&gt;u.data.length
OG
id|IW_MAX_SPY
)paren
(brace
id|ret
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;spy_number
op_assign
id|wrq-&gt;u.data.length
suffix:semicolon
multiline_comment|/* Are there are addresses to copy? */
r_if
c_cond
(paren
id|lp-&gt;spy_number
OG
l_int|0
)paren
(brace
r_struct
id|sockaddr
id|address
(braket
id|IW_MAX_SPY
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Copy addresses to the driver. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|copy_from_user
c_func
(paren
id|address
comma
id|wrq-&gt;u.data.pointer
comma
r_sizeof
(paren
r_struct
id|sockaddr
)paren
op_star
id|lp-&gt;spy_number
)paren
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Copy addresses to the lp structure. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|lp-&gt;spy_address
(braket
id|i
)braket
comma
id|address
(braket
id|i
)braket
dot
id|sa_data
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset structure. */
id|memset
c_func
(paren
id|lp-&gt;spy_stat
comma
l_int|0x00
comma
r_sizeof
(paren
id|iw_qual
)paren
op_star
id|IW_MAX_SPY
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SetSpy:  set of new addresses is: &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wrq-&gt;u.data.length
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%02X:%02X:%02X:%02X:%02X:%02X &bslash;n&quot;
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|0
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|1
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|2
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|3
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|4
)braket
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_IOCTL_INFO */
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIWSPY
suffix:colon
multiline_comment|/* Get the spy list and spy stats. */
multiline_comment|/* Set the number of addresses */
id|wrq-&gt;u.data.length
op_assign
id|lp-&gt;spy_number
suffix:semicolon
multiline_comment|/* Does the user want to have the addresses back? */
r_if
c_cond
(paren
(paren
id|lp-&gt;spy_number
OG
l_int|0
)paren
op_logical_and
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
)paren
(brace
r_struct
id|sockaddr
id|address
(braket
id|IW_MAX_SPY
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Copy addresses from the lp structure. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|address
(braket
id|i
)braket
dot
id|sa_data
comma
id|lp-&gt;spy_address
(braket
id|i
)braket
comma
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
id|address
(braket
id|i
)braket
dot
id|sa_family
op_assign
id|AF_UNIX
suffix:semicolon
)brace
multiline_comment|/* Copy addresses to the user buffer. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
id|address
comma
r_sizeof
(paren
r_struct
id|sockaddr
)paren
op_star
id|lp-&gt;spy_number
)paren
suffix:semicolon
multiline_comment|/* Copy stats to the user buffer (just after). */
id|err
op_or_assign
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
op_plus
(paren
r_sizeof
(paren
r_struct
id|sockaddr
)paren
op_star
id|lp-&gt;spy_number
)paren
comma
id|lp-&gt;spy_stat
comma
r_sizeof
(paren
id|iw_qual
)paren
op_star
id|lp-&gt;spy_number
)paren
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Reset updated flags. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;spy_number
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;spy_stat
(braket
id|i
)braket
dot
id|updated
op_assign
l_int|0x0
suffix:semicolon
)brace
multiline_comment|/* if(pointer != NULL) */
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_SPY */
multiline_comment|/* ------------------ PRIVATE IOCTL ------------------ */
r_case
id|SIOCSIPQTHR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|psa.psa_quality_thr
op_assign
op_star
(paren
id|wrq-&gt;u.name
)paren
op_amp
l_int|0x0F
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_quality_thr
)paren
comma
id|psa.psa_quality_thr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIPQTHR
suffix:colon
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
comma
l_int|1
)paren
suffix:semicolon
op_star
(paren
id|wrq-&gt;u.name
)paren
op_assign
id|psa.psa_quality_thr
op_amp
l_int|0x0F
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef HISTOGRAM
r_case
id|SIOCSIPHISTO
suffix:colon
multiline_comment|/* Verify that the user is root. */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check the number of intervals. */
r_if
c_cond
(paren
id|wrq-&gt;u.data.length
OG
l_int|16
)paren
(brace
id|ret
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;his_number
op_assign
id|wrq-&gt;u.data.length
suffix:semicolon
multiline_comment|/* Are there addresses to copy? */
r_if
c_cond
(paren
id|lp-&gt;his_number
OG
l_int|0
)paren
(brace
multiline_comment|/* Copy interval ranges to the driver */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|copy_from_user
c_func
(paren
id|lp-&gt;his_range
comma
id|wrq-&gt;u.data.pointer
comma
r_sizeof
(paren
r_char
)paren
op_star
id|lp-&gt;his_number
)paren
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Reset structure. */
id|memset
c_func
(paren
id|lp-&gt;his_sum
comma
l_int|0x00
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|16
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIPHISTO
suffix:colon
multiline_comment|/* Set the number of intervals. */
id|wrq-&gt;u.data.length
op_assign
id|lp-&gt;his_number
suffix:semicolon
multiline_comment|/* Give back the distribution statistics */
r_if
c_cond
(paren
(paren
id|lp-&gt;his_number
OG
l_int|0
)paren
op_logical_and
(paren
id|wrq-&gt;u.data.pointer
op_ne
(paren
id|caddr_t
)paren
l_int|0
)paren
)paren
(brace
multiline_comment|/* Copy data to the user buffer. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|wrq-&gt;u.data.pointer
comma
id|lp-&gt;his_sum
comma
r_sizeof
(paren
r_int
)paren
op_star
id|lp-&gt;his_number
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* if(pointer != NULL) */
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* HISTOGRAM */
multiline_comment|/* ------------------- OTHER IOCTL ------------------- */
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* switch (cmd) */
multiline_comment|/* Enable interrupts and restore flags. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_ioctl()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get wireless statistics.&n; * Called by /proc/net/wireless&n; */
DECL|function|wavelan_get_wireless_stats
r_static
id|iw_stats
op_star
id|wavelan_get_wireless_stats
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mmr_t
id|m
suffix:semicolon
id|iw_stats
op_star
id|wstats
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_get_wireless_stats()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check */
r_if
c_cond
(paren
id|lp
op_eq
(paren
id|net_local
op_star
)paren
l_int|NULL
)paren
r_return
(paren
id|iw_stats
op_star
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* Disable interrupts and save flags. */
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|wstats
op_assign
op_amp
id|lp-&gt;wstats
suffix:semicolon
multiline_comment|/* Get data from the mmc. */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_dce_status
)paren
comma
op_amp
id|m.mmr_dce_status
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_wrong_nwid_l
)paren
comma
op_amp
id|m.mmr_wrong_nwid_l
comma
l_int|2
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_thr_pre_set
)paren
comma
op_amp
id|m.mmr_thr_pre_set
comma
l_int|4
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Copy data to wireless stuff. */
id|wstats-&gt;status
op_assign
id|m.mmr_dce_status
op_amp
id|MMR_DCE_STATUS
suffix:semicolon
id|wstats-&gt;qual.qual
op_assign
id|m.mmr_sgnl_qual
op_amp
id|MMR_SGNL_QUAL
suffix:semicolon
id|wstats-&gt;qual.level
op_assign
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL
suffix:semicolon
id|wstats-&gt;qual.noise
op_assign
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL
suffix:semicolon
id|wstats-&gt;qual.updated
op_assign
(paren
(paren
(paren
id|m
dot
id|mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL_VALID
)paren
op_rshift
l_int|7
)paren
op_or
(paren
(paren
id|m.mmr_signal_lvl
op_amp
id|MMR_SIGNAL_LVL_VALID
)paren
op_rshift
l_int|6
)paren
op_or
(paren
(paren
id|m.mmr_silence_lvl
op_amp
id|MMR_SILENCE_LVL_VALID
)paren
op_rshift
l_int|5
)paren
)paren
suffix:semicolon
id|wstats-&gt;discard.nwid
op_add_assign
(paren
id|m.mmr_wrong_nwid_h
op_lshift
l_int|8
)paren
op_or
id|m.mmr_wrong_nwid_l
suffix:semicolon
id|wstats-&gt;discard.code
op_assign
l_int|0L
suffix:semicolon
id|wstats-&gt;discard.misc
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* Enable interrupts and restore flags. */
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_get_wireless_stats()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_amp
id|lp-&gt;wstats
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_EXT */
multiline_comment|/************************* PACKET RECEPTION *************************/
multiline_comment|/*&n; * This part deals with receiving the packets.&n; * The interrupt handler gets an interrupt when a packet has been&n; * successfully received and calls this part.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine does the actual copying of data (including the Ethernet&n; * header structure) from the WaveLAN card to an sk_buff chain that&n; * will be passed up to the network interface layer. NOTE: we&n; * currently don&squot;t handle trailer protocols (neither does the rest of&n; * the network interface), so if that is needed, it will (at least in&n; * part) be added here.  The contents of the receive ring buffer are&n; * copied to a message chain that is then passed to the kernel.&n; *&n; * Note: if any errors occur, the packet is &quot;dropped on the floor&quot;.&n; * (called by wv_packet_rcv())&n; */
r_static
r_inline
r_void
DECL|function|wv_packet_read
id|wv_packet_read
c_func
(paren
id|device
op_star
id|dev
comma
id|u16
id|buf_off
comma
r_int
id|sksize
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_packet_read(0x%X, %d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|buf_off
comma
id|sksize
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Allocate buffer for the data */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|sksize
)paren
)paren
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_RX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_packet_read(): could not alloc_skb(%d, GFP_ATOMIC).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sksize
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Copy the packet to the buffer. */
id|obram_read
c_func
(paren
id|ioaddr
comma
id|buf_off
comma
id|skb_put
c_func
(paren
id|skb
comma
id|sksize
)paren
comma
id|sksize
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RX_INFO
id|wv_packet_info
c_func
(paren
id|skb-&gt;mac.raw
comma
id|sksize
comma
id|dev-&gt;name
comma
l_string|&quot;wv_packet_read&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_RX_INFO */
multiline_comment|/* Statistics-gathering and associated stuff.&n;&t; * It seem a bit messy with all the define, but it&squot;s really simple... */
macro_line|#if defined(WIRELESS_SPY) || defined(HISTOGRAM)
r_if
c_cond
(paren
macro_line|#ifdef WIRELESS_SPY
(paren
id|lp-&gt;spy_number
OG
l_int|0
)paren
op_logical_or
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_SPY */
macro_line|#ifdef HISTOGRAM
(paren
id|lp-&gt;his_number
OG
l_int|0
)paren
op_logical_or
macro_line|#endif&t;&t;&t;&t;/* HISTOGRAM */
l_int|0
)paren
(brace
id|u8
id|stats
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* signal level, noise level, signal quality */
multiline_comment|/* Read signal level, silence level and signal quality bytes. */
multiline_comment|/* Note: in the PCMCIA hardware, these are part of the frame.  It seems&n;&t;&t; * that for the ISA hardware, it&squot;s nowhere to be found in the frame,&n;&t;&t; * so I&squot;m obliged to do this (it has a side effect on /proc/net/wireless).&n;&t;&t; * Any ideas?&n;&t;&t; */
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|1
)paren
suffix:semicolon
id|mmc_read
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_signal_lvl
)paren
comma
id|stats
comma
l_int|3
)paren
suffix:semicolon
id|mmc_out
c_func
(paren
id|ioaddr
comma
id|mmwoff
c_func
(paren
l_int|0
comma
id|mmw_freeze
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RX_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_packet_read(): Signal level %d/63, Silence level %d/63, signal quality %d/16&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats
(braket
l_int|0
)braket
op_amp
l_int|0x3F
comma
id|stats
(braket
l_int|1
)braket
op_amp
l_int|0x3F
comma
id|stats
(braket
l_int|2
)braket
op_amp
l_int|0x0F
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Spying stuff */
macro_line|#ifdef WIRELESS_SPY
id|wl_spy_gather
c_func
(paren
id|dev
comma
id|skb-&gt;mac.raw
op_plus
id|WAVELAN_ADDR_SIZE
comma
id|stats
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* WIRELESS_SPY */
macro_line|#ifdef HISTOGRAM
id|wl_his_gather
c_func
(paren
id|dev
comma
id|stats
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* HISTOGRAM */
)brace
macro_line|#endif&t;&t;&t;&t;/* defined(WIRELESS_SPY) || defined(HISTOGRAM) */
multiline_comment|/*&n;&t; * Hand the packet to the network module.&n;&t; */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keep statistics up to date */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_packet_read()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Transfer as many packets as we can&n; * from the device RAM.&n; * (called in wavelan_interrupt()).&n; * Note : the spinlock is already grabbed for us.&n; */
DECL|function|wv_receive
r_static
r_inline
r_void
id|wv_receive
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|fd_t
id|fd
suffix:semicolon
id|rbd_t
id|rbd
suffix:semicolon
r_int
id|nreaped
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_receive()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Loop on each received packet. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;rx_head
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|fd
comma
r_sizeof
(paren
id|fd
)paren
)paren
suffix:semicolon
multiline_comment|/* Note about the status :&n;&t;&t; * It start up to be 0 (the value we set). Then, when the RU&n;&t;&t; * grab the buffer to prepare for reception, it sets the&n;&t;&t; * FD_STATUS_B flag. When the RU has finished receiving the&n;&t;&t; * frame, it clears FD_STATUS_B, set FD_STATUS_C to indicate&n;&t;&t; * completion and set the other flags to indicate the eventual&n;&t;&t; * errors. FD_STATUS_OK indicates that the reception was OK.&n;&t;&t; */
multiline_comment|/* If the current frame is not complete, we have reached the end. */
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_C
)paren
op_ne
id|FD_STATUS_C
)paren
r_break
suffix:semicolon
multiline_comment|/* This is how we exit the loop. */
id|nreaped
op_increment
suffix:semicolon
multiline_comment|/* Check whether frame was correctly received. */
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_OK
)paren
op_eq
id|FD_STATUS_OK
)paren
(brace
multiline_comment|/* Does the frame contain a pointer to the data?  Let&squot;s check. */
r_if
c_cond
(paren
id|fd.fd_rbd_offset
op_ne
id|I82586NULL
)paren
(brace
multiline_comment|/* Read the receive buffer descriptor */
id|obram_read
c_func
(paren
id|ioaddr
comma
id|fd.fd_rbd_offset
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|rbd
comma
r_sizeof
(paren
id|rbd
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RX_ERROR
r_if
c_cond
(paren
(paren
id|rbd.rbd_status
op_amp
id|RBD_STATUS_EOF
)paren
op_ne
id|RBD_STATUS_EOF
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_receive(): missing EOF flag.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rbd.rbd_status
op_amp
id|RBD_STATUS_F
)paren
op_ne
id|RBD_STATUS_F
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_receive(): missing F flag.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_RX_ERROR */
multiline_comment|/* Read the packet and transmit to Linux */
id|wv_packet_read
c_func
(paren
id|dev
comma
id|rbd.rbd_bufl
comma
id|rbd
dot
id|rbd_status
op_amp
id|RBD_STATUS_ACNT
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_RX_ERROR
r_else
multiline_comment|/* if frame has no data */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_receive(): frame has no data.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* If reception was no successful */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_RX_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): frame not received successfully (%X).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|fd.fd_status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_RX_ERROR
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_S6
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_receive(): no EOF flag.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_S7
)paren
op_ne
l_int|0
)paren
(brace
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_RX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): frame too short.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_S8
)paren
op_ne
l_int|0
)paren
(brace
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_RX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): rx DMA overrun.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_S9
)paren
op_ne
l_int|0
)paren
(brace
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_RX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): ran out of resources.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_S10
)paren
op_ne
l_int|0
)paren
(brace
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_RX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): alignment error.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|fd.fd_status
op_amp
id|FD_STATUS_S11
)paren
op_ne
l_int|0
)paren
(brace
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_RX_FAIL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): CRC error.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|fd.fd_status
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|fdoff
c_func
(paren
id|lp-&gt;rx_head
comma
id|fd_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|fd.fd_status
comma
r_sizeof
(paren
id|fd.fd_status
)paren
)paren
suffix:semicolon
id|fd.fd_command
op_assign
id|FD_COMMAND_EL
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|fdoff
c_func
(paren
id|lp-&gt;rx_head
comma
id|fd_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|fd.fd_command
comma
r_sizeof
(paren
id|fd.fd_command
)paren
)paren
suffix:semicolon
id|fd.fd_command
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|fdoff
c_func
(paren
id|lp-&gt;rx_last
comma
id|fd_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|fd.fd_command
comma
r_sizeof
(paren
id|fd.fd_command
)paren
)paren
suffix:semicolon
id|lp-&gt;rx_last
op_assign
id|lp-&gt;rx_head
suffix:semicolon
id|lp-&gt;rx_head
op_assign
id|fd.fd_link_offset
suffix:semicolon
)brace
multiline_comment|/* for(;;) -&gt; loop on all frames */
macro_line|#ifdef DEBUG_RX_INFO
r_if
c_cond
(paren
id|nreaped
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_receive(): reaped %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|nreaped
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_RX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_receive()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*********************** PACKET TRANSMISSION ***********************/
multiline_comment|/*&n; * This part deals with sending packets through the WaveLAN.&n; *&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine fills in the appropriate registers and memory&n; * locations on the WaveLAN card and starts the card off on&n; * the transmit.&n; *&n; * The principle:&n; * Each block contains a transmit command, a NOP command,&n; * a transmit block descriptor and a buffer.&n; * The CU read the transmit block which point to the tbd,&n; * read the tbd and the content of the buffer.&n; * When it has finish with it, it goes to the next command&n; * which in our case is the NOP. The NOP points on itself,&n; * so the CU stop here.&n; * When we add the next block, we modify the previous nop&n; * to make it point on the new tx command.&n; * Simple, isn&squot;t it ?&n; *&n; * (called in wavelan_packet_xmit())&n; */
DECL|function|wv_packet_write
r_static
r_inline
r_int
id|wv_packet_write
c_func
(paren
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|txblock
suffix:semicolon
r_int
r_int
id|txpred
suffix:semicolon
r_int
r_int
id|tx_addr
suffix:semicolon
r_int
r_int
id|nop_addr
suffix:semicolon
r_int
r_int
id|tbd_addr
suffix:semicolon
r_int
r_int
id|buf_addr
suffix:semicolon
id|ac_tx_t
id|tx
suffix:semicolon
id|ac_nop_t
id|nop
suffix:semicolon
id|tbd_t
id|tbd
suffix:semicolon
r_int
id|clen
op_assign
id|length
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_packet_write(%d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Do we need some padding? */
r_if
c_cond
(paren
id|clen
OL
id|ETH_ZLEN
)paren
id|clen
op_assign
id|ETH_ZLEN
suffix:semicolon
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check nothing bad has happened */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
op_eq
(paren
id|NTXBLOCKS
op_minus
l_int|1
)paren
)paren
(brace
macro_line|#ifdef DEBUG_TX_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_packet_write(): Tx queue full.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Calculate addresses of next block and previous block. */
id|txblock
op_assign
id|lp-&gt;tx_first_free
suffix:semicolon
id|txpred
op_assign
id|txblock
op_minus
id|TXBLOCKZ
suffix:semicolon
r_if
c_cond
(paren
id|txpred
OL
id|OFFSET_CU
)paren
id|txpred
op_add_assign
id|NTXBLOCKS
op_star
id|TXBLOCKZ
suffix:semicolon
id|lp-&gt;tx_first_free
op_add_assign
id|TXBLOCKZ
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_first_free
op_ge
id|OFFSET_CU
op_plus
id|NTXBLOCKS
op_star
id|TXBLOCKZ
)paren
id|lp-&gt;tx_first_free
op_sub_assign
id|NTXBLOCKS
op_star
id|TXBLOCKZ
suffix:semicolon
id|lp-&gt;tx_n_in_use
op_increment
suffix:semicolon
multiline_comment|/* Calculate addresses of the different parts of the block. */
id|tx_addr
op_assign
id|txblock
suffix:semicolon
id|nop_addr
op_assign
id|tx_addr
op_plus
r_sizeof
(paren
id|tx
)paren
suffix:semicolon
id|tbd_addr
op_assign
id|nop_addr
op_plus
r_sizeof
(paren
id|nop
)paren
suffix:semicolon
id|buf_addr
op_assign
id|tbd_addr
op_plus
r_sizeof
(paren
id|tbd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Transmit command&n;&t; */
id|tx.tx_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_tx_t
comma
id|tx_addr
comma
id|tx_h.ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|tx.tx_h.ac_status
comma
r_sizeof
(paren
id|tx.tx_h.ac_status
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOP command&n;&t; */
id|nop.nop_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_status
comma
r_sizeof
(paren
id|nop.nop_h.ac_status
)paren
)paren
suffix:semicolon
id|nop.nop_h.ac_link
op_assign
id|nop_addr
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_link
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_link
comma
r_sizeof
(paren
id|nop.nop_h.ac_link
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Transmit buffer descriptor&n;&t; */
id|tbd.tbd_status
op_assign
id|TBD_STATUS_EOF
op_or
(paren
id|TBD_STATUS_ACNT
op_amp
id|clen
)paren
suffix:semicolon
id|tbd.tbd_next_bd_offset
op_assign
id|I82586NULL
suffix:semicolon
id|tbd.tbd_bufl
op_assign
id|buf_addr
suffix:semicolon
id|tbd.tbd_bufh
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|tbd_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|tbd
comma
r_sizeof
(paren
id|tbd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Data&n;&t; */
id|obram_write
c_func
(paren
id|ioaddr
comma
id|buf_addr
comma
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Overwrite the predecessor NOP link&n;&t; * so that it points to this txblock.&n;&t; */
id|nop_addr
op_assign
id|txpred
op_plus
r_sizeof
(paren
id|tx
)paren
suffix:semicolon
id|nop.nop_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_status
comma
r_sizeof
(paren
id|nop.nop_h.ac_status
)paren
)paren
suffix:semicolon
id|nop.nop_h.ac_link
op_assign
id|txblock
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_link
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_link
comma
r_sizeof
(paren
id|nop.nop_h.ac_link
)paren
)paren
suffix:semicolon
multiline_comment|/* Keep stats up to date. */
id|lp-&gt;stats.tx_bytes
op_add_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_first_in_use
op_eq
id|I82586NULL
)paren
id|lp-&gt;tx_first_in_use
op_assign
id|txblock
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
OL
id|NTXBLOCKS
op_minus
l_int|1
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TX_INFO
id|wv_packet_info
c_func
(paren
(paren
id|u8
op_star
)paren
id|buf
comma
id|length
comma
id|dev-&gt;name
comma
l_string|&quot;wv_packet_write&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* DEBUG_TX_INFO */
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_packet_write()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine is called when we want to send a packet (NET3 callback)&n; * In this routine, we check if the harware is ready to accept&n; * the packet.  We also prevent reentrance.  Then we call the function&n; * to send the packet.&n; */
DECL|function|wavelan_packet_xmit
r_static
r_int
id|wavelan_packet_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_packet_xmit(0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Block a timer-based transmit from overlapping.&n;&t; * In other words, prevent reentering this routine.&n;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* If somebody has asked to reconfigure the controller, &n;&t; * we can do it now.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;reconfig_82586
)paren
(brace
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|wv_82586_config
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check that we can continue */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
op_eq
(paren
id|NTXBLOCKS
op_minus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TX_ERROR
r_if
c_cond
(paren
id|skb-&gt;next
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;skb has next&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Write packet on the card */
r_if
c_cond
(paren
id|wv_packet_write
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We failed */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TX_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_packet_xmit()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*********************** HARDWARE CONFIGURATION ***********************/
multiline_comment|/*&n; * This part does the real job of starting and configuring the hardware.&n; */
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/*&n; * Routine to initialize the Modem Management Controller.&n; * (called by wv_hw_reset())&n; */
DECL|function|wv_mmc_init
r_static
r_inline
r_int
id|wv_mmc_init
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|psa_t
id|psa
suffix:semicolon
id|mmw_t
id|m
suffix:semicolon
r_int
id|configured
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_mmc_init()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the parameter storage area. */
id|psa_read
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
macro_line|#ifdef USE_PSA_CONFIG
id|configured
op_assign
id|psa.psa_conf_status
op_amp
l_int|1
suffix:semicolon
macro_line|#else
id|configured
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is the PSA is not configured */
r_if
c_cond
(paren
op_logical_neg
id|configured
)paren
(brace
multiline_comment|/* User will be able to configure NWID later (with iwconfig). */
id|psa.psa_nwid
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|psa.psa_nwid
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no NWID checking since NWID is not set */
id|psa.psa_nwid_select
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Disable encryption */
id|psa.psa_encryption_select
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set to standard values:&n;&t;&t; * 0x04 for AT,&n;&t;&t; * 0x01 for MCA,&n;&t;&t; * 0x04 for PCMCIA and 2.00 card (AT&amp;T 407-024689/E document)&n;&t;&t; */
r_if
c_cond
(paren
id|psa.psa_comp_number
op_amp
l_int|1
)paren
id|psa.psa_thr_pre_set
op_assign
l_int|0x01
suffix:semicolon
r_else
id|psa.psa_thr_pre_set
op_assign
l_int|0x04
suffix:semicolon
id|psa.psa_quality_thr
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* It is configured */
id|psa.psa_conf_status
op_or_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USE_PSA_CONFIG
multiline_comment|/* Write the psa. */
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
id|psa.psa_nwid
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
id|psa.psa_nwid
comma
l_int|4
)paren
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_thr_pre_set
comma
l_int|1
)paren
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_quality_thr
comma
l_int|1
)paren
suffix:semicolon
id|psa_write
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
comma
(paren
r_char
op_star
)paren
op_amp
id|psa.psa_conf_status
op_minus
(paren
r_char
op_star
)paren
op_amp
id|psa
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa.psa_conf_status
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Zero the mmc structure. */
id|memset
c_func
(paren
op_amp
id|m
comma
l_int|0x00
comma
r_sizeof
(paren
id|m
)paren
)paren
suffix:semicolon
multiline_comment|/* Copy PSA info to the mmc. */
id|m.mmw_netw_id_l
op_assign
id|psa.psa_nwid
(braket
l_int|1
)braket
suffix:semicolon
id|m.mmw_netw_id_h
op_assign
id|psa.psa_nwid
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|psa.psa_nwid_select
op_amp
l_int|1
)paren
id|m.mmw_loopt_sel
op_assign
l_int|0x00
suffix:semicolon
r_else
id|m.mmw_loopt_sel
op_assign
id|MMW_LOOPT_SEL_DIS_NWID
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|m.mmw_encr_key
comma
op_amp
id|psa.psa_encryption_key
comma
r_sizeof
(paren
id|m.mmw_encr_key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psa.psa_encryption_select
)paren
id|m.mmw_encr_enable
op_assign
id|MMW_ENCR_ENABLE_EN
op_or
id|MMW_ENCR_ENABLE_MODE
suffix:semicolon
r_else
id|m.mmw_encr_enable
op_assign
l_int|0
suffix:semicolon
id|m.mmw_thr_pre_set
op_assign
id|psa.psa_thr_pre_set
op_amp
l_int|0x3F
suffix:semicolon
id|m.mmw_quality_thr
op_assign
id|psa.psa_quality_thr
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/*&n;&t; * Set default modem control parameters.&n;&t; * See NCR document 407-0024326 Rev. A.&n;&t; */
id|m.mmw_jabber_enable
op_assign
l_int|0x01
suffix:semicolon
id|m.mmw_freeze
op_assign
l_int|0
suffix:semicolon
id|m.mmw_anten_sel
op_assign
id|MMW_ANTEN_SEL_ALG_EN
suffix:semicolon
id|m.mmw_ifs
op_assign
l_int|0x20
suffix:semicolon
id|m.mmw_mod_delay
op_assign
l_int|0x04
suffix:semicolon
id|m.mmw_jam_time
op_assign
l_int|0x38
suffix:semicolon
id|m.mmw_des_io_invert
op_assign
l_int|0
suffix:semicolon
id|m.mmw_decay_prm
op_assign
l_int|0
suffix:semicolon
id|m.mmw_decay_updat_prm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Write all info to MMC. */
id|mmc_write
c_func
(paren
id|ioaddr
comma
l_int|0
comma
(paren
id|u8
op_star
)paren
op_amp
id|m
comma
r_sizeof
(paren
id|m
)paren
)paren
suffix:semicolon
multiline_comment|/* The following code starts the modem of the 2.00 frequency&n;&t; * selectable cards at power on.  It&squot;s not strictly needed for the&n;&t; * following boots.&n;&t; * The original patch was by Joe Finney for the PCMCIA driver, but&n;&t; * I&squot;ve cleaned it up a bit and added documentation.&n;&t; * Thanks to Loeke Brederveld from Lucent for the info.&n;&t; */
multiline_comment|/* Attempt to recognise 2.00 cards (2.4 GHz frequency selectable)&n;&t; * Does it work for everybody, especially old cards? */
multiline_comment|/* Note: WFREQSEL verifies that it is able to read a sensible&n;&t; * frequency from EEPROM (address 0x00) and that MMR_FEE_STATUS_ID&n;&t; * is 0xA (Xilinx version) or 0xB (Ariadne version).&n;&t; * My test is more crude but does work. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mmc_in
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_fee_status
)paren
)paren
op_amp
(paren
id|MMR_FEE_STATUS_DWLD
op_or
id|MMR_FEE_STATUS_BUSY
)paren
)paren
)paren
(brace
multiline_comment|/* We must download the frequency parameters to the&n;&t;&t; * synthesizers (from the EEPROM - area 1)&n;&t;&t; * Note: as the EEPROM is automatically decremented, we set the end&n;&t;&t; * if the area... */
id|m.mmw_fee_addr
op_assign
l_int|0x0F
suffix:semicolon
id|m.mmw_fee_ctrl
op_assign
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
suffix:semicolon
id|mmc_write
c_func
(paren
id|ioaddr
comma
(paren
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished. */
id|fee_wait
c_func
(paren
id|ioaddr
comma
l_int|100
comma
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
multiline_comment|/* The frequency was in the last word downloaded. */
id|mmc_read
c_func
(paren
id|ioaddr
comma
(paren
r_char
op_star
)paren
op_amp
id|m.mmw_fee_data_l
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.mmw_fee_data_l
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Print some info for the user. */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: WaveLAN 2.00 recognised (frequency select).  Current frequency = %ld&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
(paren
id|m
dot
id|mmw_fee_data_h
op_lshift
l_int|4
)paren
op_or
(paren
id|m.mmw_fee_data_l
op_rshift
l_int|4
)paren
)paren
op_star
l_int|5
op_div
l_int|2
op_plus
l_int|24000L
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We must now download the power adjust value (gain) to&n;&t;&t; * the synthesizers (from the EEPROM - area 7 - DAC). */
id|m.mmw_fee_addr
op_assign
l_int|0x61
suffix:semicolon
id|m.mmw_fee_ctrl
op_assign
id|MMW_FEE_CTRL_READ
op_or
id|MMW_FEE_CTRL_DWLD
suffix:semicolon
id|mmc_write
c_func
(paren
id|ioaddr
comma
(paren
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
op_minus
(paren
r_char
op_star
)paren
op_amp
id|m
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|m.mmw_fee_ctrl
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Wait until the download is finished. */
)brace
multiline_comment|/* if 2.00 card */
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_mmc_init()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Construct the fd and rbd structures.&n; * Start the receive unit.&n; * (called by wv_hw_reset())&n; */
DECL|function|wv_ru_start
r_static
r_inline
r_int
id|wv_ru_start
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|scb_cs
suffix:semicolon
id|fd_t
id|fd
suffix:semicolon
id|rbd_t
id|rbd
suffix:semicolon
id|u16
id|rx
suffix:semicolon
id|u16
id|rx_next
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_ru_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|obram_read
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb_cs
op_amp
id|SCB_ST_RUS
)paren
op_eq
id|SCB_ST_RUS_RDY
)paren
r_return
l_int|0
suffix:semicolon
id|lp-&gt;rx_head
op_assign
id|OFFSET_RU
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|rx
op_assign
id|lp-&gt;rx_head
suffix:semicolon
id|i
OL
id|NRXBLOCKS
suffix:semicolon
id|i
op_increment
comma
id|rx
op_assign
id|rx_next
)paren
(brace
id|rx_next
op_assign
(paren
id|i
op_eq
id|NRXBLOCKS
op_minus
l_int|1
)paren
ques
c_cond
id|lp-&gt;rx_head
suffix:colon
id|rx
op_plus
id|RXBLOCKZ
suffix:semicolon
id|fd.fd_status
op_assign
l_int|0
suffix:semicolon
id|fd.fd_command
op_assign
(paren
id|i
op_eq
id|NRXBLOCKS
op_minus
l_int|1
)paren
ques
c_cond
id|FD_COMMAND_EL
suffix:colon
l_int|0
suffix:semicolon
id|fd.fd_link_offset
op_assign
id|rx_next
suffix:semicolon
id|fd.fd_rbd_offset
op_assign
id|rx
op_plus
r_sizeof
(paren
id|fd
)paren
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|rx
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|fd
comma
r_sizeof
(paren
id|fd
)paren
)paren
suffix:semicolon
id|rbd.rbd_status
op_assign
l_int|0
suffix:semicolon
id|rbd.rbd_next_rbd_offset
op_assign
id|I82586NULL
suffix:semicolon
id|rbd.rbd_bufl
op_assign
id|rx
op_plus
r_sizeof
(paren
id|fd
)paren
op_plus
r_sizeof
(paren
id|rbd
)paren
suffix:semicolon
id|rbd.rbd_bufh
op_assign
l_int|0
suffix:semicolon
id|rbd.rbd_el_size
op_assign
id|RBD_EL
op_or
(paren
id|RBD_SIZE
op_amp
id|MAXDATAZ
)paren
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|rx
op_plus
r_sizeof
(paren
id|fd
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|rbd
comma
r_sizeof
(paren
id|rbd
)paren
)paren
suffix:semicolon
id|lp-&gt;rx_last
op_assign
id|rx
suffix:semicolon
)brace
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_rfa_offset
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|lp-&gt;rx_head
comma
r_sizeof
(paren
id|lp-&gt;rx_head
)paren
)paren
suffix:semicolon
id|scb_cs
op_assign
id|SCB_CMD_RUC_GO
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_cs
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_ru_start(): board not accepting command.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_ru_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Initialise the transmit blocks.&n; * Start the command unit executing the NOP&n; * self-loop of the first transmit block.&n; *&n; * Here we create the list of send buffers used to transmit packets&n; * between the PC and the command unit. For each buffer, we create a&n; * buffer descriptor (pointing on the buffer), a transmit command&n; * (pointing to the buffer descriptor) and a NOP command.&n; * The transmit command is linked to the NOP, and the NOP to itself.&n; * When we will have finished executing the transmit command, we will&n; * then loop on the NOP. By releasing the NOP link to a new command,&n; * we may send another buffer.&n; *&n; * (called by wv_hw_reset())&n; */
DECL|function|wv_cu_start
r_static
r_inline
r_int
id|wv_cu_start
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u16
id|txblock
suffix:semicolon
id|u16
id|first_nop
suffix:semicolon
id|u16
id|scb_cs
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_cu_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp-&gt;tx_first_free
op_assign
id|OFFSET_CU
suffix:semicolon
id|lp-&gt;tx_first_in_use
op_assign
id|I82586NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|txblock
op_assign
id|OFFSET_CU
suffix:semicolon
id|i
OL
id|NTXBLOCKS
suffix:semicolon
id|i
op_increment
comma
id|txblock
op_add_assign
id|TXBLOCKZ
)paren
(brace
id|ac_tx_t
id|tx
suffix:semicolon
id|ac_nop_t
id|nop
suffix:semicolon
id|tbd_t
id|tbd
suffix:semicolon
r_int
r_int
id|tx_addr
suffix:semicolon
r_int
r_int
id|nop_addr
suffix:semicolon
r_int
r_int
id|tbd_addr
suffix:semicolon
r_int
r_int
id|buf_addr
suffix:semicolon
id|tx_addr
op_assign
id|txblock
suffix:semicolon
id|nop_addr
op_assign
id|tx_addr
op_plus
r_sizeof
(paren
id|tx
)paren
suffix:semicolon
id|tbd_addr
op_assign
id|nop_addr
op_plus
r_sizeof
(paren
id|nop
)paren
suffix:semicolon
id|buf_addr
op_assign
id|tbd_addr
op_plus
r_sizeof
(paren
id|tbd
)paren
suffix:semicolon
id|tx.tx_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|tx.tx_h.ac_command
op_assign
id|acmd_transmit
op_or
id|AC_CFLD_I
suffix:semicolon
id|tx.tx_h.ac_link
op_assign
id|nop_addr
suffix:semicolon
id|tx.tx_tbd_offset
op_assign
id|tbd_addr
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|tx_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|tx
comma
r_sizeof
(paren
id|tx
)paren
)paren
suffix:semicolon
id|nop.nop_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|nop.nop_h.ac_command
op_assign
id|acmd_nop
suffix:semicolon
id|nop.nop_h.ac_link
op_assign
id|nop_addr
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|nop_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop
comma
r_sizeof
(paren
id|nop
)paren
)paren
suffix:semicolon
id|tbd.tbd_status
op_assign
id|TBD_STATUS_EOF
suffix:semicolon
id|tbd.tbd_next_bd_offset
op_assign
id|I82586NULL
suffix:semicolon
id|tbd.tbd_bufl
op_assign
id|buf_addr
suffix:semicolon
id|tbd.tbd_bufh
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|tbd_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|tbd
comma
r_sizeof
(paren
id|tbd
)paren
)paren
suffix:semicolon
)brace
id|first_nop
op_assign
id|OFFSET_CU
op_plus
(paren
id|NTXBLOCKS
op_minus
l_int|1
)paren
op_star
id|TXBLOCKZ
op_plus
r_sizeof
(paren
id|ac_tx_t
)paren
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_cbl_offset
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|first_nop
comma
r_sizeof
(paren
id|first_nop
)paren
)paren
suffix:semicolon
id|scb_cs
op_assign
id|SCB_CMD_CUC_GO
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cs
comma
r_sizeof
(paren
id|scb_cs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_cs
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_cu_start(): board not accepting command.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lp-&gt;tx_n_in_use
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_cu_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine does a standard configuration of the WaveLAN &n; * controller (i82586).&n; *&n; * It initialises the scp, iscp and scb structure&n; * The first two are just pointers to the next.&n; * The last one is used for basic configuration and for basic&n; * communication (interrupt status).&n; *&n; * (called by wv_hw_reset())&n; */
DECL|function|wv_82586_start
r_static
r_inline
r_int
id|wv_82586_start
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|scp_t
id|scp
suffix:semicolon
multiline_comment|/* system configuration pointer */
id|iscp_t
id|iscp
suffix:semicolon
multiline_comment|/* intermediate scp */
id|scb_t
id|scb
suffix:semicolon
multiline_comment|/* system control block */
id|ach_t
id|cb
suffix:semicolon
multiline_comment|/* Action command header */
id|u8
id|zeroes
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_82586_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Clear the onboard RAM.&n;&t; */
id|memset
c_func
(paren
op_amp
id|zeroes
(braket
l_int|0
)braket
comma
l_int|0x00
comma
r_sizeof
(paren
id|zeroes
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I82586_MEMZ
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|zeroes
)paren
)paren
id|obram_write
c_func
(paren
id|ioaddr
comma
id|i
comma
op_amp
id|zeroes
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|zeroes
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Construct the command unit structures:&n;&t; * scp, iscp, scb, cb.&n;&t; */
id|memset
c_func
(paren
op_amp
id|scp
comma
l_int|0x00
comma
r_sizeof
(paren
id|scp
)paren
)paren
suffix:semicolon
id|scp.scp_sysbus
op_assign
id|SCP_SY_16BBUS
suffix:semicolon
id|scp.scp_iscpl
op_assign
id|OFFSET_ISCP
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|OFFSET_SCP
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scp
comma
r_sizeof
(paren
id|scp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|iscp
comma
l_int|0x00
comma
r_sizeof
(paren
id|iscp
)paren
)paren
suffix:semicolon
id|iscp.iscp_busy
op_assign
l_int|1
suffix:semicolon
id|iscp.iscp_offset
op_assign
id|OFFSET_SCB
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|OFFSET_ISCP
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|iscp
comma
r_sizeof
(paren
id|iscp
)paren
)paren
suffix:semicolon
multiline_comment|/* Our first command is to reset the i82586. */
id|memset
c_func
(paren
op_amp
id|scb
comma
l_int|0x00
comma
r_sizeof
(paren
id|scb
)paren
)paren
suffix:semicolon
id|scb.scb_command
op_assign
id|SCB_CMD_RESET
suffix:semicolon
id|scb.scb_cbl_offset
op_assign
id|OFFSET_CU
suffix:semicolon
id|scb.scb_rfa_offset
op_assign
id|OFFSET_RU
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|OFFSET_SCB
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb
comma
r_sizeof
(paren
id|scb
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
multiline_comment|/* Wait for command to finish. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|OFFSET_ISCP
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|iscp
comma
r_sizeof
(paren
id|iscp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iscp.iscp_busy
op_eq
(paren
r_int
r_int
)paren
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_82586_start(): iscp_busy timeout.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check command completion. */
r_for
c_loop
(paren
id|i
op_assign
l_int|15
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|obram_read
c_func
(paren
id|ioaddr
comma
id|OFFSET_SCB
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb
comma
r_sizeof
(paren
id|scb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb.scb_status
op_eq
(paren
id|SCB_ST_CX
op_or
id|SCB_ST_CNA
)paren
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_82586_start(): status: expected 0x%02x, got 0x%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|SCB_ST_CX
op_or
id|SCB_ST_CNA
comma
id|scb.scb_status
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|wv_ack
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set the action command header. */
id|memset
c_func
(paren
op_amp
id|cb
comma
l_int|0x00
comma
r_sizeof
(paren
id|cb
)paren
)paren
suffix:semicolon
id|cb.ac_command
op_assign
id|AC_CFLD_EL
op_or
(paren
id|AC_CFLD_CMD
op_amp
id|acmd_diagnose
)paren
suffix:semicolon
id|cb.ac_link
op_assign
id|OFFSET_CU
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|OFFSET_CU
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|cb
comma
r_sizeof
(paren
id|cb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wv_synchronous_cmd
c_func
(paren
id|dev
comma
l_string|&quot;diag()&quot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|obram_read
c_func
(paren
id|ioaddr
comma
id|OFFSET_CU
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|cb
comma
r_sizeof
(paren
id|cb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb.ac_status
op_amp
id|AC_SFLD_FAIL
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_82586_start(): i82586 Self Test failed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_I82586_SHOW
id|wv_scb_show
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_82586_start()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine does a standard configuration of the WaveLAN&n; * controller (i82586).&n; *&n; * This routine is a violent hack. We use the first free transmit block&n; * to make our configuration. In the buffer area, we create the three&n; * configuration commands (linked). We make the previous NOP point to&n; * the beginning of the buffer instead of the tx command. After, we go&n; * as usual to the NOP command.&n; * Note that only the last command (mc_set) will generate an interrupt.&n; *&n; * (called by wv_hw_reset(), wv_82586_reconfig(), wavelan_packet_xmit())&n; */
DECL|function|wv_82586_config
r_static
r_void
id|wv_82586_config
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|txblock
suffix:semicolon
r_int
r_int
id|txpred
suffix:semicolon
r_int
r_int
id|tx_addr
suffix:semicolon
r_int
r_int
id|nop_addr
suffix:semicolon
r_int
r_int
id|tbd_addr
suffix:semicolon
r_int
r_int
id|cfg_addr
suffix:semicolon
r_int
r_int
id|ias_addr
suffix:semicolon
r_int
r_int
id|mcs_addr
suffix:semicolon
id|ac_tx_t
id|tx
suffix:semicolon
id|ac_nop_t
id|nop
suffix:semicolon
id|ac_cfg_t
id|cfg
suffix:semicolon
multiline_comment|/* Configure action */
id|ac_ias_t
id|ias
suffix:semicolon
multiline_comment|/* IA-setup action */
id|ac_mcs_t
id|mcs
suffix:semicolon
multiline_comment|/* Multicast setup */
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_82586_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check nothing bad has happened */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
op_eq
(paren
id|NTXBLOCKS
op_minus
l_int|1
)paren
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wv_82586_config(): Tx queue full.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* Calculate addresses of next block and previous block. */
id|txblock
op_assign
id|lp-&gt;tx_first_free
suffix:semicolon
id|txpred
op_assign
id|txblock
op_minus
id|TXBLOCKZ
suffix:semicolon
r_if
c_cond
(paren
id|txpred
OL
id|OFFSET_CU
)paren
id|txpred
op_add_assign
id|NTXBLOCKS
op_star
id|TXBLOCKZ
suffix:semicolon
id|lp-&gt;tx_first_free
op_add_assign
id|TXBLOCKZ
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_first_free
op_ge
id|OFFSET_CU
op_plus
id|NTXBLOCKS
op_star
id|TXBLOCKZ
)paren
id|lp-&gt;tx_first_free
op_sub_assign
id|NTXBLOCKS
op_star
id|TXBLOCKZ
suffix:semicolon
id|lp-&gt;tx_n_in_use
op_increment
suffix:semicolon
multiline_comment|/* Calculate addresses of the different parts of the block. */
id|tx_addr
op_assign
id|txblock
suffix:semicolon
id|nop_addr
op_assign
id|tx_addr
op_plus
r_sizeof
(paren
id|tx
)paren
suffix:semicolon
id|tbd_addr
op_assign
id|nop_addr
op_plus
r_sizeof
(paren
id|nop
)paren
suffix:semicolon
id|cfg_addr
op_assign
id|tbd_addr
op_plus
r_sizeof
(paren
id|tbd_t
)paren
suffix:semicolon
multiline_comment|/* beginning of the buffer */
id|ias_addr
op_assign
id|cfg_addr
op_plus
r_sizeof
(paren
id|cfg
)paren
suffix:semicolon
id|mcs_addr
op_assign
id|ias_addr
op_plus
r_sizeof
(paren
id|ias
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Transmit command&n;&t; */
id|tx.tx_h.ac_status
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* Fake completion value */
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_tx_t
comma
id|tx_addr
comma
id|tx_h.ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|tx.tx_h.ac_status
comma
r_sizeof
(paren
id|tx.tx_h.ac_status
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOP command&n;&t; */
id|nop.nop_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_status
comma
r_sizeof
(paren
id|nop.nop_h.ac_status
)paren
)paren
suffix:semicolon
id|nop.nop_h.ac_link
op_assign
id|nop_addr
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_link
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_link
comma
r_sizeof
(paren
id|nop.nop_h.ac_link
)paren
)paren
suffix:semicolon
multiline_comment|/* Create a configure action. */
id|memset
c_func
(paren
op_amp
id|cfg
comma
l_int|0x00
comma
r_sizeof
(paren
id|cfg
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For Linux we invert AC_CFG_ALOC() so as to conform&n;&t; * to the way that net packets reach us from above.&n;&t; * (See also ac_tx_t.)&n;&t; *&n;&t; * Updated from Wavelan Manual WCIN085B&n;&t; */
id|cfg.cfg_byte_cnt
op_assign
id|AC_CFG_BYTE_CNT
c_func
(paren
r_sizeof
(paren
id|ac_cfg_t
)paren
op_minus
r_sizeof
(paren
id|ach_t
)paren
)paren
suffix:semicolon
id|cfg.cfg_fifolim
op_assign
id|AC_CFG_FIFOLIM
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|cfg.cfg_byte8
op_assign
id|AC_CFG_SAV_BF
c_func
(paren
l_int|1
)paren
op_or
id|AC_CFG_SRDY
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cfg.cfg_byte9
op_assign
id|AC_CFG_ELPBCK
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_ILPBCK
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_PRELEN
c_func
(paren
id|AC_CFG_PLEN_2
)paren
op_or
id|AC_CFG_ALOC
c_func
(paren
l_int|1
)paren
op_or
id|AC_CFG_ADDRLEN
c_func
(paren
id|WAVELAN_ADDR_SIZE
)paren
suffix:semicolon
id|cfg.cfg_byte10
op_assign
id|AC_CFG_BOFMET
c_func
(paren
l_int|1
)paren
op_or
id|AC_CFG_ACR
c_func
(paren
l_int|6
)paren
op_or
id|AC_CFG_LINPRIO
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cfg.cfg_ifs
op_assign
l_int|0x20
suffix:semicolon
id|cfg.cfg_slotl
op_assign
l_int|0x0C
suffix:semicolon
id|cfg.cfg_byte13
op_assign
id|AC_CFG_RETRYNUM
c_func
(paren
l_int|15
)paren
op_or
id|AC_CFG_SLTTMHI
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cfg.cfg_byte14
op_assign
id|AC_CFG_FLGPAD
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_BTSTF
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_CRC16
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_NCRC
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_TNCRS
c_func
(paren
l_int|1
)paren
op_or
id|AC_CFG_MANCH
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_BCDIS
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_PRM
c_func
(paren
id|lp-&gt;promiscuous
)paren
suffix:semicolon
id|cfg.cfg_byte15
op_assign
id|AC_CFG_ICDS
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_CDTF
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_ICSS
c_func
(paren
l_int|0
)paren
op_or
id|AC_CFG_CSTF
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;  cfg.cfg_min_frm_len = AC_CFG_MNFRM(64);&n;*/
id|cfg.cfg_min_frm_len
op_assign
id|AC_CFG_MNFRM
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|cfg.cfg_h.ac_command
op_assign
(paren
id|AC_CFLD_CMD
op_amp
id|acmd_configure
)paren
suffix:semicolon
id|cfg.cfg_h.ac_link
op_assign
id|ias_addr
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|cfg_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|cfg
comma
r_sizeof
(paren
id|cfg
)paren
)paren
suffix:semicolon
multiline_comment|/* Set up the MAC address */
id|memset
c_func
(paren
op_amp
id|ias
comma
l_int|0x00
comma
r_sizeof
(paren
id|ias
)paren
)paren
suffix:semicolon
id|ias.ias_h.ac_command
op_assign
(paren
id|AC_CFLD_CMD
op_amp
id|acmd_ia_setup
)paren
suffix:semicolon
id|ias.ias_h.ac_link
op_assign
id|mcs_addr
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ias.ias_addr
(braket
l_int|0
)braket
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|ias.ias_addr
)paren
)paren
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|ias_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|ias
comma
r_sizeof
(paren
id|ias
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize adapter&squot;s Ethernet multicast addresses */
id|memset
c_func
(paren
op_amp
id|mcs
comma
l_int|0x00
comma
r_sizeof
(paren
id|mcs
)paren
)paren
suffix:semicolon
id|mcs.mcs_h.ac_command
op_assign
id|AC_CFLD_I
op_or
(paren
id|AC_CFLD_CMD
op_amp
id|acmd_mc_setup
)paren
suffix:semicolon
id|mcs.mcs_h.ac_link
op_assign
id|nop_addr
suffix:semicolon
id|mcs.mcs_cnt
op_assign
id|WAVELAN_ADDR_SIZE
op_star
id|lp-&gt;mc_count
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|mcs_addr
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|mcs
comma
r_sizeof
(paren
id|mcs
)paren
)paren
suffix:semicolon
multiline_comment|/* Any address to set? */
r_if
c_cond
(paren
id|lp-&gt;mc_count
)paren
(brace
r_for
c_loop
(paren
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|outsw
c_func
(paren
id|PIOP1
c_func
(paren
id|ioaddr
)paren
comma
(paren
id|u16
op_star
)paren
id|dmi-&gt;dmi_addr
comma
id|WAVELAN_ADDR_SIZE
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wv_82586_config(): set %d multicast addresses:&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;mc_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|1
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|2
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|3
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|4
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Overwrite the predecessor NOP link&n;&t; * so that it points to the configure action.&n;&t; */
id|nop_addr
op_assign
id|txpred
op_plus
r_sizeof
(paren
id|tx
)paren
suffix:semicolon
id|nop.nop_h.ac_status
op_assign
l_int|0
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_status
comma
r_sizeof
(paren
id|nop.nop_h.ac_status
)paren
)paren
suffix:semicolon
id|nop.nop_h.ac_link
op_assign
id|cfg_addr
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|toff
c_func
(paren
id|ac_nop_t
comma
id|nop_addr
comma
id|nop_h.ac_link
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|nop.nop_h.ac_link
comma
r_sizeof
(paren
id|nop.nop_h.ac_link
)paren
)paren
suffix:semicolon
multiline_comment|/* Job done, clear the flag */
id|lp-&gt;reconfig_82586
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_first_in_use
op_eq
id|I82586NULL
)paren
id|lp-&gt;tx_first_in_use
op_assign
id|txblock
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
op_eq
(paren
id|NTXBLOCKS
op_minus
l_int|1
)paren
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_82586_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine, called by wavelan_close(), gracefully stops the &n; * WaveLAN controller (i82586).&n; * (called by wavelan_close())&n; */
DECL|function|wv_82586_stop
r_static
r_inline
r_void
id|wv_82586_stop
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|scb_cmd
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_82586_stop()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Suspend both command unit and receive unit. */
id|scb_cmd
op_assign
(paren
id|SCB_CMD_CUC
op_amp
id|SCB_CMD_CUC_SUS
)paren
op_or
(paren
id|SCB_CMD_RUC
op_amp
id|SCB_CMD_RUC_SUS
)paren
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb_cmd
comma
r_sizeof
(paren
id|scb_cmd
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
multiline_comment|/* No more interrupts */
id|wv_ints_off
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_82586_stop()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Totally reset the WaveLAN and restart it.&n; * Performs the following actions:&n; *&t;1. A power reset (reset DMA)&n; *&t;2. Initialize the radio modem (using wv_mmc_init)&n; *&t;3. Reset &amp; Configure LAN controller (using wv_82586_start)&n; *&t;4. Start the LAN controller&squot;s command unit&n; *&t;5. Start the LAN controller&squot;s receive unit&n; * (called by wavelan_interrupt(), wavelan_watchdog() &amp; wavelan_open())&n; */
DECL|function|wv_hw_reset
r_static
r_int
id|wv_hw_reset
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wv_hw_reset(dev=0x%x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Increase the number of resets done. */
id|lp-&gt;nresets
op_increment
suffix:semicolon
id|wv_hacr_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;hacr
op_assign
id|HACR_DEFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wv_mmc_init
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|wv_82586_start
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Enable the card to send interrupts. */
id|wv_ints_on
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Start card functions */
r_if
c_cond
(paren
id|wv_cu_start
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Setup the controller and parameters */
id|wv_82586_config
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Finish configuration with the receive unit */
r_if
c_cond
(paren
id|wv_ru_start
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wv_hw_reset()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Check if there is a WaveLAN at the specific base address.&n; * As a side effect, this reads the MAC address.&n; * (called in wavelan_probe() and init_module())&n; */
DECL|function|wv_check_ioaddr
r_static
r_int
id|wv_check_ioaddr
c_func
(paren
r_int
r_int
id|ioaddr
comma
id|u8
op_star
id|mac
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Loop counter */
multiline_comment|/* Check if the base address if available. */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
r_sizeof
(paren
id|ha_t
)paren
)paren
)paren
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
multiline_comment|/* ioaddr already used */
multiline_comment|/* Reset host interface */
id|wv_hacr_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Read the MAC address from the parameter storage area. */
id|psa_read
c_func
(paren
id|ioaddr
comma
id|HACR_DEFAULT
comma
id|psaoff
c_func
(paren
l_int|0
comma
id|psa_univ_mac_addr
)paren
comma
id|mac
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check the first three octets of the address for the manufacturer&squot;s code.&n;&t; * Note: if this can&squot;t find your WaveLAN card, you&squot;ve got a&n;&t; * non-NCR/AT&amp;T/Lucent ISA card.  See wavelan.p.h for detail on&n;&t; * how to configure your card.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|MAC_ADDRESSES
)paren
op_div
r_sizeof
(paren
r_char
)paren
op_div
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|mac
(braket
l_int|0
)braket
op_eq
id|MAC_ADDRESSES
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
id|mac
(braket
l_int|1
)braket
op_eq
id|MAC_ADDRESSES
(braket
id|i
)braket
(braket
l_int|1
)braket
)paren
op_logical_and
(paren
id|mac
(braket
l_int|2
)braket
op_eq
id|MAC_ADDRESSES
(braket
id|i
)braket
(braket
l_int|2
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WaveLAN (0x%3X): your MAC address might be %02X:%02X:%02X.&bslash;n&quot;
comma
id|ioaddr
comma
id|mac
(braket
l_int|0
)braket
comma
id|mac
(braket
l_int|1
)braket
comma
id|mac
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/************************ INTERRUPT HANDLING ************************/
multiline_comment|/*&n; * This function is the interrupt handler for the WaveLAN card. This&n; * routine will be called whenever: &n; */
DECL|function|wavelan_interrupt
r_static
r_void
id|wavelan_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|ioaddr
suffix:semicolon
id|net_local
op_star
id|lp
suffix:semicolon
id|u16
id|hasr
suffix:semicolon
id|u16
id|status
suffix:semicolon
id|u16
id|ack_cmd
suffix:semicolon
id|dev
op_assign
id|dev_id
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_interrupt()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_INFO
multiline_comment|/* Check state of our spinlock */
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|lp-&gt;spinlock
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_interrupt(): spinlock is already locked !!!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Prevent reentrancy. We need to do that because we may have&n;&t; * multiple interrupt handler running concurrently.&n;&t; * It is safe because wv_splhi() disables interrupts before acquiring&n;&t; * the spinlock. */
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* Check modem interupt */
r_if
c_cond
(paren
(paren
id|hasr
op_assign
id|hasr_read
c_func
(paren
id|ioaddr
)paren
)paren
op_amp
id|HASR_MMC_INTR
)paren
(brace
id|u8
id|dce_status
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Interrupt from the modem management controller.&n;&t;&t; * This will clear it -- ignored for now.&n;&t;&t; */
id|mmc_read
c_func
(paren
id|ioaddr
comma
id|mmroff
c_func
(paren
l_int|0
comma
id|mmr_dce_status
)paren
comma
op_amp
id|dce_status
comma
r_sizeof
(paren
id|dce_status
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_interrupt(): unexpected mmc interrupt: status 0x%04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dce_status
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Check if not controller interrupt */
r_if
c_cond
(paren
(paren
id|hasr
op_amp
id|HASR_82586_INTR
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_interrupt(): interrupt not coming from i82586&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
(paren
op_amp
id|lp-&gt;spinlock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read interrupt data. */
id|obram_read
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_status
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|status
comma
r_sizeof
(paren
id|status
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Acknowledge the interrupt(s).&n;&t; */
id|ack_cmd
op_assign
id|status
op_amp
id|SCB_ST_INT
suffix:semicolon
id|obram_write
c_func
(paren
id|ioaddr
comma
id|scboff
c_func
(paren
id|OFFSET_SCB
comma
id|scb_command
)paren
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|ack_cmd
comma
r_sizeof
(paren
id|ack_cmd
)paren
)paren
suffix:semicolon
id|set_chan_attn
c_func
(paren
id|ioaddr
comma
id|lp-&gt;hacr
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_interrupt(): status 0x%04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Command completed. */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCB_ST_CX
)paren
op_eq
id|SCB_ST_CX
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_interrupt(): command completed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_complete
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp
)paren
suffix:semicolon
)brace
multiline_comment|/* Frame received. */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCB_ST_FR
)paren
op_eq
id|SCB_ST_FR
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_interrupt(): received packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Check the state of the command unit. */
r_if
c_cond
(paren
(paren
(paren
id|status
op_amp
id|SCB_ST_CNA
)paren
op_eq
id|SCB_ST_CNA
)paren
op_logical_or
(paren
(paren
(paren
id|status
op_amp
id|SCB_ST_CUS
)paren
op_ne
id|SCB_ST_CUS_ACTV
)paren
op_logical_and
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_interrupt(): CU inactive -- restarting&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_hw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Check the state of the command unit. */
r_if
c_cond
(paren
(paren
(paren
id|status
op_amp
id|SCB_ST_RNR
)paren
op_eq
id|SCB_ST_RNR
)paren
op_logical_or
(paren
(paren
(paren
id|status
op_amp
id|SCB_ST_RUS
)paren
op_ne
id|SCB_ST_RUS_RDY
)paren
op_logical_and
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_interrupt(): RU not ready -- restarting&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_hw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Release spinlock */
id|spin_unlock
(paren
op_amp
id|lp-&gt;spinlock
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_interrupt()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Watchdog: when we start a transmission, a timer is set for us in the&n; * kernel.  If the transmission completes, this timer is disabled. If&n; * the timer expires, we are called and we try to unlock the hardware.&n; */
DECL|function|wavelan_watchdog
r_static
r_void
id|wavelan_watchdog
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|nreaped
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_watchdog()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_watchdog: watchdog timer expired&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check that we came here for something */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
op_le
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/* Try to see if some buffers are not free (in case we missed&n;&t; * an interrupt */
id|nreaped
op_assign
id|wv_complete
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|lp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_watchdog(): %d reaped, %d remain.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|nreaped
comma
id|lp-&gt;tx_n_in_use
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_PSA_SHOW
(brace
id|psa_t
id|psa
suffix:semicolon
id|psa_read
c_func
(paren
id|dev
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|psa
comma
r_sizeof
(paren
id|psa
)paren
)paren
suffix:semicolon
id|wv_psa_show
c_func
(paren
op_amp
id|psa
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DEBUG_MMC_SHOW
id|wv_mmc_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_I82586_SHOW
id|wv_cu_show
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If no buffer has been freed */
r_if
c_cond
(paren
id|nreaped
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_INTERRUPT_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_watchdog(): cleanup failed, trying reset&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_hw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* At this point, we should have some free Tx buffer ;-) */
r_if
c_cond
(paren
id|lp-&gt;tx_n_in_use
OL
id|NTXBLOCKS
op_minus
l_int|1
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPT_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_watchdog()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/********************* CONFIGURATION CALLBACKS *********************/
multiline_comment|/*&n; * Here are the functions called by the Linux networking code (NET3)&n; * for initialization, configuration and deinstallations of the &n; * WaveLAN ISA hardware.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Configure and start up the WaveLAN PCMCIA adaptor.&n; * Called by NET3 when it &quot;opens&quot; the device.&n; */
DECL|function|wavelan_open
r_static
r_int
id|wavelan_open
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_open(dev=0x%x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check irq */
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wavelan_open(): no IRQ&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|wavelan_interrupt
comma
l_int|0
comma
l_string|&quot;WaveLAN&quot;
comma
id|dev
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wavelan_open(): invalid IRQ&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wv_hw_reset
c_func
(paren
id|dev
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_open(): impossible to start the card&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_open()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Shut down the WaveLAN ISA card.&n; * Called by NET3 when it &quot;closes&quot; the device.&n; */
DECL|function|wavelan_close
r_static
r_int
id|wavelan_close
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
id|net_local
op_star
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_close(dev=0x%x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush the Tx and disable Rx.&n;&t; */
id|wv_splhi
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|wv_82586_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wv_splx
c_func
(paren
id|lp
comma
op_amp
id|flags
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_close()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Probe an I/O address, and if the WaveLAN is there configure the&n; * device structure&n; * (called by wavelan_probe() and via init_module()).&n; */
DECL|function|wavelan_config
r_static
r_int
id|__init
id|wavelan_config
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u8
id|irq_mask
suffix:semicolon
r_int
id|irq
suffix:semicolon
id|net_local
op_star
id|lp
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_config(dev=0x%x, ioaddr=0x%lx)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
comma
id|ioaddr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check IRQ argument on command line. */
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
(brace
id|irq_mask
op_assign
id|wv_irq_to_psa
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_mask
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wavelan_config(): invalid IRQ %d ignored.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_config(): changing IRQ to %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
id|psa_write
c_func
(paren
id|ioaddr
comma
id|HACR_DEFAULT
comma
id|psaoff
c_func
(paren
l_int|0
comma
id|psa_int_req_no
)paren
comma
op_amp
id|irq_mask
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the Wavelan checksum */
id|update_psa_checksum
c_func
(paren
id|dev
comma
id|ioaddr
comma
id|HACR_DEFAULT
)paren
suffix:semicolon
id|wv_hacr_reset
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
)brace
)brace
id|psa_read
c_func
(paren
id|ioaddr
comma
id|HACR_DEFAULT
comma
id|psaoff
c_func
(paren
l_int|0
comma
id|psa_int_req_no
)paren
comma
op_amp
id|irq_mask
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_assign
id|wv_psa_to_irq
c_func
(paren
id|irq_mask
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wavelan_config(): could not wavelan_map_irq(%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|irq_mask
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|request_region
c_func
(paren
id|ioaddr
comma
r_sizeof
(paren
id|ha_t
)paren
comma
l_string|&quot;wavelan&quot;
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0x0000
suffix:semicolon
id|dev-&gt;mem_end
op_assign
l_int|0x0000
suffix:semicolon
id|dev-&gt;if_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize device structures */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0x00
comma
r_sizeof
(paren
id|net_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Back link to the device structure. */
id|lp-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Add the device at the beginning of the linked list. */
id|lp-&gt;next
op_assign
id|wavelan_list
suffix:semicolon
id|wavelan_list
op_assign
id|lp
suffix:semicolon
id|lp-&gt;hacr
op_assign
id|HACR_DEFAULT
suffix:semicolon
multiline_comment|/* Multicast stuff */
id|lp-&gt;promiscuous
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Init spinlock */
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the fields of the device structure&n;&t; * with generic Ethernet values.&n;&t; */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|wavelan_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|wavelan_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|wavelan_packet_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|wavelan_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|wavelan_set_multicast_list
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
op_amp
id|wavelan_watchdog
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|WATCHDOG_JIFFIES
suffix:semicolon
macro_line|#ifdef SET_MAC_ADDRESS
id|dev-&gt;set_mac_address
op_assign
op_amp
id|wavelan_set_mac_address
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* SET_MAC_ADDRESS */
macro_line|#ifdef WIRELESS_EXT&t;&t;/* if wireless extension exists in the kernel */
id|dev-&gt;do_ioctl
op_assign
id|wavelan_ioctl
suffix:semicolon
id|dev-&gt;get_wireless_stats
op_assign
id|wavelan_get_wireless_stats
suffix:semicolon
macro_line|#endif
id|dev-&gt;mtu
op_assign
id|WAVELAN_MTU
suffix:semicolon
multiline_comment|/* Display nice information. */
id|wv_init_info
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_config()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Check for a network adaptor of this type.  Return &squot;0&squot; iff one &n; * exists.  There seem to be different interpretations of&n; * the initial value of dev-&gt;base_addr.&n; * We follow the example in drivers/net/ne.c.&n; * (called in &quot;Space.c&quot;)&n; */
DECL|function|wavelan_probe
r_int
id|__init
id|wavelan_probe
c_func
(paren
id|device
op_star
id|dev
)paren
(brace
r_int
id|base_addr
suffix:semicolon
id|mac_addr
id|mac
suffix:semicolon
multiline_comment|/* MAC address (check existence of WaveLAN) */
r_int
id|i
suffix:semicolon
r_int
id|r
suffix:semicolon
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: -&gt;wavelan_probe(dev=0x%x (base_addr=0x%x))&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
comma
(paren
r_int
r_int
)paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;STRUCT_CHECK
r_if
c_cond
(paren
id|wv_struct_check
c_func
(paren
)paren
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wavelan_probe(): structure/compiler botch: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|wv_struct_check
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* STRUCT_CHECK */
multiline_comment|/* Check the value of the command line parameter for base address. */
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* Don&squot;t probe at all. */
r_if
c_cond
(paren
id|base_addr
OL
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wavelan_probe(): invalid base address&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Check a single specified location. */
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x100
)paren
(brace
multiline_comment|/* Check if there is something at this base address */
r_if
c_cond
(paren
(paren
id|r
op_assign
id|wv_check_ioaddr
c_func
(paren
id|base_addr
comma
id|mac
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|mac
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Copy MAC address. */
id|r
op_assign
id|wavelan_config
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CONFIG_INFO
r_if
c_cond
(paren
id|r
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_probe(): no device at specified base address (0x%X) or address already in use&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|base_addr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_probe()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* Scan all possible addresses of the WaveLAN hardware. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NELS
c_func
(paren
id|iobase
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Check whether there is something at this base address. */
r_if
c_cond
(paren
id|wv_check_ioaddr
c_func
(paren
id|iobase
(braket
id|i
)braket
comma
id|mac
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;base_addr
op_assign
id|iobase
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Copy base address. */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|mac
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Copy MAC address. */
r_if
c_cond
(paren
id|wavelan_config
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CALLBACK_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: &lt;-wavelan_probe()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* We may have touched base_addr.  Another driver may not like it. */
id|dev-&gt;base_addr
op_assign
id|base_addr
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: wavelan_probe(): no device found&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/****************************** MODULE ******************************/
multiline_comment|/*&n; * Module entry point: insertion and removal&n; */
macro_line|#ifdef&t;MODULE
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Insertion of the module&n; * I&squot;m now quite proud of the multi-device support.&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|mac_addr
id|mac
suffix:semicolon
multiline_comment|/* MAC address (check WaveLAN existence) */
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Return error if no cards found */
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; init_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If probing is asked */
r_if
c_cond
(paren
id|io
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CONFIG_ERROR
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WaveLAN init_module(): doing device probing (bad !)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Specify base addresses while loading module to correct the problem&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Copy the basic set of address to be probed. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NELS
c_func
(paren
id|iobase
)paren
suffix:semicolon
id|i
op_increment
)paren
id|io
(braket
id|i
)braket
op_assign
id|iobase
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Loop on all possible base addresses. */
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|io
(braket
op_increment
id|i
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
OL
id|NELS
c_func
(paren
id|io
)paren
)paren
)paren
(brace
multiline_comment|/* Check if there is something at this base address. */
r_if
c_cond
(paren
id|wv_check_ioaddr
c_func
(paren
id|io
(braket
id|i
)braket
comma
id|mac
)paren
op_eq
l_int|0
)paren
(brace
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Create device and set basic arguments. */
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;name
comma
id|name
(braket
id|i
)braket
comma
id|IFNAMSIZ
)paren
suffix:semicolon
multiline_comment|/* Copy name */
id|dev-&gt;base_addr
op_assign
id|io
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;init
op_assign
op_amp
id|wavelan_config
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|mac
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Copy MAC address. */
multiline_comment|/* Try to create the device. */
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Deallocate everything. */
multiline_comment|/* Note: if dev-&gt;priv is mallocated, there is no way to fail. */
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If at least one device OK, we do not fail */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* if there is something at the address */
)brace
multiline_comment|/* Loop on all addresses. */
macro_line|#ifdef DEBUG_CONFIG_ERROR
r_if
c_cond
(paren
id|wavelan_list
op_eq
(paren
id|net_local
op_star
)paren
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WaveLAN init_module(): no device found&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- init_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Removal of the module&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;-&gt; cleanup_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Loop on all devices and release them. */
r_while
c_loop
(paren
id|wavelan_list
op_ne
(paren
id|net_local
op_star
)paren
l_int|NULL
)paren
(brace
id|device
op_star
id|dev
op_assign
id|wavelan_list-&gt;dev
suffix:semicolon
macro_line|#ifdef DEBUG_CONFIG_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: cleanup_module(): removing device at 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Release the ioport region. */
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
r_sizeof
(paren
id|ha_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Definitely remove the device. */
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unlink the device. */
id|wavelan_list
op_assign
id|wavelan_list-&gt;next
suffix:semicolon
multiline_comment|/* Free pieces. */
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MODULE_TRACE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&lt;- cleanup_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
multiline_comment|/*&n; * This software may only be used and distributed&n; * according to the terms of the GNU Public License.&n; *&n; * This software was developed as a component of the&n; * Linux operating system.&n; * It is based on other device drivers and information&n; * either written or supplied by:&n; *&t;Ajay Bakre (bakre@paul.rutgers.edu),&n; *&t;Donald Becker (becker@cesdis.gsfc.nasa.gov),&n; *&t;Loeke Brederveld (Loeke.Brederveld@Utrecht.NCR.com),&n; *&t;Anders Klemets (klemets@it.kth.se),&n; *&t;Vladimir V. Kolpakov (w@stier.koenig.ru),&n; *&t;Marc Meertens (Marc.Meertens@Utrecht.NCR.com),&n; *&t;Pauline Middelink (middelin@polyware.iaf.nl),&n; *&t;Robert Morris (rtm@das.harvard.edu),&n; *&t;Jean Tourrilhes (jt@hplb.hpl.hp.com),&n; *&t;Girish Welling (welling@paul.rutgers.edu),&n; *&n; * Thanks go also to:&n; *&t;James Ashton (jaa101@syseng.anu.edu.au),&n; *&t;Alan Cox (alan@redhat.com),&n; *&t;Allan Creighton (allanc@cs.usyd.edu.au),&n; *&t;Matthew Geier (matthew@cs.usyd.edu.au),&n; *&t;Remo di Giovanni (remo@cs.usyd.edu.au),&n; *&t;Eckhard Grah (grah@wrcs1.urz.uni-wuppertal.de),&n; *&t;Vipul Gupta (vgupta@cs.binghamton.edu),&n; *&t;Mark Hagan (mhagan@wtcpost.daytonoh.NCR.COM),&n; *&t;Tim Nicholson (tim@cs.usyd.edu.au),&n; *&t;Ian Parkin (ian@cs.usyd.edu.au),&n; *&t;John Rosenberg (johnr@cs.usyd.edu.au),&n; *&t;George Rossi (george@phm.gov.au),&n; *&t;Arthur Scott (arthur@cs.usyd.edu.au),&n; *&t;Peter Storey,&n; * for their assistance and advice.&n; *&n; * Please send bug reports, updates, comments to:&n; *&n; * Bruce Janson                                    Email:  bruce@cs.usyd.edu.au&n; * Basser Department of Computer Science           Phone:  +61-2-9351-3423&n; * University of Sydney, N.S.W., 2006, AUSTRALIA   Fax:    +61-2-9351-3838&n; */
eof
