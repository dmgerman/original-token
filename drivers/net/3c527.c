multiline_comment|/* 3c527.c: 3Com Etherlink/MC32 driver for Linux&n; *&n; *&t;(c) Copyright 1998 Red Hat Software Inc&n; *&t;Written by Alan Cox.&n; *&t;Further debugging by Carl Drougge.&n; *&n; *&t;Based on skeleton.c written 1993-94 by Donald Becker and ne2.c&n; *&t;(for the MCA stuff) written by Wim Dumon.&n; *&n; *&t;Thanks to 3Com for making this possible by providing me with the&n; *&t;documentation.&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU Public License, incorporated herein by reference.&n; *&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;3c527.c:v0.08 2000/02/22 Alan Cox (alan@redhat.com)&bslash;n&quot;
suffix:semicolon
multiline_comment|/**&n; * DOC: Traps for the unwary&n; *&n; *&t;The diagram (Figure 1-1) and the POS summary disagree with the&n; *&t;&quot;Interrupt Level&quot; section in the manual.&n; *&n; *&t;The documentation in places seems to miss things. In actual fact&n; *&t;I&squot;ve always eventually found everything is documented, it just&n; *&t;requires careful study.&n; *&n; * DOC: Theory Of Operation&n; *&n; *&t;The 3com 3c527 is a 32bit MCA bus mastering adapter with a large&n; *&t;amount of on board intelligence that housekeeps a somewhat dumber&n; *&t;Intel NIC. For performance we want to keep the transmit queue deep&n; *&t;as the card can transmit packets while fetching others from main&n; *&t;memory by bus master DMA. Transmission and reception are driven by&n; *&t;ring buffers. When updating the ring we are required to do some&n; *&t;housekeeping work using the mailboxes and the command register.&n; *&n; *&t;The mailboxes provide a method for sending control requests to the&n; *&t;card. The transmit mail box is used to update the transmit ring &n; *&t;pointers and the receive mail box to update the receive ring&n; *&t;pointers. The exec mailbox allows a variety of commands to be&n; *&t;executed. Each command must complete before the next is executed.&n; *&t;Primarily we use the exec mailbox for controlling the multicast lists.&n; *&t;We have to do a certain amount of interesting hoop jumping as the &n; *&t;multicast list changes can occur in interrupt state when the card&n; *&t;has an exec command pending. We defer such events until the command&n; *&t;completion interrupt.&n; *&n; *&t;The control register is used to pass status information. It tells us&n; *&t;the transmit and receive status for packets and allows us to control&n; *&t;the card operation mode. You must stop the card when emptying the&n; *&t;receive ring, or you will race with the ring buffer and lose packets.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;3c527.h&quot;
multiline_comment|/*&n; * The name of the card. Is used for messages and in the requests for&n; * io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;3c527&quot;
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
DECL|variable|mc32_debug
r_static
r_int
r_int
id|mc32_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|NETCARD_IO_EXTENT
mdefine_line|#define NETCARD_IO_EXTENT&t;8
DECL|struct|mc32_mailbox
r_struct
id|mc32_mailbox
(brace
id|u16
id|mbox
id|__attribute
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
id|u16
id|data
(braket
l_int|1
)braket
id|__attribute
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|macro|TX_RING_MAX
mdefine_line|#define TX_RING_MAX&t;16&t;/* Typically the card supports 37 */
DECL|macro|RX_RING_MAX
mdefine_line|#define RX_RING_MAX&t;32&t;/*        &quot;     &quot;       &quot;         */
DECL|struct|mc32_local
r_struct
id|mc32_local
(brace
DECL|member|net_stats
r_struct
id|net_device_stats
id|net_stats
suffix:semicolon
DECL|member|slot
r_int
id|slot
suffix:semicolon
DECL|member|rx_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|rx_box
suffix:semicolon
DECL|member|tx_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|tx_box
suffix:semicolon
DECL|member|exec_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|exec_box
suffix:semicolon
DECL|member|stats
r_volatile
id|u16
op_star
id|stats
suffix:semicolon
DECL|member|tx_chain
id|u16
id|tx_chain
suffix:semicolon
DECL|member|rx_chain
id|u16
id|rx_chain
suffix:semicolon
DECL|member|tx_len
id|u16
id|tx_len
suffix:semicolon
DECL|member|rx_len
id|u16
id|rx_len
suffix:semicolon
DECL|member|base
id|u32
id|base
suffix:semicolon
DECL|member|rx_halted
id|u16
id|rx_halted
suffix:semicolon
DECL|member|tx_halted
id|u16
id|tx_halted
suffix:semicolon
DECL|member|rx_pending
id|u16
id|rx_pending
suffix:semicolon
DECL|member|exec_pending
id|u16
id|exec_pending
suffix:semicolon
DECL|member|mc_reload_wait
id|u16
id|mc_reload_wait
suffix:semicolon
multiline_comment|/* a multicast load request is pending */
DECL|member|tx_count
id|atomic_t
id|tx_count
suffix:semicolon
multiline_comment|/* buffers left */
DECL|member|event
id|wait_queue_head_t
id|event
suffix:semicolon
DECL|member|tx_skb
r_struct
id|sk_buff
op_star
id|tx_skb
(braket
id|TX_RING_MAX
)braket
suffix:semicolon
multiline_comment|/* Transmit ring */
DECL|member|tx_skb_top
id|u16
id|tx_skb_top
suffix:semicolon
DECL|member|tx_skb_end
id|u16
id|tx_skb_end
suffix:semicolon
DECL|member|rx_skb
r_struct
id|sk_buff
op_star
id|rx_skb
(braket
id|RX_RING_MAX
)braket
suffix:semicolon
multiline_comment|/* Receive ring */
DECL|member|rx_ptr
r_void
op_star
id|rx_ptr
(braket
id|RX_RING_MAX
)braket
suffix:semicolon
multiline_comment|/* Data pointers */
DECL|member|mc_list_valid
id|u32
id|mc_list_valid
suffix:semicolon
multiline_comment|/* True when the mclist is set */
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for a sanity check. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x02
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0x60
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0xAC
DECL|struct|mca_adapters_t
r_struct
id|mca_adapters_t
(brace
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|mca_adapters_t
id|mc32_adapters
(braket
)braket
id|__initdata
op_assign
(brace
(brace
l_int|0x0041
comma
l_string|&quot;3COM EtherLink MC/32&quot;
)brace
comma
(brace
l_int|0x8EF5
comma
l_string|&quot;IBM High Performance Lan Adapter&quot;
)brace
comma
(brace
l_int|0x0000
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|mc32_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mc32_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mc32_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mc32_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|mc32_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|mc32_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_reset_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/**&n; * mc32_probe:&n; * @dev: device to probe&n; *&n; * Because MCA bus is a real bus and we can scan for cards we could do a&n; * single scan for all boards here. Right now we use the passed in device&n; * structure and scan for only one board. This needs fixing for modules&n; * in paticular.&n; */
DECL|function|mc32_probe
r_int
id|__init
id|mc32_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_int
id|current_mca_slot
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|adapter_found
op_assign
l_int|0
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Do not check any supplied i/o locations. &n;&t;   POS registers usually don&squot;t fail :) */
multiline_comment|/* MCA cards have POS registers.  &n;&t;   Autodetecting MCA cards is extremely simple. &n;&t;   Just search for the card. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|mc32_adapters
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|adapter_found
suffix:semicolon
id|i
op_increment
)paren
(brace
id|current_mca_slot
op_assign
id|mca_find_unused_adapter
c_func
(paren
id|mc32_adapters
(braket
id|i
)braket
dot
id|id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current_mca_slot
op_ne
id|MCA_NOTFOUND
)paren
op_logical_and
op_logical_neg
id|adapter_found
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mc32_probe1
c_func
(paren
id|dev
comma
id|current_mca_slot
)paren
)paren
(brace
id|mca_set_adapter_name
c_func
(paren
id|current_mca_slot
comma
id|mc32_adapters
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|mca_mark_as_used
c_func
(paren
id|current_mca_slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; * mc32_probe1:&n; * @dev:  Device structure to fill in&n; * @slot: The MCA bus slot being used by this card&n; *&n; * Decode the slot data and configure the card structures. Having done this we&n; * can reset the card and configure it. The card does a full self test cycle&n; * in firmware so we have to wait for it to return and post us either a &n; * failure case or some addresses we use to find the board internals.&n; */
DECL|function|mc32_probe1
r_static
r_int
id|__init
id|mc32_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|slot
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u8
id|POS
suffix:semicolon
id|u32
id|base
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
r_static
id|u16
id|mca_io_bases
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
id|u32
id|mca_mem_bases
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_char
op_star
id|failures
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Time to play MCA games */
r_if
c_cond
(paren
id|mc32_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s found in slot %d:&quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|slot
)paren
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|POS
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|mca_io_bases
(braket
(paren
id|POS
op_rshift
l_int|1
)paren
op_amp
l_int|7
)braket
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|mca_mem_bases
(braket
(paren
id|POS
op_rshift
l_int|4
)paren
op_amp
l_int|7
)braket
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|POS
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;memory window disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|5
)paren
suffix:semicolon
id|i
op_assign
(paren
id|POS
op_rshift
l_int|4
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;invalid memory window.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|i
op_mul_assign
l_int|16384
suffix:semicolon
id|i
op_add_assign
l_int|16384
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|i
suffix:semicolon
id|dev-&gt;irq
op_assign
(paren
(paren
id|POS
op_rshift
l_int|2
)paren
op_amp
l_int|3
)paren
op_plus
l_int|9
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;io 0x%3lX irq %d mem 0x%lX (%dK)&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
comma
id|i
op_div
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* We ought to set the cache line size here.. */
multiline_comment|/*&n;&t; *&t;Go PROM browsing&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: Address &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Retrieve and print the ethernet address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|6
comma
id|i
op_plus
l_int|12
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|7
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|mca_read_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|6
comma
l_int|0
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|7
comma
l_int|0
)paren
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|POS
op_amp
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; : BNC port selected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; : AUI port selected.&bslash;n&quot;
)paren
suffix:semicolon
id|POS
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|POS
op_or_assign
id|HOST_CTRL_ATTN
op_or
id|HOST_CTRL_RESET
suffix:semicolon
id|POS
op_and_assign
op_complement
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|POS
comma
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
multiline_comment|/* Reset adapter */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Reset off */
id|POS
op_and_assign
op_complement
(paren
id|HOST_CTRL_ATTN
op_or
id|HOST_CTRL_RESET
)paren
suffix:semicolon
id|outb
c_func
(paren
id|POS
comma
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|300
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Grab the IRQ&n;&t; */
id|i
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|mc32_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mc32_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mc32_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;slot
op_assign
id|slot
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|base
op_eq
l_int|0xFF
)paren
(brace
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: failed to boot adapter.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
(brace
id|base
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|base
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|base
OL
l_int|0x0C
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s%s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|failures
(braket
id|base
op_minus
l_int|1
)braket
comma
id|base
OL
l_int|0x0A
ques
c_cond
l_string|&quot; test failure&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: unknown failure %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|base
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|base
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
)paren
(brace
id|n
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|100
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: mailbox read fail (%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|base
op_or_assign
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
op_lshift
(paren
l_int|8
op_star
id|i
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_box
op_assign
id|bus_to_virt
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|base
)paren
suffix:semicolon
id|base
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|1
)braket
op_lshift
l_int|16
op_or
id|lp-&gt;exec_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|lp-&gt;base
op_assign
id|dev-&gt;mem_start
op_plus
id|base
suffix:semicolon
id|lp-&gt;rx_box
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_box
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|lp-&gt;stats
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Descriptor chains (card relative)&n;&t; */
id|lp-&gt;tx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|8
)braket
suffix:semicolon
id|lp-&gt;rx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|10
)braket
suffix:semicolon
id|lp-&gt;tx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|9
)braket
suffix:semicolon
id|lp-&gt;rx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|11
)braket
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %d RX buffers, %d TX buffers. Base of 0x%08X.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;rx_len
comma
id|lp-&gt;tx_len
comma
id|lp-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_len
OG
id|TX_RING_MAX
)paren
(brace
id|lp-&gt;tx_len
op_assign
id|TX_RING_MAX
suffix:semicolon
)brace
id|dev-&gt;open
op_assign
id|mc32_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|mc32_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|mc32_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|mc32_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|mc32_set_multicast_list
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|mc32_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
op_star
l_int|5
suffix:semicolon
multiline_comment|/* Board does all the work */
id|lp-&gt;rx_halted
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;tx_halted
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;rx_pending
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_ring_poll:&n; *&t;@dev:&t;The device to wait for&n; *&t;&n; *&t;Wait until a command we issues to the control register is completed.&n; *&t;This actually takes very little time at all, which is fortunate as&n; *&t;we often have to busy wait it.&n; */
DECL|function|mc32_ring_poll
r_static
r_void
id|mc32_ring_poll
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_command_nowait:&n; *&t;@dev: The 3c527 to issue the command to&n; *&t;@cmd: The command word to write to the mailbox&n; *&t;@data: A data block if the command expects one&n; *&t;@len: Length of the data block&n; *&n; *&t;Send a command from interrupt state. If there is a command currently&n; *&t;being executed then we return an error of -1. It simply isnt viable&n; *&t;to wait around as commands may be slow. Providing we get in then&n; *&t;we send the command and busy wait for the board to acknowledge that&n; *&t;a command request is pending. We do not wait for the command to &n; *&t;complete, just for the card to admit to noticing it.  &n; */
DECL|function|mc32_command_nowait
r_static
r_int
id|mc32_command_nowait
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u16
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;exec_pending
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lp-&gt;exec_pending
op_assign
l_int|3
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
id|cmd
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|lp-&gt;exec_box-&gt;data
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the memcpy forgot the volatile so be sure */
multiline_comment|/* Send the command */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|6
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_command: &n; *&t;@dev: The 3c527 card to issue the command to&n; *&t;@cmd: The command word to write to the mailbox&n; *&t;@data: A data block if the command expects one&n; *&t;@len: Length of the data block&n; *&n; *&t;Sends exec commands in a user context. This permits us to wait around&n; *&t;for the replies and also to wait for the command buffer to complete&n; *&t;from a previous command before we execute our command. After our &n; *&t;command completes we will complete any pending multicast reload&n; *&t;we blocked off by hogging the exec buffer.&n; *&n; *&t;You feed the card a command, you wait, it interrupts you get a &n; *&t;reply. All well and good. The complication arises because you use&n; *&t;commands for filter list changes which come in at bh level from things&n; *&t;like IPV6 group stuff.&n; *&n; *&t;We have a simple state machine&n; *&n; *&t;0&t;- nothing issued&n; *&n; *&t;1&t;- command issued, wait reply&n; *&n; *&t;2&t;- reply waiting - reader then goes to state 0&n; *&n; *&t;3&t;- command issued, trash reply. In which case the irq&n; *&t;&t;  takes it back to state 0&n; *&n; *&t;Send command and block for results. On completion spot and reissue&n; *&t;multicasts&n; */
DECL|function|mc32_command
r_static
r_int
id|mc32_command
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u16
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait for a command&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;exec_pending
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Issue mine&n;&t; */
id|lp-&gt;exec_pending
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
id|cmd
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|lp-&gt;exec_box-&gt;data
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the memcpy forgot the volatile so be sure */
multiline_comment|/* Send the command */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|6
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;exec_pending
op_ne
l_int|2
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_pending
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;exec_box-&gt;data
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;A multicast set got blocked - do it now&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;mc_reload_wait
)paren
(brace
id|mc32_reset_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_rx_abort:&n; *&t;@dev: 3c527 to abort&n; *&n; *&t;Peforms a receive abort sequence on the card. In fact after some&n; *&t;experimenting we now simply tell the card to suspend reception. When&n; *&t;issuing aborts occasionally odd things happened.&n; */
DECL|function|mc32_rx_abort
r_static
r_void
id|mc32_rx_abort
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* Suspend reception */
)brace
multiline_comment|/**&n; *&t;mc32_rx_begin:&n; *&t;@dev: 3c527 to enable&n; *&n; *&t;We wait for any pending command to complete and then issue &n; *&t;a start reception command to the board itself. At this point &n; *&t;receive handling continues as it was before.&n; */
DECL|function|mc32_rx_begin
r_static
r_void
id|mc32_rx_begin
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* GO */
id|mc32_ring_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;rx_halted
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_pending
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_tx_abort:&n; *&t;@dev: 3c527 to abort&n; *&n; *&t;Peforms a receive abort sequence on the card. In fact after some&n; *&t;experimenting we now simply tell the card to suspend transmits . When&n; *&t;issuing aborts occasionally odd things happened. In theory we want&n; *&t;an abort to be sure we can recycle our buffers. As it happens we&n; *&t;just have to be careful to shut the card down on close, and&n; *&t;boot it carefully from scratch on setup.&n; */
DECL|function|mc32_tx_abort
r_static
r_void
id|mc32_tx_abort
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* Suspend */
multiline_comment|/* Ring empty */
id|atomic_set
c_func
(paren
op_amp
id|lp-&gt;tx_count
comma
id|lp-&gt;tx_len
)paren
suffix:semicolon
multiline_comment|/* Flush */
r_if
c_cond
(paren
id|lp-&gt;tx_skb_top
op_ne
id|lp-&gt;tx_skb_end
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_skb_top
op_le
id|lp-&gt;tx_skb_end
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
OL
id|TX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|lp-&gt;tx_skb_top
op_assign
id|lp-&gt;tx_skb_end
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_tx_begin:&n; *&t;@dev: 3c527 to enable&n; *&n; *&t;We wait for any pending command to complete and then issue &n; *&t;a start transmit command to the board itself. At this point &n; *&t;transmit handling continues as it was before. The ring must&n; *&t;be setup before you do this and must have an end marker in it.&n; *&t;It turns out we can avoid issuing this specific command when&n; *&t;doing our setup so we avoid it.&n; */
DECL|function|mc32_tx_begin
r_static
r_void
id|mc32_tx_begin
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0&t;
id|outb
c_func
(paren
l_int|5
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* GO */
id|printk
c_func
(paren
l_string|&quot;TX=&gt;5&bslash;n&quot;
)paren
suffix:semicolon
id|mc32_ring_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_box-&gt;mbox
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TX begin error!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;
id|lp-&gt;tx_halted
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_load_rx_ring:&n; *&t;@dev: 3c527 to build the ring for&n; *&n; *&t;The card setups up the receive ring for us. We are required to&n; *&t;use the ring it provides although we can change the size of the&n; *&t;ring.&n; *&n; *&t;We allocate an sk_buff for each ring entry in turn and set the entry&n; *&t;up for a single non s/g buffer. The first buffer we mark with the&n; *&t;end marker bits. Finally we clear the rx mailbox.&n; */
DECL|function|mc32_load_rx_ring
r_static
r_int
id|mc32_load_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u16
id|base
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
id|base
op_assign
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Fix me - should use card size - also fix flush ! */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_assign
id|alloc_skb
c_func
(paren
l_int|1532
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|kfree_skb
c_func
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|lp-&gt;rx_ptr
(braket
id|i
)braket
op_assign
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_member_access_from_pointer
id|data
op_plus
l_int|18
suffix:semicolon
id|p
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|base
)paren
suffix:semicolon
id|p-&gt;control
op_assign
l_int|0
suffix:semicolon
id|p-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|lp-&gt;rx_ptr
(braket
id|i
)braket
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|p-&gt;length
op_assign
l_int|1532
suffix:semicolon
id|base
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|p-&gt;control
op_assign
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_flush_rx_ring:&n; *&t;@lp: Local data of 3c527 to flush the rx ring of&n; *&n; *&t;Free the buffer for each ring slot. Because of the receive &n; *&t;algorithm we use the ring will always be loaded will a full set&n; *&t;of buffers.&n; */
DECL|function|mc32_flush_rx_ring
r_static
r_void
id|mc32_flush_rx_ring
c_func
(paren
r_struct
id|mc32_local
op_star
id|lp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree_skb
c_func
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_flush_tx_ring:&n; *&t;@lp: Local data of 3c527 to flush the tx ring of&n; *&n; *&t;We have to consider two cases here. We want to free the pending&n; *&t;buffers only. If the ring buffer head is past the start then the&n; *&t;ring segment we wish to free wraps through zero.&n; */
DECL|function|mc32_flush_tx_ring
r_static
r_void
id|mc32_flush_tx_ring
c_func
(paren
r_struct
id|mc32_local
op_star
id|lp
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_skb_top
op_le
id|lp-&gt;tx_skb_end
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
OL
id|TX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;mc32_open&n; *&t;@dev: device to open&n; *&n; *&t;The user is trying to bring the card into ready state. This requires&n; *&t;a brief dialogue with the card. Firstly we enable interrupts and then&n; *&t;&squot;indications&squot;. Without these enabled the card doesn&squot;t bother telling&n; *&t;us what it has done. This had me puzzled for a week.&n; *&n; *&t;We then load the network address and multicast filters. Turn on the&n; *&t;workaround mode. This works around a bug in the 82586 - it asks the&n; *&t;firmware to do so. It has a performance hit but is needed on busy&n; *&t;[read most] lans. We load the ring with buffers then we kick it&n; *&t;all off.&n; */
DECL|function|mc32_open
r_static
r_int
id|mc32_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|zero_word
op_assign
l_int|0
suffix:semicolon
id|u8
id|one
op_assign
l_int|1
suffix:semicolon
id|u8
id|regs
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Interrupts enabled&n;&t; */
id|regs
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|regs
op_or_assign
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|regs
comma
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the indications on command&n;&t; */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|4
comma
op_amp
id|one
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the command sequence &quot;abort, resume&quot; for RX and TX.&n;&t; *&t;The abort cleans up the buffer chains if needed.&n;&t; */
id|mc32_rx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_tx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set Network Address */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|1
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Set the filters */
id|mc32_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Issue the 82586 workaround command - this is for &quot;busy lans&quot;,&n;&t;   but basically means for all lans now days - has a performance&n;&t;   cost but best set */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0x0D
comma
op_amp
id|zero_word
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 82586 bug workaround on */
multiline_comment|/* Load the ring we just initialised */
r_if
c_cond
(paren
id|mc32_load_rx_ring
c_func
(paren
id|dev
)paren
)paren
(brace
id|mc32_close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
multiline_comment|/* And the resume command goes last */
id|mc32_rx_begin
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_tx_begin
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_timeout:&n; *&t;@dev: 3c527 that timed out&n; *&n; *&t;Handle a timeout on transmit from the 3c527. This normally means&n; *&t;bad things as the hardware handles cable timeouts and mess for&n; *&t;us.&n; *&n; */
DECL|function|mc32_timeout
r_static
r_void
id|mc32_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_send_packet:&n; *&t;@skb: buffer to transmit&n; *&t;@dev: 3c527 to send it out of&n; *&n; *&t;Transmit a buffer. This normally means throwing the buffer onto&n; *&t;the transmit queue as the queue is quite large. If the queue is&n; *&t;full then we set tx_busy and return. Once the interrupt handler&n; *&t;gets messages telling it to reclaim transmit queue entries we will&n; *&t;clear tx_busy and the kernel will start calling this again.&n; *&n; *&t;We use cli rather than spinlocks. Since I have no access to an SMP&n; *&t;MCA machine I don&squot;t plan to change it. It is probably the top &n; *&t;performance hit for this driver on SMP however.&n; */
DECL|function|mc32_send_packet
r_static
r_int
id|mc32_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u16
id|tx_head
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
comma
op_star
id|np
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
op_eq
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|tx_head
op_assign
id|lp-&gt;tx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
suffix:semicolon
multiline_comment|/* We will need this to flush the buffer out */
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_end
)braket
op_assign
id|skb
suffix:semicolon
id|lp-&gt;tx_skb_end
op_increment
suffix:semicolon
id|lp-&gt;tx_skb_end
op_and_assign
(paren
id|TX_RING_MAX
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* TX suspend - shouldnt be needed but apparently is.&n;&t;   This is a research item ... */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* Transmit now stopped */
multiline_comment|/* P is the last sending/sent buffer as a pointer */
id|p
op_assign
(paren
r_struct
id|skb_header
op_star
)paren
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|tx_head
)paren
suffix:semicolon
multiline_comment|/* NP is the buffer we will be loading */
id|np
op_assign
(paren
r_struct
id|skb_header
op_star
)paren
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|p-&gt;next
)paren
suffix:semicolon
id|np-&gt;control
op_or_assign
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* EOL */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;length
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;length
OL
l_int|60
)paren
(brace
id|np-&gt;length
op_assign
l_int|60
suffix:semicolon
)brace
id|np-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|np-&gt;status
op_assign
l_int|0
suffix:semicolon
id|np-&gt;control
op_assign
(paren
l_int|1
op_lshift
l_int|7
)paren
op_or
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* EOP EOL */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|p-&gt;control
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|5
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* Restart TX */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_update_stats:&n; *&t;@dev: 3c527 to service&n; *&n; *&t;When the board signals us that its statistics need attention we&n; *&t;should query the table and clear it. In actual fact we currently&n; *&t;track all our statistics in software and I haven&squot;t implemented it yet.&n; */
DECL|function|mc32_update_stats
r_static
r_void
id|mc32_update_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
)brace
multiline_comment|/**&n; *&t;mc32_rx_ring:&n; *&t;@dev: 3c527 that needs its receive ring processing&n; *&n; *&t;We have received one or more indications from the card that&n; *&t;a receive has completed. The ring buffer thus contains dirty&n; *&t;entries. Firstly we tell the card to stop receiving, then We walk &n; *&t;the ring from the first filled entry, which is pointed to by the &n; *&t;card rx mailbox and for each completed packet we will either copy &n; *&t;it and pass it up the stack or if the packet is near MTU sized we &n; *&t;allocate another buffer and flip the old one up the stack.&n; *&n; *&t;We must succeed in keeping a buffer on the ring. If neccessary we&n; *&t;will toss a received packet rather than lose a ring entry. Once the&n; *&t;first packet that is unused is found we reload the mailbox with the&n; *&t;buffer so that the card knows it can use the buffers again. Finally&n; *&t;we set it receiving again. &n; *&n; *&t;We must stop reception during the ring walk. I thought it would be&n; *&t;neat to avoid it by clever tricks, but it turns out the event order&n; *&t;on the card means you have to play by the manual.&n; */
DECL|function|mc32_rx_ring
r_static
r_void
id|mc32_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|x
op_assign
l_int|0
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
id|u16
id|base
suffix:semicolon
id|u16
id|top
suffix:semicolon
multiline_comment|/* Halt RX before walking the ring */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|3
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
(brace
suffix:semicolon
)brace
id|top
op_assign
id|base
op_assign
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
r_do
(brace
id|p
op_assign
(paren
r_struct
id|skb_header
op_star
)paren
id|bus_to_virt
c_func
(paren
id|base
op_plus
id|lp-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
(brace
id|u16
id|length
op_assign
id|p-&gt;length
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;Frame at %p&bslash;n&quot;, bus_to_virt(p-&gt;data)); */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
comma
id|bus_to_virt
c_func
(paren
id|p-&gt;data
)paren
comma
id|length
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|lp-&gt;net_stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;net_stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
id|lp-&gt;net_stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;net_stats.rx_errors
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|1
suffix:colon
id|lp-&gt;net_stats.rx_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|lp-&gt;net_stats.rx_fifo_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|lp-&gt;net_stats.rx_frame_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|lp-&gt;net_stats.rx_missed_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|lp-&gt;net_stats.rx_length_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|p-&gt;length
op_assign
l_int|1532
suffix:semicolon
id|p-&gt;control
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|x
op_increment
OL
l_int|48
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Restart ring processing&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
op_assign
id|top
suffix:semicolon
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|lp-&gt;rx_halted
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_interrupt:&n; *&t;@irq: Interrupt number&n; *&t;@dev_id: 3c527 that requires servicing&n; *&t;@regs: Registers (unused)&n; *&n; *&t;The 3c527 interrupts us for four reasons. The command register &n; *&t;contains the message it wishes to send us packed into a single&n; *&t;byte field. We keep reading status entries until we have processed&n; *&t;all the transmit and control items, but simply count receive&n; *&t;reports. When the receive reports are in we can call the mc32_rx_ring&n; *&t;and empty the ring. This saves the overhead of multiple command requests&n; */
DECL|function|mc32_interrupt
r_static
r_void
id|mc32_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d for unknown device.&bslash;n&quot;
comma
id|cardname
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* See whats cooking */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
op_logical_and
id|boguscount
op_increment
OL
l_int|2000
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ&t;&t;
id|printk
c_func
(paren
l_string|&quot;Status TX%d RX%d EX%d OV%d&bslash;n&quot;
comma
(paren
id|status
op_amp
l_int|7
)paren
comma
(paren
id|status
op_rshift
l_int|3
)paren
op_amp
l_int|7
comma
(paren
id|status
op_rshift
l_int|6
)paren
op_amp
l_int|1
comma
(paren
id|status
op_rshift
l_int|7
)paren
op_amp
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|status
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* TX fail */
id|lp-&gt;net_stats.tx_errors
op_increment
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* TX ok */
id|lp-&gt;net_stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Packets are sent in order - this is&n;&t;&t;&t;&t;   basically a FIFO queue of buffers matching&n;&t;&t;&t;&t;   the card ring */
id|lp-&gt;net_stats.tx_bytes
op_add_assign
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_top
)braket
op_member_access_from_pointer
id|len
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_top
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_top
)braket
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;tx_skb_top
op_increment
suffix:semicolon
id|lp-&gt;tx_skb_top
op_and_assign
(paren
id|TX_RING_MAX
op_minus
l_int|1
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Halt */
r_case
l_int|4
suffix:colon
multiline_comment|/* Abort */
id|lp-&gt;tx_halted
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|lp-&gt;tx_halted
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: strange tx ack %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|status
op_rshift_assign
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|status
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* RX */
id|lp-&gt;rx_pending
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;rx_halted
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Halt ring receive&n;&t;&t;&t;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|3
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|lp-&gt;rx_halted
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|lp-&gt;rx_halted
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Out of RX buffers stat */
id|lp-&gt;net_stats.rx_dropped
op_increment
suffix:semicolon
id|lp-&gt;rx_pending
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Must restart */
id|lp-&gt;rx_halted
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: strange rx ack %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|status
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* 0=no 1=yes 2=replied, get cmd, 3 = wait reply &amp; dump it */
r_if
c_cond
(paren
id|lp-&gt;exec_pending
op_ne
l_int|3
)paren
(brace
id|lp-&gt;exec_pending
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|lp-&gt;exec_pending
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Update the stats as soon as&n;&t;&t;&t; *&t;we have it flagged and can &n;&t;&t;&t; *&t;send an immediate reply (CRR set)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
(brace
id|mc32_update_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Process and restart the receive ring. This has some state&n;&t; *&t;as we must halt the ring to process it and halting the ring&n;&t; *&t;might not occur in the same IRQ handling loop as we issue&n;&t; *&t;the halt.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;rx_pending
op_logical_and
id|lp-&gt;rx_halted
)paren
(brace
id|mc32_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;rx_pending
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_close:&n; *&t;@dev: 3c527 card to shut down&n; *&n; *&t;The 3c527 is a bus mastering device. We must be careful how we&n; *&t;shut it down. It may also be running shared interrupt so we have&n; *&t;to be sure to silence it properly&n; *&n; *&t;We abort any receive and transmits going on and then wait until&n; *&t;any pending exec commands have completed in other code threads.&n; *&t;In theory we can&squot;t get here while that is true, in practice I am&n; *&t;paranoid&n; *&n; *&t;We turn off the interrupt enable for the board to be sure it can&squot;t&n; *&t;intefere with other devices.&n; */
DECL|function|mc32_close
r_static
r_int
id|mc32_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u8
id|regs
suffix:semicolon
id|u16
id|one
op_assign
l_int|1
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the indications on command (handy debug check)&n;&t; */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|4
comma
op_amp
id|one
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Abort RX and Abort TX */
id|mc32_rx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_tx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Catch any waiting commands */
r_while
c_loop
(paren
id|lp-&gt;exec_pending
op_eq
l_int|1
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok the card is now stopping */
id|regs
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|regs
op_and_assign
op_complement
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|regs
comma
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|mc32_flush_rx_ring
c_func
(paren
id|lp
)paren
suffix:semicolon
id|mc32_flush_tx_ring
c_func
(paren
id|lp
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_get_stats:&n; *&t;@dev: The 3c527 card to handle&n; *&n; *&t;As we currently handle our statistics in software this one is&n; *&t;easy to handle. With hardware statistics it will get messy&n; *&t;as the get_stats call will need to send exec mailbox messages and&n; *&t;need to lock out the multicast reloads.&n; */
DECL|function|mc32_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|mc32_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;net_stats
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;do_mc32_set_multicast_list:&n; *&t;@dev: 3c527 device to load the list on&n; *&t;@retry: indicates this is not the first call. &n; *&n; * Actually set or clear the multicast filter for this adaptor. The locking&n; * issues are handled by this routine. We have to track state as it may take&n; * multiple calls to get the command sequence completed. We just keep trying&n; * to schedule the loads until we manage to process them all.&n; *&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; *&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; *&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
DECL|function|do_mc32_set_multicast_list
r_static
r_void
id|do_mc32_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|retry
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
id|filt
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
multiline_comment|/* Enable promiscuous mode */
id|filt
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_count
OG
l_int|10
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|filt
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
r_int
r_char
id|block
(braket
l_int|62
)braket
suffix:semicolon
r_int
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmc
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_int
id|i
suffix:semicolon
id|filt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_eq
l_int|0
)paren
(brace
id|lp-&gt;mc_list_valid
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;mc_list_valid
)paren
(brace
id|block
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|block
(braket
l_int|0
)braket
op_assign
id|dev-&gt;mc_count
suffix:semicolon
id|bp
op_assign
id|block
op_plus
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|bp
comma
id|dmc-&gt;dmi_addr
comma
l_int|6
)paren
suffix:semicolon
id|bp
op_add_assign
l_int|6
suffix:semicolon
id|dmc
op_assign
id|dmc-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mc32_command_nowait
c_func
(paren
id|dev
comma
l_int|2
comma
id|block
comma
l_int|2
op_plus
l_int|6
op_star
id|dev-&gt;mc_count
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|lp-&gt;mc_reload_wait
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lp-&gt;mc_list_valid
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|filt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mc32_command_nowait
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|filt
comma
l_int|2
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|lp-&gt;mc_reload_wait
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_set_multicast_list:&n; *&t;@dev: The 3c527 to use&n; *&n; *&t;Commence loading the multicast list. This is called when the kernel&n; *&t;changes the lists. It will override any pending list we are trying to&n; *&t;load.&n; */
DECL|function|mc32_set_multicast_list
r_static
r_void
id|mc32_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|do_mc32_set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_reset_multicast_list:&n; *&t;@dev: The 3c527 to use&n; *&n; *&t;Attempt the next step in loading the multicast lists. If this attempt&n; *&t;fails to complete then it will be scheduled and this function called&n; *&t;again later from elsewhere.&n; */
DECL|function|mc32_reset_multicast_list
r_static
r_void
id|mc32_reset_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|do_mc32_set_multicast_list
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|this_device
r_static
r_struct
id|net_device
id|this_device
suffix:semicolon
multiline_comment|/**&n; *&t;init_module:&n; *&n; *&t;Probe and locate a 3c527 card. This really should probe and locate&n; *&t;all the 3c527 cards in the machine not just one of them. Yes you can&n; *&t;insmod multiple modules for now but its a hack.&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
id|this_device.init
op_assign
id|mc32_probe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|this_device
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;cleanup_module:&n; *&n; *&t;Unloading time. We release the MCA bus resources and the interrupt&n; *&t;at which point everything is ready to unload. The card must be stopped&n; *&t;at this point or we would not have been called. When we unload we&n; *&t;leave the card stopped but not totally shut down. When the card is&n; *&t;initialized it must be rebooted or the rings reloaded before any&n; *&t;transmit operations are allowed to start scribbling into memory.&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|slot
suffix:semicolon
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
id|unregister_netdev
c_func
(paren
op_amp
id|this_device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t do this, we can&squot;t re-insmod it later.&n;&t; */
r_if
c_cond
(paren
id|this_device.priv
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
id|this_device.priv
suffix:semicolon
id|slot
op_assign
id|lp-&gt;slot
suffix:semicolon
id|mca_mark_as_unused
c_func
(paren
id|slot
)paren
suffix:semicolon
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this_device.priv
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|this_device.irq
comma
op_amp
id|this_device
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
