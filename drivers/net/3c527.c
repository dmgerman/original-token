multiline_comment|/* 3c527.c: 3Com Etherlink/MC32 driver for Linux&n; *&n; *&t;(c) Copyright 1998 Red Hat Software Inc&n; *&t;Written by Alan Cox.&n; *&n; *&t;Based on skeleton.c written 1993-94 by Donald Becker and ne2.c&n; *&t;(for the MCA stuff) written by Wim Dumon.&n; *&n; *&t;Thanks to 3Com for making this possible by providing me with the&n; *&t;documentation.&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU Public License, incorporated herein by reference.&n; *&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;3c527.c:v0.04 1999/03/16 Alan Cox (alan@redhat.com)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; *&t;Things you need&n; *&t;o&t;The databook.&n; *&n; *&t;Traps for the unwary&n; *&n; *&t;The diagram (Figure 1-1) and the POS summary disagree with the&n; *&t;&quot;Interrupt Level&quot; section in the manual.&n; *&n; *&t;The documentation in places seems to miss things. In actual fact&n; *&t;I&squot;ve always eventually found everything is documented, it just&n; *&t;requires careful study.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;3c527.h&quot;
multiline_comment|/*&n; * The name of the card. Is used for messages and in the requests for&n; * io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;3c527&quot;
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
DECL|variable|mc32_debug
r_static
r_int
r_int
id|mc32_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|NETCARD_IO_EXTENT
mdefine_line|#define NETCARD_IO_EXTENT&t;8
DECL|struct|mc32_mailbox
r_struct
id|mc32_mailbox
(brace
id|u16
id|mbox
id|__attribute
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
id|u16
id|data
(braket
l_int|1
)braket
id|__attribute
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|macro|TX_RING_MAX
mdefine_line|#define TX_RING_MAX&t;16&t;/* Typically the card supports 37 */
DECL|macro|RX_RING_MAX
mdefine_line|#define RX_RING_MAX&t;32&t;/*        &quot;     &quot;       &quot;         */
DECL|struct|mc32_local
r_struct
id|mc32_local
(brace
DECL|member|net_stats
r_struct
id|net_device_stats
id|net_stats
suffix:semicolon
DECL|member|slot
r_int
id|slot
suffix:semicolon
DECL|member|rx_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|rx_box
suffix:semicolon
DECL|member|tx_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|tx_box
suffix:semicolon
DECL|member|exec_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|exec_box
suffix:semicolon
DECL|member|stats
r_volatile
id|u16
op_star
id|stats
suffix:semicolon
DECL|member|tx_chain
id|u16
id|tx_chain
suffix:semicolon
DECL|member|rx_chain
id|u16
id|rx_chain
suffix:semicolon
DECL|member|tx_len
id|u16
id|tx_len
suffix:semicolon
DECL|member|rx_len
id|u16
id|rx_len
suffix:semicolon
DECL|member|base
id|u32
id|base
suffix:semicolon
DECL|member|rx_halted
id|u16
id|rx_halted
suffix:semicolon
DECL|member|tx_halted
id|u16
id|tx_halted
suffix:semicolon
DECL|member|exec_pending
id|u16
id|exec_pending
suffix:semicolon
DECL|member|mc_reload_wait
id|u16
id|mc_reload_wait
suffix:semicolon
multiline_comment|/* a multicast load request is pending */
DECL|member|tx_count
id|atomic_t
id|tx_count
suffix:semicolon
multiline_comment|/* buffers left */
DECL|member|event
id|wait_queue_head_t
id|event
suffix:semicolon
DECL|member|tx_skb
r_struct
id|sk_buff
op_star
id|tx_skb
(braket
id|TX_RING_MAX
)braket
suffix:semicolon
multiline_comment|/* Transmit ring */
DECL|member|tx_skb_top
id|u16
id|tx_skb_top
suffix:semicolon
DECL|member|tx_skb_end
id|u16
id|tx_skb_end
suffix:semicolon
DECL|member|rx_skb
r_struct
id|sk_buff
op_star
id|rx_skb
(braket
id|RX_RING_MAX
)braket
suffix:semicolon
multiline_comment|/* Receive ring */
DECL|member|rx_ptr
r_void
op_star
id|rx_ptr
(braket
id|RX_RING_MAX
)braket
suffix:semicolon
multiline_comment|/* Data pointers */
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for a sanity check. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x02
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0x60
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0xAC
DECL|struct|mca_adapters_t
r_struct
id|mca_adapters_t
(brace
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|mc32_adapters
r_const
r_struct
id|mca_adapters_t
id|mc32_adapters
(braket
)braket
op_assign
(brace
(brace
l_int|0x0041
comma
l_string|&quot;3COM EtherLink MC/32&quot;
)brace
comma
(brace
l_int|0x8EF5
comma
l_string|&quot;IBM High Performance Lan Adapter&quot;
)brace
comma
(brace
l_int|0x0000
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|mc32_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mc32_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mc32_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mc32_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|mc32_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|mc32_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; * Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n; * If dev-&gt;base_addr == 0, probe all likely locations.&n; * If dev-&gt;base_addr == 1, always return failure.&n; * If dev-&gt;base_addr == 2, allocate space for the device and return success&n; * (detachable devices only).&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|mc32_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
)paren
(brace
r_static
r_int
id|current_mca_slot
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|adapter_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not check any supplied i/o locations. &n;&t;   POS registers usually don&squot;t fail :) */
multiline_comment|/* MCA cards have POS registers.  &n;&t;   Autodetecting MCA cards is extremely simple. &n;&t;   Just search for the card. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|mc32_adapters
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|adapter_found
suffix:semicolon
id|i
op_increment
)paren
(brace
id|current_mca_slot
op_assign
id|mca_find_unused_adapter
c_func
(paren
id|mc32_adapters
(braket
id|i
)braket
dot
id|id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current_mca_slot
op_ne
id|MCA_NOTFOUND
)paren
op_logical_and
op_logical_neg
id|adapter_found
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mc32_probe1
c_func
(paren
id|dev
comma
id|current_mca_slot
)paren
)paren
(brace
id|mca_set_adapter_name
c_func
(paren
id|current_mca_slot
comma
id|mc32_adapters
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|mca_mark_as_used
c_func
(paren
id|current_mca_slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the real probe routine. Linux has a history of friendly device&n; * probes on the ISA bus. A good device probes avoids doing writes, and&n; * verifies that the correct device exists and functions.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|mc32_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|slot
)paren
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u8
id|POS
suffix:semicolon
id|u32
id|base
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
r_static
id|u16
id|mca_io_bases
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
id|u32
id|mca_mem_bases
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_char
op_star
id|failures
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Time to play MCA games */
r_if
c_cond
(paren
id|mc32_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s found in slot %d:&quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|slot
)paren
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|POS
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Allocate a new &squot;dev&squot; if needed. */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t allocate the private data here, it is done later&n;&t;&t; * This makes it easier to free the memory when this driver&n;&t;&t; * is used as a module.&n;&t;&t; */
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|mca_io_bases
(braket
(paren
id|POS
op_rshift
l_int|1
)paren
op_amp
l_int|7
)braket
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|mca_mem_bases
(braket
(paren
id|POS
op_rshift
l_int|4
)paren
op_amp
l_int|7
)braket
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|POS
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;memory window disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|5
)paren
suffix:semicolon
id|i
op_assign
(paren
id|POS
op_rshift
l_int|4
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;invalid memory window.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|i
op_mul_assign
l_int|16384
suffix:semicolon
id|i
op_add_assign
l_int|16384
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|i
suffix:semicolon
id|dev-&gt;irq
op_assign
(paren
(paren
id|POS
op_rshift
l_int|2
)paren
op_amp
l_int|3
)paren
op_plus
l_int|9
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;io 0x%3lX irq %d mem 0x%lX (%dK)&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
comma
id|i
op_div
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* We ought to set the cache line size here.. */
multiline_comment|/*&n;&t; *&t;Go PROM browsing&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: Address &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Retrieve and print the ethernet address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|6
comma
id|i
op_plus
l_int|12
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|7
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|mca_read_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|6
comma
l_int|0
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|7
comma
l_int|0
)paren
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|POS
op_amp
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; : BNC port selected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; : AUI port selected.&bslash;n&quot;
)paren
suffix:semicolon
id|POS
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|POS
op_or_assign
id|HOST_CTRL_ATTN
op_or
id|HOST_CTRL_RESET
suffix:semicolon
id|POS
op_and_assign
op_complement
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|POS
comma
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
multiline_comment|/* Reset adapter */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Reset off */
id|POS
op_and_assign
op_complement
(paren
id|HOST_CTRL_ATTN
op_or
id|HOST_CTRL_RESET
)paren
suffix:semicolon
id|outb
c_func
(paren
id|POS
comma
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|300
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Grab the IRQ&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|mc32_interrupt
comma
l_int|0
comma
id|cardname
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mc32_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mc32_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;slot
op_assign
id|slot
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|base
op_eq
l_int|0xFF
)paren
(brace
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: failed to boot adapter.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
(brace
id|base
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|base
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|base
OL
l_int|0x0C
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s%s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|failures
(braket
id|base
op_minus
l_int|1
)braket
comma
id|base
OL
l_int|0x0A
ques
c_cond
l_string|&quot; test failure&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: unknown failure %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|base
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|base
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
)paren
(brace
id|n
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|100
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: mailbox read fail (%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|base
op_or_assign
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
op_lshift
(paren
l_int|8
op_star
id|i
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_box
op_assign
id|bus_to_virt
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|base
)paren
suffix:semicolon
id|base
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|1
)braket
op_lshift
l_int|16
op_or
id|lp-&gt;exec_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|lp-&gt;base
op_assign
id|dev-&gt;mem_start
op_plus
id|base
suffix:semicolon
id|lp-&gt;rx_box
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_box
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|lp-&gt;stats
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Descriptor chains (card relative)&n;&t; */
id|lp-&gt;tx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|8
)braket
suffix:semicolon
id|lp-&gt;rx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|10
)braket
suffix:semicolon
id|lp-&gt;tx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|9
)braket
suffix:semicolon
id|lp-&gt;rx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|11
)braket
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %d RX buffers, %d TX buffers. Base of 0x%08X.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;rx_len
comma
id|lp-&gt;tx_len
comma
id|lp-&gt;base
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|mc32_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|mc32_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|mc32_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|mc32_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|mc32_set_multicast_list
suffix:semicolon
id|lp-&gt;rx_halted
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;tx_halted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Polled command stuff &n; */
DECL|function|mc32_ring_poll
r_static
r_void
id|mc32_ring_poll
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Send exec commands&n; */
DECL|function|mc32_command
r_static
r_int
id|mc32_command
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;exec_pending
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_pending
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
id|cmd
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|lp-&gt;exec_box-&gt;data
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the memcpy forgot the volatile so be sure */
multiline_comment|/* Send the command */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|6
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;exec_pending
op_ne
l_int|2
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_pending
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;A multicast set got blocked - do it now&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;mc_reload_wait
)paren
(brace
id|mc32_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;exec_box-&gt;data
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;RX abort&n; */
DECL|function|mc32_rx_abort
r_static
r_void
id|mc32_rx_abort
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* Suspend reception */
)brace
multiline_comment|/*&n; *&t;RX enable&n; */
DECL|function|mc32_rx_begin
r_static
r_void
id|mc32_rx_begin
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* GO */
id|mc32_ring_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;rx_halted
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|mc32_tx_abort
r_static
r_void
id|mc32_tx_abort
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* Suspend */
multiline_comment|/* Ring empty */
id|atomic_set
c_func
(paren
op_amp
id|lp-&gt;tx_count
comma
id|lp-&gt;tx_len
)paren
suffix:semicolon
multiline_comment|/* Flush */
r_if
c_cond
(paren
id|lp-&gt;tx_skb_top
op_ne
id|lp-&gt;tx_skb_end
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_skb_top
op_le
id|lp-&gt;tx_skb_end
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
OL
id|TX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|lp-&gt;tx_skb_top
op_assign
id|lp-&gt;tx_skb_end
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;TX enable&n; */
DECL|function|mc32_tx_begin
r_static
r_void
id|mc32_tx_begin
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0&t;
id|outb
c_func
(paren
l_int|5
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* GO */
id|printk
c_func
(paren
l_string|&quot;TX=&gt;5&bslash;n&quot;
)paren
suffix:semicolon
id|mc32_ring_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_box-&gt;mbox
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TX begin error!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;
id|lp-&gt;tx_halted
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Load the rx ring&n; */
DECL|function|mc32_load_rx_ring
r_static
r_int
id|mc32_load_rx_ring
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u16
id|base
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
id|base
op_assign
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Fix me - should use card size - also fix flush ! */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_assign
id|alloc_skb
c_func
(paren
l_int|1532
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|kfree_skb
c_func
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|lp-&gt;rx_ptr
(braket
id|i
)braket
op_assign
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_member_access_from_pointer
id|data
op_plus
l_int|18
suffix:semicolon
id|p
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|base
)paren
suffix:semicolon
id|p-&gt;control
op_assign
l_int|0
suffix:semicolon
id|p-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|lp-&gt;rx_ptr
(braket
id|i
)braket
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|p-&gt;length
op_assign
l_int|1532
suffix:semicolon
id|base
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|p-&gt;control
op_assign
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mc32_flush_rx_ring
r_static
r_void
id|mc32_flush_rx_ring
c_func
(paren
r_struct
id|mc32_local
op_star
id|lp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree_skb
c_func
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|mc32_flush_tx_ring
r_static
r_void
id|mc32_flush_tx_ring
c_func
(paren
r_struct
id|mc32_local
op_star
id|lp
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_skb_top
op_le
id|lp-&gt;tx_skb_end
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;tx_skb_end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_skb_top
suffix:semicolon
id|i
OL
id|TX_RING_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Open/initialize the board. This is called (in the current kernel)&n; * sometime after booting when the &squot;ifconfig&squot; program is run.&n; */
DECL|function|mc32_open
r_static
r_int
id|mc32_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|zero_word
op_assign
l_int|0
suffix:semicolon
id|u8
id|one
op_assign
l_int|1
suffix:semicolon
id|u8
id|regs
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Interrupts enabled&n;&t; */
id|regs
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|regs
op_or_assign
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|regs
comma
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the indications on command&n;&t; */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|4
comma
op_amp
id|one
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the command sequence &quot;abort, resume&quot; for RX and TX.&n;&t; *&t;The abort cleans up the buffer chains if needed.&n;&t; */
id|mc32_rx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_tx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set Network Address */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|1
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Set the filters */
id|mc32_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Issue the 82586 workaround command - this is for &quot;busy lans&quot;,&n;&t;   but basically means for all lans now days - has a performance&n;&t;   cost but best set */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0x0D
comma
op_amp
id|zero_word
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 82586 bug workaround on */
multiline_comment|/* Load the ring we just initialised */
r_if
c_cond
(paren
id|mc32_load_rx_ring
c_func
(paren
id|dev
)paren
)paren
(brace
id|mc32_close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
multiline_comment|/* And the resume command goes last */
id|mc32_rx_begin
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_tx_begin
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mc32_send_packet
r_static
r_int
id|mc32_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we get here, some higher level has decided we are broken.&n;&t;&t; * There should really be a &quot;kick me&quot; function call instead.&n;&t;&t; */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Block a timer-based transmit from overlapping. This could better be&n;&t; * done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well.&n;&t; */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u16
id|tx_head
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
comma
op_star
id|np
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|tx_head
op_assign
id|lp-&gt;tx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
suffix:semicolon
multiline_comment|/* We will need this to flush the buffer out */
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_end
)braket
op_assign
id|skb
suffix:semicolon
id|lp-&gt;tx_skb_end
op_increment
suffix:semicolon
id|lp-&gt;tx_skb_end
op_and_assign
(paren
id|TX_RING_MAX
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* P is the last sending/sent buffer as a pointer */
id|p
op_assign
(paren
r_struct
id|skb_header
op_star
)paren
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|tx_head
)paren
suffix:semicolon
multiline_comment|/* NP is the buffer we will be loading */
id|np
op_assign
(paren
r_struct
id|skb_header
op_star
)paren
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|p-&gt;next
)paren
suffix:semicolon
id|np-&gt;control
op_or_assign
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* EOL */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;length
op_assign
id|skb-&gt;len
suffix:semicolon
id|np-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|np-&gt;status
op_assign
l_int|0
suffix:semicolon
id|np-&gt;control
op_assign
(paren
l_int|1
op_lshift
l_int|7
)paren
op_or
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* EOP EOL */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|p-&gt;control
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Keep feeding me */
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mc32_update_stats
r_static
r_void
id|mc32_update_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
)brace
DECL|function|mc32_rx_ring
r_static
r_void
id|mc32_rx_ring
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|x
op_assign
l_int|0
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
id|u16
id|base
suffix:semicolon
id|u16
id|top
suffix:semicolon
id|top
op_assign
id|base
op_assign
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
r_do
(brace
id|p
op_assign
(paren
r_struct
id|skb_header
op_star
)paren
id|bus_to_virt
c_func
(paren
id|base
op_plus
id|lp-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
(brace
id|u16
id|length
op_assign
id|p-&gt;length
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;Frame at %p&bslash;n&quot;, bus_to_virt(p-&gt;data)); */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
comma
id|bus_to_virt
c_func
(paren
id|p-&gt;data
)paren
comma
id|length
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|lp-&gt;net_stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;net_stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
id|lp-&gt;net_stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;net_stats.rx_errors
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|1
suffix:colon
id|lp-&gt;net_stats.rx_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|lp-&gt;net_stats.rx_fifo_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|lp-&gt;net_stats.rx_frame_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|lp-&gt;net_stats.rx_missed_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|lp-&gt;net_stats.rx_length_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|p-&gt;length
op_assign
l_int|1532
suffix:semicolon
id|p-&gt;control
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|x
op_increment
OL
l_int|48
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *&t;This is curious. It seems the receive stop and receive continue&n;&t; *&t;commands race against each other, even though we poll for &n;&t; *&t;command ready to be issued. The delay is hackish but is a workaround&n;&t; *&t;while I investigate in depth&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
op_assign
id|top
suffix:semicolon
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|3
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The typical workload of the driver:&n; *   Handle the network interface interrupts.&n; */
DECL|function|mc32_interrupt
r_static
r_void
id|mc32_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_int
id|rx_event
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d for unknown device.&bslash;n&quot;
comma
id|cardname
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* See whats cooking */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
op_logical_and
id|boguscount
op_increment
OL
l_int|2000
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ&t;&t;
id|printk
c_func
(paren
l_string|&quot;Status TX%d RX%d EX%d OV%d&bslash;n&quot;
comma
(paren
id|status
op_amp
l_int|7
)paren
comma
(paren
id|status
op_rshift
l_int|3
)paren
op_amp
l_int|7
comma
(paren
id|status
op_rshift
l_int|6
)paren
op_amp
l_int|1
comma
(paren
id|status
op_rshift
l_int|7
)paren
op_amp
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|status
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* TX fail */
id|lp-&gt;net_stats.tx_errors
op_increment
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* TX ok */
id|lp-&gt;net_stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Packets are sent in order - this is&n;&t;&t;&t;&t;   basically a FIFO queue of buffers matching&n;&t;&t;&t;&t;   the card ring */
id|lp-&gt;net_stats.tx_bytes
op_add_assign
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_top
)braket
op_member_access_from_pointer
id|len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_top
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_skb_top
)braket
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;tx_skb_top
op_increment
suffix:semicolon
id|lp-&gt;tx_skb_top
op_and_assign
(paren
id|TX_RING_MAX
op_minus
l_int|1
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Halt */
r_case
l_int|4
suffix:colon
multiline_comment|/* Abort */
id|lp-&gt;tx_halted
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|lp-&gt;tx_halted
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: strange tx ack %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|status
op_rshift_assign
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|status
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* RX */
id|rx_event
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|lp-&gt;rx_halted
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|lp-&gt;rx_halted
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Out of RX buffers stat */
multiline_comment|/* Must restart */
id|lp-&gt;net_stats.rx_dropped
op_increment
suffix:semicolon
id|rx_event
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* To restart */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: strange rx ack %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|status
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* 0=no 1=yes 2=reply clearing */
id|lp-&gt;exec_pending
op_assign
l_int|2
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Update the stats as soon as&n;&t;&t;&t; *&t;we have it flagged and can &n;&t;&t;&t; *&t;send an immediate reply (CRR set)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
(brace
id|mc32_update_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Process and restart the receive ring.&n;&t; */
r_if
c_cond
(paren
id|rx_event
)paren
(brace
id|mc32_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to mc32_open(). */
DECL|function|mc32_close
r_static
r_int
id|mc32_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u8
id|regs
suffix:semicolon
id|u16
id|one
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the indications on command (handy debug check)&n;&t; */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|4
comma
op_amp
id|one
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Abort RX and Abort TX */
id|mc32_rx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_tx_abort
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Catch any waiting commands */
r_while
c_loop
(paren
id|lp-&gt;exec_pending
op_eq
l_int|1
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok the card is now stopping */
id|regs
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|regs
op_and_assign
op_complement
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|regs
comma
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|mc32_flush_rx_ring
c_func
(paren
id|lp
)paren
suffix:semicolon
id|mc32_flush_tx_ring
c_func
(paren
id|lp
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Update the statistics here. */
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the current statistics.&n; * This may be called with the card open or closed.&n; */
DECL|function|mc32_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|mc32_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;net_stats
suffix:semicolon
)brace
multiline_comment|/*&n; * Set or clear the multicast filter for this adaptor.&n; * num_addrs == -1&t;Promiscuous mode, receive all packets&n; * num_addrs == 0&t;Normal mode, clear multicast list&n; * num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets,&n; *&t;&t;&t;and do best-effort filtering.&n; */
DECL|function|mc32_set_multicast_list
r_static
r_void
id|mc32_set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|u16
id|filt
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Enable promiscuous mode */
id|filt
op_assign
l_int|1
suffix:semicolon
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|filt
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_count
OG
l_int|10
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|filt
op_assign
l_int|1
suffix:semicolon
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|filt
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
r_int
r_char
id|block
(braket
l_int|62
)braket
suffix:semicolon
r_int
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmc
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_int
id|i
suffix:semicolon
id|filt
op_assign
l_int|0
suffix:semicolon
id|block
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|block
(braket
l_int|0
)braket
op_assign
id|dev-&gt;mc_count
suffix:semicolon
id|bp
op_assign
id|block
op_plus
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|bp
comma
id|dmc-&gt;dmi_addr
comma
l_int|6
)paren
suffix:semicolon
id|bp
op_add_assign
l_int|6
suffix:semicolon
id|dmc
op_assign
id|dmc-&gt;next
suffix:semicolon
)brace
id|mc32_command
c_func
(paren
id|dev
comma
l_int|2
comma
id|block
comma
l_int|2
op_plus
l_int|6
op_star
id|dev-&gt;mc_count
)paren
suffix:semicolon
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|filt
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
id|filt
op_assign
l_int|0
suffix:semicolon
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|filt
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|variable|devicename
r_static
r_char
id|devicename
(braket
l_int|9
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|this_device
r_static
r_struct
id|device
id|this_device
op_assign
(brace
id|devicename
comma
multiline_comment|/* will be inserted by linux/drivers/net/mc32_init.c */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* I/O address, IRQ */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|mc32_probe
)brace
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|this_device
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|slot
suffix:semicolon
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
id|unregister_netdev
c_func
(paren
op_amp
id|this_device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t do this, we can&squot;t re-insmod it later.&n;&t; * Release irq/dma here, when you have jumpered versions and&n;&t; * allocate them in mc32_probe1().&n;&t; */
r_if
c_cond
(paren
id|this_device.priv
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
id|this_device.priv
suffix:semicolon
id|slot
op_assign
id|lp-&gt;slot
suffix:semicolon
id|mca_mark_as_unused
c_func
(paren
id|slot
)paren
suffix:semicolon
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|this_device.priv
comma
r_sizeof
(paren
r_struct
id|mc32_local
)paren
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|this_device.irq
comma
op_amp
id|this_device
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
