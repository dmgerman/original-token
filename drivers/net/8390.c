multiline_comment|/* 8390.c: A general NS8390 ethernet driver core for linux. */
multiline_comment|/*&n;&t;Written 1992-94 by Donald Becker.&n;  &n;&t;Copyright 1993 United States Government as represented by the&n;&t;Director, National Security Agency.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;&t;The author may be reached as becker@CESDIS.gsfc.nasa.gov, or C/O&n;&t;Center of Excellence in Space Data and Information Sciences&n;&t;   Code 930.5, Goddard Space Flight Center, Greenbelt MD 20771&n;  &n;  This is the chip-specific code for many 8390-based ethernet adaptors.&n;  This is not a complete driver, it must be combined with board-specific&n;  code such as ne.c, wd.c, 3c503.c, etc.&n;&n;  Changelog:&n;&n;  Paul Gortmaker&t;: remove set_bit lock, other cleanups.&n;  Paul Gortmaker&t;: add ei_get_8390_hdr() so we can pass skb&squot;s to &n;&t;&t;&t;  ei_block_input() for eth_io_copy_and_sum().&n;&n;  */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;8390.c:v1.10 9/23/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n;  Braindamage remaining:&n;  Much of this code should have been cleaned up, but every attempt &n;  has broken some clone part.&n;  &n;  Sources:&n;  The National Semiconductor LAN Databook, and the 3Com 3c503 databook.&n;  */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &quot;8390.h&quot;
multiline_comment|/* These are the operational function interfaces to board-specific&n;   routines.&n;&t;void reset_8390(struct device *dev)&n;&t;&t;Resets the board associated with DEV, including a hardware reset of&n;&t;&t;the 8390.  This is only called when there is a transmit timeout, and&n;&t;&t;it is always followed by 8390_init().&n;&t;void block_output(struct device *dev, int count, const unsigned char *buf,&n;&t;&t;&t;&t;&t;  int start_page)&n;&t;&t;Write the COUNT bytes of BUF to the packet buffer at START_PAGE.  The&n;&t;&t;&quot;page&quot; value uses the 8390&squot;s 256-byte pages.&n;&t;void get_8390_hdr(struct device *dev, struct e8390_hdr *hdr, int ring_page)&n;&t;&t;Read the 4 byte, page aligned 8390 header. *If* there is a&n;&t;&t;subsequent read, it will be of the rest of the packet.&n;&t;void block_input(struct device *dev, int count, struct sk_buff *skb, int ring_offset)&n;&t;&t;Read COUNT bytes from the packet buffer into the skb data area. Start &n;&t;&t;reading from RING_OFFSET, the address as the 8390 sees it.  This will always&n;&t;&t;follow the read of the 8390 header. &n;*/
DECL|macro|ei_reset_8390
mdefine_line|#define ei_reset_8390 (ei_local-&gt;reset_8390)
DECL|macro|ei_block_output
mdefine_line|#define ei_block_output (ei_local-&gt;block_output)
DECL|macro|ei_block_input
mdefine_line|#define ei_block_input (ei_local-&gt;block_input)
DECL|macro|ei_get_8390_hdr
mdefine_line|#define ei_get_8390_hdr (ei_local-&gt;get_8390_hdr)
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifdef EI_DEBUG
DECL|variable|ei_debug
r_int
id|ei_debug
op_assign
id|EI_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|ei_debug
r_int
id|ei_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef EI_PINGPONG
DECL|variable|ei_pingpong
r_static
r_int
id|ei_pingpong
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|ei_pingpong
r_static
r_int
id|ei_pingpong
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Max number of packets received at one Intr.&n;   Currently this may only be examined by a kernel debugger. */
DECL|variable|high_water_mark
r_static
r_int
id|high_water_mark
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Index to functions. */
r_static
r_void
id|ei_tx_intr
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_receive
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_rx_overrun
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Routines generic to NS8390-based boards. */
r_static
r_void
id|NS8390_trigger_send
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|length
comma
r_int
id|start_page
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
multiline_comment|/* Open/initialize the board.  This routine goes all-out, setting everything&n;   up anew at each open, even though many of these registers should only&n;   need to be set once at boot.&n;   */
DECL|function|ei_open
r_int
id|ei_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* This can&squot;t happen unless somebody forgot to call ethdev_init(). */
r_if
c_cond
(paren
id|ei_local
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: ei_open passed a non-existent device!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Opposite of above. Only used when &quot;ifconfig &lt;devname&gt; down&quot; is done. */
DECL|function|ei_close
r_int
id|ei_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ei_start_xmit
r_static
r_int
id|ei_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|length
comma
id|send_length
suffix:semicolon
multiline_comment|/*&n; *  We normally shouldn&squot;t be called if dev-&gt;tbusy is set, but the&n; *  existing code does anyway. If it has been too long since the&n; *  last Tx, we assume the board has died and kick it.&n; */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* Do timeouts, just like the 8003 driver. */
r_int
id|txsr
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
comma
id|isr
suffix:semicolon
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
id|TX_TIMEOUT
op_logical_or
(paren
id|tickssofar
OL
(paren
id|TX_TIMEOUT
op_plus
l_int|5
)paren
op_logical_and
op_logical_neg
(paren
id|txsr
op_amp
id|ENTSR_PTX
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|isr
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;start
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: xmit on stopped card&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|txsr
op_amp
id|ENTSR_ABT
)paren
ques
c_cond
l_string|&quot;excess collisions.&quot;
suffix:colon
(paren
id|isr
)paren
ques
c_cond
l_string|&quot;lost interrupt?&quot;
suffix:colon
l_string|&quot;cable problem?&quot;
comma
id|txsr
comma
id|isr
comma
id|tickssofar
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isr
op_logical_and
op_logical_neg
id|ei_local-&gt;stat.tx_packets
)paren
(brace
multiline_comment|/* The 8390 probably hasn&squot;t gotten on the cable yet. */
id|ei_local-&gt;interface_num
op_xor_assign
l_int|1
suffix:semicolon
multiline_comment|/* Try a different xcvr.  */
)brace
multiline_comment|/* Try to restart the card.  Perhaps the user has fixed something. */
id|ei_reset_8390
c_func
(paren
id|dev
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* Sending a NULL skb means some higher layer thinks we&squot;ve missed an&n;       tx-done interrupt. Caution: dev_tint() handles the cli()/sti()&n;       itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|length
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Mask interrupts from the ethercard. */
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Tx request while isr active.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ei_local-&gt;irqlock
op_assign
l_int|1
suffix:semicolon
id|send_length
op_assign
id|ETH_ZLEN
OL
id|length
ques
c_cond
id|length
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;pingpong
)paren
(brace
r_int
id|output_page
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
op_eq
l_int|0
)paren
(brace
id|output_page
op_assign
id|ei_local-&gt;tx_start_page
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|send_length
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|ei_local-&gt;tx2
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: idle transmitter tx2=%d, lasttx=%d, txing=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;txing
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ei_local-&gt;tx2
op_eq
l_int|0
)paren
(brace
id|output_page
op_assign
id|ei_local-&gt;tx_start_page
op_plus
l_int|6
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
id|send_length
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|ei_local-&gt;tx1
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: idle transmitter, tx1=%d, lasttx=%d, txing=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;txing
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We should never get here. */
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: No Tx buffers free. irq=%d tx1=%d tx2=%d last=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;interrupt
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;lasttx
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ei_block_output
c_func
(paren
id|dev
comma
id|length
comma
id|skb-&gt;data
comma
id|output_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei_local-&gt;txing
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|send_length
comma
id|output_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|output_page
op_eq
id|ei_local-&gt;tx_start_page
)paren
id|ei_local-&gt;tx1
op_assign
op_minus
l_int|1
comma
id|ei_local-&gt;lasttx
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|ei_local-&gt;tx2
op_assign
op_minus
l_int|1
comma
id|ei_local-&gt;lasttx
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_else
id|ei_local-&gt;txqueue
op_increment
suffix:semicolon
id|dev-&gt;tbusy
op_assign
(paren
id|ei_local-&gt;tx1
op_logical_and
id|ei_local-&gt;tx2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No pingpong, just a single Tx buffer. */
id|ei_block_output
c_func
(paren
id|dev
comma
id|length
comma
id|skb-&gt;data
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|send_length
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Turn 8390 interrupts back on. */
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the ether interface interrupts. */
DECL|function|ei_interrupt
r_void
id|ei_interrupt
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_int
id|e8390_base
suffix:semicolon
r_int
id|interrupts
comma
id|nr_serviced
op_assign
l_int|0
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;interrupt
op_logical_or
id|ei_local-&gt;irqlock
)paren
(brace
multiline_comment|/* The &quot;irqlock&quot; check is only for testing. */
id|printk
c_func
(paren
id|ei_local-&gt;irqlock
ques
c_cond
l_string|&quot;%s: Interrupted while interrupts are masked! isr=%#2x imr=%#2x.&bslash;n&quot;
suffix:colon
l_string|&quot;%s: Reentering the interrupt handler! isr=%#2x imr=%#2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_IMR
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Change to page 0 and read the intr status reg. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%s: interrupt(isr=%#2.2x).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
)paren
suffix:semicolon
multiline_comment|/* !!Assumption!! -- we stay in page 0.&t; Don&squot;t break this. */
r_while
c_loop
(paren
(paren
id|interrupts
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
)paren
op_ne
l_int|0
op_logical_and
op_increment
id|nr_serviced
OL
id|MAX_SERVICE
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;start
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: interrupt from stopped card&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|interrupts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_OVER
)paren
(brace
id|ei_rx_overrun
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|interrupts
op_amp
(paren
id|ENISR_RX
op_plus
id|ENISR_RX_ERR
)paren
)paren
(brace
multiline_comment|/* Got a good (?) packet. */
id|ei_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Push the next to-transmit packet through. */
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_TX
)paren
(brace
id|ei_tx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_COUNTERS
)paren
(brace
id|ei_local-&gt;stat.rx_frame_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_crc_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER1
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_missed_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER2
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_COUNTERS
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
)brace
multiline_comment|/* Ignore the transmit errs and reset intr for now. */
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_TX_ERR
)paren
(brace
id|outb_p
c_func
(paren
id|ENISR_TX_ERR
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
)brace
multiline_comment|/* Ignore any RDC interrupts that make it back to here. */
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_RDC
)paren
(brace
id|outb_p
c_func
(paren
id|ENISR_RDC
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts
op_logical_and
id|ei_debug
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_serviced
op_ge
id|MAX_SERVICE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Too much work at interrupt, status %#2.2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack. most intrs. */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unknown interrupt %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack. all intrs. */
)brace
)brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have finished a transmit: check for errors and then trigger the next&n;   packet to be sent. */
DECL|function|ei_tx_intr
r_static
r_void
id|ei_tx_intr
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_TX
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
r_if
c_cond
(paren
id|ei_local-&gt;pingpong
)paren
(brace
id|ei_local-&gt;txqueue
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ei_local-&gt;lasttx
op_ne
l_int|1
op_logical_and
id|ei_local-&gt;lasttx
op_ne
op_minus
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus last_tx_buffer %d, tx1=%d.&bslash;n&quot;
comma
id|ei_local-&gt;name
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;tx1
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx2
OG
l_int|0
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;tx_start_page
op_plus
l_int|6
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
op_minus
l_int|1
comma
id|ei_local-&gt;lasttx
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|ei_local-&gt;lasttx
op_assign
l_int|20
comma
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ei_local-&gt;tx2
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ei_local-&gt;lasttx
op_ne
l_int|2
op_logical_and
id|ei_local-&gt;lasttx
op_ne
op_minus
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus last_tx_buffer %d, tx2=%d.&bslash;n&quot;
comma
id|ei_local-&gt;name
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;tx2
)paren
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
OG
l_int|0
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|ei_local-&gt;lasttx
op_assign
l_int|10
comma
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: unexpected TX-done interrupt, lasttx=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;lasttx
)paren
suffix:semicolon
)brace
r_else
(brace
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Minimize Tx latency: update the statistics after we restart TXing. */
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_COL
)paren
id|ei_local-&gt;stat.collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_PTX
)paren
id|ei_local-&gt;stat.tx_packets
op_increment
suffix:semicolon
r_else
(brace
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_ABT
)paren
id|ei_local-&gt;stat.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_CRS
)paren
id|ei_local-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_FU
)paren
id|ei_local-&gt;stat.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_CDH
)paren
id|ei_local-&gt;stat.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_OWC
)paren
id|ei_local-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
)brace
id|mark_bh
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
DECL|function|ei_receive
r_static
r_void
id|ei_receive
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|rxing_page
comma
id|this_frame
comma
id|next_frame
comma
id|current_offset
suffix:semicolon
r_int
id|rx_pkt_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|e8390_pkt_hdr
id|rx_frame
suffix:semicolon
r_int
id|num_rx_pages
op_assign
id|ei_local-&gt;stop_page
op_minus
id|ei_local-&gt;rx_start_page
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|rx_pkt_count
OL
l_int|10
)paren
(brace
r_int
id|pkt_len
suffix:semicolon
multiline_comment|/* Get the rx page (incoming packet pointer). */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|rxing_page
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN1_CURPAG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/* Remove one frame from the ring.  Boundary is always a page behind. */
id|this_frame
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|this_frame
op_ge
id|ei_local-&gt;stop_page
)paren
id|this_frame
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
multiline_comment|/* Someday we&squot;ll omit the previous, iff we never get this message.&n;&t;&t;   (There is at least one clone claimed to have a problem.)  */
r_if
c_cond
(paren
id|ei_debug
OG
l_int|0
op_logical_and
id|this_frame
op_ne
id|ei_local-&gt;current_page
)paren
id|printk
c_func
(paren
l_string|&quot;%s: mismatched read page pointers %2x vs %2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|this_frame
comma
id|ei_local-&gt;current_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_frame
op_eq
id|rxing_page
)paren
multiline_comment|/* Read all the frames? */
r_break
suffix:semicolon
multiline_comment|/* Done for now */
id|current_offset
op_assign
id|this_frame
op_lshift
l_int|8
suffix:semicolon
id|ei_get_8390_hdr
c_func
(paren
id|dev
comma
op_amp
id|rx_frame
comma
id|this_frame
)paren
suffix:semicolon
id|pkt_len
op_assign
id|rx_frame.count
op_minus
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
suffix:semicolon
id|next_frame
op_assign
id|this_frame
op_plus
l_int|1
op_plus
(paren
(paren
id|pkt_len
op_plus
l_int|4
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Check for bogosity warned by 3c503 book: the status byte is never&n;&t;&t;   written.  This happened a lot during testing! This code should be&n;&t;&t;   cleaned up someday. */
r_if
c_cond
(paren
id|rx_frame.next
op_ne
id|next_frame
op_logical_and
id|rx_frame.next
op_ne
id|next_frame
op_plus
l_int|1
op_logical_and
id|rx_frame.next
op_ne
id|next_frame
op_minus
id|num_rx_pages
op_logical_and
id|rx_frame.next
op_ne
id|next_frame
op_plus
l_int|1
op_minus
id|num_rx_pages
)paren
(brace
id|ei_local-&gt;current_page
op_assign
id|rxing_page
suffix:semicolon
id|outb
c_func
(paren
id|ei_local-&gt;current_page
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_len
template_param
l_int|1518
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus packet size: %d, status=%#2x nxpg=%#2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_frame.count
comma
id|rx_frame.status
comma
id|rx_frame.next
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rx_frame.status
op_amp
l_int|0x0F
)paren
op_eq
id|ENRSR_RXOK
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* IP headers on 16 byte boundaries */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Make room */
id|ei_block_input
c_func
(paren
id|dev
comma
id|pkt_len
comma
id|skb
comma
id|current_offset
op_plus
r_sizeof
(paren
id|rx_frame
)paren
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_packets
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|errs
op_assign
id|rx_frame.status
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus packet: status=%#2x nxpg=%#2x size=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_frame.status
comma
id|rx_frame.next
comma
id|rx_frame.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errs
op_amp
id|ENRSR_FO
)paren
id|ei_local-&gt;stat.rx_fifo_errors
op_increment
suffix:semicolon
)brace
id|next_frame
op_assign
id|rx_frame.next
suffix:semicolon
multiline_comment|/* This _should_ never happen: it&squot;s here for avoiding bad clones. */
r_if
c_cond
(paren
id|next_frame
op_ge
id|ei_local-&gt;stop_page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: next frame inconsistency, %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|next_frame
)paren
suffix:semicolon
id|next_frame
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
)brace
id|ei_local-&gt;current_page
op_assign
id|next_frame
suffix:semicolon
id|outb_p
c_func
(paren
id|next_frame
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
)brace
multiline_comment|/* If any worth-while packets have been received, netif_rx()&n;       has done a mark_bh(NET_BH) for us and will work on them&n;       when we get to the bottom-half routine. */
multiline_comment|/* Record the maximum Rx packet queue. */
r_if
c_cond
(paren
id|rx_pkt_count
OG
id|high_water_mark
)paren
id|high_water_mark
op_assign
id|rx_pkt_count
suffix:semicolon
multiline_comment|/* We used to also ack ENISR_OVER here, but that would sometimes mask&n;    a real overrun, leaving the 8390 in a stopped state with rec&squot;vr off. */
id|outb_p
c_func
(paren
id|ENISR_RX
op_plus
id|ENISR_RX_ERR
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We have a receiver overrun: we have to kick the 8390 to get it started&n;   again.*/
DECL|function|ei_rx_overrun
r_static
r_void
id|ei_rx_overrun
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|reset_start_time
op_assign
id|jiffies
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* We should already be stopped and in page0.  Remove after testing. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Receiver overrun.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_over_errors
op_increment
suffix:semicolon
multiline_comment|/* The old Biro driver does dummy = inb_p( RBCR[01] ); at this point.&n;       It might mean something -- magic to speed up a reset?  A 8390 bug?*/
multiline_comment|/* Wait for the reset to complete.&t;This should happen almost instantly,&n;&t;   but could take up to 1.5msec in certain rare instances.  There is no&n;&t;   easy way of timing something in that range, so we use &squot;jiffies&squot; as&n;&t;   a sanity check. */
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
op_amp
id|ENISR_RESET
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|jiffies
op_minus
id|reset_start_time
OG
l_int|2
op_star
id|HZ
op_div
l_int|100
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset did not complete at ei_rx_overrun.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Remove packets right away. */
id|ei_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_OVER
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Generic 8390 insns to start up again, same as in open_8390(). */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_TXCONFIG
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* xmit on. */
)brace
DECL|function|get_stats
r_static
r_struct
id|enet_statistics
op_star
id|get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* If the card is stopped, just return the present stats. */
r_if
c_cond
(paren
id|dev-&gt;start
op_eq
l_int|0
)paren
r_return
op_amp
id|ei_local-&gt;stat
suffix:semicolon
multiline_comment|/* Read the counter registers, assuming we are in page 0. */
id|ei_local-&gt;stat.rx_frame_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_crc_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER1
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_missed_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER2
)paren
suffix:semicolon
r_return
op_amp
id|ei_local-&gt;stat
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set or clear the multicast filter for this adaptor.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
op_or
l_int|0x18
comma
id|ioaddr
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_list
)paren
(brace
multiline_comment|/* The multicast-accept list is initialized to accept-all, and we&n;&t;&t;   rely on higher-level filtering for now. */
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
op_or
l_int|0x08
comma
id|ioaddr
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
r_else
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|ioaddr
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the rest of the 8390 device structure. */
DECL|function|ethdev_init
r_int
id|ethdev_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_struct
id|ei_device
op_star
id|ei_local
suffix:semicolon
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ei_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ei_device
)paren
)paren
suffix:semicolon
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ei_local-&gt;pingpong
op_assign
id|ei_pingpong
suffix:semicolon
)brace
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|ei_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* This page of functions should be 8390 generic */
multiline_comment|/* Follow National Semi&squot;s recommendations for initializing the &quot;NIC&quot;. */
DECL|function|NS8390_init
r_void
id|NS8390_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|startp
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|endcfg
op_assign
id|ei_local-&gt;word16
ques
c_cond
(paren
l_int|0x48
op_or
id|ENDCFG_WTS
)paren
suffix:colon
l_int|0x48
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Follow National Semi&squot;s recommendations for initing the DP83902. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
)paren
suffix:semicolon
multiline_comment|/* 0x21 */
id|outb_p
c_func
(paren
id|endcfg
comma
id|e8390_base
op_plus
id|EN0_DCFG
)paren
suffix:semicolon
multiline_comment|/* 0x48 or 0x49 */
multiline_comment|/* Clear the remote byte count registers. */
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
multiline_comment|/* Set to monitor and loopback mode -- this is vital!. */
id|outb_p
c_func
(paren
id|E8390_RXOFF
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
multiline_comment|/* 0x20 */
id|outb_p
c_func
(paren
id|E8390_TXOFF
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* 0x02 */
multiline_comment|/* Set the transmit page and receive ring. */
id|outb_p
c_func
(paren
id|ei_local-&gt;tx_start_page
comma
id|e8390_base
op_plus
id|EN0_TPSR
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;rx_start_page
comma
id|e8390_base
op_plus
id|EN0_STARTPG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;stop_page
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
multiline_comment|/* 3c503 says 0x3f,NS0x26*/
id|ei_local-&gt;current_page
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
multiline_comment|/* assert boundary+1 */
id|outb_p
c_func
(paren
id|ei_local-&gt;stop_page
comma
id|e8390_base
op_plus
id|EN0_STOPPG
)paren
suffix:semicolon
multiline_comment|/* Clear the pending interrupts and mask. */
id|outb_p
c_func
(paren
l_int|0xFF
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
multiline_comment|/* Copy the station address into the DS8390 registers,&n;       and set the multicast hash bitmap to receive all multicasts. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
op_plus
id|E8390_STOP
comma
id|e8390_base
)paren
suffix:semicolon
multiline_comment|/* 0x61 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|e8390_base
op_plus
id|EN1_PHYS
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the multicast list to accept-all.  If we enable multicast&n;       the higher levels can do the filtering. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN1_MULT
op_plus
id|i
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|ei_local-&gt;rx_start_page
comma
id|e8390_base
op_plus
id|EN1_CURPAG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|startp
)paren
(brace
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_TXCONFIG
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* xmit on. */
multiline_comment|/* 3c503 TechMan says rxconfig only after the NIC is started. */
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
multiline_comment|/* rx on,  */
id|dev
op_member_access_from_pointer
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Get the multicast status right if this&n;&t;&t;&t;&t;&t;&t;&t;   was a reset. */
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Trigger a transmit start, assuming the length is valid. */
DECL|function|NS8390_trigger_send
r_static
r_void
id|NS8390_trigger_send
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|length
comma
r_int
id|start_page
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|e8390_base
)paren
op_amp
id|E8390_TRANS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: trigger_send() called with the transmitter busy.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|length
op_amp
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_TCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|length
op_rshift
l_int|8
comma
id|e8390_base
op_plus
id|EN0_TCNTHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|start_page
comma
id|e8390_base
op_plus
id|EN0_TPSR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_TRANS
op_plus
id|E8390_START
comma
id|e8390_base
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c 8390.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  c-indent-level: 4&n; *  tab-width: 4&n; * End:&n; */
eof
