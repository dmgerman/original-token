multiline_comment|/* 8390.c: A general NS8390 ethernet driver core for linux. */
multiline_comment|/*&n;&t;Written 1992-94 by Donald Becker.&n;  &n;&t;Copyright 1993 United States Government as represented by the&n;&t;Director, National Security Agency.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;&t;The author may be reached as becker@CESDIS.gsfc.nasa.gov, or C/O&n;&t;Center of Excellence in Space Data and Information Sciences&n;&t;   Code 930.5, Goddard Space Flight Center, Greenbelt MD 20771&n;  &n;  This is the chip-specific code for many 8390-based ethernet adaptors.&n;  This is not a complete driver, it must be combined with board-specific&n;  code such as ne.c, wd.c, 3c503.c, etc.&n;&n;  Seeing how at least eight drivers use this code, (not counting the&n;  PCMCIA ones either) it is easy to break some card by what seems like&n;  a simple innocent change. Please contact me or Donald if you think&n;  you have found something that needs changing. -- PG&n;&n;&n;  Changelog:&n;&n;  Paul Gortmaker&t;: remove set_bit lock, other cleanups.&n;  Paul Gortmaker&t;: add ei_get_8390_hdr() so we can pass skb&squot;s to &n;&t;&t;&t;  ei_block_input() for eth_io_copy_and_sum().&n;  Paul Gortmaker&t;: exchange static int ei_pingpong for a #define,&n;&t;&t;&t;  also add better Tx error handling.&n;  Paul Gortmaker&t;: rewrite Rx overrun handling as per NS specs.&n;  Alexey Kuznetsov&t;: use the 8390&squot;s six bit hash multicast filter.&n;  Paul Gortmaker&t;: tweak ANK&squot;s above multicast changes a bit.&n;  Paul Gortmaker&t;: update packet statistics for v2.1.x&n;  Alan Cox&t;&t;: support arbitary stupid port mappings on the&n;  &t;&t;&t;  68K Macintosh. Support &gt;16bit I/O spaces&n;  Paul Gortmaker&t;: add kmod support for auto-loading of the 8390&n;&t;&t;&t;  module by all drivers that require it.&n;  Alan Cox&t;&t;: Spinlocking work, added &squot;BUG_83C690&squot;&n;  Paul Gortmaker&t;: Separate out Tx timeout code from Tx path.&n;&n;  Sources:&n;  The National Semiconductor LAN Databook, and the 3Com 3c503 databook.&n;&n;  */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;8390.c:v1.10cvs 9/23/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
DECL|macro|NS8390_CORE
mdefine_line|#define NS8390_CORE
macro_line|#include &quot;8390.h&quot;
DECL|macro|BUG_83C690
mdefine_line|#define BUG_83C690
multiline_comment|/* These are the operational function interfaces to board-specific&n;   routines.&n;&t;void reset_8390(struct net_device *dev)&n;&t;&t;Resets the board associated with DEV, including a hardware reset of&n;&t;&t;the 8390.  This is only called when there is a transmit timeout, and&n;&t;&t;it is always followed by 8390_init().&n;&t;void block_output(struct net_device *dev, int count, const unsigned char *buf,&n;&t;&t;&t;&t;&t;  int start_page)&n;&t;&t;Write the COUNT bytes of BUF to the packet buffer at START_PAGE.  The&n;&t;&t;&quot;page&quot; value uses the 8390&squot;s 256-byte pages.&n;&t;void get_8390_hdr(struct net_device *dev, struct e8390_hdr *hdr, int ring_page)&n;&t;&t;Read the 4 byte, page aligned 8390 header. *If* there is a&n;&t;&t;subsequent read, it will be of the rest of the packet.&n;&t;void block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)&n;&t;&t;Read COUNT bytes from the packet buffer into the skb data area. Start &n;&t;&t;reading from RING_OFFSET, the address as the 8390 sees it.  This will always&n;&t;&t;follow the read of the 8390 header. &n;*/
DECL|macro|ei_reset_8390
mdefine_line|#define ei_reset_8390 (ei_local-&gt;reset_8390)
DECL|macro|ei_block_output
mdefine_line|#define ei_block_output (ei_local-&gt;block_output)
DECL|macro|ei_block_input
mdefine_line|#define ei_block_input (ei_local-&gt;block_input)
DECL|macro|ei_get_8390_hdr
mdefine_line|#define ei_get_8390_hdr (ei_local-&gt;get_8390_hdr)
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef ei_debug
DECL|variable|ei_debug
r_int
id|ei_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* Index to functions. */
r_static
r_void
id|ei_tx_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_tx_err
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_rx_overrun
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Routines generic to NS8390-based boards. */
r_static
r_void
id|NS8390_trigger_send
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|length
comma
r_int
id|start_page
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|do_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;SMP and the 8390 setup.&n; *&n; *&t;The 8390 isnt exactly designed to be multithreaded on RX/TX. There is&n; *&t;a page register that controls bank and packet buffer access. We guard&n; *&t;this with ei_local-&gt;page_lock. Nobody should assume or set the page other&n; *&t;than zero when the lock is not held. Lock holders must restore page 0&n; *&t;before unlocking. Even pure readers must take the lock to protect in &n; *&t;page 0.&n; *&n; *&t;To make life difficult the chip can also be very slow. We therefore can&squot;t&n; *&t;just use spinlocks. For the longer lockups we disable the irq the device&n; *&t;sits on and hold the lock. We must hold the lock because there is a dual&n; *&t;processor case other than interrupts (get stats/set multicast list in&n; *&t;parallel with each other and transmit).&n; *&n; *&t;Note: in theory we can just disable the irq on the card _but_ there is&n; *&t;a latency on SMP irq delivery. So we can easily go &quot;disable irq&quot; &quot;sync irqs&quot;&n; *&t;enter lock, take the queued irq. So we waddle instead of flying.&n; *&n; *&t;Finally by special arrangement for the purpose of being generally &n; *&t;annoying the transmit function is called bh atomic. That places&n; *&t;restrictions on the user context callers as disable_irq won&squot;t save&n; *&t;them.&n; */
"&f;"
multiline_comment|/**&n; * ei_open - Open/initialize the board.&n; * @dev: network device to initialize&n; *&n; * This routine goes all-out, setting everything&n; * up anew at each open, even though many of these registers should only&n; * need to be set once at boot.&n; */
DECL|function|ei_open
r_int
id|ei_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* This can&squot;t happen unless somebody forgot to call ethdev_init(). */
r_if
c_cond
(paren
id|ei_local
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: ei_open passed a non-existent device!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* The card I/O part of the driver (e.g. 3c503) can hook a Tx timeout&n;&t;    wrapper that does e.g. media check &amp; then calls ei_tx_timeout. */
r_if
c_cond
(paren
id|dev-&gt;tx_timeout
op_eq
l_int|NULL
)paren
id|dev-&gt;tx_timeout
op_assign
id|ei_tx_timeout
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;watchdog_timeo
op_le
l_int|0
)paren
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Grab the page lock so we own the register set, then call&n;&t; *&t;the init function.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the flag before we drop the lock, That way the IRQ arrives&n;&t;   after its set and we get no silly warnings */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_close - shut down network device&n; * @dev: network device to close&n; *&n; * Opposite of ei_open(). Only used when &quot;ifconfig &lt;devname&gt; down&quot; is done.&n; */
DECL|function|ei_close
r_int
id|ei_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Hold the page lock during close&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_tx_timeout - handle transmit time out condition&n; * @dev: network device which has apparently fallen asleep&n; *&n; * Called by kernel when device never acknowledges a transmit has&n; * completed (or failed) - i.e. never posted a Tx related interrupt.&n; */
DECL|function|ei_tx_timeout
r_void
id|ei_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|txsr
comma
id|isr
comma
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|txsr
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
id|isr
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|txsr
op_amp
id|ENTSR_ABT
)paren
ques
c_cond
l_string|&quot;excess collisions.&quot;
suffix:colon
(paren
id|isr
)paren
ques
c_cond
l_string|&quot;lost interrupt?&quot;
suffix:colon
l_string|&quot;cable problem?&quot;
comma
id|txsr
comma
id|isr
comma
id|tickssofar
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isr
op_logical_and
op_logical_neg
id|ei_local-&gt;stat.tx_packets
)paren
(brace
multiline_comment|/* The 8390 probably hasn&squot;t gotten on the cable yet. */
id|ei_local-&gt;interface_num
op_xor_assign
l_int|1
suffix:semicolon
multiline_comment|/* Try a different xcvr.  */
)brace
multiline_comment|/* Ugly but a reset can be slow, yet must be protected */
id|disable_irq_nosync
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
multiline_comment|/* Try to restart the card.  Perhaps the user has fixed something. */
id|ei_reset_8390
c_func
(paren
id|dev
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_start_xmit - begin packet transmission&n; * @skb: packet to be sent&n; * @dev: network device to which packet is sent&n; *&n; * Sends a packet to an 8390 network device.&n; */
DECL|function|ei_start_xmit
r_static
r_int
id|ei_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|length
comma
id|send_length
comma
id|output_page
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|length
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Mask interrupts from the ethercard. &n;&t;   SMP: We have to grab the lock here otherwise the IRQ handler&n;&t;   on another CPU can flip window and race the IRQ mask set. We end&n;&t;   up trashing the mcast filter not disabling irqs if we dont lock */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Slow phase with lock held.&n;&t; */
id|disable_irq_nosync
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|1
suffix:semicolon
id|send_length
op_assign
id|ETH_ZLEN
OL
id|length
ques
c_cond
id|length
suffix:colon
id|ETH_ZLEN
suffix:semicolon
macro_line|#ifdef EI_PINGPONG
multiline_comment|/*&n;&t; * We have two Tx slots available for use. Find the first free&n;&t; * slot, and then perform some sanity checks. With two Tx bufs,&n;&t; * you get very close to transmitting back-to-back packets. With&n;&t; * only one Tx buf, the transmitter sits idle while you reload the&n;&t; * card, leaving a substantial gap between each transmitted packet.&n;&t; */
r_if
c_cond
(paren
id|ei_local-&gt;tx1
op_eq
l_int|0
)paren
(brace
id|output_page
op_assign
id|ei_local-&gt;tx_start_page
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|send_length
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|ei_local-&gt;tx2
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: idle transmitter tx2=%d, lasttx=%d, txing=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;txing
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ei_local-&gt;tx2
op_eq
l_int|0
)paren
(brace
id|output_page
op_assign
id|ei_local-&gt;tx_start_page
op_plus
id|TX_1X_PAGES
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
id|send_length
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|ei_local-&gt;tx1
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: idle transmitter, tx1=%d, lasttx=%d, txing=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;txing
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We should never get here. */
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: No Tx buffers free! tx1=%d tx2=%d last=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;lasttx
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Okay, now upload the packet and trigger a send if the transmitter&n;&t; * isn&squot;t already sending. If it is busy, the interrupt handler will&n;&t; * trigger the send later, upon receiving a Tx done interrupt.&n;&t; */
id|ei_block_output
c_func
(paren
id|dev
comma
id|length
comma
id|skb-&gt;data
comma
id|output_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei_local-&gt;txing
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|send_length
comma
id|output_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|output_page
op_eq
id|ei_local-&gt;tx_start_page
)paren
(brace
id|ei_local-&gt;tx1
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ei_local-&gt;tx2
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
)brace
r_else
id|ei_local-&gt;txqueue
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
op_logical_and
id|ei_local-&gt;tx2
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else&t;/* EI_PINGPONG */
multiline_comment|/*&n;&t; * Only one Tx buffer in use. You need two Tx bufs to come close to&n;&t; * back-to-back transmits. Expect a 20 -&gt; 25% performance hit on&n;&t; * reasonable hardware if you only use one Tx buffer.&n;&t; */
id|ei_block_output
c_func
(paren
id|dev
comma
id|length
comma
id|skb-&gt;data
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|send_length
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;/* EI_PINGPONG */
multiline_comment|/* Turn 8390 interrupts back on. */
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|ei_local-&gt;stat.tx_bytes
op_add_assign
id|send_length
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/**&n; * ei_interrupt - handle the interrupts from an 8390&n; * @irq: interrupt number&n; * @dev_id: a pointer to the net_device&n; * @regs: unused&n; *&n; * Handle the ether interface interrupts. We pull packets from&n; * the 8390 via the card specific functions and fire them at the networking&n; * stack. We also handle transmit completions and wake the transmit path if&n; * neccessary. We also update the counters and do other housekeeping as&n; * needed.&n; */
DECL|function|ei_interrupt
r_void
id|ei_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_int
id|e8390_base
suffix:semicolon
r_int
id|interrupts
comma
id|nr_serviced
op_assign
l_int|0
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Protect the irq test too.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;irqlock
)paren
(brace
macro_line|#if 1 /* This might just be an interrupt for a PCI device sharing this line */
multiline_comment|/* The &quot;irqlock&quot; check is only for testing. */
id|printk
c_func
(paren
id|ei_local-&gt;irqlock
ques
c_cond
l_string|&quot;%s: Interrupted while interrupts are masked! isr=%#2x imr=%#2x.&bslash;n&quot;
suffix:colon
l_string|&quot;%s: Reentering the interrupt handler! isr=%#2x imr=%#2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_IMR
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Change to page 0 and read the intr status reg. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: interrupt(isr=%#2.2x).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
)paren
suffix:semicolon
multiline_comment|/* !!Assumption!! -- we stay in page 0.&t; Don&squot;t break this. */
r_while
c_loop
(paren
(paren
id|interrupts
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
)paren
op_ne
l_int|0
op_logical_and
op_increment
id|nr_serviced
OL
id|MAX_SERVICE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: interrupt from stopped card&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|interrupts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_OVER
)paren
id|ei_rx_overrun
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interrupts
op_amp
(paren
id|ENISR_RX
op_plus
id|ENISR_RX_ERR
)paren
)paren
(brace
multiline_comment|/* Got a good (?) packet. */
id|ei_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Push the next to-transmit packet through. */
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_TX
)paren
id|ei_tx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_TX_ERR
)paren
id|ei_tx_err
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_COUNTERS
)paren
(brace
id|ei_local-&gt;stat.rx_frame_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_crc_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER1
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_missed_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER2
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_COUNTERS
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
)brace
multiline_comment|/* Ignore any RDC interrupts that make it back to here. */
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_RDC
)paren
(brace
id|outb_p
c_func
(paren
id|ENISR_RDC
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts
op_logical_and
id|ei_debug
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_serviced
op_ge
id|MAX_SERVICE
)paren
(brace
multiline_comment|/* 0xFF is valid for a card removal */
r_if
c_cond
(paren
id|interrupts
op_ne
l_int|0xFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Too much work at interrupt, status %#2.2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack. most intrs. */
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: unknown interrupt %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack. all intrs. */
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_tx_err - handle transmitter error&n; * @dev: network device which threw the exception&n; *&n; * A transmitter error has happened. Most likely excess collisions (which&n; * is a fairly normal condition). If the error is one where the Tx will&n; * have been aborted, we try and send another one right away, instead of&n; * letting the failed packet sit and collect dust in the Tx buffer. This&n; * is a much better solution as it avoids kernel based Tx timeouts, and&n; * an unnecessary card reset.&n; *&n; * Called with lock held.&n; */
DECL|function|ei_tx_err
r_static
r_void
id|ei_tx_err
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_char
id|txsr
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
r_int
r_char
id|tx_was_aborted
op_assign
id|txsr
op_amp
(paren
id|ENTSR_ABT
op_plus
id|ENTSR_FU
)paren
suffix:semicolon
macro_line|#ifdef VERBOSE_ERROR_DUMP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: transmitter error (%#2x): &quot;
comma
id|dev-&gt;name
comma
id|txsr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_ABT
)paren
id|printk
c_func
(paren
l_string|&quot;excess-collisions &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_ND
)paren
id|printk
c_func
(paren
l_string|&quot;non-deferral &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CRS
)paren
id|printk
c_func
(paren
l_string|&quot;lost-carrier &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_FU
)paren
id|printk
c_func
(paren
l_string|&quot;FIFO-underrun &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CDH
)paren
id|printk
c_func
(paren
l_string|&quot;lost-heartbeat &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb_p
c_func
(paren
id|ENISR_TX_ERR
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
r_if
c_cond
(paren
id|tx_was_aborted
)paren
id|ei_tx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
(brace
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CRS
)paren
id|ei_local-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CDH
)paren
id|ei_local-&gt;stat.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_OWC
)paren
id|ei_local-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * ei_tx_intr - transmit interrupt handler&n; * @dev: network device for which tx intr is handled&n; *&n; * We have finished a transmit: check for errors and then trigger the next&n; * packet to be sent. Called with lock held.&n; */
DECL|function|ei_tx_intr
r_static
r_void
id|ei_tx_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|status
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_TX
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
macro_line|#ifdef EI_PINGPONG
multiline_comment|/*&n;&t; * There are two Tx buffers, see which one finished, and trigger&n;&t; * the send of another one if it exists.&n;&t; */
id|ei_local-&gt;txqueue
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ei_local-&gt;lasttx
op_ne
l_int|1
op_logical_and
id|ei_local-&gt;lasttx
op_ne
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bogus last_tx_buffer %d, tx1=%d.&bslash;n&quot;
comma
id|ei_local-&gt;name
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;tx1
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx2
OG
l_int|0
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;tx_start_page
op_plus
l_int|6
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
op_minus
l_int|1
comma
id|ei_local-&gt;lasttx
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|ei_local-&gt;lasttx
op_assign
l_int|20
comma
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ei_local-&gt;tx2
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ei_local-&gt;lasttx
op_ne
l_int|2
op_logical_and
id|ei_local-&gt;lasttx
op_ne
op_minus
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus last_tx_buffer %d, tx2=%d.&bslash;n&quot;
comma
id|ei_local-&gt;name
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;tx2
)paren
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
OG
l_int|0
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|ei_local-&gt;lasttx
op_assign
l_int|10
comma
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|//&t;else printk(KERN_WARNING &quot;%s: unexpected TX-done interrupt, lasttx=%d.&bslash;n&quot;,
singleline_comment|//&t;&t;&t;dev-&gt;name, ei_local-&gt;lasttx);
macro_line|#else&t;/* EI_PINGPONG */
multiline_comment|/*&n;&t; *  Single Tx buffer: mark it free so another packet can be loaded.&n;&t; */
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Minimize Tx latency: update the statistics after we restart TXing. */
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_COL
)paren
id|ei_local-&gt;stat.collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_PTX
)paren
id|ei_local-&gt;stat.tx_packets
op_increment
suffix:semicolon
r_else
(brace
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_ABT
)paren
(brace
id|ei_local-&gt;stat.tx_aborted_errors
op_increment
suffix:semicolon
id|ei_local-&gt;stat.collisions
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_CRS
)paren
id|ei_local-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_FU
)paren
id|ei_local-&gt;stat.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_CDH
)paren
id|ei_local-&gt;stat.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_OWC
)paren
id|ei_local-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
)brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_receive - receive some packets&n; * @dev: network device with which receive will be run&n; *&n; * We have a good packet(s), get it/them out of the buffers. &n; * Called with lock held.&n; */
DECL|function|ei_receive
r_static
r_void
id|ei_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_char
id|rxing_page
comma
id|this_frame
comma
id|next_frame
suffix:semicolon
r_int
r_int
id|current_offset
suffix:semicolon
r_int
id|rx_pkt_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|e8390_pkt_hdr
id|rx_frame
suffix:semicolon
r_int
id|num_rx_pages
op_assign
id|ei_local-&gt;stop_page
op_minus
id|ei_local-&gt;rx_start_page
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|rx_pkt_count
OL
l_int|10
)paren
(brace
r_int
id|pkt_len
comma
id|pkt_stat
suffix:semicolon
multiline_comment|/* Get the rx page (incoming packet pointer). */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|rxing_page
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN1_CURPAG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/* Remove one frame from the ring.  Boundary is always a page behind. */
id|this_frame
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|this_frame
op_ge
id|ei_local-&gt;stop_page
)paren
id|this_frame
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
multiline_comment|/* Someday we&squot;ll omit the previous, iff we never get this message.&n;&t;&t;   (There is at least one clone claimed to have a problem.)  &n;&t;&t;   &n;&t;&t;   Keep quiet if it looks like a card removal. One problem here&n;&t;&t;   is that some clones crash in roughly the same way.&n;&t;&t; */
r_if
c_cond
(paren
id|ei_debug
OG
l_int|0
op_logical_and
id|this_frame
op_ne
id|ei_local-&gt;current_page
op_logical_and
(paren
id|this_frame
op_ne
l_int|0x0
op_logical_or
id|rxing_page
op_ne
l_int|0xFF
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: mismatched read page pointers %2x vs %2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|this_frame
comma
id|ei_local-&gt;current_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_frame
op_eq
id|rxing_page
)paren
multiline_comment|/* Read all the frames? */
r_break
suffix:semicolon
multiline_comment|/* Done for now */
id|current_offset
op_assign
id|this_frame
op_lshift
l_int|8
suffix:semicolon
id|ei_get_8390_hdr
c_func
(paren
id|dev
comma
op_amp
id|rx_frame
comma
id|this_frame
)paren
suffix:semicolon
id|pkt_len
op_assign
id|rx_frame.count
op_minus
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
suffix:semicolon
id|pkt_stat
op_assign
id|rx_frame.status
suffix:semicolon
id|next_frame
op_assign
id|this_frame
op_plus
l_int|1
op_plus
(paren
(paren
id|pkt_len
op_plus
l_int|4
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Check for bogosity warned by 3c503 book: the status byte is never&n;&t;&t;   written.  This happened a lot during testing! This code should be&n;&t;&t;   cleaned up someday. */
r_if
c_cond
(paren
id|rx_frame.next
op_ne
id|next_frame
op_logical_and
id|rx_frame.next
op_ne
id|next_frame
op_plus
l_int|1
op_logical_and
id|rx_frame.next
op_ne
id|next_frame
op_minus
id|num_rx_pages
op_logical_and
id|rx_frame.next
op_ne
id|next_frame
op_plus
l_int|1
op_minus
id|num_rx_pages
)paren
(brace
id|ei_local-&gt;current_page
op_assign
id|rxing_page
suffix:semicolon
id|outb
c_func
(paren
id|ei_local-&gt;current_page
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_len
template_param
l_int|1518
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bogus packet size: %d, status=%#2x nxpg=%#2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_frame.count
comma
id|rx_frame.status
comma
id|rx_frame.next
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
id|ei_local-&gt;stat.rx_length_errors
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|pkt_stat
op_amp
l_int|0x0F
)paren
op_eq
id|ENRSR_RXOK
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* IP headers on 16 byte boundaries */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Make room */
id|ei_block_input
c_func
(paren
id|dev
comma
id|pkt_len
comma
id|skb
comma
id|current_offset
op_plus
r_sizeof
(paren
id|rx_frame
)paren
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_packets
op_increment
suffix:semicolon
id|ei_local-&gt;stat.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
r_if
c_cond
(paren
id|pkt_stat
op_amp
id|ENRSR_PHY
)paren
id|ei_local-&gt;stat.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bogus packet: status=%#2x nxpg=%#2x size=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_frame.status
comma
id|rx_frame.next
comma
id|rx_frame.count
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* NB: The NIC counts CRC, frame and missed errors. */
r_if
c_cond
(paren
id|pkt_stat
op_amp
id|ENRSR_FO
)paren
id|ei_local-&gt;stat.rx_fifo_errors
op_increment
suffix:semicolon
)brace
id|next_frame
op_assign
id|rx_frame.next
suffix:semicolon
multiline_comment|/* This _should_ never happen: it&squot;s here for avoiding bad clones. */
r_if
c_cond
(paren
id|next_frame
op_ge
id|ei_local-&gt;stop_page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: next frame inconsistency, %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|next_frame
)paren
suffix:semicolon
id|next_frame
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
)brace
id|ei_local-&gt;current_page
op_assign
id|next_frame
suffix:semicolon
id|outb_p
c_func
(paren
id|next_frame
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
)brace
multiline_comment|/* We used to also ack ENISR_OVER here, but that would sometimes mask&n;&t;   a real overrun, leaving the 8390 in a stopped state with rec&squot;vr off. */
id|outb_p
c_func
(paren
id|ENISR_RX
op_plus
id|ENISR_RX_ERR
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_rx_overrun - handle receiver overrun&n; * @dev: network device which threw exception&n; *&n; * We have a receiver overrun: we have to kick the 8390 to get it started&n; * again. Problem is that you have to kick it exactly as NS prescribes in&n; * the updated datasheets, or &quot;the NIC may act in an unpredictable manner.&quot;&n; * This includes causing &quot;the NIC to defer indefinitely when it is stopped&n; * on a busy network.&quot;  Ugh.&n; * Called with lock held. Don&squot;t call this with the interrupts off or your&n; * computer will hate you - it takes 10ms or so. &n; */
DECL|function|ei_rx_overrun
r_static
r_void
id|ei_rx_overrun
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|was_txing
comma
id|must_resend
op_assign
l_int|0
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;&t; * Record whether a Tx was in progress and then issue the&n;&t; * stop command.&n;&t; */
id|was_txing
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|E8390_CMD
)paren
op_amp
id|E8390_TRANS
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Receiver overrun.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_over_errors
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * Wait a full Tx time (1.2ms) + some guard time, NS says 1.6ms total.&n;&t; * Early datasheets said to poll the reset bit, but now they say that&n;&t; * it &quot;is not a reliable indicator and subsequently should be ignored.&quot;&n;&t; * We wait at least 10ms.&n;&t; */
id|udelay
c_func
(paren
l_int|10
op_star
l_int|1000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset RBCR[01] back to zero as per magic incantation.&n;&t; */
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if any Tx was interrupted or not. According to NS, this&n;&t; * step is vital, and skipping it will cause no end of havoc.&n;&t; */
r_if
c_cond
(paren
id|was_txing
)paren
(brace
r_int
r_char
id|tx_completed
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
op_amp
(paren
id|ENISR_TX
op_plus
id|ENISR_TX_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_completed
)paren
id|must_resend
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Have to enter loopback mode and then restart the NIC before&n;&t; * you are allowed to slurp packets up off the ring.&n;&t; */
id|outb_p
c_func
(paren
id|E8390_TXOFF
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the Rx ring of all the debris, and ack the interrupt.&n;&t; */
id|ei_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_OVER
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Leave loopback mode, and resend any packet that got stopped.&n;&t; */
id|outb_p
c_func
(paren
id|E8390_TXCONFIG
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|must_resend
)paren
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
op_plus
id|E8390_TRANS
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Collect the stats. This is called unlocked and from several contexts.&n; */
DECL|function|get_stats
r_static
r_struct
id|net_device_stats
op_star
id|get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* If the card is stopped, just return the present stats. */
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
)paren
r_return
op_amp
id|ei_local-&gt;stat
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Read the counter registers, assuming we are in page 0. */
id|ei_local-&gt;stat.rx_frame_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_crc_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER1
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_missed_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER2
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_amp
id|ei_local-&gt;stat
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the given Autodin II CRC value with another data byte.&n; */
DECL|function|update_crc
r_static
r_inline
id|u32
id|update_crc
c_func
(paren
id|u8
id|byte
comma
id|u32
id|current_crc
)paren
(brace
r_int
id|bit
suffix:semicolon
id|u8
id|ah
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|bit
OL
l_int|8
suffix:semicolon
id|bit
op_increment
)paren
(brace
id|u8
id|carry
op_assign
(paren
id|current_crc
op_rshift
l_int|31
)paren
suffix:semicolon
id|current_crc
op_lshift_assign
l_int|1
suffix:semicolon
id|ah
op_assign
(paren
(paren
id|ah
op_lshift
l_int|1
)paren
op_or
id|carry
)paren
op_xor
id|byte
suffix:semicolon
r_if
c_cond
(paren
id|ah
op_amp
l_int|1
)paren
id|current_crc
op_xor_assign
l_int|0x04C11DB7
suffix:semicolon
multiline_comment|/* CRC polynomial */
id|ah
op_rshift_assign
l_int|1
suffix:semicolon
id|byte
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|current_crc
suffix:semicolon
)brace
multiline_comment|/*&n; * Form the 64 bit 8390 multicast table from the linked list of addresses&n; * associated with this dev structure.&n; */
DECL|function|make_mc_bits
r_static
r_inline
r_void
id|make_mc_bits
c_func
(paren
id|u8
op_star
id|bits
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|crc
suffix:semicolon
r_if
c_cond
(paren
id|dmi-&gt;dmi_addrlen
op_ne
id|ETH_ALEN
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: invalid multicast address length given.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* initial CRC value */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|crc
op_assign
id|update_crc
c_func
(paren
id|dmi-&gt;dmi_addr
(braket
id|i
)braket
comma
id|crc
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * The 8390 uses the 6 most significant bits of the&n;&t;&t; * CRC to index the multicast table.&n;&t;&t; */
id|bits
(braket
id|crc
op_rshift
l_int|29
)braket
op_or_assign
(paren
l_int|1
op_lshift
(paren
(paren
id|crc
op_rshift
l_int|26
)paren
op_amp
l_int|7
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * do_set_multicast_list - set/clear multicast filter&n; * @dev: net device for which multicast filter is adjusted&n; *&n; *&t;Set or clear the multicast filter for this adaptor. May be called&n; *&t;from a BH in 2.1.x. Must be called with lock held. &n; */
DECL|function|do_set_multicast_list
r_static
r_void
id|do_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|ei_local-&gt;mcfilter
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mc_list
)paren
id|make_mc_bits
c_func
(paren
id|ei_local-&gt;mcfilter
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
id|ei_local-&gt;mcfilter
comma
l_int|0xFF
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* mcast set to accept-all */
multiline_comment|/* &n;&t; * DP8390 manuals don&squot;t specify any magic sequence for altering&n;&t; * the multicast regs on an already running card. To be safe, we&n;&t; * ensure multicast mode is off prior to loading up the new hash&n;&t; * table. If this proves to be not enough, we can always resort&n;&t; * to stopping the NIC, loading the table and then restarting.&n;&t; *&n;&t; * Bug Alert!  The MC regs on the SMC 83C690 (SMC Elite and SMC &n;&t; * Elite16) appear to be write-only. The NS 8390 data sheet lists&n;&t; * them as r/w so this is a bug.  The SMC 83C790 (SMC Ultra and&n;&t; * Ultra32 EISA) appears to have this bug fixed.&n;&t; */
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|ei_local-&gt;mcfilter
(braket
id|i
)braket
comma
id|e8390_base
op_plus
id|EN1_MULT_SHIFT
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#ifndef BUG_83C690
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN1_MULT_SHIFT
c_func
(paren
id|i
)paren
)paren
op_ne
id|ei_local-&gt;mcfilter
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Multicast filter read/write mismap %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
op_or
l_int|0x18
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
op_logical_or
id|dev-&gt;mc_list
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
op_or
l_int|0x08
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
r_else
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called without lock held. This is invoked from user context and may&n; *&t;be parallel to just about everything else. Its also fairly quick and&n; *&t;not called too often. Must protect against both bh and irq users&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|do_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ethdev_init - init rest of 8390 device struct&n; * @dev: network device structure to init&n; *&n; * Initialize the rest of the 8390 device structure.  Do NOT __init&n; * this, as it is used by 8390 based modular drivers too.&n; */
DECL|function|ethdev_init
r_int
id|ethdev_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_struct
id|ei_device
op_star
id|ei_local
suffix:semicolon
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ei_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ei_device
)paren
)paren
suffix:semicolon
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
)brace
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|ei_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* This page of functions should be 8390 generic */
multiline_comment|/* Follow National Semi&squot;s recommendations for initializing the &quot;NIC&quot;. */
multiline_comment|/**&n; * NS8390_init - initialize 8390 hardware&n; * @dev: network device to initialize&n; * @startp: boolean.  non-zero value to initiate chip processing&n; *&n; *&t;Must be called with lock held.&n; */
DECL|function|NS8390_init
r_void
id|NS8390_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|startp
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|endcfg
op_assign
id|ei_local-&gt;word16
ques
c_cond
(paren
l_int|0x48
op_or
id|ENDCFG_WTS
op_or
(paren
id|ei_local-&gt;bigendian
ques
c_cond
id|ENDCFG_BOS
suffix:colon
l_int|0
)paren
)paren
suffix:colon
l_int|0x48
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
op_ne
l_int|4
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;8390.c: header struct mispacked&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Follow National Semi&squot;s recommendations for initing the DP83902. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/* 0x21 */
id|outb_p
c_func
(paren
id|endcfg
comma
id|e8390_base
op_plus
id|EN0_DCFG
)paren
suffix:semicolon
multiline_comment|/* 0x48 or 0x49 */
multiline_comment|/* Clear the remote byte count registers. */
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
multiline_comment|/* Set to monitor and loopback mode -- this is vital!. */
id|outb_p
c_func
(paren
id|E8390_RXOFF
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
multiline_comment|/* 0x20 */
id|outb_p
c_func
(paren
id|E8390_TXOFF
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* 0x02 */
multiline_comment|/* Set the transmit page and receive ring. */
id|outb_p
c_func
(paren
id|ei_local-&gt;tx_start_page
comma
id|e8390_base
op_plus
id|EN0_TPSR
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;rx_start_page
comma
id|e8390_base
op_plus
id|EN0_STARTPG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;stop_page
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
multiline_comment|/* 3c503 says 0x3f,NS0x26*/
id|ei_local-&gt;current_page
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
multiline_comment|/* assert boundary+1 */
id|outb_p
c_func
(paren
id|ei_local-&gt;stop_page
comma
id|e8390_base
op_plus
id|EN0_STOPPG
)paren
suffix:semicolon
multiline_comment|/* Clear the pending interrupts and mask. */
id|outb_p
c_func
(paren
l_int|0xFF
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
multiline_comment|/* Copy the station address into the DS8390 registers. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/* 0x61 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|e8390_base
op_plus
id|EN1_PHYS_SHIFT
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN1_PHYS_SHIFT
c_func
(paren
id|i
)paren
)paren
op_ne
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Hw. address read/write mismap %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
id|outb_p
c_func
(paren
id|ei_local-&gt;rx_start_page
comma
id|e8390_base
op_plus
id|EN1_CURPAG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|startp
)paren
(brace
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_TXCONFIG
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* xmit on. */
multiline_comment|/* 3c503 TechMan says rxconfig only after the NIC is started. */
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
multiline_comment|/* rx on,  */
id|do_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* (re)load the mcast table */
)brace
)brace
multiline_comment|/* Trigger a transmit start, assuming the length is valid. &n;   Always called with the page lock held */
DECL|function|NS8390_trigger_send
r_static
r_void
id|NS8390_trigger_send
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|length
comma
r_int
id|start_page
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
id|__attribute
c_func
(paren
(paren
id|unused
)paren
)paren
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|e8390_base
)paren
op_amp
id|E8390_TRANS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: trigger_send() called with the transmitter busy.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|length
op_amp
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_TCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|length
op_rshift
l_int|8
comma
id|e8390_base
op_plus
id|EN0_TCNTHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|start_page
comma
id|e8390_base
op_plus
id|EN0_TPSR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_TRANS
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
)brace
DECL|variable|ei_open
id|EXPORT_SYMBOL
c_func
(paren
id|ei_open
)paren
suffix:semicolon
DECL|variable|ei_close
id|EXPORT_SYMBOL
c_func
(paren
id|ei_close
)paren
suffix:semicolon
DECL|variable|ei_interrupt
id|EXPORT_SYMBOL
c_func
(paren
id|ei_interrupt
)paren
suffix:semicolon
DECL|variable|ei_tx_timeout
id|EXPORT_SYMBOL
c_func
(paren
id|ei_tx_timeout
)paren
suffix:semicolon
DECL|variable|ethdev_init
id|EXPORT_SYMBOL
c_func
(paren
id|ethdev_init
)paren
suffix:semicolon
DECL|variable|NS8390_init
id|EXPORT_SYMBOL
c_func
(paren
id|NS8390_init
)paren
suffix:semicolon
macro_line|#if defined(MODULE)
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c 8390.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  c-indent-level: 4&n; *  tab-width: 4&n; * End:&n; */
eof
