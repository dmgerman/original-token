multiline_comment|/* arcnet.c&n;&t;Written 1994-95 by Avery Pennarun, derived from skeleton.c by&n;        Donald Becker.&n;&n;&t;Contact Avery at: apenwarr@tourism.807-city.on.ca or&n;&t;RR #5 Pole Line Road, Thunder Bay, ON, Canada P7C 5M9&n;&t;&n;&t;**********************&n;&n;&t;skeleton.c Written 1993 by Donald Becker.&n;&t;Copyright 1993 United States Government as represented by the&n;        Director, National Security Agency.  This software may only be used&n;        and distributed according to the terms of the GNU Public License as&n;        modified by SRC, incorporated herein by reference.&n;         &n;&t;**********************&n;&n;&t;v1.01 (95/03/24)&n;&t;  - Fixed some IPX-related bugs. (Thanks to Tomasz Motylewski&n;            &lt;motyl@tichy.ch.uj.edu.pl&gt; for the patches to make arcnet work&n;            with dosemu!)&n;&t;v1.0 (95/02/15)&n;&t;  - Initial non-alpha release.&n;&t;&n;         &n;&t;TO DO:&n;&t;&n;         - Test in systems with NON-ARCnet network cards, just to see if&n;           autoprobe kills anything.  With any luck, it won&squot;t.  (It&squot;s pretty&n;           careful.)&n;           &t;- Except some unfriendly NE2000&squot;s die. (as of 0.40-ALPHA)&n;         - cards with shared memory that can be &quot;turned off?&quot;&n;         - NFS mount freezes after several megabytes to SOSS for DOS. &n; &t;   unmount/remount works.  Is this arcnet-specific?  I don&squot;t know.&n; &t; - Add support for the various stupid bugs (&quot;I didn&squot;t read the RFC&quot;&n;           syndrome) in Windows for Workgroups and LanMan.&n; */
multiline_comment|/**************************************************************************/
multiline_comment|/* define this if you want to use the new but possibly dangerous ioprobe&n; * If you get lockups right after status5, you probably need&n; * to undefine this.  It should make more cards probe correctly,&n; * I hope.&n; */
DECL|macro|DANGER_PROBE
mdefine_line|#define DANGER_PROBE
multiline_comment|/* define this if you want to use the &quot;extra delays&quot; which were removed&n; * in 0.41 since they seemed needless.&n; */
DECL|macro|EXTRA_DELAYS
macro_line|#undef EXTRA_DELAYS
multiline_comment|/* undefine this if you want to use the non-IRQ-driven transmitter. (possibly&n; * safer, although it takes more CPU time and IRQ_XMIT seems fine right now)&n; */
DECL|macro|IRQ_XMIT
mdefine_line|#define IRQ_XMIT
multiline_comment|/* define this for &quot;careful&quot; transmitting.  Try with and without if you have&n; * problems.  If you use IRQ_XMIT, do NOT define this.&n; */
DECL|macro|CAREFUL_XMIT
macro_line|#undef CAREFUL_XMIT
multiline_comment|/* define this for an extra-careful memory detect.  This should work all&n; * the time now, but you never know.&n; */
DECL|macro|STRICT_MEM_DETECT
mdefine_line|#define STRICT_MEM_DETECT
multiline_comment|/* define this to use the &quot;old-style&quot; limited MTU by default.  It basically&n; * disables packet splitting.  ifconfig can still be used to reset the MTU.&n; *&n; * leave this disabled if possible, so it will use ethernet defaults,&n; * which is our goal.&n; */
DECL|macro|LIMIT_MTU
macro_line|#undef LIMIT_MTU
multiline_comment|/* define this if you have a problem with the card getting &quot;stuck&quot; now and&n; * then, which can only be fixed by a reboot or resetting the card manually&n; * via ifconfig up/down.  ARCnet will set a timer function which is called&n; * 8 times every second.&n; *&n; * This should no longer be necessary.  if you experience &quot;stuck&quot; ARCnet&n; * drivers, please email apenwarr@tourism.807-city.on.ca or I will remove&n; * this feature in a future release.&n; */
DECL|macro|USE_TIMER_HANDLER
macro_line|#undef USE_TIMER_HANDLER
multiline_comment|/**************************************************************************/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;arcnet.c:v1.01 95/03/24 Avery Pennarun &lt;apenwarr@tourism.807-city.on.ca&gt;&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n;  Sources:&n;&t;Crynwr arcnet.com/arcether.com packet drivers.&n;&t;arcnet.c v0.00 dated 1/1/94 and apparently by&n;&t;&t;Donald Becker - it didn&squot;t work :)&n;&t;skeleton.c v0.05 dated 11/16/93 by Donald Becker&n;&t;&t;(from Linux Kernel 1.1.45)&n;&t;...I sure wish I had the ARCnet data sheets right about now!&n;&t;RFC&squot;s 1201 and 1051 (mostly 1201) - re: ARCnet IP packets&n;&t;net/inet/eth.c (from kernel 1.1.50) for header-building info...&n;&t;Alternate Linux ARCnet source by V.Shergin &lt;vsher@sao.stavropol.su&gt;&n;&t;Textual information and more alternate source from Joachim Koenig&n;&t;&t;&lt;jojo@repas.de&gt;&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif /* MODULE */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;arp.h&quot;
multiline_comment|/* debug levels:&n; * D_OFF&t;production&n; * D_NORMAL&t;verification&n; * D_INIT&t;show init/detect messages&n; * D_DURING&t;show messages during normal use (ie interrupts)&n; * D_DATA   show packets data from skb&squot;s, not on Arcnet card&n; * D_TX&t;&t;show tx packets&n; * D_RX&t;&t;show tx+rx packets&n; */
DECL|macro|D_OFF
mdefine_line|#define D_OFF&t;&t;0
DECL|macro|D_NORMAL
mdefine_line|#define D_NORMAL&t;1
DECL|macro|D_INIT
mdefine_line|#define&t;D_INIT&t;&t;2
DECL|macro|D_EXTRA
mdefine_line|#define D_EXTRA&t;&t;3
DECL|macro|D_DURING
mdefine_line|#define D_DURING&t;4
DECL|macro|D_DATA
mdefine_line|#define D_DATA&t;&t;6
DECL|macro|D_TX
mdefine_line|#define D_TX&t;&t;8
DECL|macro|D_RX
mdefine_line|#define D_RX&t;&t;9
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG &t;D_INIT
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
macro_line|#ifndef HAVE_AUTOIRQ
multiline_comment|/* From auto_irq.c, in ioport.h for later versions. */
r_extern
r_void
id|autoirq_setup
c_func
(paren
r_int
id|waittime
)paren
suffix:semicolon
r_extern
r_int
id|autoirq_report
c_func
(paren
r_int
id|waittime
)paren
suffix:semicolon
multiline_comment|/* The map from IRQ number (as passed to the interrupt handler) to&n;   &squot;struct device&squot;. */
r_extern
r_struct
id|device
op_star
id|irq2dev_map
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifndef HAVE_PORTRESERVE
DECL|macro|check_region
mdefine_line|#define check_region(ioaddr, size) &t;&t;0
DECL|macro|request_region
mdefine_line|#define&t;request_region(ioaddr, size)&t;&t;do ; while (0)
macro_line|#endif
multiline_comment|/* macro to simplify debug checking */
DECL|macro|BUGLVL
mdefine_line|#define BUGLVL(x) if (net_debug&gt;=x)
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|ETHERCARD_TOTAL_SIZE
mdefine_line|#define ETHERCARD_TOTAL_SIZE&t;16
multiline_comment|/* Handy defines for ARCnet specific stuff */
multiline_comment|/* COM 9026 (?) --&gt; ARCnet register addresses */
DECL|macro|INTMASK
mdefine_line|#define INTMASK&t;(ioaddr+0)&t;&t;/* writable */
DECL|macro|STATUS
mdefine_line|#define STATUS&t;(ioaddr+0)&t;&t;/* readable */
DECL|macro|COMMAND
mdefine_line|#define COMMAND (ioaddr+1)&t;/* writable, returns random vals on read (?) */
DECL|macro|RESET
mdefine_line|#define RESET  (ioaddr+8)&t;&t;/* software reset writable */
multiline_comment|/* time needed for various things (in clock ticks, 1/100 sec) */
DECL|macro|RESETtime
mdefine_line|#define RESETtime 40&t;&t;/* reset */
DECL|macro|XMITtime
mdefine_line|#define XMITtime 10&t;&t;/* send (?) */
DECL|macro|ACKtime
mdefine_line|#define ACKtime 10&t;&t;/* acknowledge (?) */
multiline_comment|/* these are the max/min lengths of packet data. (including&n;&t; * ClientData header)&n;&t; * note: packet sizes 250, 251, 252 are impossible (God knows why)&n;&t; *  so exception packets become necessary.&n;&t; *&n;&t; * These numbers are compared with the length of the full packet,&n;&t; * including ClientData header.&n;&t; */
DECL|macro|MTU
mdefine_line|#define MTU&t;(253+EXTRA_CLIENTDATA)  /* normal packet max size */
DECL|macro|MinTU
mdefine_line|#define MinTU&t;(257+EXTRA_CLIENTDATA)&t;/* extended packet min size */
DECL|macro|XMTU
mdefine_line|#define XMTU&t;(508+EXTRA_CLIENTDATA)  /* extended packet max size */
multiline_comment|/* status/interrupt mask bit fields */
DECL|macro|TXFREEflag
mdefine_line|#define TXFREEflag&t;0x001            /* transmitter available */
DECL|macro|TXACKflag
mdefine_line|#define TXACKflag       0x002            /* transmitted msg. ackd */
DECL|macro|RECONflag
mdefine_line|#define RECONflag       0x004            /* system reconfigured */
DECL|macro|TESTflag
mdefine_line|#define TESTflag        0x008            /* test flag */
DECL|macro|RESETflag
mdefine_line|#define RESETflag       0x010            /* power-on-reset */
DECL|macro|RES1flag
mdefine_line|#define RES1flag        0x020            /* unused */
DECL|macro|RES2flag
mdefine_line|#define RES2flag        0x040            /* unused */
DECL|macro|NORXflag
mdefine_line|#define NORXflag        0x080            /* receiver inhibited */
multiline_comment|/* in the command register, the following bits have these meanings:&n;        *                0-2     command&n;        *                3-4     page number (for enable rcv/xmt command)&n;        *                 7      receive broadcasts&n;        */
DECL|macro|NOTXcmd
mdefine_line|#define NOTXcmd         0x001            /* disable transmitter */
DECL|macro|NORXcmd
mdefine_line|#define NORXcmd         0x002            /* disable receiver */
DECL|macro|TXcmd
mdefine_line|#define TXcmd           0x003            /* enable transmitter */
DECL|macro|RXcmd
mdefine_line|#define RXcmd           0x004            /* enable receiver */
DECL|macro|CONFIGcmd
mdefine_line|#define CONFIGcmd       0x005            /* define configuration */
DECL|macro|CFLAGScmd
mdefine_line|#define CFLAGScmd       0x006            /* clear flags */
DECL|macro|TESTcmd
mdefine_line|#define TESTcmd         0x007            /* load test flags */
multiline_comment|/* flags for &quot;clear flags&quot; command */
DECL|macro|RESETclear
mdefine_line|#define RESETclear      0x008            /* power-on-reset */
DECL|macro|CONFIGclear
mdefine_line|#define CONFIGclear     0x010            /* system reconfigured */
multiline_comment|/* flags for &quot;load test flags&quot; command */
DECL|macro|TESTload
mdefine_line|#define TESTload        0x008            /* test flag (diagnostic) */
multiline_comment|/* byte deposited into first address of buffers on reset */
DECL|macro|TESTvalue
mdefine_line|#define TESTvalue       0321&t;&t; /* that&squot;s octal for 0xD1 :) */
multiline_comment|/* for &quot;enable receiver&quot; command */
DECL|macro|RXbcasts
mdefine_line|#define RXbcasts        0x080            /* receive broadcasts */
multiline_comment|/* flags for &quot;define configuration&quot; command */
DECL|macro|NORMALconf
mdefine_line|#define NORMALconf      0x000            /* 1-249 byte packets */
DECL|macro|EXTconf
mdefine_line|#define EXTconf         0x008            /* 250-504 byte packets */
multiline_comment|/* buffers (4 total) used for receive and xmit.&n;&t; */
DECL|macro|EnableReceiver
mdefine_line|#define EnableReceiver()&t;outb(RXcmd|(recbuf&lt;&lt;3)|RXbcasts,COMMAND)
multiline_comment|/*#define TXbuf&t;&t;2 (Obsoleted by ping-pong xmits) */
multiline_comment|/* Protocol ID&squot;s */
DECL|macro|ARC_P_IP
mdefine_line|#define ARC_P_IP&t;212&t;&t;/* 0xD4 */
DECL|macro|ARC_P_ARP
mdefine_line|#define ARC_P_ARP&t;213&t;&t;/* 0xD5 */
DECL|macro|ARC_P_RARP
mdefine_line|#define ARC_P_RARP&t;214&t;&t;/* 0xD6 */
DECL|macro|ARC_P_IPX
mdefine_line|#define ARC_P_IPX&t;250&t;&t;/* 0xFA */
DECL|macro|ARC_P_LANSOFT
mdefine_line|#define ARC_P_LANSOFT&t;251&t;&t;/* 0xFB */
DECL|macro|ARC_P_ATALK
mdefine_line|#define ARC_P_ATALK&t;0xDD
multiline_comment|/* Length of time between &quot;stuck&quot; checks */
DECL|macro|TIMERval
mdefine_line|#define TIMERval&t;(HZ/8)&t;&t;/* about 1/8 second */
multiline_comment|/* these structures define the format of an arcnet packet. */
DECL|macro|NORMAL
mdefine_line|#define NORMAL&t;&t;0
DECL|macro|EXTENDED
mdefine_line|#define EXTENDED&t;1
DECL|macro|EXCEPTION
mdefine_line|#define EXCEPTION&t;2
multiline_comment|/* the header required by the card itself */
DECL|struct|HardHeader
r_struct
id|HardHeader
(brace
DECL|member|source
id|u_char
id|source
comma
multiline_comment|/* source ARCnet - filled in automagically */
DECL|member|destination
id|destination
comma
multiline_comment|/* destination ARCnet - 0 for broadcast */
DECL|member|offset1
id|offset1
comma
multiline_comment|/* offset of ClientData (256-byte packets) */
DECL|member|offset2
id|offset2
suffix:semicolon
multiline_comment|/* offset of ClientData (512-byte packets) */
)brace
suffix:semicolon
multiline_comment|/* a complete ARCnet packet */
DECL|union|ArcPacket
r_union
id|ArcPacket
(brace
DECL|member|hardheader
r_struct
id|HardHeader
id|hardheader
suffix:semicolon
multiline_comment|/* the hardware header */
DECL|member|raw
id|u_char
id|raw
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* raw packet info, incl ClientData */
)brace
suffix:semicolon
multiline_comment|/* the &quot;client data&quot; header - RFC-1201 information&n;&t; * notice that this screws up if it&squot;s not an even number of bytes&n;&t; * &lt;sigh&gt;&n;&t; */
DECL|struct|ClientData
r_struct
id|ClientData
(brace
multiline_comment|/* data that&squot;s NOT part of real packet */
DECL|member|daddr
id|u_char
id|daddr
suffix:semicolon
multiline_comment|/* Destination address - stored here,&n;&t;&t;&t;&t; *   but WE MUST GET RID OF IT BEFORE SENDING A&n;&t;&t;&t;&t; *   PACKET!!&n;&t;&t;&t;&t; */
DECL|member|saddr
id|u_char
id|saddr
suffix:semicolon
multiline_comment|/* Source address - necessary for IPX protocol */
multiline_comment|/* data that IS part of real packet */
DECL|member|protocol_id
id|u_char
id|protocol_id
comma
multiline_comment|/* ARC_P_IP, ARC_P_ARP, or ARC_P_RARP */
DECL|member|split_flag
id|split_flag
suffix:semicolon
multiline_comment|/* for use with split packets */
DECL|member|sequence
id|u_short
id|sequence
suffix:semicolon
multiline_comment|/* sequence number (?) */
)brace
suffix:semicolon
DECL|macro|EXTRA_CLIENTDATA
mdefine_line|#define EXTRA_CLIENTDATA (sizeof(struct ClientData)-4)
multiline_comment|/* &quot;Incoming&quot; is information needed for each address that could be sending&n; * to us.  Mostly for partially-received split packets.&n; */
DECL|struct|Incoming
r_struct
id|Incoming
(brace
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* packet data buffer             */
DECL|member|lastpacket
r_int
r_char
id|lastpacket
comma
multiline_comment|/* number of last packet (from 1) */
DECL|member|numpackets
id|numpackets
suffix:semicolon
multiline_comment|/* number of packets in split     */
DECL|member|sequence
id|u_short
id|sequence
suffix:semicolon
multiline_comment|/* sequence number of assembly&t;  */
)brace
suffix:semicolon
DECL|struct|Outgoing
r_struct
id|Outgoing
(brace
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* buffer from upper levels */
DECL|member|hdr
r_struct
id|ClientData
op_star
id|hdr
suffix:semicolon
multiline_comment|/* clientdata of last packet */
DECL|member|data
id|u_char
op_star
id|data
suffix:semicolon
multiline_comment|/* pointer to data in packet */
DECL|member|length
r_int
id|length
comma
multiline_comment|/* bytes total */
DECL|member|dataleft
id|dataleft
comma
multiline_comment|/* bytes left */
DECL|member|segnum
id|segnum
comma
multiline_comment|/* segment being sent */
DECL|member|numsegs
id|numsegs
comma
multiline_comment|/* number of segments */
DECL|member|seglen
id|seglen
suffix:semicolon
multiline_comment|/* length of segment */
)brace
suffix:semicolon
multiline_comment|/* Information that needs to be kept for each board. */
DECL|struct|arcnet_local
r_struct
id|arcnet_local
(brace
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
DECL|member|arcnum
id|u_char
id|arcnum
suffix:semicolon
multiline_comment|/* arcnet number - our 8-bit address */
DECL|member|sequence
id|u_short
id|sequence
suffix:semicolon
multiline_comment|/* sequence number (incs with each packet) */
DECL|member|recbuf
id|u_char
id|recbuf
comma
multiline_comment|/* receive buffer # (0 or 1) */
DECL|member|txbuf
id|txbuf
comma
multiline_comment|/* transmit buffer # (2 or 3) */
DECL|member|txready
id|txready
suffix:semicolon
multiline_comment|/* buffer where a packet is ready to send */
DECL|member|intx
r_int
id|intx
comma
multiline_comment|/* in TX routine? */
DECL|member|in_txhandler
id|in_txhandler
comma
multiline_comment|/* in TX_IRQ handler? */
DECL|member|sending
id|sending
suffix:semicolon
multiline_comment|/* transmit in progress? */
DECL|member|tx_left
r_int
id|tx_left
suffix:semicolon
multiline_comment|/* segments of split packet left to TX */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* the timer interrupt struct */
DECL|member|incoming
r_struct
id|Incoming
id|incoming
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* one from each address */
DECL|member|outgoing
r_struct
id|Outgoing
id|outgoing
suffix:semicolon
multiline_comment|/* packet currently being sent */
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|arcnet_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifndef MODULE
r_static
r_int
id|arcnet_memprobe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u_char
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
id|arcnet_ioprobe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|arcnet_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|arcnet_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|arcnet_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef CAREFUL_XMIT
r_static
r_void
id|careful_xmit_wait
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#else
DECL|macro|careful_xmit_wait
mdefine_line|#define careful_xmit_wait(dev)
macro_line|#endif
r_static
r_void
id|arcnet_continue_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|arcnet_prepare_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ClientData
op_star
id|hdr
comma
r_int
id|length
comma
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|arcnet_go_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|arcnet_interrupt
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|arcnet_inthandler
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|arcnet_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|recbuf
)paren
suffix:semicolon
macro_line|#ifdef USE_TIMER_HANDLER
r_static
r_void
id|arcnet_timer
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_static
r_struct
id|enet_statistics
op_star
id|arcnet_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
multiline_comment|/* annoying functions for header/arp/etc building */
r_int
id|arc_header
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_int
id|arc_rebuild_header
c_func
(paren
r_void
op_star
id|eth
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|raddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_int
r_int
id|arc_type_trans
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|arcnet_reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|tx_done
mdefine_line|#define tx_done(dev) 1
multiline_comment|/*&n;#define JIFFER(time) for (delayval=jiffies+(time); delayval&gt;jiffies;);&n;*/
DECL|macro|JIFFER
mdefine_line|#define JIFFER(time) for (delayval=0; delayval&lt;(time*10); delayval++) &bslash;&n;&t;&t;udelay(1000);
macro_line|#ifdef EXTRA_DELAYS
DECL|macro|XJIFFER
mdefine_line|#define XJIFFER(time) JIFFER(time)
macro_line|#else
DECL|macro|XJIFFER
mdefine_line|#define XJIFFER(time)
macro_line|#endif
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; if one exists.&n; *  If dev-&gt;base_addr == 0, probe all likely locations.&n; *  If dev-&gt;base_addr == 1, always return failure.&n; *  If dev-&gt;base_addr == 2, allocate space for the device and return success&n; *  (detachable devices only).&n; */
r_int
DECL|function|arcnet_probe
id|arcnet_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
macro_line|#ifndef MODULE
multiline_comment|/* I refuse to probe anything less than 0x200, because anyone using&n;&t; * an address like that should probably be shot.&n;&t; */
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
multiline_comment|/* first the suggested values! */
l_int|0x300
comma
l_int|0x2E0
comma
l_int|0x2F0
comma
l_int|0x2D0
comma
multiline_comment|/* ...now everything else possible. */
l_int|0x200
comma
l_int|0x210
comma
l_int|0x220
comma
l_int|0x230
comma
l_int|0x240
comma
l_int|0x250
comma
l_int|0x260
comma
l_int|0x270
comma
l_int|0x280
comma
l_int|0x290
comma
l_int|0x2a0
comma
l_int|0x2b0
comma
l_int|0x2c0
comma
l_int|0x310
comma
l_int|0x320
comma
l_int|0x330
comma
l_int|0x340
comma
l_int|0x350
comma
l_int|0x360
comma
l_int|0x370
comma
l_int|0x380
comma
l_int|0x390
comma
l_int|0x3a0
comma
multiline_comment|/* video ports, */
l_int|0x3e0
comma
l_int|0x3f0
comma
multiline_comment|/* a null ends the list */
l_int|0
)brace
suffix:semicolon
multiline_comment|/* I&squot;m not going to probe below 0xA0000 either, for similar reasons.&n;&t; */
r_int
r_int
op_star
id|addr
comma
id|addrs
(braket
)braket
op_assign
(brace
l_int|0xD0000
comma
l_int|0xE0000
comma
l_int|0xA0000
comma
l_int|0xB0000
comma
l_int|0xC0000
comma
l_int|0xF0000
comma
multiline_comment|/* from &lt;mdrejhon@magi.com&gt; */
l_int|0xE1000
comma
l_int|0xDD000
comma
l_int|0xDC000
comma
l_int|0xD9000
comma
l_int|0xD8000
comma
l_int|0xD5000
comma
l_int|0xD4000
comma
l_int|0xD1000
comma
l_int|0xCD000
comma
l_int|0xCC000
comma
l_int|0xC9000
comma
l_int|0xC8000
comma
l_int|0xC5000
comma
l_int|0xC4000
comma
multiline_comment|/* terminator */
l_int|0
)brace
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
comma
id|status
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* MODULE */
r_int
id|delayval
suffix:semicolon
r_struct
id|arcnet_local
op_star
id|lp
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: ***&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: * Read linux/drivers/net/README.arcnet for important release notes!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: *&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: * This version should be stable, but e-mail me if you have any&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: * questions, comments, or bug reports!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: ***&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: given: base %lXh, IRQ %Xh, shmem %lXh&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
)paren
suffix:semicolon
macro_line|#ifndef MODULE
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
id|status
op_assign
id|arcnet_ioprobe
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
OG
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
id|ENXIO
suffix:semicolon
r_else
r_for
c_loop
(paren
id|port
op_assign
op_amp
id|ports
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
op_star
id|port
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|ETHERCARD_TOTAL_SIZE
)paren
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: Skipping %Xh because of check_region...&bslash;n&quot;
comma
id|ioaddr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|status
op_assign
id|arcnet_ioprobe
c_func
(paren
id|dev
comma
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* ioprobe turned out okay.  Now give it a couple seconds to finish&n;&t; * initializing...&n;&t; */
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: ioprobe okay!  Waiting for reset...&bslash;n&quot;
)paren
suffix:semicolon
id|JIFFER
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* okay, now we have to find the shared memory area. */
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: starting memory probe, given %lXh&bslash;n&quot;
comma
id|dev-&gt;mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mem_start
)paren
multiline_comment|/* value given - probe just that one */
(brace
id|status
op_assign
id|arcnet_memprobe
c_func
(paren
id|dev
comma
(paren
id|u_char
op_star
)paren
id|dev-&gt;mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
)brace
r_else
multiline_comment|/* no value given - probe everything */
(brace
r_for
c_loop
(paren
id|addr
op_assign
op_amp
id|addrs
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|addr
suffix:semicolon
id|addr
op_increment
)paren
(brace
id|status
op_assign
id|arcnet_memprobe
c_func
(paren
id|dev
comma
(paren
id|u_char
op_star
)paren
(paren
op_star
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
)brace
macro_line|#else /* MODULE */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;base_addr
op_logical_or
op_logical_neg
id|dev-&gt;irq
op_logical_or
op_logical_neg
id|dev-&gt;mem_start
op_logical_or
op_logical_neg
id|dev-&gt;rmem_start
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: loadable modules can&squot;t autoprobe!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet:  try using io=, irqnum=, and shmem= on the insmod line.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet:  you may also need num= to change the device name. (ie. num=1 for arc1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* now reserve the irq... */
(brace
r_int
id|irqval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|arcnet_interrupt
comma
l_int|0
comma
l_string|&quot;arcnet&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqval
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|irqval
)paren
suffix:semicolon
r_return
id|EAGAIN
suffix:semicolon
)brace
)brace
multiline_comment|/* Grab the region so we can find another board if autoIRQ fails. */
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|ETHERCARD_TOTAL_SIZE
comma
l_string|&quot;arcnet&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ARCnet card found at %03lXh, IRQ %d, ShMem at %lXh.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arcnet_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|arcnet_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|arcnet_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|arcnet_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|arcnet_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|arcnet_get_stats
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
macro_line|#endif
multiline_comment|/* Fill in the fields of the device structure with ethernet-generic values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* And now fill particular ones with arcnet values :) */
id|dev-&gt;type
op_assign
id|ARPHRD_ARCNET
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_EXTRA
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: ClientData header size is %d.&bslash;narcnet: HardHeader size is %d.&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|ClientData
)paren
comma
r_sizeof
(paren
r_struct
id|HardHeader
)paren
)paren
suffix:semicolon
macro_line|#if LIMIT_MTU&t;/* the old way - normally, now use ethernet default */
id|dev-&gt;mtu
op_assign
l_int|512
op_minus
r_sizeof
(paren
r_struct
id|HardHeader
)paren
op_plus
id|EXTRA_CLIENTDATA
suffix:semicolon
macro_line|#endif
multiline_comment|/* since we strip EXTRA_CLIENTDATA bytes off before sending,&n;&t;&t; * we let Linux add that many bytes to the packet data...&n;&t;&t; */
id|dev-&gt;addr_len
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;broadcast
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: arcnet_probe: resetting card.&bslash;n&quot;
)paren
suffix:semicolon
id|arcnet_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|JIFFER
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_NORMAL
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: We appear to be station %d (%02Xh)&bslash;n&quot;
comma
id|lp-&gt;arcnum
comma
id|lp-&gt;arcnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;arcnum
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: WARNING!  Station address 0 is reserved for broadcasts!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;arcnum
op_eq
l_int|255
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: WARNING!  Station address 255 may confuse DOS networking programs!&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
id|lp-&gt;arcnum
suffix:semicolon
id|lp-&gt;sequence
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;recbuf
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|arc_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|arc_rebuild_header
suffix:semicolon
id|dev-&gt;type_trans
op_assign
id|arc_type_trans
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef MODULE
DECL|function|arcnet_ioprobe
r_int
id|arcnet_ioprobe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
id|delayval
comma
id|airq
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: probing address %Xh&bslash;n&quot;
comma
id|ioaddr
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  status1=%Xh&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
multiline_comment|/* very simple - all we have to do is reset the card, and if there&squot;s&n;&t; * no irq, it&squot;s not an ARCnet.  We can also kill two birds with&n;&t; * one stone because we detect the IRQ at the same time :)&n;&t; */
multiline_comment|/* reset the card by reading the reset port */
id|inb
c_func
(paren
id|RESET
)paren
suffix:semicolon
id|JIFFER
c_func
(paren
id|RESETtime
)paren
suffix:semicolon
multiline_comment|/* if status port is FF, there&squot;s certainly no arcnet... give up. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_eq
l_int|0xFF
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  Status port empty.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* we&squot;ll try to be reasonably sure it&squot;s an arcnet by making sure&n;&t; * the value of the COMMAND port changes automatically once in a&n;&t; * while.  I have no idea what those values ARE, but at least&n;&t; * they work.&n;&t; */
(brace
r_int
id|initval
comma
id|curval
suffix:semicolon
id|curval
op_assign
id|initval
op_assign
id|inb
c_func
(paren
id|COMMAND
)paren
suffix:semicolon
id|delayval
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
r_while
c_loop
(paren
id|delayval
op_ge
id|jiffies
op_logical_and
id|curval
op_eq
id|initval
)paren
id|curval
op_assign
id|inb
c_func
(paren
id|COMMAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curval
op_eq
id|initval
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  never-changing command port (%02Xh).&bslash;n&quot;
comma
id|initval
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
)brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  status2=%Xh&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
multiline_comment|/* now we turn the reset bit off so we can IRQ next reset... */
id|outb
c_func
(paren
id|CFLAGScmd
op_or
id|RESETclear
op_or
id|CONFIGclear
comma
id|COMMAND
)paren
suffix:semicolon
id|XJIFFER
c_func
(paren
id|ACKtime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|RESETflag
)paren
multiline_comment|/* reset flag STILL on */
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  eternal reset flag1...(status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* set up automatic IRQ detection */
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* enable reset IRQ&squot;s (shouldn&squot;t be necessary, but worth a try) */
id|outb
c_func
(paren
id|RESETflag
comma
id|INTMASK
)paren
suffix:semicolon
multiline_comment|/* now reset it again to generate an IRQ */
id|inb
c_func
(paren
id|RESET
)paren
suffix:semicolon
id|JIFFER
c_func
(paren
id|RESETtime
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  status3=%Xh&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
multiline_comment|/* and turn the reset flag back off */
id|outb
c_func
(paren
id|CFLAGScmd
op_or
id|RESETclear
op_or
id|CONFIGclear
comma
id|COMMAND
)paren
suffix:semicolon
id|XJIFFER
c_func
(paren
id|ACKtime
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  status4=%Xh&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
multiline_comment|/* enable reset IRQ&squot;s again */
id|outb
c_func
(paren
id|RESETflag
comma
id|INTMASK
)paren
suffix:semicolon
multiline_comment|/* now reset it again to generate an IRQ */
id|inb
c_func
(paren
id|RESET
)paren
suffix:semicolon
id|JIFFER
c_func
(paren
id|RESETtime
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  status5=%Xh&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
multiline_comment|/* if we do this, we&squot;re sure to get an IRQ since the card has&n;&t; * just reset and the NORXflag is on until we tell it to start&n;&t; * receiving.&n;&t; *&n;&t; * However, this could, theoretically, cause a lockup.  Maybe I&squot;m just&n;&t; * not very good at theory! :)&n;&t; */
macro_line|#ifdef DANGER_PROBE
id|outb
c_func
(paren
id|NORXflag
comma
id|INTMASK
)paren
suffix:semicolon
id|JIFFER
c_func
(paren
id|RESETtime
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INTMASK
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* and turn the reset flag back off */
id|outb
c_func
(paren
id|CFLAGScmd
op_or
id|RESETclear
op_or
id|CONFIGclear
comma
id|COMMAND
)paren
suffix:semicolon
id|XJIFFER
c_func
(paren
id|ACKtime
)paren
suffix:semicolon
id|airq
op_assign
id|autoirq_report
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
op_ge
id|D_INIT
op_logical_and
id|airq
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  autoirq is %d&bslash;n&quot;
comma
id|airq
)paren
suffix:semicolon
multiline_comment|/* if there was no autoirq AND the user hasn&squot;t set any defaults,&n;&t; * give up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|airq
op_logical_and
op_logical_neg
(paren
id|dev-&gt;base_addr
op_logical_and
id|dev-&gt;irq
)paren
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  no autoirq...&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* otherwise we probably have a card.  Let&squot;s make sure. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|RESETflag
)paren
multiline_comment|/* reset flag on */
(brace
multiline_comment|/* now we turn the reset bit off */
id|outb
c_func
(paren
id|CFLAGScmd
op_or
id|RESETclear
op_or
id|CONFIGclear
comma
id|COMMAND
)paren
suffix:semicolon
id|XJIFFER
c_func
(paren
id|ACKtime
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|RESETflag
)paren
multiline_comment|/* reset flag STILL on */
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  eternal reset flag...(status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* okay, we&squot;ve got a real, live ARCnet on our hands. */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;base_addr
)paren
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
multiline_comment|/* &quot;Auto-IRQ&quot; */
(brace
multiline_comment|/* we already did the autoirq above, so store the values */
id|dev-&gt;irq
op_assign
id|airq
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: IRQ2 == IRQ9, don&squot;t worry.&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
)brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: irq and base address seem okay. (%lXh, IRQ %d)&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A memory probe that is called after the card is reset.&n; * It checks for the official TESTvalue in byte 0 and makes sure the buffer&n; * has certain characteristics of an ARCnet...&n; */
DECL|function|arcnet_memprobe
r_int
id|arcnet_memprobe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u_char
op_star
id|addr
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: probing memory at %lXh&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|addr
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef STRICT_MEM_DETECT /* probably better. */
multiline_comment|/* ARCnet memory byte 0 is TESTvalue */
r_if
c_cond
(paren
id|addr
(braket
l_int|0
)braket
op_ne
id|TESTvalue
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  addr=%lXh, addr[0]=%Xh (not %Xh)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|addr
comma
id|addr
(braket
l_int|0
)braket
comma
id|TESTvalue
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* now verify the shared memory writability */
id|addr
(braket
l_int|0
)braket
op_assign
l_int|0x42
suffix:semicolon
r_if
c_cond
(paren
id|addr
(braket
l_int|0
)braket
op_ne
l_int|0x42
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  addr=%lXh, addr[0]=%Xh (not 42h)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|addr
comma
id|addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|addr
(braket
l_int|0
)braket
op_ne
id|TESTvalue
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet:  probe failed.  addr=%lXh, addr[0]=%Xh (not %Xh)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|addr
comma
id|addr
(braket
l_int|0
)braket
comma
id|TESTvalue
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* got it!  fill in dev */
id|dev-&gt;mem_start
op_assign
(paren
r_int
r_int
)paren
id|addr
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
l_int|512
op_star
l_int|4
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;rmem_start
op_assign
id|dev-&gt;mem_start
op_plus
l_int|512
op_star
l_int|0
suffix:semicolon
id|dev-&gt;rmem_end
op_assign
id|dev-&gt;mem_start
op_plus
l_int|512
op_star
l_int|2
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;   */
r_static
r_int
DECL|function|arcnet_open
id|arcnet_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&t;int ioaddr = dev-&gt;base_addr;*/
r_if
c_cond
(paren
id|dev-&gt;metric
op_ge
l_int|10
)paren
(brace
id|net_debug
op_assign
id|dev-&gt;metric
op_minus
l_int|10
suffix:semicolon
id|dev-&gt;metric
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
macro_line|#if 0&t;/* Yup, they&squot;re hardwired in arcnets */
multiline_comment|/* This is used if the interrupt line can turned off (shared).&n;&t;   See 3c503.c for an example of selecting the IRQ at config-time. */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|arcnet_interrupt
comma
l_int|0
comma
l_string|&quot;arcnet&quot;
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
macro_line|#endif
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Reset the hardware here. */
id|BUGLVL
c_func
(paren
id|D_EXTRA
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: arcnet_open: resetting card.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* try to reset - twice if it fails the first time */
r_if
c_cond
(paren
id|arcnet_reset
c_func
(paren
id|dev
)paren
op_logical_and
id|arcnet_reset
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&t;chipset_init(dev, 1);*/
multiline_comment|/*&t;outb(0x00, ioaddr);*/
multiline_comment|/*&t;lp-&gt;open_time = jiffies;*/
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;intx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;in_txhandler
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef USE_TIMER_HANDLER
multiline_comment|/* grab a timer handler to recover from any missed IRQ&squot;s */
id|init_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
id|lp-&gt;timer.expires
op_assign
id|TIMERval
suffix:semicolon
multiline_comment|/* length of time */
id|lp-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
multiline_comment|/* pointer to &quot;dev&quot; structure */
id|lp-&gt;timer.function
op_assign
op_amp
id|arcnet_timer
suffix:semicolon
multiline_comment|/* timer handler */
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to arcnet_open(). */
r_static
r_int
DECL|function|arcnet_close
id|arcnet_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef EXTRA_DELAYS
r_int
id|delayval
suffix:semicolon
macro_line|#endif
multiline_comment|/*&t;lp-&gt;open_time = 0;*/
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* release the timer */
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here.     */
multiline_comment|/* resetting the card should do the job. */
multiline_comment|/*inb(RESET);*/
id|outb
c_func
(paren
l_int|0
comma
id|INTMASK
)paren
suffix:semicolon
multiline_comment|/* no IRQ&squot;s */
id|outb
c_func
(paren
id|NOTXcmd
comma
id|COMMAND
)paren
suffix:semicolon
multiline_comment|/* disable transmit */
id|XJIFFER
c_func
(paren
id|ACKtime
)paren
suffix:semicolon
id|outb
c_func
(paren
id|NORXcmd
comma
id|COMMAND
)paren
suffix:semicolon
multiline_comment|/* disable receive */
multiline_comment|/* Update the statistics here. */
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|arcnet_send_packet
id|arcnet_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/*&t;short daddr;*/
id|lp-&gt;intx
op_increment
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: transmit requested (status=%Xh, inTX=%d)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
comma
id|lp-&gt;intx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_or
id|lp-&gt;in_txhandler
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_int
id|recbuf
op_assign
id|lp-&gt;recbuf
suffix:semicolon
r_int
id|status
op_assign
id|inb
c_func
(paren
id|STATUS
)paren
suffix:semicolon
multiline_comment|/* resume any stopped tx&squot;s */
macro_line|#if 0
r_if
c_cond
(paren
id|lp-&gt;txready
op_logical_and
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXFREEflag
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: kickme: starting a TX (status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;intx
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: premature kickme! (status=%Xh ticks=%d o.skb=%ph numsegs=%d segnum=%d&bslash;n&quot;
comma
id|status
comma
id|tickssofar
comma
id|lp-&gt;outgoing.skb
comma
id|lp-&gt;outgoing.numsegs
comma
id|lp-&gt;outgoing.segnum
)paren
suffix:semicolon
id|lp-&gt;intx
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: transmit timed out (status=%Xh, inTX=%d, tickssofar=%d)&bslash;n&quot;
comma
id|status
comma
id|lp-&gt;intx
comma
id|tickssofar
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
multiline_comment|/*arcnet_reset(dev);*/
r_if
c_cond
(paren
id|status
op_amp
id|NORXflag
)paren
id|EnableReceiver
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|TXFREEflag
)paren
)paren
id|outb
c_func
(paren
id|NOTXcmd
comma
id|COMMAND
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;outgoing.skb
)paren
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;outgoing.skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|lp-&gt;outgoing.skb
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
id|lp-&gt;intx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;in_txhandler
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;txready
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;sending
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If some higher layer thinks we&squot;ve missed a tx-done interrupt&n;&t;   we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;&t;   itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: tx passed null skb (status=%Xh, inTX=%d, tickssofar=%ld)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
comma
id|lp-&gt;intx
comma
id|jiffies
op_minus
id|dev-&gt;trans_start
)paren
suffix:semicolon
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;intx
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;txready
)paren
multiline_comment|/* transmit already in progress! */
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: trying to start new packet while busy!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: marking as not ready.&bslash;n&quot;
)paren
suffix:semicolon
id|lp-&gt;txready
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping.  This could better be&n;&t;   done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: transmitter called with busy bit set! (status=%Xh, inTX=%d, tickssofar=%ld)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
comma
id|lp-&gt;intx
comma
id|jiffies
op_minus
id|dev-&gt;trans_start
)paren
suffix:semicolon
id|lp-&gt;intx
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
r_struct
id|Outgoing
op_star
id|out
op_assign
op_amp
(paren
id|lp-&gt;outgoing
)paren
suffix:semicolon
id|out-&gt;length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
id|out-&gt;hdr
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|out-&gt;skb
op_assign
id|skb
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DATA
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|16
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n[%04hX] &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02hX &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;data
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef IRQ_XMIT
r_if
c_cond
(paren
id|lp-&gt;txready
op_logical_and
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXFREEflag
)paren
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|out-&gt;length
op_le
id|XMTU
)paren
multiline_comment|/* fits in one packet? */
(brace
id|BUGLVL
c_func
(paren
id|D_TX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: not splitting %d-byte packet. (split_flag=%d)&bslash;n&quot;
comma
id|out-&gt;length
comma
id|out-&gt;hdr-&gt;split_flag
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
r_if
c_cond
(paren
id|out-&gt;hdr-&gt;split_flag
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: short packet has split_flag set?! (split_flag=%d)&bslash;n&quot;
comma
id|out-&gt;hdr-&gt;split_flag
)paren
suffix:semicolon
id|out-&gt;numsegs
op_assign
l_int|1
suffix:semicolon
id|out-&gt;segnum
op_assign
l_int|1
suffix:semicolon
id|arcnet_prepare_tx
c_func
(paren
id|dev
comma
id|out-&gt;hdr
comma
id|out-&gt;length
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
comma
(paren
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
op_plus
r_sizeof
(paren
r_struct
id|ClientData
)paren
)paren
suffix:semicolon
id|careful_xmit_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* done right away */
id|dev_kfree_skb
c_func
(paren
id|out-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|out-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;sending
)paren
(brace
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* inform upper layers */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* too big for one - split it */
(brace
r_int
id|maxsegsize
op_assign
id|XMTU
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|out-&gt;data
op_assign
(paren
id|u_char
op_star
)paren
id|skb-&gt;data
op_plus
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|out-&gt;dataleft
op_assign
id|out-&gt;length
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|out-&gt;numsegs
op_assign
(paren
id|out-&gt;dataleft
op_plus
id|maxsegsize
op_minus
l_int|1
)paren
op_div
id|maxsegsize
suffix:semicolon
id|out-&gt;segnum
op_assign
l_int|0
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_TX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: packet (%d bytes) split into %d fragments:&bslash;n&quot;
comma
id|out-&gt;length
comma
id|out-&gt;numsegs
)paren
suffix:semicolon
macro_line|#ifdef IRQ_XMIT
multiline_comment|/* if a packet waiting, launch it */
r_if
c_cond
(paren
id|lp-&gt;txready
op_logical_and
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXFREEflag
)paren
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;txready
)paren
(brace
multiline_comment|/* prepare a packet, launch it and prepare&n;                                 * another.&n;                                 */
id|arcnet_continue_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;sending
)paren
(brace
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|arcnet_continue_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;sending
)paren
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if segnum==numsegs, the transmission is finished;&n;&t;&t;&t; * free the skb right away.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|out-&gt;segnum
op_eq
id|out-&gt;numsegs
)paren
(brace
multiline_comment|/* transmit completed */
id|out-&gt;segnum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|out-&gt;skb
)paren
id|dev_kfree_skb
c_func
(paren
id|out-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|out-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if 0
multiline_comment|/* inform upper layers */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else /* non-irq xmit */
r_while
c_loop
(paren
id|out-&gt;segnum
OL
id|out-&gt;numsegs
)paren
(brace
id|arcnet_continue_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|careful_xmit_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|out-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|out-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* inform upper layers */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|lp-&gt;intx
op_decrement
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arcnet_continue_tx
r_static
r_void
id|arcnet_continue_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|maxsegsize
op_assign
id|XMTU
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
r_struct
id|Outgoing
op_star
id|out
op_assign
op_amp
(paren
id|lp-&gt;outgoing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;txready
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: continue_tx: called with packet in buffer!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|out-&gt;segnum
op_ge
id|out-&gt;numsegs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: continue_tx: building segment %d of %d!&bslash;n&quot;
comma
id|out-&gt;segnum
op_plus
l_int|1
comma
id|out-&gt;numsegs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|out-&gt;segnum
)paren
multiline_comment|/* first packet */
id|out-&gt;hdr-&gt;split_flag
op_assign
(paren
(paren
id|out-&gt;numsegs
op_minus
l_int|2
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_else
id|out-&gt;hdr-&gt;split_flag
op_assign
id|out-&gt;segnum
op_lshift
l_int|1
suffix:semicolon
id|out-&gt;seglen
op_assign
id|maxsegsize
suffix:semicolon
r_if
c_cond
(paren
id|out-&gt;seglen
OG
id|out-&gt;dataleft
)paren
id|out-&gt;seglen
op_assign
id|out-&gt;dataleft
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_TX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: building packet #%d (%d bytes) of %d (%d total), splitflag=%d&bslash;n&quot;
comma
id|out-&gt;segnum
op_plus
l_int|1
comma
id|out-&gt;seglen
comma
id|out-&gt;numsegs
comma
id|out-&gt;length
comma
id|out-&gt;hdr-&gt;split_flag
)paren
suffix:semicolon
id|arcnet_prepare_tx
c_func
(paren
id|dev
comma
id|out-&gt;hdr
comma
id|out-&gt;seglen
comma
id|out-&gt;data
)paren
suffix:semicolon
id|out-&gt;dataleft
op_sub_assign
id|out-&gt;seglen
suffix:semicolon
id|out-&gt;data
op_add_assign
id|out-&gt;seglen
suffix:semicolon
id|out-&gt;segnum
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CAREFUL_XMIT
DECL|function|careful_xmit_wait
r_static
r_void
id|careful_xmit_wait
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* wait patiently for tx to become available again */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXFREEflag
)paren
)paren
(brace
r_if
c_cond
(paren
id|jiffies
op_minus
id|dev-&gt;trans_start
OG
l_int|20
op_logical_or
op_logical_neg
id|dev-&gt;tbusy
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: CAREFUL_XMIT timeout. (busy=%d, status=%Xh)&bslash;n&quot;
comma
id|dev-&gt;tbusy
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|outb
c_func
(paren
id|NOTXcmd
comma
id|COMMAND
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|BUGLVL
c_func
(paren
id|D_TX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: transmit completed successfully. (status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_void
DECL|function|arcnet_prepare_tx
id|arcnet_prepare_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ClientData
op_star
id|hdr
comma
r_int
id|length
comma
r_char
op_star
id|data
)paren
(brace
multiline_comment|/*&t;int ioaddr = dev-&gt;base_addr;*/
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ClientData
op_star
id|arcsoft
suffix:semicolon
r_union
id|ArcPacket
op_star
id|arcpacket
op_assign
(paren
r_union
id|ArcPacket
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
l_int|512
op_star
(paren
id|lp-&gt;txbuf
op_xor
l_int|1
)paren
)paren
suffix:semicolon
id|u_char
id|pkttype
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|daddr
suffix:semicolon
id|lp-&gt;txbuf
op_assign
id|lp-&gt;txbuf
op_xor
l_int|1
suffix:semicolon
multiline_comment|/* XOR with 1 to alternate between 2 and 3 */
id|length
op_add_assign
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_TX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: arcnet_prep_tx: hdr:%ph, length:%d, data:%ph&bslash;n&quot;
comma
id|hdr
comma
id|length
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* clean out the page to make debugging make more sense :) */
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|lp-&gt;txbuf
op_star
l_int|512
comma
l_int|0x42
comma
l_int|512
)paren
suffix:semicolon
id|daddr
op_assign
id|arcpacket-&gt;hardheader.destination
op_assign
id|hdr-&gt;daddr
suffix:semicolon
multiline_comment|/* load packet into shared memory */
r_if
c_cond
(paren
id|length
op_le
id|MTU
)paren
multiline_comment|/* Normal (256-byte) Packet */
(brace
id|pkttype
op_assign
id|NORMAL
suffix:semicolon
id|arcpacket-&gt;hardheader.offset1
op_assign
id|offset
op_assign
l_int|256
op_minus
id|length
op_plus
id|EXTRA_CLIENTDATA
suffix:semicolon
id|arcsoft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
(paren
op_amp
id|arcpacket-&gt;raw
(braket
id|offset
op_minus
id|EXTRA_CLIENTDATA
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|length
op_ge
id|MinTU
)paren
multiline_comment|/* Extended (512-byte) Packet */
(brace
id|pkttype
op_assign
id|EXTENDED
suffix:semicolon
id|arcpacket-&gt;hardheader.offset1
op_assign
l_int|0
suffix:semicolon
id|arcpacket-&gt;hardheader.offset2
op_assign
id|offset
op_assign
l_int|512
op_minus
id|length
op_plus
id|EXTRA_CLIENTDATA
suffix:semicolon
id|arcsoft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
(paren
op_amp
id|arcpacket-&gt;raw
(braket
id|offset
op_minus
id|EXTRA_CLIENTDATA
)braket
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Exception Packet */
(brace
id|pkttype
op_assign
id|EXCEPTION
suffix:semicolon
id|arcpacket-&gt;hardheader.offset1
op_assign
l_int|0
suffix:semicolon
id|arcpacket-&gt;hardheader.offset2
op_assign
id|offset
op_assign
l_int|512
op_minus
id|length
op_minus
l_int|4
op_plus
id|EXTRA_CLIENTDATA
suffix:semicolon
id|arcsoft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
(paren
op_amp
id|arcpacket-&gt;raw
(braket
id|offset
op_plus
l_int|4
op_minus
id|EXTRA_CLIENTDATA
)braket
)paren
suffix:semicolon
multiline_comment|/* exception-specific stuff - these four bytes&n;&t;&t; * make the packet long enough to fit in a 512-byte&n;&t;&t; * frame.&n;&t;&t; */
id|arcpacket-&gt;raw
(braket
id|offset
op_plus
l_int|0
)braket
op_assign
id|arcsoft-&gt;protocol_id
suffix:semicolon
id|arcpacket-&gt;raw
(braket
id|offset
op_plus
l_int|1
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* FF flag */
id|arcpacket-&gt;raw
(braket
id|offset
op_plus
l_int|2
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* FF padding */
id|arcpacket-&gt;raw
(braket
id|offset
op_plus
l_int|3
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* FF padding */
)brace
multiline_comment|/* copy the packet into ARCnet shmem&n;&t; *  - the first bytes of ClientData header are skipped&n;&t; */
id|memcpy
c_func
(paren
(paren
id|u_char
op_star
)paren
id|arcsoft
op_plus
id|EXTRA_CLIENTDATA
comma
(paren
id|u_char
op_star
)paren
id|hdr
op_plus
id|EXTRA_CLIENTDATA
comma
r_sizeof
(paren
r_struct
id|ClientData
)paren
op_minus
id|EXTRA_CLIENTDATA
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|u_char
op_star
)paren
id|arcsoft
op_plus
r_sizeof
(paren
r_struct
id|ClientData
)paren
comma
id|data
comma
id|length
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: transmitting packet to station %02Xh (%d bytes, type=%d)&bslash;n&quot;
comma
id|daddr
comma
id|length
comma
id|pkttype
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_TX
)paren
(brace
r_int
id|countx
comma
id|county
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: packet dump [tx] follows:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|county
op_assign
l_int|0
suffix:semicolon
id|county
OL
l_int|16
op_plus
(paren
id|pkttype
op_ne
id|NORMAL
)paren
op_star
l_int|16
suffix:semicolon
id|county
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n[%04X] &quot;
comma
id|county
op_star
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
id|countx
op_assign
l_int|0
suffix:semicolon
id|countx
OL
l_int|16
suffix:semicolon
id|countx
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02X &quot;
comma
id|arcpacket-&gt;raw
(braket
id|county
op_star
l_int|16
op_plus
id|countx
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CAREFUL_XMIT
macro_line|#if 0
id|careful_xmit_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* if we&squot;re not broadcasting, make sure the xmit was ack&squot;d.&n;&t; * if it wasn&squot;t, there is probably no card with that&n;&t; * address... or else it missed our tx somehow.&n;&t; */
r_if
c_cond
(paren
id|daddr
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXACKflag
)paren
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: transmit not acknowledged. (status=%Xh, daddr=%02Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
comma
id|daddr
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_return
op_minus
id|ENONET
suffix:semicolon
multiline_comment|/* &quot;machine is not on the network&quot; */
)brace
macro_line|#endif
macro_line|#endif
id|lp-&gt;txready
op_assign
id|lp-&gt;txbuf
suffix:semicolon
multiline_comment|/* packet is ready for sending */
macro_line|#if 0
macro_line|#ifdef IRQ_XMIT
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXFREEflag
)paren
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
r_static
r_void
DECL|function|arcnet_go_tx
id|arcnet_go_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: go_tx: status=%Xh&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS
)paren
op_amp
id|TXFREEflag
)paren
op_logical_or
op_logical_neg
id|lp-&gt;txready
)paren
r_return
suffix:semicolon
multiline_comment|/* start sending */
id|outb
c_func
(paren
id|TXcmd
op_or
(paren
id|lp-&gt;txready
op_lshift
l_int|3
)paren
comma
id|COMMAND
)paren
suffix:semicolon
macro_line|#ifdef IRQ_XMIT
id|outb
c_func
(paren
id|TXFREEflag
op_or
id|NORXflag
comma
id|INTMASK
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;txready
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;sending
op_increment
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
r_static
r_void
DECL|function|arcnet_interrupt
id|arcnet_interrupt
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|net_debug
op_ge
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arcnet_inthandler
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|arcnet_inthandler
id|arcnet_inthandler
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|3
comma
id|didsomething
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef IRQ_XMIT
id|outb
c_func
(paren
l_int|0
comma
id|INTMASK
)paren
suffix:semicolon
macro_line|#endif
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: in net_interrupt (status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|STATUS
)paren
suffix:semicolon
id|didsomething
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;start
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_EXTRA
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: ARCnet not yet initialized.  irq ignored. (status=%Xh)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#ifdef IRQ_XMIT
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|NORXflag
)paren
)paren
id|outb
c_func
(paren
id|NORXflag
comma
id|INTMASK
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* RESET flag was enabled - card is resetting and if RX&n;&t;&t; * is disabled, it&squot;s NOT because we just got a packet.&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
id|RESETflag
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: reset irq (status=%Xh)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 1&t;/* yes, it&squot;s silly to disable this part but it makes good testing */
multiline_comment|/* RX is inhibited - we must have received something. */
r_if
c_cond
(paren
id|status
op_amp
id|NORXflag
)paren
(brace
r_int
id|recbuf
op_assign
id|lp-&gt;recbuf
op_assign
op_logical_neg
id|lp-&gt;recbuf
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: receive irq (status=%Xh)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* enable receive of our next packet */
id|EnableReceiver
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Got a packet. */
id|arcnet_rx
c_func
(paren
id|dev
comma
op_logical_neg
id|recbuf
)paren
suffix:semicolon
id|didsomething
op_increment
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef IRQ_XMIT
multiline_comment|/* it can only be an xmit-done irq if we&squot;re xmitting :) */
r_if
c_cond
(paren
id|status
op_amp
id|TXFREEflag
op_logical_and
op_logical_neg
id|lp-&gt;in_txhandler
op_logical_and
id|lp-&gt;sending
)paren
(brace
r_struct
id|Outgoing
op_star
id|out
op_assign
op_amp
(paren
id|lp-&gt;outgoing
)paren
suffix:semicolon
id|lp-&gt;in_txhandler
op_increment
suffix:semicolon
id|lp-&gt;sending
op_decrement
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: TX IRQ (stat=%Xh, numsegs=%d, segnum=%d, skb=%ph)&bslash;n&quot;
comma
id|status
comma
id|out-&gt;numsegs
comma
id|out-&gt;segnum
comma
id|out-&gt;skb
)paren
suffix:semicolon
multiline_comment|/* send packet if there is one */
r_if
c_cond
(paren
id|lp-&gt;txready
)paren
(brace
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|didsomething
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;intx
)paren
(brace
id|lp-&gt;in_txhandler
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;outgoing.skb
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: TX IRQ done: no split to continue.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* inform upper layers */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;txready
op_logical_and
id|dev-&gt;tbusy
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
id|lp-&gt;in_txhandler
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*lp-&gt;stats.tx_packets++;*/
multiline_comment|/* if more than one segment, and not all segments&n;&t;&t;&t; * are done, then continue xmit.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|out-&gt;segnum
OL
id|out-&gt;numsegs
)paren
id|arcnet_continue_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;txready
op_logical_and
op_logical_neg
id|lp-&gt;sending
)paren
id|arcnet_go_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* if segnum==numsegs, the transmission is finished;&n;&t;&t;&t; * free the skb.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|out-&gt;segnum
op_ge
id|out-&gt;numsegs
)paren
(brace
multiline_comment|/* transmit completed */
id|out-&gt;segnum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|out-&gt;skb
)paren
id|dev_kfree_skb
c_func
(paren
id|out-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|out-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* inform upper layers */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;txready
op_logical_and
id|dev-&gt;tbusy
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
id|didsomething
op_increment
suffix:semicolon
id|lp-&gt;in_txhandler
op_decrement
suffix:semicolon
)brace
macro_line|#endif /* IRQ_XMIT */
)brace
r_while
c_loop
(paren
op_decrement
id|boguscount
op_logical_and
id|didsomething
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: net_interrupt complete (status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
macro_line|#ifdef IRQ_XMIT
r_if
c_cond
(paren
id|dev-&gt;start
op_logical_and
id|lp-&gt;sending
)paren
id|outb
c_func
(paren
id|NORXflag
op_or
id|TXFREEflag
comma
id|INTMASK
)paren
suffix:semicolon
r_else
id|outb
c_func
(paren
id|NORXflag
comma
id|INTMASK
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A packet has arrived; grab it from the buffers and possibly unsplit it.&n; */
r_static
r_void
DECL|function|arcnet_rx
id|arcnet_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|recbuf
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/*&t;int status = inb(STATUS);*/
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_union
id|ArcPacket
op_star
id|arcpacket
op_assign
(paren
r_union
id|ArcPacket
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|recbuf
op_star
l_int|512
)paren
suffix:semicolon
r_struct
id|ClientData
op_star
id|soft
comma
op_star
id|arcsoft
suffix:semicolon
r_int
id|length
comma
id|offset
suffix:semicolon
id|u_char
id|pkttype
comma
id|daddr
comma
id|saddr
suffix:semicolon
id|daddr
op_assign
id|arcpacket-&gt;hardheader.destination
suffix:semicolon
id|saddr
op_assign
id|arcpacket-&gt;hardheader.source
suffix:semicolon
multiline_comment|/* if source is 0, it&squot;s not a &quot;used&quot; packet! */
r_if
c_cond
(paren
id|saddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/*BUGLVL(D_DURING)*/
id|printk
c_func
(paren
l_string|&quot;arcnet: discarding old packet. (status=%Xh)&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arcpacket-&gt;hardheader.source
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arcpacket-&gt;hardheader.offset1
)paren
multiline_comment|/* Normal Packet */
(brace
id|offset
op_assign
id|arcpacket-&gt;hardheader.offset1
suffix:semicolon
id|arcsoft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
(paren
op_amp
id|arcpacket-&gt;raw
(braket
id|offset
op_minus
id|EXTRA_CLIENTDATA
)braket
)paren
suffix:semicolon
id|length
op_assign
l_int|256
op_minus
id|offset
op_plus
id|EXTRA_CLIENTDATA
suffix:semicolon
id|pkttype
op_assign
id|NORMAL
suffix:semicolon
)brace
r_else
multiline_comment|/* ExtendedPacket or ExceptionPacket */
(brace
id|offset
op_assign
id|arcpacket-&gt;hardheader.offset2
suffix:semicolon
id|arcsoft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
(paren
op_amp
id|arcpacket-&gt;raw
(braket
id|offset
op_minus
id|EXTRA_CLIENTDATA
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arcsoft-&gt;split_flag
op_ne
l_int|0xFF
)paren
multiline_comment|/* Extended Packet */
(brace
id|length
op_assign
l_int|512
op_minus
id|offset
op_plus
id|EXTRA_CLIENTDATA
suffix:semicolon
id|pkttype
op_assign
id|EXTENDED
suffix:semicolon
)brace
r_else
multiline_comment|/* Exception Packet */
(brace
multiline_comment|/* skip over 4-byte junkola */
id|arcsoft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
(paren
(paren
id|u_char
op_star
)paren
id|arcsoft
op_plus
l_int|4
)paren
suffix:semicolon
id|length
op_assign
l_int|512
op_minus
id|offset
op_plus
id|EXTRA_CLIENTDATA
op_minus
l_int|4
suffix:semicolon
id|pkttype
op_assign
id|EXCEPTION
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|arcsoft-&gt;split_flag
)paren
multiline_comment|/* not split */
(brace
r_struct
id|Incoming
op_star
id|in
op_assign
op_amp
id|lp-&gt;incoming
(braket
id|saddr
)braket
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_RX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: incoming is not split (splitflag=%d)&bslash;n&quot;
comma
id|arcsoft-&gt;split_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;skb
)paren
multiline_comment|/* already assembling one! */
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)&bslash;n&quot;
comma
id|in-&gt;sequence
comma
id|arcsoft-&gt;split_flag
comma
id|arcsoft-&gt;sequence
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|in-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|in-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|in-&gt;sequence
op_assign
id|arcsoft-&gt;sequence
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|soft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;len
op_assign
id|length
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|u_char
op_star
)paren
id|soft
op_plus
id|EXTRA_CLIENTDATA
comma
(paren
id|u_char
op_star
)paren
id|arcsoft
op_plus
id|EXTRA_CLIENTDATA
comma
id|length
op_minus
id|EXTRA_CLIENTDATA
)paren
suffix:semicolon
id|soft-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|soft-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: received packet from %02Xh to %02Xh (%d bytes, type=%d)&bslash;n&quot;
comma
id|saddr
comma
id|daddr
comma
id|length
comma
id|pkttype
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_RX
)paren
(brace
r_int
id|countx
comma
id|county
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: packet dump [rx-unsplit] follows:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|county
op_assign
l_int|0
suffix:semicolon
id|county
OL
l_int|16
op_plus
(paren
id|pkttype
op_ne
id|NORMAL
)paren
op_star
l_int|16
suffix:semicolon
id|county
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n[%04X] &quot;
comma
id|county
op_star
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
id|countx
op_assign
l_int|0
suffix:semicolon
id|countx
OL
l_int|16
suffix:semicolon
id|countx
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02X &quot;
comma
id|arcpacket-&gt;raw
(braket
id|county
op_star
l_int|16
op_plus
id|countx
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ARP packets have problems when sent from DOS.&n;         &t; * source address is always 0!  So we take the hardware&n;         &t; * source addr (which is impossible to fumble) and insert&n;         &t; * it ourselves.&n;         &t; */
r_if
c_cond
(paren
id|soft-&gt;protocol_id
op_eq
id|ARC_P_ARP
)paren
(brace
r_struct
id|arphdr
op_star
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|soft
op_plus
r_sizeof
(paren
r_struct
id|ClientData
)paren
)paren
suffix:semicolon
multiline_comment|/* make sure addresses are the right length */
r_if
c_cond
(paren
id|arp-&gt;ar_hln
op_eq
l_int|1
op_logical_and
id|arp-&gt;ar_pln
op_eq
l_int|4
)paren
(brace
r_char
op_star
id|cptr
op_assign
(paren
r_char
op_star
)paren
(paren
id|arp
)paren
op_plus
r_sizeof
(paren
r_struct
id|arphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|cptr
)paren
multiline_comment|/* is saddr = 00? */
(brace
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: ARP source address was 00h, set to %02Xh.&bslash;n&quot;
comma
id|saddr
)paren
suffix:semicolon
op_star
id|cptr
op_assign
id|saddr
suffix:semicolon
)brace
r_else
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: ARP source address (%Xh) is fine.&bslash;n&quot;
comma
op_star
id|cptr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: funny-shaped ARP packet. (%Xh, %Xh)&bslash;n&quot;
comma
id|arp-&gt;ar_hln
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
)brace
)brace
id|BUGLVL
c_func
(paren
id|D_DATA
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|16
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n[%04hX] &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02hX &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;data
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
r_else
multiline_comment|/* split packet */
(brace
multiline_comment|/* NOTE:  MSDOS ARP packet correction should only need to&n;&t;          * apply to unsplit packets, since ARP packets are so short.&n;&t;          *&n;&t;          * My interpretation of the RFC1201 (ARCnet) document is that&n;&t;          * if a packet is received out of order, the entire assembly&n;&t;          * process should be aborted.&n;&t;          *&n;&t;          * The RFC also mentions &quot;it is possible for successfully&n;&t;          * received packets to be retransmitted.&quot;  As of 0.40 all&n;&t;          * previously received packets are allowed, not just the&n;&t;          * most recent one.&n;&t;          *&n;&t;          * We allow multiple assembly processes, one for each&n;&t;          * ARCnet card possible on the network.  Seems rather like&n;&t;          * a waste of memory.  Necessary?&n;&t;          */
r_struct
id|Incoming
op_star
id|in
op_assign
op_amp
id|lp-&gt;incoming
(braket
id|saddr
)braket
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_RX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: packet is split (splitflag=%d, seq=%d)&bslash;n&quot;
comma
id|arcsoft-&gt;split_flag
comma
id|in-&gt;sequence
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;skb
op_logical_and
id|in-&gt;sequence
op_ne
id|arcsoft-&gt;sequence
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: wrong seq number, aborting assembly (expected=%d, seq=%d, splitflag=%d)&bslash;n&quot;
comma
id|in-&gt;sequence
comma
id|arcsoft-&gt;sequence
comma
id|arcsoft-&gt;split_flag
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|in-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|in-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|in-&gt;lastpacket
op_assign
id|in-&gt;numpackets
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arcsoft-&gt;split_flag
op_amp
l_int|1
)paren
multiline_comment|/* first packet in split */
(brace
id|BUGLVL
c_func
(paren
id|D_RX
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: brand new splitpacket (splitflag=%d)&bslash;n&quot;
comma
id|arcsoft-&gt;split_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;skb
)paren
multiline_comment|/* already assembling one! */
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: aborting previous (seq=%d) assembly (splitflag=%d, seq=%d)&bslash;n&quot;
comma
id|in-&gt;sequence
comma
id|arcsoft-&gt;split_flag
comma
id|arcsoft-&gt;sequence
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|in-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|in-&gt;sequence
op_assign
id|arcsoft-&gt;sequence
suffix:semicolon
id|in-&gt;numpackets
op_assign
(paren
(paren
r_int
)paren
id|arcsoft-&gt;split_flag
op_rshift
l_int|1
)paren
op_plus
l_int|2
suffix:semicolon
id|in-&gt;lastpacket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|in-&gt;numpackets
OG
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: incoming packet more than 16 segments; dropping. (splitflag=%d)&bslash;n&quot;
comma
id|arcsoft-&gt;split_flag
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|in-&gt;skb
op_assign
id|skb
op_assign
id|alloc_skb
c_func
(paren
l_int|508
op_star
id|in-&gt;numpackets
op_plus
r_sizeof
(paren
r_struct
id|ClientData
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: (split) memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* I don&squot;t know what this is for, but it DOES avoid&n;&t;                 * warnings...&n;&t;                 */
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|soft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|u_char
op_star
)paren
id|soft
op_plus
id|EXTRA_CLIENTDATA
comma
(paren
id|u_char
op_star
)paren
id|arcsoft
op_plus
id|EXTRA_CLIENTDATA
comma
r_sizeof
(paren
r_struct
id|ClientData
)paren
op_minus
id|EXTRA_CLIENTDATA
)paren
suffix:semicolon
id|soft-&gt;split_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* final packet won&squot;t be split */
)brace
r_else
multiline_comment|/* not first packet */
(brace
r_int
id|packetnum
op_assign
(paren
(paren
r_int
)paren
id|arcsoft-&gt;split_flag
op_rshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* if we&squot;re not assembling, there&squot;s no point&n;&t;&t;&t; * trying to continue.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|in-&gt;skb
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: can&squot;t continue split without starting first! (splitflag=%d, seq=%d)&bslash;n&quot;
comma
id|arcsoft-&gt;split_flag
comma
id|arcsoft-&gt;sequence
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|in-&gt;lastpacket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|packetnum
op_ne
id|in-&gt;lastpacket
)paren
multiline_comment|/* not the right flag! */
(brace
multiline_comment|/* harmless duplicate? ignore. */
r_if
c_cond
(paren
id|packetnum
op_le
id|in-&gt;lastpacket
op_minus
l_int|1
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: duplicate splitpacket ignored! (splitflag=%d)&bslash;n&quot;
comma
id|arcsoft-&gt;split_flag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &quot;bad&quot; duplicate, kill reassembly */
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: out-of-order splitpacket, reassembly (seq=%d) aborted (splitflag=%d, seq=%d)&bslash;n&quot;
comma
id|in-&gt;sequence
comma
id|arcsoft-&gt;split_flag
comma
id|arcsoft-&gt;sequence
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|in-&gt;skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|in-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|in-&gt;lastpacket
op_assign
id|in-&gt;numpackets
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|soft
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|in-&gt;skb-&gt;data
suffix:semicolon
)brace
id|skb
op_assign
id|in-&gt;skb
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
op_plus
id|skb-&gt;len
comma
(paren
id|u_char
op_star
)paren
id|arcsoft
op_plus
r_sizeof
(paren
r_struct
id|ClientData
)paren
comma
id|length
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
)paren
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|length
op_minus
r_sizeof
(paren
r_struct
id|ClientData
)paren
suffix:semicolon
id|soft-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|soft-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: received packet from %02Xh to %02Xh (%d bytes, type=%d)&bslash;n&quot;
comma
id|saddr
comma
id|daddr
comma
id|length
comma
id|pkttype
)paren
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_RX
)paren
(brace
r_int
id|countx
comma
id|county
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arcnet: packet dump [rx-split] follows:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|county
op_assign
l_int|0
suffix:semicolon
id|county
OL
l_int|16
op_plus
(paren
id|pkttype
op_ne
id|NORMAL
)paren
op_star
l_int|16
suffix:semicolon
id|county
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n[%04X] &quot;
comma
id|county
op_star
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
id|countx
op_assign
l_int|0
suffix:semicolon
id|countx
OL
l_int|16
suffix:semicolon
id|countx
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02X &quot;
comma
id|arcpacket-&gt;raw
(braket
id|county
op_star
l_int|16
op_plus
id|countx
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* are we done? */
r_if
c_cond
(paren
id|in-&gt;lastpacket
op_eq
id|in-&gt;numpackets
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb
op_logical_or
op_logical_neg
id|in-&gt;skb
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: ?!? done reassembling packet, no skb? (skb=%ph, in-&gt;skb=%ph)&bslash;n&quot;
comma
id|skb
comma
id|in-&gt;skb
)paren
suffix:semicolon
id|in-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|in-&gt;lastpacket
op_assign
id|in-&gt;numpackets
op_assign
l_int|0
suffix:semicolon
id|BUGLVL
c_func
(paren
id|D_DATA
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|16
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n[%04hX] &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02hX &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;data
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* If any worth-while packets have been received, dev_rint()&n;&t;   has done a mark_bh(NET_BH) for us and will work on them&n;&t;   when we get to the bottom-half routine. */
multiline_comment|/* arcnet: pardon? */
)brace
macro_line|#ifdef USE_TIMER_HANDLER
multiline_comment|/* this function is called every once in a while to make sure the ARCnet&n; * isn&squot;t stuck.&n; *&n; * If we miss a receive IRQ, the receiver (and IRQ) is permanently disabled&n; * and we might never receive a packet again!  This will check if this&n; * is the case, and if so, re-enable the receiver.&n; */
r_static
r_void
DECL|function|arcnet_timer
id|arcnet_timer
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
id|inb
c_func
(paren
id|STATUS
)paren
suffix:semicolon
multiline_comment|/* if we didn&squot;t interrupt the IRQ handler, and RX&squot;s are still&n;&t; * disabled, and we&squot;re not resetting the card... then we&squot;re stuck!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;interrupt
op_logical_and
id|dev-&gt;start
op_logical_and
id|status
op_amp
id|NORXflag
op_logical_and
op_logical_neg
id|status
op_amp
id|RESETflag
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: timer: ARCnet was stuck!  (status=%Xh)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|arcnet_inthandler
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* requeue ourselves */
id|init_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
id|lp-&gt;timer.expires
op_assign
id|TIMERval
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|enet_statistics
op_star
DECL|function|arcnet_get_stats
id|arcnet_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&t;short ioaddr = dev-&gt;base_addr;*/
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n;   num_addrs == -1&t;Promiscuous mode, receive all packets&n;   num_addrs == 0&t;Normal mode, clear multicast list&n;   num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;&t;&t;&t;best-effort filtering.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
macro_line|#if 0&t;  /* no promiscuous mode at all */
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|num_addrs
)paren
(brace
id|outw
c_func
(paren
l_int|69
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Enable promiscuous mode */
)brace
r_else
id|outw
c_func
(paren
l_int|99
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Disable promiscuous mode, use normal mode */
macro_line|#endif
)brace
DECL|function|arcnet_reset
r_int
id|arcnet_reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|delayval
comma
id|recbuf
op_assign
id|lp-&gt;recbuf
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INTMASK
)paren
suffix:semicolon
multiline_comment|/* no IRQ&squot;s, please! */
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: Resetting %s (status=%Xh)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|STATUS
)paren
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RESET
)paren
suffix:semicolon
multiline_comment|/* Reset by reading this port */
id|JIFFER
c_func
(paren
id|RESETtime
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CFLAGScmd
op_or
id|RESETclear
comma
id|COMMAND
)paren
suffix:semicolon
multiline_comment|/* clear flags &amp; end reset */
id|outb
c_func
(paren
id|CFLAGScmd
op_or
id|CONFIGclear
comma
id|COMMAND
)paren
suffix:semicolon
multiline_comment|/* after a reset, the first byte of shared mem is TESTvalue and the&n;&t; * second byte is our 8-bit ARCnet address&n;&t; */
(brace
id|u_char
op_star
id|cardmem
op_assign
(paren
id|u_char
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
r_if
c_cond
(paren
id|cardmem
(braket
l_int|0
)braket
op_ne
id|TESTvalue
)paren
(brace
id|BUGLVL
c_func
(paren
id|D_INIT
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: reset failed: TESTvalue not present.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lp-&gt;arcnum
op_assign
id|cardmem
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* save address for later use */
)brace
multiline_comment|/* clear out status variables */
id|recbuf
op_assign
id|lp-&gt;recbuf
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;txbuf
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*dev-&gt;tbusy=0;*/
multiline_comment|/* enable extended (512-byte) packets */
id|outb
c_func
(paren
id|CONFIGcmd
op_or
id|EXTconf
comma
id|COMMAND
)paren
suffix:semicolon
id|XJIFFER
c_func
(paren
id|ACKtime
)paren
suffix:semicolon
multiline_comment|/* clean out all the memory to make debugging make more sense :) */
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
comma
l_int|0x42
comma
l_int|2048
)paren
suffix:semicolon
multiline_comment|/* and enable receive of our first packet to the first buffer */
id|EnableReceiver
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* re-enable interrupts */
id|outb
c_func
(paren
id|NORXflag
comma
id|INTMASK
)paren
suffix:semicolon
multiline_comment|/* done!  return success. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t; Create the ARCnet ClientData header for an arbitrary protocol layer&n; *&n; *&t;saddr=NULL&t;means use device source address (always will anyway)&n; *&t;daddr=NULL&t;means leave destination address (eg unresolved arp)&n; */
DECL|function|arc_header
r_int
id|arc_header
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ClientData
op_star
id|head
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|buff
suffix:semicolon
r_struct
id|arcnet_local
op_star
id|lp
op_assign
(paren
r_struct
id|arcnet_local
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
multiline_comment|/* set the protocol ID according to RFC-1201 */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|ETH_P_IP
suffix:colon
id|head-&gt;protocol_id
op_assign
id|ARC_P_IP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_ARP
suffix:colon
id|head-&gt;protocol_id
op_assign
id|ARC_P_ARP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_RARP
suffix:colon
id|head-&gt;protocol_id
op_assign
id|ARC_P_RARP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_IPX
suffix:colon
id|head-&gt;protocol_id
op_assign
id|ARC_P_IPX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_ATALK
suffix:colon
id|head-&gt;protocol_id
op_assign
id|ARC_P_ATALK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;arcnet: I don&squot;t understand protocol %d (%Xh)&bslash;n&quot;
comma
id|type
comma
id|type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 1
multiline_comment|/*&n;&t; *&t;Set the source hardware address.&n;&t; *&t;AVE: we can&squot;t do this, so we don&squot;t.  Code below is directly&n;&t; *&t;     stolen from eth.c driver and won&squot;t work.&n;&t; ** TM: but for debugging I would like to have saddr in the header&n;&t; */
r_if
c_cond
(paren
id|saddr
)paren
(brace
id|head-&gt;saddr
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|saddr
)paren
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
id|head-&gt;saddr
op_assign
(paren
(paren
id|u_char
op_star
)paren
(paren
id|dev-&gt;dev_addr
)paren
)paren
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/*&n;&t; *&t;Anyway, the loopback-device should never use this function... &n;&t; *&n;&t; *&t;And the chances of it using the ARCnet version of it are so&n;&t; *&t;tiny that I don&squot;t think we have to worry :)&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
(brace
id|head-&gt;daddr
op_assign
l_int|0
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
macro_line|#endif
id|head-&gt;split_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* split packets are done elsewhere */
id|head-&gt;sequence
op_assign
(paren
id|lp-&gt;sequence
op_increment
)paren
suffix:semicolon
multiline_comment|/* supposedly if daddr is NULL, we should ignore it... */
r_if
c_cond
(paren
id|daddr
)paren
(brace
id|head-&gt;daddr
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|daddr
)paren
(braket
l_int|0
)braket
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
r_else
id|head-&gt;daddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* better fill one in anyway */
r_return
op_minus
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rebuild the ARCnet ClientData header. This is called after an ARP&n; *&t;(or in future other address resolution) has completed on this&n; *&t;sk_buff. We now let ARP fill in the other fields.&n; */
DECL|function|arc_rebuild_header
r_int
id|arc_rebuild_header
c_func
(paren
r_void
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|dst
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ClientData
op_star
id|head
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|buff
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Only ARP/IP is currently supported&n;&t; */
r_if
c_cond
(paren
id|head-&gt;protocol_id
op_ne
id|ARC_P_IP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arcnet: I don&squot;t understand resolve type %d (%Xh) addresses!&bslash;n&quot;
comma
id|head-&gt;protocol_id
comma
id|head-&gt;protocol_id
)paren
suffix:semicolon
id|head-&gt;daddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*memcpy(eth-&gt;h_source, dev-&gt;dev_addr, dev-&gt;addr_len);*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Try and get ARP to resolve the header.&n;&t; */
macro_line|#ifdef CONFIG_INET&t; 
r_return
id|arp_find
c_func
(paren
op_amp
(paren
id|head-&gt;daddr
)paren
comma
id|dst
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
id|skb
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; *&t;Determine the packet&squot;s protocol ID.&n; *&n; *&t;With ARCnet we have to convert everything to Ethernet-style stuff.&n; */
DECL|function|arc_type_trans
r_int
r_int
id|arc_type_trans
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ClientData
op_star
id|head
op_assign
(paren
r_struct
id|ClientData
op_star
)paren
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*unsigned char *rawp;*/
r_if
c_cond
(paren
id|head-&gt;daddr
op_eq
l_int|0
)paren
id|skb-&gt;pkt_type
op_assign
id|PACKET_BROADCAST
suffix:semicolon
macro_line|#if 0 /* code for ethernet with multicast */
r_if
c_cond
(paren
op_star
id|eth-&gt;h_dest
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;broadcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
(brace
id|skb-&gt;pkt_type
op_assign
id|PACKET_BROADCAST
suffix:semicolon
)brace
r_else
id|skb-&gt;pkt_type
op_assign
id|PACKET_MULTICAST
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* if we&squot;re not sending to ourselves :) */
r_if
c_cond
(paren
id|head-&gt;daddr
op_ne
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
id|skb-&gt;pkt_type
op_assign
id|PACKET_OTHERHOST
suffix:semicolon
)brace
multiline_comment|/* now return the protocol number */
r_switch
c_cond
(paren
id|head-&gt;protocol_id
)paren
(brace
r_case
id|ARC_P_IP
suffix:colon
r_return
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_case
id|ARC_P_ARP
suffix:colon
r_return
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
r_case
id|ARC_P_RARP
suffix:colon
r_return
id|htons
c_func
(paren
id|ETH_P_RARP
)paren
suffix:semicolon
r_case
id|ARC_P_IPX
suffix:colon
r_return
id|htons
c_func
(paren
id|ETH_P_IPX
)paren
suffix:semicolon
r_case
id|ARC_P_ATALK
suffix:colon
r_return
id|htons
c_func
(paren
id|ETH_P_ATALK
)paren
suffix:semicolon
multiline_comment|/* appletalk, not tested */
r_case
id|ARC_P_LANSOFT
suffix:colon
multiline_comment|/* don&squot;t understand.  fall through. */
r_default
suffix:colon
id|BUGLVL
c_func
(paren
id|D_DURING
)paren
id|printk
c_func
(paren
l_string|&quot;arcnet: received packet of unknown protocol id %d (%Xh)&bslash;n&quot;
comma
id|head-&gt;protocol_id
comma
id|head-&gt;protocol_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0 /* more ethernet-specific junk */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|eth-&gt;h_proto
)paren
op_ge
l_int|1536
)paren
r_return
id|eth-&gt;h_proto
suffix:semicolon
id|rawp
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|eth
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xFFFF
)paren
r_return
id|htons
c_func
(paren
id|ETH_P_802_3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xAAAA
)paren
r_return
id|htons
c_func
(paren
id|ETH_P_SNAP
)paren
suffix:semicolon
r_return
id|htons
c_func
(paren
id|ETH_P_802_2
)paren
suffix:semicolon
macro_line|#endif
r_return
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|variable|thisARCnet
r_static
r_struct
id|device
id|thisARCnet
op_assign
(brace
l_string|&quot;      &quot;
comma
multiline_comment|/* if blank, device name inserted by /linux/drivers/net/net_init.c */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* I/O address, IRQ */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|arcnet_probe
)brace
suffix:semicolon
DECL|variable|io
r_int
id|io
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* &lt;--- EDIT THESE LINES FOR YOUR CONFIGURATION */
DECL|variable|irqnum
r_int
id|irqnum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* or use the insmod io= irq= shmem= options */
DECL|variable|shmem
r_int
id|shmem
op_assign
l_int|0
suffix:semicolon
DECL|variable|num
r_int
id|num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of device (ie for arc0, arc1, arc2...) */
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
id|sprintf
c_func
(paren
id|thisARCnet.name
comma
l_string|&quot;arc%d&quot;
comma
id|num
)paren
suffix:semicolon
id|thisARCnet.base_addr
op_assign
id|io
suffix:semicolon
id|thisARCnet.irq
op_assign
id|irqnum
suffix:semicolon
r_if
c_cond
(paren
id|thisARCnet.irq
op_eq
l_int|2
)paren
id|thisARCnet.irq
op_assign
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|shmem
)paren
(brace
id|thisARCnet.mem_start
op_assign
id|shmem
suffix:semicolon
id|thisARCnet.mem_end
op_assign
id|thisARCnet.mem_start
op_plus
l_int|512
op_star
l_int|4
op_minus
l_int|1
suffix:semicolon
id|thisARCnet.rmem_start
op_assign
id|thisARCnet.mem_start
op_plus
l_int|512
op_star
l_int|0
suffix:semicolon
id|thisARCnet.rmem_end
op_assign
id|thisARCnet.mem_start
op_plus
l_int|512
op_star
l_int|2
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|thisARCnet
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: device busy, remove delayed&bslash;n&quot;
comma
id|thisARCnet.name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|thisARCnet.start
)paren
id|arcnet_close
c_func
(paren
op_amp
id|thisARCnet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisARCnet.irq
)paren
id|free_irq
c_func
(paren
id|thisARCnet.irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisARCnet.base_addr
)paren
id|release_region
c_func
(paren
id|thisARCnet.base_addr
comma
id|ETHERCARD_TOTAL_SIZE
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|thisARCnet
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c skeleton.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 4&n; * End:&n; */
eof
