multiline_comment|/* hplance.c  : the  Linux/hp300/lance ethernet driver&n; *&n; * Copyright (C) 05/1998 Peter Maydell &lt;pmaydell@chiark.greenend.org.uk&gt;&n; * Based on the Sun Lance driver and the NetBSD HP Lance driver&n; * Uses the generic 7990.c LANCE code.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/* Used for the temporal inet entries and routing */
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/route.h&gt;
macro_line|#include &lt;linux/dio.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;hplance.h&quot;
multiline_comment|/* We have 16834 bytes of RAM for the init block and buffers. This places&n; * an upper limit on the number of buffers we can use. NetBSD uses 8 Rx&n; * buffers and 2 Tx buffers.&n; */
DECL|macro|LANCE_LOG_TX_BUFFERS
mdefine_line|#define LANCE_LOG_TX_BUFFERS 1
DECL|macro|LANCE_LOG_RX_BUFFERS
mdefine_line|#define LANCE_LOG_RX_BUFFERS 3
macro_line|#include &quot;7990.h&quot;                                 /* use generic LANCE code */
multiline_comment|/* Our private data structure */
DECL|struct|hplance_private
r_struct
id|hplance_private
(brace
DECL|member|lance
r_struct
id|lance_private
id|lance
suffix:semicolon
DECL|member|scode
r_int
r_int
id|scode
suffix:semicolon
DECL|member|base
r_void
op_star
id|base
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* function prototypes... This is easy because all the grot is in the&n; * generic LANCE support. All we have to support is probing for boards,&n; * plus board-specific init, open and close actions. &n; * Oh, and we need to tell the generic code how to read and write LANCE registers...&n; */
r_int
id|hplance_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|hplance_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|scode
)paren
suffix:semicolon
r_static
r_int
id|hplance_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|hplance_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hplance_writerap
c_func
(paren
r_struct
id|hplance_private
op_star
id|lp
comma
r_int
r_int
id|value
)paren
suffix:semicolon
r_static
r_void
id|hplance_writerdp
c_func
(paren
r_struct
id|hplance_private
op_star
id|lp
comma
r_int
r_int
id|value
)paren
suffix:semicolon
r_static
r_int
r_int
id|hplance_readrdp
c_func
(paren
r_struct
id|hplance_private
op_star
id|lp
)paren
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|root_hplance_dev
r_static
r_struct
id|hplance_private
op_star
id|root_hplance_dev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
multiline_comment|/* Find all the HP Lance boards and initialise them... */
DECL|function|hplance_probe
r_int
id|__init
id|hplance_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|cards
op_assign
l_int|0
comma
id|called
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_HP300
op_logical_or
id|called
)paren
r_return
id|ENODEV
suffix:semicolon
id|called
op_increment
suffix:semicolon
multiline_comment|/* Isn&squot;t DIO nice? */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|v
comma
id|scode
op_assign
id|dio_find
c_func
(paren
id|DIO_ID_LAN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scode
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cards
)paren
(brace
id|dev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* don&squot;t trash previous device, make a new one */
id|cards
op_increment
suffix:semicolon
id|v
op_assign
id|hplance_init
c_func
(paren
id|dev
comma
id|scode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
)paren
multiline_comment|/* error, abort immediately */
r_return
id|v
suffix:semicolon
)brace
multiline_comment|/* OK, return success, or ENODEV if we didn&squot;t find any cards */
r_if
c_cond
(paren
op_logical_neg
id|cards
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialise a single lance board at the given select code */
DECL|function|hplance_init
r_static
r_int
id|__init
id|hplance_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|scode
)paren
(brace
multiline_comment|/* const char *name = dio_scodetoname(scode); */
r_static
r_const
r_char
id|name
(braket
)braket
op_assign
l_string|&quot;HP LANCE&quot;
suffix:semicolon
r_void
op_star
id|va
op_assign
id|dio_scodetoviraddr
c_func
(paren
id|scode
)paren
suffix:semicolon
r_struct
id|hplance_private
op_star
id|lp
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef MODULE
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
r_sizeof
(paren
r_struct
id|hplance_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#else
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hplance_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hplance_private
)paren
)paren
suffix:semicolon
macro_line|#endif
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: HP LANCE; select code %d, addr&quot;
comma
id|dev-&gt;name
comma
id|scode
)paren
suffix:semicolon
multiline_comment|/* reset the board */
id|writeb
c_func
(paren
l_int|0xff
comma
id|va
op_plus
id|DIO_IDOFF
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* ariba! ariba! udelay! udelay! */
multiline_comment|/* Fill the dev fields */
id|dev-&gt;base_addr
op_assign
(paren
r_int
r_int
)paren
id|va
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|hplance_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|hplance_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|lance_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|lance_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|lance_set_multicast
suffix:semicolon
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* The NVRAM holds our ethernet address, one nibble per byte,&n;                 * at bytes NVRAMOFF+1,3,5,7,9...&n;                 */
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
id|readb
c_func
(paren
id|va
op_plus
id|HPLANCE_NVRAMOFF
op_plus
id|i
op_star
l_int|4
op_plus
l_int|1
)paren
op_amp
l_int|0xF
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|readb
c_func
(paren
id|va
op_plus
id|HPLANCE_NVRAMOFF
op_plus
id|i
op_star
l_int|4
op_plus
l_int|3
)paren
op_amp
l_int|0xF
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c%2.2x&quot;
comma
id|i
op_eq
l_int|0
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;:&squot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|hplance_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;lance.name
op_assign
(paren
r_char
op_star
)paren
id|name
suffix:semicolon
multiline_comment|/* discards const, shut up gcc */
id|lp-&gt;lance.ll
op_assign
(paren
r_struct
id|lance_regs
op_star
)paren
(paren
id|va
op_plus
id|HPLANCE_REGOFF
)paren
suffix:semicolon
id|lp-&gt;lance.init_block
op_assign
(paren
r_struct
id|lance_init_block
op_star
)paren
(paren
id|va
op_plus
id|HPLANCE_MEMOFF
)paren
suffix:semicolon
multiline_comment|/* CPU addr */
id|lp-&gt;lance.lance_init_block
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* LANCE addr of same RAM */
id|lp-&gt;lance.busmaster_regval
op_assign
id|LE_C3_BSWP
suffix:semicolon
multiline_comment|/* we&squot;re bigendian */
id|lp-&gt;lance.irq
op_assign
id|dio_scodetoipl
c_func
(paren
id|scode
)paren
suffix:semicolon
id|lp-&gt;lance.writerap
op_assign
id|hplance_writerap
suffix:semicolon
id|lp-&gt;lance.writerdp
op_assign
id|hplance_writerdp
suffix:semicolon
id|lp-&gt;lance.readrdp
op_assign
id|hplance_readrdp
suffix:semicolon
id|lp-&gt;lance.lance_log_rx_bufs
op_assign
id|LANCE_LOG_RX_BUFFERS
suffix:semicolon
id|lp-&gt;lance.lance_log_tx_bufs
op_assign
id|LANCE_LOG_TX_BUFFERS
suffix:semicolon
id|lp-&gt;lance.rx_ring_mod_mask
op_assign
id|RX_RING_MOD_MASK
suffix:semicolon
id|lp-&gt;lance.tx_ring_mod_mask
op_assign
id|TX_RING_MOD_MASK
suffix:semicolon
id|lp-&gt;scode
op_assign
id|scode
suffix:semicolon
id|lp-&gt;base
op_assign
id|va
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, irq %d&bslash;n&quot;
comma
id|lp-&gt;lance.irq
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
id|lp-&gt;next_module
op_assign
id|root_hplance_dev
suffix:semicolon
id|root_hplance_dev
op_assign
id|lp
suffix:semicolon
macro_line|#endif /* MODULE */
id|dio_config_board
c_func
(paren
id|scode
)paren
suffix:semicolon
multiline_comment|/* tell bus scanning code this one&squot;s taken */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is disgusting. We have to check the DIO status register for ack every&n; * time we read or write the LANCE registers.&n; */
DECL|function|hplance_writerap
r_static
r_void
id|hplance_writerap
c_func
(paren
r_struct
id|hplance_private
op_star
id|lp
comma
r_int
r_int
id|value
)paren
(brace
r_struct
id|hplance_reg
op_star
id|hpregs
op_assign
(paren
r_struct
id|hplance_reg
op_star
)paren
id|lp-&gt;base
suffix:semicolon
r_do
(brace
id|lp-&gt;lance.ll-&gt;rap
op_assign
id|value
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hpregs-&gt;status
op_amp
id|LE_ACK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|hplance_writerdp
r_static
r_void
id|hplance_writerdp
c_func
(paren
r_struct
id|hplance_private
op_star
id|lp
comma
r_int
r_int
id|value
)paren
(brace
r_struct
id|hplance_reg
op_star
id|hpregs
op_assign
(paren
r_struct
id|hplance_reg
op_star
)paren
id|lp-&gt;base
suffix:semicolon
r_do
(brace
id|lp-&gt;lance.ll-&gt;rdp
op_assign
id|value
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hpregs-&gt;status
op_amp
id|LE_ACK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|hplance_readrdp
r_static
r_int
r_int
id|hplance_readrdp
c_func
(paren
r_struct
id|hplance_private
op_star
id|lp
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_struct
id|hplance_reg
op_star
id|hpregs
op_assign
(paren
r_struct
id|hplance_reg
op_star
)paren
id|lp-&gt;base
suffix:semicolon
r_do
(brace
id|val
op_assign
id|lp-&gt;lance.ll-&gt;rdp
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hpregs-&gt;status
op_amp
id|LE_ACK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|hplance_open
r_static
r_int
id|hplance_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|hplance_private
op_star
id|lp
op_assign
(paren
r_struct
id|hplance_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|hplance_reg
op_star
id|hpregs
op_assign
(paren
r_struct
id|hplance_reg
op_star
)paren
id|lp-&gt;base
suffix:semicolon
id|status
op_assign
id|lance_open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* call generic lance open code */
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* enable interrupts at board level. */
id|writeb
c_func
(paren
id|LE_IE
comma
op_amp
(paren
id|hpregs-&gt;status
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hplance_close
r_static
r_int
id|hplance_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hplance_private
op_star
id|lp
op_assign
(paren
r_struct
id|hplance_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|hplance_reg
op_star
id|hpregs
op_assign
(paren
r_struct
id|hplance_reg
op_star
)paren
id|lp-&gt;base
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
(paren
id|hpregs-&gt;status
)paren
)paren
suffix:semicolon
multiline_comment|/* disable interrupts at boardlevel */
id|lance_close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|root_lance_dev
op_assign
l_int|NULL
suffix:semicolon
r_return
id|hplance_probe
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Walk the chain of devices, unregistering them */
r_struct
id|hplance_private
op_star
id|lp
suffix:semicolon
r_while
c_loop
(paren
id|root_hplance_dev
)paren
(brace
id|lp
op_assign
id|root_hplance_dev-&gt;next_module
suffix:semicolon
id|dio_unconfig_board
c_func
(paren
id|lp-&gt;scode
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|root_lance_dev-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|root_lance_dev-&gt;dev
)paren
suffix:semicolon
id|root_lance_dev
op_assign
id|lp
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
eof
