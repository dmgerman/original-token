multiline_comment|/*&n; * Update: The Berkeley copyright was changed, and the change &n; * is retroactive to all &quot;true&quot; BSD software (ie everything&n; * from UCB as opposed to other peoples code that just carried&n; * the same license). The new copyright doesn&squot;t clash with the&n; * GPL, so the module-only restriction has been removed..&n; */
multiline_comment|/* Because this code is derived from the 4.3BSD compress source:&n; *&n; * Copyright (c) 1985, 1986 The Regents of the University of California.&n; * All rights reserved.&n; *&n; * This code is derived from software contributed to Berkeley by&n; * James A. Woods, derived from original work by Spencer Thomas&n; * and Joseph Orost.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. All advertising materials mentioning features or use of this software&n; *    must display the following acknowledgement:&n; *&t;This product includes software developed by the University of&n; *&t;California, Berkeley and its contributors.&n; * 4. Neither the name of the University nor the names of its contributors&n; *    may be used to endorse or promote products derived from this software&n; *    without specific prior written permission.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n; * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
multiline_comment|/*&n; * This version is for use with contiguous buffers on Linux-derived systems.&n; *&n; *  ==FILEVERSION 20000226==&n; *&n; *  NOTE TO MAINTAINERS:&n; *     If you modify this file at all, please set the number above to the&n; *     date of the modification as YYMMDD (year month day).&n; *     bsd_comp.c is shipped with a PPP distribution as well as with&n; *     the kernel; if everyone increases the FILEVERSION number above,&n; *     then scripts can do the right thing when deciding whether to&n; *     install a new bsd_comp.c file. Don&squot;t change the format of that&n; *     line otherwise, so the installation script can recognize it.&n; *&n; * From: bsd_comp.c,v 1.3 1994/12/08 01:59:58 paulus Exp&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/ppp_defs.h&gt;
DECL|macro|PACKETPTR
macro_line|#undef   PACKETPTR
DECL|macro|PACKETPTR
mdefine_line|#define  PACKETPTR 1
macro_line|#include &lt;linux/ppp-comp.h&gt;
DECL|macro|PACKETPTR
macro_line|#undef   PACKETPTR
multiline_comment|/*&n; * PPP &quot;BSD compress&quot; compression&n; *  The differences between this compression and the classic BSD LZW&n; *  source are obvious from the requirement that the classic code worked&n; *  with files while this handles arbitrarily long streams that&n; *  are broken into packets.  They are:&n; *&n; *&t;When the code size expands, a block of junk is not emitted by&n; *&t;    the compressor and not expected by the decompressor.&n; *&n; *&t;New codes are not necessarily assigned every time an old&n; *&t;    code is output by the compressor.  This is because a packet&n; *&t;    end forces a code to be emitted, but does not imply that a&n; *&t;    new sequence has been seen.&n; *&n; *&t;The compression ratio is checked at the first end of a packet&n; *&t;    after the appropriate gap.&t;Besides simplifying and speeding&n; *&t;    things up, this makes it more likely that the transmitter&n; *&t;    and receiver will agree when the dictionary is cleared when&n; *&t;    compression is not going well.&n; */
multiline_comment|/*&n; * Macros to extract protocol version and number of bits&n; * from the third byte of the BSD Compress CCP configuration option.&n; */
DECL|macro|BSD_VERSION
mdefine_line|#define BSD_VERSION(x)&t;((x) &gt;&gt; 5)
DECL|macro|BSD_NBITS
mdefine_line|#define BSD_NBITS(x)&t;((x) &amp; 0x1F)
DECL|macro|BSD_CURRENT_VERSION
mdefine_line|#define BSD_CURRENT_VERSION&t;1
multiline_comment|/*&n; * A dictionary for doing BSD compress.&n; */
DECL|struct|bsd_dict
r_struct
id|bsd_dict
(brace
r_union
(brace
multiline_comment|/* hash value */
DECL|member|fcode
r_int
r_int
id|fcode
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN)&t;&t;/* Little endian order */
DECL|member|prefix
r_int
r_int
id|prefix
suffix:semicolon
multiline_comment|/* preceding code */
DECL|member|suffix
r_int
r_char
id|suffix
suffix:semicolon
multiline_comment|/* last character of new code */
DECL|member|pad
r_int
r_char
id|pad
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN)&t;&t;/* Big endian order */
r_int
r_char
id|pad
suffix:semicolon
r_int
r_char
id|suffix
suffix:semicolon
multiline_comment|/* last character of new code */
r_int
r_int
id|prefix
suffix:semicolon
multiline_comment|/* preceding code */
macro_line|#else
macro_line|#error Endianness not defined...
macro_line|#endif
DECL|member|hs
)brace
id|hs
suffix:semicolon
DECL|member|f
)brace
id|f
suffix:semicolon
DECL|member|codem1
r_int
r_int
id|codem1
suffix:semicolon
multiline_comment|/* output of hash table -1 */
DECL|member|cptr
r_int
r_int
id|cptr
suffix:semicolon
multiline_comment|/* map code to hash table entry */
)brace
suffix:semicolon
DECL|struct|bsd_db
r_struct
id|bsd_db
(brace
DECL|member|totlen
r_int
id|totlen
suffix:semicolon
multiline_comment|/* length of this structure */
DECL|member|hsize
r_int
r_int
id|hsize
suffix:semicolon
multiline_comment|/* size of the hash table */
DECL|member|hshift
r_int
r_char
id|hshift
suffix:semicolon
multiline_comment|/* used in hash function */
DECL|member|n_bits
r_int
r_char
id|n_bits
suffix:semicolon
multiline_comment|/* current bits/code */
DECL|member|maxbits
r_int
r_char
id|maxbits
suffix:semicolon
multiline_comment|/* maximum bits/code */
DECL|member|debug
r_int
r_char
id|debug
suffix:semicolon
multiline_comment|/* non-zero if debug desired */
DECL|member|unit
r_int
r_char
id|unit
suffix:semicolon
multiline_comment|/* ppp unit number */
DECL|member|seqno
r_int
r_int
id|seqno
suffix:semicolon
multiline_comment|/* sequence # of next packet */
DECL|member|mru
r_int
r_int
id|mru
suffix:semicolon
multiline_comment|/* size of receive (decompress) bufr */
DECL|member|maxmaxcode
r_int
r_int
id|maxmaxcode
suffix:semicolon
multiline_comment|/* largest valid code */
DECL|member|max_ent
r_int
r_int
id|max_ent
suffix:semicolon
multiline_comment|/* largest code in use */
DECL|member|in_count
r_int
r_int
id|in_count
suffix:semicolon
multiline_comment|/* uncompressed bytes, aged */
DECL|member|bytes_out
r_int
r_int
id|bytes_out
suffix:semicolon
multiline_comment|/* compressed bytes, aged */
DECL|member|ratio
r_int
r_int
id|ratio
suffix:semicolon
multiline_comment|/* recent compression ratio */
DECL|member|checkpoint
r_int
r_int
id|checkpoint
suffix:semicolon
multiline_comment|/* when to next check the ratio */
DECL|member|clear_count
r_int
r_int
id|clear_count
suffix:semicolon
multiline_comment|/* times dictionary cleared */
DECL|member|incomp_count
r_int
r_int
id|incomp_count
suffix:semicolon
multiline_comment|/* incompressible packets */
DECL|member|incomp_bytes
r_int
r_int
id|incomp_bytes
suffix:semicolon
multiline_comment|/* incompressible bytes */
DECL|member|uncomp_count
r_int
r_int
id|uncomp_count
suffix:semicolon
multiline_comment|/* uncompressed packets */
DECL|member|uncomp_bytes
r_int
r_int
id|uncomp_bytes
suffix:semicolon
multiline_comment|/* uncompressed bytes */
DECL|member|comp_count
r_int
r_int
id|comp_count
suffix:semicolon
multiline_comment|/* compressed packets */
DECL|member|comp_bytes
r_int
r_int
id|comp_bytes
suffix:semicolon
multiline_comment|/* compressed bytes */
DECL|member|lens
r_int
r_int
op_star
id|lens
suffix:semicolon
multiline_comment|/* array of lengths of codes */
DECL|member|dict
r_struct
id|bsd_dict
op_star
id|dict
suffix:semicolon
multiline_comment|/* dictionary */
)brace
suffix:semicolon
DECL|macro|BSD_OVHD
mdefine_line|#define BSD_OVHD&t;2&t;&t;/* BSD compress overhead/packet */
DECL|macro|MIN_BSD_BITS
mdefine_line|#define MIN_BSD_BITS&t;9
DECL|macro|BSD_INIT_BITS
mdefine_line|#define BSD_INIT_BITS&t;MIN_BSD_BITS
DECL|macro|MAX_BSD_BITS
mdefine_line|#define MAX_BSD_BITS&t;15
r_static
r_void
id|bsd_free
(paren
r_void
op_star
id|state
)paren
suffix:semicolon
r_static
r_void
op_star
id|bsd_alloc
c_func
(paren
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|decomp
)paren
suffix:semicolon
r_static
r_void
op_star
id|bsd_comp_alloc
(paren
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
)paren
suffix:semicolon
r_static
r_void
op_star
id|bsd_decomp_alloc
(paren
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
)paren
suffix:semicolon
r_static
r_int
id|bsd_init
(paren
r_void
op_star
id|db
comma
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|unit
comma
r_int
id|debug
comma
r_int
id|decomp
)paren
suffix:semicolon
r_static
r_int
id|bsd_comp_init
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|unit
comma
r_int
id|opthdr
comma
r_int
id|debug
)paren
suffix:semicolon
r_static
r_int
id|bsd_decomp_init
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|unit
comma
r_int
id|opthdr
comma
r_int
id|mru
comma
r_int
id|debug
)paren
suffix:semicolon
r_static
r_void
id|bsd_reset
(paren
r_void
op_star
id|state
)paren
suffix:semicolon
r_static
r_void
id|bsd_comp_stats
(paren
r_void
op_star
id|state
comma
r_struct
id|compstat
op_star
id|stats
)paren
suffix:semicolon
r_static
r_int
id|bsd_compress
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|rptr
comma
r_int
r_char
op_star
id|obuf
comma
r_int
id|isize
comma
r_int
id|osize
)paren
suffix:semicolon
r_static
r_void
id|bsd_incomp
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|ibuf
comma
r_int
id|icnt
)paren
suffix:semicolon
r_static
r_int
id|bsd_decompress
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|ibuf
comma
r_int
id|isize
comma
r_int
r_char
op_star
id|obuf
comma
r_int
id|osize
)paren
suffix:semicolon
multiline_comment|/* These are in ppp.c */
r_extern
r_int
id|ppp_register_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
suffix:semicolon
r_extern
r_void
id|ppp_unregister_compressor
(paren
r_struct
id|compressor
op_star
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n; * the next two codes should not be changed lightly, as they must not&n; * lie within the contiguous general code space.&n; */
DECL|macro|CLEAR
mdefine_line|#define CLEAR&t;256&t;&t;&t;/* table clear output code */
DECL|macro|FIRST
mdefine_line|#define FIRST&t;257&t;&t;&t;/* first free entry */
DECL|macro|LAST
mdefine_line|#define LAST&t;255
DECL|macro|MAXCODE
mdefine_line|#define MAXCODE(b)&t;((1 &lt;&lt; (b)) - 1)
DECL|macro|BADCODEM1
mdefine_line|#define BADCODEM1&t;MAXCODE(MAX_BSD_BITS);
DECL|macro|BSD_HASH
mdefine_line|#define BSD_HASH(prefix,suffix,hshift) ((((unsigned long)(suffix))&lt;&lt;(hshift)) &bslash;&n;&t;&t;&t;&t;&t; ^ (unsigned long)(prefix))
DECL|macro|BSD_KEY
mdefine_line|#define BSD_KEY(prefix,suffix)&t;&t;((((unsigned long)(suffix)) &lt;&lt; 16) &bslash;&n;&t;&t;&t;&t;&t; + (unsigned long)(prefix))
DECL|macro|CHECK_GAP
mdefine_line|#define CHECK_GAP&t;10000&t;&t;/* Ratio check interval */
DECL|macro|RATIO_SCALE_LOG
mdefine_line|#define RATIO_SCALE_LOG&t;8
DECL|macro|RATIO_SCALE
mdefine_line|#define RATIO_SCALE&t;(1&lt;&lt;RATIO_SCALE_LOG)
DECL|macro|RATIO_MAX
mdefine_line|#define RATIO_MAX&t;(0x7fffffff&gt;&gt;RATIO_SCALE_LOG)
multiline_comment|/*&n; * clear the dictionary&n; */
r_static
r_void
DECL|function|bsd_clear
id|bsd_clear
c_func
(paren
r_struct
id|bsd_db
op_star
id|db
)paren
(brace
id|db-&gt;clear_count
op_increment
suffix:semicolon
id|db-&gt;max_ent
op_assign
id|FIRST
op_minus
l_int|1
suffix:semicolon
id|db-&gt;n_bits
op_assign
id|BSD_INIT_BITS
suffix:semicolon
id|db-&gt;bytes_out
op_assign
l_int|0
suffix:semicolon
id|db-&gt;in_count
op_assign
l_int|0
suffix:semicolon
id|db-&gt;ratio
op_assign
l_int|0
suffix:semicolon
id|db-&gt;checkpoint
op_assign
id|CHECK_GAP
suffix:semicolon
)brace
multiline_comment|/*&n; * If the dictionary is full, then see if it is time to reset it.&n; *&n; * Compute the compression ratio using fixed-point arithmetic&n; * with 8 fractional bits.&n; *&n; * Since we have an infinite stream instead of a single file,&n; * watch only the local compression ratio.&n; *&n; * Since both peers must reset the dictionary at the same time even in&n; * the absence of CLEAR codes (while packets are incompressible), they&n; * must compute the same ratio.&n; */
DECL|function|bsd_check
r_static
r_int
id|bsd_check
(paren
r_struct
id|bsd_db
op_star
id|db
)paren
multiline_comment|/* 1=output CLEAR */
(brace
r_int
r_int
id|new_ratio
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;in_count
op_ge
id|db-&gt;checkpoint
)paren
(brace
multiline_comment|/* age the ratio by limiting the size of the counts */
r_if
c_cond
(paren
id|db-&gt;in_count
op_ge
id|RATIO_MAX
op_logical_or
id|db-&gt;bytes_out
op_ge
id|RATIO_MAX
)paren
(brace
id|db-&gt;in_count
op_sub_assign
(paren
id|db-&gt;in_count
op_rshift
l_int|2
)paren
suffix:semicolon
id|db-&gt;bytes_out
op_sub_assign
(paren
id|db-&gt;bytes_out
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
id|db-&gt;checkpoint
op_assign
id|db-&gt;in_count
op_plus
id|CHECK_GAP
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;max_ent
op_ge
id|db-&gt;maxmaxcode
)paren
(brace
multiline_comment|/* Reset the dictionary only if the ratio is worse,&n;&t;     * or if it looks as if it has been poisoned&n;&t;     * by incompressible data.&n;&t;     *&n;&t;     * This does not overflow, because&n;&t;     *&t;db-&gt;in_count &lt;= RATIO_MAX.&n;&t;     */
id|new_ratio
op_assign
id|db-&gt;in_count
op_lshift
id|RATIO_SCALE_LOG
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;bytes_out
op_ne
l_int|0
)paren
(brace
id|new_ratio
op_div_assign
id|db-&gt;bytes_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_ratio
OL
id|db-&gt;ratio
op_logical_or
id|new_ratio
OL
l_int|1
op_star
id|RATIO_SCALE
)paren
(brace
id|bsd_clear
(paren
id|db
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|db-&gt;ratio
op_assign
id|new_ratio
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return statistics.&n; */
DECL|function|bsd_comp_stats
r_static
r_void
id|bsd_comp_stats
(paren
r_void
op_star
id|state
comma
r_struct
id|compstat
op_star
id|stats
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|stats-&gt;unc_bytes
op_assign
id|db-&gt;uncomp_bytes
suffix:semicolon
id|stats-&gt;unc_packets
op_assign
id|db-&gt;uncomp_count
suffix:semicolon
id|stats-&gt;comp_bytes
op_assign
id|db-&gt;comp_bytes
suffix:semicolon
id|stats-&gt;comp_packets
op_assign
id|db-&gt;comp_count
suffix:semicolon
id|stats-&gt;inc_bytes
op_assign
id|db-&gt;incomp_bytes
suffix:semicolon
id|stats-&gt;inc_packets
op_assign
id|db-&gt;incomp_count
suffix:semicolon
id|stats-&gt;in_count
op_assign
id|db-&gt;in_count
suffix:semicolon
id|stats-&gt;bytes_out
op_assign
id|db-&gt;bytes_out
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset state, as on a CCP ResetReq.&n; */
DECL|function|bsd_reset
r_static
r_void
id|bsd_reset
(paren
r_void
op_star
id|state
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|bsd_clear
c_func
(paren
id|db
)paren
suffix:semicolon
id|db-&gt;seqno
op_assign
l_int|0
suffix:semicolon
id|db-&gt;clear_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the compression structure&n; */
DECL|function|bsd_free
r_static
r_void
id|bsd_free
(paren
r_void
op_star
id|state
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
r_if
c_cond
(paren
id|db
)paren
(brace
multiline_comment|/*&n; * Release the dictionary&n; */
r_if
c_cond
(paren
id|db-&gt;dict
)paren
(brace
id|vfree
(paren
id|db-&gt;dict
)paren
suffix:semicolon
id|db-&gt;dict
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the string buffer&n; */
r_if
c_cond
(paren
id|db-&gt;lens
)paren
(brace
id|vfree
(paren
id|db-&gt;lens
)paren
suffix:semicolon
id|db-&gt;lens
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Finally release the structure itself.&n; */
id|kfree
(paren
id|db
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Allocate space for a (de) compressor.&n; */
DECL|function|bsd_alloc
r_static
r_void
op_star
id|bsd_alloc
(paren
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|decomp
)paren
(brace
r_int
id|bits
suffix:semicolon
r_int
r_int
id|hsize
comma
id|hshift
comma
id|maxmaxcode
suffix:semicolon
r_struct
id|bsd_db
op_star
id|db
suffix:semicolon
r_if
c_cond
(paren
id|opt_len
op_ne
l_int|3
op_logical_or
id|options
(braket
l_int|0
)braket
op_ne
id|CI_BSD_COMPRESS
op_logical_or
id|options
(braket
l_int|1
)braket
op_ne
l_int|3
op_logical_or
id|BSD_VERSION
c_func
(paren
id|options
(braket
l_int|2
)braket
)paren
op_ne
id|BSD_CURRENT_VERSION
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|bits
op_assign
id|BSD_NBITS
c_func
(paren
id|options
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bits
)paren
(brace
r_case
l_int|9
suffix:colon
multiline_comment|/* needs 82152 for both directions */
r_case
l_int|10
suffix:colon
multiline_comment|/* needs 84144 */
r_case
l_int|11
suffix:colon
multiline_comment|/* needs 88240 */
r_case
l_int|12
suffix:colon
multiline_comment|/* needs 96432 */
id|hsize
op_assign
l_int|5003
suffix:semicolon
id|hshift
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
multiline_comment|/* needs 176784 */
id|hsize
op_assign
l_int|9001
suffix:semicolon
id|hshift
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* needs 353744 */
id|hsize
op_assign
l_int|18013
suffix:semicolon
id|hshift
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
multiline_comment|/* needs 691440 */
id|hsize
op_assign
l_int|35023
suffix:semicolon
id|hshift
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
multiline_comment|/* needs 1366160--far too much, */
multiline_comment|/* hsize = 69001; */
multiline_comment|/* and 69001 is too big for cptr */
multiline_comment|/* hshift = 8; */
multiline_comment|/* in struct bsd_db */
multiline_comment|/* break; */
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate the main control structure for this instance.&n; */
id|maxmaxcode
op_assign
id|MAXCODE
c_func
(paren
id|bits
)paren
suffix:semicolon
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|bsd_db
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|db
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|bsd_db
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Allocate space for the dictionary. This may be more than one page in&n; * length.&n; */
id|db-&gt;dict
op_assign
(paren
r_struct
id|bsd_dict
op_star
)paren
id|vmalloc
(paren
id|hsize
op_star
r_sizeof
(paren
r_struct
id|bsd_dict
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db-&gt;dict
)paren
(brace
id|bsd_free
(paren
id|db
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n; * If this is the compression buffer then there is no length data.&n; */
r_if
c_cond
(paren
op_logical_neg
id|decomp
)paren
(brace
id|db-&gt;lens
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * For decompression, the length information is needed as well.&n; */
r_else
(brace
id|db-&gt;lens
op_assign
(paren
r_int
r_int
op_star
)paren
id|vmalloc
(paren
(paren
id|maxmaxcode
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|db-&gt;lens
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db-&gt;lens
)paren
(brace
id|bsd_free
(paren
id|db
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Initialize the data information for the compression code&n; */
id|db-&gt;totlen
op_assign
r_sizeof
(paren
r_struct
id|bsd_db
)paren
op_plus
(paren
r_sizeof
(paren
r_struct
id|bsd_dict
)paren
op_star
id|hsize
)paren
suffix:semicolon
id|db-&gt;hsize
op_assign
id|hsize
suffix:semicolon
id|db-&gt;hshift
op_assign
id|hshift
suffix:semicolon
id|db-&gt;maxmaxcode
op_assign
id|maxmaxcode
suffix:semicolon
id|db-&gt;maxbits
op_assign
id|bits
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|db
suffix:semicolon
)brace
DECL|function|bsd_comp_alloc
r_static
r_void
op_star
id|bsd_comp_alloc
(paren
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
)paren
(brace
r_return
id|bsd_alloc
(paren
id|options
comma
id|opt_len
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|bsd_decomp_alloc
r_static
r_void
op_star
id|bsd_decomp_alloc
(paren
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
)paren
(brace
r_return
id|bsd_alloc
(paren
id|options
comma
id|opt_len
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the database.&n; */
DECL|function|bsd_init
r_static
r_int
id|bsd_init
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|unit
comma
r_int
id|debug
comma
r_int
id|decomp
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
id|state
suffix:semicolon
r_int
id|indx
suffix:semicolon
r_if
c_cond
(paren
(paren
id|opt_len
op_ne
l_int|3
)paren
op_logical_or
(paren
id|options
(braket
l_int|0
)braket
op_ne
id|CI_BSD_COMPRESS
)paren
op_logical_or
(paren
id|options
(braket
l_int|1
)braket
op_ne
l_int|3
)paren
op_logical_or
(paren
id|BSD_VERSION
c_func
(paren
id|options
(braket
l_int|2
)braket
)paren
op_ne
id|BSD_CURRENT_VERSION
)paren
op_logical_or
(paren
id|BSD_NBITS
c_func
(paren
id|options
(braket
l_int|2
)braket
)paren
op_ne
id|db-&gt;maxbits
)paren
op_logical_or
(paren
id|decomp
op_logical_and
id|db-&gt;lens
op_eq
l_int|NULL
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|decomp
)paren
(brace
id|indx
op_assign
id|LAST
suffix:semicolon
r_do
(brace
id|db-&gt;lens
(braket
id|indx
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|indx
op_decrement
OG
l_int|0
)paren
suffix:semicolon
)brace
id|indx
op_assign
id|db-&gt;hsize
suffix:semicolon
r_while
c_loop
(paren
id|indx
op_decrement
op_ne
l_int|0
)paren
(brace
id|db-&gt;dict
(braket
id|indx
)braket
dot
id|codem1
op_assign
id|BADCODEM1
suffix:semicolon
id|db-&gt;dict
(braket
id|indx
)braket
dot
id|cptr
op_assign
l_int|0
suffix:semicolon
)brace
id|db-&gt;unit
op_assign
id|unit
suffix:semicolon
id|db-&gt;mru
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef DEBUG
r_if
c_cond
(paren
id|debug
)paren
macro_line|#endif
id|db-&gt;debug
op_assign
l_int|1
suffix:semicolon
id|bsd_reset
c_func
(paren
id|db
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|bsd_comp_init
r_static
r_int
id|bsd_comp_init
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|unit
comma
r_int
id|opthdr
comma
r_int
id|debug
)paren
(brace
r_return
id|bsd_init
(paren
id|state
comma
id|options
comma
id|opt_len
comma
id|unit
comma
id|debug
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|bsd_decomp_init
r_static
r_int
id|bsd_decomp_init
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|options
comma
r_int
id|opt_len
comma
r_int
id|unit
comma
r_int
id|opthdr
comma
r_int
id|mru
comma
r_int
id|debug
)paren
(brace
r_return
id|bsd_init
(paren
id|state
comma
id|options
comma
id|opt_len
comma
id|unit
comma
id|debug
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain pointers to the various structures in the compression tables&n; */
DECL|macro|dict_ptrx
mdefine_line|#define dict_ptrx(p,idx) &amp;(p-&gt;dict[idx])
DECL|macro|lens_ptrx
mdefine_line|#define lens_ptrx(p,idx) &amp;(p-&gt;lens[idx])
macro_line|#ifdef DEBUG
DECL|function|lens_ptr
r_static
r_int
r_int
op_star
id|lens_ptr
c_func
(paren
r_struct
id|bsd_db
op_star
id|db
comma
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
OG
(paren
r_int
r_int
)paren
id|db-&gt;maxmaxcode
)paren
(brace
id|printk
(paren
l_string|&quot;&lt;9&gt;ppp: lens_ptr(%d) &gt; max&bslash;n&quot;
comma
id|idx
)paren
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|lens_ptrx
(paren
id|db
comma
id|idx
)paren
suffix:semicolon
)brace
DECL|function|dict_ptr
r_static
r_struct
id|bsd_dict
op_star
id|dict_ptr
c_func
(paren
r_struct
id|bsd_db
op_star
id|db
comma
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
op_ge
(paren
r_int
r_int
)paren
id|db-&gt;hsize
)paren
(brace
id|printk
(paren
l_string|&quot;&lt;9&gt;ppp: dict_ptr(%d) &gt; max&bslash;n&quot;
comma
id|idx
)paren
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|dict_ptrx
(paren
id|db
comma
id|idx
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|lens_ptr
mdefine_line|#define lens_ptr(db,idx) lens_ptrx(db,idx)
DECL|macro|dict_ptr
mdefine_line|#define dict_ptr(db,idx) dict_ptrx(db,idx)
macro_line|#endif
multiline_comment|/*&n; * compress a packet&n; *&n; *&t;The result of this function is the size of the compressed&n; *&t;packet. A zero is returned if the packet was not compressed&n; *&t;for some reason, such as the size being larger than uncompressed.&n; *&n; *&t;One change from the BSD compress command is that when the&n; *&t;code size expands, we do not output a bunch of padding.&n; */
DECL|function|bsd_compress
r_static
r_int
id|bsd_compress
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|rptr
comma
r_int
r_char
op_star
id|obuf
comma
r_int
id|isize
comma
r_int
id|osize
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
suffix:semicolon
r_int
id|hshift
suffix:semicolon
r_int
r_int
id|max_ent
suffix:semicolon
r_int
r_int
id|n_bits
suffix:semicolon
r_int
r_int
id|bitno
suffix:semicolon
r_int
r_int
id|accm
suffix:semicolon
r_int
id|ent
suffix:semicolon
r_int
r_int
id|fcode
suffix:semicolon
r_struct
id|bsd_dict
op_star
id|dictp
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_int
id|hval
suffix:semicolon
r_int
id|disp
suffix:semicolon
r_int
id|ilen
suffix:semicolon
r_int
id|mxcode
suffix:semicolon
r_int
r_char
op_star
id|wptr
suffix:semicolon
r_int
id|olen
suffix:semicolon
DECL|macro|PUTBYTE
mdefine_line|#define PUTBYTE(v)&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&bslash;&n;    ++olen;&t;&t;&t;&t;&bslash;&n;    if (wptr)&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&bslash;&n;&t;*wptr++ = (unsigned char) (v);&t;&bslash;&n;&t;if (olen &gt;= osize)&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&bslash;&n;&t;    wptr = NULL;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&bslash;&n;  }
DECL|macro|OUTPUT
mdefine_line|#define OUTPUT(ent)&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&bslash;&n;    bitno -= n_bits;&t;&t;&t;&bslash;&n;    accm |= ((ent) &lt;&lt; bitno);&t;&t;&bslash;&n;    do&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&bslash;&n;&t;PUTBYTE(accm &gt;&gt; 24);&t;&t;&bslash;&n;&t;accm &lt;&lt;= 8;&t;&t;&t;&bslash;&n;&t;bitno += 8;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&bslash;&n;    while (bitno &lt;= 24);&t;&t;&bslash;&n;  }
multiline_comment|/*&n;   * If the protocol is not in the range we&squot;re interested in,&n;   * just return without compressing the packet.  If it is,&n;   * the protocol becomes the first byte to compress.&n;   */
id|ent
op_assign
id|PPP_PROTOCOL
c_func
(paren
id|rptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
template_param
l_int|0xf9
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|hshift
op_assign
id|db-&gt;hshift
suffix:semicolon
id|max_ent
op_assign
id|db-&gt;max_ent
suffix:semicolon
id|n_bits
op_assign
id|db-&gt;n_bits
suffix:semicolon
id|bitno
op_assign
l_int|32
suffix:semicolon
id|accm
op_assign
l_int|0
suffix:semicolon
id|mxcode
op_assign
id|MAXCODE
(paren
id|n_bits
)paren
suffix:semicolon
multiline_comment|/* Initialize the output pointers */
id|wptr
op_assign
id|obuf
suffix:semicolon
id|olen
op_assign
id|PPP_HDRLEN
op_plus
id|BSD_OVHD
suffix:semicolon
r_if
c_cond
(paren
id|osize
OG
id|isize
)paren
(brace
id|osize
op_assign
id|isize
suffix:semicolon
)brace
multiline_comment|/* This is the PPP header information */
r_if
c_cond
(paren
id|wptr
)paren
(brace
op_star
id|wptr
op_increment
op_assign
id|PPP_ADDRESS
c_func
(paren
id|rptr
)paren
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
id|PPP_CONTROL
c_func
(paren
id|rptr
)paren
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
id|PPP_COMP
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
id|db-&gt;seqno
op_rshift
l_int|8
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
id|db-&gt;seqno
suffix:semicolon
)brace
multiline_comment|/* Skip the input header */
id|rptr
op_add_assign
id|PPP_HDRLEN
suffix:semicolon
id|isize
op_sub_assign
id|PPP_HDRLEN
suffix:semicolon
id|ilen
op_assign
op_increment
id|isize
suffix:semicolon
multiline_comment|/* Low byte of protocol is counted as input */
r_while
c_loop
(paren
op_decrement
id|ilen
OG
l_int|0
)paren
(brace
id|c
op_assign
op_star
id|rptr
op_increment
suffix:semicolon
id|fcode
op_assign
id|BSD_KEY
(paren
id|ent
comma
id|c
)paren
suffix:semicolon
id|hval
op_assign
id|BSD_HASH
(paren
id|ent
comma
id|c
comma
id|hshift
)paren
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
multiline_comment|/* Validate and then check the entry. */
r_if
c_cond
(paren
id|dictp-&gt;codem1
op_ge
id|max_ent
)paren
(brace
r_goto
id|nomatch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dictp-&gt;f.fcode
op_eq
id|fcode
)paren
(brace
id|ent
op_assign
id|dictp-&gt;codem1
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* found (prefix,suffix) */
)brace
multiline_comment|/* continue probing until a match or invalid entry */
id|disp
op_assign
(paren
id|hval
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
id|hval
suffix:semicolon
r_do
(brace
id|hval
op_add_assign
id|disp
suffix:semicolon
r_if
c_cond
(paren
id|hval
op_ge
id|db-&gt;hsize
)paren
(brace
id|hval
op_sub_assign
id|db-&gt;hsize
suffix:semicolon
)brace
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dictp-&gt;codem1
op_ge
id|max_ent
)paren
(brace
r_goto
id|nomatch
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|dictp-&gt;f.fcode
op_ne
id|fcode
)paren
suffix:semicolon
id|ent
op_assign
id|dictp-&gt;codem1
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* finally found (prefix,suffix) */
r_continue
suffix:semicolon
id|nomatch
suffix:colon
id|OUTPUT
c_func
(paren
id|ent
)paren
suffix:semicolon
multiline_comment|/* output the prefix */
multiline_comment|/* code -&gt; hashtable */
r_if
c_cond
(paren
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
r_struct
id|bsd_dict
op_star
id|dictp2
suffix:semicolon
r_struct
id|bsd_dict
op_star
id|dictp3
suffix:semicolon
r_int
id|indx
suffix:semicolon
multiline_comment|/* expand code size if needed */
r_if
c_cond
(paren
id|max_ent
op_ge
id|mxcode
)paren
(brace
id|db-&gt;n_bits
op_assign
op_increment
id|n_bits
suffix:semicolon
id|mxcode
op_assign
id|MAXCODE
(paren
id|n_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Invalidate old hash table entry using&n;&t;     * this code, and then take it over.&n;&t;     */
id|dictp2
op_assign
id|dict_ptr
(paren
id|db
comma
id|max_ent
op_plus
l_int|1
)paren
suffix:semicolon
id|indx
op_assign
id|dictp2-&gt;cptr
suffix:semicolon
id|dictp3
op_assign
id|dict_ptr
(paren
id|db
comma
id|indx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dictp3-&gt;codem1
op_eq
id|max_ent
)paren
(brace
id|dictp3-&gt;codem1
op_assign
id|BADCODEM1
suffix:semicolon
)brace
id|dictp2-&gt;cptr
op_assign
id|hval
suffix:semicolon
id|dictp-&gt;codem1
op_assign
id|max_ent
suffix:semicolon
id|dictp-&gt;f.fcode
op_assign
id|fcode
suffix:semicolon
id|db-&gt;max_ent
op_assign
op_increment
id|max_ent
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;lens
)paren
(brace
r_int
r_int
op_star
id|len1
op_assign
id|lens_ptr
(paren
id|db
comma
id|max_ent
)paren
suffix:semicolon
r_int
r_int
op_star
id|len2
op_assign
id|lens_ptr
(paren
id|db
comma
id|ent
)paren
suffix:semicolon
op_star
id|len1
op_assign
op_star
id|len2
op_plus
l_int|1
suffix:semicolon
)brace
)brace
id|ent
op_assign
id|c
suffix:semicolon
)brace
id|OUTPUT
c_func
(paren
id|ent
)paren
suffix:semicolon
multiline_comment|/* output the last code */
id|db-&gt;bytes_out
op_add_assign
id|olen
op_minus
id|PPP_HDRLEN
op_minus
id|BSD_OVHD
suffix:semicolon
id|db-&gt;uncomp_bytes
op_add_assign
id|isize
suffix:semicolon
id|db-&gt;in_count
op_add_assign
id|isize
suffix:semicolon
op_increment
id|db-&gt;uncomp_count
suffix:semicolon
op_increment
id|db-&gt;seqno
suffix:semicolon
r_if
c_cond
(paren
id|bitno
OL
l_int|32
)paren
(brace
op_increment
id|db-&gt;bytes_out
suffix:semicolon
multiline_comment|/* must be set before calling bsd_check */
)brace
multiline_comment|/*&n;     * Generate the clear command if needed&n;     */
r_if
c_cond
(paren
id|bsd_check
c_func
(paren
id|db
)paren
)paren
(brace
id|OUTPUT
(paren
id|CLEAR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Pad dribble bits of last code with ones.&n;     * Do not emit a completely useless byte of ones.&n;     */
r_if
c_cond
(paren
id|bitno
op_ne
l_int|32
)paren
(brace
id|PUTBYTE
c_func
(paren
(paren
id|accm
op_or
(paren
l_int|0xff
op_lshift
(paren
id|bitno
op_minus
l_int|8
)paren
)paren
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Increase code size if we would have without the packet&n;     * boundary because the decompressor will do so.&n;     */
r_if
c_cond
(paren
id|max_ent
op_ge
id|mxcode
op_logical_and
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
id|db-&gt;n_bits
op_increment
suffix:semicolon
)brace
multiline_comment|/* If output length is too large then this is an incomplete frame. */
r_if
c_cond
(paren
id|wptr
op_eq
l_int|NULL
)paren
(brace
op_increment
id|db-&gt;incomp_count
suffix:semicolon
id|db-&gt;incomp_bytes
op_add_assign
id|isize
suffix:semicolon
id|olen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
multiline_comment|/* Count the number of compressed frames */
(brace
op_increment
id|db-&gt;comp_count
suffix:semicolon
id|db-&gt;comp_bytes
op_add_assign
id|olen
suffix:semicolon
)brace
multiline_comment|/* Return the resulting output length */
r_return
id|olen
suffix:semicolon
DECL|macro|OUTPUT
macro_line|#undef OUTPUT
DECL|macro|PUTBYTE
macro_line|#undef PUTBYTE
)brace
multiline_comment|/*&n; * Update the &quot;BSD Compress&quot; dictionary on the receiver for&n; * incompressible data by pretending to compress the incoming data.&n; */
DECL|function|bsd_incomp
r_static
r_void
id|bsd_incomp
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|ibuf
comma
r_int
id|icnt
)paren
(brace
(paren
r_void
)paren
id|bsd_compress
(paren
id|state
comma
id|ibuf
comma
(paren
r_char
op_star
)paren
l_int|0
comma
id|icnt
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decompress &quot;BSD Compress&quot;.&n; *&n; * Because of patent problems, we return DECOMP_ERROR for errors&n; * found by inspecting the input data and for system problems, but&n; * DECOMP_FATALERROR for any errors which could possibly be said to&n; * be being detected &quot;after&quot; decompression.  For DECOMP_ERROR,&n; * we can issue a CCP reset-request; for DECOMP_FATALERROR, we may be&n; * infringing a patent of Motorola&squot;s if we do, so we take CCP down&n; * instead.&n; *&n; * Given that the frame has the correct sequence number and a good FCS,&n; * errors such as invalid codes in the input most likely indicate a&n; * bug, so we return DECOMP_FATALERROR for them in order to turn off&n; * compression, even though they are detected by inspecting the input.&n; */
DECL|function|bsd_decompress
r_static
r_int
id|bsd_decompress
(paren
r_void
op_star
id|state
comma
r_int
r_char
op_star
id|ibuf
comma
r_int
id|isize
comma
r_int
r_char
op_star
id|obuf
comma
r_int
id|osize
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
suffix:semicolon
r_int
r_int
id|max_ent
suffix:semicolon
r_int
r_int
id|accm
suffix:semicolon
r_int
r_int
id|bitno
suffix:semicolon
multiline_comment|/* 1st valid bit in accm */
r_int
r_int
id|n_bits
suffix:semicolon
r_int
r_int
id|tgtbitno
suffix:semicolon
multiline_comment|/* bitno when we have a code */
r_struct
id|bsd_dict
op_star
id|dictp
suffix:semicolon
r_int
id|explen
suffix:semicolon
r_int
id|seq
suffix:semicolon
r_int
r_int
id|incode
suffix:semicolon
r_int
r_int
id|oldcode
suffix:semicolon
r_int
r_int
id|finchar
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_char
op_star
id|wptr
suffix:semicolon
r_int
id|adrs
suffix:semicolon
r_int
id|ctrl
suffix:semicolon
r_int
id|ilen
suffix:semicolon
r_int
id|codelen
suffix:semicolon
r_int
id|extra
suffix:semicolon
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|max_ent
op_assign
id|db-&gt;max_ent
suffix:semicolon
id|accm
op_assign
l_int|0
suffix:semicolon
id|bitno
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* 1st valid bit in accm */
id|n_bits
op_assign
id|db-&gt;n_bits
suffix:semicolon
id|tgtbitno
op_assign
l_int|32
op_minus
id|n_bits
suffix:semicolon
multiline_comment|/* bitno when we have a code */
multiline_comment|/*&n;     * Save the address/control from the PPP header&n;     * and then get the sequence number.&n;     */
id|adrs
op_assign
id|PPP_ADDRESS
(paren
id|ibuf
)paren
suffix:semicolon
id|ctrl
op_assign
id|PPP_CONTROL
(paren
id|ibuf
)paren
suffix:semicolon
id|seq
op_assign
(paren
id|ibuf
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
id|ibuf
(braket
l_int|5
)braket
suffix:semicolon
id|ibuf
op_add_assign
(paren
id|PPP_HDRLEN
op_plus
l_int|2
)paren
suffix:semicolon
id|ilen
op_assign
id|isize
op_minus
(paren
id|PPP_HDRLEN
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;     * Check the sequence number and give up if it differs from&n;     * the value we&squot;re expecting.&n;     */
r_if
c_cond
(paren
id|seq
op_ne
id|db-&gt;seqno
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: bad sequence # %d, expected %d&bslash;n&quot;
comma
id|db-&gt;unit
comma
id|seq
comma
id|db-&gt;seqno
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|DECOMP_ERROR
suffix:semicolon
)brace
op_increment
id|db-&gt;seqno
suffix:semicolon
id|db-&gt;bytes_out
op_add_assign
id|ilen
suffix:semicolon
multiline_comment|/*&n;     * Fill in the ppp header, but not the last byte of the protocol&n;     * (that comes from the decompressed data).&n;     */
id|wptr
op_assign
id|obuf
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
id|adrs
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
id|ctrl
suffix:semicolon
op_star
id|wptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|oldcode
op_assign
id|CLEAR
suffix:semicolon
id|explen
op_assign
l_int|3
suffix:semicolon
multiline_comment|/*&n;     * Keep the checkpoint correctly so that incompressible packets&n;     * clear the dictionary at the proper times.&n;     */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|ilen
op_decrement
op_le
l_int|0
)paren
(brace
id|db-&gt;in_count
op_add_assign
(paren
id|explen
op_minus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* don&squot;t count the header */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Accumulate bytes until we have a complete code.&n;&t; * Then get the next code, relying on the 32-bit,&n;&t; * unsigned accm to mask the result.&n;&t; */
id|bitno
op_sub_assign
l_int|8
suffix:semicolon
id|accm
op_or_assign
op_star
id|ibuf
op_increment
op_lshift
id|bitno
suffix:semicolon
r_if
c_cond
(paren
id|tgtbitno
OL
id|bitno
)paren
(brace
r_continue
suffix:semicolon
)brace
id|incode
op_assign
id|accm
op_rshift
id|tgtbitno
suffix:semicolon
id|accm
op_lshift_assign
id|n_bits
suffix:semicolon
id|bitno
op_add_assign
id|n_bits
suffix:semicolon
multiline_comment|/*&n;&t; * The dictionary must only be cleared at the end of a packet.&n;&t; */
r_if
c_cond
(paren
id|incode
op_eq
id|CLEAR
)paren
(brace
r_if
c_cond
(paren
id|ilen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: bad CLEAR&bslash;n&quot;
comma
id|db-&gt;unit
)paren
suffix:semicolon
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
multiline_comment|/* probably a bug */
)brace
id|bsd_clear
c_func
(paren
id|db
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|incode
OG
id|max_ent
op_plus
l_int|2
)paren
op_logical_or
(paren
id|incode
OG
id|db-&gt;maxmaxcode
)paren
op_logical_or
(paren
id|incode
OG
id|max_ent
op_logical_and
id|oldcode
op_eq
id|CLEAR
)paren
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: bad code 0x%x oldcode=0x%x &quot;
comma
id|db-&gt;unit
comma
id|incode
comma
id|oldcode
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;max_ent=0x%x explen=%d seqno=%d&bslash;n&quot;
comma
id|max_ent
comma
id|explen
comma
id|db-&gt;seqno
)paren
suffix:semicolon
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
multiline_comment|/* probably a bug */
)brace
multiline_comment|/* Special case for KwKwK string. */
r_if
c_cond
(paren
id|incode
OG
id|max_ent
)paren
(brace
id|finchar
op_assign
id|oldcode
suffix:semicolon
id|extra
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|finchar
op_assign
id|incode
suffix:semicolon
id|extra
op_assign
l_int|0
suffix:semicolon
)brace
id|codelen
op_assign
op_star
(paren
id|lens_ptr
(paren
id|db
comma
id|finchar
)paren
)paren
suffix:semicolon
id|explen
op_add_assign
id|codelen
op_plus
id|extra
suffix:semicolon
r_if
c_cond
(paren
id|explen
OG
id|osize
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: ran out of mru&bslash;n&quot;
comma
id|db-&gt;unit
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;  len=%d, finchar=0x%x, codelen=%d, explen=%d&bslash;n&quot;
comma
id|ilen
comma
id|finchar
comma
id|codelen
comma
id|explen
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decode this code and install it in the decompressed buffer.&n;&t; */
id|wptr
op_add_assign
id|codelen
suffix:semicolon
id|p
op_assign
id|wptr
suffix:semicolon
r_while
c_loop
(paren
id|finchar
OG
id|LAST
)paren
(brace
r_struct
id|bsd_dict
op_star
id|dictp2
op_assign
id|dict_ptr
(paren
id|db
comma
id|finchar
)paren
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|dictp2-&gt;cptr
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_decrement
id|codelen
op_le
l_int|0
op_logical_or
id|dictp-&gt;codem1
op_ne
id|finchar
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|codelen
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: fell off end of chain &quot;
comma
id|db-&gt;unit
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;0x%x at 0x%x by 0x%x, max_ent=0x%x&bslash;n&quot;
comma
id|incode
comma
id|finchar
comma
id|dictp2-&gt;cptr
comma
id|max_ent
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dictp-&gt;codem1
op_ne
id|finchar
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: bad code chain 0x%x &quot;
l_string|&quot;finchar=0x%x &quot;
comma
id|db-&gt;unit
comma
id|incode
comma
id|finchar
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;oldcode=0x%x cptr=0x%x codem1=0x%x&bslash;n&quot;
comma
id|oldcode
comma
id|dictp2-&gt;cptr
comma
id|dictp-&gt;codem1
)paren
suffix:semicolon
)brace
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
)brace
macro_line|#endif
op_star
op_decrement
id|p
op_assign
id|dictp-&gt;f.hs.suffix
suffix:semicolon
id|finchar
op_assign
id|dictp-&gt;f.hs.prefix
suffix:semicolon
)brace
op_star
op_decrement
id|p
op_assign
id|finchar
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_decrement
id|codelen
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x&bslash;n&quot;
comma
id|db-&gt;unit
comma
id|codelen
comma
id|incode
comma
id|max_ent
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|extra
)paren
multiline_comment|/* the KwKwK case again */
(brace
op_star
id|wptr
op_increment
op_assign
id|finchar
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If not first code in a packet, and&n;&t; * if not out of code space, then allocate a new code.&n;&t; *&n;&t; * Keep the hash table correct so it can be used&n;&t; * with uncompressed packets.&n;&t; */
r_if
c_cond
(paren
id|oldcode
op_ne
id|CLEAR
op_logical_and
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
r_struct
id|bsd_dict
op_star
id|dictp2
comma
op_star
id|dictp3
suffix:semicolon
r_int
r_int
op_star
id|lens1
comma
op_star
id|lens2
suffix:semicolon
r_int
r_int
id|fcode
suffix:semicolon
r_int
id|hval
comma
id|disp
comma
id|indx
suffix:semicolon
id|fcode
op_assign
id|BSD_KEY
c_func
(paren
id|oldcode
comma
id|finchar
)paren
suffix:semicolon
id|hval
op_assign
id|BSD_HASH
c_func
(paren
id|oldcode
comma
id|finchar
comma
id|db-&gt;hshift
)paren
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
multiline_comment|/* look for a free hash table entry */
r_if
c_cond
(paren
id|dictp-&gt;codem1
OL
id|max_ent
)paren
(brace
id|disp
op_assign
(paren
id|hval
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
id|hval
suffix:semicolon
r_do
(brace
id|hval
op_add_assign
id|disp
suffix:semicolon
r_if
c_cond
(paren
id|hval
op_ge
id|db-&gt;hsize
)paren
(brace
id|hval
op_sub_assign
id|db-&gt;hsize
suffix:semicolon
)brace
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dictp-&gt;codem1
OL
id|max_ent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;     * Invalidate previous hash table entry&n;&t;     * assigned this code, and then take it over&n;&t;     */
id|dictp2
op_assign
id|dict_ptr
(paren
id|db
comma
id|max_ent
op_plus
l_int|1
)paren
suffix:semicolon
id|indx
op_assign
id|dictp2-&gt;cptr
suffix:semicolon
id|dictp3
op_assign
id|dict_ptr
(paren
id|db
comma
id|indx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dictp3-&gt;codem1
op_eq
id|max_ent
)paren
(brace
id|dictp3-&gt;codem1
op_assign
id|BADCODEM1
suffix:semicolon
)brace
id|dictp2-&gt;cptr
op_assign
id|hval
suffix:semicolon
id|dictp-&gt;codem1
op_assign
id|max_ent
suffix:semicolon
id|dictp-&gt;f.fcode
op_assign
id|fcode
suffix:semicolon
id|db-&gt;max_ent
op_assign
op_increment
id|max_ent
suffix:semicolon
multiline_comment|/* Update the length of this string. */
id|lens1
op_assign
id|lens_ptr
(paren
id|db
comma
id|max_ent
)paren
suffix:semicolon
id|lens2
op_assign
id|lens_ptr
(paren
id|db
comma
id|oldcode
)paren
suffix:semicolon
op_star
id|lens1
op_assign
op_star
id|lens2
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Expand code size if needed. */
r_if
c_cond
(paren
id|max_ent
op_ge
id|MAXCODE
c_func
(paren
id|n_bits
)paren
op_logical_and
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
id|db-&gt;n_bits
op_assign
op_increment
id|n_bits
suffix:semicolon
id|tgtbitno
op_assign
l_int|32
op_minus
id|n_bits
suffix:semicolon
)brace
)brace
id|oldcode
op_assign
id|incode
suffix:semicolon
)brace
op_increment
id|db-&gt;comp_count
suffix:semicolon
op_increment
id|db-&gt;uncomp_count
suffix:semicolon
id|db-&gt;comp_bytes
op_add_assign
id|isize
op_minus
id|BSD_OVHD
op_minus
id|PPP_HDRLEN
suffix:semicolon
id|db-&gt;uncomp_bytes
op_add_assign
id|explen
suffix:semicolon
r_if
c_cond
(paren
id|bsd_check
c_func
(paren
id|db
)paren
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bsd_decomp%d: peer should have cleared dictionary on %d&bslash;n&quot;
comma
id|db-&gt;unit
comma
id|db-&gt;seqno
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|explen
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * Table of addresses for the BSD compression module&n; *************************************************************/
DECL|variable|ppp_bsd_compress
r_static
r_struct
id|compressor
id|ppp_bsd_compress
op_assign
(brace
id|CI_BSD_COMPRESS
comma
multiline_comment|/* compress_proto */
id|bsd_comp_alloc
comma
multiline_comment|/* comp_alloc */
id|bsd_free
comma
multiline_comment|/* comp_free */
id|bsd_comp_init
comma
multiline_comment|/* comp_init */
id|bsd_reset
comma
multiline_comment|/* comp_reset */
id|bsd_compress
comma
multiline_comment|/* compress */
id|bsd_comp_stats
comma
multiline_comment|/* comp_stat */
id|bsd_decomp_alloc
comma
multiline_comment|/* decomp_alloc */
id|bsd_free
comma
multiline_comment|/* decomp_free */
id|bsd_decomp_init
comma
multiline_comment|/* decomp_init */
id|bsd_reset
comma
multiline_comment|/* decomp_reset */
id|bsd_decompress
comma
multiline_comment|/* decompress */
id|bsd_incomp
comma
multiline_comment|/* incomp */
id|bsd_comp_stats
multiline_comment|/* decomp_stat */
)brace
suffix:semicolon
multiline_comment|/*************************************************************&n; * Module support routines&n; *************************************************************/
DECL|function|bsdcomp_init
r_int
id|bsdcomp_init
c_func
(paren
r_void
)paren
(brace
r_int
id|answer
op_assign
id|ppp_register_compressor
c_func
(paren
op_amp
id|ppp_bsd_compress
)paren
suffix:semicolon
r_if
c_cond
(paren
id|answer
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PPP BSD Compression module registered&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|answer
suffix:semicolon
)brace
DECL|function|bsdcomp_cleanup
r_void
id|bsdcomp_cleanup
c_func
(paren
r_void
)paren
(brace
id|ppp_unregister_compressor
c_func
(paren
op_amp
id|ppp_bsd_compress
)paren
suffix:semicolon
)brace
DECL|variable|bsdcomp_init
id|module_init
c_func
(paren
id|bsdcomp_init
)paren
suffix:semicolon
DECL|variable|bsdcomp_cleanup
id|module_exit
c_func
(paren
id|bsdcomp_cleanup
)paren
suffix:semicolon
eof
