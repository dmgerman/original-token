multiline_comment|/* seeq8005.c: A network driver for linux. */
multiline_comment|/*&n;&t;Based on skeleton.c,&n;&t;Written 1993-94 by Donald Becker.&n;&t;See the skeleton.c file for further copyright information.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;&t;The author may be reached as hamish@zot.apana.org.au&n;&n;&t;This file is a network device driver for the SEEQ 8005 chipset and&n;&t;the Linux operating system.&n;&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;seeq8005.c:v1.00 8/07/95 Hamish Coleman (hamish@zot.apana.org.au)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n;  Sources:&n;  &t;SEEQ 8005 databook&n;  &t;&n;  Version history:&n;  &t;1.00&t;Public release. cosmetic changes (no warnings now)&n;  &t;0.68&t;Turning per- packet,interrupt debug messages off - testing for release.&n;  &t;0.67&t;timing problems/bad buffer reads seem to be fixed now&n;  &t;0.63&t;*!@$ protocol=eth_type_trans -- now packets flow&n;  &t;0.56&t;Send working&n;  &t;0.48&t;Receive working&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;seeq8005.h&quot;
multiline_comment|/* First, a few definitions that the brave might change. */
multiline_comment|/* A zero-terminated list of I/O addresses to be probed. */
DECL|variable|__initdata
r_static
r_int
r_int
id|seeq8005_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 1
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|receive_ptr
r_int
r_int
id|receive_ptr
suffix:semicolon
multiline_comment|/* What address in packet memory do we expect a recv_pkt_header? */
DECL|member|open_time
r_int
id|open_time
suffix:semicolon
multiline_comment|/* Useless example local info. */
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for IDing the board. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x00
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0x80
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0x4b
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|seeq8005_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|seeq8005_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|seeq8005_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|seeq8005_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|seeq8005_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|seeq8005_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|seeq8005_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|seeq8005_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|seeq8005_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Example routines you must write ;-&gt;. */
DECL|macro|tx_done
mdefine_line|#define tx_done(dev)&t;(inw(SEEQ_STATUS) &amp; SEEQSTAT_TX_ON)
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_extern
r_void
id|seeq8005_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|startp
)paren
suffix:semicolon
r_static
r_inline
r_void
id|wait_for_buffer
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, allocate space for the device and return success&n;   (detachable devices only).&n;   */
r_int
id|__init
DECL|function|seeq8005_probe
id|seeq8005_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev
ques
c_cond
id|dev-&gt;base_addr
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|seeq8005_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|seeq8005_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|seeq8005_probe1
c_func
(paren
id|dev
comma
id|seeq8005_portlist
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* This is the real probe routine.  Linux has a history of friendly device&n;   probes on the ISA bus.  A good device probes avoids doing writes, and&n;   verifies that the correct device exists and functions.  */
DECL|function|seeq8005_probe1
r_static
r_int
id|__init
id|seeq8005_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_static
r_int
id|version_printed
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_char
id|SA_prom
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|old_cfg1
suffix:semicolon
r_int
id|old_cfg2
suffix:semicolon
r_int
id|old_stat
suffix:semicolon
r_int
id|old_dmaar
suffix:semicolon
r_int
id|old_rear
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|SEEQ8005_IO_EXTENT
comma
l_string|&quot;seeq8005&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;seeq8005: probing at 0x%x&bslash;n&quot;
comma
id|ioaddr
)paren
suffix:semicolon
id|old_stat
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
suffix:semicolon
multiline_comment|/* read status register */
r_if
c_cond
(paren
id|old_stat
op_eq
l_int|0xffff
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/* assume that 0xffff == no device */
)brace
r_if
c_cond
(paren
(paren
id|old_stat
op_amp
l_int|0x1800
)paren
op_ne
l_int|0x1800
)paren
(brace
multiline_comment|/* assume that unused bits are 1, as my manual says */
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;seeq8005: reserved stat bits != 0x1800&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;          == 0x%04x&bslash;n&quot;
comma
id|old_stat
)paren
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|old_rear
op_assign
id|inw
c_func
(paren
id|SEEQ_REA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_rear
op_eq
l_int|0xffff
)paren
(brace
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_REA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
c_func
(paren
id|SEEQ_REA
)paren
op_eq
l_int|0xffff
)paren
(brace
multiline_comment|/* assume that 0xffff == no device */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|old_rear
op_amp
l_int|0xff00
)paren
op_ne
l_int|0xff00
)paren
(brace
multiline_comment|/* assume that unused bits are 1 */
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;seeq8005: unused rear bits != 0xff00&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;          == 0x%04x&bslash;n&quot;
comma
id|old_rear
)paren
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|old_cfg2
op_assign
id|inw
c_func
(paren
id|SEEQ_CFG2
)paren
suffix:semicolon
multiline_comment|/* read CFG2 register */
id|old_cfg1
op_assign
id|inw
c_func
(paren
id|SEEQ_CFG1
)paren
suffix:semicolon
id|old_dmaar
op_assign
id|inw
c_func
(paren
id|SEEQ_DMAAR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;seeq8005: stat = 0x%04x&bslash;n&quot;
comma
id|old_stat
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;seeq8005: cfg1 = 0x%04x&bslash;n&quot;
comma
id|old_cfg1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;seeq8005: cfg2 = 0x%04x&bslash;n&quot;
comma
id|old_cfg2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;seeq8005: raer = 0x%04x&bslash;n&quot;
comma
id|old_rear
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;seeq8005: dmaar= 0x%04x&bslash;n&quot;
comma
id|old_dmaar
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|SEEQCMD_FIFO_WRITE
op_or
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
multiline_comment|/* setup for reading PROM */
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
multiline_comment|/* set starting PROM address */
id|outw
c_func
(paren
id|SEEQCFG1_BUFFER_PROM
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
multiline_comment|/* set buffer to look at PROM */
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_add_assign
id|SA_prom
(braket
id|i
)braket
op_assign
id|inw
c_func
(paren
id|SEEQ_BUFFER
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* untested because I only have the one card */
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|0xff
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* checksum appears to be 8bit = 0 */
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
(brace
multiline_comment|/* check this before deciding that we have a card */
id|printk
c_func
(paren
l_string|&quot;seeq8005: prom sum error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|old_stat
comma
id|SEEQ_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_dmaar
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_cfg1
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
id|outw
c_func
(paren
id|SEEQCFG2_RESET
comma
id|SEEQ_CFG2
)paren
suffix:semicolon
multiline_comment|/* reset the card */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;seeq8005: prom sum = 0x%08x&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_add_assign
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;seeq8005: prom %02x: &quot;
comma
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|SA_prom
(braket
id|j
op_or
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|SA_prom
(braket
id|j
op_or
id|i
)braket
OG
l_int|31
)paren
op_logical_and
(paren
id|SA_prom
(braket
id|j
op_or
id|i
)braket
OL
l_int|127
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|SA_prom
(braket
id|j
op_or
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0&t;
multiline_comment|/* &n;&t; * testing the packet buffer memory doesn&squot;t work yet&n;&t; * but all other buffer accesses do &n;&t; *&t;&t;&t;- fixing is not a priority&n;&t; */
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
(brace
multiline_comment|/* test packet buffer memory */
id|printk
c_func
(paren
l_string|&quot;seeq8005: testing packet buffer ... &quot;
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCFG1_BUFFER_BUFFER
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_FIFO_WRITE
op_or
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32768
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outw
c_func
(paren
l_int|0x5a5a
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
)brace
id|j
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
op_amp
id|SEEQSTAT_FIFO_EMPTY
)paren
op_ne
id|SEEQSTAT_FIFO_EMPTY
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|j
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
op_amp
id|SEEQSTAT_WINDOW_INT
)paren
op_ne
id|SEEQSTAT_WINDOW_INT
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|j
op_plus
id|HZ
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
op_amp
id|SEEQSTAT_WINDOW_INT
)paren
op_eq
id|SEEQSTAT_WINDOW_INT
)paren
id|outw
c_func
(paren
id|SEEQCMD_WINDOW_INT_ACK
op_or
(paren
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_FIFO_READ
op_or
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32768
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inw
c_func
(paren
id|SEEQ_BUFFER
)paren
op_ne
l_int|0x5a5a
)paren
id|j
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%i&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ok.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|net_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s found at %#3x, &quot;
comma
id|dev-&gt;name
comma
l_string|&quot;seeq8005&quot;
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* Retrieve and print the ethernet address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|SA_prom
(braket
id|i
op_plus
l_int|6
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Do nothing: a user-level program will set it. */
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
multiline_comment|/* &quot;Auto-IRQ&quot; */
r_int
r_int
id|cookie
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_RX_INT_EN
op_or
id|SEEQCMD_SET_RX_ON
op_or
id|SEEQCMD_SET_RX_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|probe_irq_off
c_func
(paren
id|cookie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
op_ge
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot; autoirq is %d&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
multiline_comment|/* Fixup for users that don&squot;t know that IRQ 2 is really IRQ 9,&n;&t;   * or don&squot;t know which one to set. &n;&t;   */
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
macro_line|#if 0
(brace
r_int
id|irqval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|seeq8005_interrupt
comma
l_int|0
comma
l_string|&quot;seeq8005&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqval
)paren
(brace
id|printk
(paren
l_string|&quot;%s: unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|irqval
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|seeq8005_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|seeq8005_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|seeq8005_send_packet
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|seeq8005_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
op_div
l_int|20
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|seeq8005_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_MULTICAST
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|release_region
c_func
(paren
id|ioaddr
comma
id|SEEQ8005_IO_EXTENT
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;ifconfig&squot; program is run.&n;&n;   This routine should set everything up anew at each open, even&n;   registers that &quot;should&quot; only need to be set once at boot, so that&n;   there is non-reboot way to recover if something goes wrong.&n;   */
DECL|function|seeq8005_open
r_static
r_int
id|seeq8005_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
(brace
r_int
id|irqval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|seeq8005_interrupt
comma
l_int|0
comma
l_string|&quot;seeq8005&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqval
)paren
(brace
id|printk
(paren
l_string|&quot;%s: unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
comma
id|irqval
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset the hardware here.  Don&squot;t forget to set the station address. */
id|seeq8005_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|lp-&gt;open_time
op_assign
id|jiffies
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|seeq8005_timeout
r_static
r_void
id|seeq8005_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_done
c_func
(paren
id|dev
)paren
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|seeq8005_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|seeq8005_send_packet
r_static
r_int
id|seeq8005_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Block a timer-based transmit from overlapping */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|hardware_send_packet
c_func
(paren
id|dev
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|length
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* You might need to clean up and record Tx statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* The typical workload of the driver:&n;   Handle the network interface interrupts. */
DECL|function|seeq8005_interrupt
r_static
r_void
id|seeq8005_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: int, status=0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|SEEQSTAT_WINDOW_INT
)paren
(brace
id|outw
c_func
(paren
id|SEEQCMD_WINDOW_INT_ACK
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: window int!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
op_amp
id|SEEQSTAT_TX_INT
)paren
(brace
id|outw
c_func
(paren
id|SEEQCMD_TX_INT_ACK
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
r_if
c_cond
(paren
id|status
op_amp
id|SEEQSTAT_RX_INT
)paren
(brace
multiline_comment|/* Got a packet(s). */
id|seeq8005_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|status
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_increment
id|boguscount
OL
l_int|10
)paren
op_logical_and
(paren
id|status
op_amp
id|SEEQSTAT_ANY_INT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: eoi&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We have a good packet(s), get it/them out of the buffers. */
DECL|function|seeq8005_rx
r_static
r_void
id|seeq8005_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|10
suffix:semicolon
r_int
id|pkt_hdr
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_do
(brace
r_int
id|next_packet
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;receive_ptr
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_FIFO_READ
op_or
id|SEEQCMD_RX_INT_ACK
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|wait_for_buffer
c_func
(paren
id|dev
)paren
suffix:semicolon
id|next_packet
op_assign
id|ntohs
c_func
(paren
id|inw
c_func
(paren
id|SEEQ_BUFFER
)paren
)paren
suffix:semicolon
id|pkt_hdr
op_assign
id|inw
c_func
(paren
id|SEEQ_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: 0x%04x recv next=0x%04x, hdr=0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;receive_ptr
comma
id|next_packet
comma
id|pkt_hdr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|next_packet
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|pkt_hdr
op_amp
id|SEEQPKTH_CHAIN
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Read all the frames? */
r_return
suffix:semicolon
multiline_comment|/* Done for now */
)brace
r_if
c_cond
(paren
(paren
id|pkt_hdr
op_amp
id|SEEQPKTS_DONE
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|next_packet
OL
id|lp-&gt;receive_ptr
)paren
(brace
id|pkt_len
op_assign
(paren
id|next_packet
op_plus
l_int|0x10000
op_minus
(paren
(paren
id|DEFAULT_TEA
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
)paren
op_minus
id|lp-&gt;receive_ptr
op_minus
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|pkt_len
op_assign
id|next_packet
op_minus
id|lp-&gt;receive_ptr
op_minus
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next_packet
OL
(paren
(paren
id|DEFAULT_TEA
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
)paren
(brace
multiline_comment|/* is the next_packet address sane? */
id|printk
c_func
(paren
l_string|&quot;%s: recv packet ring corrupt, resetting board&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|seeq8005_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lp-&gt;receive_ptr
op_assign
id|next_packet
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: recv len=0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_hdr
op_amp
id|SEEQPKTS_ANY_ERROR
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_hdr
op_amp
id|SEEQPKTS_SHORT
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_hdr
op_amp
id|SEEQPKTS_DRIB
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_hdr
op_amp
id|SEEQPKTS_OVERSIZE
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pkt_hdr
op_amp
id|SEEQPKTS_CRC_ERR
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
multiline_comment|/* skip over this packet */
id|outw
c_func
(paren
id|SEEQCMD_FIFO_WRITE
op_or
id|SEEQCMD_DMA_INT_ACK
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|lp-&gt;receive_ptr
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
comma
id|SEEQ_REA
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* align data on 16 byte */
id|buf
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
id|insw
c_func
(paren
id|SEEQ_BUFFER
comma
id|buf
comma
(paren
id|pkt_len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|2
)paren
(brace
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: recv &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
op_star
(paren
id|p
op_increment
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
op_decrement
id|boguscount
)paren
op_logical_and
(paren
id|pkt_hdr
op_amp
id|SEEQPKTH_CHAIN
)paren
)paren
suffix:semicolon
multiline_comment|/* If any worth-while packets have been received, netif_rx()&n;&t;   has done a mark_bh(NET_BH) for us and will work on them&n;&t;   when we get to the bottom-half routine. */
r_return
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to net_open(). */
DECL|function|seeq8005_close
r_static
r_int
id|seeq8005_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;open_time
op_assign
l_int|0
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx here. */
id|outw
c_func
(paren
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
DECL|function|seeq8005_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|seeq8005_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n;   num_addrs == -1&t;Promiscuous mode, receive all packets&n;   num_addrs == 0&t;Normal mode, clear multicast list&n;   num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;&t;&t;&t;best-effort filtering.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/*&n; * I _could_ do up to 6 addresses here, but won&squot;t (yet?)&n; */
macro_line|#if 0
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/*&n; * hmm, not even sure if my matching works _anyway_ - seem to be receiving&n; * _everything_ . . .&n; */
r_if
c_cond
(paren
id|num_addrs
)paren
(brace
multiline_comment|/* Enable promiscuous mode */
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|SEEQ_CFG1
)paren
op_amp
op_complement
id|SEEQCFG1_MATCH_MASK
)paren
op_or
id|SEEQCFG1_MATCH_ALL
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable promiscuous mode, use normal mode */
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|SEEQ_CFG1
)paren
op_amp
op_complement
id|SEEQCFG1_MATCH_MASK
)paren
op_or
id|SEEQCFG1_MATCH_BROAD
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|seeq8005_init
r_void
id|seeq8005_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|startp
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCFG2_RESET
comma
id|SEEQ_CFG2
)paren
suffix:semicolon
multiline_comment|/* reset device */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_FIFO_WRITE
op_or
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
multiline_comment|/* load start address into both low and high byte */
multiline_comment|/*&t;wait_for_buffer(dev); */
multiline_comment|/* I think that you only need a wait for memory buffer */
id|outw
c_func
(paren
id|SEEQCFG1_BUFFER_MAC0
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* set Station address */
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|SEEQCFG1_BUFFER_TEA
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
multiline_comment|/* set xmit end area pointer to 16K */
id|outb
c_func
(paren
id|DEFAULT_TEA
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
multiline_comment|/* this gives us 16K of send buffer and 48K of recv buffer */
id|lp-&gt;receive_ptr
op_assign
(paren
id|DEFAULT_TEA
op_plus
l_int|1
)paren
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* so we can find our packet_header */
id|outw
c_func
(paren
id|lp-&gt;receive_ptr
comma
id|SEEQ_RPR
)paren
suffix:semicolon
multiline_comment|/* Receive Pointer Register is set to recv buffer memory */
id|outw
c_func
(paren
l_int|0x00ff
comma
id|SEEQ_REA
)paren
suffix:semicolon
multiline_comment|/* Receive Area End */
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: SA0 = &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_FIFO_READ
op_or
id|SEEQCMD_SET_ALL_OFF
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCFG1_BUFFER_MAC0
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|inb
c_func
(paren
id|SEEQ_BUFFER
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|SEEQCFG1_MAC0_EN
op_or
id|SEEQCFG1_MATCH_BROAD
op_or
id|SEEQCFG1_BUFFER_BUFFER
comma
id|SEEQ_CFG1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCFG2_AUTO_REA
op_or
id|SEEQCFG2_CTRLO
comma
id|SEEQ_CFG2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQCMD_SET_RX_ON
op_or
id|SEEQCMD_TX_INT_EN
op_or
id|SEEQCMD_RX_INT_EN
comma
id|SEEQ_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
r_int
id|old_cfg1
suffix:semicolon
id|old_cfg1
op_assign
id|inw
c_func
(paren
id|SEEQ_CFG1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: stat = 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: cfg1 = 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|old_cfg1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: cfg2 = 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|SEEQ_CFG2
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: raer = 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|SEEQ_REA
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: dmaar= 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|SEEQ_DMAAR
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|hardware_send_packet
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
suffix:semicolon
r_int
id|transmit_ptr
op_assign
l_int|0
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: send 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/* Set FIFO to writemode and set packet-buffer address */
id|outw
c_func
(paren
id|SEEQCMD_FIFO_WRITE
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
id|transmit_ptr
comma
id|SEEQ_DMAAR
)paren
suffix:semicolon
multiline_comment|/* output SEEQ Packet header barfage */
id|outw
c_func
(paren
id|htons
c_func
(paren
id|length
op_plus
l_int|4
)paren
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SEEQPKTH_XMIT
op_or
id|SEEQPKTH_DATA_FOLLOWS
op_or
id|SEEQPKTH_XMIT_INT_EN
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
multiline_comment|/* blat the buffer */
id|outsw
c_func
(paren
id|SEEQ_BUFFER
comma
id|buf
comma
(paren
id|length
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* paranoia !! */
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|SEEQ_BUFFER
)paren
suffix:semicolon
multiline_comment|/* set address of start of transmit chain */
id|outw
c_func
(paren
id|transmit_ptr
comma
id|SEEQ_TPR
)paren
suffix:semicolon
multiline_comment|/* drain FIFO */
id|tmp
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
id|status
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
)paren
op_amp
id|SEEQSTAT_FIFO_EMPTY
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|jiffies
op_minus
id|tmp
OL
id|HZ
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* doit ! */
id|outw
c_func
(paren
id|SEEQCMD_WINDOW_INT_ACK
op_or
id|SEEQCMD_SET_TX_ON
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * wait_for_buffer&n; *&n; * This routine waits for the SEEQ chip to assert that the FIFO is ready&n; * by checking for a window interrupt, and then clearing it&n; */
DECL|function|wait_for_buffer
r_inline
r_void
id|wait_for_buffer
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_int
id|status
suffix:semicolon
id|tmp
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
id|status
op_assign
id|inw
c_func
(paren
id|SEEQ_STATUS
)paren
)paren
op_amp
id|SEEQSTAT_WINDOW_INT
)paren
op_ne
id|SEEQSTAT_WINDOW_INT
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|tmp
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SEEQSTAT_WINDOW_INT
)paren
op_eq
id|SEEQSTAT_WINDOW_INT
)paren
id|outw
c_func
(paren
id|SEEQCMD_WINDOW_INT_ACK
op_or
(paren
id|status
op_amp
id|SEEQCMD_INT_MASK
)paren
comma
id|SEEQ_CMD
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|dev_seeq
r_static
r_struct
id|net_device
id|dev_seeq
op_assign
(brace
id|init
suffix:colon
id|seeq8005_probe
)brace
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x320
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|10
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|dev_seeq.irq
op_assign
id|irq
suffix:semicolon
id|dev_seeq.base_addr
op_assign
id|io
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_seeq
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; *&t;No need to check MOD_IN_USE, as sys_delete_module() checks.&n;&t; */
id|unregister_netdev
c_func
(paren
op_amp
id|dev_seeq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free up the private structure, or leak memory :-)&n;&t; */
id|kfree
c_func
(paren
id|dev_seeq.priv
)paren
suffix:semicolon
id|dev_seeq.priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* gets re-allocated by el1_probe1 */
multiline_comment|/*&n;&t; *&t;If we don&squot;t do this, we can&squot;t re-insmod it later.&n;&t; */
id|release_region
c_func
(paren
id|dev_seeq.base_addr
comma
id|SEEQ8005_IO_EXTENT
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c skeleton.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 4&n; * End:&n; */
eof
