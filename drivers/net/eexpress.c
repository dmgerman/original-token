multiline_comment|/* eexpress.c: Intel EtherExpress device driver for Linux. */
multiline_comment|/*&n;&t;Written 1993 by Donald Becker.&n;&t;Copyright 1993 United States Government as represented by the Director,&n;&t;National Security Agency.  This software may only be used and distributed&n;&t;according to the terms of the GNU Public License as modified by SRC,&n;&t;incorported herein by reference.&n;&n;&t;The author may be reached as becker@super.org or&n;&t;C/O Supercomputing Research Ctr., 17100 Science Dr., Bowie MD 20715&n;&n;&t;Things remaining to do:&n;&t;Check that the 586 and ASIC are reset/unreset at the right times.&n;&t;Check tx and rx buffer setup.&n;&t;The current Tx is single-buffer-only.&n;&t;Move the theory of operation and memory map documentation.&n;&t;Rework the board error reset&n;&t;The statistics need to be updated correctly.&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;eexpress.c:v0.07 1/19/94 Donald Becker (becker@super.org)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n;  Sources:&n;&t;This driver wouldn&squot;t have been written with the availability of the&n;&t;Crynwr driver source code.&t;It provided a known-working implementation&n;&t;that filled in the gaping holes of the Intel documention.  Three cheers&n;&t;for Russ Nelson.&n;&n;&t;Intel Microcommunications Databook, Vol. 1, 1990. It provides just enough&n;&t;info that the casual reader might think that it documents the i82586.&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/* use 0 for production, 1 for verification, 2..7 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/*&n;  &t;&t;&t;Details of the i82586.&n;&n;   You&squot;ll really need the databook to understand the details of this part,&n;   but the outline is that the i82586 has two seperate processing units.&n;&n;   The Rx unit uses a list of frame descriptors and a list of data buffer&n;   descriptors.  We use full-sized (1518 byte) data buffers, so there is&n;   a one-to-one pairing of frame descriptors to buffer descriptors.&n;&n;   The Tx (&quot;command&quot;) unit executes a list of commands that look like:&n;&t;&t;Status word&t;&t;Written by the 82586 when the command is done.&n;&t;&t;Command word&t;Command in lower 3 bits, post-command action in upper 3&n;&t;&t;Link word&t;&t;The address of the next command.&n;&t;&t;Parameters&t;&t;(as needed).&n;&n;&t;Some definitions related to the Command Word are:&n; */
DECL|macro|CMD_EOL
mdefine_line|#define CMD_EOL&t;&t;0x8000&t;&t;&t;/* The last command of the list, stop. */
DECL|macro|CMD_SUSP
mdefine_line|#define CMD_SUSP&t;0x4000&t;&t;&t;/* Suspend after doing cmd. */
DECL|macro|CMD_INTR
mdefine_line|#define CMD_INTR&t;0x2000&t;&t;&t;/* Interrupt after doing cmd. */
DECL|enum|commands
r_enum
id|commands
(brace
DECL|enumerator|CmdNOp
DECL|enumerator|CmdSASetup
DECL|enumerator|CmdConfigure
DECL|enumerator|CmdMulticastList
id|CmdNOp
op_assign
l_int|0
comma
id|CmdSASetup
op_assign
l_int|1
comma
id|CmdConfigure
op_assign
l_int|2
comma
id|CmdMulticastList
op_assign
l_int|3
comma
DECL|enumerator|CmdTx
DECL|enumerator|CmdTDR
DECL|enumerator|CmdDump
DECL|enumerator|CmdDiagnose
id|CmdTx
op_assign
l_int|4
comma
id|CmdTDR
op_assign
l_int|5
comma
id|CmdDump
op_assign
l_int|6
comma
id|CmdDiagnose
op_assign
l_int|7
)brace
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
DECL|member|last_restart
r_int
id|last_restart
suffix:semicolon
DECL|member|rx_head
r_int
id|rx_head
suffix:semicolon
DECL|member|rx_tail
r_int
id|rx_tail
suffix:semicolon
DECL|member|tx_head
r_int
id|tx_head
suffix:semicolon
DECL|member|tx_cmd_link
r_int
id|tx_cmd_link
suffix:semicolon
DECL|member|tx_reap
r_int
id|tx_reap
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;  &t;&t;Details of the EtherExpress Implementation&n;  The EtherExpress takes an unusual approach to host access to packet buffer&n;  memory.  The host can use either the Dataport, with independent&n;  autoincrementing read and write pointers, or it can I/O map 32 bytes of the&n;  memory using the &quot;Shadow Memory Pointer&quot; (SMB) as follows:&n;&t;&t;&t;ioaddr&t;&t;&t;&t;&t;&t;Normal EtherExpress registers&n;&t;&t;&t;ioaddr+0x4000...0x400f&t;&t;Buffer Memory at SMB...SMB+15&n;&t;&t;&t;ioaddr+0x8000...0x800f&t;&t;Buffer Memory at SMB+16...SMB+31&n;&t;&t;&t;ioaddr+0xC000...0xC007&t;&t;&quot;&quot; SMB+16...SMB+23 (hardware flaw?)&n;&t;&t;&t;ioaddr+0xC008...0xC00f&t;&t;Buffer Memory at 0x0008...0x000f&n;  The last I/O map set is useful if you put the i82586 System Command Block&n;  (the command mailbox) exactly at 0x0008.  (There seems to be some&n;  undocumented init structure at 0x0000-7, so I had to use the Crywnr memory&n;  setup verbatim for those four words anyway.)&n;&n;  A problem with using either one of these mechanisms is that you must run&n;  single-threaded, or the interrupt handler must restore a changed value of&n;  the read, write, or SMB pointers.&n;&n;  Unlike the Crynwr driver, my driver mostly ignores the I/O mapped &quot;feature&quot;&n;  and relies heavily on the dataport for buffer memory access.  To minimize&n;  switching, the read_pointer is dedicated to the Rx interrupt handler, and&n;  the write_pointer is used by the send_packet() routine (it&squot;s carefully saved&n;  and restored when it&squot;s needed by the interrupt handler).&n;  */
multiline_comment|/* Offsets from the base I/O address. */
DECL|macro|DATAPORT
mdefine_line|#define DATAPORT&t;0&t;/* Data Transfer Register. */
DECL|macro|WRITE_PTR
mdefine_line|#define WRITE_PTR&t;2&t;/* Write Address Pointer. */
DECL|macro|READ_PTR
mdefine_line|#define READ_PTR&t;4&t;/* Read Address Pointer. */
DECL|macro|SIGNAL_CA
mdefine_line|#define SIGNAL_CA&t;6&t;/* Frob the 82586 Channel Attention line. */
DECL|macro|SET_IRQ
mdefine_line|#define SET_IRQ&t;&t;7&t;/* IRQ Select. */
DECL|macro|SHADOW_PTR
mdefine_line|#define SHADOW_PTR&t;8&t;/* Shadow Memory Bank Pointer. */
DECL|macro|MEM_Ctrl
mdefine_line|#define MEM_Ctrl&t;11
DECL|macro|MEM_Page_Ctrl
mdefine_line|#define MEM_Page_Ctrl&t;12
DECL|macro|Config
mdefine_line|#define Config&t;&t;13
DECL|macro|EEPROM_Ctrl
mdefine_line|#define EEPROM_Ctrl&t;&t;14
DECL|macro|ID_PORT
mdefine_line|#define ID_PORT&t;&t;15
multiline_comment|/*&t;EEPROM_Ctrl bits. */
DECL|macro|EE_SHIFT_CLK
mdefine_line|#define EE_SHIFT_CLK&t;0x01&t;/* EEPROM shift clock. */
DECL|macro|EE_CS
mdefine_line|#define EE_CS&t;&t;&t;0x02&t;/* EEPROM chip select. */
DECL|macro|EE_DATA_WRITE
mdefine_line|#define EE_DATA_WRITE&t;0x04&t;/* EEPROM chip data in. */
DECL|macro|EE_DATA_READ
mdefine_line|#define EE_DATA_READ&t;0x08&t;/* EEPROM chip data out. */
DECL|macro|EE_CTRL_BITS
mdefine_line|#define EE_CTRL_BITS&t;(EE_SHIFT_CLK | EE_CS | EE_DATA_WRITE | EE_DATA_READ)
DECL|macro|ASIC_RESET
mdefine_line|#define ASIC_RESET&t;&t;0x40
DECL|macro|_586_RESET
mdefine_line|#define _586_RESET&t;&t;0x80
multiline_comment|/* Offsets to elements of the System Control Block structure. */
DECL|macro|SCB_STATUS
mdefine_line|#define SCB_STATUS&t;0xc008
DECL|macro|SCB_CMD
mdefine_line|#define SCB_CMD&t;&t;0xc00A
DECL|macro|CUC_START
mdefine_line|#define&t; CUC_START&t; 0x0100
DECL|macro|CUC_RESUME
mdefine_line|#define&t; CUC_RESUME&t; 0x0200
DECL|macro|CUC_SUSPEND
mdefine_line|#define&t; CUC_SUSPEND 0x0300
DECL|macro|RX_START
mdefine_line|#define&t; RX_START&t; 0x0010
DECL|macro|RX_RESUME
mdefine_line|#define&t; RX_RESUME&t; 0x0020
DECL|macro|RX_SUSPEND
mdefine_line|#define&t; RX_SUSPEND&t; 0x0030
DECL|macro|SCB_CBL
mdefine_line|#define SCB_CBL&t;&t;0xc00C&t;/* Command BLock offset. */
DECL|macro|SCB_RFA
mdefine_line|#define SCB_RFA&t;&t;0xc00E&t;/* Rx Frame Area offset. */
multiline_comment|/*&n;  What follows in &squot;init_words[]&squot; is the &quot;program&quot; that is downloaded to the&n;  82586 memory.&t; It&squot;s mostly tables and command blocks, and starts at the&n;  reset address 0xfffff6.&n;&n;  Even with the additional &quot;don&squot;t care&quot; values, doing it this way takes less&n;  program space than initializing the individual tables, and I feel it&squot;s much&n;  cleaner.&n;&n;  The databook is particularly useless for the first two structures; they are&n;  completely undocumented.  I had to use the Crynwr driver as an example.&n;&n;   The memory setup is as follows:&n;   */
DECL|macro|CONFIG_CMD
mdefine_line|#define CONFIG_CMD&t;0x0018
DECL|macro|SET_SA_CMD
mdefine_line|#define SET_SA_CMD&t;0x0024
DECL|macro|SA_OFFSET
mdefine_line|#define SA_OFFSET&t;0x002A
DECL|macro|IDLELOOP
mdefine_line|#define IDLELOOP&t;0x30
DECL|macro|TDR_CMD
mdefine_line|#define TDR_CMD&t;&t;0x38
DECL|macro|TDR_TIME
mdefine_line|#define TDR_TIME&t;0x3C
DECL|macro|DUMP_CMD
mdefine_line|#define DUMP_CMD&t;0x40
DECL|macro|DIAG_CMD
mdefine_line|#define DIAG_CMD&t;0x48
DECL|macro|SET_MC_CMD
mdefine_line|#define SET_MC_CMD&t;0x4E
DECL|macro|DUMP_DATA
mdefine_line|#define DUMP_DATA&t;0x56&t;/* A 170 byte buffer for dump and Set-MC into. */
DECL|macro|TX_BUF_START
mdefine_line|#define TX_BUF_START&t;0x0100
DECL|macro|NUM_TX_BUFS
mdefine_line|#define NUM_TX_BUFS &t;4
DECL|macro|TX_BUF_SIZE
mdefine_line|#define TX_BUF_SIZE&t;&t;0x0680&t;/* packet+header+TBD+extra (1518+14+20+16) */
DECL|macro|TX_BUF_END
mdefine_line|#define TX_BUF_END&t;&t;0x2000
DECL|macro|RX_BUF_START
mdefine_line|#define RX_BUF_START&t;0x2000
DECL|macro|RX_BUF_SIZE
mdefine_line|#define RX_BUF_SIZE &t;(0x640)&t;/* packet+header+RBD+extra */
DECL|macro|RX_BUF_END
mdefine_line|#define RX_BUF_END&t;&t;0x4000
multiline_comment|/*&n;  That&squot;s it: only 86 bytes to set up the beast, including every extra&n;  command available.  The 170 byte buffer at DUMP_DATA is shared between the&n;  Dump command (called only by the diagnostic program) and the SetMulticastList&n;  command.&n;&n;  To complete the memory setup you only have to write the station address at&n;  SA_OFFSET and create the Tx &amp; Rx buffer lists.&n;&n;  The Tx command chain and buffer list is setup as follows:&n;  A Tx command table, with the data buffer pointing to...&n;  A Tx data buffer descriptor.  The packet is in a single buffer, rather than&n;     chaining together several smaller buffers.&n;  A NoOp command, which initially points to itself,&n;  And the packet data.&n;&n;  A transmit is done by filling in the Tx command table and data buffer,&n;  re-writing the NoOp command, and finally changing the offset of the last&n;  command to point to the current Tx command.  When the Tx command is finished,&n;  it jumps to the NoOp, when it loops until the next Tx command changes the&n;  &quot;link offset&quot; in the NoOp.  This way the 82586 never has to go through the&n;  slow restart sequence.&n;&n;  The Rx buffer list is set up in the obvious ring structure.  We have enough&n;  memory (and low enough interrupt latency) that we can avoid the complicated&n;  Rx buffer linked lists by alway associating a full-size Rx data buffer with&n;  each Rx data frame.&n;&n;  I current use four transmit buffers starting at TX_BUF_START (0x0100), and&n;  use the rest of memory, from RX_BUF_START to RX_BUF_END, for Rx buffers.&n;&n;  */
DECL|variable|init_words
r_static
r_int
id|init_words
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
multiline_comment|/* Set bus size to 16 bits. */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* Set control mailbox (SCB) addr. */
l_int|0
comma
l_int|0
comma
multiline_comment|/* pad to 0x000000. */
l_int|0x0001
comma
multiline_comment|/* Status word that&squot;s cleared when init is done. */
l_int|0x0008
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* SCB offset, (skip, skip) */
l_int|0
comma
l_int|0xf000
op_or
id|RX_START
op_or
id|CUC_START
comma
multiline_comment|/* SCB status and cmd. */
id|CONFIG_CMD
comma
multiline_comment|/* Command list pointer, points to Configure. */
id|RX_BUF_START
comma
multiline_comment|/* Rx block list. */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* Error count: CRC, align, buffer, overrun. */
multiline_comment|/* 0x0018: Configure command.  Change to put MAC data with packet. */
l_int|0
comma
id|CmdConfigure
comma
multiline_comment|/* Status, command.&t;&t;*/
id|SET_SA_CMD
comma
multiline_comment|/* Next command is Set Station Addr. */
l_int|0x0804
comma
multiline_comment|/* &quot;4&quot; bytes of config data, 8 byte FIFO. */
l_int|0x2e40
comma
multiline_comment|/* Magic values, including MAC data location. */
l_int|0
comma
multiline_comment|/* Unused pad word. */
multiline_comment|/* 0x0024: Setup station address command. */
l_int|0
comma
id|CmdSASetup
comma
id|SET_MC_CMD
comma
multiline_comment|/* Next command. */
l_int|0xaa00
comma
l_int|0xb000
comma
l_int|0x0bad
comma
multiline_comment|/* Station address (to be filled in) */
multiline_comment|/* 0x0030: NOP, looping back to itself.&t; Point to first Tx buffer to Tx. */
l_int|0
comma
id|CmdNOp
comma
id|IDLELOOP
comma
l_int|0
multiline_comment|/* pad */
comma
multiline_comment|/* 0x0038: A unused Time-Domain Reflectometer command. */
l_int|0
comma
id|CmdTDR
comma
id|IDLELOOP
comma
l_int|0
comma
multiline_comment|/* 0x0040: An unused Dump State command. */
l_int|0
comma
id|CmdDump
comma
id|IDLELOOP
comma
id|DUMP_DATA
comma
multiline_comment|/* 0x0048: An unused Diagnose command. */
l_int|0
comma
id|CmdDiagnose
comma
id|IDLELOOP
comma
multiline_comment|/* 0x004E: An empty set-multicast-list command. */
macro_line|#ifdef initial_text_tx
l_int|0
comma
id|CmdMulticastList
comma
id|DUMP_DATA
comma
l_int|0
comma
macro_line|#else
l_int|0
comma
id|CmdMulticastList
comma
id|IDLELOOP
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/* 0x0056: A continuous transmit command, only here for testing. */
l_int|0
comma
id|CmdTx
comma
id|DUMP_DATA
comma
id|DUMP_DATA
op_plus
l_int|8
comma
l_int|0x83ff
comma
op_minus
l_int|1
comma
id|DUMP_DATA
comma
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|express_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Called from Space.c */
r_static
r_int
id|eexp_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|eexp_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eexp_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_void
id|eexp_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eexp_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|eexp_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
suffix:semicolon
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|init_82586_mem
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|init_rx_bufs
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, (detachable devices only) alloate space for the&n;   device and return success.&n;   */
r_int
DECL|function|express_probe
id|express_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* Don&squot;t probe all settable addresses, 0x[23][0-7]0, just common ones. */
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
l_int|0x300
comma
l_int|0x270
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0
)brace
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|eexp_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
OG
l_int|0
)paren
r_return
id|ENXIO
suffix:semicolon
multiline_comment|/* Don&squot;t probe at all. */
r_for
c_loop
(paren
id|port
op_assign
op_amp
id|ports
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
id|id_addr
op_assign
op_star
id|port
op_plus
id|ID_PORT
suffix:semicolon
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef notdef
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|sum
op_add_assign
id|inb
c_func
(paren
id|id_addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EtherExpress ID checksum is %04x.&bslash;n&quot;
comma
id|sum
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|id_val
op_assign
id|inb
c_func
(paren
id|id_addr
)paren
suffix:semicolon
id|sum
op_or_assign
(paren
id|id_val
op_rshift
l_int|4
)paren
op_lshift
(paren
(paren
id|id_val
op_amp
l_int|3
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|sum
op_eq
l_int|0xbaba
op_logical_and
id|eexp_probe1
c_func
(paren
id|dev
comma
op_star
id|port
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ENODEV
suffix:semicolon
multiline_comment|/* ENODEV would be more accurate. */
)brace
DECL|function|eexp_probe1
r_int
id|eexp_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
r_int
id|station_addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: EtherExpress at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* The station address is stored !backwards! in the EEPROM, reverse&n;&t;   after reading.  (Hmmm, a little brain-damage there at Intel, eh?) */
id|station_addr
(braket
l_int|0
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|2
)paren
suffix:semicolon
id|station_addr
(braket
l_int|1
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|3
)paren
suffix:semicolon
id|station_addr
(braket
l_int|2
)braket
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Check the first three octets of the S.A. for the manufactor&squot;s code. */
r_if
c_cond
(paren
id|station_addr
(braket
l_int|2
)braket
op_ne
l_int|0x00aa
op_logical_or
(paren
id|station_addr
(braket
l_int|1
)braket
op_amp
l_int|0xff00
)paren
op_ne
l_int|0x0000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; rejected (invalid address %04x%04x%04x).&bslash;n&quot;
comma
id|station_addr
(braket
l_int|2
)braket
comma
id|station_addr
(braket
l_int|1
)braket
comma
id|station_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve committed to using the board, and can start filling in *dev. */
id|snarf_region
c_func
(paren
id|ioaddr
comma
l_int|16
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|station_addr
)paren
(braket
l_int|5
op_minus
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* There is no reason for the driver to care, but I print out the&n;&t;   interface to minimize bogus bug reports. */
(brace
r_char
id|irqmap
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|9
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|10
comma
l_int|11
comma
l_int|0
)brace
suffix:semicolon
r_char
op_star
id|ifmap
(braket
)braket
op_assign
(brace
l_string|&quot;AUI&quot;
comma
l_string|&quot;BNC&quot;
comma
l_string|&quot;10baseT&quot;
)brace
suffix:semicolon
r_enum
id|iftype
(brace
id|AUI
op_assign
l_int|0
comma
id|BNC
op_assign
l_int|1
comma
id|TP
op_assign
l_int|2
)brace
suffix:semicolon
r_int
r_int
id|setupval
op_assign
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irqmap
(braket
id|setupval
op_rshift
l_int|13
)braket
suffix:semicolon
id|dev-&gt;if_port
op_assign
(paren
id|setupval
op_amp
l_int|0x1000
)paren
op_eq
l_int|0
ques
c_cond
id|AUI
suffix:colon
id|read_eeprom
c_func
(paren
id|ioaddr
comma
l_int|5
)paren
op_amp
l_int|0x1
ques
c_cond
id|TP
suffix:colon
id|BNC
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, IRQ %d, Interface %s.&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|ifmap
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
multiline_comment|/* Release the IRQ line so that it can be shared if we don&squot;t use the&n;&t;&t;   ethercard. */
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
)brace
multiline_comment|/* It&squot;s now OK to leave the board in reset, pending the open(). */
id|outb
c_func
(paren
id|ASIC_RESET
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
OG
l_int|0
)paren
id|net_debug
op_assign
id|dev-&gt;mem_start
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|eexp_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|eexp_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|eexp_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|eexp_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet-generic values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Reverse IRQ map: the value to put in the SET_IRQ reg. for IRQ&lt;index&gt;. */
DECL|variable|irqrmap
r_static
r_char
id|irqrmap
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_int
DECL|function|eexp_open
id|eexp_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
op_logical_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_ne
l_int|0
multiline_comment|/* This is always true, but avoid the false IRQ. */
op_logical_or
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
)paren
op_eq
l_int|0
op_logical_or
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|eexp_interrupt
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Initialize the 82586 memory and start it. */
id|init_82586_mem
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Enable the interrupt line. */
id|outb
c_func
(paren
id|irqrmap
(braket
id|dev-&gt;irq
)braket
op_or
l_int|0x08
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|eexp_send_packet
id|eexp_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?  &quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
op_amp
l_int|0x8000
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
r_if
c_cond
(paren
id|lp-&gt;last_restart
op_eq
id|lp-&gt;stats.tx_packets
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Resetting board.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Completely reset the adaptor. */
id|init_82586_mem
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Issue the channel attention signal and hope it &quot;gets better&quot;. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Kicking board.&bslash;n&quot;
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xf000
op_or
id|CUC_START
op_or
id|RX_START
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
id|lp-&gt;last_restart
op_assign
id|lp-&gt;stats.tx_packets
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* If some higher layer thinks we&squot;ve missed an tx-done interrupt&n;&t;   we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;&t;   itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
(brace
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Disable the 82586&squot;s input to the interrupt line. */
id|outb
c_func
(paren
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|hardware_send_packet
c_func
(paren
id|dev
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Enable the 82586 interrupt input. */
id|outb
c_func
(paren
l_int|0x08
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* You might need to clean up and record Tx statistics here. */
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&t;The typical workload of the driver:&n;&t;Handle the network interface interrupts. */
r_static
r_void
DECL|function|eexp_interrupt
id|eexp_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_int
id|ack_cmd
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EExp interrupt, status %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable the 82586&squot;s input to the interrupt line. */
id|outb
c_func
(paren
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
multiline_comment|/* Reap the Tx packet buffers. */
r_while
c_loop
(paren
id|lp-&gt;tx_reap
op_ne
id|lp-&gt;tx_head
)paren
(brace
multiline_comment|/* if (status &amp; 0x8000) */
r_int
r_int
id|tx_status
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_reap
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|tx_status
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t reap %#x.&bslash;n&quot;
comma
id|lp-&gt;tx_reap
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x2000
)paren
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.collisions
op_add_assign
id|tx_status
op_amp
l_int|0xf
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
r_else
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0600
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0100
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tx_status
op_amp
l_int|0x0040
)paren
)paren
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0020
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Reaped %x, Tx status %04x.&bslash;n&quot;
comma
id|lp-&gt;tx_reap
comma
id|tx_status
)paren
suffix:semicolon
id|lp-&gt;tx_reap
op_add_assign
id|TX_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_reap
OG
id|TX_BUF_END
op_minus
id|TX_BUF_SIZE
)paren
id|lp-&gt;tx_reap
op_assign
id|TX_BUF_START
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|boguscount
OG
l_int|4
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x4000
)paren
(brace
multiline_comment|/* Packet received. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Received packet, rx_head %04x.&bslash;n&quot;
comma
id|lp-&gt;rx_head
)paren
suffix:semicolon
id|eexp_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Acknowledge the interrupt sources. */
id|ack_cmd
op_assign
id|status
op_amp
l_int|0xf000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x0700
)paren
op_ne
l_int|0x0200
op_logical_and
id|dev-&gt;start
)paren
(brace
r_int
id|saved_write_ptr
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Command unit stopped, status %04x, restarting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* If this ever occurs we must re-write the idle loop, reset&n;&t;&t;   the Tx list, and do a complete restart of the command unit. */
id|outw
c_func
(paren
id|IDLELOOP
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CmdNOp
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|IDLELOOP
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|IDLELOOP
comma
id|SCB_CBL
)paren
suffix:semicolon
id|lp-&gt;tx_cmd_link
op_assign
id|IDLELOOP
op_plus
l_int|4
suffix:semicolon
id|lp-&gt;tx_head
op_assign
id|lp-&gt;tx_reap
op_assign
id|TX_BUF_START
suffix:semicolon
multiline_comment|/* Restore the saved write pointer. */
id|outw
c_func
(paren
id|saved_write_ptr
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|ack_cmd
op_or_assign
id|CUC_START
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x0070
)paren
op_ne
l_int|0x0040
op_logical_and
id|dev-&gt;start
)paren
(brace
r_int
id|saved_write_ptr
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
multiline_comment|/* The Rx unit is not ready, it must be hung.  Restart the receiver by&n;&t;&t;   initializing the rx buffers, and issuing an Rx start command. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
(brace
r_int
id|cur_rxbuf
op_assign
id|RX_BUF_START
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Rx unit stopped status %04x rx head %04x tail %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
comma
id|lp-&gt;rx_head
comma
id|lp-&gt;rx_tail
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cur_rxbuf
op_le
id|RX_BUF_END
op_minus
id|RX_BUF_SIZE
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Rx buf at %04x:&quot;
comma
id|cur_rxbuf
)paren
suffix:semicolon
id|outw
c_func
(paren
id|cur_rxbuf
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x20
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot; %04x&quot;
comma
id|inw
c_func
(paren
id|ioaddr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|cur_rxbuf
op_add_assign
id|RX_BUF_SIZE
suffix:semicolon
)brace
)brace
id|init_rx_bufs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|RX_BUF_START
comma
id|SCB_RFA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|saved_write_ptr
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|ack_cmd
op_or_assign
id|RX_START
suffix:semicolon
)brace
id|outw
c_func
(paren
id|ack_cmd
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EExp exiting interrupt, status %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_CMD
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable the 82586&squot;s input to the interrupt line. */
id|outb
c_func
(paren
id|irqrmap
(braket
id|dev-&gt;irq
)braket
op_or
l_int|0x08
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|eexp_close
id|eexp_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx. */
id|outw
c_func
(paren
id|RX_SUSPEND
op_or
id|CUC_SUSPEND
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
multiline_comment|/* Disable the physical interrupt line. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|enet_statistics
op_star
DECL|function|eexp_get_stats
id|eexp_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* ToDo: decide if there are any useful statistics from the SCB. */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n;   num_addrs == -1&t;Promiscuous mode, receive all packets&n;   num_addrs == 0&t;Normal mode, clear multicast list&n;   num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;&t;&t;&t;best-effort filtering.&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|num_addrs
OL
l_int|0
)paren
(brace
multiline_comment|/* Not written yet, this requires expanding the init_words config&n;&t;&t;   cmd. */
)brace
r_else
r_if
c_cond
(paren
id|num_addrs
OG
l_int|0
)paren
(brace
multiline_comment|/* Fill in the SET_MC_CMD with the number of address bytes, followed&n;&t;&t;   by the list of multicast addresses to be accepted. */
id|outw
c_func
(paren
id|SET_MC_CMD
op_plus
l_int|6
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|num_addrs
op_star
l_int|6
comma
id|ioaddr
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|addrs
comma
id|num_addrs
op_star
l_int|3
)paren
suffix:semicolon
multiline_comment|/* 3 = addr len in words */
multiline_comment|/* We must trigger a whole 586 reset due to a bug. */
)brace
r_else
(brace
multiline_comment|/* Not written yet, this requires expanding the init_words config&n;&t;&t;   cmd. */
id|outw
c_func
(paren
l_int|99
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Disable promiscuous mode, use normal mode */
)brace
)brace
multiline_comment|/* The horrible routine to read a word from the serial EEPROM. */
multiline_comment|/* The delay between EEPROM clock transitions. */
DECL|macro|eeprom_delay
mdefine_line|#define eeprom_delay()&t;{ int _i = 40; while (--_i &gt; 0) { __SLOW_DOWN_IO; }}
DECL|macro|EE_READ_CMD
mdefine_line|#define EE_READ_CMD (6 &lt;&lt; 6)
r_int
DECL|function|read_eeprom
id|read_eeprom
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|location
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|ee_addr
op_assign
id|ioaddr
op_plus
id|EEPROM_Ctrl
suffix:semicolon
r_int
id|read_cmd
op_assign
id|location
op_or
id|EE_READ_CMD
suffix:semicolon
r_int
id|ctrl_val
op_assign
id|EE_CS
op_or
id|_586_RESET
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* Shift the read command bits out. */
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|outval
op_assign
(paren
id|read_cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|ctrl_val
op_or
id|EE_DATA_WRITE
suffix:colon
id|ctrl_val
suffix:semicolon
id|outb
c_func
(paren
id|outval
comma
id|ee_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outval
op_or
id|EE_SHIFT_CLK
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* EEPROM clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|outval
comma
id|ee_addr
)paren
suffix:semicolon
multiline_comment|/* Finish EEPROM a clock tick. */
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outb
c_func
(paren
id|ctrl_val
op_or
id|EE_SHIFT_CLK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|inb
c_func
(paren
id|ee_addr
)paren
op_amp
id|EE_DATA_READ
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate the EEPROM access. */
id|ctrl_val
op_and_assign
op_complement
id|EE_CS
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
op_or
id|EE_SHIFT_CLK
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctrl_val
comma
id|ee_addr
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|init_82586_mem
id|init_82586_mem
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* Enable loopback to protect the wire while starting up.&n;&t;   This is Superstition From Crynwr. */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|Config
)paren
op_or
l_int|0x02
comma
id|ioaddr
op_plus
id|Config
)paren
suffix:semicolon
multiline_comment|/* Hold the 586 in reset during the memory initialization. */
id|outb
c_func
(paren
id|_586_RESET
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
multiline_comment|/* Place the write pointer at 0xfff6 (address-aliased to 0xfffff6). */
id|outw
c_func
(paren
l_int|0xfff6
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|init_words
comma
r_sizeof
(paren
id|init_words
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Fill in the station address. */
id|outw
c_func
(paren
id|SA_OFFSET
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|dev-&gt;dev_addr
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* The Tx-block list is written as needed.  We just set up the values. */
macro_line|#ifdef initial_text_tx
id|lp-&gt;tx_cmd_link
op_assign
id|DUMP_DATA
op_plus
l_int|4
suffix:semicolon
macro_line|#else
id|lp-&gt;tx_cmd_link
op_assign
id|IDLELOOP
op_plus
l_int|4
suffix:semicolon
macro_line|#endif
id|lp-&gt;tx_head
op_assign
id|lp-&gt;tx_reap
op_assign
id|TX_BUF_START
suffix:semicolon
id|init_rx_bufs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Start the 586 by releasing the reset line. */
id|outb
c_func
(paren
l_int|0x00
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
multiline_comment|/* This was time consuming to track down: you need to give two channel&n;&t;   attention signals to reliably start up the i82586. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
(brace
r_int
id|boguscnt
op_assign
l_int|50
suffix:semicolon
r_while
c_loop
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
op_decrement
id|boguscnt
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: i82586 initialization timed out with status %04x, cmd %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_CMD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Issue channel-attn -- the 82586 won&squot;t start without it. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable loopback. */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|Config
)paren
op_amp
op_complement
l_int|0x02
comma
id|ioaddr
op_plus
id|Config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Initialized 82586, status %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Initialize the Rx-block list. */
DECL|function|init_rx_bufs
r_static
r_void
id|init_rx_bufs
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|cur_rxbuf
op_assign
id|lp-&gt;rx_head
op_assign
id|RX_BUF_START
suffix:semicolon
multiline_comment|/* Initialize each Rx frame + data buffer. */
r_do
(brace
multiline_comment|/* While there is room for one more. */
id|outw
c_func
(paren
id|cur_rxbuf
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Status */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Command */
id|outw
c_func
(paren
id|cur_rxbuf
op_plus
id|RX_BUF_SIZE
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Link */
id|outw
c_func
(paren
id|cur_rxbuf
op_plus
l_int|22
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Buffer offset */
id|outw
c_func
(paren
l_int|0xFeed
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Pad for dest addr. */
id|outw
c_func
(paren
l_int|0xF00d
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xF001
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0505
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Pad for source addr. */
id|outw
c_func
(paren
l_int|0x2424
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x6565
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xdeaf
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Pad for protocol. */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Buffer: Actual count */
id|outw
c_func
(paren
op_minus
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Buffer: Next (none). */
id|outw
c_func
(paren
id|cur_rxbuf
op_plus
l_int|0x20
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Buffer: Address low */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Finally, the number of bytes in the buffer. */
id|outw
c_func
(paren
l_int|0x8000
op_plus
id|RX_BUF_SIZE
op_minus
l_int|0x20
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;rx_tail
op_assign
id|cur_rxbuf
suffix:semicolon
id|cur_rxbuf
op_add_assign
id|RX_BUF_SIZE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur_rxbuf
op_le
id|RX_BUF_END
op_minus
id|RX_BUF_SIZE
)paren
suffix:semicolon
multiline_comment|/* Terminate the list by setting the EOL bit, and wrap the pointer to make&n;&t;   the list a ring. */
id|outw
c_func
(paren
id|lp-&gt;rx_tail
op_plus
l_int|2
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xC000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Command, mark as last. */
id|outw
c_func
(paren
id|lp-&gt;rx_head
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Link */
)brace
r_static
r_void
DECL|function|hardware_send_packet
id|hardware_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|tx_block
op_assign
id|lp-&gt;tx_head
suffix:semicolon
multiline_comment|/* Set the write pointer to the Tx block, and put out the header. */
id|outw
c_func
(paren
id|tx_block
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Tx status */
id|outw
c_func
(paren
id|CMD_INTR
op_or
id|CmdTx
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Tx command */
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|16
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Next command is a NoOp. */
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|8
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Data Buffer offset. */
multiline_comment|/* Output the data buffer descriptor. */
id|outw
c_func
(paren
id|length
op_or
l_int|0x8000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Byte count parameter. */
id|outw
c_func
(paren
op_minus
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* No next data buffer. */
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|22
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Buffer follows the NoOp command. */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Buffer address high bits (always zero). */
multiline_comment|/* Output the Loop-back NoOp command. */
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Tx status */
id|outw
c_func
(paren
id|CmdNOp
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Tx command */
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|16
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Next is myself. */
multiline_comment|/* Output the packet using the write pointer.&n;&t;   Hmmm, it feels a little like a 3c501! */
id|outsw
c_func
(paren
id|ioaddr
op_plus
id|DATAPORT
comma
id|buf
comma
(paren
id|length
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the old command link pointing to this send packet. */
id|outw
c_func
(paren
id|lp-&gt;tx_cmd_link
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|tx_block
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;tx_cmd_link
op_assign
id|tx_block
op_plus
l_int|20
suffix:semicolon
multiline_comment|/* Set the next free tx region. */
id|lp-&gt;tx_head
op_assign
id|tx_block
op_plus
id|TX_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_head
OG
id|TX_BUF_END
op_minus
id|TX_BUF_SIZE
)paren
id|lp-&gt;tx_head
op_assign
id|TX_BUF_START
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EExp @%x send length = %d, tx_block %3x, next %3x, &quot;
l_string|&quot;reap %4x status %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
comma
id|length
comma
id|tx_block
comma
id|lp-&gt;tx_head
comma
id|lp-&gt;tx_reap
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;tx_head
op_ne
id|lp-&gt;tx_reap
)paren
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|eexp_rx
id|eexp_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|saved_write_ptr
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_int
id|rx_head
op_assign
id|lp-&gt;rx_head
suffix:semicolon
r_int
id|rx_tail
op_assign
id|lp-&gt;rx_tail
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|10
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
multiline_comment|/* Set the read pointer to the Rx frame. */
id|outw
c_func
(paren
id|rx_head
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|frame_status
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Command complete */
r_int
id|rfd_cmd
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
id|next_rx_frame
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
id|data_buffer_addr
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
multiline_comment|/* Set the read pointer the data buffer. */
id|outw
c_func
(paren
id|data_buffer_addr
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|pkt_len
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rfd_cmd
op_ne
l_int|0
op_logical_or
id|data_buffer_addr
op_ne
id|rx_head
op_plus
l_int|22
op_logical_or
id|pkt_len
op_amp
l_int|0xC000
op_ne
l_int|0xC000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Rx frame at %#x corrupted, status %04x cmd %04x&quot;
l_string|&quot;next %04x data-buf @%04x %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_head
comma
id|frame_status
comma
id|rfd_cmd
comma
id|next_rx_frame
comma
id|data_buffer_addr
comma
id|pkt_len
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|frame_status
op_amp
l_int|0x2000
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Frame Rxed, but with error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0800
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0400
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0200
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0100
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0080
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pkt_len
op_and_assign
l_int|0x3fff
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|outw
c_func
(paren
id|data_buffer_addr
op_plus
l_int|10
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
comma
id|skb-&gt;data
comma
(paren
id|pkt_len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
multiline_comment|/* Clear the status word and set End-of-List on the rx frame. */
id|outw
c_func
(paren
id|rx_head
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xC000
comma
id|ioaddr
)paren
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|next_rx_frame
op_ne
id|rx_head
op_plus
id|RX_BUF_SIZE
op_logical_and
id|next_rx_frame
op_ne
id|RX_BUF_START
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Rx next frame at %#x is %#x instead of %#x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_head
comma
id|next_rx_frame
comma
id|rx_head
op_plus
id|RX_BUF_SIZE
)paren
suffix:semicolon
id|next_rx_frame
op_assign
id|rx_head
op_plus
id|RX_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|next_rx_frame
op_ge
id|RX_BUF_END
op_minus
id|RX_BUF_SIZE
)paren
id|next_rx_frame
op_assign
id|RX_BUF_START
suffix:semicolon
)brace
macro_line|#endif
id|outw
c_func
(paren
id|rx_tail
op_plus
l_int|2
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Clear the end-of-list on the prev. RFD. */
macro_line|#ifndef final_version
id|outw
c_func
(paren
id|rx_tail
op_plus
l_int|4
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
c_func
(paren
id|ioaddr
)paren
op_ne
id|rx_head
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Rx buf link mismatch, at %04x link %04x instead of %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_tail
comma
(paren
id|outw
c_func
(paren
id|rx_tail
op_plus
l_int|4
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
comma
id|inw
c_func
(paren
id|ioaddr
)paren
)paren
comma
id|rx_head
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_head
comma
id|ioaddr
)paren
suffix:semicolon
)brace
macro_line|#endif
id|rx_tail
op_assign
id|rx_head
suffix:semicolon
id|rx_head
op_assign
id|next_rx_frame
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscount
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|outw
c_func
(paren
id|rx_head
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
)brace
id|lp-&gt;rx_head
op_assign
id|rx_head
suffix:semicolon
id|lp-&gt;rx_tail
op_assign
id|rx_tail
suffix:semicolon
multiline_comment|/* Restore the original write pointer. */
id|outw
c_func
(paren
id|saved_write_ptr
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -I/usr/src/linux/drivers/net -Wall -Wstrict-prototypes -O6 -m486 -c eexpress.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 4&n; * End:&n; */
eof
