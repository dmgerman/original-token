multiline_comment|/*&n; * eexpress2.c: Intel EtherExpress device driver for Linux&n; *&n; * Original version written 1993 by Donald Becker&n; * Modularized by Pauline Middelink &lt;middelin@polyware.iaf.nl&gt;&n; * Changed to support io= irq= by Alan Cox &lt;Alan.Cox@linux.org&gt;&n; * Reworked 1995 by John Sullivan &lt;js10039@cam.ac.uk&gt;&n; *&n; *  06mar96 Philip Blundell &lt;pjb27@cam.ac.uk&gt;&n; *     - move started, buffer sizes, and so on into private data area.&n; *     - fix module loading for multiple cards&n; * &n; *  31jan96 Philip Blundell &lt;pjb27@cam.ac.uk&gt;&n; *     - Tidy up&n; *     - Some debugging.  Now works with 1.3 kernels.&n; *&n; *     Still to do:&n; *     - rationalise debugging&n; *     - fix detect/autoprobe and module routines&n; *     - test under high load, try to chase CU lockups&n; *     - look at RAM size check&n; *&n; * ToDo:&n; *   Multicast/Promiscuous mode handling&n; *   Put back debug reporting?&n; *   More documentation&n; *   Some worry about whether statistics are reported accurately&n; *&n; */
multiline_comment|/*&n; * The original EtherExpress driver was just about usable, but&n; * suffered from a long startup delay, a hard limit of 16k memory&n; * usage on the card (EtherExpress 16s have either 32k or 64k),&n; * and random locks under load. The last was particularly annoying&n; * and made running eXceed/W preferable to Linux/XFree. After hacking&n; * through the driver for a couple of days, I had fixed most of the&n; * card handling errors, at the expense of turning the code into&n; * a complete jungle, but still hadn&squot;t tracked down the lock-ups.&n; * I had hoped these would be an IP bug, but failed to reproduce them&n; * under other drivers, so decided to start from scratch and rewrite&n; * the driver cleanly. And here it is.&n; *&n; * It&squot;s still not quite there, but self-corrects a lot more problems.&n; * the &squot;CU wedged, resetting...&squot; message shouldn&squot;t happen at all, but&n; * at least we recover. It still locks occasionally, any ideas welcome.&n; *&n; * The original startup delay experienced by some people was due to the&n; * first ARP request for the address of the default router getting lost.&n; * (mostly the reply we were getting back was arriving before our&n; * hardware address was set up, or before the configuration sequence&n; * had told the card NOT to strip of the frame header). If you a long&n; * startup delay, you may have lost this ARP request/reply, although&n; * the original cause has been fixed. However, it is more likely that&n; * you&squot;ve just locked under this version.&n; *&n; * The main changes are in the 586 initialization procedure (which was&n; * just broken before - the EExp is a strange beasty and needs careful&n; * handling) the receive buffer handling (we now use a non-terminating&n; * circular list of buffers, which stops the card giving us out-of-&n; * resources errors), and the transmit code. The driver is also more&n; * structured, and I have tried to keep the kernel interface separate&n; * from the hardware interface (although some routines naturally want&n; * to do both).&n; *&n; * John Sullivan&n; *&n; * 18/5/95:&n; *&n; * The lock-ups seem to happen when you access card memory after a 586&n; * reset. This happens only 1 in 12 resets, on a random basis, and&n; * completely locks the machine. As far as I can see there is no&n; * workaround possible - the only thing to be done is make sure we&n; * never reset the card *after* booting the kernel - once at probe time&n; * must be sufficient, and we&squot;ll just have to put up with that failing&n; * occasionally (or buy a new NIC). By the way, this looks like a &n; * definite card bug, since Intel&squot;s own driver for DOS does exactly the&n; * same.&n; */
multiline_comment|/*&n; * Sources:&n; *&n; * The original eexpress.c by Donald Becker&n; *   Sources: the Crynwr EtherExpress driver source.&n; *            the Intel Microcommunications Databook Vol.1 1990&n; *&n; * wavelan.c and i82586.h&n; *   This was invaluable for the complete &squot;586 configuration details&n; *   and command format.&n; *&n; * The Crynwr sources (again)&n; *   Not as useful as the Wavelan driver, but then I had eexpress.c to&n; *   go off.&n; *&n; * The Intel EtherExpress 16 ethernet card&n; *   Provided the only reason I want to see a working etherexpress driver.&n; *   A lot of fixes came from just observing how the card (mis)behaves when&n; *   you prod it.&n; *&n; */
DECL|variable|version
r_static
r_char
id|version
(braket
)braket
op_assign
l_string|&quot;eexpress.c: v0.07 1/19/94 Donald Becker &lt;becker@super.org&gt;&bslash;n&quot;
l_string|&quot;            v0.10 4th May 1995 John Sullivan &lt;js10039@cam.ac.uk&gt;&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/*&n; * Not actually used yet - may be implemented when the driver has&n; * been debugged!&n; *&n; * Debug Level&t;&t;Driver Status&n; *&t;0&t;&t;Final release&n; *&t;1&t;&t;Beta test&n; *&t;2&n; *&t;3&n; * &t;4&t;&t;Report timeouts &amp; 586 errors (normal debug level)&n; *&t;5&t;&t;Report all major events&n; *&t;6&t;&t;Dump sent/received packet contents&n; *&t;7&t;&t;Report function entry/exit&n; */
DECL|macro|NET_DEBUG
macro_line|#undef NET_DEBUG
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 4
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
DECL|macro|F_DEB
macro_line|#undef F_DEB
macro_line|#include &quot;eth82586.h&quot;
DECL|macro|PRIV
mdefine_line|#define PRIV(x)         ((struct net_local *)(x)-&gt;priv)
DECL|macro|EEXP_IO_EXTENT
mdefine_line|#define EEXP_IO_EXTENT  16
multiline_comment|/*&n; * Private data declarations&n; */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
DECL|member|init_time
r_int
r_int
id|init_time
suffix:semicolon
multiline_comment|/* jiffies when eexp_hw_init586 called */
DECL|member|rx_first
r_int
r_int
id|rx_first
suffix:semicolon
multiline_comment|/* first rx buf, same as RX_BUF_START */
DECL|member|rx_last
r_int
r_int
id|rx_last
suffix:semicolon
multiline_comment|/* last rx buf */
DECL|member|tx_head
r_int
r_int
id|tx_head
suffix:semicolon
multiline_comment|/* next free tx buf */
DECL|member|tx_reap
r_int
r_int
id|tx_reap
suffix:semicolon
multiline_comment|/* first in-use tx buf */
DECL|member|tx_tail
r_int
r_int
id|tx_tail
suffix:semicolon
multiline_comment|/* previous tx buf to tx_head */
DECL|member|tx_link
r_int
r_int
id|tx_link
suffix:semicolon
multiline_comment|/* last known-executing tx buf */
DECL|member|last_tx_restart
r_int
r_int
id|last_tx_restart
suffix:semicolon
multiline_comment|/* set to tx_link when we restart the CU */
DECL|member|started
r_int
r_char
id|started
suffix:semicolon
DECL|member|rx_buf_start
r_int
r_int
id|rx_buf_start
suffix:semicolon
DECL|member|rx_buf_end
r_int
r_int
id|rx_buf_end
suffix:semicolon
DECL|member|num_tx_bufs
r_int
r_int
id|num_tx_bufs
suffix:semicolon
DECL|member|num_rx_bufs
r_int
r_int
id|num_rx_bufs
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|start_code
r_int
r_int
id|start_code
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
multiline_comment|/* SCP: set bus to 16 bits */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* junk */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* address of ISCP (lo,hi) */
l_int|0x0001
comma
multiline_comment|/* ISCP: busy - cleared after reset */
l_int|0x0008
comma
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* offset,address (lo,hi) of SCB */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* SCB: status, commands */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* links to first command block, first receive descriptor */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* CRC error, alignment error counts */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* out of resources, overrun error counts */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* pad */
l_int|0x0000
comma
l_int|0x0000
comma
l_int|0x0000
comma
id|Cmd_Config
comma
multiline_comment|/* startup configure sequence, at 0x0020 */
l_int|0x0032
comma
multiline_comment|/* link to next command */
l_int|0x080c
comma
multiline_comment|/* 12 bytes follow : fifo threshold=8 */
l_int|0x2e40
comma
multiline_comment|/* don&squot;t rx bad frames : SRDY/ARDY =&gt; ext. sync. : preamble len=8&n;&t;                         * take addresses from data buffers : 6 bytes/address */
l_int|0x6000
comma
multiline_comment|/* default backoff method &amp; priority : interframe spacing = 0x60 */
l_int|0xf200
comma
multiline_comment|/* slot time=0x200 : max collision retry = 0xf */
l_int|0x0000
comma
multiline_comment|/* no HDLC : normal CRC : enable broadcast : disable promiscuous/multicast modes */
l_int|0x003c
comma
multiline_comment|/* minimum frame length = 60 octets) */
l_int|0x0000
comma
id|Cmd_INT
op_or
id|Cmd_SetAddr
comma
l_int|0x003e
comma
multiline_comment|/* link to next command */
l_int|0x0000
comma
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* hardware address placed here, 0x0038 */
l_int|0x0000
comma
id|Cmd_END
op_or
id|Cmd_Nop
comma
multiline_comment|/* end of configure sequence */
l_int|0x003e
comma
l_int|0x0000
)brace
suffix:semicolon
DECL|macro|CONF_LINK
mdefine_line|#define CONF_LINK 0x0020
DECL|macro|CONF_HW_ADDR
mdefine_line|#define CONF_HW_ADDR 0x0038
multiline_comment|/* maps irq number to EtherExpress magic value */
DECL|variable|irqrmap
r_static
r_char
id|irqrmap
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|5
comma
l_int|6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Prototypes for Linux interface&n; */
r_extern
r_int
id|express_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eexp_open
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eexp_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|eexp_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|eexp_xmit
(paren
r_struct
id|sk_buff
op_star
id|buf
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_addr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; * Prototypes for hardware access functions&n; */
r_static
r_void
id|eexp_hw_rx
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_tx
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
op_star
id|buf
comma
r_int
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|eexp_hw_probe
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
r_int
id|eexp_hw_readeeprom
c_func
(paren
r_int
r_int
id|ioaddr
comma
r_int
r_char
id|location
)paren
suffix:semicolon
r_static
r_int
r_int
id|eexp_hw_lasttxstat
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_txrestart
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_txinit
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_rxinit
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_rxmap
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|rx_buf
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_init586
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eexp_hw_ASICrst
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; * Linux interface&n; */
multiline_comment|/*&n; * checks for presence of EtherExpress card&n; */
DECL|function|express_probe
r_int
id|express_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
l_int|0x0300
comma
l_int|0x0270
comma
l_int|0x0320
comma
l_int|0x0340
comma
l_int|0
)brace
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_amp
l_int|0xfe00
)paren
r_return
id|eexp_hw_probe
c_func
(paren
id|dev
comma
id|ioaddr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ioaddr
)paren
r_return
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
op_amp
id|ports
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|t
suffix:semicolon
id|t
op_assign
id|inb
c_func
(paren
op_star
id|port
op_plus
id|ID_PORT
)paren
suffix:semicolon
id|sum
op_or_assign
(paren
id|t
op_rshift
l_int|4
)paren
op_lshift
(paren
(paren
id|t
op_amp
l_int|0x03
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sum
op_eq
l_int|0xbaba
op_logical_and
op_logical_neg
id|eexp_hw_probe
c_func
(paren
id|dev
comma
op_star
id|port
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * open and initialize the adapter, ready for use&n; */
DECL|function|eexp_open
r_static
r_int
id|eexp_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#if NET_DEBUG &gt; 6
id|printk
c_func
(paren
l_string|&quot;%s: eexp_open()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|irq
op_logical_or
op_logical_neg
id|irqrmap
(braket
id|irq
)braket
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|irq2dev_map
(braket
id|irq
)braket
op_logical_or
multiline_comment|/* more consistent, surely? */
(paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
op_assign
id|dev
)paren
comma
l_int|0
)paren
op_logical_or
id|request_irq
c_func
(paren
id|irq
comma
op_amp
id|eexp_irq
comma
l_int|0
comma
l_string|&quot;eexpress&quot;
comma
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|request_region
c_func
(paren
id|ioaddr
comma
id|EEXP_IO_EXTENT
comma
l_string|&quot;eexpress&quot;
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|eexp_hw_init586
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * close and disable the interface, leaving&n; * the 586 in reset&n; */
DECL|function|eexp_close
r_static
r_int
id|eexp_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
id|SCB_CUsuspend
op_or
id|SCB_RUsuspend
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|irq
)braket
op_assign
l_int|NULL
suffix:semicolon
id|outb
c_func
(paren
id|i586_RST
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|ioaddr
comma
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return interface stats&n; */
DECL|function|eexp_stats
r_static
r_struct
id|enet_statistics
op_star
id|eexp_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* &n;&t; * Hmmm, this looks a little too easy... The card maintains&n;&t; * some stats in the SCB, and I&squot;m not convinced we&squot;re&n;&t; * incrementing the most sensible statistics when the card&n;&t; * returns an error (esp. slow DMA, out-of-resources)&n;&t; */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; * Called to transmit a packet, or to allow us to right ourselves&n; * if the kernel thinks we&squot;ve died.&n; */
DECL|function|eexp_xmit
r_static
r_int
id|eexp_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|buf
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#if NET_DEBUG &gt; 6
id|printk
c_func
(paren
l_string|&quot;%s: eexp_xmit()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* This will happen, but hopefully not as often as when&n;&t;&t; * tbusy==0. If it happens too much, we probably ought&n;&t;&t; * to think about unwedging ourselves...&n;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|dev-&gt;trans_start
)paren
OG
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;tx_link
op_eq
id|lp-&gt;last_tx_restart
)paren
(brace
r_int
r_int
id|boguscount
op_assign
l_int|200
comma
id|rsst
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Retransmit timed out, status %04x, resetting...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
suffix:semicolon
id|eexp_hw_txinit
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;last_tx_restart
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_link
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SCB_CUstart
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCB_complete
c_func
(paren
id|rsst
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|boguscount
)paren
(brace
id|boguscount
op_assign
l_int|200
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Reset timed out status %04x, retrying...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rsst
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_link
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SCB_CUstart
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
)brace
)brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCB_CUdead
c_func
(paren
id|status
)paren
)paren
(brace
r_int
r_int
id|txstatus
op_assign
id|eexp_hw_lasttxstat
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Transmit timed out, CU not active status %04x %04x, restarting...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
comma
id|txstatus
)paren
suffix:semicolon
id|eexp_hw_txrestart
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|txstatus
op_assign
id|eexp_hw_lasttxstat
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_and
op_logical_neg
id|txstatus
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: CU wedged, status %04x %04x, resetting...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
comma
id|txstatus
)paren
suffix:semicolon
id|eexp_hw_init586
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|lp-&gt;init_time
)paren
OG
l_int|10
)paren
(brace
r_int
r_int
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: i82586 startup timed out, status %04x, resetting...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
id|eexp_hw_init586
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
r_int
r_int
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
r_int
r_int
id|txstatus
op_assign
id|eexp_hw_lasttxstat
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCB_CUdead
c_func
(paren
id|status
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: CU has died! status %04x %04x, attempting to restart...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
comma
id|txstatus
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|eexp_hw_txrestart
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_en
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
)paren
(brace
multiline_comment|/*    printk(&quot;%s: Transmitter busy or access conflict&bslash;n&quot;,dev-&gt;name); */
id|lp-&gt;stats.tx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|length
op_assign
(paren
id|ETH_ZLEN
OL
id|buf-&gt;len
)paren
ques
c_cond
id|buf-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_int
op_star
id|data
op_assign
(paren
r_int
r_int
op_star
)paren
id|buf-&gt;data
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|eexp_hw_tx
c_func
(paren
id|dev
comma
id|data
comma
id|length
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_en
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|buf
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_en
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle an EtherExpress interrupt&n; * If we&squot;ve finished initializing, start the RU and CU up.&n; * If we&squot;ve already started, reap tx buffers, handle any received packets,&n; * check to make sure we&squot;ve not become wedged.&n; */
DECL|function|eexp_irq
r_static
r_void
id|eexp_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_info
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|irq2dev_map
(braket
id|irq
)braket
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
r_int
id|ioaddr
comma
id|status
comma
id|ack_cmd
suffix:semicolon
r_int
r_int
id|old_rp
comma
id|old_wp
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device caught by EExpress&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if NET_DEBUG &gt; 6
id|printk
c_func
(paren
l_string|&quot;%s: interrupt&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* should this be reset on exit? */
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|old_rp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|ack_cmd
op_assign
id|SCB_ack
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_eq
l_int|0
op_logical_and
id|SCB_complete
c_func
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|SCB_CUstat
c_func
(paren
id|status
)paren
op_eq
l_int|2
)paren
r_while
c_loop
(paren
id|SCB_CUstat
c_func
(paren
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_assign
l_int|1
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_link
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|rx_buf_start
comma
id|ioaddr
op_plus
id|SCB_RFA
)paren
suffix:semicolon
id|ack_cmd
op_or_assign
id|SCB_CUstart
op_or
id|SCB_RUstart
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
)paren
(brace
r_int
r_int
id|txstatus
suffix:semicolon
id|txstatus
op_assign
id|eexp_hw_lasttxstat
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCB_rxdframe
c_func
(paren
id|status
)paren
)paren
(brace
id|eexp_hw_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_amp
l_int|2
)paren
op_ne
l_int|0
op_logical_and
id|SCB_RUstat
c_func
(paren
id|status
)paren
op_ne
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: RU stopped status %04x, restarting...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|eexp_hw_rxinit
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|rx_buf_start
comma
id|ioaddr
op_plus
id|SCB_RFA
)paren
suffix:semicolon
id|ack_cmd
op_or_assign
id|SCB_RUstart
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_eq
l_int|1
op_logical_and
id|SCB_RUstat
c_func
(paren
id|status
)paren
op_eq
l_int|4
)paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_or_assign
l_int|2
suffix:semicolon
id|outw
c_func
(paren
id|ack_cmd
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_rp
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_en
op_or
id|irqrmap
(braket
id|irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Hardware access functions&n; */
multiline_comment|/*&n; * Check all the receive buffers, and hand any received packets&n; * to the upper levels. Basic sanity check on each frame&n; * descriptor&n; */
DECL|function|eexp_hw_rx
r_static
r_void
id|eexp_hw_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_int
r_int
id|old_rp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
r_int
r_int
id|rx_block
op_assign
id|lp-&gt;rx_first
suffix:semicolon
r_int
r_int
id|boguscount
op_assign
id|lp-&gt;num_rx_bufs
suffix:semicolon
macro_line|#if NET_DEBUG &gt; 6
id|printk
c_func
(paren
l_string|&quot;%s: eexp_hw_rx()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|outw
c_func
(paren
id|rx_block
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
comma
id|boguscount
op_decrement
)paren
(brace
r_int
r_int
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
r_int
id|rfd_cmd
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
r_int
id|rx_next
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
r_int
id|pbuf
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_int
r_int
id|pkt_len
suffix:semicolon
r_if
c_cond
(paren
id|FD_Done
c_func
(paren
id|status
)paren
)paren
(brace
id|outw
c_func
(paren
id|pbuf
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|pkt_len
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rfd_cmd
op_ne
l_int|0x0000
op_logical_or
id|pbuf
op_ne
id|rx_block
op_plus
l_int|0x16
op_logical_or
(paren
id|pkt_len
op_amp
l_int|0xc000
)paren
op_ne
l_int|0xc000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Rx frame at %04x corrupted, status %04x, cmd %04x, &quot;
l_string|&quot;next %04x, pbuf %04x, len %04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_block
comma
id|status
comma
id|rfd_cmd
comma
id|rx_next
comma
id|pbuf
comma
id|pkt_len
)paren
suffix:semicolon
id|eexp_hw_rxmap
c_func
(paren
id|dev
comma
id|rx_block
)paren
suffix:semicolon
id|boguscount
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|FD_OK
c_func
(paren
id|status
)paren
)paren
(brace
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|FD_CRC
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|FD_Align
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|FD_Resrc
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|FD_DMA
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|FD_Short
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pkt_len
op_and_assign
l_int|0x3fff
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|outw
c_func
(paren
id|pbuf
op_plus
l_int|10
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|insw
c_func
(paren
id|ioaddr
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
(paren
id|pkt_len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
id|outw
c_func
(paren
id|rx_block
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
)brace
id|rx_block
op_assign
id|rx_next
suffix:semicolon
)brace
id|outw
c_func
(paren
id|old_rp
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Hand a packet to the card for transmission&n; * If we get here, we MUST have already checked&n; * to make sure there is room in the transmit&n; * buffer region&n; */
DECL|function|eexp_hw_tx
r_static
r_void
id|eexp_hw_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
op_star
id|buf
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_head
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|Cmd_INT
op_or
id|Cmd_Xmit
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_head
op_plus
l_int|0x08
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_head
op_plus
l_int|0x0e
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_head
op_plus
l_int|0x08
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_or
id|len
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
op_minus
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_head
op_plus
l_int|0x16
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|buf
comma
(paren
id|len
op_plus
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_tail
op_plus
l_int|0x0c
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_head
comma
id|ioaddr
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;tx_tail
op_assign
id|lp-&gt;tx_head
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_head
op_eq
id|TX_BUF_START
op_plus
(paren
(paren
id|lp-&gt;num_tx_bufs
op_minus
l_int|1
)paren
op_star
id|TX_BUF_SIZE
)paren
)paren
id|lp-&gt;tx_head
op_assign
id|TX_BUF_START
suffix:semicolon
r_else
id|lp-&gt;tx_head
op_add_assign
id|TX_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_head
op_ne
id|lp-&gt;tx_reap
)paren
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sanity check the suspected EtherExpress card&n; * Read hardware address, reset card, size memory and&n; * initialize buffer memory pointers. These should&n; * probably be held in dev-&gt;priv, in case someone has 2&n; * differently configured cards in their box (Arghhh!)&n; */
DECL|function|eexp_hw_probe
r_static
r_int
id|eexp_hw_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
)paren
(brace
r_int
r_int
id|hw_addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|chw_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|hw_addr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: EtherExpress at %#x, &quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
id|hw_addr
(braket
l_int|0
)braket
op_assign
id|eexp_hw_readeeprom
c_func
(paren
id|ioaddr
comma
l_int|2
)paren
suffix:semicolon
id|hw_addr
(braket
l_int|1
)braket
op_assign
id|eexp_hw_readeeprom
c_func
(paren
id|ioaddr
comma
l_int|3
)paren
suffix:semicolon
id|hw_addr
(braket
l_int|2
)braket
op_assign
id|eexp_hw_readeeprom
c_func
(paren
id|ioaddr
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw_addr
(braket
l_int|2
)braket
op_ne
l_int|0x00aa
op_logical_or
(paren
(paren
id|hw_addr
(braket
l_int|1
)braket
op_amp
l_int|0xff00
)paren
op_ne
l_int|0x0000
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rejected: invalid address %04x%04x%04x&bslash;n&quot;
comma
id|hw_addr
(braket
l_int|2
)braket
comma
id|hw_addr
(braket
l_int|1
)braket
comma
id|hw_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|chw_addr
(braket
l_int|5
op_minus
id|i
)braket
suffix:semicolon
(brace
r_char
id|irqmap
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_char
op_star
id|ifmap
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_enum
id|iftype
(brace
id|AUI
op_assign
l_int|0
comma
id|BNC
op_assign
l_int|1
comma
id|TP
op_assign
l_int|2
)brace
suffix:semicolon
r_int
r_int
id|setupval
op_assign
id|eexp_hw_readeeprom
c_func
(paren
id|ioaddr
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irqmap
(braket
id|setupval
op_rshift
l_int|13
)braket
suffix:semicolon
id|dev-&gt;if_port
op_assign
op_logical_neg
(paren
id|setupval
op_amp
l_int|0x1000
)paren
ques
c_cond
id|AUI
suffix:colon
id|eexp_hw_readeeprom
c_func
(paren
id|ioaddr
comma
l_int|5
)paren
op_amp
l_int|0x1
ques
c_cond
id|TP
suffix:colon
id|BNC
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRQ %d, Interface %s, &quot;
comma
id|dev-&gt;irq
comma
id|ifmap
(braket
id|dev-&gt;if_port
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
)brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|eexp_hw_ASICrst
c_func
(paren
id|dev
)paren
suffix:semicolon
(brace
r_int
r_int
id|i586mso
op_assign
l_int|0x023e
suffix:semicolon
r_int
r_int
id|old_wp
comma
id|old_rp
comma
id|old_a0
comma
id|old_a1
suffix:semicolon
r_int
r_int
id|a0_0
comma
id|a1_0
comma
id|a0_1
comma
id|a1_1
suffix:semicolon
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|old_rp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_plus
id|i586mso
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|old_a1
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i586mso
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|old_a0
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i586mso
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x55aa
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i586mso
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|a0_0
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_plus
id|i586mso
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x5a5a
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_plus
id|i586mso
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|a1_0
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i586mso
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|a0_1
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i586mso
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x1234
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_plus
id|i586mso
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|a1_1
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a0_0
op_ne
id|a0_1
)paren
op_logical_or
(paren
id|a1_0
op_ne
id|a1_1
)paren
op_logical_or
(paren
id|a1_0
op_ne
l_int|0x5a5a
)paren
op_logical_or
(paren
id|a0_0
op_ne
l_int|0x55aa
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;32k&bslash;n&quot;
)paren
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|rx_buf_end
op_assign
l_int|0x7ff6
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|num_tx_bufs
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;64k&bslash;n&quot;
)paren
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|num_tx_bufs
op_assign
l_int|8
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|rx_buf_start
op_assign
id|TX_BUF_START
op_plus
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|num_tx_bufs
op_star
id|TX_BUF_SIZE
)paren
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|rx_buf_end
op_assign
l_int|0xfff6
suffix:semicolon
)brace
id|outw
c_func
(paren
l_int|0x8000
op_plus
id|i586mso
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_a1
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|i586mso
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_a0
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_rp
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|eexp_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|eexp_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|eexp_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|eexp_stats
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read a word from eeprom location (0-63?)&n; */
DECL|function|eexp_hw_readeeprom
r_static
r_int
r_int
id|eexp_hw_readeeprom
c_func
(paren
r_int
r_int
id|ioaddr
comma
r_int
r_char
id|location
)paren
(brace
r_int
r_int
id|cmd
op_assign
l_int|0x180
op_or
(paren
id|location
op_amp
l_int|0x7f
)paren
suffix:semicolon
r_int
r_int
id|rval
op_assign
l_int|0
comma
id|wval
op_assign
id|EC_CS
op_or
id|i586_RST
suffix:semicolon
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
id|EC_CS
op_or
id|i586_RST
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x100
suffix:semicolon
id|i
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_amp
id|i
)paren
id|wval
op_or_assign
id|EC_Wr
suffix:semicolon
r_else
id|wval
op_and_assign
op_complement
id|EC_Wr
suffix:semicolon
id|outb
c_func
(paren
id|wval
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|outb
c_func
(paren
id|wval
op_or
id|EC_Clk
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|wval
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
id|wval
op_and_assign
op_complement
id|EC_Wr
suffix:semicolon
id|outb
c_func
(paren
id|wval
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x8000
suffix:semicolon
id|i
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|outb
c_func
(paren
id|wval
op_or
id|EC_Clk
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
op_amp
id|EC_Rd
)paren
id|rval
op_or_assign
id|i
suffix:semicolon
id|outb
c_func
(paren
id|wval
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
)brace
id|wval
op_and_assign
op_complement
id|EC_CS
suffix:semicolon
id|outb
c_func
(paren
id|wval
op_or
id|EC_Clk
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|wval
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|eeprom_delay
c_func
(paren
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Reap tx buffers and return last transmit status.&n; * if ==0 then either:&n; *    a) we&squot;re not transmitting anything, so why are we here?&n; *    b) we&squot;ve died.&n; * otherwise, Stat_Busy(return) means we&squot;ve still got some packets&n; * to transmit, Stat_Done(return) means our buffers should be empty&n; * again&n; */
DECL|function|eexp_hw_lasttxstat
r_static
r_int
r_int
id|eexp_hw_lasttxstat
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_rp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
r_int
r_int
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_int
r_int
id|tx_block
op_assign
id|lp-&gt;tx_reap
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_logical_and
id|lp-&gt;tx_head
op_eq
id|lp-&gt;tx_reap
)paren
r_return
l_int|0x0000
suffix:semicolon
r_do
(brace
id|outw
c_func
(paren
id|tx_block
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Stat_Done
c_func
(paren
id|status
)paren
)paren
(brace
id|lp-&gt;tx_link
op_assign
id|tx_block
suffix:semicolon
id|outw
c_func
(paren
id|old_rp
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;last_tx_restart
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;stats.collisions
op_add_assign
id|Stat_NoColl
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Stat_OK
c_func
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|Stat_Abort
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Stat_TNoCar
c_func
(paren
id|status
)paren
op_logical_or
id|Stat_TNoCTS
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Stat_TNoDMA
c_func
(paren
id|status
)paren
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_block
op_eq
id|TX_BUF_START
op_plus
(paren
(paren
id|lp-&gt;num_tx_bufs
op_minus
l_int|1
)paren
op_star
id|TX_BUF_SIZE
)paren
)paren
id|lp-&gt;tx_reap
op_assign
id|tx_block
op_assign
id|TX_BUF_START
suffix:semicolon
r_else
id|lp-&gt;tx_reap
op_assign
id|tx_block
op_add_assign
id|TX_BUF_SIZE
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lp-&gt;tx_reap
op_ne
id|lp-&gt;tx_head
)paren
suffix:semicolon
id|lp-&gt;tx_link
op_assign
id|lp-&gt;tx_tail
op_plus
l_int|0x08
suffix:semicolon
id|outw
c_func
(paren
id|old_rp
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; * This should never happen. It is called when some higher&n; * routine detects the CU has stopped, to try and restart&n; * it from the last packet we knew we were working on,&n; * or the idle loop if we had finished for the time.&n; */
DECL|function|eexp_hw_txrestart
r_static
r_void
id|eexp_hw_txrestart
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;last_tx_restart
op_assign
id|lp-&gt;tx_link
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_link
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SCB_CUstart
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
(brace
r_int
r_int
id|boguscount
op_assign
l_int|50
comma
id|failcount
op_assign
l_int|5
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|boguscount
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|failcount
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: CU start timed out, status %04x, cmd %04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_CMD
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_link
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
id|SCB_CUstart
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
id|boguscount
op_assign
l_int|100
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Failed to restart CU, resetting board...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|eexp_hw_init586
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Writes down the list of transmit buffers into card&n; * memory. Initial separate, repeated transmits link&n; * them into a circular list, such that the CU can&n; * be constantly active, and unlink them as we reap&n; * transmitted packet buffers, so the CU doesn&squot;t loop&n; * and endlessly transmit packets. (Try hacking the driver&n; * to send continuous broadcast messages, say ARP requests&n; * on a subnet with Windows boxes running on Novell and&n; * LAN Workplace with EMM386. Amusing to watch them all die&n; * horribly leaving the Linux boxes up!)&n; */
DECL|function|eexp_hw_txinit
r_static
r_void
id|eexp_hw_txinit
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_int
r_int
id|tx_block
op_assign
id|TX_BUF_START
suffix:semicolon
r_int
r_int
id|curtbuf
suffix:semicolon
r_for
c_loop
(paren
id|curtbuf
op_assign
l_int|0
suffix:semicolon
id|curtbuf
OL
id|lp-&gt;num_tx_bufs
suffix:semicolon
id|curtbuf
op_increment
)paren
(brace
id|outw
c_func
(paren
id|tx_block
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|Cmd_INT
op_or
id|Cmd_Xmit
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|0x08
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|0x0e
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|0x08
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
op_minus
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|tx_block
op_plus
l_int|0x16
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|tx_block
op_add_assign
id|TX_BUF_SIZE
suffix:semicolon
)brace
id|lp-&gt;tx_head
op_assign
id|TX_BUF_START
suffix:semicolon
id|lp-&gt;tx_reap
op_assign
id|TX_BUF_START
suffix:semicolon
id|lp-&gt;tx_tail
op_assign
id|tx_block
op_minus
id|TX_BUF_SIZE
suffix:semicolon
id|lp-&gt;tx_link
op_assign
id|lp-&gt;tx_tail
op_plus
l_int|0x08
suffix:semicolon
id|lp-&gt;rx_buf_start
op_assign
id|tx_block
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
)brace
multiline_comment|/* is this a standard test pattern, or dbecker randomness? */
DECL|variable|rx_words
r_int
r_int
id|rx_words
(braket
)braket
op_assign
(brace
l_int|0xfeed
comma
l_int|0xf00d
comma
l_int|0xf001
comma
l_int|0x0505
comma
l_int|0x2424
comma
l_int|0x6565
comma
l_int|0xdeaf
)brace
suffix:semicolon
multiline_comment|/*&n; * Write the circular list of receive buffer descriptors to&n; * card memory. Note, we no longer mark the end of the list,&n; * so if all the buffers fill up, the 82586 will loop until&n; * we free one. This may sound dodgy, but it works, and&n; * it makes the error detection in the interrupt handler&n; * a lot simpler.&n; */
DECL|function|eexp_hw_rxinit
r_static
r_void
id|eexp_hw_rxinit
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_int
r_int
id|rx_block
op_assign
id|lp-&gt;rx_buf_start
suffix:semicolon
id|lp-&gt;num_rx_bufs
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_first
op_assign
id|rx_block
suffix:semicolon
r_do
(brace
id|lp-&gt;num_rx_bufs
op_increment
suffix:semicolon
id|outw
c_func
(paren
id|rx_block
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_block
op_plus
id|RX_BUF_SIZE
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_block
op_plus
l_int|0x16
comma
id|ioaddr
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|rx_words
comma
r_sizeof
(paren
id|rx_words
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
op_minus
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_block
op_plus
l_int|0x20
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_or
(paren
id|RX_BUF_SIZE
op_minus
l_int|0x20
)paren
comma
id|ioaddr
)paren
suffix:semicolon
id|lp-&gt;rx_last
op_assign
id|rx_block
suffix:semicolon
id|rx_block
op_add_assign
id|RX_BUF_SIZE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rx_block
op_le
id|lp-&gt;rx_buf_end
op_minus
id|RX_BUF_SIZE
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;rx_last
op_plus
l_int|4
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;rx_first
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This really ought not to be necessary now. Repairs a single&n; * damaged receive buffer. If buffer memory is getting bashed&n; * enough to call this, we probably have bigger problems that can&n; * be fixed here.&n; */
DECL|function|eexp_hw_rxmap
r_static
r_void
id|eexp_hw_rxmap
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|rx_buf
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_wp
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_buf
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|rx_buf
op_eq
id|lp-&gt;rx_last
)paren
ques
c_cond
id|lp-&gt;rx_first
suffix:colon
(paren
id|rx_buf
op_plus
id|RX_BUF_SIZE
)paren
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_buf
op_plus
l_int|0x16
comma
id|ioaddr
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|rx_words
comma
r_sizeof
(paren
id|rx_words
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
op_minus
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|rx_buf
op_plus
l_int|0x20
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0000
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x8000
op_or
(paren
id|RX_BUF_SIZE
op_minus
l_int|0x20
)paren
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
id|old_wp
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the 586, fill memory (including calls to&n; * eexp_hw_[(rx)(tx)]init()) unreset, and start&n; * the configuration sequence. We don&squot;t wait for this&n; * to finish, but allow the interrupt handler to start&n; * the CU and RU for us. We can&squot;t start the receive/&n; * transmission system up before we know that the&n; * hardware is configured correctly&n; */
DECL|function|eexp_hw_init586
r_static
r_void
id|eexp_hw_init586
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_assign
l_int|0
suffix:semicolon
id|set_loopback
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|outb
c_func
(paren
id|i586_RST
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
(brace
r_int
r_int
id|wcnt
suffix:semicolon
id|wcnt
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|wcnt
op_add_assign
l_int|2
)paren
op_ne
id|lp-&gt;rx_buf_end
op_plus
l_int|12
)paren
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|lp-&gt;rx_buf_end
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|start_code
comma
r_sizeof
(paren
id|start_code
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CONF_HW_ADDR
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|ioaddr
comma
id|dev-&gt;dev_addr
comma
l_int|3
)paren
suffix:semicolon
id|eexp_hw_txinit
c_func
(paren
id|dev
)paren
suffix:semicolon
id|eexp_hw_rxinit
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
(brace
r_int
r_int
id|rboguscount
op_assign
l_int|50
comma
id|rfailcount
op_assign
l_int|5
suffix:semicolon
r_while
c_loop
(paren
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
comma
id|inw
c_func
(paren
id|ioaddr
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|rboguscount
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: i82586 reset timed out, kicking...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
id|rboguscount
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|rfailcount
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: i82586 not responding, giving up.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
)brace
id|outw
c_func
(paren
id|CONF_LINK
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xf000
op_or
id|SCB_CUstart
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
(brace
r_int
r_int
id|iboguscount
op_assign
l_int|50
comma
id|ifailcount
op_assign
l_int|5
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|iboguscount
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|ifailcount
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: i82586 initialization timed out, status %04x, cmd %04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_STATUS
)paren
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|SCB_CMD
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CONF_LINK
comma
id|ioaddr
op_plus
id|SCB_CBL
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SCB_STATUS
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xf000
op_or
id|SCB_CUstart
comma
id|ioaddr
op_plus
id|SCB_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
id|iboguscount
op_assign
l_int|100
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Failed to initialize i82586, giving up.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
)brace
id|outb
c_func
(paren
id|SIRQ_en
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|clear_loopback
suffix:semicolon
id|lp-&gt;init_time
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Uh? We haven&squot;t started yet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * completely reset the EtherExpress hardware. We will most likely get&n; * an interrupt during this whether we want one or not. It is best,&n; * therefore, to call this while we don&squot;t have a request_irq() on.&n; */
DECL|function|eexp_hw_ASICrst
r_static
r_void
id|eexp_hw_ASICrst
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|wrval
op_assign
l_int|0x0001
comma
id|succount
op_assign
l_int|0
comma
id|boguscount
op_assign
l_int|500
suffix:semicolon
id|outb
c_func
(paren
id|SIRQ_dis
op_or
id|irqrmap
(braket
id|dev-&gt;irq
)braket
comma
id|ioaddr
op_plus
id|SET_IRQ
)paren
suffix:semicolon
id|set_loopback
suffix:semicolon
multiline_comment|/* yet more paranoia - since we&squot;re resetting the ASIC&n;&t;&t;&t;* that controls this function, how can it possibly work?&n;&t;&t;&t;*/
id|PRIV
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|started
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|ASIC_RST
op_or
id|i586_RST
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|succount
OL
l_int|20
)paren
(brace
r_if
c_cond
(paren
id|wrval
op_eq
l_int|0xffff
)paren
id|wrval
op_assign
l_int|0x0001
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|WRITE_PTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|wrval
comma
id|ioaddr
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|READ_PTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wrval
op_increment
op_eq
id|inw
c_func
(paren
id|ioaddr
)paren
)paren
id|succount
op_increment
suffix:semicolon
r_else
(brace
id|succount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boguscount
op_decrement
)paren
(brace
id|boguscount
op_assign
l_int|500
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Having problems resetting EtherExpress ASIC, continuing...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|wrval
op_assign
l_int|0x0001
suffix:semicolon
id|outb
c_func
(paren
id|ASIC_RST
op_or
id|i586_RST
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
)brace
)brace
)brace
id|outb
c_func
(paren
id|i586_RST
comma
id|ioaddr
op_plus
id|EEPROM_Ctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * MODULE stuff&n; */
macro_line|#ifdef MODULE
DECL|macro|EEXP_MAX_CARDS
mdefine_line|#define EEXP_MAX_CARDS     4    /* max number of cards to support */
DECL|macro|NAMELEN
mdefine_line|#define NAMELEN            8    /* max length of dev-&gt;name (inc null) */
DECL|variable|namelist
r_static
r_char
id|namelist
(braket
id|NAMELEN
op_star
id|EEXP_MAX_CARDS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dev_eexp
r_static
r_struct
id|device
id|dev_eexp
(braket
id|EEXP_MAX_CARDS
)braket
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* will allocate dynamically */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|express_probe
)brace
suffix:semicolon
DECL|variable|irq
r_int
id|irq
(braket
id|EEXP_MAX_CARDS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|io
r_int
id|io
(braket
id|EEXP_MAX_CARDS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* Ideally the user would give us io=, irq= for every card.  If any parameters&n; * are specified, we verify and then use them.  If no parameters are given, we&n; * autoprobe for one card only.&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|this_dev
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|this_dev
op_assign
l_int|0
suffix:semicolon
id|this_dev
OL
id|EEXP_MAX_CARDS
suffix:semicolon
id|this_dev
op_increment
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|dev_eexp
(braket
id|this_dev
)braket
suffix:semicolon
id|dev-&gt;name
op_assign
id|namelist
op_plus
(paren
id|NAMELEN
op_star
id|this_dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
(braket
id|this_dev
)braket
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|io
(braket
id|this_dev
)braket
suffix:semicolon
r_if
c_cond
(paren
id|io
(braket
id|this_dev
)braket
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|this_dev
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;eexpress.c: Module autoprobe not recommended, give io=xx.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;eexpress.c: Failed to register card at 0x%x.&bslash;n&quot;
comma
id|io
(braket
id|this_dev
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|found
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|this_dev
suffix:semicolon
r_for
c_loop
(paren
id|this_dev
op_assign
l_int|0
suffix:semicolon
id|this_dev
OL
id|EEXP_MAX_CARDS
suffix:semicolon
id|this_dev
op_increment
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|dev_eexp
(braket
id|this_dev
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|EEXP_IO_EXTENT
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
eof
