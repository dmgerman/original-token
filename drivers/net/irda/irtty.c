multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irtty.c&n; * Version:       1.1&n; * Description:   IrDA line discipline implementation&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Tue Dec  9 21:18:38 1997&n; * Modified at:   Sat Mar 11 07:43:30 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Sources:       slip.c by Laurence Culhane,   &lt;loz@holmes.demon.co.uk&gt;&n; *                          Fred N. van Kempen, &lt;waltje@uwalt.nl.mugnet.org&gt;&n; * &n; *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.&n; *      &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *  &n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irtty.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
DECL|variable|irtty
r_static
id|hashbin_t
op_star
id|irtty
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|irda_ldisc
r_static
r_struct
id|tty_ldisc
id|irda_ldisc
suffix:semicolon
DECL|variable|qos_mtt_bits
r_static
r_int
id|qos_mtt_bits
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* 5 ms or more */
multiline_comment|/* Network device fuction prototypes */
r_static
r_int
id|irtty_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irtty_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irtty_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irtty_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irtty_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|irtty_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Line discipline function prototypes */
r_static
r_int
id|irtty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|irtty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|irtty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_void
op_star
comma
r_int
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|irtty_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|irtty_write_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|irtty_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_const
r_int
r_char
op_star
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* IrDA specific function protoctypes */
r_static
r_int
id|irtty_is_receiving
c_func
(paren
r_struct
id|irtty_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irtty_set_dtr_rts
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|dtr
comma
r_int
id|rts
)paren
suffix:semicolon
r_static
r_int
id|irtty_raw_write
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|irtty_raw_read
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|irtty_set_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_int
id|irtty_change_speed
c_func
(paren
r_struct
id|irda_task
op_star
id|task
)paren
suffix:semicolon
DECL|variable|driver_name
r_char
op_star
id|driver_name
op_assign
l_string|&quot;irtty&quot;
suffix:semicolon
DECL|function|irtty_init
r_int
id|__init
id|irtty_init
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|irtty
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irtty
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IrDA: Can&squot;t allocate irtty hashbin!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Fill in our line protocol discipline, and register it */
id|memset
c_func
(paren
op_amp
id|irda_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|irda_ldisc
)paren
)paren
suffix:semicolon
id|irda_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|irda_ldisc.name
op_assign
l_string|&quot;irda&quot;
suffix:semicolon
id|irda_ldisc.flags
op_assign
l_int|0
suffix:semicolon
id|irda_ldisc.open
op_assign
id|irtty_open
suffix:semicolon
id|irda_ldisc.close
op_assign
id|irtty_close
suffix:semicolon
id|irda_ldisc.read
op_assign
l_int|NULL
suffix:semicolon
id|irda_ldisc.write
op_assign
l_int|NULL
suffix:semicolon
id|irda_ldisc.ioctl
op_assign
(paren
r_int
(paren
op_star
)paren
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
)paren
id|irtty_ioctl
suffix:semicolon
id|irda_ldisc.poll
op_assign
l_int|NULL
suffix:semicolon
id|irda_ldisc.receive_buf
op_assign
id|irtty_receive_buf
suffix:semicolon
id|irda_ldisc.receive_room
op_assign
id|irtty_receive_room
suffix:semicolon
id|irda_ldisc.write_wakeup
op_assign
id|irtty_write_wakeup
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_IRDA
comma
op_amp
id|irda_ldisc
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;IrDA: can&squot;t register line discipline (err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; *  Function irtty_cleanup ( )&n; *&n; *    Called when the irda module is removed. Here we remove all instances&n; *    of the driver, and the master array.&n; */
macro_line|#ifdef MODULE
DECL|function|irtty_cleanup
r_static
r_void
id|irtty_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Unregister tty line-discipline */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_IRDA
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  The TTY should care of deallocating the instances by using the&n;&t; *  callback to irtty_close(), therefore we do give any deallocation&n;&t; *  function to hashbin_destroy().&n;&t; */
id|hashbin_delete
c_func
(paren
id|irtty
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/* &n; *  Function irtty_open(tty)&n; *&n; *    This function is called by the TTY module when the IrDA line&n; *    discipline is called for.  Because we are sure the tty line exists,&n; *    we only have to link it to a free IrDA channel.  &n; */
DECL|function|irtty_open
r_static
r_int
id|irtty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ASSERT
c_func
(paren
id|tty
op_ne
l_int|NULL
comma
r_return
op_minus
id|EEXIST
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* First make sure we&squot;re not already connected. */
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
id|self
op_ne
l_int|NULL
op_logical_and
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate new instance of the driver&n;&t; */
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irtty_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IrDA: Can&squot;t allocate memory for &quot;
l_string|&quot;IrDA control block!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irtty_cb
)paren
)paren
suffix:semicolon
id|self-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|self
suffix:semicolon
multiline_comment|/* Give self a name */
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%s%d&quot;
comma
id|tty-&gt;driver.name
comma
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
op_plus
id|tty-&gt;driver.name_base
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irtty
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|IRTTY_MAGIC
suffix:semicolon
id|self-&gt;mode
op_assign
id|IRDA_IRLAP
suffix:semicolon
multiline_comment|/* &n;&t; *  Initialize QoS capabilities, we fill in all the stuff that&n;&t; *  we support. Be careful not to place any restrictions on values&n;&t; *  that are not device dependent (such as link disconnect time) so&n;&t; *  this parameter can be set by IrLAP (or the user) instead. DB&n;&t; */
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
multiline_comment|/* The only value we must override it the baudrate */
id|self-&gt;qos.baud_rate.bits
op_assign
id|IR_9600
op_or
id|IR_19200
op_or
id|IR_38400
op_or
id|IR_57600
op_or
id|IR_115200
suffix:semicolon
id|self-&gt;qos.min_turn_time.bits
op_assign
id|qos_mtt_bits
suffix:semicolon
id|self-&gt;flags
op_assign
id|IFF_SIR
op_or
id|IFF_PIO
suffix:semicolon
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
multiline_comment|/* Specify how much memory we want */
id|self-&gt;rx_buff.truesize
op_assign
l_int|4000
suffix:semicolon
id|self-&gt;tx_buff.truesize
op_assign
l_int|4000
suffix:semicolon
multiline_comment|/* Allocate memory if needed */
r_if
c_cond
(paren
id|self-&gt;rx_buff.truesize
OG
l_int|0
)paren
(brace
id|self-&gt;rx_buff.head
op_assign
(paren
id|__u8
op_star
)paren
id|kmalloc
c_func
(paren
id|self-&gt;rx_buff.truesize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;rx_buff.head
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|self-&gt;rx_buff.head
comma
l_int|0
comma
id|self-&gt;rx_buff.truesize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;tx_buff.truesize
OG
l_int|0
)paren
(brace
id|self-&gt;tx_buff.head
op_assign
(paren
id|__u8
op_star
)paren
id|kmalloc
c_func
(paren
id|self-&gt;tx_buff.truesize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tx_buff.head
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|self-&gt;rx_buff.head
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self-&gt;tx_buff.head
comma
l_int|0
comma
id|self-&gt;tx_buff.truesize
)paren
suffix:semicolon
)brace
id|self-&gt;rx_buff.in_frame
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|self-&gt;tx_buff.data
op_assign
id|self-&gt;tx_buff.head
suffix:semicolon
id|self-&gt;rx_buff.data
op_assign
id|self-&gt;rx_buff.head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|dev_alloc
c_func
(paren
l_string|&quot;irda%d&quot;
comma
op_amp
id|err
)paren
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), dev_alloc() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|self
suffix:semicolon
id|self-&gt;netdev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Override the network functions we need to use */
id|dev-&gt;init
op_assign
id|irtty_net_init
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|irtty_hard_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|irtty_net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|irtty_net_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|irtty_net_get_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|irtty_net_ioctl
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|register_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), register_netdev() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|MESSAGE
c_func
(paren
l_string|&quot;IrDA: Registered device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *  Function irtty_close (tty)&n; *&n; *    Close down a IrDA channel. This means flushing out any pending queues,&n; *    and then restoring the TTY line discipline to what it was before it got&n; *    hooked to IrDA (which usually is TTY again).  &n; */
DECL|function|irtty_close
r_static
r_void
id|irtty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Stop tty */
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remove netdevice */
r_if
c_cond
(paren
id|self-&gt;netdev
)paren
(brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We are not using any dongle anymore! */
r_if
c_cond
(paren
id|self-&gt;dongle
)paren
id|irda_device_dongle_cleanup
c_func
(paren
id|self-&gt;dongle
)paren
suffix:semicolon
id|self-&gt;dongle
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Remove speed changing task if any */
r_if
c_cond
(paren
id|self-&gt;task
)paren
id|irda_task_delete
c_func
(paren
id|self-&gt;task
)paren
suffix:semicolon
id|self-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|self-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
id|hashbin_remove
c_func
(paren
id|irtty
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tx_buff.head
)paren
id|kfree
c_func
(paren
id|self-&gt;tx_buff.head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;rx_buff.head
)paren
id|kfree
c_func
(paren
id|self-&gt;rx_buff.head
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_stop_receiver (self, stop)&n; *&n; *    &n; *&n; */
DECL|function|irtty_stop_receiver
r_static
r_void
id|irtty_stop_receiver
c_func
(paren
r_struct
id|irtty_cb
op_star
id|self
comma
r_int
id|stop
)paren
(brace
r_struct
id|termios
id|old_termios
suffix:semicolon
r_int
id|cflag
suffix:semicolon
id|old_termios
op_assign
op_star
(paren
id|self-&gt;tty-&gt;termios
)paren
suffix:semicolon
id|cflag
op_assign
id|self-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
r_if
c_cond
(paren
id|stop
)paren
id|cflag
op_and_assign
op_complement
id|CREAD
suffix:semicolon
r_else
id|cflag
op_or_assign
id|CREAD
suffix:semicolon
id|self-&gt;tty-&gt;termios-&gt;c_cflag
op_assign
id|cflag
suffix:semicolon
id|self-&gt;tty-&gt;driver
dot
id|set_termios
c_func
(paren
id|self-&gt;tty
comma
op_amp
id|old_termios
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *  Function irtty_do_change_speed (self, speed)&n; *&n; *    Change the speed of the serial port.&n; */
DECL|function|__irtty_change_speed
r_static
r_void
id|__irtty_change_speed
c_func
(paren
r_struct
id|irtty_cb
op_star
id|self
comma
id|__u32
id|speed
)paren
(brace
r_struct
id|termios
id|old_termios
suffix:semicolon
r_int
id|cflag
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|old_termios
op_assign
op_star
(paren
id|self-&gt;tty-&gt;termios
)paren
suffix:semicolon
id|cflag
op_assign
id|self-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|cflag
op_and_assign
op_complement
id|CBAUD
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Setting speed to %d&bslash;n&quot;
comma
id|speed
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
l_int|1200
suffix:colon
id|cflag
op_or_assign
id|B1200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2400
suffix:colon
id|cflag
op_or_assign
id|B2400
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4800
suffix:colon
id|cflag
op_or_assign
id|B4800
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
id|cflag
op_or_assign
id|B19200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38400
suffix:colon
id|cflag
op_or_assign
id|B38400
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|57600
suffix:colon
id|cflag
op_or_assign
id|B57600
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|115200
suffix:colon
id|cflag
op_or_assign
id|B115200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
r_default
suffix:colon
id|cflag
op_or_assign
id|B9600
suffix:semicolon
r_break
suffix:semicolon
)brace
id|self-&gt;tty-&gt;termios-&gt;c_cflag
op_assign
id|cflag
suffix:semicolon
id|self-&gt;tty-&gt;driver
dot
id|set_termios
c_func
(paren
id|self-&gt;tty
comma
op_amp
id|old_termios
)paren
suffix:semicolon
id|self-&gt;io.speed
op_assign
id|speed
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_change_speed (instance, state, param)&n; *&n; *    State machine for changing speed of the device. We do it this way since&n; *    we cannot use schedule_timeout() when we are in interrupt context&n; */
DECL|function|irtty_change_speed
r_static
r_int
id|irtty_change_speed
c_func
(paren
r_struct
id|irda_task
op_star
id|task
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
id|__u32
id|speed
op_assign
(paren
id|__u32
)paren
id|task-&gt;param
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), &lt;%ld&gt;&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|task-&gt;instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Check if busy */
r_if
c_cond
(paren
id|self-&gt;task
op_logical_and
id|self-&gt;task
op_ne
id|task
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), busy!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|self-&gt;task
op_assign
id|task
suffix:semicolon
r_switch
c_cond
(paren
id|task-&gt;state
)paren
(brace
r_case
id|IRDA_TASK_INIT
suffix:colon
multiline_comment|/* &n;&t;&t; * Make sure all data is sent before changing the speed of the&n;&t;&t; * serial port.&n;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;tty-&gt;driver
dot
id|chars_in_buffer
c_func
(paren
id|self-&gt;tty
)paren
)paren
(brace
multiline_comment|/* Keep state, and try again later */
id|ret
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transmit buffer is now empty, but it may still&n;&t;&t;&t; * take over 13 ms for the FIFO to become empty, so&n;&t;&t;&t; * wait some more to be sure all data is sent&n;&t;&t;&t; */
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_WAIT
)paren
suffix:semicolon
id|ret
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|13
)paren
suffix:semicolon
)brace
r_case
id|IRDA_TASK_WAIT
suffix:colon
r_if
c_cond
(paren
id|self-&gt;dongle
)paren
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_CHILD_INIT
)paren
suffix:semicolon
r_else
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_CHILD_DONE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRDA_TASK_CHILD_INIT
suffix:colon
multiline_comment|/* Go to default speed */
id|__irtty_change_speed
c_func
(paren
id|self
comma
l_int|9600
)paren
suffix:semicolon
multiline_comment|/* Change speed of dongle */
r_if
c_cond
(paren
id|irda_task_execute
c_func
(paren
id|self-&gt;dongle
comma
id|self-&gt;dongle-&gt;issue-&gt;change_speed
comma
l_int|NULL
comma
id|task
comma
(paren
r_void
op_star
)paren
id|speed
)paren
)paren
(brace
multiline_comment|/* Dongle need more time to change its speed */
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_CHILD_WAIT
)paren
suffix:semicolon
multiline_comment|/* Give dongle 1 sec to finish */
id|ret
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Child finished immediately */
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_CHILD_DONE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRDA_TASK_CHILD_WAIT
suffix:colon
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), changing speed of dongle timed out!&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRDA_TASK_CHILD_DONE
suffix:colon
multiline_comment|/* Finally we are ready to change the speed */
id|__irtty_change_speed
c_func
(paren
id|self
comma
id|speed
)paren
suffix:semicolon
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_DONE
)paren
suffix:semicolon
id|self-&gt;task
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), unknown state %d&bslash;n&quot;
comma
id|task-&gt;state
)paren
suffix:semicolon
id|irda_task_next_state
c_func
(paren
id|task
comma
id|IRDA_TASK_DONE
)paren
suffix:semicolon
id|self-&gt;task
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_ioctl (tty, file, cmd, arg)&n; *&n; *     The Swiss army knife of system calls :-)&n; *&n; */
DECL|function|irtty_ioctl
r_static
r_int
id|irtty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_void
op_star
id|file
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
id|dongle_t
op_star
id|dongle
suffix:semicolon
r_struct
id|irtty_info
id|info
suffix:semicolon
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
r_int
id|size
op_assign
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_IOC_READ
)paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_IOC_WRITE
)paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
r_return
id|n_tty_ioctl
c_func
(paren
id|tty
comma
(paren
r_struct
id|file
op_star
)paren
id|file
comma
id|cmd
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRTTY_IOCTDONGLE
suffix:colon
multiline_comment|/* Initialize dongle */
id|dongle
op_assign
id|irda_device_dongle_init
c_func
(paren
id|self-&gt;netdev
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dongle
)paren
r_break
suffix:semicolon
multiline_comment|/* Initialize callbacks */
id|dongle-&gt;set_mode
op_assign
id|irtty_set_mode
suffix:semicolon
id|dongle-&gt;read
op_assign
id|irtty_raw_read
suffix:semicolon
id|dongle-&gt;write
op_assign
id|irtty_raw_write
suffix:semicolon
id|dongle-&gt;set_dtr_rts
op_assign
id|irtty_set_dtr_rts
suffix:semicolon
multiline_comment|/* Bind dongle */
id|self-&gt;dongle
op_assign
id|dongle
suffix:semicolon
multiline_comment|/* Now initialize the dongle!  */
id|dongle-&gt;issue
op_member_access_from_pointer
id|open
c_func
(paren
id|dongle
comma
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
multiline_comment|/* Reset dongle */
id|irda_task_execute
c_func
(paren
id|dongle
comma
id|dongle-&gt;issue-&gt;reset
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRTTY_IOCGET
suffix:colon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irtty_info
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.name
comma
id|self-&gt;netdev-&gt;name
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
r_struct
id|irtty_info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *  Function irtty_receive_buf( tty, cp, count)&n; *&n; *    Handle the &squot;receiver data ready&squot; interrupt.  This function is called&n; *    by the &squot;tty_io&squot; module in the kernel when a block of IrDA data has&n; *    been received, which can now be decapsulated and delivered for&n; *    further processing &n; */
DECL|function|irtty_receive_buf
r_static
r_void
id|irtty_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
op_logical_neg
id|self-&gt;netdev
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), not ready yet!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read the characters out of the buffer */
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
multiline_comment|/* &n;&t;&t; *  Characters received with a parity error, etc?&n;&t;&t; */
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
op_increment
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;Framing or parity error!&bslash;n&quot;
)paren
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|self-&gt;mode
)paren
(brace
r_case
id|IRDA_IRLAP
suffix:colon
multiline_comment|/* Unwrap and destuff one byte */
id|async_unwrap_char
c_func
(paren
id|self-&gt;netdev
comma
op_amp
id|self-&gt;stats
comma
op_amp
id|self-&gt;rx_buff
comma
op_star
id|cp
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRDA_RAW
suffix:colon
multiline_comment|/* What should we do when the buffer is full? */
r_if
c_cond
(paren
id|self-&gt;rx_buff.len
op_eq
id|self-&gt;rx_buff.truesize
)paren
id|self-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_buff.data
(braket
id|self-&gt;rx_buff.len
op_increment
)braket
op_assign
op_star
id|cp
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function irtty_change_speed_complete (task)&n; *&n; *    Called when the change speed operation completes&n; *&n; */
DECL|function|irtty_change_speed_complete
r_static
r_int
id|irtty_change_speed_complete
c_func
(paren
r_struct
id|irda_task
op_star
id|task
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|task-&gt;instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Finished changing speed, so we are not busy any longer */
multiline_comment|/* Signal network layer so it can try to send the frame */
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_hard_xmit (skb, dev)&n; *&n; *    Transmit frame&n; *&n; */
DECL|function|irtty_hard_xmit
r_static
r_int
id|irtty_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
r_int
id|actual
op_assign
l_int|0
suffix:semicolon
id|__u32
id|speed
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Lock transmit buffer */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Check if we need to change the speed */
r_if
c_cond
(paren
(paren
id|speed
op_assign
id|irda_get_speed
c_func
(paren
id|skb
)paren
)paren
op_ne
id|self-&gt;io.speed
)paren
(brace
multiline_comment|/* Check for empty frame */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;len
)paren
(brace
id|irda_task_execute
c_func
(paren
id|self
comma
id|irtty_change_speed
comma
id|irtty_change_speed_complete
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|speed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|self-&gt;new_speed
op_assign
id|speed
suffix:semicolon
)brace
multiline_comment|/* Init tx buffer*/
id|self-&gt;tx_buff.data
op_assign
id|self-&gt;tx_buff.head
suffix:semicolon
multiline_comment|/* Copy skb to tx_buff while wrapping, stuffing and making CRC */
id|self-&gt;tx_buff.len
op_assign
id|async_wrap_skb
c_func
(paren
id|skb
comma
id|self-&gt;tx_buff.data
comma
id|self-&gt;tx_buff.truesize
)paren
suffix:semicolon
id|self-&gt;tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|self-&gt;stats.tx_bytes
op_add_assign
id|self-&gt;tx_buff.len
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tty-&gt;driver.write
)paren
id|actual
op_assign
id|self-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|self-&gt;tty
comma
l_int|0
comma
id|self-&gt;tx_buff.data
comma
id|self-&gt;tx_buff.len
)paren
suffix:semicolon
multiline_comment|/* Hide the part we just transmitted */
id|self-&gt;tx_buff.data
op_add_assign
id|actual
suffix:semicolon
id|self-&gt;tx_buff.len
op_sub_assign
id|actual
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_receive_room (tty)&n; *&n; *    Used by the TTY to find out how much data we can receive at a time&n; * &n;*/
DECL|function|irtty_receive_room
r_static
r_int
id|irtty_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|65536
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/*&n; * Function irtty_write_wakeup (tty)&n; *&n; *    Called by the driver when there&squot;s room for more data.  If we have&n; *    more packets to send, we send them here.&n; *&n; */
DECL|function|irtty_write_wakeup
r_static
r_void
id|irtty_write_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_int
id|actual
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; *  First make sure we&squot;re connected. &n;&t; */
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Finished with frame?  */
r_if
c_cond
(paren
id|self-&gt;tx_buff.len
OG
l_int|0
)paren
(brace
multiline_comment|/* Write data left in transmit buffer */
id|actual
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|self-&gt;tx_buff.data
comma
id|self-&gt;tx_buff.len
)paren
suffix:semicolon
id|self-&gt;tx_buff.data
op_add_assign
id|actual
suffix:semicolon
id|self-&gt;tx_buff.len
op_sub_assign
id|actual
suffix:semicolon
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; *  Now serial buffer is almost free &amp; we can start &n;&t;&t; *  transmission of another packet &n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|5
comma
id|__FUNCTION__
l_string|&quot;(), finished with frame!&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;new_speed
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|5
comma
id|__FUNCTION__
l_string|&quot;(), Changing speed!&bslash;n&quot;
)paren
suffix:semicolon
id|irda_task_execute
c_func
(paren
id|self
comma
id|irtty_change_speed
comma
id|irtty_change_speed_complete
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|self-&gt;new_speed
)paren
suffix:semicolon
id|self-&gt;new_speed
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Tell network layer that we want more frames */
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function irtty_is_receiving (self)&n; *&n; *    Return TRUE is we are currently receiving a frame&n; *&n; */
DECL|function|irtty_is_receiving
r_static
r_int
id|irtty_is_receiving
c_func
(paren
r_struct
id|irtty_cb
op_star
id|self
)paren
(brace
r_return
(paren
id|self-&gt;rx_buff.state
op_ne
id|OUTSIDE_FRAME
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_set_dtr_rts (tty, dtr, rts)&n; *&n; *    This function can be used by dongles etc. to set or reset the status&n; *    of the dtr and rts lines&n; */
DECL|function|irtty_set_dtr_rts
r_static
r_int
id|irtty_set_dtr_rts
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|dtr
comma
r_int
id|rts
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|arg
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|tty
op_assign
id|self-&gt;tty
suffix:semicolon
macro_line|#ifdef TIOCM_OUT2 /* Not defined for ARM */
id|arg
op_assign
id|TIOCM_OUT2
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rts
)paren
id|arg
op_or_assign
id|TIOCM_RTS
suffix:semicolon
r_if
c_cond
(paren
id|dtr
)paren
id|arg
op_or_assign
id|TIOCM_DTR
suffix:semicolon
multiline_comment|/*&n;&t; *  The ioctl() function, or actually set_modem_info() in serial.c&n;&t; *  expects a pointer to the argument in user space. To hack us&n;&t; *  around this, we use the set_fs() function to fool the routines &n;&t; *  that check if they are called from user space. We also need &n;&t; *  to send a pointer to the argument so get_user() gets happy. DB.&n;&t; */
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver
dot
id|ioctl
c_func
(paren
id|tty
comma
l_int|NULL
comma
id|TIOCMSET
comma
(paren
r_int
r_int
)paren
op_amp
id|arg
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), error doing ioctl!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_set_mode (self, status)&n; *&n; *    For the airport dongle, we need support for reading raw characters&n; *    from the IrDA device. This function switches between those modes. &n; *    FALSE is the default mode, and will then treat incoming data as IrDA &n; *    packets.&n; */
DECL|function|irtty_set_mode
r_int
id|irtty_set_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|mode
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), mode=%s&bslash;n&quot;
comma
id|infrared_mode
(braket
id|mode
)braket
)paren
suffix:semicolon
multiline_comment|/* save status for driver */
id|self-&gt;mode
op_assign
id|mode
suffix:semicolon
multiline_comment|/* reset the buffer state */
id|self-&gt;rx_buff.data
op_assign
id|self-&gt;rx_buff.head
suffix:semicolon
id|self-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_raw_read (self, buf, len)&n; *&n; *    Receive incomming data. This function sleeps, so it must only be&n; *    called with a process context. Timeout is currently defined to be&n; *    a multiple of 10 ms.&n; */
DECL|function|irtty_raw_read
r_static
r_int
id|irtty_raw_read
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
r_int
id|count
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#if 0
id|buf
op_assign
id|self-&gt;rx_buff.data
suffix:semicolon
multiline_comment|/* Wait for the requested amount of data to arrive */
r_while
c_loop
(paren
id|len
OL
id|self-&gt;rx_buff.len
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeout
op_decrement
)paren
r_break
suffix:semicolon
)brace
id|count
op_assign
id|self-&gt;rx_buff.len
OL
id|len
ques
c_cond
id|self-&gt;rx_buff.len
suffix:colon
id|len
suffix:semicolon
multiline_comment|/* &n;&t; * Reset the state, this mean that a raw read is sort of a &n;&t; * datagram read, and _not_ a stream style read. Be aware of the&n;&t; * difference. Implementing it the other way will just be painful ;-)&n;&t; */
id|self-&gt;rx_buff.data
op_assign
id|self-&gt;rx_buff.head
suffix:semicolon
id|self-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
macro_line|#endif
multiline_comment|/* Return the amount we were able to get */
r_return
id|count
suffix:semicolon
)brace
DECL|function|irtty_raw_write
r_static
r_int
id|irtty_raw_write
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
r_int
id|actual
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tty-&gt;driver.write
)paren
id|actual
op_assign
id|self-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|self-&gt;tty
comma
l_int|0
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|actual
suffix:semicolon
)brace
DECL|function|irtty_net_init
r_static
r_int
id|irtty_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Set up to be a normal IrDA network device driver */
id|irda_device_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Insert overrides below this line! */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irtty_net_open
r_static
r_int
id|irtty_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Ready to play! */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Make sure we can receive more data */
id|irtty_stop_receiver
c_func
(paren
id|self
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Open new IrLAP layer instance, now that everything should be&n;&t; * initialized properly &n;&t; */
id|self-&gt;irlap
op_assign
id|irlap_open
c_func
(paren
id|dev
comma
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irtty_net_close
r_static
r_int
id|irtty_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t receive more data */
id|irtty_stop_receiver
c_func
(paren
id|self
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* Stop device */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Stop and remove instance of IrLAP */
r_if
c_cond
(paren
id|self-&gt;irlap
)paren
id|irlap_close
c_func
(paren
id|self-&gt;irlap
)paren
suffix:semicolon
id|self-&gt;irlap
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irtty_net_ioctl (dev, rq, cmd)&n; *&n; *    Process IOCTL commands for this device&n; *&n; */
DECL|function|irtty_net_ioctl
r_static
r_int
id|irtty_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|if_irda_req
op_star
id|irq
op_assign
(paren
r_struct
id|if_irda_req
op_star
)paren
id|rq
suffix:semicolon
r_struct
id|irtty_cb
op_star
id|self
suffix:semicolon
id|dongle_t
op_star
id|dongle
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRTTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), %s, (cmd=0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts &amp; save flags */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSBANDWIDTH
suffix:colon
multiline_comment|/* Set bandwidth */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|irda_task_execute
c_func
(paren
id|self
comma
id|irtty_change_speed
comma
l_int|NULL
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|irq-&gt;ifr_baudrate
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSDONGLE
suffix:colon
multiline_comment|/* Set dongle */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Initialize dongle */
id|dongle
op_assign
id|irda_device_dongle_init
c_func
(paren
id|dev
comma
id|irq-&gt;ifr_dongle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dongle
)paren
r_break
suffix:semicolon
id|dongle-&gt;set_mode
op_assign
id|irtty_set_mode
suffix:semicolon
id|dongle-&gt;read
op_assign
id|irtty_raw_read
suffix:semicolon
id|dongle-&gt;write
op_assign
id|irtty_raw_write
suffix:semicolon
id|dongle-&gt;set_dtr_rts
op_assign
id|irtty_set_dtr_rts
suffix:semicolon
id|self-&gt;dongle
op_assign
id|dongle
suffix:semicolon
multiline_comment|/* Now initialize the dongle!  */
id|dongle-&gt;issue
op_member_access_from_pointer
id|open
c_func
(paren
id|dongle
comma
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
multiline_comment|/* Reset dongle */
id|irda_task_execute
c_func
(paren
id|dongle
comma
id|dongle-&gt;issue-&gt;reset
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSMEDIABUSY
suffix:colon
multiline_comment|/* Set media busy */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGRECEIVING
suffix:colon
multiline_comment|/* Check if we are receiving right now */
id|irq-&gt;ifr_receiving
op_assign
id|irtty_is_receiving
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSDTRRTS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|irtty_set_dtr_rts
c_func
(paren
id|dev
comma
id|irq-&gt;ifr_dtr
comma
id|irq-&gt;ifr_rts
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSMODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|irtty_set_mode
c_func
(paren
id|dev
comma
id|irq-&gt;ifr_mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|irtty_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|irtty_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irtty_cb
op_star
id|self
op_assign
(paren
r_struct
id|irtty_cb
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|self-&gt;stats
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IrDA TTY device driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;Minimum Turn Time&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Function init_module (void)&n; *&n; *    Initialize IrTTY module&n; *&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|irtty_init
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function cleanup_module (void)&n; *&n; *    Cleanup IrTTY module&n; *&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|irtty_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
