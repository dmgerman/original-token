multiline_comment|/*********************************************************************&n; *&t;&t;  &n; * Filename:&t;  irport.c&n; * Version:&t;  0.9&n; * Description:   Serial driver for IrDA. &n; * Status:&t;  Experimental.&n; * Author:&t;  Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:&t;  Sun Aug  3 13:49:59 1997&n; * Modified at:   Sat May 23 23:15:20 1998&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Sources:&t;  serial.c by Linus Torvalds &n; * &n; *     Copyright (c) 1997,1998 Dag Brattli &lt;dagb@cs.uit.no&gt;&n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; *     NOTICE:&n; *&n; *     This driver is ment to be a small half duplex serial driver to be&n; *     used for IR-chipsets that has a UART (16550) compatibility mode. If&n; *     your chipset is is UART only, you should probably use IrTTY instead&n; *     since the Linux serial driver is probably more robust and optimized.&n; *&n; *     The functions in this file may be used by FIR drivers, but this&n; *     driver knows nothing about FIR drivers so don&squot;t ever insert such&n; *     code into this file. Instead you should code your FIR driver in a&n; *     separate file, and then call the functions in this file if&n; *     necessary. This is becase it is difficult to use the Linux serial&n; *     driver with a FIR driver becase they must share interrupts etc. Most&n; *     FIR chipsets can function in advanced SIR mode, and you should&n; *     probably use that mode instead of the UART compatibility mode (and&n; *     then just forget about this file)&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irport.h&gt;
DECL|macro|IO_EXTENT
mdefine_line|#define IO_EXTENT 8
multiline_comment|/* static unsigned int io[]  = { 0x3e8, ~0, ~0, ~0 }; */
multiline_comment|/* static unsigned int irq[] = { 11, 0, 0, 0 }; */
r_static
r_void
id|irport_write_wakeup
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
suffix:semicolon
r_static
r_int
id|irport_write
c_func
(paren
r_int
id|iobase
comma
r_int
id|fifo_size
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|irport_receive
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|irport_init
c_func
(paren
r_void
)paren
)paren
(brace
multiline_comment|/* &t;int i; */
multiline_comment|/* &t;for ( i=0; (io[i] &lt; 2000) &amp;&amp; (i &lt; 4); i++) { */
multiline_comment|/* &t;&t;int ioaddr = io[i]; */
multiline_comment|/* &t;&t;if (check_region(ioaddr, IO_EXTENT)) */
multiline_comment|/* &t;&t;&t;continue; */
multiline_comment|/* &t;&t;if (irport_open( i, io[i], io2[i], irq[i], dma[i]) == 0) */
multiline_comment|/* &t;&t;&t;return 0; */
multiline_comment|/* &t;} */
multiline_comment|/* &t;return -ENODEV; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function pc87108_cleanup ()&n; *&n; *    Close all configured chips&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|irport_cleanup
r_static
r_void
id|irport_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* &t;int i; */
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* for ( i=0; i &lt; 4; i++) { */
multiline_comment|/* &t;&t;if ( dev_self[i]) */
multiline_comment|/* &t;&t;&t;irport_close( &amp;(dev_self[i]-&gt;idev)); */
multiline_comment|/* &t;} */
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Function irport_open (void)&n; *&n; *    Start IO port &n; *&n; */
DECL|function|irport_open
r_int
id|irport_open
c_func
(paren
r_int
id|iobase
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), iobase=%#x&bslash;n&quot;
comma
id|iobase
)paren
suffix:semicolon
multiline_comment|/* Initialize UART */
id|outb
c_func
(paren
id|UART_LCR_WLEN8
comma
id|iobase
op_plus
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Reset DLAB */
id|outb
c_func
(paren
(paren
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
op_or
id|UART_MCR_OUT2
)paren
comma
id|iobase
op_plus
id|UART_MCR
)paren
suffix:semicolon
multiline_comment|/* Turn on interrups */
id|outb
c_func
(paren
(paren
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
)paren
comma
id|iobase
op_plus
id|UART_IER
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irport_cleanup ()&n; *&n; *    Stop IO port&n; *&n; */
DECL|function|irport_close
r_void
id|irport_close
c_func
(paren
r_int
id|iobase
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Reset UART */
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UART_MCR
)paren
suffix:semicolon
multiline_comment|/* Turn off interrupts */
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UART_IER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irport_change_speed (idev, speed)&n; *&n; *    Set speed of port to specified baudrate&n; *&n; */
DECL|function|irport_change_speed
r_void
id|irport_change_speed
c_func
(paren
r_int
id|iobase
comma
r_int
id|speed
)paren
(brace
r_int
id|fcr
suffix:semicolon
multiline_comment|/* FIFO control reg */
r_int
id|lcr
suffix:semicolon
multiline_comment|/* Line control reg */
r_int
id|divisor
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Setting speed to: %d&bslash;n&quot;
comma
id|speed
)paren
suffix:semicolon
multiline_comment|/* Turn off interrupts */
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UART_IER
)paren
suffix:semicolon
id|divisor
op_assign
id|SPEED_MAX
op_div
id|speed
suffix:semicolon
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_14
suffix:semicolon
multiline_comment|/* IrDA ports use 8N1 */
id|lcr
op_assign
id|UART_LCR_WLEN8
suffix:semicolon
id|outb
c_func
(paren
id|UART_LCR_DLAB
op_or
id|lcr
comma
id|iobase
op_plus
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Set DLAB */
id|outb
c_func
(paren
id|divisor
op_amp
l_int|0xff
comma
id|iobase
op_plus
id|UART_DLL
)paren
suffix:semicolon
multiline_comment|/* Set speed */
id|outb
c_func
(paren
id|divisor
op_rshift
l_int|8
comma
id|iobase
op_plus
id|UART_DLM
)paren
suffix:semicolon
id|outb
c_func
(paren
id|lcr
comma
id|iobase
op_plus
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Set 8N1&t;*/
id|outb
c_func
(paren
id|fcr
comma
id|iobase
op_plus
id|UART_FCR
)paren
suffix:semicolon
multiline_comment|/* Enable FIFO&squot;s */
multiline_comment|/* Turn on receive interrups */
id|outb
c_func
(paren
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
comma
id|iobase
op_plus
id|UART_IER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irport_write_wakeup (tty)&n; *&n; *    Called by the driver when there&squot;s room for more data.  If we have&n; *    more packets to send, we send them here.&n; *&n; */
DECL|function|irport_write_wakeup
r_static
r_void
id|irport_write_wakeup
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
(brace
r_int
id|actual
op_assign
l_int|0
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Finished with frame?  */
r_if
c_cond
(paren
id|idev-&gt;tx_buff.len
OG
l_int|0
)paren
(brace
multiline_comment|/* Write data left in transmit buffer */
id|actual
op_assign
id|irport_write
c_func
(paren
id|idev-&gt;io.iobase2
comma
id|idev-&gt;io.fifo_size
comma
id|idev-&gt;tx_buff.data
comma
id|idev-&gt;tx_buff.len
)paren
suffix:semicolon
id|idev-&gt;tx_buff.data
op_add_assign
id|actual
suffix:semicolon
id|idev-&gt;tx_buff.len
op_sub_assign
id|actual
suffix:semicolon
)brace
r_else
(brace
id|iobase
op_assign
id|idev-&gt;io.iobase2
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Now serial buffer is almost free &amp; we can start &n;&t;&t; *  transmission of another packet &n;&t;&t; */
id|idev-&gt;netdev.tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock */
id|idev-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Schedule network layer, so we can get some more frames */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
id|outb
c_func
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_14
op_or
id|UART_FCR_CLEAR_RCVR
comma
id|iobase
op_plus
id|UART_FCR
)paren
suffix:semicolon
multiline_comment|/* Enable FIFO&squot;s */
multiline_comment|/* Turn on receive interrupts */
id|outb
c_func
(paren
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
comma
id|iobase
op_plus
id|UART_IER
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irport_write (driver)&n; *&n; *    &n; *&n; */
DECL|function|irport_write
r_static
r_int
id|irport_write
c_func
(paren
r_int
id|iobase
comma
r_int
id|fifo_size
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|actual
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Tx FIFO should be empty! */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|UART_LSR
)paren
op_amp
id|UART_LSR_THRE
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), failed, fifo not empty!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Fill FIFO with current frame */
r_while
c_loop
(paren
(paren
id|fifo_size
op_decrement
OG
l_int|0
)paren
op_logical_and
(paren
id|actual
OL
id|len
)paren
)paren
(brace
multiline_comment|/* Transmit next byte */
id|outb
c_func
(paren
id|buf
(braket
id|actual
)braket
comma
id|iobase
op_plus
id|UART_TX
)paren
suffix:semicolon
id|actual
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), fifo_size %d ; %d sent of %d&bslash;n&quot;
comma
id|fifo_size
comma
id|actual
comma
id|len
)paren
suffix:semicolon
r_return
id|actual
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irport_xmit (void)&n; *&n; *    Transmits the current frame until FIFO is full, then&n; *    waits until the next transmitt interrupt, and continues until the&n; *    frame is transmited.&n; */
DECL|function|irport_hard_xmit
r_int
id|irport_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|irda_device
op_star
id|idev
suffix:semicolon
r_int
id|actual
op_assign
l_int|0
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|5
comma
id|__FUNCTION__
l_string|&quot;(), dev=%p&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|idev
op_assign
(paren
r_struct
id|irda_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase2
suffix:semicolon
multiline_comment|/* Lock transmit buffer */
r_if
c_cond
(paren
id|irda_lock
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_eq
id|FALSE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Init tx buffer */
id|idev-&gt;tx_buff.data
op_assign
id|idev-&gt;tx_buff.head
suffix:semicolon
multiline_comment|/* Copy skb to tx_buff while wrapping, stuffing and making CRC */
id|idev-&gt;tx_buff.len
op_assign
id|async_wrap_skb
c_func
(paren
id|skb
comma
id|idev-&gt;tx_buff.data
comma
id|idev-&gt;tx_buff.truesize
)paren
suffix:semicolon
id|idev-&gt;tx_buff.data
op_add_assign
id|actual
suffix:semicolon
id|idev-&gt;tx_buff.len
op_sub_assign
id|actual
suffix:semicolon
multiline_comment|/* Turn on transmit finished interrupt. Will fire immediately!  */
id|outb
c_func
(paren
id|UART_IER_THRI
comma
id|iobase
op_plus
id|UART_IER
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irport_receive (void)&n; *&n; *    Receive one frame from the infrared port&n; *&n; */
DECL|function|irport_receive
r_static
r_void
id|irport_receive
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
(brace
r_int
id|iobase
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idev
)paren
r_return
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase2
suffix:semicolon
multiline_comment|/*  &n;&t; * Receive all characters in Rx FIFO, unwrap and unstuff them. &n;         * async_unwrap_char will deliver all found frames  &n;&t; */
r_do
(brace
id|async_unwrap_char
c_func
(paren
id|idev
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UART_RX
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t stay here to long */
r_if
c_cond
(paren
id|boguscount
op_increment
OG
l_int|32
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), breaking!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|UART_LSR
)paren
op_amp
id|UART_LSR_DR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irport_interrupt (irq, dev_id, regs)&n; *&n; *    Interrupt handler&n; */
DECL|function|irport_interrupt
r_void
id|irport_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irda_device
op_star
id|idev
op_assign
(paren
r_struct
id|irda_device
op_star
)paren
id|dev_id
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
id|iir
comma
id|lsr
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|__FUNCTION__
l_string|&quot;() irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|idev-&gt;netdev.interrupt
op_assign
l_int|1
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase2
suffix:semicolon
id|iir
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UART_IIR
)paren
op_amp
id|UART_IIR_ID
suffix:semicolon
r_while
c_loop
(paren
id|iir
)paren
(brace
multiline_comment|/* Clear interrupt */
id|lsr
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UART_LSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iir
op_amp
id|UART_IIR_THRI
)paren
op_logical_and
(paren
id|lsr
op_amp
id|UART_LSR_THRE
)paren
)paren
(brace
multiline_comment|/* Transmitter ready for data */
id|irport_write_wakeup
c_func
(paren
id|idev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|iir
op_amp
id|UART_IIR_RDI
)paren
op_logical_and
(paren
id|lsr
op_amp
id|UART_LSR_DR
)paren
)paren
(brace
multiline_comment|/* Receive interrupt */
id|irport_receive
c_func
(paren
id|idev
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure we don&squot;t stay here to long */
r_if
c_cond
(paren
id|boguscount
op_increment
OG
l_int|32
)paren
r_break
suffix:semicolon
id|iir
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UART_IIR
)paren
op_amp
id|UART_IIR_ID
suffix:semicolon
)brace
id|idev-&gt;netdev.interrupt
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/*&n; * Function cleanup_module (void)&n; *&n; *    &n; *&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|irport_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function init_module (void)&n; *&n; *    &n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|irport_init
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|cleanup_module
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
