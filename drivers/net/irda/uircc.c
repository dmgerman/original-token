multiline_comment|/*********************************************************************&n; *                &n; * Filename:      uircc.c&n; * Version:       0.3&n; * Description:   Driver for the Sharp Universal Infrared &n; *                Communications Controller (UIRCC v 1.3)&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sat Dec 26 10:59:03 1998&n; * Modified at:   Tue Aug 24 13:33:57 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998-1999 Dag Brattli, All Rights Reserved.&n; *      &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *  &n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; *     Applicable Models : Tecra 510CDT, 500C Series, 530CDT, 520CDT,&n; *     740CDT, Portege 300CT, 660CDT, Satellite 220C Series, &n; *     Satellite Pro, 440C Series, 470CDT, 460C Series, 480C Series&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#include &lt;net/irda/uircc.h&gt;
macro_line|#include &lt;net/irda/irport.h&gt;
DECL|variable|driver_name
r_static
r_char
op_star
id|driver_name
op_assign
l_string|&quot;uircc&quot;
suffix:semicolon
DECL|macro|CHIP_IO_EXTENT
mdefine_line|#define CHIP_IO_EXTENT 16
DECL|variable|io
r_static
r_int
r_int
id|io
(braket
)braket
op_assign
(brace
l_int|0x300
comma
op_complement
l_int|0
comma
op_complement
l_int|0
comma
op_complement
l_int|0
)brace
suffix:semicolon
DECL|variable|io2
r_static
r_int
r_int
id|io2
(braket
)braket
op_assign
(brace
l_int|0x3e8
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_int
r_int
id|irq
(braket
)braket
op_assign
(brace
l_int|11
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|dma
r_static
r_int
r_int
id|dma
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|dev_self
r_static
r_struct
id|uircc_cb
op_star
id|dev_self
(braket
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* Some prototypes */
r_static
r_int
id|uircc_open
c_func
(paren
r_int
id|i
comma
r_int
r_int
id|iobase
comma
r_int
r_int
id|board_addr
comma
r_int
r_int
id|irq
comma
r_int
r_int
id|dma
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_static
r_int
id|uircc_close
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
r_static
r_int
id|uircc_probe
c_func
(paren
r_int
id|iobase
comma
r_int
id|board_addr
comma
r_int
id|irq
comma
r_int
id|dma
)paren
suffix:semicolon
r_static
r_int
id|uircc_dma_receive
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
suffix:semicolon
r_static
r_int
id|uircc_dma_receive_complete
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_int
id|uircc_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|uircc_dma_write
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|uircc_change_speed
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
id|__u32
id|baud
)paren
suffix:semicolon
r_static
r_void
id|uircc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|uircc_wait_until_sent
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
suffix:semicolon
r_static
r_int
id|uircc_is_receiving
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
suffix:semicolon
r_static
r_int
id|uircc_toshiba_cmd
c_func
(paren
r_int
op_star
id|retval
comma
r_int
id|arg0
comma
r_int
id|arg1
comma
r_int
id|arg2
)paren
suffix:semicolon
r_static
r_int
id|uircc_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|uircc_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|uircc_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; * Function uircc_init ()&n; *&n; *    Initialize chip. Just try to find out how many chips we are dealing with&n; *    and where they are&n; */
DECL|function|uircc_init
r_int
id|__init
id|uircc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|io
(braket
id|i
)braket
OL
l_int|2000
)paren
op_logical_and
(paren
id|i
OL
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
id|io
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|CHIP_IO_EXTENT
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|uircc_open
c_func
(paren
id|i
comma
id|io
(braket
id|i
)braket
comma
id|io2
(braket
id|i
)braket
comma
id|irq
(braket
id|i
)braket
comma
id|dma
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_cleanup ()&n; *&n; *    Close all configured chips&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|uircc_cleanup
r_static
r_void
id|uircc_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev_self
(braket
id|i
)braket
)paren
id|uircc_close
c_func
(paren
op_amp
(paren
id|dev_self
(braket
id|i
)braket
op_member_access_from_pointer
id|idev
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Function uircc_open (iobase, irq)&n; *&n; *    Open driver instance&n; *&n; */
DECL|function|uircc_open
r_static
r_int
id|uircc_open
c_func
(paren
r_int
id|i
comma
r_int
r_int
id|iobase
comma
r_int
r_int
id|iobase2
comma
r_int
r_int
id|irq
comma
r_int
r_int
id|dma
)paren
(brace
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
r_struct
id|irda_device
op_star
id|idev
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uircc_probe
c_func
(paren
id|iobase
comma
id|iobase2
comma
id|irq
comma
id|dma
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate new instance of the driver&n;&t; */
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|uircc_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IrDA: Can&squot;t allocate memory for &quot;
l_string|&quot;IrDA control block!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|uircc_cb
)paren
)paren
suffix:semicolon
multiline_comment|/* Need to store self somewhere */
id|dev_self
(braket
id|i
)braket
op_assign
id|self
suffix:semicolon
id|idev
op_assign
op_amp
id|self-&gt;idev
suffix:semicolon
multiline_comment|/* Initialize IO */
id|idev-&gt;io.iobase
op_assign
id|iobase
suffix:semicolon
id|idev-&gt;io.iobase2
op_assign
id|iobase2
suffix:semicolon
multiline_comment|/* Used by irport */
id|idev-&gt;io.irq
op_assign
id|irq
suffix:semicolon
id|idev-&gt;io.io_ext
op_assign
id|CHIP_IO_EXTENT
suffix:semicolon
id|idev-&gt;io.io_ext2
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Used by irport */
id|idev-&gt;io.dma
op_assign
id|dma
suffix:semicolon
id|idev-&gt;io.fifo_size
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Lock the port that we need */
id|ret
op_assign
id|check_region
c_func
(paren
id|idev-&gt;io.iobase
comma
id|idev-&gt;io.io_ext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), can&squot;t get iobase of 0x%03x&bslash;n&quot;
comma
id|idev-&gt;io.iobase
)paren
suffix:semicolon
multiline_comment|/* uircc_cleanup( self-&gt;idev);  */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|ret
op_assign
id|check_region
c_func
(paren
id|idev-&gt;io.iobase2
comma
id|idev-&gt;io.io_ext2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), can&squot;t get iobase of 0x%03x&bslash;n&quot;
comma
id|idev-&gt;io.iobase2
)paren
suffix:semicolon
multiline_comment|/* uircc_cleanup( self-&gt;idev);  */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|idev-&gt;io.iobase
comma
id|idev-&gt;io.io_ext
comma
id|idev-&gt;name
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|idev-&gt;io.iobase2
comma
id|idev-&gt;io.io_ext2
comma
id|idev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Initialize QoS for this device */
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|idev-&gt;qos
)paren
suffix:semicolon
multiline_comment|/* The only value we must override it the baudrate */
id|idev-&gt;qos.baud_rate.bits
op_assign
id|IR_9600
op_or
id|IR_19200
op_or
id|IR_38400
op_or
id|IR_57600
op_or
id|IR_115200
multiline_comment|/*IR_576000|IR_1152000 |(IR_4000000 &lt;&lt; 8)*/
suffix:semicolon
id|idev-&gt;qos.min_turn_time.bits
op_assign
l_int|0x0f
suffix:semicolon
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|idev-&gt;qos
)paren
suffix:semicolon
id|idev-&gt;flags
op_assign
id|IFF_FIR
op_or
id|IFF_SIR
op_or
id|IFF_DMA
op_or
id|IFF_PIO
suffix:semicolon
multiline_comment|/* Specify which buffer allocation policy we need */
id|idev-&gt;rx_buff.flags
op_assign
id|GFP_KERNEL
op_or
id|GFP_DMA
suffix:semicolon
id|idev-&gt;tx_buff.flags
op_assign
id|GFP_KERNEL
op_or
id|GFP_DMA
suffix:semicolon
multiline_comment|/* Max DMA buffer size needed = (data_size + 6) * (window_size) + 6; */
id|idev-&gt;rx_buff.truesize
op_assign
l_int|4000
suffix:semicolon
id|idev-&gt;tx_buff.truesize
op_assign
l_int|4000
suffix:semicolon
multiline_comment|/* Initialize callbacks */
id|idev-&gt;change_speed
op_assign
id|uircc_change_speed
suffix:semicolon
id|idev-&gt;wait_until_sent
op_assign
id|uircc_wait_until_sent
suffix:semicolon
id|idev-&gt;is_receiving
op_assign
id|uircc_is_receiving
suffix:semicolon
multiline_comment|/* Override the network functions we need to use */
id|idev-&gt;netdev.init
op_assign
id|uircc_net_init
suffix:semicolon
id|idev-&gt;netdev.hard_start_xmit
op_assign
id|uircc_hard_xmit
suffix:semicolon
id|idev-&gt;netdev.open
op_assign
id|uircc_net_open
suffix:semicolon
id|idev-&gt;netdev.stop
op_assign
id|uircc_net_close
suffix:semicolon
id|irport_start
c_func
(paren
id|idev
comma
id|iobase2
)paren
suffix:semicolon
multiline_comment|/* Open the IrDA device */
id|irda_device_open
c_func
(paren
id|idev
comma
id|driver_name
comma
id|self
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_close (idev)&n; *&n; *    Close driver instance&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|uircc_close
r_static
r_int
id|uircc_close
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
(brace
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
id|status
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|uircc_cb
op_star
)paren
id|idev-&gt;priv
suffix:semicolon
multiline_comment|/* Some magic to disable FIR and enable SIR */
id|uircc_toshiba_cmd
c_func
(paren
op_amp
id|status
comma
l_int|0xffff
comma
l_int|0x001b
comma
l_int|0x0000
)paren
suffix:semicolon
multiline_comment|/* Disable modem */
id|outb
c_func
(paren
l_int|0x00
comma
id|iobase
op_plus
id|UIRCC_CR10
)paren
suffix:semicolon
id|irport_stop
c_func
(paren
id|idev
comma
id|idev-&gt;io.iobase2
)paren
suffix:semicolon
multiline_comment|/* Release the PORT that this driver is using */
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Releasing Region %03x&bslash;n&quot;
comma
id|idev-&gt;io.iobase
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|idev-&gt;io.iobase
comma
id|idev-&gt;io.io_ext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idev-&gt;io.iobase2
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Releasing Region %03x&bslash;n&quot;
comma
id|idev-&gt;io.iobase2
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|idev-&gt;io.iobase2
comma
id|idev-&gt;io.io_ext2
)paren
suffix:semicolon
)brace
id|irda_device_close
c_func
(paren
id|idev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Function uircc_probe (iobase, board_addr, irq, dma)&n; *&n; *    Returns non-negative on success.&n; *&n; */
DECL|function|uircc_probe
r_static
r_int
id|uircc_probe
c_func
(paren
r_int
id|iobase
comma
r_int
id|iobase2
comma
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
r_int
id|version
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* read the chip version, should be 0x03 */
id|version
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|version
op_ne
l_int|0x03
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Wrong chip version&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Sharp UIRCC IrDA driver loaded. Version: 0x%02x&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/* Reset chip */
id|outb
c_func
(paren
id|UIRCC_CR0_SYS_RST
comma
id|iobase
op_plus
id|UIRCC_CR0
)paren
suffix:semicolon
multiline_comment|/* Initialize some registers */
id|outb
c_func
(paren
l_int|0x03
comma
id|iobase
op_plus
id|UIRCC_CR15
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UIRCC_CR11
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UIRCC_CR9
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), sr15=%#x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR15
)paren
)paren
suffix:semicolon
multiline_comment|/* Enable DMA single mode */
id|outb
c_func
(paren
id|UIRCC_CR1_RX_DMA
op_or
id|UIRCC_CR1_TX_DMA
op_or
id|UIRCC_CR1_MUST_SET
comma
id|iobase
op_plus
id|UIRCC_CR1
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts */
id|outb
c_func
(paren
l_int|0xff
comma
id|iobase
op_plus
id|UIRCC_CR2
)paren
suffix:semicolon
multiline_comment|/* Set self poll address */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_change_speed (idev, baud)&n; *&n; *    Change the speed of the device&n; *&n; */
DECL|function|uircc_change_speed
r_static
r_void
id|uircc_change_speed
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
id|__u32
id|speed
)paren
(brace
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
id|modem
op_assign
id|UIRCC_CR10_SIR
suffix:semicolon
r_int
id|status
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Just test the high speed stuff */
multiline_comment|/*speed = 4000000;*/
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|idev-&gt;priv
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
multiline_comment|/* Update accounting for new speed */
id|idev-&gt;io.baudrate
op_assign
id|speed
suffix:semicolon
multiline_comment|/* Disable interrupts */
id|outb
c_func
(paren
l_int|0xff
comma
id|iobase
op_plus
id|UIRCC_CR2
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
l_int|9600
suffix:colon
r_case
l_int|19200
suffix:colon
r_case
l_int|37600
suffix:colon
r_case
l_int|57600
suffix:colon
r_case
l_int|115200
suffix:colon
id|irport_start
c_func
(paren
id|idev
comma
id|idev-&gt;io.iobase2
)paren
suffix:semicolon
id|irport_change_speed
c_func
(paren
id|idev
comma
id|speed
)paren
suffix:semicolon
multiline_comment|/* Some magic to disable FIR and enable SIR */
id|uircc_toshiba_cmd
c_func
(paren
op_amp
id|status
comma
l_int|0xffff
comma
l_int|0x001b
comma
l_int|0x0000
)paren
suffix:semicolon
id|modem
op_assign
id|UIRCC_CR10_SIR
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|576000
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), handling baud of 576000&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1152000
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), handling baud of 1152000&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4000000
suffix:colon
id|irport_stop
c_func
(paren
id|idev
comma
id|idev-&gt;io.iobase2
)paren
suffix:semicolon
multiline_comment|/* Some magic to disable SIR and enable FIR */
id|uircc_toshiba_cmd
c_func
(paren
op_amp
id|status
comma
l_int|0xffff
comma
l_int|0x001b
comma
l_int|0x0001
)paren
suffix:semicolon
id|modem
op_assign
id|UIRCC_CR10_FIR
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), handling baud of 4000000&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set self pole address */
singleline_comment|//outb(0xfe, iobase+UIRCC_CR8);
multiline_comment|/* outb(0x10, iobase+UIRCC_CR11); */
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unknown baud rate of %d&bslash;n&quot;
comma
id|speed
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Set appropriate speed mode */
id|outb
c_func
(paren
id|modem
comma
id|iobase
op_plus
id|UIRCC_CR10
)paren
suffix:semicolon
id|idev-&gt;netdev.tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Enable some interrupts so we can receive frames */
r_if
c_cond
(paren
id|speed
OG
l_int|115200
)paren
(brace
multiline_comment|/* Enable DMA single mode */
id|outb
c_func
(paren
id|UIRCC_CR1_RX_DMA
op_or
id|UIRCC_CR1_TX_DMA
op_or
id|UIRCC_CR1_MUST_SET
comma
id|iobase
op_plus
id|UIRCC_CR1
)paren
suffix:semicolon
multiline_comment|/* Enable all interrupts  */
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UIRCC_CR2
)paren
suffix:semicolon
id|uircc_dma_receive
c_func
(paren
id|idev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function uircc_hard_xmit (skb, dev)&n; *&n; *    Transmit the frame!&n; *&n; */
DECL|function|uircc_hard_xmit
r_static
r_int
id|uircc_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irda_device
op_star
id|idev
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
id|mtt
suffix:semicolon
id|idev
op_assign
(paren
r_struct
id|irda_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(%ld), skb-&gt;len=%d&bslash;n&quot;
comma
id|jiffies
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Reset carrier latch */
multiline_comment|/*outb(0x02, iobase+UIRCC_CR0);*/
multiline_comment|/* Use irport for SIR speeds */
r_if
c_cond
(paren
id|idev-&gt;io.baudrate
op_le
l_int|115200
)paren
(brace
r_return
id|irport_hard_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), sr0=%#x, sr1=%#x, sr2=%#x, sr3=%#x, sr10=%#x, sr11=%#x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR0
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR3
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR2
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR3
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR10
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR11
)paren
)paren
suffix:semicolon
multiline_comment|/* Lock transmit buffer */
r_if
c_cond
(paren
id|irda_lock
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_eq
id|FALSE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|memcpy
c_func
(paren
id|idev-&gt;tx_buff.data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Make sure that the length is a multiple of 16 bits */
r_if
c_cond
(paren
id|skb-&gt;len
op_amp
l_int|0x01
)paren
id|skb-&gt;len
op_increment
suffix:semicolon
id|idev-&gt;tx_buff.len
op_assign
id|skb-&gt;len
suffix:semicolon
id|idev-&gt;tx_buff.data
op_assign
id|idev-&gt;tx_buff.head
suffix:semicolon
id|mtt
op_assign
id|irda_get_mtt
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Use udelay for delays less than 50 us. */
r_if
c_cond
(paren
id|mtt
)paren
id|udelay
c_func
(paren
id|mtt
)paren
suffix:semicolon
multiline_comment|/* Enable transmit interrupts */
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UIRCC_CR2
)paren
suffix:semicolon
id|uircc_dma_write
c_func
(paren
id|idev
comma
id|iobase
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_dma_write (idev, iobase)&n; *&n; *    Transmit data using DMA&n; *&n; */
DECL|function|uircc_dma_write
r_static
r_void
id|uircc_dma_write
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
r_int
id|iobase
)paren
(brace
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|idev-&gt;priv
suffix:semicolon
multiline_comment|/* Receiving disable */
id|self-&gt;cr3
op_and_assign
op_complement
id|UIRCC_CR3_RECV_EN
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
multiline_comment|/* Set modem */
id|outb
c_func
(paren
l_int|0x80
comma
id|iobase
op_plus
id|UIRCC_CR10
)paren
suffix:semicolon
multiline_comment|/* Enable transmit DMA */
id|outb
c_func
(paren
id|UIRCC_CR1_TX_DMA
op_or
id|UIRCC_CR1_MUST_SET
comma
id|iobase
op_plus
id|UIRCC_CR1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
(paren
id|__u32
)paren
(paren
id|idev-&gt;tx_buff.data
)paren
)paren
op_amp
l_int|0x01
)paren
op_ne
l_int|0x01
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|setup_dma
c_func
(paren
id|idev-&gt;io.dma
comma
id|idev-&gt;tx_buff.data
comma
id|idev-&gt;tx_buff.len
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|idev-&gt;io.direction
op_assign
id|IO_XMIT
suffix:semicolon
multiline_comment|/* Set frame length (should be the real length without padding */
id|outb
c_func
(paren
id|idev-&gt;tx_buff.len
op_amp
l_int|0xff
comma
id|iobase
op_plus
id|UIRCC_CR4
)paren
suffix:semicolon
multiline_comment|/* Low byte */
id|outb
c_func
(paren
id|idev-&gt;tx_buff.len
op_rshift
l_int|8
comma
id|iobase
op_plus
id|UIRCC_CR5
)paren
suffix:semicolon
multiline_comment|/* High byte */
multiline_comment|/* Enable transmit and transmit CRC */
id|self-&gt;cr3
op_or_assign
(paren
id|UIRCC_CR3_XMIT_EN
op_or
id|UIRCC_CR3_TX_CRC_EN
)paren
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_dma_xmit_complete (idev)&n; *&n; *    The transfer of a frame in finished. This function will only be called &n; *    by the interrupt handler&n; *&n; */
DECL|function|uircc_dma_xmit_complete
r_static
r_void
id|uircc_dma_xmit_complete
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
r_int
id|underrun
)paren
(brace
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
id|len
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|idev-&gt;priv
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
multiline_comment|/* Select TX counter */
id|outb
c_func
(paren
id|UIRCC_CR0_CNT_SWT
comma
id|iobase
op_plus
id|UIRCC_CR0
)paren
suffix:semicolon
multiline_comment|/* Read TX length counter */
id|len
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR4
)paren
suffix:semicolon
multiline_comment|/* Low byte */
id|len
op_or_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR5
)paren
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* High byte */
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), sent %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Disable transmit */
id|self-&gt;cr3
op_and_assign
op_complement
id|UIRCC_CR3_XMIT_EN
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
multiline_comment|/* Transmit reset (just to be sure) */
id|outb
c_func
(paren
id|UIRCC_CR0_XMIT_RST
comma
id|iobase
op_plus
id|UIRCC_CR0
)paren
suffix:semicolon
multiline_comment|/* Check for underrrun! */
r_if
c_cond
(paren
id|underrun
)paren
(brace
id|idev-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|idev-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
id|idev-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|idev-&gt;stats.tx_bytes
op_add_assign
id|idev-&gt;tx_buff.len
suffix:semicolon
)brace
multiline_comment|/* Unlock tx_buff and request another frame */
id|idev-&gt;netdev.tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock */
id|idev-&gt;media_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Tell the network layer, that we can accept more frames */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_dma_receive (idev)&n; *&n; *    Get ready for receiving a frame. The device will initiate a DMA&n; *    if it starts to receive a frame.&n; *&n; */
DECL|function|uircc_dma_receive
r_static
r_int
id|uircc_dma_receive
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
(brace
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|idev-&gt;priv
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
multiline_comment|/* Transmit disable */
multiline_comment|/* self-&gt;cr3 &amp;= ~UIRCC_CR3_XMIT_EN; */
id|self-&gt;cr3
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
multiline_comment|/* Transmit reset (just in case) */
id|outb
c_func
(paren
id|UIRCC_CR0_XMIT_RST
op_or
l_int|0x17
comma
id|iobase
op_plus
id|UIRCC_CR0
)paren
suffix:semicolon
multiline_comment|/* Set modem */
id|outb
c_func
(paren
l_int|0x08
comma
id|iobase
op_plus
id|UIRCC_CR10
)paren
suffix:semicolon
multiline_comment|/* Enable receiving with CRC */
id|self-&gt;cr3
op_assign
(paren
id|UIRCC_CR3_RECV_EN
op_or
id|UIRCC_CR3_RX_CRC_EN
)paren
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
multiline_comment|/* Make sure Rx DMA is set */
id|outb
c_func
(paren
id|UIRCC_CR1_RX_DMA
op_or
id|UIRCC_CR1_MUST_SET
comma
id|iobase
op_plus
id|UIRCC_CR1
)paren
suffix:semicolon
multiline_comment|/* Rx reset */
multiline_comment|/* outb(UIRCC_CR0_RECV_RST, iobase+UIRCC_CR0); */
id|setup_dma
c_func
(paren
id|idev-&gt;io.dma
comma
id|idev-&gt;rx_buff.data
comma
id|idev-&gt;rx_buff.truesize
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
multiline_comment|/* driver-&gt;media_busy = FALSE; */
id|idev-&gt;io.direction
op_assign
id|IO_RECV
suffix:semicolon
id|idev-&gt;rx_buff.data
op_assign
id|idev-&gt;rx_buff.head
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Enable receiving with CRC */
id|self-&gt;cr3
op_assign
(paren
id|UIRCC_CR3_RECV_EN
op_or
id|UIRCC_CR3_RX_CRC_EN
)paren
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
macro_line|#endif
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), cr3=%#x&bslash;n&quot;
comma
id|self-&gt;cr3
)paren
suffix:semicolon
multiline_comment|/* Address check? */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_dma_receive_complete (idev)&n; *&n; *    Finished with receiving frames&n; *&n; *    &n; */
DECL|function|uircc_dma_receive_complete
r_static
r_int
id|uircc_dma_receive_complete
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
r_int
id|iobase
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|uircc_cb
op_star
id|self
suffix:semicolon
r_int
id|len
suffix:semicolon
id|self
op_assign
id|idev-&gt;priv
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for CRC or framing error */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR0
)paren
op_amp
id|UIRCC_SR0_RX_CRCFRM
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), CRC or FRAME error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Select receive length counter */
id|outb
c_func
(paren
l_int|0x00
comma
id|iobase
op_plus
id|UIRCC_CR0
)paren
suffix:semicolon
multiline_comment|/* Read frame length */
id|len
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR4
)paren
suffix:semicolon
multiline_comment|/* Low byte */
id|len
op_or_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR5
)paren
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* High byte */
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), len=%d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Receiving disable */
id|self-&gt;cr3
op_and_assign
op_complement
id|UIRCC_CR3_RECV_EN
suffix:semicolon
id|outb
c_func
(paren
id|self-&gt;cr3
comma
id|iobase
op_plus
id|UIRCC_CR3
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|__FUNCTION__
l_string|&quot;(), memory squeeze, dropping frame.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Restore bank register */
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Make sure IP header gets aligned */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Copy frame without CRC */
multiline_comment|/* if ( idev-&gt;io.baudrate &lt; 4000000) { */
multiline_comment|/* &t;&t;skb_put( skb, len-2); */
multiline_comment|/* &t;&t;memcpy( skb-&gt;data, idev-&gt;rx_buff.head, len-2); */
multiline_comment|/* &t;} else { */
multiline_comment|/* &t;&t;skb_put( skb, len-4); */
multiline_comment|/* &t;&t;memcpy( skb-&gt;data, idev-&gt;rx_buff.head, len-4); */
multiline_comment|/* &t;} */
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|idev-&gt;rx_buff.data
comma
id|len
)paren
suffix:semicolon
id|idev-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|skb-&gt;dev
op_assign
op_amp
id|idev-&gt;netdev
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_interrupt (irq, dev_id, regs)&n; *&n; *    An interrupt from the chip has arrived. Time to do some work&n; *&n; */
DECL|function|uircc_interrupt
r_static
r_void
id|uircc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|__u8
id|sr3
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_struct
id|irda_device
op_star
id|idev
op_assign
(paren
r_struct
id|irda_device
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|idev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d for unknown device.&bslash;n&quot;
comma
id|driver_name
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|idev-&gt;io.baudrate
op_le
l_int|115200
)paren
r_return
id|irport_interrupt
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
multiline_comment|/* Read interrupt status */
id|sr3
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sr3
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;**&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|idev-&gt;netdev.interrupt
op_assign
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), sr3=%#x, sr2=%#x, sr10=%#x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR3
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR2
)paren
comma
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_SR10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check what interrupt this is. The UIRCC will not report two&n;&t; *  different interrupts at the same time!&n;&t; */
r_switch
c_cond
(paren
id|sr3
)paren
(brace
r_case
id|UIRCC_SR3_RX_EOF
suffix:colon
multiline_comment|/* Check for end of frame */
id|uircc_dma_receive_complete
c_func
(paren
id|idev
comma
id|iobase
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UIRCC_SR3_TXUR
suffix:colon
multiline_comment|/* Check for transmit underrun */
id|uircc_dma_xmit_complete
c_func
(paren
id|idev
comma
id|TRUE
)paren
suffix:semicolon
id|uircc_dma_receive
c_func
(paren
id|idev
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|iobase
op_plus
id|UIRCC_CR2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UIRCC_SR3_TX_DONE
suffix:colon
id|uircc_dma_xmit_complete
c_func
(paren
id|idev
comma
id|FALSE
)paren
suffix:semicolon
id|uircc_dma_receive
c_func
(paren
id|idev
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0d
comma
id|iobase
op_plus
id|UIRCC_CR2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UIRCC_SR3_TMR_OUT
suffix:colon
multiline_comment|/* Disable timer */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|UIRCC_CR11
)paren
op_amp
op_complement
id|UIRCC_CR11_TMR_EN
comma
id|iobase
op_plus
id|UIRCC_CR11
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unknown interrupt status=%#x&bslash;n&quot;
comma
id|sr3
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|idev-&gt;netdev.interrupt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_wait_until_sent (idev)&n; *&n; *    This function should put the current thread to sleep until all data &n; *    have been sent, so it is safe to change the speed.&n; */
DECL|function|uircc_wait_until_sent
r_static
r_void
id|uircc_wait_until_sent
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
(brace
multiline_comment|/* Just delay 60 ms */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|6
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_is_receiving (idev)&n; *&n; *    Return TRUE is we are currently receiving a frame&n; *&n; */
DECL|function|uircc_is_receiving
r_static
r_int
id|uircc_is_receiving
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
)paren
(brace
r_int
id|status
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* int iobase; */
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
id|FALSE
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
id|FALSE
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idev-&gt;io.baudrate
OG
l_int|115200
)paren
(brace
)brace
r_else
id|status
op_assign
(paren
id|idev-&gt;rx_buff.state
op_ne
id|OUTSIDE_FRAME
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_net_init (dev)&n; *&n; *    Initialize network device&n; *&n; */
DECL|function|uircc_net_init
r_static
r_int
id|uircc_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup to be a normal IrDA network device driver */
id|irda_device_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Insert overrides below this line! */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_net_open (dev)&n; *&n; *    Start the device&n; *&n; */
DECL|function|uircc_net_open
r_static
r_int
id|uircc_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irda_device
op_star
id|idev
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|idev
op_assign
(paren
r_struct
id|irda_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|idev-&gt;io.irq
comma
id|uircc_interrupt
comma
l_int|0
comma
id|idev-&gt;name
comma
(paren
r_void
op_star
)paren
id|idev
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Always allocate the DMA channel after the IRQ,&n;&t; * and clean up on failure.&n;&t; */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|idev-&gt;io.dma
comma
id|idev-&gt;name
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|idev-&gt;io.irq
comma
id|idev
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Ready to play! */
id|irda_device_net_open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* turn on interrupts */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_net_close (dev)&n; *&n; *    Stop the device&n; *&n; */
DECL|function|uircc_net_close
r_static
r_int
id|uircc_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irda_device
op_star
id|idev
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|idev
op_assign
(paren
r_struct
id|irda_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idev-&gt;magic
op_eq
id|IRDA_DEVICE_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|iobase
op_assign
id|idev-&gt;io.iobase
suffix:semicolon
id|irda_device_net_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|idev-&gt;io.dma
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts */
id|free_irq
c_func
(paren
id|idev-&gt;io.irq
comma
id|idev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|idev-&gt;io.dma
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function uircc_toshiba_cmd (arg0, arg1, arg2)&n; *&n; *    disable FIR: uircc_toshiba_cmd(&amp;status, 0xffff, 0x001b, 0x0000);&n; *    enable  FIR: uircc_toshiba_cmd(&amp;status, 0xffff, 0x001b, 0x0001);&n; *    IRDA status: uircc_toshiba_cmd(&amp;status, 0xfefe, 0x001b, 0x0000);&n; */
DECL|function|uircc_toshiba_cmd
r_static
r_int
id|uircc_toshiba_cmd
c_func
(paren
r_int
op_star
id|retval
comma
r_int
id|arg0
comma
r_int
id|arg1
comma
r_int
id|arg2
)paren
(brace
r_char
id|return_code
op_assign
l_int|0
suffix:semicolon
id|__asm__
r_volatile
(paren
l_string|&quot;inb   $0xb2,%%al; &quot;
l_string|&quot;movb  %%ah,%%al;  &quot;
suffix:colon
multiline_comment|/* Output */
l_string|&quot;=al&quot;
(paren
id|return_code
)paren
comma
l_string|&quot;=ecx&quot;
(paren
op_star
id|retval
)paren
suffix:colon
multiline_comment|/* Input */
l_string|&quot;ax&quot;
(paren
id|arg0
)paren
comma
l_string|&quot;bx&quot;
(paren
id|arg1
)paren
comma
l_string|&quot;cx&quot;
(paren
id|arg2
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return&n;&t; * 0x00 = OK&n;&t; * 0x80 = Function not supported by system&n;&t; * 0x83 = Input data error&n;&t; */
r_return
(paren
r_int
)paren
id|return_code
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/*&n; * Function init_module (void)&n; *&n; *    &n; *&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|uircc_init
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function cleanup_module (void)&n; *&n; *    &n; *&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|uircc_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
