multiline_comment|/*&n; * File Name:&n; *   defxx.c&n; *&n; * Copyright Information:&n; *   Copyright Digital Equipment Corporation 1996.&n; *&n; *   This software may be used and distributed according to the terms of&n; *   the GNU Public License, incorporated herein by reference.&n; *&n; * Abstract:&n; *   A Linux device driver supporting the Digital Equipment Corporation&n; *   FDDI EISA and PCI controller families.  Supported adapters include:&n; *&n; *&t;&t;DEC FDDIcontroller/EISA (DEFEA)&n; *&t;&t;DEC FDDIcontroller/PCI  (DEFPA)&n; *&n; * Maintainers:&n; *   LVS&t;Lawrence V. Stefani&n; *&n; * Contact:&n; *&t; The author may be reached at:&n; *&n; *&t;&t;Inet: stefani@lkg.dec.com&n; *&t;&t;(NOTE! this address no longer works -jgarzik)&n; *&n; *&t;&t;Mail: Digital Equipment Corporation&n; *&t;&t;&t;  550 King Street&n; *&t;&t;&t;  M/S: LKG1-3/M07&n; *&t;&t;&t;  Littleton, MA  01460&n; *&n; * Credits:&n; *   I&squot;d like to thank Patricia Cross for helping me get started with&n; *   Linux, David Davies for a lot of help upgrading and configuring&n; *   my development system and for answering many OS and driver&n; *   development questions, and Alan Cox for recommendations and&n; *   integration help on getting FDDI support into Linux.  LVS&n; *&n; * Driver Architecture:&n; *   The driver architecture is largely based on previous driver work&n; *   for other operating systems.  The upper edge interface and&n; *   functions were largely taken from existing Linux device drivers&n; *   such as David Davies&squot; DE4X5.C driver and Donald Becker&squot;s TULIP.C&n; *   driver.&n; *&n; *   Adapter Probe -&n; *&t;&t;The driver scans for supported EISA adapters by reading the&n; *&t;&t;SLOT ID register for each EISA slot and making a match&n; *&t;&t;against the expected value.&n; *&n; *   Bus-Specific Initialization -&n; *&t;&t;This driver currently supports both EISA and PCI controller&n; *&t;&t;families.  While the custom DMA chip and FDDI logic is similar&n; *&t;&t;or identical, the bus logic is very different.  After&n; *&t;&t;initialization, the&t;only bus-specific differences is in how the&n; *&t;&t;driver enables and disables interrupts.  Other than that, the&n; *&t;&t;run-time critical code behaves the same on both families.&n; *&t;&t;It&squot;s important to note that both adapter families are configured&n; *&t;&t;to I/O map, rather than memory map, the adapter registers.&n; *&n; *   Driver Open/Close -&n; *&t;&t;In the driver open routine, the driver ISR (interrupt service&n; *&t;&t;routine) is registered and the adapter is brought to an&n; *&t;&t;operational state.  In the driver close routine, the opposite&n; *&t;&t;occurs; the driver ISR is deregistered and the adapter is&n; *&t;&t;brought to a safe, but closed state.  Users may use consecutive&n; *&t;&t;commands to bring the adapter up and down as in the following&n; *&t;&t;example:&n; *&t;&t;&t;&t;&t;ifconfig fddi0 up&n; *&t;&t;&t;&t;&t;ifconfig fddi0 down&n; *&t;&t;&t;&t;&t;ifconfig fddi0 up&n; *&n; *   Driver Shutdown -&n; *&t;&t;Apparently, there is no shutdown or halt routine support under&n; *&t;&t;Linux.  This routine would be called during &quot;reboot&quot; or&n; *&t;&t;&quot;shutdown&quot; to allow the driver to place the adapter in a safe&n; *&t;&t;state before a warm reboot occurs.  To be really safe, the user&n; *&t;&t;should close the adapter before shutdown (eg. ifconfig fddi0 down)&n; *&t;&t;to ensure that the adapter DMA engine is taken off-line.  However,&n; *&t;&t;the current driver code anticipates this problem and always issues&n; *&t;&t;a soft reset of the adapter&t;at the beginning of driver initialization.&n; *&t;&t;A future driver enhancement in this area may occur in 2.1.X where&n; *&t;&t;Alan indicated that a shutdown handler may be implemented.&n; *&n; *   Interrupt Service Routine -&n; *&t;&t;The driver supports shared interrupts, so the ISR is registered for&n; *&t;&t;each board with the appropriate flag and the pointer to that board&squot;s&n; *&t;&t;device structure.  This provides the context during interrupt&n; *&t;&t;processing to support shared interrupts and multiple boards.&n; *&n; *&t;&t;Interrupt enabling/disabling can occur at many levels.  At the host&n; *&t;&t;end, you can disable system interrupts, or disable interrupts at the&n; *&t;&t;PIC (on Intel systems).  Across the bus, both EISA and PCI adapters&n; *&t;&t;have a bus-logic chip interrupt enable/disable as well as a DMA&n; *&t;&t;controller interrupt enable/disable.&n; *&n; *&t;&t;The driver currently enables and disables adapter interrupts at the&n; *&t;&t;bus-logic chip and assumes that Linux will take care of clearing or&n; *&t;&t;acknowledging any host-based interrupt chips.&n; *&n; *   Control Functions -&n; *&t;&t;Control functions are those used to support functions such as adding&n; *&t;&t;or deleting multicast addresses, enabling or disabling packet&n; *&t;&t;reception filters, or other custom/proprietary commands.  Presently,&n; *&t;&t;the driver supports the &quot;get statistics&quot;, &quot;set multicast list&quot;, and&n; *&t;&t;&quot;set mac address&quot; functions defined by Linux.  A list of possible&n; *&t;&t;enhancements include:&n; *&n; *&t;&t;&t;&t;- Custom ioctl interface for executing port interface commands&n; *&t;&t;&t;&t;- Custom ioctl interface for adding unicast addresses to&n; *&t;&t;&t;&t;  adapter CAM (to support bridge functions).&n; *&t;&t;&t;&t;- Custom ioctl interface for supporting firmware upgrades.&n; *&n; *   Hardware (port interface) Support Routines -&n; *&t;&t;The driver function names that start with &quot;dfx_hw_&quot; represent&n; *&t;&t;low-level port interface routines that are called frequently.  They&n; *&t;&t;include issuing a DMA or port control command to the adapter,&n; *&t;&t;resetting the adapter, or reading the adapter state.  Since the&n; *&t;&t;driver initialization and run-time code must make calls into the&n; *&t;&t;port interface, these routines were written to be as generic and&n; *&t;&t;usable as possible.&n; *&n; *   Receive Path -&n; *&t;&t;The adapter DMA engine supports a 256 entry receive descriptor block&n; *&t;&t;of which up to 255 entries can be used at any given time.  The&n; *&t;&t;architecture is a standard producer, consumer, completion model in&n; *&t;&t;which the driver &quot;produces&quot; receive buffers to the adapter, the&n; *&t;&t;adapter &quot;consumes&quot; the receive buffers by DMAing incoming packet data,&n; *&t;&t;and the driver &quot;completes&quot; the receive buffers by servicing the&n; *&t;&t;incoming packet, then &quot;produces&quot; a new buffer and starts the cycle&n; *&t;&t;again.  Receive buffers can be fragmented in up to 16 fragments&n; *&t;&t;(descriptor&t;entries).  For simplicity, this driver posts&n; *&t;&t;single-fragment receive buffers of 4608 bytes, then allocates a&n; *&t;&t;sk_buff, copies the data, then reposts the buffer.  To reduce CPU&n; *&t;&t;utilization, a better approach would be to pass up the receive&n; *&t;&t;buffer (no extra copy) then allocate and post a replacement buffer.&n; *&t;&t;This is a performance enhancement that should be looked into at&n; *&t;&t;some point.&n; *&n; *   Transmit Path -&n; *&t;&t;Like the receive path, the adapter DMA engine supports a 256 entry&n; *&t;&t;transmit descriptor block of which up to 255 entries can be used at&n; *&t;&t;any&t;given time.  Transmit buffers can be fragmented&t;in up to 255&n; *&t;&t;fragments (descriptor entries).  This driver always posts one&n; *&t;&t;fragment per transmit packet request.&n; *&n; *&t;&t;The fragment contains the entire packet from FC to end of data.&n; *&t;&t;Before posting the buffer to the adapter, the driver sets a three-byte&n; *&t;&t;packet request header (PRH) which is required by the Motorola MAC chip&n; *&t;&t;used on the adapters.  The PRH tells the MAC the type of token to&n; *&t;&t;receive/send, whether or not to generate and append the CRC, whether&n; *&t;&t;synchronous or asynchronous framing is used, etc.  Since the PRH&n; *&t;&t;definition is not necessarily consistent across all FDDI chipsets,&n; *&t;&t;the driver, rather than the common FDDI packet handler routines,&n; *&t;&t;sets these bytes.&n; *&n; *&t;&t;To reduce the amount of descriptor fetches needed per transmit request,&n; *&t;&t;the driver takes advantage of the fact that there are at least three&n; *&t;&t;bytes available before the skb-&gt;data field on the outgoing transmit&n; *&t;&t;request.  This is guaranteed by having fddi_setup() in net_init.c set&n; *&t;&t;dev-&gt;hard_header_len to 24 bytes.  21 bytes accounts for the largest&n; *&t;&t;header in an 802.2 SNAP frame.  The other 3 bytes are the extra &quot;pad&quot;&n; *&t;&t;bytes which we&squot;ll use to store the PRH.&n; *&n; *&t;&t;There&squot;s a subtle advantage to adding these pad bytes to the&n; *&t;&t;hard_header_len, it ensures that the data portion of the packet for&n; *&t;&t;an 802.2 SNAP frame is longword aligned.  Other FDDI driver&n; *&t;&t;implementations may not need the extra padding and can start copying&n; *&t;&t;or DMAing directly from the FC byte which starts at skb-&gt;data.  Should&n; *&t;&t;another driver implementation need ADDITIONAL padding, the net_init.c&n; *&t;&t;module should be updated and dev-&gt;hard_header_len should be increased.&n; *&t;&t;NOTE: To maintain the alignment on the data portion of the packet,&n; *&t;&t;dev-&gt;hard_header_len should always be evenly divisible by 4 and at&n; *&t;&t;least 24 bytes in size.&n; *&n; * Modification History:&n; *&t;&t;Date&t;&t;Name&t;Description&n; *&t;&t;16-Aug-96&t;LVS&t;&t;Created.&n; *&t;&t;20-Aug-96&t;LVS&t;&t;Updated dfx_probe so that version information&n; *&t;&t;&t;&t;&t;&t;&t;string is only displayed if 1 or more cards are&n; *&t;&t;&t;&t;&t;&t;&t;found.  Changed dfx_rcv_queue_process to copy&n; *&t;&t;&t;&t;&t;&t;&t;3 NULL bytes before FC to ensure that data is&n; *&t;&t;&t;&t;&t;&t;&t;longword aligned in receive buffer.&n; *&t;&t;09-Sep-96&t;LVS&t;&t;Updated dfx_ctl_set_multicast_list to enable&n; *&t;&t;&t;&t;&t;&t;&t;LLC group promiscuous mode if multicast list&n; *&t;&t;&t;&t;&t;&t;&t;is too large.  LLC individual/group promiscuous&n; *&t;&t;&t;&t;&t;&t;&t;mode is now disabled if IFF_PROMISC flag not set.&n; *&t;&t;&t;&t;&t;&t;&t;dfx_xmt_queue_pkt no longer checks for NULL skb&n; *&t;&t;&t;&t;&t;&t;&t;on Alan Cox recommendation.  Added node address&n; *&t;&t;&t;&t;&t;&t;&t;override support.&n; *&t;&t;12-Sep-96&t;LVS&t;&t;Reset current address to factory address during&n; *&t;&t;&t;&t;&t;&t;&t;device open.  Updated transmit path to post a&n; *&t;&t;&t;&t;&t;&t;&t;single fragment which includes PRH-&gt;end of data.&n; *&t;&t;Mar 2000&t;AC&t;&t;Did various cleanups for 2.3.x&n; *&t;&t;Jun 2000&t;jgarzik&t;&t;PCI and resource alloc cleanups&n; *&t;&t;Jul 2000&t;tjeerd&t;&t;Much cleanup and some bug fixes&n; *&t;&t;Sep 2000&t;tjeerd&t;&t;Fix leak on unload, cosmetic code cleanup&n; */
multiline_comment|/* Include files */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/fddidevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;defxx.h&quot;
multiline_comment|/* Version information string - should be updated prior to each new release!!! */
DECL|variable|__devinitdata
r_static
r_char
id|version
(braket
)braket
id|__devinitdata
op_assign
l_string|&quot;defxx.c:v1.05d 2000/09/05  Lawrence V. Stefani and others&bslash;n&quot;
suffix:semicolon
DECL|macro|DYNAMIC_BUFFERS
mdefine_line|#define DYNAMIC_BUFFERS 1
DECL|macro|SKBUFF_RX_COPYBREAK
mdefine_line|#define SKBUFF_RX_COPYBREAK 200
multiline_comment|/*&n; * NEW_SKB_SIZE = PI_RCV_DATA_K_SIZE_MAX+128 to allow 128 byte&n; * alignment for compatibility with old EISA boards.&n; */
DECL|macro|NEW_SKB_SIZE
mdefine_line|#define NEW_SKB_SIZE (PI_RCV_DATA_K_SIZE_MAX+128)
multiline_comment|/* Define module-wide (static) routines */
r_static
r_void
id|dfx_bus_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|dfx_bus_config_check
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_driver_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dfx_adap_init
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dfx_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|dfx_int_pr_halt_id
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|dfx_int_type_0_process
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|dfx_int_common
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|dfx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|dfx_ctl_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|dfx_ctl_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dfx_ctl_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
id|dfx_ctl_update_cam
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_ctl_update_filters
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_hw_dma_cmd_req
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_hw_port_ctrl_req
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
id|PI_UINT32
id|command
comma
id|PI_UINT32
id|data_a
comma
id|PI_UINT32
id|data_b
comma
id|PI_UINT32
op_star
id|host_data
)paren
suffix:semicolon
r_static
r_void
id|dfx_hw_adap_reset
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
id|PI_UINT32
id|type
)paren
suffix:semicolon
r_static
r_int
id|dfx_hw_adap_state_rd
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_hw_dma_uninit
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
id|PI_UINT32
id|type
)paren
suffix:semicolon
r_static
r_void
id|dfx_rcv_init
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|dfx_rcv_queue_process
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|dfx_xmt_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dfx_xmt_done
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|dfx_xmt_flush
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
suffix:semicolon
multiline_comment|/* Define module-wide (static) variables */
DECL|variable|root_dfx_eisa_dev
r_static
r_struct
id|net_device
op_star
id|root_dfx_eisa_dev
suffix:semicolon
"&f;"
multiline_comment|/*&n; * =======================&n; * = dfx_port_write_byte =&n; * = dfx_port_read_byte&t; =&n; * = dfx_port_write_long =&n; * = dfx_port_read_long  =&n; * =======================&n; *   &n; * Overview:&n; *   Routines for reading and writing values from/to adapter&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp     - pointer to board information&n; *   offset - register offset from base I/O address&n; *   data   - for dfx_port_write_byte and dfx_port_write_long, this&n; *&t;&t;&t;  is a value to write.&n; *&t;&t;&t;  for dfx_port_read_byte and dfx_port_read_byte, this&n; *&t;&t;&t;  is a pointer to store the read value.&n; *&n; * Functional Description:&n; *   These routines perform the correct operation to read or write&n; *   the adapter register.&n; *   &n; *   EISA port block base addresses are based on the slot number in which the&n; *   controller is installed.  For example, if the EISA controller is installed&n; *   in slot 4, the port block base address is 0x4000.  If the controller is&n; *   installed in slot 2, the port block base address is 0x2000, and so on.&n; *   This port block can be used to access PDQ, ESIC, and DEFEA on-board&n; *   registers using the register offsets defined in DEFXX.H.&n; *&n; *   PCI port block base addresses are assigned by the PCI BIOS or system&n; *&t; firmware.  There is one 128 byte port block which can be accessed.  It&n; *   allows for I/O mapping of both PDQ and PFI registers using the register&n; *   offsets defined in DEFXX.H.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   bp-&gt;base_addr is a valid base I/O address for this adapter.&n; *   offset is a valid register offset for this adapter.&n; *&n; * Side Effects:&n; *   Rather than produce macros for these functions, these routines&n; *   are defined using &quot;inline&quot; to ensure that the compiler will&n; *   generate inline code and not waste a procedure call and return.&n; *   This provides all the benefits of macros, but with the&n; *   advantage of strict data type checking.&n; */
DECL|function|dfx_port_write_byte
r_static
r_inline
r_void
id|dfx_port_write_byte
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
r_int
id|offset
comma
id|u8
id|data
)paren
(brace
id|u16
id|port
op_assign
id|bp-&gt;base_addr
op_plus
id|offset
suffix:semicolon
id|outb
c_func
(paren
id|data
comma
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|dfx_port_read_byte
r_static
r_inline
r_void
id|dfx_port_read_byte
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
r_int
id|offset
comma
id|u8
op_star
id|data
)paren
(brace
id|u16
id|port
op_assign
id|bp-&gt;base_addr
op_plus
id|offset
suffix:semicolon
op_star
id|data
op_assign
id|inb
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|dfx_port_write_long
r_static
r_inline
r_void
id|dfx_port_write_long
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
r_int
id|offset
comma
id|u32
id|data
)paren
(brace
id|u16
id|port
op_assign
id|bp-&gt;base_addr
op_plus
id|offset
suffix:semicolon
id|outl
c_func
(paren
id|data
comma
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|dfx_port_read_long
r_static
r_inline
r_void
id|dfx_port_read_long
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
r_int
id|offset
comma
id|u32
op_star
id|data
)paren
(brace
id|u16
id|port
op_assign
id|bp-&gt;base_addr
op_plus
id|offset
suffix:semicolon
op_star
id|data
op_assign
id|inl
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =============&n; * = dfx_init_one_pci_or_eisa =&n; * =============&n; *   &n; * Overview:&n; *   Initializes a supported FDDI EISA or PCI controller&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   pdev - pointer to pci device information (NULL for EISA)&n; *&n; * Functional Description:&n; *&n; * Return Codes:&n; *   0&t;&t; - This device (fddi0, fddi1, etc) configured successfully&n; *   -EBUSY      - Failed to get resources, or dfx_driver_init failed.&n; *&n; * Assumptions:&n; *   It compiles so it should work :-( (PCI cards do :-)&n; *&n; * Side Effects:&n; *   Device structures for FDDI adapters (fddi0, fddi1, etc) are&n; *   initialized and the board resources are read and stored in&n; *   the device structure.&n; */
DECL|function|dfx_init_one_pci_or_eisa
r_static
r_int
id|__devinit
id|dfx_init_one_pci_or_eisa
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|DFX_board_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* board pointer */
r_static
r_int
id|version_disp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|version_disp
)paren
multiline_comment|/* display version info if adapter is found */
(brace
id|version_disp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set display flag to TRUE so that */
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* we only display this string ONCE */
)brace
multiline_comment|/*&n;&t; * init_fddidev() allocates a device structure with private data, clears the device structure and private data,&n;&t; * and  calls fddi_setup() and register_netdev(). Not much left to do for us here.&n;&t; */
id|dev
op_assign
id|init_fddidev
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
op_star
id|bp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;defxx: unable to allocate fddidev, aborting&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
(paren
id|ioaddr
comma
id|pdev
ques
c_cond
id|PFI_K_CSR_IO_LEN
suffix:colon
id|PI_ESIC_K_CSR_IO_LEN
comma
id|dev-&gt;name
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot reserve I/O resource 0x%x @ 0x%lx, aborting&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|PFI_K_CSR_IO_LEN
comma
id|ioaddr
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Initialize new device structure */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* save port (I/O) base address */
id|dev-&gt;get_stats
op_assign
id|dfx_ctl_get_stats
suffix:semicolon
id|dev-&gt;open
op_assign
id|dfx_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|dfx_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|dfx_xmt_queue_pkt
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|dfx_ctl_set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|dfx_ctl_set_mac_address
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* EISA board */
id|bp-&gt;bus_type
op_assign
id|DFX_BUS_TYPE_EISA
suffix:semicolon
id|bp-&gt;next
op_assign
id|root_dfx_eisa_dev
suffix:semicolon
id|root_dfx_eisa_dev
op_assign
id|dev
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PCI board */
id|bp-&gt;bus_type
op_assign
id|DFX_BUS_TYPE_PCI
suffix:semicolon
id|bp-&gt;pci_dev
op_assign
id|pdev
suffix:semicolon
id|pdev-&gt;driver_data
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|pdev
)paren
)paren
r_goto
id|err_out_region
suffix:semicolon
id|pci_set_master
(paren
id|pdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dfx_driver_init
c_func
(paren
id|dev
)paren
op_ne
id|DFX_K_SUCCESS
)paren
r_goto
id|err_out_region
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out_region
suffix:colon
id|release_region
c_func
(paren
id|ioaddr
comma
id|pdev
ques
c_cond
id|PFI_K_CSR_IO_LEN
suffix:colon
id|PI_ESIC_K_CSR_IO_LEN
)paren
suffix:semicolon
id|err_out
suffix:colon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|dfx_init_one
r_static
r_int
id|__devinit
id|dfx_init_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_return
id|dfx_init_one_pci_or_eisa
c_func
(paren
id|pdev
comma
id|pci_resource_start
(paren
id|pdev
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
DECL|function|dfx_eisa_init
r_static
r_int
id|__init
id|dfx_eisa_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|NODEV
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* used in for loops */
id|u16
id|port
suffix:semicolon
multiline_comment|/* temporary I/O (port) address */
id|u32
id|slot_id
suffix:semicolon
multiline_comment|/* EISA hardware (slot) ID read from adapter */
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_eisa_init...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Scan for FDDI EISA controllers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DFX_MAX_EISA_SLOTS
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* only scan for up to 16 EISA slots */
(brace
id|port
op_assign
(paren
id|i
op_lshift
l_int|12
)paren
op_plus
id|PI_ESIC_K_SLOT_ID
suffix:semicolon
multiline_comment|/* port = I/O address for reading slot ID */
id|slot_id
op_assign
id|inl
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* read EISA HW (slot) ID */
r_if
c_cond
(paren
(paren
id|slot_id
op_amp
l_int|0xF0FFFFFF
)paren
op_eq
id|DEFEA_PRODUCT_ID
)paren
(brace
id|port
op_assign
(paren
id|i
op_lshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* recalc base addr */
r_if
c_cond
(paren
id|dfx_init_one_pci_or_eisa
c_func
(paren
l_int|NULL
comma
id|port
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ================&n; * = dfx_bus_init =&n; * ================&n; *   &n; * Overview:&n; *   Initializes EISA and PCI controller bus-specific logic.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   Determine and save adapter IRQ in device table,&n; *   then perform bus-specific logic initialization.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   dev-&gt;base_addr has already been set with the proper&n; *&t; base I/O address for this device.&n; *&n; * Side Effects:&n; *   Interrupts are enabled at the adapter bus-specific logic.&n; *   Note:  Interrupts at the DMA engine (PDQ chip) are not&n; *   enabled yet.&n; */
DECL|function|dfx_bus_init
r_static
r_void
id|__devinit
id|dfx_bus_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u8
id|val
suffix:semicolon
multiline_comment|/* used for I/O read/writes */
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_bus_init...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize base I/O address field in bp structure&n;&t; *&n;&t; * Note: bp-&gt;base_addr is the same as dev-&gt;base_addr.&n;&t; *&t;&t; It&squot;s useful because often we&squot;ll need to read&n;&t; *&t;&t; or write registers where we already have the&n;&t; *&t;&t; bp pointer instead of the dev pointer.  Having&n;&t; *&t;&t; the base address in the bp structure will&n;&t; *&t;&t; save a pointer dereference.&n;&t; *&n;&t; *&t;&t; IMPORTANT!! This field must be defined before&n;&t; *&t;&t; any of the dfx_port_* inline functions are&n;&t; *&t;&t; called.&n;&t; */
id|bp-&gt;base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* And a pointer back to the net_device struct */
id|bp-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Initialize adapter based on bus type */
r_if
c_cond
(paren
id|bp-&gt;bus_type
op_eq
id|DFX_BUS_TYPE_EISA
)paren
(brace
multiline_comment|/* Get the interrupt level from the ESIC chip */
id|dfx_port_read_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
op_amp
id|val
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|val
op_amp
id|PI_CONFIG_STAT_0_M_IRQ
)paren
op_rshift
id|PI_CONFIG_STAT_0_V_IRQ
)paren
(brace
r_case
id|PI_CONFIG_STAT_0_IRQ_K_9
suffix:colon
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_CONFIG_STAT_0_IRQ_K_10
suffix:colon
id|dev-&gt;irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_CONFIG_STAT_0_IRQ_K_11
suffix:colon
id|dev-&gt;irq
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_CONFIG_STAT_0_IRQ_K_15
suffix:colon
id|dev-&gt;irq
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Enable access to I/O on the board by writing 0x03 to Function Control Register */
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_FUNCTION_CNTRL
comma
id|PI_ESIC_K_FUNCTION_CNTRL_IO_ENB
)paren
suffix:semicolon
multiline_comment|/* Set the I/O decode range of the board */
id|val
op_assign
(paren
(paren
id|dev-&gt;base_addr
op_rshift
l_int|12
)paren
op_lshift
id|PI_IO_CMP_V_SLOT
)paren
suffix:semicolon
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CMP_0_1
comma
id|val
)paren
suffix:semicolon
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CMP_1_1
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* Enable access to rest of module (including PDQ and packet memory) */
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_SLOT_CNTRL
comma
id|PI_SLOT_CNTRL_M_ENB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Map PDQ registers into I/O space.  This is done by clearing a bit&n;&t;&t; * in Burst Holdoff register.&n;&t;&t; */
id|dfx_port_read_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_BURST_HOLDOFF
comma
op_amp
id|val
)paren
suffix:semicolon
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_BURST_HOLDOFF
comma
(paren
id|val
op_amp
op_complement
id|PI_BURST_HOLDOFF_M_MEM_MAP
)paren
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts at EISA bus interface chip (ESIC) */
id|dfx_port_read_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
op_amp
id|val
)paren
suffix:semicolon
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
(paren
id|val
op_or
id|PI_CONFIG_STAT_0_M_INT_ENB
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|bp-&gt;pci_dev
suffix:semicolon
multiline_comment|/* Get the interrupt level from the PCI Configuration Table */
id|dev-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
multiline_comment|/* Check Latency Timer and set if less than minimal */
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
id|PFI_K_LAT_TIMER_MIN
)paren
multiline_comment|/* if less than min, override with default */
(brace
id|val
op_assign
id|PFI_K_LAT_TIMER_DEF
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable interrupts at PCI bus interface chip (PFI) */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PFI_K_REG_MODE_CTRL
comma
(paren
id|PFI_MODE_M_PDQ_INT_ENB
op_or
id|PFI_MODE_M_DMA_ENB
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ========================&n; * = dfx_bus_config_check =&n; * ========================&n; *   &n; * Overview:&n; *   Checks the configuration (burst size, full-duplex, etc.)  If any parameters&n; *   are illegal, then this routine will set new defaults.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   For Revision 1 FDDI EISA, Revision 2 or later FDDI EISA with rev E or later&n; *   PDQ, and all FDDI PCI controllers, all values are legal.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   dfx_adap_init has NOT been called yet so burst size and other items have&n; *   not been set.&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_bus_config_check
r_static
r_void
id|__devinit
id|dfx_bus_config_check
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* return code from adapter port control call */
id|u32
id|slot_id
suffix:semicolon
multiline_comment|/* EISA-bus hardware id (DEC3001, DEC3002,...) */
id|u32
id|host_data
suffix:semicolon
multiline_comment|/* LW data returned from port control call */
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_bus_config_check...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Configuration check only valid for EISA adapter */
r_if
c_cond
(paren
id|bp-&gt;bus_type
op_eq
id|DFX_BUS_TYPE_EISA
)paren
(brace
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_ESIC_K_SLOT_ID
comma
op_amp
id|slot_id
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * First check if revision 2 EISA controller.  Rev. 1 cards used&n;&t;&t; * PDQ revision B, so no workaround needed in this case.  Rev. 3&n;&t;&t; * cards used PDQ revision E, so no workaround needed in this&n;&t;&t; * case, either.  Only Rev. 2 cards used either Rev. D or E&n;&t;&t; * chips, so we must verify the chip revision on Rev. 2 cards.&n;&t;&t; */
r_if
c_cond
(paren
id|slot_id
op_eq
id|DEFEA_PROD_ID_2
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Revision 2 FDDI EISA controller found, so let&squot;s check PDQ&n;&t;&t;&t; * revision of adapter.&n;&t;&t;&t; */
id|status
op_assign
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_SUB_CMD
comma
id|PI_SUB_CMD_K_PDQ_REV_GET
comma
l_int|0
comma
op_amp
id|host_data
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_ne
id|DFX_K_SUCCESS
)paren
op_logical_or
(paren
id|host_data
op_eq
l_int|2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Either we couldn&squot;t determine the PDQ revision, or&n;&t;&t;&t;&t; * we determined that it is at revision D.  In either case,&n;&t;&t;&t;&t; * we need to implement the workaround.&n;&t;&t;&t;&t; */
multiline_comment|/* Ensure that the burst size is set to 8 longwords or less */
r_switch
c_cond
(paren
id|bp-&gt;burst_size
)paren
(brace
r_case
id|PI_PDATA_B_DMA_BURST_SIZE_32
suffix:colon
r_case
id|PI_PDATA_B_DMA_BURST_SIZE_16
suffix:colon
id|bp-&gt;burst_size
op_assign
id|PI_PDATA_B_DMA_BURST_SIZE_8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Ensure that full-duplex mode is not enabled */
id|bp-&gt;full_duplex_enb
op_assign
id|PI_SNMP_K_FALSE
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ===================&n; * = dfx_driver_init =&n; * ===================&n; *   &n; * Overview:&n; *   Initializes remaining adapter board structure information&n; *   and makes sure adapter is in a safe state prior to dfx_open().&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This function allocates additional resources such as the host memory&n; *   blocks needed by the adapter (eg. descriptor and consumer blocks).&n; *&t; Remaining bus initialization steps are also completed.  The adapter&n; *   is also reset so that it is in the DMA_UNAVAILABLE state.  The OS&n; *   must call dfx_open() to open the adapter and bring it on-line.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS&t;- initialization succeeded&n; *   DFX_K_FAILURE&t;- initialization failed - could not allocate memory&n; *&t;&t;&t;&t;&t;&t;or read adapter MAC address&n; *&n; * Assumptions:&n; *   Memory allocated from kmalloc() call is physically contiguous, locked&n; *   memory whose physical address equals its virtual address.&n; *&n; * Side Effects:&n; *   Adapter is reset and should be in DMA_UNAVAILABLE state before&n; *   returning from this routine.&n; */
DECL|function|dfx_driver_init
r_static
r_int
id|__devinit
id|dfx_driver_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|alloc_size
suffix:semicolon
multiline_comment|/* total buffer size needed */
r_char
op_star
id|top_v
comma
op_star
id|curr_v
suffix:semicolon
multiline_comment|/* virtual addrs into memory block */
id|u32
id|top_p
comma
id|curr_p
suffix:semicolon
multiline_comment|/* physical addrs into memory block */
id|u32
id|data
suffix:semicolon
multiline_comment|/* host data register value */
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_driver_init...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize bus-specific hardware registers */
id|dfx_bus_init
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize default values for configurable parameters&n;&t; *&n;&t; * Note: All of these parameters are ones that a user may&n;&t; *       want to customize.  It&squot;d be nice to break these&n;&t; *&t;&t; out into Space.c or someplace else that&squot;s more&n;&t; *&t;&t; accessible/understandable than this file.&n;&t; */
id|bp-&gt;full_duplex_enb
op_assign
id|PI_SNMP_K_FALSE
suffix:semicolon
id|bp-&gt;req_ttrt
op_assign
l_int|8
op_star
l_int|12500
suffix:semicolon
multiline_comment|/* 8ms in 80 nanosec units */
id|bp-&gt;burst_size
op_assign
id|PI_PDATA_B_DMA_BURST_SIZE_DEF
suffix:semicolon
id|bp-&gt;rcv_bufs_to_post
op_assign
id|RCV_BUFS_DEF
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that HW configuration is OK&n;&t; *&n;&t; * Note: Depending on the hardware revision, we may need to modify&n;&t; *       some of the configurable parameters to workaround hardware&n;&t; *       limitations.  We&squot;ll perform this configuration check AFTER&n;&t; *       setting the parameters to their default values.&n;&t; */
id|dfx_bus_config_check
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Disable PDQ interrupts first */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_INT_ENB
comma
id|PI_HOST_INT_K_DISABLE_ALL_INTS
)paren
suffix:semicolon
multiline_comment|/* Place adapter in DMA_UNAVAILABLE state by resetting adapter */
(paren
r_void
)paren
id|dfx_hw_dma_uninit
c_func
(paren
id|bp
comma
id|PI_PDATA_A_RESET_M_SKIP_ST
)paren
suffix:semicolon
multiline_comment|/*  Read the factory MAC address from the adapter then save it */
r_if
c_cond
(paren
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_MLA
comma
id|PI_PDATA_A_MLA_K_LO
comma
l_int|0
comma
op_amp
id|data
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not read adapter factory MAC address!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;factory_mac_addr
(braket
l_int|0
)braket
comma
op_amp
id|data
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_MLA
comma
id|PI_PDATA_A_MLA_K_HI
comma
l_int|0
comma
op_amp
id|data
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not read adapter factory MAC address!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;factory_mac_addr
(braket
l_int|4
)braket
comma
op_amp
id|data
comma
r_sizeof
(paren
id|u16
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set current address to factory address&n;&t; *&n;&t; * Note: Node address override support is handled through&n;&t; *       dfx_ctl_set_mac_address.&n;&t; */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|bp-&gt;factory_mac_addr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;bus_type
op_eq
id|DFX_BUS_TYPE_EISA
)paren
id|printk
c_func
(paren
l_string|&quot;%s: DEFEA at I/O addr = 0x%lX, IRQ = %d, Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: DEFPA at I/O addr = 0x%lX, IRQ = %d, Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get memory for descriptor block, consumer block, and other buffers&n;&t; * that need to be DMA read or written to by the adapter.&n;&t; */
id|alloc_size
op_assign
r_sizeof
(paren
id|PI_DESCR_BLOCK
)paren
op_plus
id|PI_CMD_REQ_K_SIZE_MAX
op_plus
id|PI_CMD_RSP_K_SIZE_MAX
op_plus
macro_line|#ifndef DYNAMIC_BUFFERS
(paren
id|bp-&gt;rcv_bufs_to_post
op_star
id|PI_RCV_DATA_K_SIZE_MAX
)paren
op_plus
macro_line|#endif
r_sizeof
(paren
id|PI_CONSUMER_BLOCK
)paren
op_plus
(paren
id|PI_ALIGN_K_DESC_BLK
op_minus
l_int|1
)paren
suffix:semicolon
id|bp-&gt;kmalloced
op_assign
id|top_v
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|alloc_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|top_v
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not allocate memory for host buffers and structures!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
id|memset
c_func
(paren
id|top_v
comma
l_int|0
comma
id|alloc_size
)paren
suffix:semicolon
multiline_comment|/* zero out memory before continuing */
id|top_p
op_assign
id|virt_to_bus
c_func
(paren
id|top_v
)paren
suffix:semicolon
multiline_comment|/* get physical address of buffer */
multiline_comment|/*&n;&t; *  To guarantee the 8K alignment required for the descriptor block, 8K - 1&n;&t; *  plus the amount of memory needed was allocated.  The physical address&n;&t; *&t;is now 8K aligned.  By carving up the memory in a specific order,&n;&t; *  we&squot;ll guarantee the alignment requirements for all other structures.&n;&t; *&n;&t; *  Note: If the assumptions change regarding the non-paged, non-cached,&n;&t; *&t;&t;  physically contiguous nature of the memory block or the address&n;&t; *&t;&t;  alignments, then we&squot;ll need to implement a different algorithm&n;&t; *&t;&t;  for allocating the needed memory.&n;&t; */
id|curr_p
op_assign
(paren
id|u32
)paren
(paren
id|ALIGN
c_func
(paren
id|top_p
comma
id|PI_ALIGN_K_DESC_BLK
)paren
)paren
suffix:semicolon
id|curr_v
op_assign
id|top_v
op_plus
(paren
id|curr_p
op_minus
id|top_p
)paren
suffix:semicolon
multiline_comment|/* Reserve space for descriptor block */
id|bp-&gt;descr_block_virt
op_assign
(paren
id|PI_DESCR_BLOCK
op_star
)paren
id|curr_v
suffix:semicolon
id|bp-&gt;descr_block_phys
op_assign
id|curr_p
suffix:semicolon
id|curr_v
op_add_assign
r_sizeof
(paren
id|PI_DESCR_BLOCK
)paren
suffix:semicolon
id|curr_p
op_add_assign
r_sizeof
(paren
id|PI_DESCR_BLOCK
)paren
suffix:semicolon
multiline_comment|/* Reserve space for command request buffer */
id|bp-&gt;cmd_req_virt
op_assign
(paren
id|PI_DMA_CMD_REQ
op_star
)paren
id|curr_v
suffix:semicolon
id|bp-&gt;cmd_req_phys
op_assign
id|curr_p
suffix:semicolon
id|curr_v
op_add_assign
id|PI_CMD_REQ_K_SIZE_MAX
suffix:semicolon
id|curr_p
op_add_assign
id|PI_CMD_REQ_K_SIZE_MAX
suffix:semicolon
multiline_comment|/* Reserve space for command response buffer */
id|bp-&gt;cmd_rsp_virt
op_assign
(paren
id|PI_DMA_CMD_RSP
op_star
)paren
id|curr_v
suffix:semicolon
id|bp-&gt;cmd_rsp_phys
op_assign
id|curr_p
suffix:semicolon
id|curr_v
op_add_assign
id|PI_CMD_RSP_K_SIZE_MAX
suffix:semicolon
id|curr_p
op_add_assign
id|PI_CMD_RSP_K_SIZE_MAX
suffix:semicolon
multiline_comment|/* Reserve space for the LLC host receive queue buffers */
id|bp-&gt;rcv_block_virt
op_assign
id|curr_v
suffix:semicolon
id|bp-&gt;rcv_block_phys
op_assign
id|curr_p
suffix:semicolon
macro_line|#ifndef DYNAMIC_BUFFERS
id|curr_v
op_add_assign
(paren
id|bp-&gt;rcv_bufs_to_post
op_star
id|PI_RCV_DATA_K_SIZE_MAX
)paren
suffix:semicolon
id|curr_p
op_add_assign
(paren
id|bp-&gt;rcv_bufs_to_post
op_star
id|PI_RCV_DATA_K_SIZE_MAX
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Reserve space for the consumer block */
id|bp-&gt;cons_block_virt
op_assign
(paren
id|PI_CONSUMER_BLOCK
op_star
)paren
id|curr_v
suffix:semicolon
id|bp-&gt;cons_block_phys
op_assign
id|curr_p
suffix:semicolon
multiline_comment|/* Display virtual and physical addresses if debug driver */
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Descriptor block virt = %0lX, phys = %0X&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|bp-&gt;descr_block_virt
comma
id|bp-&gt;descr_block_phys
)paren
suffix:semicolon
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Command Request buffer virt = %0lX, phys = %0X&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|bp-&gt;cmd_req_virt
comma
id|bp-&gt;cmd_req_phys
)paren
suffix:semicolon
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Command Response buffer virt = %0lX, phys = %0X&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|bp-&gt;cmd_rsp_virt
comma
id|bp-&gt;cmd_rsp_phys
)paren
suffix:semicolon
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Receive buffer block virt = %0lX, phys = %0X&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|bp-&gt;rcv_block_virt
comma
id|bp-&gt;rcv_block_phys
)paren
suffix:semicolon
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Consumer block virt = %0lX, phys = %0X&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|bp-&gt;cons_block_virt
comma
id|bp-&gt;cons_block_phys
)paren
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =================&n; * = dfx_adap_init =&n; * =================&n; *   &n; * Overview:&n; *   Brings the adapter to the link avail/link unavailable state.&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Issues the low-level firmware/hardware calls necessary to bring&n; *   the adapter up, or to properly reset and restore adapter during&n; *   run-time.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS - Adapter brought up successfully&n; *   DFX_K_FAILURE - Adapter initialization failed&n; *&n; * Assumptions:&n; *   bp-&gt;reset_type should be set to a valid reset type value before&n; *   calling this routine.&n; *&n; * Side Effects:&n; *   Adapter should be in LINK_AVAILABLE or LINK_UNAVAILABLE state&n; *   upon a successful return of this routine.&n; */
DECL|function|dfx_adap_init
r_static
r_int
id|dfx_adap_init
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_adap_init...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disable PDQ interrupts first */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_INT_ENB
comma
id|PI_HOST_INT_K_DISABLE_ALL_INTS
)paren
suffix:semicolon
multiline_comment|/* Place adapter in DMA_UNAVAILABLE state by resetting adapter */
r_if
c_cond
(paren
id|dfx_hw_dma_uninit
c_func
(paren
id|bp
comma
id|bp-&gt;reset_type
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not uninitialize/reset adapter!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * When the PDQ is reset, some false Type 0 interrupts may be pending,&n;&t; * so we&squot;ll acknowledge all Type 0 interrupts now before continuing.&n;&t; */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_TYPE_0_STATUS
comma
id|PI_HOST_INT_K_ACK_ALL_TYPE_0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear Type 1 and Type 2 registers before going to DMA_AVAILABLE state&n;&t; *&n;&t; * Note: We only need to clear host copies of these registers.  The PDQ reset&n;&t; *       takes care of the on-board register values.&n;&t; */
id|bp-&gt;cmd_req_reg.lword
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;cmd_rsp_reg.lword
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;rcv_xmt_reg.lword
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear consumer block before going to DMA_AVAILABLE state */
id|memset
c_func
(paren
id|bp-&gt;cons_block_virt
comma
l_int|0
comma
r_sizeof
(paren
id|PI_CONSUMER_BLOCK
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the DMA Burst Size */
r_if
c_cond
(paren
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_SUB_CMD
comma
id|PI_SUB_CMD_K_BURST_SIZE_SET
comma
id|bp-&gt;burst_size
comma
l_int|NULL
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not set adapter burst size!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set base address of Consumer Block&n;&t; *&n;&t; * Assumption: 32-bit physical address of consumer block is 64 byte&n;&t; *&t;&t;&t;   aligned.  That is, bits 0-5 of the address must be zero.&n;&t; */
r_if
c_cond
(paren
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_CONS_BLOCK
comma
id|bp-&gt;cons_block_phys
comma
l_int|0
comma
l_int|NULL
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not set consumer block address!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set base address of Descriptor Block and bring adapter to DMA_AVAILABLE state&n;&t; *&n;&t; * Note: We also set the literal and data swapping requirements in this&n;&t; *&t;     command.  Since this driver presently runs on Intel platforms&n;&t; *&t;&t; which are Little Endian, we&squot;ll tell the adapter to byte swap&n;&t; *&t;&t; data only.  This code will need to change when we support&n;&t; *&t;&t; Big Endian systems (eg. PowerPC).&n;&t; *&n;&t; * Assumption: 32-bit physical address of descriptor block is 8Kbyte&n;&t; *             aligned.  That is, bits 0-12 of the address must be zero.&n;&t; */
r_if
c_cond
(paren
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_INIT
comma
(paren
id|u32
)paren
(paren
id|bp-&gt;descr_block_phys
op_or
id|PI_PDATA_A_INIT_M_BSWAP_DATA
)paren
comma
l_int|0
comma
l_int|NULL
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not set descriptor block address!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/* Set transmit flush timeout value */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_CHARS_SET
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;char_set.item
(braket
l_int|0
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_FLUSH_TIME
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;char_set.item
(braket
l_int|0
)braket
dot
id|value
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 seconds */
id|bp-&gt;cmd_req_virt-&gt;char_set.item
(braket
l_int|0
)braket
dot
id|item_index
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;char_set.item
(braket
l_int|1
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_EOL
suffix:semicolon
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA command request failed!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/* Set the initial values for eFDXEnable and MACTReq MIB objects */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_SNMP_SET
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|0
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_FDX_ENB_DIS
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|0
)braket
dot
id|value
op_assign
id|bp-&gt;full_duplex_enb
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|0
)braket
dot
id|item_index
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|1
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_MAC_T_REQ
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|1
)braket
dot
id|value
op_assign
id|bp-&gt;req_ttrt
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|1
)braket
dot
id|item_index
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;snmp_set.item
(braket
l_int|2
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_EOL
suffix:semicolon
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA command request failed!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/* Initialize adapter CAM */
r_if
c_cond
(paren
id|dfx_ctl_update_cam
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Adapter CAM update failed!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/* Initialize adapter filters */
r_if
c_cond
(paren
id|dfx_ctl_update_filters
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Adapter filters update failed!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/* Initialize receive descriptor block and produce buffers */
id|dfx_rcv_init
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Issue START command and bring adapter to LINK_(UN)AVAILABLE state */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_START
suffix:semicolon
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Start command failed&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
id|DFX_K_FAILURE
suffix:semicolon
)brace
multiline_comment|/* Initialization succeeded, reenable PDQ interrupts */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_INT_ENB
comma
id|PI_HOST_INT_K_ENABLE_DEF_INTS
)paren
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ============&n; * = dfx_open =&n; * ============&n; *   &n; * Overview:&n; *   Opens the adapter&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This function brings the adapter to an operational state.&n; *&n; * Return Codes:&n; *   0&t;&t; - Adapter was successfully opened&n; *   -EAGAIN - Could not register IRQ or adapter initialization failed&n; *&n; * Assumptions:&n; *   This routine should only be called for a device that was&n; *   initialized successfully.&n; *&n; * Side Effects:&n; *   Adapter should be in LINK_AVAILABLE or LINK_UNAVAILABLE state&n; *   if the open is successful.&n; */
DECL|function|dfx_open
r_static
r_int
id|dfx_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_open...&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* Register IRQ - support shared interrupts by passing device ptr */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|dfx_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Requested IRQ %d is busy&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set current address to factory MAC address&n;&t; *&n;&t; * Note: We&squot;ve already done this step in dfx_driver_init.&n;&t; *       However, it&squot;s possible that a user has set a node&n;&t; *&t;&t; address override, then closed and reopened the&n;&t; *&t;&t; adapter.  Unless we reset the device address field&n;&t; *&t;&t; now, we&squot;ll continue to use the existing modified&n;&t; *&t;&t; address.&n;&t; */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|bp-&gt;factory_mac_addr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
multiline_comment|/* Clear local unicast/multicast address tables and counts */
id|memset
c_func
(paren
id|bp-&gt;uc_table
comma
l_int|0
comma
r_sizeof
(paren
id|bp-&gt;uc_table
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bp-&gt;mc_table
comma
l_int|0
comma
r_sizeof
(paren
id|bp-&gt;mc_table
)paren
)paren
suffix:semicolon
id|bp-&gt;uc_count
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Disable promiscuous filter settings */
id|bp-&gt;ind_group_prom
op_assign
id|PI_FSTATE_K_BLOCK
suffix:semicolon
id|bp-&gt;group_prom
op_assign
id|PI_FSTATE_K_BLOCK
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|bp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Reset and initialize adapter */
id|bp-&gt;reset_type
op_assign
id|PI_PDATA_A_RESET_M_SKIP_ST
suffix:semicolon
multiline_comment|/* skip self-test */
r_if
c_cond
(paren
id|dfx_adap_init
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Adapter open failed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Set device structure info */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =============&n; * = dfx_close =&n; * =============&n; *   &n; * Overview:&n; *   Closes the device/module.&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This routine closes the adapter and brings it to a safe state.&n; *   The interrupt service routine is deregistered with the OS.&n; *   The adapter can be opened again with another call to dfx_open().&n; *&n; * Return Codes:&n; *   Always return 0.&n; *&n; * Assumptions:&n; *   No further requests for this adapter are made after this routine is&n; *   called.  dfx_open() can be called to reset and reinitialize the&n; *   adapter.&n; *&n; * Side Effects:&n; *   Adapter should be in DMA_UNAVAILABLE state upon completion of this&n; *   routine.&n; */
DECL|function|dfx_close
r_static
r_int
id|dfx_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|DBG_printk
c_func
(paren
l_string|&quot;In dfx_close...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disable PDQ interrupts first */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_INT_ENB
comma
id|PI_HOST_INT_K_DISABLE_ALL_INTS
)paren
suffix:semicolon
multiline_comment|/* Place adapter in DMA_UNAVAILABLE state by resetting adapter */
(paren
r_void
)paren
id|dfx_hw_dma_uninit
c_func
(paren
id|bp
comma
id|PI_PDATA_A_RESET_M_SKIP_ST
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush any pending transmit buffers&n;&t; *&n;&t; * Note: It&squot;s important that we flush the transmit buffers&n;&t; *&t;&t; BEFORE we clear our copy of the Type 2 register.&n;&t; *&t;&t; Otherwise, we&squot;ll have no idea how many buffers&n;&t; *&t;&t; we need to free.&n;&t; */
id|dfx_xmt_flush
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear Type 1 and Type 2 registers after adapter reset&n;&t; *&n;&t; * Note: Even though we&squot;re closing the adapter, it&squot;s&n;&t; *       possible that an interrupt will occur after&n;&t; *&t;&t; dfx_close is called.  Without some assurance to&n;&t; *&t;&t; the contrary we want to make sure that we don&squot;t&n;&t; *&t;&t; process receive and transmit LLC frames and update&n;&t; *&t;&t; the Type 2 register with bad information.&n;&t; */
id|bp-&gt;cmd_req_reg.lword
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;cmd_rsp_reg.lword
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;rcv_xmt_reg.lword
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear consumer block for the same reason given above */
id|memset
c_func
(paren
id|bp-&gt;cons_block_virt
comma
l_int|0
comma
r_sizeof
(paren
id|PI_CONSUMER_BLOCK
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear device structure flags */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Deregister (free) IRQ */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ======================&n; * = dfx_int_pr_halt_id =&n; * ======================&n; *   &n; * Overview:&n; *   Displays halt id&squot;s in string form.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Determine current halt id and display appropriate string.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_int_pr_halt_id
r_static
r_void
id|dfx_int_pr_halt_id
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|PI_UINT32
id|port_status
suffix:semicolon
multiline_comment|/* PDQ port status register value */
id|PI_UINT32
id|halt_id
suffix:semicolon
multiline_comment|/* PDQ port status halt ID */
multiline_comment|/* Read the latest port status */
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_STATUS
comma
op_amp
id|port_status
)paren
suffix:semicolon
multiline_comment|/* Display halt state transition information */
id|halt_id
op_assign
(paren
id|port_status
op_amp
id|PI_PSTATUS_M_HALT_ID
)paren
op_rshift
id|PI_PSTATUS_V_HALT_ID
suffix:semicolon
r_switch
c_cond
(paren
id|halt_id
)paren
(brace
r_case
id|PI_HALT_ID_K_SELFTEST_TIMEOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Selftest Timeout&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_PARITY_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Host Bus Parity Error&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_HOST_DIR_HALT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Host-Directed Halt&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_SW_FAULT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Adapter Software Fault&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_HW_FAULT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Adapter Hardware Fault&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_PC_TRACE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: FDDI Network PC Trace Path Test&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_DMA_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Adapter DMA Error&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_IMAGE_CRC_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Firmware Image CRC Error&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_HALT_ID_K_BUS_EXCEPTION
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: 68000 Bus Exception&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Halt ID: Unknown (code = %X)&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
comma
id|halt_id
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ==========================&n; * = dfx_int_type_0_process =&n; * ==========================&n; *   &n; * Overview:&n; *   Processes Type 0 interrupts.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Processes all enabled Type 0 interrupts.  If the reason for the interrupt&n; *   is a serious fault on the adapter, then an error message is displayed&n; *   and the adapter is reset.&n; *&n; *   One tricky potential timing window is the rapid succession of &quot;link avail&quot;&n; *   &quot;link unavail&quot; state change interrupts.  The acknowledgement of the Type 0&n; *   interrupt must be done before reading the state from the Port Status&n; *   register.  This is true because a state change could occur after reading&n; *   the data, but before acknowledging the interrupt.  If this state change&n; *   does happen, it would be lost because the driver is using the old state,&n; *   and it will never know about the new state because it subsequently&n; *   acknowledges the state change interrupt.&n; *&n; *          INCORRECT                                      CORRECT&n; *      read type 0 int reasons                   read type 0 int reasons&n; *      read adapter state                        ack type 0 interrupts&n; *      ack type 0 interrupts                     read adapter state&n; *      ... process interrupt ...                 ... process interrupt ...&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   An adapter reset may occur if the adapter has any Type 0 error interrupts&n; *   or if the port status indicates that the adapter is halted.  The driver&n; *   is responsible for reinitializing the adapter with the current CAM&n; *   contents and adapter filter settings.&n; */
DECL|function|dfx_int_type_0_process
r_static
r_void
id|dfx_int_type_0_process
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|PI_UINT32
id|type_0_status
suffix:semicolon
multiline_comment|/* Host Interrupt Type 0 register */
id|PI_UINT32
id|state
suffix:semicolon
multiline_comment|/* current adap state (from port status) */
multiline_comment|/*&n;&t; * Read host interrupt Type 0 register to determine which Type 0&n;&t; * interrupts are pending.  Immediately write it back out to clear&n;&t; * those interrupts.&n;&t; */
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_TYPE_0_STATUS
comma
op_amp
id|type_0_status
)paren
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_TYPE_0_STATUS
comma
id|type_0_status
)paren
suffix:semicolon
multiline_comment|/* Check for Type 0 error interrupts */
r_if
c_cond
(paren
id|type_0_status
op_amp
(paren
id|PI_TYPE_0_STAT_M_NXM
op_or
id|PI_TYPE_0_STAT_M_PM_PAR_ERR
op_or
id|PI_TYPE_0_STAT_M_BUS_PAR_ERR
)paren
)paren
(brace
multiline_comment|/* Check for Non-Existent Memory error */
r_if
c_cond
(paren
id|type_0_status
op_amp
id|PI_TYPE_0_STAT_M_NXM
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Non-Existent Memory Access Error&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Check for Packet Memory Parity error */
r_if
c_cond
(paren
id|type_0_status
op_amp
id|PI_TYPE_0_STAT_M_PM_PAR_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Packet Memory Parity Error&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Check for Host Bus Parity error */
r_if
c_cond
(paren
id|type_0_status
op_amp
id|PI_TYPE_0_STAT_M_BUS_PAR_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Host Bus Parity Error&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Reset adapter and bring it back on-line */
id|bp-&gt;link_available
op_assign
id|PI_K_FALSE
suffix:semicolon
multiline_comment|/* link is no longer available */
id|bp-&gt;reset_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* rerun on-board diagnostics */
id|printk
c_func
(paren
l_string|&quot;%s: Resetting adapter...&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfx_adap_init
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Adapter reset failed!  Disabling adapter interrupts.&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_INT_ENB
comma
id|PI_HOST_INT_K_DISABLE_ALL_INTS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: Adapter reset successful!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for transmit flush interrupt */
r_if
c_cond
(paren
id|type_0_status
op_amp
id|PI_TYPE_0_STAT_M_XMT_FLUSH
)paren
(brace
multiline_comment|/* Flush any pending xmt&squot;s and acknowledge the flush interrupt */
id|bp-&gt;link_available
op_assign
id|PI_K_FALSE
suffix:semicolon
multiline_comment|/* link is no longer available */
id|dfx_xmt_flush
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* flush any outstanding packets */
(paren
r_void
)paren
id|dfx_hw_port_ctrl_req
c_func
(paren
id|bp
comma
id|PI_PCTRL_M_XMT_DATA_FLUSH_DONE
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for adapter state change */
r_if
c_cond
(paren
id|type_0_status
op_amp
id|PI_TYPE_0_STAT_M_STATE_CHANGE
)paren
(brace
multiline_comment|/* Get latest adapter state */
id|state
op_assign
id|dfx_hw_adap_state_rd
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* get adapter state */
r_if
c_cond
(paren
id|state
op_eq
id|PI_STATE_K_HALTED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Adapter has transitioned to HALTED state, try to reset&n;&t;&t;&t; * adapter to bring it back on-line.  If reset fails,&n;&t;&t;&t; * leave the adapter in the broken state.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: Controller has transitioned to HALTED state!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|dfx_int_pr_halt_id
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* display halt id as string */
multiline_comment|/* Reset adapter and bring it back on-line */
id|bp-&gt;link_available
op_assign
id|PI_K_FALSE
suffix:semicolon
multiline_comment|/* link is no longer available */
id|bp-&gt;reset_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* rerun on-board diagnostics */
id|printk
c_func
(paren
l_string|&quot;%s: Resetting adapter...&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfx_adap_init
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Adapter reset failed!  Disabling adapter interrupts.&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_INT_ENB
comma
id|PI_HOST_INT_K_DISABLE_ALL_INTS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: Adapter reset successful!&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|state
op_eq
id|PI_STATE_K_LINK_AVAIL
)paren
(brace
id|bp-&gt;link_available
op_assign
id|PI_K_TRUE
suffix:semicolon
multiline_comment|/* set link available flag */
)brace
)brace
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ==================&n; * = dfx_int_common =&n; * ==================&n; *   &n; * Overview:&n; *   Interrupt service routine (ISR)&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   This is the ISR which processes incoming adapter interrupts.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   This routine assumes PDQ interrupts have not been disabled.&n; *   When interrupts are disabled at the PDQ, the Port Status register&n; *   is automatically cleared.  This routine uses the Port Status&n; *   register value to determine whether a Type 0 interrupt occurred,&n; *   so it&squot;s important that adapter interrupts are not normally&n; *   enabled/disabled at the PDQ.&n; *&n; *   It&squot;s vital that this routine is NOT reentered for the&n; *   same board and that the OS is not in another section of&n; *   code (eg. dfx_xmt_queue_pkt) for the same board on a&n; *   different thread.&n; *&n; * Side Effects:&n; *   Pending interrupts are serviced.  Depending on the type of&n; *   interrupt, acknowledging and clearing the interrupt at the&n; *   PDQ involves writing a register to clear the interrupt bit&n; *   or updating completion indices.&n; */
DECL|function|dfx_int_common
r_static
r_void
id|dfx_int_common
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|PI_UINT32
id|port_status
suffix:semicolon
multiline_comment|/* Port Status register */
multiline_comment|/* Process xmt interrupts - frequent case, so always call this routine */
r_if
c_cond
(paren
id|dfx_xmt_done
c_func
(paren
id|bp
)paren
)paren
(brace
multiline_comment|/* free consumed xmt packets */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Process rcv interrupts - frequent case, so always call this routine */
id|dfx_rcv_queue_process
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* service received LLC frames */
multiline_comment|/*&n;&t; * Transmit and receive producer and completion indices are updated on the&n;&t; * adapter by writing to the Type 2 Producer register.  Since the frequent&n;&t; * case is that we&squot;ll be processing either LLC transmit or receive buffers,&n;&t; * we&squot;ll optimize I/O writes by doing a single register write here.&n;&t; */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_TYPE_2_PROD
comma
id|bp-&gt;rcv_xmt_reg.lword
)paren
suffix:semicolon
multiline_comment|/* Read PDQ Port Status register to find out which interrupts need processing */
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_STATUS
comma
op_amp
id|port_status
)paren
suffix:semicolon
multiline_comment|/* Process Type 0 interrupts (if any) - infrequent, so only call when needed */
r_if
c_cond
(paren
id|port_status
op_amp
id|PI_PSTATUS_M_TYPE_0_PENDING
)paren
id|dfx_int_type_0_process
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* process Type 0 interrupts */
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =================&n; * = dfx_interrupt =&n; * =================&n; *   &n; * Overview:&n; *   Interrupt processing routine&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   irq&t;- interrupt vector&n; *   dev_id&t;- pointer to device information&n; *&t; regs&t;- pointer to registers structure&n; *&n; * Functional Description:&n; *   This routine calls the interrupt processing routine for this adapter.  It&n; *   disables and reenables adapter interrupts, as appropriate.  We can support&n; *   shared interrupts since the incoming dev_id pointer provides our device&n; *   structure context.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   The interrupt acknowledgement at the hardware level (eg. ACKing the PIC&n; *   on Intel-based systems) is done by the operating system outside this&n; *   routine.&n; *&n; *&t; System interrupts are enabled through this call.&n; *&n; * Side Effects:&n; *   Interrupts are disabled, then reenabled at the adapter.&n; */
DECL|function|dfx_interrupt
r_static
r_void
id|dfx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
id|DFX_board_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* private board structure pointer */
id|u8
id|tmp
suffix:semicolon
multiline_comment|/* used for disabling/enabling ints */
multiline_comment|/* Get board pointer only if device structure is valid */
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* See if we&squot;re already servicing an interrupt */
multiline_comment|/* Service adapter interrupts */
r_if
c_cond
(paren
id|bp-&gt;bus_type
op_eq
id|DFX_BUS_TYPE_PCI
)paren
(brace
multiline_comment|/* Disable PDQ-PFI interrupts at PFI */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PFI_K_REG_MODE_CTRL
comma
id|PFI_MODE_M_DMA_ENB
)paren
suffix:semicolon
multiline_comment|/* Call interrupt service routine for this adapter */
id|dfx_int_common
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear PDQ interrupt status bit and reenable interrupts */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PFI_K_REG_STATUS
comma
id|PFI_STATUS_M_PDQ_INT
)paren
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PFI_K_REG_MODE_CTRL
comma
(paren
id|PFI_MODE_M_PDQ_INT_ENB
op_plus
id|PFI_MODE_M_DMA_ENB
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable interrupts at the ESIC */
id|dfx_port_read_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|PI_CONFIG_STAT_0_M_INT_ENB
suffix:semicolon
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Call interrupt service routine for this adapter */
id|dfx_int_common
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reenable interrupts at the ESIC */
id|dfx_port_read_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp
op_or_assign
id|PI_CONFIG_STAT_0_M_INT_ENB
suffix:semicolon
id|dfx_port_write_byte
c_func
(paren
id|bp
comma
id|PI_ESIC_K_IO_CONFIG_STAT_0
comma
id|tmp
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|bp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =====================&n; * = dfx_ctl_get_stats =&n; * =====================&n; *   &n; * Overview:&n; *   Get statistics for FDDI adapter&n; *  &n; * Returns:&n; *   Pointer to FDDI statistics structure&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   Gets current MIB objects from adapter, then&n; *   returns FDDI statistics structure as defined&n; *   in if_fddi.h.&n; *&n; *   Note: Since the FDDI statistics structure is&n; *   still new and the device structure doesn&squot;t&n; *   have an FDDI-specific get statistics handler,&n; *   we&squot;ll return the FDDI statistics structure as&n; *   a pointer to an Ethernet statistics structure.&n; *   That way, at least the first part of the statistics&n; *   structure can be decoded properly, and it allows&n; *   &quot;smart&quot; applications to perform a second cast to&n; *   decode the FDDI-specific statistics.&n; *&n; *   We&squot;ll have to pay attention to this routine as the&n; *   device structure becomes more mature and LAN media&n; *   independent.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_ctl_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|dfx_ctl_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Fill the bp-&gt;stats structure with driver-maintained counters */
id|bp-&gt;stats.rx_packets
op_assign
id|bp-&gt;rcv_total_frames
suffix:semicolon
id|bp-&gt;stats.tx_packets
op_assign
id|bp-&gt;xmt_total_frames
suffix:semicolon
id|bp-&gt;stats.rx_bytes
op_assign
id|bp-&gt;rcv_total_bytes
suffix:semicolon
id|bp-&gt;stats.tx_bytes
op_assign
id|bp-&gt;xmt_total_bytes
suffix:semicolon
id|bp-&gt;stats.rx_errors
op_assign
(paren
id|u32
)paren
(paren
id|bp-&gt;rcv_crc_errors
op_plus
id|bp-&gt;rcv_frame_status_errors
op_plus
id|bp-&gt;rcv_length_errors
)paren
suffix:semicolon
id|bp-&gt;stats.tx_errors
op_assign
id|bp-&gt;xmt_length_errors
suffix:semicolon
id|bp-&gt;stats.rx_dropped
op_assign
id|bp-&gt;rcv_discards
suffix:semicolon
id|bp-&gt;stats.tx_dropped
op_assign
id|bp-&gt;xmt_discards
suffix:semicolon
id|bp-&gt;stats.multicast
op_assign
id|bp-&gt;rcv_multicast_frames
suffix:semicolon
id|bp-&gt;stats.transmit_collision
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always zero (0) for FDDI */
multiline_comment|/* Get FDDI SMT MIB objects */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_SMT_MIB_GET
suffix:semicolon
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
r_return
(paren
r_struct
id|net_device_stats
op_star
)paren
op_amp
id|bp-&gt;stats
suffix:semicolon
multiline_comment|/* Fill the bp-&gt;stats structure with the SMT MIB object values */
id|memcpy
c_func
(paren
id|bp-&gt;stats.smt_station_id
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_id
comma
r_sizeof
(paren
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_id
)paren
)paren
suffix:semicolon
id|bp-&gt;stats.smt_op_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_op_version_id
suffix:semicolon
id|bp-&gt;stats.smt_hi_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_hi_version_id
suffix:semicolon
id|bp-&gt;stats.smt_lo_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_lo_version_id
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.smt_user_data
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_user_data
comma
r_sizeof
(paren
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_user_data
)paren
)paren
suffix:semicolon
id|bp-&gt;stats.smt_mib_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_mib_version_id
suffix:semicolon
id|bp-&gt;stats.smt_mac_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_mac_ct
suffix:semicolon
id|bp-&gt;stats.smt_non_master_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_non_master_ct
suffix:semicolon
id|bp-&gt;stats.smt_master_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_master_ct
suffix:semicolon
id|bp-&gt;stats.smt_available_paths
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_available_paths
suffix:semicolon
id|bp-&gt;stats.smt_config_capabilities
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_config_capabilities
suffix:semicolon
id|bp-&gt;stats.smt_config_policy
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_config_policy
suffix:semicolon
id|bp-&gt;stats.smt_connection_policy
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_connection_policy
suffix:semicolon
id|bp-&gt;stats.smt_t_notify
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_t_notify
suffix:semicolon
id|bp-&gt;stats.smt_stat_rpt_policy
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_stat_rpt_policy
suffix:semicolon
id|bp-&gt;stats.smt_trace_max_expiration
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_trace_max_expiration
suffix:semicolon
id|bp-&gt;stats.smt_bypass_present
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_bypass_present
suffix:semicolon
id|bp-&gt;stats.smt_ecm_state
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_ecm_state
suffix:semicolon
id|bp-&gt;stats.smt_cf_state
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_cf_state
suffix:semicolon
id|bp-&gt;stats.smt_remote_disconnect_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_remote_disconnect_flag
suffix:semicolon
id|bp-&gt;stats.smt_station_status
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_status
suffix:semicolon
id|bp-&gt;stats.smt_peer_wrap_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_peer_wrap_flag
suffix:semicolon
id|bp-&gt;stats.smt_time_stamp
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_msg_time_stamp.ls
suffix:semicolon
id|bp-&gt;stats.smt_transition_time_stamp
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_transition_time_stamp.ls
suffix:semicolon
id|bp-&gt;stats.mac_frame_status_functions
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_status_functions
suffix:semicolon
id|bp-&gt;stats.mac_t_max_capability
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_max_capability
suffix:semicolon
id|bp-&gt;stats.mac_tvx_capability
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_tvx_capability
suffix:semicolon
id|bp-&gt;stats.mac_available_paths
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_available_paths
suffix:semicolon
id|bp-&gt;stats.mac_current_path
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_current_path
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_upstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_upstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_downstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_downstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_old_upstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_old_upstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_old_downstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_old_downstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|bp-&gt;stats.mac_dup_address_test
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_dup_address_test
suffix:semicolon
id|bp-&gt;stats.mac_requested_paths
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_requested_paths
suffix:semicolon
id|bp-&gt;stats.mac_downstream_port_type
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_downstream_port_type
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_smt_address
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_smt_address
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|bp-&gt;stats.mac_t_req
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_req
suffix:semicolon
id|bp-&gt;stats.mac_t_neg
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_neg
suffix:semicolon
id|bp-&gt;stats.mac_t_max
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_max
suffix:semicolon
id|bp-&gt;stats.mac_tvx_value
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_tvx_value
suffix:semicolon
id|bp-&gt;stats.mac_frame_error_threshold
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_threshold
suffix:semicolon
id|bp-&gt;stats.mac_frame_error_ratio
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_ratio
suffix:semicolon
id|bp-&gt;stats.mac_rmt_state
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_rmt_state
suffix:semicolon
id|bp-&gt;stats.mac_da_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_da_flag
suffix:semicolon
id|bp-&gt;stats.mac_una_da_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_unda_flag
suffix:semicolon
id|bp-&gt;stats.mac_frame_error_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_flag
suffix:semicolon
id|bp-&gt;stats.mac_ma_unitdata_available
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_ma_unitdata_available
suffix:semicolon
id|bp-&gt;stats.mac_hardware_present
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_hardware_present
suffix:semicolon
id|bp-&gt;stats.mac_ma_unitdata_enable
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_ma_unitdata_enable
suffix:semicolon
id|bp-&gt;stats.path_tvx_lower_bound
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_tvx_lower_bound
suffix:semicolon
id|bp-&gt;stats.path_t_max_lower_bound
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_t_max_lower_bound
suffix:semicolon
id|bp-&gt;stats.path_max_t_req
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_max_t_req
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.path_configuration
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_configuration
comma
r_sizeof
(paren
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_configuration
)paren
)paren
suffix:semicolon
id|bp-&gt;stats.port_my_type
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_my_type
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_my_type
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_my_type
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_neighbor_type
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_neighbor_type
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_neighbor_type
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_neighbor_type
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_policies
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_policies
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_policies
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_policies
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_mac_indicated
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_indicated
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_mac_indicated
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_indicated
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_current_path
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_current_path
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_current_path
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_current_path
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;stats.port_requested_paths
(braket
l_int|0
op_star
l_int|3
)braket
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_requested_paths
(braket
l_int|0
)braket
comma
l_int|3
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;stats.port_requested_paths
(braket
l_int|1
op_star
l_int|3
)braket
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_requested_paths
(braket
l_int|1
)braket
comma
l_int|3
)paren
suffix:semicolon
id|bp-&gt;stats.port_mac_placement
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_placement
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_mac_placement
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_placement
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_available_paths
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_available_paths
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_available_paths
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_available_paths
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_pmd_class
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pmd_class
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_pmd_class
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pmd_class
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_capabilities
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_capabilities
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_capabilities
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_capabilities
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_bs_flag
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_bs_flag
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_bs_flag
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_bs_flag
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_estimate
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_estimate
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_estimate
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_estimate
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_cutoff
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_cutoff
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_cutoff
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_cutoff
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_alarm
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_alarm
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_alarm
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_alarm
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_connect_state
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connect_state
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_connect_state
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connect_state
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_pcm_state
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pcm_state
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_pcm_state
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pcm_state
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_pc_withhold
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pc_withhold
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_pc_withhold
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pc_withhold
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_flag
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_flag
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_flag
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_flag
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_hardware_present
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_hardware_present
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_hardware_present
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_hardware_present
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Get FDDI counters */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_CNTRS_GET
suffix:semicolon
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
r_return
(paren
r_struct
id|net_device_stats
op_star
)paren
op_amp
id|bp-&gt;stats
suffix:semicolon
multiline_comment|/* Fill the bp-&gt;stats structure with the FDDI counter values */
id|bp-&gt;stats.mac_frame_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.frame_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_copied_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.copied_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_transmit_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.transmit_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_error_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.error_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_lost_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lost_cnt.ls
suffix:semicolon
id|bp-&gt;stats.port_lct_fail_cts
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lct_rejects
(braket
l_int|0
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lct_fail_cts
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lct_rejects
(braket
l_int|1
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_reject_cts
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lem_rejects
(braket
l_int|0
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_reject_cts
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lem_rejects
(braket
l_int|1
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_cts
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.link_errors
(braket
l_int|0
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_cts
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.link_errors
(braket
l_int|1
)braket
dot
id|ls
suffix:semicolon
r_return
(paren
r_struct
id|net_device_stats
op_star
)paren
op_amp
id|bp-&gt;stats
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ==============================&n; * = dfx_ctl_set_multicast_list =&n; * ==============================&n; *   &n; * Overview:&n; *   Enable/Disable LLC frame promiscuous mode reception&n; *   on the adapter and/or update multicast address table.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This routine follows a fairly simple algorithm for setting the&n; *   adapter filters and CAM:&n; *&n; *&t;&t;if IFF_PROMISC flag is set&n; *&t;&t;&t;enable LLC individual/group promiscuous mode&n; *&t;&t;else&n; *&t;&t;&t;disable LLC individual/group promiscuous mode&n; *&t;&t;&t;if number of incoming multicast addresses &gt;&n; *&t;&t;&t;&t;&t;(CAM max size - number of unicast addresses in CAM)&n; *&t;&t;&t;&t;enable LLC group promiscuous mode&n; *&t;&t;&t;&t;set driver-maintained multicast address count to zero&n; *&t;&t;&t;else&n; *&t;&t;&t;&t;disable LLC group promiscuous mode&n; *&t;&t;&t;&t;set driver-maintained multicast address count to incoming count&n; *&t;&t;&t;update adapter CAM&n; *&t;&t;update adapter filters&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   Multicast addresses are presented in canonical (LSB) format.&n; *&n; * Side Effects:&n; *   On-board adapter CAM and filters are updated.&n; */
DECL|function|dfx_ctl_set_multicast_list
r_static
r_void
id|dfx_ctl_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* used as index in for loop */
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
multiline_comment|/* ptr to multicast addr entry */
multiline_comment|/* Enable LLC frame promiscuous mode, if necessary */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|bp-&gt;ind_group_prom
op_assign
id|PI_FSTATE_K_PASS
suffix:semicolon
multiline_comment|/* Enable LLC ind/group prom mode */
multiline_comment|/* Else, update multicast address table */
r_else
(brace
id|bp-&gt;ind_group_prom
op_assign
id|PI_FSTATE_K_BLOCK
suffix:semicolon
multiline_comment|/* Disable LLC ind/group prom mode */
multiline_comment|/*&n;&t;&t; * Check whether incoming multicast address count exceeds table size&n;&t;&t; *&n;&t;&t; * Note: The adapters utilize an on-board 64 entry CAM for&n;&t;&t; *       supporting perfect filtering of multicast packets&n;&t;&t; *&t;&t; and bridge functions when adding unicast addresses.&n;&t;&t; *&t;&t; There is no hash function available.  To support&n;&t;&t; *&t;&t; additional multicast addresses, the all multicast&n;&t;&t; *&t;&t; filter (LLC group promiscuous mode) must be enabled.&n;&t;&t; *&n;&t;&t; *&t;&t; The firmware reserves two CAM entries for SMT-related&n;&t;&t; *&t;&t; multicast addresses, which leaves 62 entries available.&n;&t;&t; *&t;&t; The following code ensures that we&squot;re not being asked&n;&t;&t; *&t;&t; to add more than 62 addresses to the CAM.  If we are,&n;&t;&t; *&t;&t; the driver will enable the all multicast filter.&n;&t;&t; *&t;&t; Should the number of multicast addresses drop below&n;&t;&t; *&t;&t; the high water mark, the filter will be disabled and&n;&t;&t; *&t;&t; perfect filtering will be used.&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;mc_count
OG
(paren
id|PI_CMD_ADDR_FILTER_K_SIZE
op_minus
id|bp-&gt;uc_count
)paren
)paren
(brace
id|bp-&gt;group_prom
op_assign
id|PI_FSTATE_K_PASS
suffix:semicolon
multiline_comment|/* Enable LLC group prom mode */
id|bp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t add mc addrs to CAM */
)brace
r_else
(brace
id|bp-&gt;group_prom
op_assign
id|PI_FSTATE_K_BLOCK
suffix:semicolon
multiline_comment|/* Disable LLC group prom mode */
id|bp-&gt;mc_count
op_assign
id|dev-&gt;mc_count
suffix:semicolon
multiline_comment|/* Add mc addrs to CAM */
)brace
multiline_comment|/* Copy addresses to multicast address table, then update adapter CAM */
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
multiline_comment|/* point to first multicast addr */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;mc_table
(braket
id|i
op_star
id|FDDI_K_ALEN
)braket
comma
id|dmi-&gt;dmi_addr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
multiline_comment|/* point to next multicast addr */
)brace
r_if
c_cond
(paren
id|dfx_ctl_update_cam
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Could not update multicast address table!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Multicast address table updated!  Added %d addresses.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|bp-&gt;mc_count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Update adapter filters */
r_if
c_cond
(paren
id|dfx_ctl_update_filters
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Could not update adapter filters!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Adapter filters updated!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ===========================&n; * = dfx_ctl_set_mac_address =&n; * ===========================&n; *   &n; * Overview:&n; *   Add node address override (unicast address) to adapter&n; *   CAM and update dev_addr field in device table.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   dev  - pointer to device information&n; *   addr - pointer to sockaddr structure containing unicast address to add&n; *&n; * Functional Description:&n; *   The adapter supports node address overrides by adding one or more&n; *   unicast addresses to the adapter CAM.  This is similar to adding&n; *   multicast addresses.  In this routine we&squot;ll update the driver and&n; *   device structures with the new address, then update the adapter CAM&n; *   to ensure that the adapter will copy and strip frames destined and&n; *   sourced by that address.&n; *&n; * Return Codes:&n; *   Always returns zero.&n; *&n; * Assumptions:&n; *   The address pointed to by addr-&gt;sa_data is a valid unicast&n; *   address and is presented in canonical (LSB) format.&n; *&n; * Side Effects:&n; *   On-board adapter CAM is updated.  On-board adapter filters&n; *   may be updated.&n; */
DECL|function|dfx_ctl_set_mac_address
r_static
r_int
id|dfx_ctl_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sockaddr
op_star
id|p_sockaddr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr
suffix:semicolon
multiline_comment|/* Copy unicast address to driver-maintained structs and update count */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|p_sockaddr-&gt;sa_data
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
multiline_comment|/* update device struct */
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;uc_table
(braket
l_int|0
)braket
comma
id|p_sockaddr-&gt;sa_data
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
multiline_comment|/* update driver struct */
id|bp-&gt;uc_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Verify we&squot;re not exceeding the CAM size by adding unicast address&n;&t; *&n;&t; * Note: It&squot;s possible that before entering this routine we&squot;ve&n;&t; *       already filled the CAM with 62 multicast addresses.&n;&t; *&t;&t; Since we need to place the node address override into&n;&t; *&t;&t; the CAM, we have to check to see that we&squot;re not&n;&t; *&t;&t; exceeding the CAM size.  If we are, we have to enable&n;&t; *&t;&t; the LLC group (multicast) promiscuous mode filter as&n;&t; *&t;&t; in dfx_ctl_set_multicast_list.&n;&t; */
r_if
c_cond
(paren
(paren
id|bp-&gt;uc_count
op_plus
id|bp-&gt;mc_count
)paren
OG
id|PI_CMD_ADDR_FILTER_K_SIZE
)paren
(brace
id|bp-&gt;group_prom
op_assign
id|PI_FSTATE_K_PASS
suffix:semicolon
multiline_comment|/* Enable LLC group prom mode */
id|bp-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t add mc addrs to CAM */
multiline_comment|/* Update adapter filters */
r_if
c_cond
(paren
id|dfx_ctl_update_filters
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Could not update adapter filters!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Adapter filters updated!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Update adapter CAM with new unicast address */
r_if
c_cond
(paren
id|dfx_ctl_update_cam
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Could not set new MAC address!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG_printk
c_func
(paren
l_string|&quot;%s: Adapter CAM updated with new MAC address&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* always return zero */
)brace
"&f;"
multiline_comment|/*&n; * ======================&n; * = dfx_ctl_update_cam =&n; * ======================&n; *&n; * Overview:&n; *   Procedure to update adapter CAM (Content Addressable Memory)&n; *   with desired unicast and multicast address entries.&n; *&n; * Returns:&n; *   Condition code&n; *&n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Updates adapter CAM with current contents of board structure&n; *   unicast and multicast address tables.  Since there are only 62&n; *   free entries in CAM, this routine ensures that the command&n; *   request buffer is not overrun.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS - Request succeeded&n; *   DFX_K_FAILURE - Request failed&n; *&n; * Assumptions:&n; *   All addresses being added (unicast and multicast) are in canonical&n; *   order.&n; *&n; * Side Effects:&n; *   On-board adapter CAM is updated.&n; */
DECL|function|dfx_ctl_update_cam
r_static
r_int
id|dfx_ctl_update_cam
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* used as index */
id|PI_LAN_ADDR
op_star
id|p_addr
suffix:semicolon
multiline_comment|/* pointer to CAM entry */
multiline_comment|/*&n;&t; * Fill in command request information&n;&t; *&n;&t; * Note: Even though both the unicast and multicast address&n;&t; *       table entries are stored as contiguous 6 byte entries,&n;&t; *&t;&t; the firmware address filter set command expects each&n;&t; *&t;&t; entry to be two longwords (8 bytes total).  We must be&n;&t; *&t;&t; careful to only copy the six bytes of each unicast and&n;&t; *&t;&t; multicast table entry into each command entry.  This&n;&t; *&t;&t; is also why we must first clear the entire command&n;&t; *&t;&t; request buffer.&n;&t; */
id|memset
c_func
(paren
id|bp-&gt;cmd_req_virt
comma
l_int|0
comma
id|PI_CMD_REQ_K_SIZE_MAX
)paren
suffix:semicolon
multiline_comment|/* first clear buffer */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_ADDR_FILTER_SET
suffix:semicolon
id|p_addr
op_assign
op_amp
id|bp-&gt;cmd_req_virt-&gt;addr_filter_set.entry
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Now add unicast addresses to command request buffer, if any */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|bp-&gt;uc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|PI_CMD_ADDR_FILTER_K_SIZE
)paren
(brace
id|memcpy
c_func
(paren
id|p_addr
comma
op_amp
id|bp-&gt;uc_table
(braket
id|i
op_star
id|FDDI_K_ALEN
)braket
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|p_addr
op_increment
suffix:semicolon
multiline_comment|/* point to next command entry */
)brace
)brace
multiline_comment|/* Now add multicast addresses to command request buffer, if any */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|bp-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
id|bp-&gt;uc_count
)paren
OL
id|PI_CMD_ADDR_FILTER_K_SIZE
)paren
(brace
id|memcpy
c_func
(paren
id|p_addr
comma
op_amp
id|bp-&gt;mc_table
(braket
id|i
op_star
id|FDDI_K_ALEN
)braket
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|p_addr
op_increment
suffix:semicolon
multiline_comment|/* point to next command entry */
)brace
)brace
multiline_comment|/* Issue command to update adapter CAM, then return */
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
r_return
id|DFX_K_FAILURE
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ==========================&n; * = dfx_ctl_update_filters =&n; * ==========================&n; *&n; * Overview:&n; *   Procedure to update adapter filters with desired&n; *   filter settings.&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Enables or disables filter using current filter settings.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS - Request succeeded.&n; *   DFX_K_FAILURE - Request failed.&n; *&n; * Assumptions:&n; *   We must always pass up packets destined to the broadcast&n; *   address (FF-FF-FF-FF-FF-FF), so we&squot;ll always keep the&n; *   broadcast filter enabled.&n; *&n; * Side Effects:&n; *   On-board adapter filters are updated.&n; */
DECL|function|dfx_ctl_update_filters
r_static
r_int
id|dfx_ctl_update_filters
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used as index */
multiline_comment|/* Fill in command request information */
id|bp-&gt;cmd_req_virt-&gt;cmd_type
op_assign
id|PI_CMD_K_FILTERS_SET
suffix:semicolon
multiline_comment|/* Initialize Broadcast filter - * ALWAYS ENABLED * */
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_BROADCAST
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
op_increment
)braket
dot
id|value
op_assign
id|PI_FSTATE_K_PASS
suffix:semicolon
multiline_comment|/* Initialize LLC Individual/Group Promiscuous filter */
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_IND_GROUP_PROM
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
op_increment
)braket
dot
id|value
op_assign
id|bp-&gt;ind_group_prom
suffix:semicolon
multiline_comment|/* Initialize LLC Group Promiscuous filter */
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_GROUP_PROM
suffix:semicolon
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
op_increment
)braket
dot
id|value
op_assign
id|bp-&gt;group_prom
suffix:semicolon
multiline_comment|/* Terminate the item code list */
id|bp-&gt;cmd_req_virt-&gt;filter_set.item
(braket
id|i
)braket
dot
id|item_code
op_assign
id|PI_ITEM_K_EOL
suffix:semicolon
multiline_comment|/* Issue command to update adapter filters, then return */
r_if
c_cond
(paren
id|dfx_hw_dma_cmd_req
c_func
(paren
id|bp
)paren
op_ne
id|DFX_K_SUCCESS
)paren
r_return
id|DFX_K_FAILURE
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ======================&n; * = dfx_hw_dma_cmd_req =&n; * ======================&n; *   &n; * Overview:&n; *   Sends PDQ DMA command to adapter firmware&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   The command request and response buffers are posted to the adapter in the manner&n; *   described in the PDQ Port Specification:&n; *&n; *&t;&t;1. Command Response Buffer is posted to adapter.&n; *&t;&t;2. Command Request Buffer is posted to adapter.&n; *&t;&t;3. Command Request consumer index is polled until it indicates that request&n; *         buffer has been DMA&squot;d to adapter.&n; *&t;&t;4. Command Response consumer index is polled until it indicates that response&n; *         buffer has been DMA&squot;d from adapter.&n; *&n; *   This ordering ensures that a response buffer is already available for the firmware&n; *   to use once it&squot;s done processing the request buffer.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS&t;  - DMA command succeeded&n; * &t; DFX_K_OUTSTATE   - Adapter is NOT in proper state&n; *   DFX_K_HW_TIMEOUT - DMA command timed out&n; *&n; * Assumptions:&n; *   Command request buffer has already been filled with desired DMA command.&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_hw_dma_cmd_req
r_static
r_int
id|dfx_hw_dma_cmd_req
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* adapter status */
r_int
id|timeout_cnt
suffix:semicolon
multiline_comment|/* used in for loops */
multiline_comment|/* Make sure the adapter is in a state that we can issue the DMA command in */
id|status
op_assign
id|dfx_hw_adap_state_rd
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_eq
id|PI_STATE_K_RESET
)paren
op_logical_or
(paren
id|status
op_eq
id|PI_STATE_K_HALTED
)paren
op_logical_or
(paren
id|status
op_eq
id|PI_STATE_K_DMA_UNAVAIL
)paren
op_logical_or
(paren
id|status
op_eq
id|PI_STATE_K_UPGRADE
)paren
)paren
r_return
id|DFX_K_OUTSTATE
suffix:semicolon
multiline_comment|/* Put response buffer on the command response queue */
id|bp-&gt;descr_block_virt-&gt;cmd_rsp
(braket
id|bp-&gt;cmd_rsp_reg.index.prod
)braket
dot
id|long_0
op_assign
(paren
id|u32
)paren
(paren
id|PI_RCV_DESCR_M_SOP
op_or
(paren
(paren
id|PI_CMD_RSP_K_SIZE_MAX
op_div
id|PI_ALIGN_K_CMD_RSP_BUFF
)paren
op_lshift
id|PI_RCV_DESCR_V_SEG_LEN
)paren
)paren
suffix:semicolon
id|bp-&gt;descr_block_virt-&gt;cmd_rsp
(braket
id|bp-&gt;cmd_rsp_reg.index.prod
)braket
dot
id|long_1
op_assign
id|bp-&gt;cmd_rsp_phys
suffix:semicolon
multiline_comment|/* Bump (and wrap) the producer index and write out to register */
id|bp-&gt;cmd_rsp_reg.index.prod
op_add_assign
l_int|1
suffix:semicolon
id|bp-&gt;cmd_rsp_reg.index.prod
op_and_assign
id|PI_CMD_RSP_K_NUM_ENTRIES
op_minus
l_int|1
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_CMD_RSP_PROD
comma
id|bp-&gt;cmd_rsp_reg.lword
)paren
suffix:semicolon
multiline_comment|/* Put request buffer on the command request queue */
id|bp-&gt;descr_block_virt-&gt;cmd_req
(braket
id|bp-&gt;cmd_req_reg.index.prod
)braket
dot
id|long_0
op_assign
(paren
id|u32
)paren
(paren
id|PI_XMT_DESCR_M_SOP
op_or
id|PI_XMT_DESCR_M_EOP
op_or
(paren
id|PI_CMD_REQ_K_SIZE_MAX
op_lshift
id|PI_XMT_DESCR_V_SEG_LEN
)paren
)paren
suffix:semicolon
id|bp-&gt;descr_block_virt-&gt;cmd_req
(braket
id|bp-&gt;cmd_req_reg.index.prod
)braket
dot
id|long_1
op_assign
id|bp-&gt;cmd_req_phys
suffix:semicolon
multiline_comment|/* Bump (and wrap) the producer index and write out to register */
id|bp-&gt;cmd_req_reg.index.prod
op_add_assign
l_int|1
suffix:semicolon
id|bp-&gt;cmd_req_reg.index.prod
op_and_assign
id|PI_CMD_REQ_K_NUM_ENTRIES
op_minus
l_int|1
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_CMD_REQ_PROD
comma
id|bp-&gt;cmd_req_reg.lword
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here we wait for the command request consumer index to be equal&n;&t; * to the producer, indicating that the adapter has DMAed the request.&n;&t; */
r_for
c_loop
(paren
id|timeout_cnt
op_assign
l_int|20000
suffix:semicolon
id|timeout_cnt
OG
l_int|0
suffix:semicolon
id|timeout_cnt
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;cmd_req_reg.index.prod
op_eq
(paren
id|u8
)paren
(paren
id|bp-&gt;cons_block_virt-&gt;cmd_req
)paren
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for 100 microseconds */
)brace
r_if
c_cond
(paren
id|timeout_cnt
op_eq
l_int|0
)paren
r_return
id|DFX_K_HW_TIMEOUT
suffix:semicolon
multiline_comment|/* Bump (and wrap) the completion index and write out to register */
id|bp-&gt;cmd_req_reg.index.comp
op_add_assign
l_int|1
suffix:semicolon
id|bp-&gt;cmd_req_reg.index.comp
op_and_assign
id|PI_CMD_REQ_K_NUM_ENTRIES
op_minus
l_int|1
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_CMD_REQ_PROD
comma
id|bp-&gt;cmd_req_reg.lword
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here we wait for the command response consumer index to be equal&n;&t; * to the producer, indicating that the adapter has DMAed the response.&n;&t; */
r_for
c_loop
(paren
id|timeout_cnt
op_assign
l_int|20000
suffix:semicolon
id|timeout_cnt
OG
l_int|0
suffix:semicolon
id|timeout_cnt
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;cmd_rsp_reg.index.prod
op_eq
(paren
id|u8
)paren
(paren
id|bp-&gt;cons_block_virt-&gt;cmd_rsp
)paren
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for 100 microseconds */
)brace
r_if
c_cond
(paren
id|timeout_cnt
op_eq
l_int|0
)paren
r_return
id|DFX_K_HW_TIMEOUT
suffix:semicolon
multiline_comment|/* Bump (and wrap) the completion index and write out to register */
id|bp-&gt;cmd_rsp_reg.index.comp
op_add_assign
l_int|1
suffix:semicolon
id|bp-&gt;cmd_rsp_reg.index.comp
op_and_assign
id|PI_CMD_RSP_K_NUM_ENTRIES
op_minus
l_int|1
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_CMD_RSP_PROD
comma
id|bp-&gt;cmd_rsp_reg.lword
)paren
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ========================&n; * = dfx_hw_port_ctrl_req =&n; * ========================&n; *   &n; * Overview:&n; *   Sends PDQ port control command to adapter firmware&n; *  &n; * Returns:&n; *   Host data register value in host_data if ptr is not NULL&n; *       &n; * Arguments:&n; *   bp&t;&t;&t;- pointer to board information&n; *&t; command&t;- port control command&n; *&t; data_a&t;&t;- port data A register value&n; *&t; data_b&t;&t;- port data B register value&n; *&t; host_data&t;- ptr to host data register value&n; *&n; * Functional Description:&n; *   Send generic port control command to adapter by writing&n; *   to various PDQ port registers, then polling for completion.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS&t;  - port control command succeeded&n; *   DFX_K_HW_TIMEOUT - port control command timed out&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_hw_port_ctrl_req
r_static
r_int
id|dfx_hw_port_ctrl_req
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
id|PI_UINT32
id|command
comma
id|PI_UINT32
id|data_a
comma
id|PI_UINT32
id|data_b
comma
id|PI_UINT32
op_star
id|host_data
)paren
(brace
id|PI_UINT32
id|port_cmd
suffix:semicolon
multiline_comment|/* Port Control command register value */
r_int
id|timeout_cnt
suffix:semicolon
multiline_comment|/* used in for loops */
multiline_comment|/* Set Command Error bit in command longword */
id|port_cmd
op_assign
(paren
id|PI_UINT32
)paren
(paren
id|command
op_or
id|PI_PCTRL_M_CMD_ERROR
)paren
suffix:semicolon
multiline_comment|/* Issue port command to the adapter */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_DATA_A
comma
id|data_a
)paren
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_DATA_B
comma
id|data_b
)paren
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_CTRL
comma
id|port_cmd
)paren
suffix:semicolon
multiline_comment|/* Now wait for command to complete */
r_if
c_cond
(paren
id|command
op_eq
id|PI_PCTRL_M_BLAST_FLASH
)paren
id|timeout_cnt
op_assign
l_int|600000
suffix:semicolon
multiline_comment|/* set command timeout count to 60 seconds */
r_else
id|timeout_cnt
op_assign
l_int|20000
suffix:semicolon
multiline_comment|/* set command timeout count to 2 seconds */
r_for
c_loop
(paren
suffix:semicolon
id|timeout_cnt
OG
l_int|0
suffix:semicolon
id|timeout_cnt
op_decrement
)paren
(brace
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_CTRL
comma
op_amp
id|port_cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|port_cmd
op_amp
id|PI_PCTRL_M_CMD_ERROR
)paren
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for 100 microseconds */
)brace
r_if
c_cond
(paren
id|timeout_cnt
op_eq
l_int|0
)paren
r_return
id|DFX_K_HW_TIMEOUT
suffix:semicolon
multiline_comment|/*&n;&t; * If the address of host_data is non-zero, assume caller has supplied a  &n;&t; * non NULL pointer, and return the contents of the HOST_DATA register in &n;&t; * it.&n;&t; */
r_if
c_cond
(paren
id|host_data
op_ne
l_int|NULL
)paren
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_HOST_DATA
comma
id|host_data
)paren
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =====================&n; * = dfx_hw_adap_reset =&n; * =====================&n; *   &n; * Overview:&n; *   Resets adapter&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp   - pointer to board information&n; *   type - type of reset to perform&n; *&n; * Functional Description:&n; *   Issue soft reset to adapter by writing to PDQ Port Reset&n; *   register.  Use incoming reset type to tell adapter what&n; *   kind of reset operation to perform.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   This routine merely issues a soft reset to the adapter.&n; *   It is expected that after this routine returns, the caller&n; *   will appropriately poll the Port Status register for the&n; *   adapter to enter the proper state.&n; *&n; * Side Effects:&n; *   Internal adapter registers are cleared.&n; */
DECL|function|dfx_hw_adap_reset
r_static
r_void
id|dfx_hw_adap_reset
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
id|PI_UINT32
id|type
)paren
(brace
multiline_comment|/* Set Reset type and assert reset */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_DATA_A
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* tell adapter type of reset */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_RESET
comma
id|PI_RESET_M_ASSERT_RESET
)paren
suffix:semicolon
multiline_comment|/* Wait for at least 1 Microsecond according to the spec. We wait 20 just to be safe */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* Deassert reset */
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_RESET
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ========================&n; * = dfx_hw_adap_state_rd =&n; * ========================&n; *   &n; * Overview:&n; *   Returns current adapter state&n; *  &n; * Returns:&n; *   Adapter state per PDQ Port Specification&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Reads PDQ Port Status register and returns adapter state.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_hw_adap_state_rd
r_static
r_int
id|dfx_hw_adap_state_rd
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|PI_UINT32
id|port_status
suffix:semicolon
multiline_comment|/* Port Status register value */
id|dfx_port_read_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_PORT_STATUS
comma
op_amp
id|port_status
)paren
suffix:semicolon
r_return
(paren
id|port_status
op_amp
id|PI_PSTATUS_M_STATE
)paren
op_rshift
id|PI_PSTATUS_V_STATE
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =====================&n; * = dfx_hw_dma_uninit =&n; * =====================&n; *   &n; * Overview:&n; *   Brings adapter to DMA_UNAVAILABLE state&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   bp   - pointer to board information&n; *   type - type of reset to perform&n; *&n; * Functional Description:&n; *   Bring adapter to DMA_UNAVAILABLE state by performing the following:&n; *&t;&t;1. Set reset type bit in Port Data A Register then reset adapter.&n; *&t;&t;2. Check that adapter is in DMA_UNAVAILABLE state.&n; *&n; * Return Codes:&n; *   DFX_K_SUCCESS&t;  - adapter is in DMA_UNAVAILABLE state&n; *   DFX_K_HW_TIMEOUT - adapter did not reset properly&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   Internal adapter registers are cleared.&n; */
DECL|function|dfx_hw_dma_uninit
r_static
r_int
id|dfx_hw_dma_uninit
c_func
(paren
id|DFX_board_t
op_star
id|bp
comma
id|PI_UINT32
id|type
)paren
(brace
r_int
id|timeout_cnt
suffix:semicolon
multiline_comment|/* used in for loops */
multiline_comment|/* Set reset type bit and reset adapter */
id|dfx_hw_adap_reset
c_func
(paren
id|bp
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Now wait for adapter to enter DMA_UNAVAILABLE state */
r_for
c_loop
(paren
id|timeout_cnt
op_assign
l_int|100000
suffix:semicolon
id|timeout_cnt
OG
l_int|0
suffix:semicolon
id|timeout_cnt
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|dfx_hw_adap_state_rd
c_func
(paren
id|bp
)paren
op_eq
id|PI_STATE_K_DMA_UNAVAIL
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for 100 microseconds */
)brace
r_if
c_cond
(paren
id|timeout_cnt
op_eq
l_int|0
)paren
r_return
id|DFX_K_HW_TIMEOUT
suffix:semicolon
r_return
id|DFX_K_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Align an sk_buff to a boundary power of 2&n; *&n; */
DECL|function|my_skb_align
r_static
r_void
id|my_skb_align
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|n
)paren
(brace
id|u32
id|x
op_assign
(paren
id|u32
)paren
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* We only want the low bits .. */
id|u32
id|v
suffix:semicolon
id|v
op_assign
(paren
id|x
op_plus
id|n
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|n
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Where we want to be */
id|skb_reserve
c_func
(paren
id|skb
comma
id|v
op_minus
id|x
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * ================&n; * = dfx_rcv_init =&n; * ================&n; *   &n; * Overview:&n; *   Produces buffers to adapter LLC Host receive descriptor block&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   This routine can be called during dfx_adap_init() or during an adapter&n; *&t; reset.  It initializes the descriptor block and produces all allocated&n; *   LLC Host queue receive buffers.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   The PDQ has been reset and the adapter and driver maintained Type 2&n; *   register indices are cleared.&n; *&n; * Side Effects:&n; *   Receive buffers are posted to the adapter LLC queue and the adapter&n; *   is notified.&n; */
DECL|function|dfx_rcv_init
r_static
r_void
id|dfx_rcv_init
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* used in for loop */
multiline_comment|/*&n;&t; *  Since each receive buffer is a single fragment of same length, initialize&n;&t; *  first longword in each receive descriptor for entire LLC Host descriptor&n;&t; *  block.  Also initialize second longword in each receive descriptor with&n;&t; *  physical address of receive buffer.  We&squot;ll always allocate receive&n;&t; *  buffers in powers of 2 so that we can easily fill the 256 entry descriptor&n;&t; *  block and produce new receive buffers by simply updating the receive&n;&t; *  producer index.&n;&t; *&n;&t; * &t;Assumptions:&n;&t; *&t;&t;To support all shipping versions of PDQ, the receive buffer size&n;&t; *&t;&t;must be mod 128 in length and the physical address must be 128 byte&n;&t; *&t;&t;aligned.  In other words, bits 0-6 of the length and address must&n;&t; *&t;&t;be zero for the following descriptor field entries to be correct on&n;&t; *&t;&t;all PDQ-based boards.  We guaranteed both requirements during&n;&t; *&t;&t;driver initialization when we allocated memory for the receive buffers.&n;&t; */
macro_line|#ifdef DYNAMIC_BUFFERS
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
(paren
id|bp-&gt;rcv_bufs_to_post
)paren
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|i
op_plus
id|j
)paren
OL
(paren
r_int
)paren
id|PI_RCV_DATA_K_NUM_ENTRIES
suffix:semicolon
id|j
op_add_assign
id|bp-&gt;rcv_bufs_to_post
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
suffix:semicolon
id|bp-&gt;descr_block_virt-&gt;rcv_data
(braket
id|i
op_plus
id|j
)braket
dot
id|long_0
op_assign
(paren
id|u32
)paren
(paren
id|PI_RCV_DESCR_M_SOP
op_or
(paren
(paren
id|PI_RCV_DATA_K_SIZE_MAX
op_div
id|PI_ALIGN_K_RCV_DATA_BUFF
)paren
op_lshift
id|PI_RCV_DESCR_V_SEG_LEN
)paren
)paren
suffix:semicolon
id|newskb
op_assign
id|dev_alloc_skb
c_func
(paren
id|NEW_SKB_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * align to 128 bytes for compatibility with&n;&t;&t;&t; * the old EISA boards.&n;&t;&t;&t; */
id|my_skb_align
c_func
(paren
id|newskb
comma
l_int|128
)paren
suffix:semicolon
id|bp-&gt;descr_block_virt-&gt;rcv_data
(braket
id|i
op_plus
id|j
)braket
dot
id|long_1
op_assign
id|virt_to_bus
c_func
(paren
id|newskb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * p_rcv_buff_va is only used inside the&n;&t;&t;&t; * kernel so we put the skb pointer here.&n;&t;&t;&t; */
id|bp-&gt;p_rcv_buff_va
(braket
id|i
op_plus
id|j
)braket
op_assign
(paren
r_char
op_star
)paren
id|newskb
suffix:semicolon
)brace
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
(paren
id|bp-&gt;rcv_bufs_to_post
)paren
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|i
op_plus
id|j
)paren
OL
(paren
r_int
)paren
id|PI_RCV_DATA_K_NUM_ENTRIES
suffix:semicolon
id|j
op_add_assign
id|bp-&gt;rcv_bufs_to_post
)paren
(brace
id|bp-&gt;descr_block_virt-&gt;rcv_data
(braket
id|i
op_plus
id|j
)braket
dot
id|long_0
op_assign
(paren
id|u32
)paren
(paren
id|PI_RCV_DESCR_M_SOP
op_or
(paren
(paren
id|PI_RCV_DATA_K_SIZE_MAX
op_div
id|PI_ALIGN_K_RCV_DATA_BUFF
)paren
op_lshift
id|PI_RCV_DESCR_V_SEG_LEN
)paren
)paren
suffix:semicolon
id|bp-&gt;descr_block_virt-&gt;rcv_data
(braket
id|i
op_plus
id|j
)braket
dot
id|long_1
op_assign
(paren
id|u32
)paren
(paren
id|bp-&gt;rcv_block_phys
op_plus
(paren
id|i
op_star
id|PI_RCV_DATA_K_SIZE_MAX
)paren
)paren
suffix:semicolon
id|bp-&gt;p_rcv_buff_va
(braket
id|i
op_plus
id|j
)braket
op_assign
(paren
r_char
op_star
)paren
(paren
id|bp-&gt;rcv_block_virt
op_plus
(paren
id|i
op_star
id|PI_RCV_DATA_K_SIZE_MAX
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Update receive producer and Type 2 register */
id|bp-&gt;rcv_xmt_reg.index.rcv_prod
op_assign
id|bp-&gt;rcv_bufs_to_post
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_TYPE_2_PROD
comma
id|bp-&gt;rcv_xmt_reg.lword
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =========================&n; * = dfx_rcv_queue_process =&n; * =========================&n; *   &n; * Overview:&n; *   Process received LLC frames.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   Received LLC frames are processed until there are no more consumed frames.&n; *   Once all frames are processed, the receive buffers are returned to the&n; *   adapter.  Note that this algorithm fixes the length of time that can be spent&n; *   in this routine, because there are a fixed number of receive buffers to&n; *   process and buffers are not produced until this routine exits and returns&n; *   to the ISR.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   None&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_rcv_queue_process
r_static
r_void
id|dfx_rcv_queue_process
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|PI_TYPE_2_CONSUMER
op_star
id|p_type_2_cons
suffix:semicolon
multiline_comment|/* ptr to rcv/xmt consumer block register */
r_char
op_star
id|p_buff
suffix:semicolon
multiline_comment|/* ptr to start of packet receive buffer (FMC descriptor) */
id|u32
id|descr
comma
id|pkt_len
suffix:semicolon
multiline_comment|/* FMC descriptor field and packet length */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* pointer to a sk_buff to hold incoming packet data */
multiline_comment|/* Service all consumed LLC receive frames */
id|p_type_2_cons
op_assign
(paren
id|PI_TYPE_2_CONSUMER
op_star
)paren
(paren
op_amp
id|bp-&gt;cons_block_virt-&gt;xmt_rcv_data
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bp-&gt;rcv_xmt_reg.index.rcv_comp
op_ne
id|p_type_2_cons-&gt;index.rcv_cons
)paren
(brace
multiline_comment|/* Process any errors */
r_int
id|entry
suffix:semicolon
id|entry
op_assign
id|bp-&gt;rcv_xmt_reg.index.rcv_comp
suffix:semicolon
macro_line|#ifdef DYNAMIC_BUFFERS
id|p_buff
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|bp-&gt;p_rcv_buff_va
(braket
id|entry
)braket
)paren
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
macro_line|#else
id|p_buff
op_assign
(paren
r_char
op_star
)paren
id|bp-&gt;p_rcv_buff_va
(braket
id|entry
)braket
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
op_amp
id|descr
comma
id|p_buff
op_plus
id|RCV_BUFF_K_DESCR
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|descr
op_amp
id|PI_FMC_DESCR_M_RCC_FLUSH
)paren
(brace
r_if
c_cond
(paren
id|descr
op_amp
id|PI_FMC_DESCR_M_RCC_CRC
)paren
id|bp-&gt;rcv_crc_errors
op_increment
suffix:semicolon
r_else
id|bp-&gt;rcv_frame_status_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_int
id|rx_in_place
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The frame was received without errors - verify packet length */
id|pkt_len
op_assign
(paren
id|u32
)paren
(paren
(paren
id|descr
op_amp
id|PI_FMC_DESCR_M_LEN
)paren
op_rshift
id|PI_FMC_DESCR_V_LEN
)paren
suffix:semicolon
id|pkt_len
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* subtract 4 byte CRC */
r_if
c_cond
(paren
op_logical_neg
id|IN_RANGE
c_func
(paren
id|pkt_len
comma
id|FDDI_K_LLC_ZLEN
comma
id|FDDI_K_LLC_LEN
)paren
)paren
id|bp-&gt;rcv_length_errors
op_increment
suffix:semicolon
r_else
(brace
macro_line|#ifdef DYNAMIC_BUFFERS
r_if
c_cond
(paren
id|pkt_len
OG
id|SKBUFF_RX_COPYBREAK
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
suffix:semicolon
id|newskb
op_assign
id|dev_alloc_skb
c_func
(paren
id|NEW_SKB_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
)paren
(brace
id|rx_in_place
op_assign
l_int|1
suffix:semicolon
id|my_skb_align
c_func
(paren
id|newskb
comma
l_int|128
)paren
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|bp-&gt;p_rcv_buff_va
(braket
id|entry
)braket
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|RCV_BUFF_K_PADDING
)paren
suffix:semicolon
id|bp-&gt;p_rcv_buff_va
(braket
id|entry
)braket
op_assign
(paren
r_char
op_star
)paren
id|newskb
suffix:semicolon
id|bp-&gt;descr_block_virt-&gt;rcv_data
(braket
id|entry
)braket
dot
id|long_1
op_assign
id|virt_to_bus
c_func
(paren
id|newskb-&gt;data
)paren
suffix:semicolon
)brace
r_else
id|skb
op_assign
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* alloc new buffer to pass up, add room for PRH */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not allocate receive buffer.  Dropping packet.&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|bp-&gt;rcv_discards
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef DYNAMIC_BUFFERS
r_if
c_cond
(paren
op_logical_neg
id|rx_in_place
)paren
macro_line|#endif
(brace
multiline_comment|/* Receive buffer allocated, pass receive packet up */
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|p_buff
op_plus
id|RCV_BUFF_K_PADDING
comma
id|pkt_len
op_plus
l_int|3
)paren
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* adjust data field so that it points to FC byte */
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* pass up packet length, NOT including CRC */
id|skb-&gt;dev
op_assign
id|bp-&gt;dev
suffix:semicolon
multiline_comment|/* pass up device pointer */
id|skb-&gt;protocol
op_assign
id|fddi_type_trans
c_func
(paren
id|skb
comma
id|bp-&gt;dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Update the rcv counters */
id|bp-&gt;rcv_total_frames
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|p_buff
op_plus
id|RCV_BUFF_K_DA
)paren
op_amp
l_int|0x01
)paren
id|bp-&gt;rcv_multicast_frames
op_increment
suffix:semicolon
id|bp-&gt;rcv_total_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Advance the producer (for recycling) and advance the completion&n;&t;&t; * (for servicing received frames).  Note that it is okay to&n;&t;&t; * advance the producer without checking that it passes the&n;&t;&t; * completion index because they are both advanced at the same&n;&t;&t; * rate.&n;&t;&t; */
id|bp-&gt;rcv_xmt_reg.index.rcv_prod
op_add_assign
l_int|1
suffix:semicolon
id|bp-&gt;rcv_xmt_reg.index.rcv_comp
op_add_assign
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =====================&n; * = dfx_xmt_queue_pkt =&n; * =====================&n; *   &n; * Overview:&n; *   Queues packets for transmission&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   skb - pointer to sk_buff to queue for transmission&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   Here we assume that an incoming skb transmit request&n; *   is contained in a single physically contiguous buffer&n; *   in which the virtual address of the start of packet&n; *   (skb-&gt;data) can be converted to a physical address&n; *   by using virt_to_bus().&n; *&n; *   Since the adapter architecture requires a three byte&n; *   packet request header to prepend the start of packet,&n; *   we&squot;ll write the three byte field immediately prior to&n; *   the FC byte.  This assumption is valid because we&squot;ve&n; *   ensured that dev-&gt;hard_header_len includes three pad&n; *   bytes.  By posting a single fragment to the adapter,&n; *   we&squot;ll reduce the number of descriptor fetches and&n; *   bus traffic needed to send the request.&n; *&n; *   Also, we can&squot;t free the skb until after it&squot;s been DMA&squot;d&n; *   out by the adapter, so we&squot;ll queue it in the driver and&n; *   return it in dfx_xmt_done.&n; *&n; * Return Codes:&n; *   0 - driver queued packet, link is unavailable, or skbuff was bad&n; *&t; 1 - caller should requeue the sk_buff for later transmission&n; *&n; * Assumptions:&n; *&t; First and foremost, we assume the incoming skb pointer&n; *   is NOT NULL and is pointing to a valid sk_buff structure.&n; *&n; *   The outgoing packet is complete, starting with the&n; *   frame control byte including the last byte of data,&n; *   but NOT including the 4 byte CRC.  We&squot;ll let the&n; *   adapter hardware generate and append the CRC.&n; *&n; *   The entire packet is stored in one physically&n; *   contiguous buffer which is not cached and whose&n; *   32-bit physical address can be determined.&n; *&n; *   It&squot;s vital that this routine is NOT reentered for the&n; *   same board and that the OS is not in another section of&n; *   code (eg. dfx_int_common) for the same board on a&n; *   different thread.&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_xmt_queue_pkt
r_static
r_int
id|dfx_xmt_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u8
id|prod
suffix:semicolon
multiline_comment|/* local transmit producer index */
id|PI_XMT_DESCR
op_star
id|p_xmt_descr
suffix:semicolon
multiline_comment|/* ptr to transmit descriptor block entry */
id|XMT_DRIVER_DESCR
op_star
id|p_xmt_drv_descr
suffix:semicolon
multiline_comment|/* ptr to transmit driver descriptor */
r_int
r_int
id|flags
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that incoming transmit request is OK&n;&t; *&n;&t; * Note: The packet size check is consistent with other&n;&t; *&t;&t; Linux device drivers, although the correct packet&n;&t; *&t;&t; size should be verified before calling the&n;&t; *&t;&t; transmit routine.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|IN_RANGE
c_func
(paren
id|skb-&gt;len
comma
id|FDDI_K_LLC_ZLEN
comma
id|FDDI_K_LLC_LEN
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Invalid packet length - %u bytes&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|bp-&gt;xmt_length_errors
op_increment
suffix:semicolon
multiline_comment|/* bump error counter */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* return &quot;success&quot; */
)brace
multiline_comment|/*&n;&t; * See if adapter link is available, if not, free buffer&n;&t; *&n;&t; * Note: If the link isn&squot;t available, free buffer and return 0&n;&t; *&t;&t; rather than tell the upper layer to requeue the packet.&n;&t; *&t;&t; The methodology here is that by the time the link&n;&t; *&t;&t; becomes available, the packet to be sent will be&n;&t; *&t;&t; fairly stale.  By simply dropping the packet, the&n;&t; *&t;&t; higher layer protocols will eventually time out&n;&t; *&t;&t; waiting for response packets which it won&squot;t receive.&n;&t; */
r_if
c_cond
(paren
id|bp-&gt;link_available
op_eq
id|PI_K_FALSE
)paren
(brace
r_if
c_cond
(paren
id|dfx_hw_adap_state_rd
c_func
(paren
id|bp
)paren
op_eq
id|PI_STATE_K_LINK_AVAIL
)paren
multiline_comment|/* is link really available? */
id|bp-&gt;link_available
op_assign
id|PI_K_TRUE
suffix:semicolon
multiline_comment|/* if so, set flag and continue */
r_else
(brace
id|bp-&gt;xmt_discards
op_increment
suffix:semicolon
multiline_comment|/* bump error counter */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* free sk_buff now */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* return &quot;success&quot; */
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get the current producer and the next free xmt data descriptor */
id|prod
op_assign
id|bp-&gt;rcv_xmt_reg.index.xmt_prod
suffix:semicolon
id|p_xmt_descr
op_assign
op_amp
(paren
id|bp-&gt;descr_block_virt-&gt;xmt_data
(braket
id|prod
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get pointer to auxiliary queue entry to contain information&n;&t; * for this packet.&n;&t; *&n;&t; * Note: The current xmt producer index will become the&n;&t; *&t; current xmt completion index when we complete this&n;&t; *&t; packet later on.  So, we&squot;ll get the pointer to the&n;&t; *&t; next auxiliary queue entry now before we bump the&n;&t; *&t; producer index.&n;&t; */
id|p_xmt_drv_descr
op_assign
op_amp
(paren
id|bp-&gt;xmt_drv_descr_blk
(braket
id|prod
op_increment
)braket
)paren
suffix:semicolon
multiline_comment|/* also bump producer index */
multiline_comment|/* Write the three PRH bytes immediately before the FC byte */
id|skb_push
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|DFX_PRH0_BYTE
suffix:semicolon
multiline_comment|/* these byte values are defined */
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|DFX_PRH1_BYTE
suffix:semicolon
multiline_comment|/* in the Motorola FDDI MAC chip */
id|skb-&gt;data
(braket
l_int|2
)braket
op_assign
id|DFX_PRH2_BYTE
suffix:semicolon
multiline_comment|/* specification */
multiline_comment|/*&n;&t; * Write the descriptor with buffer info and bump producer&n;&t; *&n;&t; * Note: Since we need to start DMA from the packet request&n;&t; *&t;&t; header, we&squot;ll add 3 bytes to the DMA buffer length,&n;&t; *&t;&t; and we&squot;ll determine the physical address of the&n;&t; *&t;&t; buffer from the PRH, not skb-&gt;data.&n;&t; *&n;&t; * Assumptions:&n;&t; *&t;&t; 1. Packet starts with the frame control (FC) byte&n;&t; *&t;&t;    at skb-&gt;data.&n;&t; *&t;&t; 2. The 4-byte CRC is not appended to the buffer or&n;&t; *&t;&t;&t;included in the length.&n;&t; *&t;&t; 3. Packet length (skb-&gt;len) is from FC to end of&n;&t; *&t;&t;&t;data, inclusive.&n;&t; *&t;&t; 4. The packet length does not exceed the maximum&n;&t; *&t;&t;&t;FDDI LLC frame length of 4491 bytes.&n;&t; *&t;&t; 5. The entire packet is contained in a physically&n;&t; *&t;&t;&t;contiguous, non-cached, locked memory space&n;&t; *&t;&t;&t;comprised of a single buffer pointed to by&n;&t; *&t;&t;&t;skb-&gt;data.&n;&t; *&t;&t; 6. The physical address of the start of packet&n;&t; *&t;&t;&t;can be determined from the virtual address&n;&t; *&t;&t;&t;by using virt_to_bus() and is only 32-bits&n;&t; *&t;&t;&t;wide.&n;&t; */
id|p_xmt_descr-&gt;long_0
op_assign
(paren
id|u32
)paren
(paren
id|PI_XMT_DESCR_M_SOP
op_or
id|PI_XMT_DESCR_M_EOP
op_or
(paren
(paren
id|skb-&gt;len
)paren
op_lshift
id|PI_XMT_DESCR_V_SEG_LEN
)paren
)paren
suffix:semicolon
id|p_xmt_descr-&gt;long_1
op_assign
(paren
id|u32
)paren
id|virt_to_bus
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that descriptor is actually available&n;&t; *&n;&t; * Note: If descriptor isn&squot;t available, return 1 which tells&n;&t; *&t; the upper layer to requeue the packet for later&n;&t; *&t; transmission.&n;&t; *&n;&t; *       We need to ensure that the producer never reaches the&n;&t; *&t; completion, except to indicate that the queue is empty.&n;&t; */
r_if
c_cond
(paren
id|prod
op_eq
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
)paren
(brace
id|skb_pull
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* requeue packet for later */
)brace
multiline_comment|/*&n;&t; * Save info for this packet for xmt done indication routine&n;&t; *&n;&t; * Normally, we&squot;d save the producer index in the p_xmt_drv_descr&n;&t; * structure so that we&squot;d have it handy when we complete this&n;&t; * packet later (in dfx_xmt_done).  However, since the current&n;&t; * transmit architecture guarantees a single fragment for the&n;&t; * entire packet, we can simply bump the completion index by&n;&t; * one (1) for each completed packet.&n;&t; *&n;&t; * Note: If this assumption changes and we&squot;re presented with&n;&t; *&t; an inconsistent number of transmit fragments for packet&n;&t; *&t; data, we&squot;ll need to modify this code to save the current&n;&t; *&t; transmit producer index.&n;&t; */
id|p_xmt_drv_descr-&gt;p_skb
op_assign
id|skb
suffix:semicolon
multiline_comment|/* Update Type 2 register */
id|bp-&gt;rcv_xmt_reg.index.xmt_prod
op_assign
id|prod
suffix:semicolon
id|dfx_port_write_long
c_func
(paren
id|bp
comma
id|PI_PDQ_K_REG_TYPE_2_PROD
comma
id|bp-&gt;rcv_xmt_reg.lword
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* packet queued to adapter */
)brace
"&f;"
multiline_comment|/*&n; * ================&n; * = dfx_xmt_done =&n; * ================&n; *   &n; * Overview:&n; *   Processes all frames that have been transmitted.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   For all consumed transmit descriptors that have not&n; *   yet been completed, we&squot;ll free the skb we were holding&n; *   onto using dev_kfree_skb and bump the appropriate&n; *   counters.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   The Type 2 register is not updated in this routine.  It is&n; *   assumed that it will be updated in the ISR when dfx_xmt_done&n; *   returns.&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_xmt_done
r_static
r_int
id|dfx_xmt_done
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|XMT_DRIVER_DESCR
op_star
id|p_xmt_drv_descr
suffix:semicolon
multiline_comment|/* ptr to transmit driver descriptor */
id|PI_TYPE_2_CONSUMER
op_star
id|p_type_2_cons
suffix:semicolon
multiline_comment|/* ptr to rcv/xmt consumer block register */
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* buffers freed */
multiline_comment|/* Service all consumed transmit frames */
id|p_type_2_cons
op_assign
(paren
id|PI_TYPE_2_CONSUMER
op_star
)paren
(paren
op_amp
id|bp-&gt;cons_block_virt-&gt;xmt_rcv_data
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
op_ne
id|p_type_2_cons-&gt;index.xmt_cons
)paren
(brace
multiline_comment|/* Get pointer to the transmit driver descriptor block information */
id|p_xmt_drv_descr
op_assign
op_amp
(paren
id|bp-&gt;xmt_drv_descr_blk
(braket
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
)braket
)paren
suffix:semicolon
multiline_comment|/* Increment transmit counters */
id|bp-&gt;xmt_total_frames
op_increment
suffix:semicolon
id|bp-&gt;xmt_total_bytes
op_add_assign
id|p_xmt_drv_descr-&gt;p_skb-&gt;len
suffix:semicolon
multiline_comment|/* Return skb to operating system */
id|dev_kfree_skb_irq
c_func
(paren
id|p_xmt_drv_descr-&gt;p_skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move to start of next packet by updating completion index&n;&t;&t; *&n;&t;&t; * Here we assume that a transmit packet request is always&n;&t;&t; * serviced by posting one fragment.  We can therefore&n;&t;&t; * simplify the completion code by incrementing the&n;&t;&t; * completion index by one.  This code will need to be&n;&t;&t; * modified if this assumption changes.  See comments&n;&t;&t; * in dfx_xmt_queue_pkt for more details.&n;&t;&t; */
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
op_add_assign
l_int|1
suffix:semicolon
id|freed
op_increment
suffix:semicolon
)brace
r_return
id|freed
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * =================&n; * = dfx_xmt_flush =&n; * =================&n; *   &n; * Overview:&n; *   Processes all frames whether they&squot;ve been transmitted&n; *   or not.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   bp - pointer to board information&n; *&n; * Functional Description:&n; *   For all produced transmit descriptors that have not&n; *   yet been completed, we&squot;ll free the skb we were holding&n; *   onto using dev_kfree_skb and bump the appropriate&n; *   counters.  Of course, it&squot;s possible that some of&n; *   these transmit requests actually did go out, but we&n; *   won&squot;t make that distinction here.  Finally, we&squot;ll&n; *   update the consumer index to match the producer.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   This routine does NOT update the Type 2 register.  It&n; *   is assumed that this routine is being called during a&n; *   transmit flush interrupt, or a shutdown or close routine.&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|dfx_xmt_flush
r_static
r_void
id|dfx_xmt_flush
c_func
(paren
id|DFX_board_t
op_star
id|bp
)paren
(brace
id|u32
id|prod_cons
suffix:semicolon
multiline_comment|/* rcv/xmt consumer block longword */
id|XMT_DRIVER_DESCR
op_star
id|p_xmt_drv_descr
suffix:semicolon
multiline_comment|/* ptr to transmit driver descriptor */
multiline_comment|/* Flush all outstanding transmit frames */
r_while
c_loop
(paren
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
op_ne
id|bp-&gt;rcv_xmt_reg.index.xmt_prod
)paren
(brace
multiline_comment|/* Get pointer to the transmit driver descriptor block information */
id|p_xmt_drv_descr
op_assign
op_amp
(paren
id|bp-&gt;xmt_drv_descr_blk
(braket
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
)braket
)paren
suffix:semicolon
multiline_comment|/* Return skb to operating system */
id|dev_kfree_skb
c_func
(paren
id|p_xmt_drv_descr-&gt;p_skb
)paren
suffix:semicolon
multiline_comment|/* Increment transmit error counter */
id|bp-&gt;xmt_discards
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move to start of next packet by updating completion index&n;&t;&t; *&n;&t;&t; * Here we assume that a transmit packet request is always&n;&t;&t; * serviced by posting one fragment.  We can therefore&n;&t;&t; * simplify the completion code by incrementing the&n;&t;&t; * completion index by one.  This code will need to be&n;&t;&t; * modified if this assumption changes.  See comments&n;&t;&t; * in dfx_xmt_queue_pkt for more details.&n;&t;&t; */
id|bp-&gt;rcv_xmt_reg.index.xmt_comp
op_add_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update the transmit consumer index in the consumer block */
id|prod_cons
op_assign
(paren
id|u32
)paren
(paren
id|bp-&gt;cons_block_virt-&gt;xmt_rcv_data
op_amp
op_complement
id|PI_CONS_M_XMT_INDEX
)paren
suffix:semicolon
id|prod_cons
op_or_assign
(paren
id|u32
)paren
(paren
id|bp-&gt;rcv_xmt_reg.index.xmt_prod
op_lshift
id|PI_CONS_V_XMT_INDEX
)paren
suffix:semicolon
id|bp-&gt;cons_block_virt-&gt;xmt_rcv_data
op_assign
id|prod_cons
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|dfx_remove_one_pci_or_eisa
r_static
r_void
id|__devexit
id|dfx_remove_one_pci_or_eisa
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|DFX_board_t
op_star
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|pdev
ques
c_cond
id|PFI_K_CSR_IO_LEN
suffix:colon
id|PI_ESIC_K_CSR_IO_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;kmalloced
)paren
id|kfree
c_func
(paren
id|bp-&gt;kmalloced
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|dfx_remove_one
r_static
r_void
id|__devexit
id|dfx_remove_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|pdev-&gt;driver_data
suffix:semicolon
id|dfx_remove_one_pci_or_eisa
c_func
(paren
id|pdev
comma
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|dfx_pci_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_DEC
comma
id|PCI_DEVICE_ID_DEC_FDDI
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|dfx_pci_tbl
)paren
suffix:semicolon
DECL|variable|dfx_driver
r_static
r_struct
id|pci_driver
id|dfx_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;defxx&quot;
comma
id|probe
suffix:colon
id|dfx_init_one
comma
id|remove
suffix:colon
id|dfx_remove_one
comma
id|id_table
suffix:colon
id|dfx_pci_tbl
comma
)brace
suffix:semicolon
DECL|variable|dfx_have_pci
r_static
r_int
id|dfx_have_pci
suffix:semicolon
DECL|variable|dfx_have_eisa
r_static
r_int
id|dfx_have_eisa
suffix:semicolon
DECL|function|dfx_eisa_cleanup
r_static
r_void
id|__exit
id|dfx_eisa_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|root_dfx_eisa_dev
suffix:semicolon
r_while
c_loop
(paren
id|dev
)paren
(brace
r_struct
id|net_device
op_star
id|tmp
suffix:semicolon
id|DFX_board_t
op_star
id|bp
suffix:semicolon
id|bp
op_assign
(paren
id|DFX_board_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|tmp
op_assign
id|bp-&gt;next
suffix:semicolon
id|dfx_remove_one_pci_or_eisa
c_func
(paren
l_int|NULL
comma
id|dev
)paren
suffix:semicolon
id|dev
op_assign
id|tmp
suffix:semicolon
)brace
)brace
DECL|function|dfx_init
r_static
r_int
id|__init
id|dfx_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc_pci
comma
id|rc_eisa
suffix:semicolon
id|rc_pci
op_assign
id|pci_module_init
c_func
(paren
op_amp
id|dfx_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc_pci
op_ge
l_int|0
)paren
id|dfx_have_pci
op_assign
l_int|1
suffix:semicolon
id|rc_eisa
op_assign
id|dfx_eisa_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc_eisa
op_ge
l_int|0
)paren
id|dfx_have_eisa
op_assign
l_int|1
suffix:semicolon
r_return
(paren
(paren
id|rc_eisa
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|rc_eisa
)paren
op_plus
(paren
(paren
id|rc_pci
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|rc_pci
)paren
suffix:semicolon
)brace
DECL|function|dfx_cleanup
r_static
r_void
id|__exit
id|dfx_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|dfx_have_pci
)paren
id|pci_unregister_driver
c_func
(paren
op_amp
id|dfx_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfx_have_eisa
)paren
id|dfx_eisa_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|dfx_init
id|module_init
c_func
(paren
id|dfx_init
)paren
suffix:semicolon
DECL|variable|dfx_cleanup
id|module_exit
c_func
(paren
id|dfx_cleanup
)paren
suffix:semicolon
"&f;"
multiline_comment|/*&n; * Local variables:&n; * kernel-compile-command: &quot;gcc -D__KERNEL__ -I/root/linux/include -Wall -Wstrict-prototypes -O2 -pipe -fomit-frame-pointer -fno-strength-reduce -m486 -malign-loops=2 -malign-jumps=2 -malign-functions=2 -c defxx.c&quot;&n; * End:&n; */
eof
