multiline_comment|/* $Id: cosa.c,v 1.31 2000/03/08 17:47:16 kas Exp $ */
multiline_comment|/*&n; *  Copyright (C) 1995-1997  Jan &quot;Yenya&quot; Kasprzak &lt;kas@fi.muni.cz&gt;&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * The driver for the SRP and COSA synchronous serial cards.&n; *&n; * HARDWARE INFO&n; *&n; * Both cards are developed at the Institute of Computer Science,&n; * Masaryk University (http://www.ics.muni.cz/). The hardware is&n; * developed by Jiri Novotny &lt;novotny@ics.muni.cz&gt;. More information&n; * and the photo of both cards is available at&n; * http://www.pavoucek.cz/cosa.html. The card documentation, firmwares&n; * and other goods can be downloaded from ftp://ftp.ics.muni.cz/pub/cosa/.&n; * For Linux-specific utilities, see below in the &quot;Software info&quot; section.&n; * If you want to order the card, contact Jiri Novotny.&n; *&n; * The SRP (serial port?, the Czech word &quot;srp&quot; means &quot;sickle&quot;) card&n; * is a 2-port intelligent (with its own 8-bit CPU) synchronous serial card&n; * with V.24 interfaces up to 80kb/s each.&n; *&n; * The COSA (communication serial adapter?, the Czech word &quot;kosa&quot; means&n; * &quot;scythe&quot;) is a next-generation sync/async board with two interfaces&n; * - currently any of V.24, X.21, V.35 and V.36 can be selected.&n; * It has a 16-bit SAB80166 CPU and can do up to 10 Mb/s per channel.&n; * The 8-channels version is in development.&n; *&n; * Both types have downloadable firmware and communicate via ISA DMA.&n; * COSA can be also a bus-mastering device.&n; *&n; * SOFTWARE INFO&n; *&n; * The homepage of the Linux driver is at http://www.fi.muni.cz/~kas/cosa/.&n; * The CVS tree of Linux driver can be viewed there, as well as the&n; * firmware binaries and user-space utilities for downloading the firmware&n; * into the card and setting up the card.&n; *&n; * The Linux driver (unlike the present *BSD drivers :-) can work even&n; * for the COSA and SRP in one computer and allows each channel to work&n; * in one of the three modes (character device, Cisco HDLC, Sync PPP).&n; *&n; * AUTHOR&n; *&n; * The Linux driver was written by Jan &quot;Yenya&quot; Kasprzak &lt;kas@fi.muni.cz&gt;.&n; *&n; * You can mail me bugfixes and even success reports. I am especially&n; * interested in the SMP and/or muliti-channel success/failure reports&n; * (I wonder if I did the locking properly :-).&n; *&n; * THE AUTHOR USED THE FOLLOWING SOURCES WHEN PROGRAMMING THE DRIVER&n; *&n; * The COSA/SRP NetBSD driver by Zdenek Salvet and Ivos Cernohlavek&n; * The skeleton.c by Donald Becker&n; * The SDL Riscom/N2 driver by Mike Natale&n; * The Comtrol Hostess SV11 driver by Alan Cox&n; * The Sync PPP/Cisco HDLC layer (syncppp.c) ported to Linux by Alan Cox&n; */
multiline_comment|/*&n; *     5/25/1999 : Marcelo Tosatti &lt;marcelo@conectiva.com.br&gt;&n; *             fixed a deadlock in cosa_sppp_open&n; */
"&f;"
multiline_comment|/* ---------- Headers, macros, data structures ---------- */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|COSA_SLOW_IO
macro_line|#undef COSA_SLOW_IO&t;/* for testing purposes only */
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;syncppp.h&quot;
macro_line|#include &quot;cosa.h&quot;
multiline_comment|/* Linux version stuff */
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,1)
DECL|typedef|wait_queue_head_t
r_typedef
r_struct
id|wait_queue
op_star
id|wait_queue_head_t
suffix:semicolon
DECL|macro|DECLARE_WAITQUEUE
mdefine_line|#define DECLARE_WAITQUEUE(wait, current) &bslash;&n;&t;struct wait_queue wait = { current, NULL }
macro_line|#endif
multiline_comment|/* Maximum length of the identification string. */
DECL|macro|COSA_MAX_ID_STRING
mdefine_line|#define COSA_MAX_ID_STRING&t;128
multiline_comment|/* Maximum length of the channel name */
DECL|macro|COSA_MAX_NAME
mdefine_line|#define COSA_MAX_NAME&t;&t;(sizeof(&quot;cosaXXXcXXX&quot;)+1)
multiline_comment|/* Per-channel data structure */
DECL|struct|channel_data
r_struct
id|channel_data
(brace
DECL|member|if_ptr
r_void
op_star
id|if_ptr
suffix:semicolon
multiline_comment|/* General purpose pointer (used by SPPP) */
DECL|member|usage
r_int
id|usage
suffix:semicolon
multiline_comment|/* Usage count; &gt;0 for chrdev, -1 for netdev */
DECL|member|num
r_int
id|num
suffix:semicolon
multiline_comment|/* Number of the channel */
DECL|member|cosa
r_struct
id|cosa_data
op_star
id|cosa
suffix:semicolon
multiline_comment|/* Pointer to the per-card structure */
DECL|member|txsize
r_int
id|txsize
suffix:semicolon
multiline_comment|/* Size of transmitted data */
DECL|member|txbuf
r_char
op_star
id|txbuf
suffix:semicolon
multiline_comment|/* Transmit buffer */
DECL|member|name
r_char
id|name
(braket
id|COSA_MAX_NAME
)braket
suffix:semicolon
multiline_comment|/* channel name */
multiline_comment|/* The HW layer interface */
multiline_comment|/* routine called from the RX interrupt */
DECL|member|setup_rx
r_char
op_star
(paren
op_star
id|setup_rx
)paren
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_int
id|size
)paren
suffix:semicolon
multiline_comment|/* routine called when the RX is done (from the EOT interrupt) */
DECL|member|rx_done
r_int
(paren
op_star
id|rx_done
)paren
(paren
r_struct
id|channel_data
op_star
id|channel
)paren
suffix:semicolon
multiline_comment|/* routine called when the TX is done (from the EOT interrupt) */
DECL|member|tx_done
r_int
(paren
op_star
id|tx_done
)paren
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_int
id|size
)paren
suffix:semicolon
multiline_comment|/* Character device parts */
DECL|member|rsem
DECL|member|wsem
r_struct
id|semaphore
id|rsem
comma
id|wsem
suffix:semicolon
DECL|member|rxdata
r_char
op_star
id|rxdata
suffix:semicolon
DECL|member|rxsize
r_int
id|rxsize
suffix:semicolon
DECL|member|txwaitq
DECL|member|rxwaitq
id|wait_queue_head_t
id|txwaitq
comma
id|rxwaitq
suffix:semicolon
DECL|member|tx_status
DECL|member|rx_status
r_int
id|tx_status
comma
id|rx_status
suffix:semicolon
multiline_comment|/* SPPP/HDLC device parts */
DECL|member|pppdev
r_struct
id|ppp_device
id|pppdev
suffix:semicolon
DECL|member|rx_skb
DECL|member|tx_skb
r_struct
id|sk_buff
op_star
id|rx_skb
comma
op_star
id|tx_skb
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* cosa-&gt;firmware_status bits */
DECL|macro|COSA_FW_RESET
mdefine_line|#define COSA_FW_RESET&t;&t;(1&lt;&lt;0)&t;/* Is the ROM monitor active? */
DECL|macro|COSA_FW_DOWNLOAD
mdefine_line|#define COSA_FW_DOWNLOAD&t;(1&lt;&lt;1)&t;/* Is the microcode downloaded? */
DECL|macro|COSA_FW_START
mdefine_line|#define COSA_FW_START&t;&t;(1&lt;&lt;2)&t;/* Is the microcode running? */
DECL|struct|cosa_data
r_struct
id|cosa_data
(brace
DECL|member|num
r_int
id|num
suffix:semicolon
multiline_comment|/* Card number */
DECL|member|name
r_char
id|name
(braket
id|COSA_MAX_NAME
)braket
suffix:semicolon
multiline_comment|/* Card name - e.g &quot;cosa0&quot; */
DECL|member|datareg
DECL|member|statusreg
r_int
r_int
id|datareg
comma
id|statusreg
suffix:semicolon
multiline_comment|/* I/O ports */
DECL|member|irq
DECL|member|dma
r_int
r_int
id|irq
comma
id|dma
suffix:semicolon
multiline_comment|/* IRQ and DMA number */
DECL|member|startaddr
r_int
r_int
id|startaddr
suffix:semicolon
multiline_comment|/* Firmware start address */
DECL|member|busmaster
r_int
r_int
id|busmaster
suffix:semicolon
multiline_comment|/* Use busmastering? */
DECL|member|nchannels
r_int
id|nchannels
suffix:semicolon
multiline_comment|/* # of channels on this card */
DECL|member|driver_status
r_int
id|driver_status
suffix:semicolon
multiline_comment|/* For communicating with firware */
DECL|member|firmware_status
r_int
id|firmware_status
suffix:semicolon
multiline_comment|/* Downloaded, reseted, etc. */
DECL|member|rxbitmap
DECL|member|txbitmap
r_int
r_int
id|rxbitmap
comma
id|txbitmap
suffix:semicolon
multiline_comment|/* Bitmap of channels who are willing to send/receive data */
DECL|member|rxtx
r_int
r_int
id|rxtx
suffix:semicolon
multiline_comment|/* RX or TX in progress? */
DECL|member|enabled
r_int
id|enabled
suffix:semicolon
DECL|member|usage
r_int
id|usage
suffix:semicolon
multiline_comment|/* usage count */
DECL|member|txchan
DECL|member|txsize
DECL|member|rxsize
r_int
id|txchan
comma
id|txsize
comma
id|rxsize
suffix:semicolon
DECL|member|rxchan
r_struct
id|channel_data
op_star
id|rxchan
suffix:semicolon
DECL|member|bouncebuf
r_char
op_star
id|bouncebuf
suffix:semicolon
DECL|member|txbuf
DECL|member|rxbuf
r_char
op_star
id|txbuf
comma
op_star
id|rxbuf
suffix:semicolon
DECL|member|chan
r_struct
id|channel_data
op_star
id|chan
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* For exclusive operations on this structure */
DECL|member|id_string
r_char
id|id_string
(braket
id|COSA_MAX_ID_STRING
)braket
suffix:semicolon
multiline_comment|/* ROM monitor ID string */
DECL|member|type
r_char
op_star
id|type
suffix:semicolon
multiline_comment|/* card type */
)brace
suffix:semicolon
multiline_comment|/*&n; * Define this if you want all the possible ports to be autoprobed.&n; * It is here but it probably is not a good idea to use this.&n; */
multiline_comment|/* #define COSA_ISA_AUTOPROBE&t;1 */
multiline_comment|/*&n; * Character device major number. 117 was allocated for us.&n; * The value of 0 means to allocate a first free one.&n; */
DECL|variable|cosa_major
r_static
r_int
id|cosa_major
op_assign
l_int|117
suffix:semicolon
multiline_comment|/*&n; * Encoding of the minor numbers:&n; * The lowest CARD_MINOR_BITS bits means the channel on the single card,&n; * the highest bits means the card number.&n; */
DECL|macro|CARD_MINOR_BITS
mdefine_line|#define CARD_MINOR_BITS&t;4&t;/* How many bits in minor number are reserved&n;&t;&t;&t;&t; * for the single card */
multiline_comment|/*&n; * The following depends on CARD_MINOR_BITS. Unfortunately, the &quot;MODULE_STRING&quot;&n; * macro doesn&squot;t like anything other than the raw number as an argument :-(&n; */
DECL|macro|MAX_CARDS
mdefine_line|#define MAX_CARDS&t;16
multiline_comment|/* #define MAX_CARDS&t;(1 &lt;&lt; (8-CARD_MINOR_BITS)) */
DECL|macro|DRIVER_RX_READY
mdefine_line|#define DRIVER_RX_READY&t;&t;0x0001
DECL|macro|DRIVER_TX_READY
mdefine_line|#define DRIVER_TX_READY&t;&t;0x0002
DECL|macro|DRIVER_TXMAP_SHIFT
mdefine_line|#define DRIVER_TXMAP_SHIFT&t;2
DECL|macro|DRIVER_TXMAP_MASK
mdefine_line|#define DRIVER_TXMAP_MASK&t;0x0c&t;/* FIXME: 0xfc for 8-channel version */
multiline_comment|/*&n; * for cosa-&gt;rxtx - indicates whether either transmit or receive is&n; * in progress. These values are mean number of the bit.&n; */
DECL|macro|TXBIT
mdefine_line|#define TXBIT 0
DECL|macro|RXBIT
mdefine_line|#define RXBIT 1
DECL|macro|IRQBIT
mdefine_line|#define IRQBIT 2
DECL|macro|COSA_MTU
mdefine_line|#define COSA_MTU 2000&t;/* FIXME: I don&squot;t know this exactly */
DECL|macro|DEBUG_DATA
macro_line|#undef DEBUG_DATA 1&t;/* Dump the data read or written to the channel */
DECL|macro|DEBUG_IRQS
macro_line|#undef DEBUG_IRQS 1&t;/* Print the message when the IRQ is received */
DECL|macro|DEBUG_IO
macro_line|#undef DEBUG_IO 1&t;/* Dump the I/O traffic */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT&t;(5*HZ)
multiline_comment|/* Maybe the following should be allocated dynamically */
DECL|variable|cosa_cards
r_static
r_struct
id|cosa_data
id|cosa_cards
(braket
id|MAX_CARDS
)braket
suffix:semicolon
DECL|variable|nr_cards
r_static
r_int
id|nr_cards
suffix:semicolon
macro_line|#ifdef COSA_ISA_AUTOPROBE
DECL|variable|io
r_static
r_int
id|io
(braket
id|MAX_CARDS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|0x220
comma
l_int|0x228
comma
l_int|0x210
comma
l_int|0x218
comma
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* NOTE: DMA is not autoprobed!!! */
DECL|variable|dma
r_static
r_int
id|dma
(braket
id|MAX_CARDS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|1
comma
l_int|7
comma
l_int|1
comma
l_int|7
comma
l_int|1
comma
l_int|7
comma
l_int|1
comma
l_int|7
comma
l_int|0
comma
)brace
suffix:semicolon
macro_line|#else
DECL|variable|io
r_int
id|io
(braket
id|MAX_CARDS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dma
r_int
id|dma
(braket
id|MAX_CARDS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* IRQ can be safely autoprobed */
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|MAX_CARDS
op_plus
l_int|1
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
)brace
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_CARDS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;The I/O bases of the COSA or SRP cards&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_CARDS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;The IRQ lines of the COSA or SRP cards&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_CARDS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dma
comma
l_string|&quot;The DMA channels of the COSA or SRP cards&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jan &bslash;&quot;Yenya&bslash;&quot; Kasprzak, &lt;kas@fi.muni.cz&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Modular driver for the COSA or SRP synchronous card&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* I use this mainly for testing purposes */
macro_line|#ifdef COSA_SLOW_IO
DECL|macro|cosa_outb
mdefine_line|#define cosa_outb outb_p
DECL|macro|cosa_outw
mdefine_line|#define cosa_outw outw_p
DECL|macro|cosa_inb
mdefine_line|#define cosa_inb  inb_p
DECL|macro|cosa_inw
mdefine_line|#define cosa_inw  inw_p
macro_line|#else
DECL|macro|cosa_outb
mdefine_line|#define cosa_outb outb
DECL|macro|cosa_outw
mdefine_line|#define cosa_outw outw
DECL|macro|cosa_inb
mdefine_line|#define cosa_inb  inb
DECL|macro|cosa_inw
mdefine_line|#define cosa_inw  inw
macro_line|#endif
DECL|macro|is_8bit
mdefine_line|#define is_8bit(cosa)&t;&t;(!(cosa-&gt;datareg &amp; 0x08))
DECL|macro|cosa_getstatus
mdefine_line|#define cosa_getstatus(cosa)&t;(cosa_inb(cosa-&gt;statusreg))
DECL|macro|cosa_putstatus
mdefine_line|#define cosa_putstatus(cosa, stat)&t;(cosa_outb(stat, cosa-&gt;statusreg))
DECL|macro|cosa_getdata16
mdefine_line|#define cosa_getdata16(cosa)&t;(cosa_inw(cosa-&gt;datareg))
DECL|macro|cosa_getdata8
mdefine_line|#define cosa_getdata8(cosa)&t;(cosa_inb(cosa-&gt;datareg))
DECL|macro|cosa_putdata16
mdefine_line|#define cosa_putdata16(cosa, dt)&t;(cosa_outw(dt, cosa-&gt;datareg))
DECL|macro|cosa_putdata8
mdefine_line|#define cosa_putdata8(cosa, dt)&t;(cosa_outb(dt, cosa-&gt;datareg))
multiline_comment|/* Initialization stuff */
r_static
r_int
id|cosa_probe
c_func
(paren
r_int
id|ioaddr
comma
r_int
id|irq
comma
r_int
id|dma
)paren
suffix:semicolon
multiline_comment|/* HW interface */
r_static
r_void
id|cosa_enable_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
suffix:semicolon
r_static
r_void
id|cosa_disable_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
suffix:semicolon
r_static
r_int
id|cosa_start_tx
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|cosa_kick
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
suffix:semicolon
r_static
r_int
id|cosa_dma_able
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_char
op_star
id|buf
comma
r_int
id|data
)paren
suffix:semicolon
multiline_comment|/* SPPP/HDLC stuff */
r_static
r_void
id|sppp_channel_init
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
suffix:semicolon
r_static
r_void
id|sppp_channel_delete
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
suffix:semicolon
r_static
r_int
id|cosa_sppp_open
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_static
r_int
id|cosa_sppp_close
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_static
r_void
id|cosa_sppp_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_static
r_int
id|cosa_sppp_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_static
r_char
op_star
id|sppp_setup_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|sppp_rx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
)paren
suffix:semicolon
r_static
r_int
id|sppp_tx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|cosa_sppp_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|cosa_net_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Character device */
r_static
r_void
id|chardev_channel_init
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
suffix:semicolon
r_static
r_char
op_star
id|chrdev_setup_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|chrdev_rx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
)paren
suffix:semicolon
r_static
r_int
id|chrdev_tx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|channel
comma
r_int
id|size
)paren
suffix:semicolon
r_static
id|loff_t
id|cosa_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
suffix:semicolon
r_static
id|ssize_t
id|cosa_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
id|ssize_t
id|cosa_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
r_int
id|cosa_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|poll
)paren
suffix:semicolon
r_static
r_int
id|cosa_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|cosa_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|cosa_chardev_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#ifdef COSA_FASYNC_WORKING
r_static
r_int
id|cosa_fasync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|on
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|cosa_fops
r_static
r_struct
id|file_operations
id|cosa_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|cosa_lseek
comma
id|read
suffix:colon
id|cosa_read
comma
id|write
suffix:colon
id|cosa_write
comma
id|poll
suffix:colon
id|cosa_poll
comma
id|ioctl
suffix:colon
id|cosa_chardev_ioctl
comma
id|open
suffix:colon
id|cosa_open
comma
id|release
suffix:colon
id|cosa_release
comma
macro_line|#ifdef COSA_FASYNC_WORKING
id|fasync
suffix:colon
id|cosa_fasync
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Ioctls */
r_static
r_int
id|cosa_start
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|address
)paren
suffix:semicolon
r_static
r_int
id|cosa_reset
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
suffix:semicolon
r_static
r_int
id|cosa_download
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_struct
id|cosa_download
op_star
id|d
)paren
suffix:semicolon
r_static
r_int
id|cosa_readmem
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_struct
id|cosa_download
op_star
id|d
)paren
suffix:semicolon
multiline_comment|/* COSA/SRP ROM monitor */
r_static
r_int
id|download
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|data
comma
r_int
id|addr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|startmicrocode
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|address
)paren
suffix:semicolon
r_static
r_int
id|readmem
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|data
comma
r_int
id|addr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|cosa_reset_and_read_id
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|id
)paren
suffix:semicolon
multiline_comment|/* Auxilliary functions */
r_static
r_int
id|get_wait_data
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
suffix:semicolon
r_static
r_int
id|put_wait_data
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
suffix:semicolon
r_static
r_int
id|puthexnumber
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|number
)paren
suffix:semicolon
r_static
r_void
id|put_driver_status
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
suffix:semicolon
r_static
r_void
id|put_driver_status_nolock
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
suffix:semicolon
multiline_comment|/* Interrupt handling */
r_static
r_void
id|cosa_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|cosa
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/* I/O ops debugging */
macro_line|#ifdef DEBUG_IO
r_static
r_void
id|debug_data_in
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|debug_data_out
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|debug_data_cmd
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|debug_status_in
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|debug_status_out
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
suffix:semicolon
macro_line|#endif
"&f;"
multiline_comment|/* ---------- Initialization stuff ---------- */
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
macro_line|#else
r_static
r_int
id|__init
id|cosa_init
c_func
(paren
r_void
)paren
macro_line|#endif
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa v1.08 (c) 1997-2000 Jan Kasprzak &lt;kas@fi.muni.cz&gt;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa: SMP found. Please mail any success/failure reports to the author.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cosa_major
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|cosa_major
comma
l_string|&quot;cosa&quot;
comma
op_amp
id|cosa_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cosa: unable to get major %d&bslash;n&quot;
comma
id|cosa_major
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cosa_major
op_assign
id|devfs_register_chrdev
c_func
(paren
l_int|0
comma
l_string|&quot;cosa&quot;
comma
op_amp
id|cosa_fops
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cosa: unable to register chardev&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CARDS
suffix:semicolon
id|i
op_increment
)paren
id|cosa_cards
(braket
id|i
)braket
dot
id|num
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|io
(braket
id|i
)braket
op_ne
l_int|0
op_logical_and
id|i
OL
id|MAX_CARDS
suffix:semicolon
id|i
op_increment
)paren
id|cosa_probe
c_func
(paren
id|io
(braket
id|i
)braket
comma
id|irq
(braket
id|i
)braket
comma
id|dma
(braket
id|i
)braket
)paren
suffix:semicolon
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;cosa&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
id|nr_cards
comma
id|DEVFS_FL_DEFAULT
comma
id|cosa_major
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|cosa_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_cards
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cosa: no devices found.&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_unregister_chrdev
c_func
(paren
id|cosa_major
comma
l_string|&quot;cosa&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
r_struct
id|cosa_data
op_star
id|cosa
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Unloading the cosa module&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cosa
op_assign
id|cosa_cards
suffix:semicolon
id|nr_cards
op_decrement
suffix:semicolon
id|cosa
op_increment
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Clean up the per-channel data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cosa-&gt;nchannels
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Chardev driver has no alloc&squot;d per-channel data */
id|sppp_channel_delete
c_func
(paren
id|cosa-&gt;chan
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Clean up the per-card data */
id|kfree
c_func
(paren
id|cosa-&gt;chan
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cosa-&gt;bouncebuf
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|cosa-&gt;irq
comma
id|cosa
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|cosa-&gt;datareg
comma
id|is_8bit
c_func
(paren
id|cosa
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|4
)paren
suffix:semicolon
)brace
id|devfs_unregister_chrdev
c_func
(paren
id|cosa_major
comma
l_string|&quot;cosa&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * This function should register all the net devices needed for the&n; * single channel.&n; */
DECL|function|channel_init
r_static
id|__inline__
r_void
id|channel_init
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
id|sprintf
c_func
(paren
id|chan-&gt;name
comma
l_string|&quot;cosa%dc%d&quot;
comma
id|chan-&gt;cosa-&gt;num
comma
id|chan-&gt;num
)paren
suffix:semicolon
multiline_comment|/* Initialize the chardev data structures */
id|chardev_channel_init
c_func
(paren
id|chan
)paren
suffix:semicolon
multiline_comment|/* Register the sppp interface */
id|sppp_channel_init
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
DECL|function|cosa_probe
r_static
r_int
id|cosa_probe
c_func
(paren
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|cosa_cards
op_plus
id|nr_cards
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|cosa
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cosa_data
)paren
)paren
suffix:semicolon
multiline_comment|/* Checking validity of parameters: */
multiline_comment|/* IRQ should be 2-7 or 10-15; negative IRQ means autoprobe */
r_if
c_cond
(paren
(paren
id|irq
op_ge
l_int|0
op_logical_and
id|irq
OL
l_int|2
)paren
op_logical_or
id|irq
OG
l_int|15
op_logical_or
(paren
id|irq
template_param
l_int|7
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa_probe: invalid IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* I/O address should be between 0x100 and 0x3ff and should be&n;&t; * multiple of 8. */
r_if
c_cond
(paren
id|base
template_param
l_int|0x3ff
op_logical_or
id|base
op_amp
l_int|0x7
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa_probe: invalid I/O address 0x%x&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* DMA should be 0,1 or 3-7 */
r_if
c_cond
(paren
id|dma
template_param
l_int|7
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa_probe: invalid DMA %d&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* and finally, on 16-bit COSA DMA should be 4-7 and &n;&t; * I/O base should not be multiple of 0x10 */
r_if
c_cond
(paren
(paren
(paren
id|base
op_amp
l_int|0x8
)paren
op_logical_and
id|dma
OL
l_int|4
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|base
op_amp
l_int|0x8
)paren
op_logical_and
id|dma
OG
l_int|3
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa_probe: 8/16 bit base and DMA mismatch&quot;
l_string|&quot; (base=0x%x, dma=%d)&bslash;n&quot;
comma
id|base
comma
id|dma
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cosa-&gt;dma
op_assign
id|dma
suffix:semicolon
id|cosa-&gt;datareg
op_assign
id|base
suffix:semicolon
id|cosa-&gt;statusreg
op_assign
id|is_8bit
c_func
(paren
id|cosa
)paren
ques
c_cond
id|base
op_plus
l_int|1
suffix:colon
id|base
op_plus
l_int|2
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cosa-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
id|is_8bit
c_func
(paren
id|cosa
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|4
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cosa_reset_and_read_id
c_func
(paren
id|cosa
comma
id|cosa-&gt;id_string
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cosa: probe at 0x%x failed.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Test the validity of identification string */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cosa-&gt;id_string
comma
l_string|&quot;SRP&quot;
comma
l_int|3
)paren
)paren
id|cosa-&gt;type
op_assign
l_string|&quot;srp&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cosa-&gt;id_string
comma
l_string|&quot;COSA&quot;
comma
l_int|4
)paren
)paren
id|cosa-&gt;type
op_assign
id|is_8bit
c_func
(paren
id|cosa
)paren
ques
c_cond
l_string|&quot;cosa8&quot;
suffix:colon
l_string|&quot;cosa16&quot;
suffix:semicolon
r_else
(brace
multiline_comment|/* Print a warning only if we are not autoprobing */
macro_line|#ifndef COSA_ISA_AUTOPROBE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa: valid signature not found at 0x%x.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now do IRQ autoprobe */
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
r_int
r_int
id|irqs
suffix:semicolon
multiline_comment|/*&t;&t;printk(KERN_INFO &quot;IRQ autoprobe&bslash;n&quot;); */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Enable interrupt on tx buffer empty (it sure is) &n;&t;&t; * really sure ?&n;&t;&t; * FIXME: When this code is not used as module, we should&n;&t;&t; * probably call udelay() instead of the interruptible sleep.&n;&t;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_TX_INT_ENA
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
multiline_comment|/* Disable all IRQs from the card */
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Empty the received data register */
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa IRQ autoprobe: multiple interrupts obtained (%d, board at 0x%x)&bslash;n&quot;
comma
id|irq
comma
id|cosa-&gt;datareg
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa IRQ autoprobe: no interrupt obtained (board at 0x%x)&bslash;n&quot;
comma
id|cosa-&gt;datareg
)paren
suffix:semicolon
multiline_comment|/*&t;return -1; */
)brace
)brace
id|cosa-&gt;irq
op_assign
id|irq
suffix:semicolon
id|cosa-&gt;num
op_assign
id|nr_cards
suffix:semicolon
id|cosa-&gt;usage
op_assign
l_int|0
suffix:semicolon
id|cosa-&gt;nchannels
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* FIXME: how to determine this? */
id|request_region
c_func
(paren
id|base
comma
id|is_8bit
c_func
(paren
id|cosa
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|4
comma
id|cosa-&gt;type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cosa-&gt;irq
comma
id|cosa_interrupt
comma
l_int|0
comma
id|cosa-&gt;type
comma
id|cosa
)paren
)paren
r_goto
id|bad1
suffix:semicolon
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|cosa-&gt;dma
comma
id|cosa-&gt;type
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|cosa-&gt;irq
comma
id|cosa
)paren
suffix:semicolon
id|bad1
suffix:colon
id|release_region
c_func
(paren
id|cosa-&gt;datareg
comma
id|is_8bit
c_func
(paren
id|cosa
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: allocating resources failed&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cosa-&gt;bouncebuf
op_assign
id|kmalloc
c_func
(paren
id|COSA_MTU
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|cosa-&gt;name
comma
l_string|&quot;cosa%d&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
multiline_comment|/* Initialize the per-channel data */
id|cosa-&gt;chan
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|channel_data
)paren
op_star
id|cosa-&gt;nchannels
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cosa-&gt;chan
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|channel_data
)paren
op_star
id|cosa-&gt;nchannels
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cosa-&gt;nchannels
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cosa-&gt;chan
(braket
id|i
)braket
dot
id|cosa
op_assign
id|cosa
suffix:semicolon
id|cosa-&gt;chan
(braket
id|i
)braket
dot
id|num
op_assign
id|i
suffix:semicolon
id|channel_init
c_func
(paren
id|cosa-&gt;chan
op_plus
id|i
)paren
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa%d: %s (%s at 0x%x irq %d dma %d), %d channels&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;id_string
comma
id|cosa-&gt;type
comma
id|cosa-&gt;datareg
comma
id|cosa-&gt;irq
comma
id|cosa-&gt;dma
comma
id|cosa-&gt;nchannels
)paren
suffix:semicolon
r_return
id|nr_cards
op_increment
suffix:semicolon
)brace
"&f;"
multiline_comment|/*---------- SPPP/HDLC netdevice ---------- */
DECL|function|sppp_channel_init
r_static
r_void
id|sppp_channel_init
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
r_struct
id|net_device
op_star
id|d
suffix:semicolon
id|chan-&gt;if_ptr
op_assign
op_amp
id|chan-&gt;pppdev
suffix:semicolon
id|chan-&gt;pppdev.dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|chan-&gt;pppdev.dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|sppp_attach
c_func
(paren
op_amp
id|chan-&gt;pppdev
)paren
suffix:semicolon
id|d
op_assign
id|chan-&gt;pppdev.dev
suffix:semicolon
id|strcpy
c_func
(paren
id|d-&gt;name
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|d-&gt;base_addr
op_assign
id|chan-&gt;cosa-&gt;datareg
suffix:semicolon
id|d-&gt;irq
op_assign
id|chan-&gt;cosa-&gt;irq
suffix:semicolon
id|d-&gt;dma
op_assign
id|chan-&gt;cosa-&gt;dma
suffix:semicolon
id|d-&gt;priv
op_assign
id|chan
suffix:semicolon
id|d-&gt;init
op_assign
l_int|NULL
suffix:semicolon
id|d-&gt;open
op_assign
id|cosa_sppp_open
suffix:semicolon
id|d-&gt;stop
op_assign
id|cosa_sppp_close
suffix:semicolon
id|d-&gt;hard_start_xmit
op_assign
id|cosa_sppp_tx
suffix:semicolon
id|d-&gt;do_ioctl
op_assign
id|cosa_sppp_ioctl
suffix:semicolon
id|d-&gt;get_stats
op_assign
id|cosa_net_stats
suffix:semicolon
id|d-&gt;tx_timeout
op_assign
id|cosa_sppp_timeout
suffix:semicolon
id|d-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|d
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: register_netdev failed.&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
id|sppp_detach
c_func
(paren
id|chan-&gt;pppdev.dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|sppp_channel_delete
r_static
r_void
id|sppp_channel_delete
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
id|sppp_detach
c_func
(paren
id|chan-&gt;pppdev.dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|chan-&gt;pppdev.dev
)paren
suffix:semicolon
)brace
DECL|function|cosa_sppp_open
r_static
r_int
id|cosa_sppp_open
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
(brace
r_struct
id|channel_data
op_star
id|chan
op_assign
id|d-&gt;priv
suffix:semicolon
r_int
id|err
comma
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|chan-&gt;cosa-&gt;firmware_status
op_amp
id|COSA_FW_START
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: start the firmware first (status %d)&bslash;n&quot;
comma
id|chan-&gt;cosa-&gt;name
comma
id|chan-&gt;cosa-&gt;firmware_status
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;usage
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: sppp_open called with usage count %d&bslash;n&quot;
comma
id|chan-&gt;name
comma
id|chan-&gt;usage
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|chan-&gt;setup_rx
op_assign
id|sppp_setup_rx
suffix:semicolon
id|chan-&gt;tx_done
op_assign
id|sppp_tx_done
suffix:semicolon
id|chan-&gt;rx_done
op_assign
id|sppp_rx_done
suffix:semicolon
id|chan-&gt;usage
op_assign
op_minus
l_int|1
suffix:semicolon
id|chan-&gt;cosa-&gt;usage
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|err
op_assign
id|sppp_open
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|chan-&gt;usage
op_assign
l_int|0
suffix:semicolon
id|chan-&gt;cosa-&gt;usage
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|d
)paren
suffix:semicolon
id|cosa_enable_rx
c_func
(paren
id|chan
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cosa_sppp_tx
r_static
r_int
id|cosa_sppp_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|channel_data
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|chan-&gt;tx_skb
op_assign
id|skb
suffix:semicolon
id|cosa_start_tx
c_func
(paren
id|chan
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cosa_sppp_timeout
r_static
r_void
id|cosa_sppp_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|channel_data
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|RXBIT
comma
op_amp
id|chan-&gt;cosa-&gt;rxtx
)paren
)paren
(brace
id|chan-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|chan-&gt;stats.rx_missed_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
id|chan-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|chan-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
id|cosa_kick
c_func
(paren
id|chan-&gt;cosa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;tx_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|chan-&gt;tx_skb
)paren
suffix:semicolon
id|chan-&gt;tx_skb
op_assign
l_int|0
suffix:semicolon
)brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|cosa_sppp_close
r_static
r_int
id|cosa_sppp_close
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
(brace
r_struct
id|channel_data
op_star
id|chan
op_assign
id|d-&gt;priv
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|d
)paren
suffix:semicolon
id|sppp_close
c_func
(paren
id|d
)paren
suffix:semicolon
id|cosa_disable_rx
c_func
(paren
id|chan
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;rx_skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|chan-&gt;rx_skb
)paren
suffix:semicolon
id|chan-&gt;rx_skb
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chan-&gt;tx_skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|chan-&gt;tx_skb
)paren
suffix:semicolon
id|chan-&gt;tx_skb
op_assign
l_int|0
suffix:semicolon
)brace
id|chan-&gt;usage
op_assign
l_int|0
suffix:semicolon
id|chan-&gt;cosa-&gt;usage
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chan-&gt;cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sppp_setup_rx
r_static
r_char
op_star
id|sppp_setup_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_int
id|size
)paren
(brace
multiline_comment|/*&n;&t; * We can safely fall back to non-dma-able memory, because we have&n;&t; * the cosa-&gt;bouncebuf pre-allocated.&n;&t; */
r_if
c_cond
(paren
id|chan-&gt;rx_skb
)paren
id|kfree_skb
c_func
(paren
id|chan-&gt;rx_skb
)paren
suffix:semicolon
id|chan-&gt;rx_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;rx_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Memory squeeze, dropping packet&bslash;n&quot;
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|chan-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|chan-&gt;pppdev.dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
id|skb_put
c_func
(paren
id|chan-&gt;rx_skb
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|sppp_rx_done
r_static
r_int
id|sppp_rx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;rx_skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: rx_done with empty skb!&bslash;n&quot;
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|chan-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|chan-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|chan-&gt;rx_skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_WAN_PPP
)paren
suffix:semicolon
id|chan-&gt;rx_skb-&gt;dev
op_assign
id|chan-&gt;pppdev.dev
suffix:semicolon
id|chan-&gt;rx_skb-&gt;mac.raw
op_assign
id|chan-&gt;rx_skb-&gt;data
suffix:semicolon
id|chan-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|chan-&gt;stats.rx_bytes
op_add_assign
id|chan-&gt;cosa-&gt;rxsize
suffix:semicolon
id|netif_rx
c_func
(paren
id|chan-&gt;rx_skb
)paren
suffix:semicolon
id|chan-&gt;rx_skb
op_assign
l_int|0
suffix:semicolon
id|chan-&gt;pppdev.dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ARGSUSED */
DECL|function|sppp_tx_done
r_static
r_int
id|sppp_tx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;tx_skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: tx_done with empty skb!&bslash;n&quot;
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|chan-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|chan-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dev_kfree_skb_irq
c_func
(paren
id|chan-&gt;tx_skb
)paren
suffix:semicolon
id|chan-&gt;tx_skb
op_assign
l_int|0
suffix:semicolon
id|chan-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|chan-&gt;stats.tx_bytes
op_add_assign
id|size
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|chan-&gt;pppdev.dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cosa_net_stats
r_static
r_struct
id|net_device_stats
op_star
id|cosa_net_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|channel_data
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|chan-&gt;stats
suffix:semicolon
)brace
"&f;"
multiline_comment|/*---------- Character device ---------- */
DECL|function|chardev_channel_init
r_static
r_void
id|chardev_channel_init
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
id|init_MUTEX
c_func
(paren
op_amp
id|chan-&gt;rsem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
suffix:semicolon
)brace
DECL|function|cosa_lseek
r_static
id|loff_t
id|cosa_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|function|cosa_read
r_static
id|ssize_t
id|cosa_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_struct
id|channel_data
op_star
id|chan
op_assign
(paren
r_struct
id|channel_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|chan-&gt;cosa
suffix:semicolon
r_char
op_star
id|kbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cosa-&gt;firmware_status
op_amp
id|COSA_FW_START
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: start the firmware first (status %d)&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;firmware_status
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|chan-&gt;rsem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan-&gt;rxdata
op_assign
id|kmalloc
c_func
(paren
id|COSA_MTU
comma
id|GFP_DMA
op_or
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: cosa_read() - OOM&bslash;n&quot;
comma
id|cosa-&gt;name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;rsem
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|chan-&gt;rx_status
op_assign
l_int|0
suffix:semicolon
id|cosa_enable_rx
c_func
(paren
id|chan
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|chan-&gt;rxwaitq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|chan-&gt;rx_status
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|chan-&gt;rx_status
op_eq
l_int|0
)paren
(brace
id|chan-&gt;rx_status
op_assign
l_int|1
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|chan-&gt;rxwaitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;rsem
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|chan-&gt;rxwaitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|kbuf
op_assign
id|chan-&gt;rxdata
suffix:semicolon
id|count
op_assign
id|chan-&gt;rxsize
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;rsem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|kbuf
comma
id|count
)paren
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|kbuf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|chrdev_setup_rx
r_static
r_char
op_star
id|chrdev_setup_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_int
id|size
)paren
(brace
multiline_comment|/* Expect size &lt;= COSA_MTU */
id|chan-&gt;rxsize
op_assign
id|size
suffix:semicolon
r_return
id|chan-&gt;rxdata
suffix:semicolon
)brace
DECL|function|chrdev_rx_done
r_static
r_int
id|chrdev_rx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;rx_status
)paren
(brace
multiline_comment|/* Reader has died */
id|kfree
c_func
(paren
id|chan-&gt;rxdata
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
suffix:semicolon
)brace
id|chan-&gt;rx_status
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|chan-&gt;rxwaitq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cosa_write
r_static
id|ssize_t
id|cosa_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|channel_data
op_star
id|chan
op_assign
(paren
r_struct
id|channel_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|chan-&gt;cosa
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|kbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cosa-&gt;firmware_status
op_amp
id|COSA_FW_START
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: start the firmware first (status %d)&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;firmware_status
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|COSA_MTU
)paren
id|count
op_assign
id|COSA_MTU
suffix:semicolon
multiline_comment|/* Allocate the buffer */
r_if
c_cond
(paren
(paren
id|kbuf
op_assign
id|kmalloc
c_func
(paren
id|count
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: cosa_write() OOM - dropping packet&bslash;n&quot;
comma
id|cosa-&gt;name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kbuf
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|kbuf
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|chan-&gt;tx_status
op_assign
l_int|0
suffix:semicolon
id|cosa_start_tx
c_func
(paren
id|chan
comma
id|kbuf
comma
id|count
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|chan-&gt;txwaitq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|chan-&gt;tx_status
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|chan-&gt;tx_status
op_eq
l_int|0
)paren
(brace
id|chan-&gt;tx_status
op_assign
l_int|1
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|chan-&gt;txwaitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|chan-&gt;tx_status
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|chan-&gt;txwaitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|kbuf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|chrdev_tx_done
r_static
r_int
id|chrdev_tx_done
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;tx_status
)paren
(brace
multiline_comment|/* Writer was interrupted */
id|kfree
c_func
(paren
id|chan-&gt;txbuf
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|chan-&gt;wsem
)paren
suffix:semicolon
)brace
id|chan-&gt;tx_status
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|chan-&gt;txwaitq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cosa_poll
r_static
r_int
r_int
id|cosa_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|poll
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa_poll is here&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cosa_open
r_static
r_int
id|cosa_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cosa_data
op_star
id|cosa
suffix:semicolon
r_struct
id|channel_data
op_star
id|chan
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_assign
id|MINOR
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
op_rshift
id|CARD_MINOR_BITS
)paren
op_ge
id|nr_cards
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|cosa
op_assign
id|cosa_cards
op_plus
id|n
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_assign
id|MINOR
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
id|CARD_MINOR_BITS
)paren
op_minus
l_int|1
)paren
)paren
op_ge
id|cosa-&gt;nchannels
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|chan
op_assign
id|cosa-&gt;chan
op_plus
id|n
suffix:semicolon
id|file-&gt;private_data
op_assign
id|chan
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;usage
OL
l_int|0
)paren
(brace
multiline_comment|/* in netdev mode */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|cosa-&gt;usage
op_increment
suffix:semicolon
id|chan-&gt;usage
op_increment
suffix:semicolon
id|chan-&gt;tx_done
op_assign
id|chrdev_tx_done
suffix:semicolon
id|chan-&gt;setup_rx
op_assign
id|chrdev_setup_rx
suffix:semicolon
id|chan-&gt;rx_done
op_assign
id|chrdev_rx_done
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cosa_release
r_static
r_int
id|cosa_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|channel_data
op_star
id|channel
op_assign
(paren
r_struct
id|channel_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|cosa_data
op_star
id|cosa
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|cosa
op_assign
id|channel-&gt;cosa
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cosa-&gt;usage
op_decrement
suffix:semicolon
id|channel-&gt;usage
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef COSA_FASYNC_WORKING
DECL|variable|fasync
r_static
r_struct
id|fasync_struct
op_star
id|fasync
(braket
l_int|256
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* To be done ... */
DECL|function|cosa_fasync
r_static
r_int
id|cosa_fasync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|on
)paren
(brace
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|rv
op_assign
id|fasync_helper
c_func
(paren
id|inode
comma
id|file
comma
id|on
comma
op_amp
id|fasync
(braket
id|port
)braket
)paren
suffix:semicolon
r_return
id|rv
OL
l_int|0
ques
c_cond
id|rv
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
"&f;"
multiline_comment|/* ---------- Ioctls ---------- */
multiline_comment|/*&n; * Ioctl subroutines can safely be made inline, because they are called&n; * only from cosa_ioctl().&n; */
DECL|function|cosa_reset
r_static
r_inline
r_int
id|cosa_reset
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
(brace
r_char
id|idstring
(braket
id|COSA_MAX_ID_STRING
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;usage
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: WARNING: reset requested with cosa-&gt;usage &gt; 1 (%d). Odd things may happen.&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;usage
)paren
suffix:semicolon
id|cosa-&gt;firmware_status
op_and_assign
op_complement
(paren
id|COSA_FW_RESET
op_or
id|COSA_FW_START
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cosa_reset_and_read_id
c_func
(paren
id|cosa
comma
id|idstring
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: reset failed&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: resetting device: %s&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|idstring
)paren
suffix:semicolon
id|cosa-&gt;firmware_status
op_or_assign
id|COSA_FW_RESET
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* High-level function to download data into COSA memory. Calls download() */
DECL|function|cosa_download
r_static
r_inline
r_int
id|cosa_download
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_struct
id|cosa_download
op_star
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|addr
comma
id|len
suffix:semicolon
r_char
op_star
id|code
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;usage
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: WARNING: download of microcode requested with cosa-&gt;usage &gt; 1 (%d). Odd things may happen.&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;usage
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cosa-&gt;firmware_status
op_amp
id|COSA_FW_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: reset the card first (status %d).&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;firmware_status
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|addr
comma
op_amp
(paren
id|d-&gt;addr
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|len
comma
op_amp
(paren
id|d-&gt;len
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|code
comma
op_amp
(paren
id|d-&gt;code
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;addr
template_param
id|COSA_MAX_FIRMWARE_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;len
template_param
id|COSA_MAX_FIRMWARE_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* If something fails, force the user to reset the card */
id|cosa-&gt;firmware_status
op_and_assign
op_complement
(paren
id|COSA_FW_RESET
op_or
id|COSA_FW_DOWNLOAD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|download
c_func
(paren
id|cosa
comma
id|d-&gt;code
comma
id|len
comma
id|addr
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: microcode download failed: %d&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: downloading microcode - 0x%04x bytes at 0x%04x&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|len
comma
id|addr
)paren
suffix:semicolon
id|cosa-&gt;firmware_status
op_or_assign
id|COSA_FW_RESET
op_or
id|COSA_FW_DOWNLOAD
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* High-level function to read COSA memory. Calls readmem() */
DECL|function|cosa_readmem
r_static
r_inline
r_int
id|cosa_readmem
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_struct
id|cosa_download
op_star
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|addr
comma
id|len
suffix:semicolon
r_char
op_star
id|code
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;usage
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: WARNING: readmem requested with &quot;
l_string|&quot;cosa-&gt;usage &gt; 1 (%d). Odd things may happen.&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;usage
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cosa-&gt;firmware_status
op_amp
id|COSA_FW_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: reset the card first (status %d).&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;firmware_status
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|addr
comma
op_amp
(paren
id|d-&gt;addr
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|len
comma
op_amp
(paren
id|d-&gt;len
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|code
comma
op_amp
(paren
id|d-&gt;code
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* If something fails, force the user to reset the card */
id|cosa-&gt;firmware_status
op_and_assign
op_complement
id|COSA_FW_RESET
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|readmem
c_func
(paren
id|cosa
comma
id|d-&gt;code
comma
id|len
comma
id|addr
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: reading memory failed: %d&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: reading card memory - 0x%04x bytes at 0x%04x&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|len
comma
id|addr
)paren
suffix:semicolon
id|cosa-&gt;firmware_status
op_or_assign
id|COSA_FW_RESET
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* High-level function to start microcode. Calls startmicrocode(). */
DECL|function|cosa_start
r_static
r_inline
r_int
id|cosa_start
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|address
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;usage
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: WARNING: start microcode requested with cosa-&gt;usage &gt; 1 (%d). Odd things may happen.&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;usage
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cosa-&gt;firmware_status
op_amp
(paren
id|COSA_FW_RESET
op_or
id|COSA_FW_DOWNLOAD
)paren
)paren
op_ne
(paren
id|COSA_FW_RESET
op_or
id|COSA_FW_DOWNLOAD
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: download the microcode and/or reset the card first (status %d).&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;firmware_status
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|cosa-&gt;firmware_status
op_and_assign
op_complement
id|COSA_FW_RESET
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|startmicrocode
c_func
(paren
id|cosa
comma
id|address
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: start microcode at 0x%04x failed: %d&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|address
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: starting microcode at 0x%04x&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|address
)paren
suffix:semicolon
id|cosa-&gt;startaddr
op_assign
id|address
suffix:semicolon
id|cosa-&gt;firmware_status
op_or_assign
id|COSA_FW_START
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Buffer of size at least COSA_MAX_ID_STRING is expected */
DECL|function|cosa_getidstr
r_static
r_inline
r_int
id|cosa_getidstr
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|string
)paren
(brace
r_int
id|l
op_assign
id|strlen
c_func
(paren
id|cosa-&gt;id_string
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|string
comma
id|cosa-&gt;id_string
comma
id|l
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|l
suffix:semicolon
)brace
multiline_comment|/* Buffer of size at least COSA_MAX_ID_STRING is expected */
DECL|function|cosa_gettype
r_static
r_inline
r_int
id|cosa_gettype
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|string
)paren
(brace
r_int
id|l
op_assign
id|strlen
c_func
(paren
id|cosa-&gt;type
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|string
comma
id|cosa-&gt;type
comma
id|l
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|l
suffix:semicolon
)brace
DECL|function|cosa_ioctl_common
r_static
r_int
id|cosa_ioctl_common
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_struct
id|channel_data
op_star
id|channel
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|COSAIORSET
suffix:colon
multiline_comment|/* Reset the device */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|cosa_reset
c_func
(paren
id|cosa
)paren
suffix:semicolon
r_case
id|COSAIOSTRT
suffix:colon
multiline_comment|/* Start the firmware */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|cosa_start
c_func
(paren
id|cosa
comma
id|arg
)paren
suffix:semicolon
r_case
id|COSAIODOWNLD
suffix:colon
multiline_comment|/* Download the firmware */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|cosa_download
c_func
(paren
id|cosa
comma
(paren
r_struct
id|cosa_download
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|COSAIORMEM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|cosa_readmem
c_func
(paren
id|cosa
comma
(paren
r_struct
id|cosa_download
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|COSAIORTYPE
suffix:colon
r_return
id|cosa_gettype
c_func
(paren
id|cosa
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|COSAIORIDSTR
suffix:colon
r_return
id|cosa_getidstr
c_func
(paren
id|cosa
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/*&n; * These two are _very_ugly_hack_(tm). Don&squot;t even look at this.&n; * Implementing this saved me few reboots after some process segfaulted&n; * inside this module.&n; */
macro_line|#ifdef MODULE
macro_line|#if 0
r_case
id|COSAIOMINC
suffix:colon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|COSAIOMDEC
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_case
id|COSAIONRCARDS
suffix:colon
r_return
id|nr_cards
suffix:semicolon
r_case
id|COSAIONRCHANS
suffix:colon
r_return
id|cosa-&gt;nchannels
suffix:semicolon
r_case
id|COSAIOBMSET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|is_8bit
c_func
(paren
id|cosa
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ne
id|COSA_BM_OFF
op_logical_and
id|arg
op_ne
id|COSA_BM_ON
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cosa-&gt;busmaster
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|COSAIOBMGET
suffix:colon
r_return
id|cosa-&gt;busmaster
suffix:semicolon
)brace
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
DECL|function|cosa_sppp_ioctl
r_static
r_int
id|cosa_sppp_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|channel_data
op_star
id|chan
op_assign
(paren
r_struct
id|channel_data
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|rv
op_assign
id|cosa_ioctl_common
c_func
(paren
id|chan-&gt;cosa
comma
id|chan
comma
id|cmd
comma
(paren
r_int
r_int
)paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
op_minus
id|ENOIOCTLCMD
)paren
(brace
r_return
id|sppp_do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|cosa_chardev_ioctl
r_static
r_int
id|cosa_chardev_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|channel_data
op_star
id|channel
op_assign
(paren
r_struct
id|channel_data
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|channel-&gt;cosa
suffix:semicolon
r_return
id|cosa_ioctl_common
c_func
(paren
id|cosa
comma
id|channel
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/*---------- HW layer interface ---------- */
multiline_comment|/*&n; * The higher layer can bind itself to the HW layer by setting the callbacks&n; * in the channel_data structure and by using these routines.&n; */
DECL|function|cosa_enable_rx
r_static
r_void
id|cosa_enable_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|chan-&gt;cosa
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|chan-&gt;num
comma
op_amp
id|cosa-&gt;rxbitmap
)paren
)paren
id|put_driver_status
c_func
(paren
id|cosa
)paren
suffix:semicolon
)brace
DECL|function|cosa_disable_rx
r_static
r_void
id|cosa_disable_rx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
)paren
(brace
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|chan-&gt;cosa
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|chan-&gt;num
comma
op_amp
id|cosa-&gt;rxbitmap
)paren
)paren
id|put_driver_status
c_func
(paren
id|cosa
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: This routine probably should check for cosa_start_tx() called when&n; * the previous transmit is still unfinished. In this case the non-zero&n; * return value should indicate to the caller that the queuing(sp?) up&n; * the transmit has failed.&n; */
DECL|function|cosa_start_tx
r_static
r_int
id|cosa_start_tx
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|chan-&gt;cosa
suffix:semicolon
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_DATA
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%dc%d: starting tx(0x%x)&quot;
comma
id|chan-&gt;cosa-&gt;num
comma
id|chan-&gt;num
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|buf
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|chan-&gt;txbuf
op_assign
id|buf
suffix:semicolon
id|chan-&gt;txsize
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|COSA_MTU
)paren
id|chan-&gt;txsize
op_assign
id|COSA_MTU
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Tell the firmware we are ready */
id|set_bit
c_func
(paren
id|chan-&gt;num
comma
op_amp
id|cosa-&gt;txbitmap
)paren
suffix:semicolon
id|put_driver_status
c_func
(paren
id|cosa
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_driver_status
r_static
r_void
id|put_driver_status
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
(brace
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
(paren
id|cosa-&gt;rxbitmap
ques
c_cond
id|DRIVER_RX_READY
suffix:colon
l_int|0
)paren
op_or
(paren
id|cosa-&gt;txbitmap
ques
c_cond
id|DRIVER_TX_READY
suffix:colon
l_int|0
)paren
op_or
(paren
id|cosa-&gt;txbitmap
ques
c_cond
op_complement
(paren
id|cosa-&gt;txbitmap
op_lshift
id|DRIVER_TXMAP_SHIFT
)paren
op_amp
id|DRIVER_TXMAP_MASK
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cosa-&gt;rxtx
)paren
(brace
r_if
c_cond
(paren
id|cosa-&gt;rxbitmap
op_or
id|cosa-&gt;txbitmap
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cosa-&gt;enabled
)paren
(brace
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_RX_INT_ENA
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
id|SR_RX_INT_ENA
)paren
suffix:semicolon
macro_line|#endif
id|cosa-&gt;enabled
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cosa-&gt;enabled
)paren
(brace
id|cosa-&gt;enabled
op_assign
l_int|0
suffix:semicolon
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
id|cosa_putdata8
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_data_cmd
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|put_driver_status_nolock
r_static
r_void
id|put_driver_status_nolock
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
(paren
id|cosa-&gt;rxbitmap
ques
c_cond
id|DRIVER_RX_READY
suffix:colon
l_int|0
)paren
op_or
(paren
id|cosa-&gt;txbitmap
ques
c_cond
id|DRIVER_TX_READY
suffix:colon
l_int|0
)paren
op_or
(paren
id|cosa-&gt;txbitmap
ques
c_cond
op_complement
(paren
id|cosa-&gt;txbitmap
op_lshift
id|DRIVER_TXMAP_SHIFT
)paren
op_amp
id|DRIVER_TXMAP_MASK
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;rxbitmap
op_or
id|cosa-&gt;txbitmap
)paren
(brace
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_RX_INT_ENA
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
id|SR_RX_INT_ENA
)paren
suffix:semicolon
macro_line|#endif
id|cosa-&gt;enabled
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|cosa-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
id|cosa_putdata8
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_data_cmd
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The &quot;kickme&quot; function: When the DMA times out, this is called to&n; * clean up the driver status.&n; * FIXME: Preliminary support, the interface is probably wrong.&n; */
DECL|function|cosa_kick
r_static
r_void
id|cosa_kick
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
(brace
r_int
id|flags
comma
id|flags1
suffix:semicolon
r_char
op_star
id|s
op_assign
l_string|&quot;(probably) IRQ&quot;
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|RXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
id|s
op_assign
l_string|&quot;RX DMA&quot;
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
id|s
op_assign
l_string|&quot;TX DMA&quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s timeout - restarting.&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|s
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cosa-&gt;rxtx
op_assign
l_int|0
suffix:semicolon
id|flags1
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags1
)paren
suffix:semicolon
multiline_comment|/* FIXME: Anything else? */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
(paren
r_void
)paren
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|cosa_putdata8
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|put_driver_status_nolock
c_func
(paren
id|cosa
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if the whole buffer is DMA-able. It means it is below the 16M of&n; * physical memory and doesn&squot;t span the 64k boundary. For now it seems&n; * SKB&squot;s never do this, but we&squot;ll check this anyway.&n; */
DECL|function|cosa_dma_able
r_static
r_int
id|cosa_dma_able
c_func
(paren
r_struct
id|channel_data
op_star
id|chan
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_static
r_int
id|count
suffix:semicolon
r_int
r_int
id|b
op_assign
(paren
r_int
r_int
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|b
op_plus
id|len
op_ge
id|MAX_DMA_ADDRESS
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|b
op_xor
(paren
id|b
op_plus
id|len
)paren
)paren
op_amp
l_int|0x10000
)paren
(brace
r_if
c_cond
(paren
id|count
op_increment
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: packet spanning a 64k boundary&bslash;n&quot;
comma
id|chan-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ---------- The SRP/COSA ROM monitor functions ---------- */
multiline_comment|/*&n; * Downloading SRP microcode: say &quot;w&quot; to SRP monitor, it answers by &quot;w=&quot;,&n; * drivers need to say 4-digit hex number meaning start address of the microcode&n; * separated by a single space. Monitor replies by saying &quot; =&quot;. Now driver&n; * has to write 4-digit hex number meaning the last byte address ended&n; * by a single space. Monitor has to reply with a space. Now the download&n; * begins. After the download monitor replies with &quot;&bslash;r&bslash;n.&quot; (CR LF dot).&n; */
DECL|function|download
r_static
r_int
id|download
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|microcode
comma
r_int
id|length
comma
r_int
id|address
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot;w&squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_wait_data
c_func
(paren
id|cosa
)paren
)paren
op_ne
l_char|&squot;w&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dnld: 0x%04x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;=&squot;
)paren
r_return
op_minus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|puthexnumber
c_func
(paren
id|cosa
comma
id|address
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot; &squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot; &squot;
)paren
r_return
op_minus
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;=&squot;
)paren
r_return
op_minus
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|puthexnumber
c_func
(paren
id|cosa
comma
id|address
op_plus
id|length
op_minus
l_int|1
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|13
suffix:semicolon
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot; &squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|18
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot; &squot;
)paren
r_return
op_minus
l_int|19
suffix:semicolon
r_while
c_loop
(paren
id|length
op_decrement
)paren
(brace
r_char
id|c
suffix:semicolon
macro_line|#ifndef SRP_DOWNLOAD_AT_BOOT
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|c
comma
id|microcode
)paren
)paren
r_return
op_minus
l_int|23
suffix:semicolon
multiline_comment|/* ??? */
macro_line|#else
id|c
op_assign
op_star
id|microcode
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
id|c
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|20
suffix:semicolon
id|microcode
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;r&squot;
)paren
r_return
op_minus
l_int|21
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
op_minus
l_int|22
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;.&squot;
)paren
r_return
op_minus
l_int|23
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cosa%d: download completed.&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Starting microcode is done via the &quot;g&quot; command of the SRP monitor.&n; * The chat should be the following: &quot;g&quot; &quot;g=&quot; &quot;&lt;addr&gt;&lt;CR&gt;&quot;&n; * &quot;&lt;CR&gt;&lt;CR&gt;&lt;LF&gt;&lt;CR&gt;&lt;LF&gt;&quot;.&n; */
DECL|function|startmicrocode
r_static
r_int
id|startmicrocode
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|address
)paren
(brace
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot;g&squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;g&squot;
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;=&squot;
)paren
r_return
op_minus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|puthexnumber
c_func
(paren
id|cosa
comma
id|address
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot;&bslash;r&squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;r&squot;
)paren
r_return
op_minus
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;r&squot;
)paren
r_return
op_minus
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
op_minus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;r&squot;
)paren
r_return
op_minus
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
op_minus
l_int|10
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cosa%d: microcode started&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reading memory is done via the &quot;r&quot; command of the SRP monitor.&n; * The chat is the following &quot;r&quot; &quot;r=&quot; &quot;&lt;addr&gt; &quot; &quot; =&quot; &quot;&lt;last_byte&gt; &quot; &quot; &quot;&n; * Then driver can read the data and the conversation is finished&n; * by SRP monitor sending &quot;&lt;CR&gt;&lt;LF&gt;.&quot; (dot at the end).&n; *&n; * This routine is not needed during the normal operation and serves&n; * for debugging purposes only.&n; */
DECL|function|readmem
r_static
r_int
id|readmem
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|microcode
comma
r_int
id|length
comma
r_int
id|address
)paren
(brace
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot;r&squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
)paren
op_ne
l_char|&squot;r&squot;
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
)paren
op_ne
l_char|&squot;=&squot;
)paren
r_return
op_minus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|puthexnumber
c_func
(paren
id|cosa
comma
id|address
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot; &squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot; &squot;
)paren
r_return
op_minus
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;=&squot;
)paren
r_return
op_minus
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|puthexnumber
c_func
(paren
id|cosa
comma
id|address
op_plus
id|length
op_minus
l_int|1
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
l_char|&squot; &squot;
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot; &squot;
)paren
r_return
op_minus
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|length
op_decrement
)paren
(brace
r_char
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_wait_data
c_func
(paren
id|cosa
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;cosa: 0x%04x bytes remaining&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
r_return
op_minus
l_int|11
suffix:semicolon
)brace
id|c
op_assign
id|i
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|c
comma
id|microcode
)paren
)paren
r_return
op_minus
l_int|23
suffix:semicolon
multiline_comment|/* ??? */
macro_line|#else
op_star
id|microcode
op_assign
id|c
suffix:semicolon
macro_line|#endif
id|microcode
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;r&squot;
)paren
r_return
op_minus
l_int|21
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
op_minus
l_int|22
suffix:semicolon
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
l_char|&squot;.&squot;
)paren
r_return
op_minus
l_int|23
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cosa%d: readmem completed.&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function resets the device and reads the initial prompt&n; * of the device&squot;s ROM monitor.&n; */
DECL|function|cosa_reset_and_read_id
r_static
r_int
id|cosa_reset_and_read_id
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_char
op_star
id|idstring
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|id
op_assign
l_int|0
comma
id|prev
op_assign
l_int|0
comma
id|curr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the card ... */
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
suffix:semicolon
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_RST
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
macro_line|#else
id|udelay
c_func
(paren
l_int|5
op_star
l_int|100000
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable all IRQs from the card */
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to read the ID string. The card then prints out the&n;&t; * identification string ended by the &quot;&bslash;n&bslash;x2e&quot;.&n;&t; *&n;&t; * The following loop is indexed through i (instead of id)&n;&t; * to avoid looping forever when for any reason&n;&t; * the port returns &squot;&bslash;r&squot;, &squot;&bslash;n&squot; or &squot;&bslash;x2e&squot; permanently.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COSA_MAX_ID_STRING
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
comma
id|prev
op_assign
id|curr
)paren
(brace
r_if
c_cond
(paren
(paren
id|curr
op_assign
id|get_wait_data
c_func
(paren
id|cosa
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|curr
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_ne
l_char|&squot;&bslash;r&squot;
op_logical_and
id|curr
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|curr
op_ne
l_int|0x2e
)paren
id|idstring
(braket
id|id
op_increment
)braket
op_assign
id|curr
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_eq
l_int|0x2e
op_logical_and
id|prev
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Perhaps we should fail when i==COSA_MAX_ID_STRING-1 ? */
id|idstring
(braket
id|id
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|id
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ---------- Auxiliary routines for COSA/SRP monitor ---------- */
multiline_comment|/*&n; * This routine gets the data byte from the card waiting for the SR_RX_RDY&n; * bit to be set in a loop. It should be used in the exceptional cases&n; * only (for example when resetting the card or downloading the firmware.&n; */
DECL|function|get_wait_data
r_static
r_int
id|get_wait_data
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
)paren
(brace
r_int
id|retries
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|retries
)paren
(brace
multiline_comment|/* read data and return them */
r_if
c_cond
(paren
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
op_amp
id|SR_RX_RDY
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa: get_wait_data returning after %d retries&bslash;n&quot;
comma
l_int|999
op_minus
id|retries
)paren
suffix:semicolon
macro_line|#endif
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* sleep if not ready to read */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa: timeout in get_wait_data (status 0x%x)&bslash;n&quot;
comma
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine puts the data byte to the card waiting for the SR_TX_RDY&n; * bit to be set in a loop. It should be used in the exceptional cases&n; * only (for example when resetting the card or downloading the firmware).&n; */
DECL|function|put_wait_data
r_static
r_int
id|put_wait_data
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
(brace
r_int
id|retries
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|retries
)paren
(brace
multiline_comment|/* read data and return them */
r_if
c_cond
(paren
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
op_amp
id|SR_TX_RDY
)paren
(brace
id|cosa_putdata8
c_func
(paren
id|cosa
comma
id|data
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Putdata: %d retries&bslash;n&quot;
comma
l_int|999
op_minus
id|retries
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* sleep if not ready to read */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: timeout in put_wait_data (status 0x%x)&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * The following routine puts the hexadecimal number into the SRP monitor&n; * and verifies the proper echo of the sent bytes. Returns 0 on success,&n; * negative number on failure (-1,-3,-5,-7) means that put_wait_data() failed,&n; * (-2,-4,-6,-8) means that reading echo failed.&n; */
DECL|function|puthexnumber
r_static
r_int
id|puthexnumber
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|number
)paren
(brace
r_char
id|temp
(braket
l_int|5
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Well, I should probably replace this by something faster. */
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;%04X&quot;
comma
id|number
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|put_wait_data
c_func
(paren
id|cosa
comma
id|temp
(braket
id|i
)braket
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: puthexnumber failed to write byte %d&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
op_minus
l_int|2
op_star
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_wait_data
c_func
(paren
id|cosa
)paren
op_ne
id|temp
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: puthexhumber failed to read echo of byte %d&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|2
op_minus
l_int|2
op_star
id|i
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ---------- Interrupt routines ---------- */
multiline_comment|/*&n; * There are three types of interrupt:&n; * At the beginning of transmit - this handled is in tx_interrupt(),&n; * at the beginning of receive - it is in rx_interrupt() and&n; * at the end of transmit/receive - it is the eot_interrupt() function.&n; * These functions are multiplexed by cosa_interrupt() according to the&n; * COSA status byte. I have moved the rx/tx/eot interrupt handling into&n; * separate functions to make it more readable. These functions are inline,&n; * so there should be no overhead of function call.&n; * &n; * In the COSA bus-master mode, we need to tell the card the address of a&n; * buffer. Unfortunately, COSA may be too slow for us, so we must busy-wait.&n; * It&squot;s time to use the bottom half :-(&n; */
multiline_comment|/*&n; * Transmit interrupt routine - called when COSA is willing to obtain&n; * data from the OS. The most tricky part of the routine is selection&n; * of channel we (OS) want to send packet for. For SRP we should probably&n; * use the round-robin approach. The newer COSA firmwares have a simple&n; * flow-control - in the status word has bits 2 and 3 set to 1 means that the&n; * channel 0 or 1 doesn&squot;t want to receive data.&n; *&n; * It seems there is a bug in COSA firmware (need to trace it further):&n; * When the driver status says that the kernel has no more data for transmit&n; * (e.g. at the end of TX DMA) and then the kernel changes its mind&n; * (e.g. new packet is queued to hard_start_xmit()), the card issues&n; * the TX interrupt but does not mark the channel as ready-to-transmit.&n; * The fix seems to be to push the packet to COSA despite its request.&n; * We first try to obey the card&squot;s opinion, and then fall back to forced TX.&n; */
DECL|function|tx_interrupt
r_static
r_inline
r_void
id|tx_interrupt
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
(brace
r_int
r_int
id|flags
comma
id|flags1
suffix:semicolon
macro_line|#ifdef DEBUG_IRQS
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: SR_DOWN_REQUEST status=0x%04x&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
(brace
multiline_comment|/* flow control, see the comment above */
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cosa-&gt;txbitmap
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No channel wants data &quot;
l_string|&quot;in TX IRQ. Expect DMA timeout.&quot;
comma
id|cosa-&gt;name
)paren
suffix:semicolon
id|put_driver_status_nolock
c_func
(paren
id|cosa
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|TXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cosa-&gt;txchan
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;txchan
op_ge
id|cosa-&gt;nchannels
)paren
id|cosa-&gt;txchan
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cosa-&gt;txbitmap
op_amp
(paren
l_int|1
op_lshift
id|cosa-&gt;txchan
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|status
op_amp
(paren
l_int|1
op_lshift
(paren
id|cosa-&gt;txchan
op_plus
id|DRIVER_TXMAP_SHIFT
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* in second pass, accept first ready-to-TX channel */
r_if
c_cond
(paren
id|i
OG
id|cosa-&gt;nchannels
)paren
(brace
multiline_comment|/* Can be safely ignored */
macro_line|#ifdef DEBUG_IRQS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Forcing TX &quot;
l_string|&quot;to not-ready channel %d&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;txchan
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
id|cosa-&gt;txsize
op_assign
id|cosa-&gt;chan
(braket
id|cosa-&gt;txchan
)braket
dot
id|txsize
suffix:semicolon
r_if
c_cond
(paren
id|cosa_dma_able
c_func
(paren
id|cosa-&gt;chan
op_plus
id|cosa-&gt;txchan
comma
id|cosa-&gt;chan
(braket
id|cosa-&gt;txchan
)braket
dot
id|txbuf
comma
id|cosa-&gt;txsize
)paren
)paren
(brace
id|cosa-&gt;txbuf
op_assign
id|cosa-&gt;chan
(braket
id|cosa-&gt;txchan
)braket
dot
id|txbuf
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|cosa-&gt;bouncebuf
comma
id|cosa-&gt;chan
(braket
id|cosa-&gt;txchan
)braket
dot
id|txbuf
comma
id|cosa-&gt;txsize
)paren
suffix:semicolon
id|cosa-&gt;txbuf
op_assign
id|cosa-&gt;bouncebuf
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|is_8bit
c_func
(paren
id|cosa
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
(brace
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_TX_INT_ENA
)paren
suffix:semicolon
id|cosa_putdata8
c_func
(paren
id|cosa
comma
(paren
(paren
id|cosa-&gt;txchan
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
)paren
op_or
(paren
(paren
id|cosa-&gt;txsize
op_rshift
l_int|8
)paren
op_amp
l_int|0x1f
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
id|SR_TX_INT_ENA
)paren
suffix:semicolon
id|debug_data_out
c_func
(paren
id|cosa
comma
(paren
(paren
id|cosa-&gt;txchan
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
)paren
op_or
(paren
(paren
id|cosa-&gt;txsize
op_rshift
l_int|8
)paren
op_amp
l_int|0x1f
)paren
)paren
suffix:semicolon
id|debug_data_in
c_func
(paren
id|cosa
comma
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
)paren
suffix:semicolon
macro_line|#else
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
suffix:semicolon
macro_line|#endif
id|set_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
id|cosa_putdata8
c_func
(paren
id|cosa
comma
id|cosa-&gt;txsize
op_amp
l_int|0xff
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
id|debug_data_out
c_func
(paren
id|cosa
comma
id|cosa-&gt;txsize
op_amp
l_int|0xff
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_TX_INT_ENA
)paren
suffix:semicolon
id|cosa_putdata16
c_func
(paren
id|cosa
comma
(paren
(paren
id|cosa-&gt;txchan
op_lshift
l_int|13
)paren
op_amp
l_int|0xe000
)paren
op_or
(paren
id|cosa-&gt;txsize
op_amp
l_int|0x1fff
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
id|SR_TX_INT_ENA
)paren
suffix:semicolon
id|debug_data_out
c_func
(paren
id|cosa
comma
(paren
(paren
id|cosa-&gt;txchan
op_lshift
l_int|13
)paren
op_amp
l_int|0xe000
)paren
op_or
(paren
id|cosa-&gt;txsize
op_amp
l_int|0x1fff
)paren
)paren
suffix:semicolon
id|debug_data_in
c_func
(paren
id|cosa
comma
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
)paren
suffix:semicolon
id|debug_status_out
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
suffix:semicolon
macro_line|#endif
id|cosa_putstatus
c_func
(paren
id|cosa
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cosa-&gt;busmaster
)paren
(brace
r_int
r_int
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|cosa-&gt;txbuf
)paren
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;busmaster IRQ&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
op_amp
id|SR_TX_RDY
)paren
)paren
(brace
id|count
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|1000
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;status %x&bslash;n&quot;
comma
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ready after %d loops&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|cosa_putdata16
c_func
(paren
id|cosa
comma
(paren
id|addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
op_amp
id|SR_TX_RDY
)paren
)paren
(brace
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|1000
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ready after %d loops&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|cosa_putdata16
c_func
(paren
id|cosa
comma
id|addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|flags1
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|cosa-&gt;dma
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* start the DMA */
id|flags1
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|cosa-&gt;dma
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|cosa-&gt;dma
comma
id|virt_to_bus
c_func
(paren
id|cosa-&gt;txbuf
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|cosa-&gt;dma
comma
id|cosa-&gt;txsize
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags1
)paren
suffix:semicolon
)brace
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_TX_DMA_ENA
op_or
id|SR_USR_INT_ENA
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
id|SR_TX_DMA_ENA
op_or
id|SR_USR_INT_ENA
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|rx_interrupt
r_static
r_inline
r_void
id|rx_interrupt
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_IRQS
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: SR_UP_REQUEST&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|RXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_8bit
c_func
(paren
id|cosa
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
id|put_driver_status_nolock
c_func
(paren
id|cosa
)paren
suffix:semicolon
id|cosa-&gt;rxsize
op_assign
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
op_lshift
l_int|8
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_data_in
c_func
(paren
id|cosa
comma
id|cosa-&gt;rxsize
op_rshift
l_int|8
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|IRQBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
suffix:semicolon
id|cosa-&gt;rxsize
op_or_assign
id|cosa_getdata8
c_func
(paren
id|cosa
)paren
op_amp
l_int|0xff
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_data_in
c_func
(paren
id|cosa
comma
id|cosa-&gt;rxsize
op_amp
l_int|0xff
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: receive rxsize = (0x%04x).&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|cosa-&gt;rxsize
op_assign
id|cosa_getdata16
c_func
(paren
id|cosa
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_data_in
c_func
(paren
id|cosa
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: receive rxsize = (0x%04x).&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
(paren
id|cosa-&gt;rxsize
op_amp
l_int|0xe000
)paren
op_rshift
l_int|13
)paren
op_ge
id|cosa-&gt;nchannels
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: rx for unknown channel (0x%04x)&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
id|cosa-&gt;rxchan
op_assign
id|cosa-&gt;chan
op_plus
(paren
(paren
id|cosa-&gt;rxsize
op_amp
l_int|0xe000
)paren
op_rshift
l_int|13
)paren
suffix:semicolon
id|cosa-&gt;rxsize
op_and_assign
l_int|0x1fff
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cosa-&gt;rxbuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;rxchan-&gt;setup_rx
)paren
id|cosa-&gt;rxbuf
op_assign
id|cosa-&gt;rxchan
op_member_access_from_pointer
id|setup_rx
c_func
(paren
id|cosa-&gt;rxchan
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cosa-&gt;rxbuf
)paren
(brace
id|reject
suffix:colon
multiline_comment|/* Reject the packet */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: rejecting packet on channel %d&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;rxchan-&gt;num
)paren
suffix:semicolon
id|cosa-&gt;rxbuf
op_assign
id|cosa-&gt;bouncebuf
suffix:semicolon
)brace
multiline_comment|/* start the DMA */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|cosa-&gt;dma
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cosa_dma_able
c_func
(paren
id|cosa-&gt;rxchan
comma
id|cosa-&gt;rxbuf
comma
id|cosa-&gt;rxsize
op_amp
l_int|0x1fff
)paren
)paren
(brace
id|set_dma_addr
c_func
(paren
id|cosa-&gt;dma
comma
id|virt_to_bus
c_func
(paren
id|cosa-&gt;rxbuf
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_dma_addr
c_func
(paren
id|cosa-&gt;dma
comma
id|virt_to_bus
c_func
(paren
id|cosa-&gt;bouncebuf
)paren
)paren
suffix:semicolon
)brace
id|set_dma_count
c_func
(paren
id|cosa-&gt;dma
comma
(paren
id|cosa-&gt;rxsize
op_amp
l_int|0x1fff
)paren
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cosa_putstatus
c_func
(paren
id|cosa
comma
id|SR_RX_DMA_ENA
op_or
id|SR_USR_INT_ENA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_8bit
c_func
(paren
id|cosa
)paren
op_logical_and
(paren
id|status
op_amp
id|SR_TX_RDY
)paren
)paren
id|cosa_putdata8
c_func
(paren
id|cosa
comma
id|DRIVER_RX_READY
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IO
id|debug_status_out
c_func
(paren
id|cosa
comma
id|SR_RX_DMA_ENA
op_or
id|SR_USR_INT_ENA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_8bit
c_func
(paren
id|cosa
)paren
op_logical_and
(paren
id|status
op_amp
id|SR_TX_RDY
)paren
)paren
id|debug_data_cmd
c_func
(paren
id|cosa
comma
id|DRIVER_RX_READY
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|eot_interrupt
r_static
r_void
r_inline
id|eot_interrupt
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
(brace
r_int
r_int
id|flags
comma
id|flags1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|flags1
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|cosa-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
(brace
r_struct
id|channel_data
op_star
id|chan
op_assign
id|cosa-&gt;chan
op_plus
id|cosa-&gt;txchan
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;tx_done
)paren
r_if
c_cond
(paren
id|chan
op_member_access_from_pointer
id|tx_done
c_func
(paren
id|chan
comma
id|cosa-&gt;txsize
)paren
)paren
id|clear_bit
c_func
(paren
id|chan-&gt;num
comma
op_amp
id|cosa-&gt;txbitmap
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|RXBIT
comma
op_amp
id|cosa-&gt;rxtx
)paren
)paren
(brace
macro_line|#ifdef DEBUG_DATA
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%dc%d: done rx(0x%x)&quot;
comma
id|cosa-&gt;num
comma
id|cosa-&gt;rxchan-&gt;num
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cosa-&gt;rxsize
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
id|cosa-&gt;rxbuf
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Packet for unknown channel? */
r_if
c_cond
(paren
id|cosa-&gt;rxbuf
op_eq
id|cosa-&gt;bouncebuf
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cosa_dma_able
c_func
(paren
id|cosa-&gt;rxchan
comma
id|cosa-&gt;rxbuf
comma
id|cosa-&gt;rxsize
)paren
)paren
id|memcpy
c_func
(paren
id|cosa-&gt;rxbuf
comma
id|cosa-&gt;bouncebuf
comma
id|cosa-&gt;rxsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cosa-&gt;rxchan-&gt;rx_done
)paren
r_if
c_cond
(paren
id|cosa-&gt;rxchan
op_member_access_from_pointer
id|rx_done
c_func
(paren
id|cosa-&gt;rxchan
)paren
)paren
id|clear_bit
c_func
(paren
id|cosa-&gt;rxchan-&gt;num
comma
op_amp
id|cosa-&gt;rxbitmap
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cosa%d: unexpected EOT interrupt&bslash;n&quot;
comma
id|cosa-&gt;num
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the RXBIT, TXBIT and IRQBIT (the latest should be&n;&t; * cleared anyway). We should do it as soon as possible&n;&t; * so that we can tell the COSA we are done and to give it a time&n;&t; * for recovery.&n;&t; */
id|out
suffix:colon
id|cosa-&gt;rxtx
op_assign
l_int|0
suffix:semicolon
id|put_driver_status_nolock
c_func
(paren
id|cosa
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cosa-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|cosa_interrupt
r_static
r_void
id|cosa_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|cosa_
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|cosa_data
op_star
id|cosa
op_assign
id|cosa_
suffix:semicolon
id|again
suffix:colon
id|status
op_assign
id|cosa_getstatus
c_func
(paren
id|cosa
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IRQS
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: got IRQ, status 0x%02x&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|status
op_amp
l_int|0xff
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_IO
id|debug_status_in
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|status
op_amp
id|SR_CMD_FROM_SRP_MASK
)paren
(brace
r_case
id|SR_DOWN_REQUEST
suffix:colon
id|tx_interrupt
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SR_UP_REQUEST
suffix:colon
id|rx_interrupt
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SR_END_OF_TRANSFER
suffix:colon
id|eot_interrupt
c_func
(paren
id|cosa
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* We may be too fast for SRP. Try to wait a bit more. */
r_if
c_cond
(paren
id|count
op_increment
OL
l_int|100
)paren
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cosa%d: unknown status 0x%02x in IRQ after %d retries&bslash;n&quot;
comma
id|cosa-&gt;num
comma
id|status
op_amp
l_int|0xff
comma
id|count
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_IRQS
r_if
c_cond
(paren
id|count
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %d-times got unknown status in IRQ&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|count
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: returning from IRQ&bslash;n&quot;
comma
id|cosa-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
"&f;"
multiline_comment|/* ---------- I/O debugging routines ---------- */
multiline_comment|/*&n; * These routines can be used to monitor COSA/SRP I/O and to printk()&n; * the data being transfered on the data and status I/O port in a&n; * readable way.&n; */
macro_line|#ifdef DEBUG_IO
DECL|function|debug_status_in
r_static
r_void
id|debug_status_in
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
r_switch
c_cond
(paren
id|status
op_amp
id|SR_CMD_FROM_SRP_MASK
)paren
(brace
r_case
id|SR_UP_REQUEST
suffix:colon
id|s
op_assign
l_string|&quot;RX_REQ&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SR_DOWN_REQUEST
suffix:colon
id|s
op_assign
l_string|&quot;TX_REQ&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SR_END_OF_TRANSFER
suffix:colon
id|s
op_assign
l_string|&quot;ET_REQ&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|s
op_assign
l_string|&quot;NO_REQ&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: IO: status -&gt; 0x%02x (%s%s%s%s)&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|status
comma
id|status
op_amp
id|SR_USR_RQ
ques
c_cond
l_string|&quot;USR_RQ|&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|status
op_amp
id|SR_TX_RDY
ques
c_cond
l_string|&quot;TX_RDY|&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|status
op_amp
id|SR_RX_RDY
ques
c_cond
l_string|&quot;RX_RDY|&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|s
)paren
suffix:semicolon
)brace
DECL|function|debug_status_out
r_static
r_void
id|debug_status_out
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|status
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: IO: status &lt;- 0x%02x (%s%s%s%s%s%s)&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|status
comma
id|status
op_amp
id|SR_RX_DMA_ENA
ques
c_cond
l_string|&quot;RXDMA|&quot;
suffix:colon
l_string|&quot;!rxdma|&quot;
comma
id|status
op_amp
id|SR_TX_DMA_ENA
ques
c_cond
l_string|&quot;TXDMA|&quot;
suffix:colon
l_string|&quot;!txdma|&quot;
comma
id|status
op_amp
id|SR_RST
ques
c_cond
l_string|&quot;RESET|&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|status
op_amp
id|SR_USR_INT_ENA
ques
c_cond
l_string|&quot;USRINT|&quot;
suffix:colon
l_string|&quot;!usrint|&quot;
comma
id|status
op_amp
id|SR_TX_INT_ENA
ques
c_cond
l_string|&quot;TXINT|&quot;
suffix:colon
l_string|&quot;!txint|&quot;
comma
id|status
op_amp
id|SR_RX_INT_ENA
ques
c_cond
l_string|&quot;RXINT&quot;
suffix:colon
l_string|&quot;!rxint&quot;
)paren
suffix:semicolon
)brace
DECL|function|debug_data_in
r_static
r_void
id|debug_data_in
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: IO: data -&gt; 0x%04x&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|debug_data_out
r_static
r_void
id|debug_data_out
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: IO: data &lt;- 0x%04x&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|debug_data_cmd
r_static
r_void
id|debug_data_cmd
c_func
(paren
r_struct
id|cosa_data
op_star
id|cosa
comma
r_int
id|data
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: IO: data &lt;- 0x%04x (%s|%s)&bslash;n&quot;
comma
id|cosa-&gt;name
comma
id|data
comma
id|data
op_amp
id|SR_RDY_RCV
ques
c_cond
l_string|&quot;RX_RDY&quot;
suffix:colon
l_string|&quot;!rx_rdy&quot;
comma
id|data
op_amp
id|SR_RDY_SND
ques
c_cond
l_string|&quot;TX_RDY&quot;
suffix:colon
l_string|&quot;!tx_rdy&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* EOF -- this file has not been truncated */
eof
