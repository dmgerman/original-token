multiline_comment|/*&n;  * Copyright (c) 1997-2000 LAN Media Corporation (LMC)&n;  * All rights reserved.  www.lanmedia.com&n;  *&n;  * This code is written by:&n;  * Andrew Stanley-Jones (asj@cban.com)&n;  * Rob Braun (bbraun@vix.com),&n;  * Michael Graff (explorer@vix.com) and&n;  * Matt Thomas (matt@3am-software.com).&n;  *&n;  * With Help By:&n;  * David Boggs&n;  * Ron Crane&n;  * Allan Cox&n;  *&n;  * This software may be used and distributed according to the terms&n;  * of the GNU Public License version 2, incorporated herein by reference.&n;  *&n;  * Driver for the LanMedia LMC5200, LMC5245, LMC1000, LMC1200 cards.&n;  *&n;  * To control link specific options lmcctl is required.&n;  * It can be obtained from ftp.lanmedia.com.&n;  *&n;  * Linux driver notes:&n;  * Linux uses the device struct lmc_private to pass private information&n;  * arround.&n;  *&n;  * The initialization portion of this driver (the lmc_reset() and the&n;  * lmc_dec_reset() functions, as well as the led controls and the&n;  * lmc_initcsrs() functions.&n;  *&n;  * The watchdog function runs every second and checks to see if&n;  * we still have link, and that the timing source is what we expected&n;  * it to be.  If link is lost, the interface is marked down, and&n;  * we no longer can transmit.&n;  *&n;  */
multiline_comment|/* $Id: lmc_main.c,v 1.36 2000/04/11 05:25:25 asj Exp $ */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#if LINUX_VERSION_CODE &lt; 0x20155
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;asm/processor.h&gt;             /* Processor type for cache alignment. */
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;../syncppp.h&quot;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20200
macro_line|#include &lt;asm/uaccess.h&gt;
singleline_comment|//#include &lt;asm/spinlock.h&gt;
macro_line|#else&t;&t;&t;&t;/* 2.0 kernel */
DECL|macro|ARPHRD_HDLC
mdefine_line|#define ARPHRD_HDLC 513
macro_line|#endif
macro_line|#ifdef MODULE
macro_line|#ifdef MODVERSIONS
macro_line|#include &lt;linux/modversions.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#else
DECL|macro|MOD_INC_USE_COUNT
mdefine_line|#define MOD_INC_USE_COUNT
DECL|macro|MOD_DEC_USE_COUNT
mdefine_line|#define MOD_DEC_USE_COUNT
macro_line|#endif
DECL|macro|DRIVER_MAJOR_VERSION
mdefine_line|#define DRIVER_MAJOR_VERSION     1
DECL|macro|DRIVER_MINOR_VERSION
mdefine_line|#define DRIVER_MINOR_VERSION    34
DECL|macro|DRIVER_SUB_VERSION
mdefine_line|#define DRIVER_SUB_VERSION       0
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION  ((DRIVER_MAJOR_VERSION &lt;&lt; 8) + DRIVER_MINOR_VERSION)
macro_line|#include &quot;lmc_ver.h&quot;
macro_line|#include &quot;lmc.h&quot;
macro_line|#include &quot;lmc_var.h&quot;
macro_line|#include &quot;lmc_ioctl.h&quot;
macro_line|#include &quot;lmc_debug.h&quot;
macro_line|#include &quot;lmc_proto.h&quot;
DECL|variable|Lmc_Count
r_static
r_int
id|Lmc_Count
op_assign
l_int|0
suffix:semicolon
DECL|variable|Lmc_root_dev
r_static
r_struct
id|net_device
op_star
id|Lmc_root_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|cards_found
r_static
id|u8
id|cards_found
op_assign
l_int|0
suffix:semicolon
DECL|variable|lmc_first_load
r_static
r_int
id|lmc_first_load
op_assign
l_int|0
suffix:semicolon
DECL|variable|LMC_PKT_BUF_SZ
r_int
id|LMC_PKT_BUF_SZ
op_assign
l_int|1542
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|lmc_pci_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
l_int|0x1011
comma
l_int|0x009
comma
l_int|0x1379
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|lmc_pci_tbl
)paren
suffix:semicolon
macro_line|#endif
r_int
id|lmc_probe_fake
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|lmc_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
comma
r_int
r_int
id|irq
comma
r_int
id|chip_id
comma
r_int
id|subdevice
comma
r_int
id|board_idx
)paren
suffix:semicolon
r_static
r_int
id|lmc_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|lmc_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|lmc_rx
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|lmc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|lmc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|lmc_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|lmc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|lmc_set_config
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifmap
op_star
id|map
)paren
suffix:semicolon
r_static
r_void
id|lmc_initcsrs
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
id|lmc_csrptr_t
id|csr_base
comma
r_int
id|csr_size
)paren
suffix:semicolon
r_static
r_void
id|lmc_softreset
c_func
(paren
id|lmc_softc_t
op_star
r_const
)paren
suffix:semicolon
r_static
r_void
id|lmc_running_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|lmc_ifdown
c_func
(paren
r_struct
id|net_device
op_star
r_const
)paren
suffix:semicolon
r_static
r_void
id|lmc_watchdog
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_int
id|lmc_init
c_func
(paren
r_struct
id|net_device
op_star
r_const
)paren
suffix:semicolon
r_static
r_void
id|lmc_reset
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
)paren
suffix:semicolon
r_static
r_void
id|lmc_dec_reset
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20363
r_static
r_void
id|lmc_driver_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_int
id|lmc_setup
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * linux reserves 16 device specific IOCTLs.  We call them&n; * LMCIOC* to control various bits of our world.&n; */
DECL|function|lmc_ioctl
r_int
id|lmc_ioctl
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
id|lmc_ctl_t
id|ctl
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|u_int16_t
id|regVal
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sppp
op_star
id|sp
suffix:semicolon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_ioctl in&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Most functions mess with the structure&n;     * Disable interupts while we do the polling&n;     */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;         * Return current driver state.  Since we keep this up&n;         * To date internally, just copy this out to the user.&n;         */
r_case
id|LMCIOCGINFO
suffix:colon
multiline_comment|/*fold01*/
id|LMC_COPY_TO_USER
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|sc-&gt;ictl
comma
r_sizeof
(paren
id|lmc_ctl_t
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMCIOCSINFO
suffix:colon
multiline_comment|/*fold01*/
id|sp
op_assign
op_amp
(paren
(paren
r_struct
id|ppp_device
op_star
)paren
id|dev
)paren
op_member_access_from_pointer
id|sppp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
id|LMC_COPY_FROM_USER
c_func
(paren
op_amp
id|ctl
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|lmc_ctl_t
)paren
)paren
suffix:semicolon
id|sc-&gt;lmc_media-&gt;set_status
(paren
id|sc
comma
op_amp
id|ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctl.crc_length
op_ne
id|sc-&gt;ictl.crc_length
)paren
(brace
id|sc-&gt;lmc_media
op_member_access_from_pointer
id|set_crc_length
c_func
(paren
id|sc
comma
id|ctl.crc_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;ictl.crc_length
op_eq
id|LMC_CTL_CRC_LENGTH_16
)paren
id|sc-&gt;TxDescriptControlInit
op_or_assign
id|LMC_TDES_ADD_CRC_DISABLE
suffix:semicolon
r_else
id|sc-&gt;TxDescriptControlInit
op_and_assign
op_complement
id|LMC_TDES_ADD_CRC_DISABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctl.keepalive_onoff
op_eq
id|LMC_CTL_OFF
)paren
id|sp-&gt;pp_flags
op_and_assign
op_complement
id|PP_KEEPALIVE
suffix:semicolon
multiline_comment|/* Turn off */
r_else
id|sp-&gt;pp_flags
op_or_assign
id|PP_KEEPALIVE
suffix:semicolon
multiline_comment|/* Turn on */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMCIOCIFTYPE
suffix:colon
multiline_comment|/*fold01*/
(brace
id|u_int16_t
id|old_type
op_assign
id|sc-&gt;if_type
suffix:semicolon
id|u_int16_t
id|new_type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|LMC_COPY_FROM_USER
c_func
(paren
op_amp
id|new_type
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|u_int16_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_type
op_eq
id|old_type
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* no change */
)brace
id|lmc_proto_close
c_func
(paren
id|sc
)paren
suffix:semicolon
id|lmc_proto_detach
c_func
(paren
id|sc
)paren
suffix:semicolon
id|sc-&gt;if_type
op_assign
id|new_type
suffix:semicolon
singleline_comment|//            lmc_proto_init(sc);
id|lmc_proto_attach
c_func
(paren
id|sc
)paren
suffix:semicolon
id|lmc_proto_open
c_func
(paren
id|sc
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|LMCIOCGETXINFO
suffix:colon
multiline_comment|/*fold01*/
id|sc-&gt;lmc_xinfo.Magic0
op_assign
l_int|0xBEEFCAFE
suffix:semicolon
id|sc-&gt;lmc_xinfo.PciCardType
op_assign
id|sc-&gt;lmc_cardtype
suffix:semicolon
id|sc-&gt;lmc_xinfo.PciSlotNumber
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_xinfo.DriverMajorVersion
op_assign
id|DRIVER_MAJOR_VERSION
suffix:semicolon
id|sc-&gt;lmc_xinfo.DriverMinorVersion
op_assign
id|DRIVER_MINOR_VERSION
suffix:semicolon
id|sc-&gt;lmc_xinfo.DriverSubVersion
op_assign
id|DRIVER_SUB_VERSION
suffix:semicolon
id|sc-&gt;lmc_xinfo.XilinxRevisionNumber
op_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|3
)paren
op_amp
l_int|0xf
suffix:semicolon
id|sc-&gt;lmc_xinfo.MaxFrameSize
op_assign
id|LMC_PKT_BUF_SZ
suffix:semicolon
id|sc-&gt;lmc_xinfo.link_status
op_assign
id|sc-&gt;lmc_media-&gt;get_link_status
(paren
id|sc
)paren
suffix:semicolon
id|sc-&gt;lmc_xinfo.mii_reg16
op_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|sc-&gt;lmc_xinfo.Magic1
op_assign
l_int|0xDEADBEEF
suffix:semicolon
id|LMC_COPY_TO_USER
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|sc-&gt;lmc_xinfo
comma
r_sizeof
(paren
r_struct
id|lmc_xinfo
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMCIOCGETLMCSTATS
suffix:colon
multiline_comment|/*fold01*/
r_if
c_cond
(paren
id|sc-&gt;lmc_cardtype
op_eq
id|LMC_CARDTYPE_T1
)paren
(brace
id|lmc_mii_writereg
(paren
id|sc
comma
l_int|0
comma
l_int|17
comma
id|T1FRAMER_FERR_LSB
)paren
suffix:semicolon
id|sc-&gt;stats.framingBitErrorCount
op_add_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|18
)paren
op_amp
l_int|0xff
suffix:semicolon
id|lmc_mii_writereg
(paren
id|sc
comma
l_int|0
comma
l_int|17
comma
id|T1FRAMER_FERR_MSB
)paren
suffix:semicolon
id|sc-&gt;stats.framingBitErrorCount
op_add_assign
(paren
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|18
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|lmc_mii_writereg
(paren
id|sc
comma
l_int|0
comma
l_int|17
comma
id|T1FRAMER_LCV_LSB
)paren
suffix:semicolon
id|sc-&gt;stats.lineCodeViolationCount
op_add_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|18
)paren
op_amp
l_int|0xff
suffix:semicolon
id|lmc_mii_writereg
(paren
id|sc
comma
l_int|0
comma
l_int|17
comma
id|T1FRAMER_LCV_MSB
)paren
suffix:semicolon
id|sc-&gt;stats.lineCodeViolationCount
op_add_assign
(paren
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|18
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|lmc_mii_writereg
(paren
id|sc
comma
l_int|0
comma
l_int|17
comma
id|T1FRAMER_AERR
)paren
suffix:semicolon
id|regVal
op_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|18
)paren
op_amp
l_int|0xff
suffix:semicolon
id|sc-&gt;stats.lossOfFrameCount
op_add_assign
(paren
id|regVal
op_amp
id|T1FRAMER_LOF_MASK
)paren
op_rshift
l_int|4
suffix:semicolon
id|sc-&gt;stats.changeOfFrameAlignmentCount
op_add_assign
(paren
id|regVal
op_amp
id|T1FRAMER_COFA_MASK
)paren
op_rshift
l_int|2
suffix:semicolon
id|sc-&gt;stats.severelyErroredFrameCount
op_add_assign
id|regVal
op_amp
id|T1FRAMER_SEF_MASK
suffix:semicolon
)brace
id|LMC_COPY_TO_USER
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|sc-&gt;stats
comma
r_sizeof
(paren
r_struct
id|lmc_statistics
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMCIOCCLEARLMCSTATS
suffix:colon
multiline_comment|/*fold01*/
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
(paren
op_amp
id|sc-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lmc_statistics
)paren
)paren
suffix:semicolon
id|sc-&gt;stats.check
op_assign
id|STATCHECK
suffix:semicolon
id|sc-&gt;stats.version_size
op_assign
(paren
id|DRIVER_VERSION
op_lshift
l_int|16
)paren
op_plus
r_sizeof
(paren
r_struct
id|lmc_statistics
)paren
suffix:semicolon
id|sc-&gt;stats.lmc_cardtype
op_assign
id|sc-&gt;lmc_cardtype
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMCIOCSETCIRCUIT
suffix:colon
multiline_comment|/*fold01*/
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
id|LMC_COPY_FROM_USER
c_func
(paren
op_amp
id|ctl
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|lmc_ctl_t
)paren
)paren
suffix:semicolon
id|sc-&gt;lmc_media
op_member_access_from_pointer
id|set_circuit_type
c_func
(paren
id|sc
comma
id|ctl.circuit_type
)paren
suffix:semicolon
id|sc-&gt;ictl.circuit_type
op_assign
id|ctl.circuit_type
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LMCIOCRESET
suffix:colon
multiline_comment|/*fold01*/
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Reset driver and bring back to current state */
id|printk
(paren
l_string|&quot; REG16 before reset +%04x&bslash;n&quot;
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
)paren
suffix:semicolon
id|lmc_running_reset
(paren
id|dev
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; REG16 after reset +%04x&bslash;n&quot;
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_FORCEDRESET
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef DEBUG
r_case
id|LMCIOCDUMPEVENTLOG
suffix:colon
id|LMC_COPY_TO_USER
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|lmcEventLogIndex
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|LMC_COPY_TO_USER
c_func
(paren
id|ifr-&gt;ifr_data
op_plus
r_sizeof
(paren
id|u32
)paren
comma
id|lmcEventLogBuf
comma
r_sizeof
(paren
id|lmcEventLogBuf
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* end ifdef _DBG_EVENTLOG */
r_case
id|LMCIOCT1CONTROL
suffix:colon
multiline_comment|/*fold01*/
r_if
c_cond
(paren
id|sc-&gt;lmc_cardtype
op_ne
id|LMC_CARDTYPE_T1
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LMCIOCXILINX
suffix:colon
multiline_comment|/*fold01*/
(brace
r_struct
id|lmc_xilinx_control
id|xc
suffix:semicolon
multiline_comment|/*fold02*/
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;             * Stop the xwitter whlie we restart the hardware&n;             */
id|LMC_XMITTER_BUSY
c_func
(paren
id|dev
)paren
suffix:semicolon
id|LMC_COPY_FROM_USER
c_func
(paren
op_amp
id|xc
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
r_struct
id|lmc_xilinx_control
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|xc.command
)paren
(brace
r_case
id|lmc_xilinx_reset
suffix:colon
multiline_comment|/*fold02*/
(brace
id|u16
id|mii
suffix:semicolon
id|mii
op_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;                     * Make all of them 0 and make input&n;                     */
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/*&n;                     * make the reset output&n;                     */
id|lmc_gpio_mkoutput
c_func
(paren
id|sc
comma
id|LMC_GEP_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;                     * RESET low to force configuration.  This also forces&n;                     * the transmitter clock to be internal, but we expect to reset&n;                     * that later anyway.&n;                     */
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
id|LMC_GEP_RESET
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
multiline_comment|/*&n;                     * hold for more than 10 microseconds&n;                     */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_RESET
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
multiline_comment|/*&n;                     * stop driving Xilinx-related signals&n;                     */
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Reset the frammer hardware */
id|sc-&gt;lmc_media-&gt;set_link_status
(paren
id|sc
comma
l_int|1
)paren
suffix:semicolon
id|sc-&gt;lmc_media-&gt;set_status
(paren
id|sc
comma
l_int|NULL
)paren
suffix:semicolon
singleline_comment|//                    lmc_softreset(sc);
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lmc_led_on
c_func
(paren
id|sc
comma
id|LMC_DS3_LED0
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|lmc_led_off
c_func
(paren
id|sc
comma
id|LMC_DS3_LED0
)paren
suffix:semicolon
id|lmc_led_on
c_func
(paren
id|sc
comma
id|LMC_DS3_LED1
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|lmc_led_off
c_func
(paren
id|sc
comma
id|LMC_DS3_LED1
)paren
suffix:semicolon
id|lmc_led_on
c_func
(paren
id|sc
comma
id|LMC_DS3_LED3
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|lmc_led_off
c_func
(paren
id|sc
comma
id|LMC_DS3_LED3
)paren
suffix:semicolon
id|lmc_led_on
c_func
(paren
id|sc
comma
id|LMC_DS3_LED2
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|lmc_led_off
c_func
(paren
id|sc
comma
id|LMC_DS3_LED2
)paren
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0x0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|lmc_xilinx_load_prom
suffix:colon
multiline_comment|/*fold02*/
(brace
id|u16
id|mii
suffix:semicolon
r_int
id|timeout
op_assign
l_int|500000
suffix:semicolon
id|mii
op_assign
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;                     * Make all of them 0 and make input&n;                     */
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/*&n;                     * make the reset output&n;                     */
id|lmc_gpio_mkoutput
c_func
(paren
id|sc
comma
id|LMC_GEP_DP
op_or
id|LMC_GEP_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;                     * RESET low to force configuration.  This also forces&n;                     * the transmitter clock to be internal, but we expect to reset&n;                     * that later anyway.&n;                     */
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
(paren
id|LMC_GEP_RESET
op_or
id|LMC_GEP_DP
)paren
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
multiline_comment|/*&n;                     * hold for more than 10 microseconds&n;                     */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_DP
op_or
id|LMC_GEP_RESET
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
multiline_comment|/*&n;                     * busy wait for the chip to reset&n;                     */
r_while
c_loop
(paren
(paren
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_gp
)paren
op_amp
id|LMC_GEP_INIT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|timeout
op_decrement
OG
l_int|0
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;                     * stop driving Xilinx-related signals&n;                     */
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
id|ret
op_assign
l_int|0x0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|lmc_xilinx_load
suffix:colon
multiline_comment|/*fold02*/
(brace
r_char
op_star
id|data
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_int
id|timeout
op_assign
l_int|500000
suffix:semicolon
r_if
c_cond
(paren
id|xc.data
op_eq
l_int|0x0
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|data
op_assign
id|kmalloc
c_func
(paren
id|xc.len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|0x0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed to allocate memory for copy&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|LMC_COPY_FROM_USER
c_func
(paren
id|data
comma
id|xc.data
comma
id|xc.len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Starting load of data Len: %d at 0x%p == 0x%p&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|xc.len
comma
id|xc.data
comma
id|data
)paren
suffix:semicolon
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/*&n;                     * Clear the Xilinx and start prgramming from the DEC&n;                     */
multiline_comment|/*&n;                     * Set ouput as:&n;                     * Reset: 0 (active)&n;                     * DP:    0 (active)&n;                     * Mode:  1&n;                     *&n;                     */
id|sc-&gt;lmc_gpio
op_assign
l_int|0x00
suffix:semicolon
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
id|LMC_GEP_DP
suffix:semicolon
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
id|LMC_GEP_RESET
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_MODE
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
id|lmc_gpio_mkoutput
c_func
(paren
id|sc
comma
id|LMC_GEP_MODE
op_or
id|LMC_GEP_DP
op_or
id|LMC_GEP_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;                     * Wait at least 10 us 20 to be safe&n;                     */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/*&n;                     * Clear reset and activate programing lines&n;                     * Reset: Input&n;                     * DP:    Input&n;                     * Clock: Output&n;                     * Data:  Output&n;                     * Mode:  Output&n;                     */
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
id|LMC_GEP_DP
op_or
id|LMC_GEP_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;                     * Set LOAD, DATA, Clock to 1&n;                     */
id|sc-&gt;lmc_gpio
op_assign
l_int|0x00
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_MODE
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_DATA
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_CLK
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
id|lmc_gpio_mkoutput
c_func
(paren
id|sc
comma
id|LMC_GEP_DATA
op_or
id|LMC_GEP_CLK
op_or
id|LMC_GEP_MODE
)paren
suffix:semicolon
multiline_comment|/*&n;                     * busy wait for the chip to reset&n;                     */
r_while
c_loop
(paren
(paren
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_gp
)paren
op_amp
id|LMC_GEP_INIT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|timeout
op_decrement
OG
l_int|0
)paren
)paren
(brace
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Waited %d for the Xilinx to clear it&squot;s memory&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_int|500000
op_minus
id|timeout
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|xc.len
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|data
(braket
id|pos
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
id|LMC_GEP_DATA
suffix:semicolon
multiline_comment|/* Data is 0 */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_DATA
suffix:semicolon
multiline_comment|/* Data is 1 */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s Bad data in xilinx programing data at %d, got %d wanted 0 or 1&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pos
comma
id|data
(braket
id|pos
)braket
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_DATA
suffix:semicolon
multiline_comment|/* Assume it&squot;s 1 */
)brace
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
id|LMC_GEP_CLK
suffix:semicolon
multiline_comment|/* Clock to zero */
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_MODE
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_CLK
suffix:semicolon
multiline_comment|/* Put the clack back to one */
id|sc-&gt;lmc_gpio
op_or_assign
id|LMC_GEP_MODE
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_gp
)paren
op_amp
id|LMC_GEP_INIT
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Reprograming FAILED. Needs to be reprogramed. (corrupted data)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_gp
)paren
op_amp
id|LMC_GEP_DP
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Reprograming FAILED. Needs to be reprogramed. (done)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Done reprograming Xilinx, %d bits, good luck!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pos
)paren
suffix:semicolon
)brace
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
id|sc-&gt;lmc_miireg16
op_or_assign
id|LMC_MII16_FIFO_RESET
suffix:semicolon
id|lmc_mii_writereg
c_func
(paren
id|sc
comma
l_int|0
comma
l_int|16
comma
id|sc-&gt;lmc_miireg16
)paren
suffix:semicolon
id|sc-&gt;lmc_miireg16
op_and_assign
op_complement
id|LMC_MII16_FIFO_RESET
suffix:semicolon
id|lmc_mii_writereg
c_func
(paren
id|sc
comma
l_int|0
comma
l_int|16
comma
id|sc-&gt;lmc_miireg16
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/*fold02*/
id|ret
op_assign
op_minus
id|EBADE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc-&gt;lmc_txfull
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*fold01*/
multiline_comment|/* If we don&squot;t know what to do, give the protocol a shot. */
id|ret
op_assign
id|lmc_proto_ioctl
(paren
id|sc
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*fold01*/
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_ioctl out&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* the watchdog process that cruises around */
DECL|function|lmc_watchdog
r_static
r_void
id|lmc_watchdog
(paren
r_int
r_int
id|data
)paren
multiline_comment|/*fold00*/
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
r_int
id|link_status
suffix:semicolon
id|u_int32_t
id|ticks
suffix:semicolon
id|LMC_SPIN_FLAGS
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_watchdog in&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;check
op_ne
l_int|0xBEAFCAFE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;LMC: Corrupt net_device stuct, breaking out&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Make sure the tx jabber and rx watchdog are off,&n;     * and the transmit and recieve processes are running.&n;     */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_15
comma
l_int|0x00000011
)paren
suffix:semicolon
id|sc-&gt;lmc_cmdmode
op_or_assign
id|TULIP_CMD_TXRUN
op_or
id|TULIP_CMD_RXRUN
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|sc-&gt;lmc_cmdmode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;lmc_ok
op_eq
l_int|0
)paren
r_goto
id|kick_timer
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_WATCHDOG
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* --- begin time out check -----------------------------------&n;     * check for a transmit interrupt timeout&n;     * Has the packet xmt vs xmt serviced threshold been exceeded */
r_if
c_cond
(paren
id|sc-&gt;lmc_taint_tx
op_eq
id|sc-&gt;lastlmc_taint_tx
op_logical_and
id|sc-&gt;stats.tx_packets
OG
id|sc-&gt;lasttx_packets
op_logical_and
id|sc-&gt;tx_TimeoutInd
op_eq
l_int|0
)paren
(brace
multiline_comment|/* wait for the watchdog to come around again */
id|sc-&gt;tx_TimeoutInd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sc-&gt;lmc_taint_tx
op_eq
id|sc-&gt;lastlmc_taint_tx
op_logical_and
id|sc-&gt;stats.tx_packets
OG
id|sc-&gt;lasttx_packets
op_logical_and
id|sc-&gt;tx_TimeoutInd
)paren
(brace
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_XMTINTTMO
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
l_int|0
)paren
suffix:semicolon
id|sc-&gt;tx_TimeoutDisplay
op_assign
l_int|1
suffix:semicolon
id|sc-&gt;stats.tx_TimeoutCnt
op_increment
suffix:semicolon
multiline_comment|/* DEC chip is stuck, hit it with a RESET!!!! */
id|lmc_running_reset
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* look at receive &amp; transmit process state to make sure they are running */
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET1
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* look at: DSR - 02  for Reg 16&n;         *                  CTS - 08&n;         *                  DCD - 10&n;         *                  RI  - 20&n;         * for Reg 17&n;         */
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET2
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|17
)paren
)paren
suffix:semicolon
multiline_comment|/* reset the transmit timeout detection flag */
id|sc-&gt;tx_TimeoutInd
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lastlmc_taint_tx
op_assign
id|sc-&gt;lmc_taint_tx
suffix:semicolon
id|sc-&gt;lasttx_packets
op_assign
id|sc-&gt;stats.tx_packets
suffix:semicolon
)brace
r_else
(brace
id|sc-&gt;tx_TimeoutInd
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lastlmc_taint_tx
op_assign
id|sc-&gt;lmc_taint_tx
suffix:semicolon
id|sc-&gt;lasttx_packets
op_assign
id|sc-&gt;stats.tx_packets
suffix:semicolon
)brace
multiline_comment|/* --- end time out check ----------------------------------- */
id|link_status
op_assign
id|sc-&gt;lmc_media-&gt;get_link_status
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/*&n;     * hardware level link lost, but the interface is marked as up.&n;     * Mark it as down.&n;     */
r_if
c_cond
(paren
(paren
id|link_status
op_eq
l_int|0
)paren
op_logical_and
(paren
id|sc-&gt;last_link_status
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: hardware/physical link down&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;last_link_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* lmc_reset (sc); Why reset??? The link can go down ok */
multiline_comment|/* Inform the world that link has been lost */
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n;     * hardware link is up, but the interface is marked as down.&n;     * Bring it back up again.&n;     */
r_if
c_cond
(paren
id|link_status
op_ne
l_int|0
op_logical_and
id|sc-&gt;last_link_status
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: hardware/physical link up&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;last_link_status
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* lmc_reset (sc); Again why reset??? */
multiline_comment|/* Inform the world that link protocol is back up. */
id|dev-&gt;flags
op_or_assign
id|IFF_RUNNING
suffix:semicolon
multiline_comment|/* Now we have to tell the syncppp that we had an outage&n;          * and that it should deal.  Calling sppp_reopen here&n;          * should do the trick, but we may have to call sppp_close&n;          * when the link goes down, and call sppp_open here.&n;          * Subject to more testing.&n;          * --bbraun&n;          */
id|lmc_proto_reopen
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
multiline_comment|/* Call media specific watchdog functions */
id|sc-&gt;lmc_media
op_member_access_from_pointer
id|watchdog
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/*&n;     * Poke the transmitter to make sure it&n;     * never stops, even if we run out of mem&n;     */
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_rxpoll
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;     * Check for code that failed&n;     * and try and fix it as appropriate&n;     */
r_if
c_cond
(paren
id|sc-&gt;failed_ring
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;         * Failed to setup the recv/xmit rin&n;         * Try again&n;         */
id|sc-&gt;failed_ring
op_assign
l_int|0
suffix:semicolon
id|lmc_softreset
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sc-&gt;failed_recv_alloc
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;         * We failed to alloc mem in the&n;         * interupt halder, go through the rings&n;         * and rebuild them&n;         */
id|sc-&gt;failed_recv_alloc
op_assign
l_int|0
suffix:semicolon
id|lmc_softreset
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * remember the timer value&n;     */
id|kick_timer
suffix:colon
id|ticks
op_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_gp_timer
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_gp_timer
comma
l_int|0xffffffffUL
)paren
suffix:semicolon
id|sc-&gt;ictl.ticks
op_assign
l_int|0x0000ffff
op_minus
(paren
id|ticks
op_amp
l_int|0x0000ffff
)paren
suffix:semicolon
multiline_comment|/*&n;     * restart this timer.&n;     */
id|sc-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
)paren
suffix:semicolon
id|add_timer
(paren
op_amp
id|sc-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_watchdog out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_init
r_static
r_int
id|lmc_init
c_func
(paren
r_struct
id|net_device
op_star
r_const
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_init in&quot;
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_init out&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This initializes each card from lmc_probe() */
DECL|function|lmc_probe1
r_static
r_struct
id|net_device
op_star
id|lmc_probe1
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
comma
r_int
r_int
id|irq
comma
multiline_comment|/*fold00*/
r_int
id|chip_id
comma
r_int
id|subdevice
comma
r_int
id|board_idx
)paren
(brace
id|lmc_softc_t
op_star
id|sc
op_assign
l_int|NULL
suffix:semicolon
id|u_int16_t
id|AdapModelNum
suffix:semicolon
multiline_comment|/*&n;     * Allocate our own device structure&n;     */
macro_line|#if LINUX_VERSION_CODE &lt; 0x20363
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|ppp_device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
macro_line|#else
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;lmc: kmalloc for device failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
macro_line|#ifndef GCOM
multiline_comment|/*&n;     *&t;Switch to common hdlc%d naming. We name by type not by vendor&n;     */
id|dev_alloc_name
c_func
(paren
id|dev
comma
l_string|&quot;hdlc%d&quot;
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;     * GCOM uses LMC vendor name so that clients can know which card&n;     * to attach to.&n;     */
id|dev_alloc_name
c_func
(paren
id|dev
comma
l_string|&quot;lmc%d&quot;
)paren
suffix:semicolon
macro_line|#endif
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_probe1 in&quot;
)paren
suffix:semicolon
id|Lmc_Count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lmc_first_load
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Lan Media Corporation WAN Driver Version %d.%d.%d&bslash;n&quot;
comma
id|DRIVER_MAJOR_VERSION
comma
id|DRIVER_MINOR_VERSION
comma
id|DRIVER_SUB_VERSION
)paren
suffix:semicolon
id|lmc_first_load
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate space for the private data structure&n;     */
id|sc
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|lmc_softc_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: Cannot allocate memory for device state&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|memset
(paren
id|sc
comma
l_int|0
comma
r_sizeof
(paren
id|lmc_softc_t
)paren
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|sc
suffix:semicolon
id|sc-&gt;lmc_device
op_assign
id|dev
suffix:semicolon
id|sc-&gt;name
op_assign
id|dev-&gt;name
suffix:semicolon
multiline_comment|/* Initialize the sppp layer */
multiline_comment|/* An ioctl can cause a subsequent detach for raw frame interface */
id|sc-&gt;if_type
op_assign
id|LMC_PPP
suffix:semicolon
id|sc-&gt;check
op_assign
l_int|0xBEAFCAFE
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
multiline_comment|/*&n;     * This will get the protocol layer ready and do any 1 time init&squot;s&n;     * Must have a valid sc and dev structure&n;     */
id|lmc_proto_init
c_func
(paren
id|sc
)paren
suffix:semicolon
id|lmc_proto_attach
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* Just fill in the entries for the device */
id|dev-&gt;init
op_assign
id|lmc_init
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_HDLC
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|lmc_start_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|lmc_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|lmc_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|lmc_get_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|lmc_ioctl
suffix:semicolon
id|dev-&gt;set_config
op_assign
id|lmc_set_config
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20363
id|dev-&gt;tx_timeout
op_assign
id|lmc_driver_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 1 second */
macro_line|#endif
multiline_comment|/*&n;     * Why were we changing this???&n;     dev-&gt;tx_queue_len = 100;&n;     */
multiline_comment|/* Init the spin lock so can call it latter */
id|spin_lock_init
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
)paren
suffix:semicolon
id|LMC_SETUP_20_DEV
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: detected at %lx, irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: register_netdev failed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lmc_proto_detach
c_func
(paren
id|sc
)paren
suffix:semicolon
id|kfree
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Request the region of registers we need, so that&n;     * later on, no one else will take our card away from&n;     * us.&n;     */
id|request_region
(paren
id|ioaddr
comma
id|LMC_REG_RANGE
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;lmc_cardtype
op_assign
id|LMC_CARDTYPE_UNKNOWN
suffix:semicolon
id|sc-&gt;lmc_timing
op_assign
id|LMC_CTL_CLOCK_SOURCE_EXT
suffix:semicolon
r_switch
c_cond
(paren
id|subdevice
)paren
(brace
r_case
id|PCI_PRODUCT_LMC_HSSI
suffix:colon
id|printk
(paren
l_string|&quot;%s: LMC HSSI&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;lmc_cardtype
op_assign
id|LMC_CARDTYPE_HSSI
suffix:semicolon
id|sc-&gt;lmc_media
op_assign
op_amp
id|lmc_hssi_media
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_PRODUCT_LMC_DS3
suffix:colon
id|printk
(paren
l_string|&quot;%s: LMC DS3&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;lmc_cardtype
op_assign
id|LMC_CARDTYPE_DS3
suffix:semicolon
id|sc-&gt;lmc_media
op_assign
op_amp
id|lmc_ds3_media
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_PRODUCT_LMC_SSI
suffix:colon
id|printk
(paren
l_string|&quot;%s: LMC SSI&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;lmc_cardtype
op_assign
id|LMC_CARDTYPE_SSI
suffix:semicolon
id|sc-&gt;lmc_media
op_assign
op_amp
id|lmc_ssi_media
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_PRODUCT_LMC_T1
suffix:colon
id|printk
(paren
l_string|&quot;%s: LMC T1&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;lmc_cardtype
op_assign
id|LMC_CARDTYPE_T1
suffix:semicolon
id|sc-&gt;lmc_media
op_assign
op_amp
id|lmc_t1_media
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: LMC UNKOWN CARD!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lmc_initcsrs
(paren
id|sc
comma
id|dev-&gt;base_addr
comma
l_int|8
)paren
suffix:semicolon
id|lmc_gpio_mkinput
(paren
id|sc
comma
l_int|0xff
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* drive no signals yet */
id|sc-&gt;lmc_media-&gt;defaults
(paren
id|sc
)paren
suffix:semicolon
id|sc-&gt;lmc_media-&gt;set_link_status
(paren
id|sc
comma
id|LMC_LINK_UP
)paren
suffix:semicolon
multiline_comment|/* verify that the PCI Sub System ID matches the Adapter Model number&n;     * from the MII register&n;     */
id|AdapModelNum
op_assign
(paren
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|3
)paren
op_amp
l_int|0x3f0
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|AdapModelNum
op_eq
id|LMC_ADAP_T1
op_logical_and
id|subdevice
op_eq
id|PCI_PRODUCT_LMC_T1
)paren
op_logical_or
multiline_comment|/* detect LMC1200 */
(paren
id|AdapModelNum
op_eq
id|LMC_ADAP_SSI
op_logical_and
id|subdevice
op_eq
id|PCI_PRODUCT_LMC_SSI
)paren
op_logical_or
multiline_comment|/* detect LMC1000 */
(paren
id|AdapModelNum
op_eq
id|LMC_ADAP_DS3
op_logical_and
id|subdevice
op_eq
id|PCI_PRODUCT_LMC_DS3
)paren
op_logical_or
multiline_comment|/* detect LMC5245 */
(paren
id|AdapModelNum
op_eq
id|LMC_ADAP_HSSI
op_logical_and
id|subdevice
op_eq
id|PCI_PRODUCT_LMC_HSSI
)paren
)paren
(brace
multiline_comment|/* detect LMC5200 */
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;%s: Model number (%d) miscompare for PCI Subsystem ID = 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|AdapModelNum
comma
id|subdevice
)paren
suffix:semicolon
singleline_comment|//        return (NULL);
)brace
multiline_comment|/*&n;     * reset clock&n;     */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_gp_timer
comma
l_int|0xFFFFFFFFUL
)paren
suffix:semicolon
id|sc-&gt;board_idx
op_assign
id|board_idx
suffix:semicolon
id|memset
(paren
op_amp
id|sc-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lmc_statistics
)paren
)paren
suffix:semicolon
id|sc-&gt;stats.check
op_assign
id|STATCHECK
suffix:semicolon
id|sc-&gt;stats.version_size
op_assign
(paren
id|DRIVER_VERSION
op_lshift
l_int|16
)paren
op_plus
r_sizeof
(paren
r_struct
id|lmc_statistics
)paren
suffix:semicolon
id|sc-&gt;stats.lmc_cardtype
op_assign
id|sc-&gt;lmc_cardtype
suffix:semicolon
id|sc-&gt;lmc_ok
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;last_link_status
op_assign
l_int|0
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_probe1 out&quot;
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/* This is the entry point.  This is what is called immediatly. */
multiline_comment|/* This goes out and finds the card */
DECL|function|lmc_probe_fake
r_int
id|lmc_probe_fake
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_probe
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Return 1 to unloaded bogus device */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|lmc_probe
r_int
id|lmc_probe
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
r_int
id|pci_index
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pci_ioaddr
suffix:semicolon
r_int
r_int
id|pci_irq_line
suffix:semicolon
id|u16
id|vendor
comma
id|subvendor
comma
id|device
comma
id|subdevice
suffix:semicolon
id|u32
id|foundaddr
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
id|u8
id|intcf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The card is only available on PCI, so if we don&squot;t have a&n;     * PCI bus, we are in trouble.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|LMC_PCI_PRESENT
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*        printk (&quot;%s: We really want a pci bios!&bslash;n&quot;, dev-&gt;name);*/
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Loop basically until we don&squot;t find anymore. */
r_while
c_loop
(paren
id|pci_index
OL
l_int|0xff
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
multiline_comment|/* The tulip is considered an ethernet class of card... */
r_if
c_cond
(paren
id|pcibios_find_class
(paren
id|PCI_CLASS_NETWORK_ETHERNET
op_lshift
l_int|8
comma
id|pci_index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
multiline_comment|/* No card found on this pass */
r_break
suffix:semicolon
)brace
multiline_comment|/* Read the info we need to determine if this is&n;         * our card or not&n;         */
id|pdev
op_assign
id|pci_find_slot
(paren
id|pci_bus
comma
id|pci_device_fn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_break
suffix:semicolon
id|vendor
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device
op_assign
id|pdev-&gt;device
suffix:semicolon
id|pci_irq_line
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|pci_ioaddr
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|subvendor
op_assign
id|pdev-&gt;subsystem_vendor
suffix:semicolon
id|subdevice
op_assign
id|pdev-&gt;subsystem_device
suffix:semicolon
id|pci_set_master
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/*&n;         * Make sure it&squot;s the correct card.  CHECK SUBVENDOR ID!&n;         * There are lots of tulip&squot;s out there.&n;         * Also check the region of registers we will soon be&n;         * poking, to make sure no one else has reserved them.&n;         * This prevents taking someone else&squot;s device.&n;         *&n;         * Check either the subvendor or the subdevice, some systems reverse&n;         * the setting in the bois, seems to be version and arch dependant?&n;         * Fix the two variables&n;         *&n;         */
r_if
c_cond
(paren
op_logical_neg
(paren
id|check_region
(paren
id|pci_ioaddr
comma
id|LMC_REG_RANGE
)paren
)paren
op_logical_and
(paren
id|vendor
op_eq
id|CORRECT_VENDOR_ID
)paren
op_logical_and
(paren
id|device
op_eq
id|CORRECT_DEV_ID
)paren
op_logical_and
(paren
(paren
id|subvendor
op_eq
id|PCI_VENDOR_LMC
)paren
op_logical_or
(paren
id|subdevice
op_eq
id|PCI_VENDOR_LMC
)paren
)paren
)paren
(brace
r_struct
id|net_device
op_star
id|cur
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Fix the error, exchange the two values */
r_if
c_cond
(paren
id|subdevice
op_eq
id|PCI_VENDOR_LMC
)paren
(brace
id|subdevice
op_assign
id|subvendor
suffix:semicolon
id|subvendor
op_assign
id|PCI_VENDOR_LMC
suffix:semicolon
)brace
multiline_comment|/* Make the call to actually setup this card */
id|dev
op_assign
id|lmc_probe1
(paren
id|dev
comma
id|pci_ioaddr
comma
id|pci_irq_line
comma
id|device
comma
id|subdevice
comma
id|cards_found
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;lmc_probe: lmc_probe1 failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|lmc_probe_next_card
suffix:semicolon
)brace
multiline_comment|/* insert the device into the chain of lmc devices */
r_for
c_loop
(paren
id|cur
op_assign
id|Lmc_root_dev
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
(paren
(paren
id|lmc_softc_t
op_star
)paren
id|cur-&gt;priv
)paren
op_member_access_from_pointer
id|next_module
)paren
(brace
id|prev
op_assign
id|cur
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev
op_eq
l_int|NULL
)paren
id|Lmc_root_dev
op_assign
id|dev
suffix:semicolon
r_else
(paren
(paren
id|lmc_softc_t
op_star
)paren
id|prev-&gt;priv
)paren
op_member_access_from_pointer
id|next_module
op_assign
id|dev
suffix:semicolon
(paren
(paren
id|lmc_softc_t
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|next_module
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* end insert */
id|foundaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|cards_found
op_increment
suffix:semicolon
id|intcf
op_increment
suffix:semicolon
)brace
id|lmc_probe_next_card
suffix:colon
id|pci_index
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cards_found
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20200
r_return
id|foundaddr
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* After this is called, packets can be sent.&n; * Does not initialize the addresses&n; */
DECL|function|lmc_open
r_static
r_int
id|lmc_open
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_open in&quot;
)paren
suffix:semicolon
id|lmc_led_on
c_func
(paren
id|sc
comma
id|LMC_DS3_LED0
)paren
suffix:semicolon
id|lmc_dec_reset
(paren
id|sc
)paren
suffix:semicolon
id|lmc_reset
(paren
id|sc
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET1
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
l_int|0
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET2
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|17
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;lmc_ok
)paren
(brace
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_open lmc_ok out&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|lmc_softreset
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* Since we have to use PCI bus, this should work on x86,alpha,ppc */
r_if
c_cond
(paren
id|request_irq
(paren
id|dev-&gt;irq
comma
op_amp
id|lmc_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: could not get irq: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_open irq failed out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|sc-&gt;got_irq
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Assert Terminal Active */
id|sc-&gt;lmc_miireg16
op_or_assign
id|LMC_MII16_LED_ALL
suffix:semicolon
id|sc-&gt;lmc_media-&gt;set_link_status
(paren
id|sc
comma
id|LMC_LINK_UP
)paren
suffix:semicolon
multiline_comment|/*&n;     * reset to last state.&n;     */
id|sc-&gt;lmc_media-&gt;set_status
(paren
id|sc
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* setup default bits to be used in tulip_desc_t transmit descriptor&n;     * -baz */
id|sc-&gt;TxDescriptControlInit
op_assign
(paren
id|LMC_TDES_INTERRUPT_ON_COMPLETION
op_or
id|LMC_TDES_FIRST_SEGMENT
op_or
id|LMC_TDES_LAST_SEGMENT
op_or
id|LMC_TDES_SECOND_ADDR_CHAINED
op_or
id|LMC_TDES_DISABLE_PADDING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;ictl.crc_length
op_eq
id|LMC_CTL_CRC_LENGTH_16
)paren
(brace
multiline_comment|/* disable 32 bit CRC generated by ASIC */
id|sc-&gt;TxDescriptControlInit
op_or_assign
id|LMC_TDES_ADD_CRC_DISABLE
suffix:semicolon
)brace
id|sc-&gt;lmc_media
op_member_access_from_pointer
id|set_crc_length
c_func
(paren
id|sc
comma
id|sc-&gt;ictl.crc_length
)paren
suffix:semicolon
multiline_comment|/* Acknoledge the Terminal Active and light LEDs */
multiline_comment|/* dev-&gt;flags |= IFF_UP; */
id|lmc_proto_open
c_func
(paren
id|sc
)paren
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|lmc_ioctl
suffix:semicolon
id|LMC_XMITTER_INIT
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20363
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|sc-&gt;stats.tx_tbusy0
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;     * select what interrupts we want to get&n;     */
id|sc-&gt;lmc_intrmask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Should be using the default interrupt mask defined in the .h file. */
id|sc-&gt;lmc_intrmask
op_or_assign
(paren
id|TULIP_STS_NORMALINTR
op_or
id|TULIP_STS_RXINTR
op_or
id|TULIP_STS_TXINTR
op_or
id|TULIP_STS_ABNRMLINTR
op_or
id|TULIP_STS_SYSERROR
op_or
id|TULIP_STS_TXSTOPPED
op_or
id|TULIP_STS_TXUNDERFLOW
op_or
id|TULIP_STS_RXSTOPPED
op_or
id|TULIP_STS_RXNOBUF
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_intr
comma
id|sc-&gt;lmc_intrmask
)paren
suffix:semicolon
id|sc-&gt;lmc_cmdmode
op_or_assign
id|TULIP_CMD_TXRUN
suffix:semicolon
id|sc-&gt;lmc_cmdmode
op_or_assign
id|TULIP_CMD_RXRUN
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|sc-&gt;lmc_cmdmode
)paren
suffix:semicolon
id|sc-&gt;lmc_ok
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Run watchdog */
multiline_comment|/*&n;     * Set the if up now - pfb&n;     */
id|sc-&gt;last_link_status
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;     * Setup a timer for the watchdog on probe, and start it running.&n;     * Since lmc_ok == 0, it will be a NOP for now.&n;     */
id|init_timer
(paren
op_amp
id|sc-&gt;timer
)paren
suffix:semicolon
id|sc-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|sc-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|sc-&gt;timer.function
op_assign
op_amp
id|lmc_watchdog
suffix:semicolon
id|add_timer
(paren
op_amp
id|sc-&gt;timer
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_open out&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Total reset to compensate for the AdTran DSU doing bad things&n; *  under heavy load&n; */
DECL|function|lmc_running_reset
r_static
r_void
id|lmc_running_reset
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
op_assign
(paren
id|lmc_softc_t
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_runnig_reset in&quot;
)paren
suffix:semicolon
multiline_comment|/* stop interrupts */
multiline_comment|/* Clear the interrupt mask */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_intr
comma
l_int|0x00000000
)paren
suffix:semicolon
id|lmc_dec_reset
(paren
id|sc
)paren
suffix:semicolon
id|lmc_reset
(paren
id|sc
)paren
suffix:semicolon
id|lmc_softreset
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* sc-&gt;lmc_miireg16 |= LMC_MII16_LED_ALL; */
id|sc-&gt;lmc_media-&gt;set_link_status
(paren
id|sc
comma
l_int|1
)paren
suffix:semicolon
id|sc-&gt;lmc_media-&gt;set_status
(paren
id|sc
comma
l_int|NULL
)paren
suffix:semicolon
singleline_comment|//dev-&gt;flags |= IFF_RUNNING;
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc-&gt;lmc_txfull
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;stats.tx_tbusy0
op_increment
suffix:semicolon
id|sc-&gt;lmc_intrmask
op_assign
id|TULIP_DEFAULT_INTR_MASK
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_intr
comma
id|sc-&gt;lmc_intrmask
)paren
suffix:semicolon
id|sc-&gt;lmc_cmdmode
op_or_assign
(paren
id|TULIP_CMD_TXRUN
op_or
id|TULIP_CMD_RXRUN
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|sc-&gt;lmc_cmdmode
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_runnin_reset_out&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This is what is called when you ifconfig down a device.&n; * This disables the timer for the watchdog and keepalives,&n; * and disables the irq for dev.&n; */
DECL|function|lmc_close
r_static
r_int
id|lmc_close
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
multiline_comment|/* not calling release_region() as we should */
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_close in&quot;
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sc-&gt;lmc_ok
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_media-&gt;set_link_status
(paren
id|sc
comma
l_int|0
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
id|sc-&gt;timer
)paren
suffix:semicolon
id|lmc_proto_close
c_func
(paren
id|sc
)paren
suffix:semicolon
id|lmc_ifdown
(paren
id|dev
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_close out&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Ends the transfer of packets */
multiline_comment|/* When the interface goes down, this is called */
DECL|function|lmc_ifdown
r_static
r_int
id|lmc_ifdown
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|u32
id|csr6
suffix:semicolon
r_int
id|i
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_ifdown in&quot;
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t let anything else go on right now */
singleline_comment|//    dev-&gt;start = 0;
id|LMC_XMITTER_BUSY
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc-&gt;stats.tx_tbusy1
op_increment
suffix:semicolon
multiline_comment|/* stop interrupts */
multiline_comment|/* Clear the interrupt mask */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_intr
comma
l_int|0x00000000
)paren
suffix:semicolon
multiline_comment|/* Stop Tx and Rx on the chip */
id|csr6
op_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_command
)paren
suffix:semicolon
id|csr6
op_and_assign
op_complement
id|LMC_DEC_ST
suffix:semicolon
multiline_comment|/* Turn off the Transmission bit */
id|csr6
op_and_assign
op_complement
id|LMC_DEC_SR
suffix:semicolon
multiline_comment|/* Turn off the Recieve bit */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|csr6
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_RUNNING
suffix:semicolon
id|sc-&gt;stats.rx_missed_errors
op_add_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_missed_frames
)paren
op_amp
l_int|0xffff
suffix:semicolon
multiline_comment|/* release the interrupt */
r_if
c_cond
(paren
id|sc-&gt;got_irq
op_eq
l_int|1
)paren
(brace
id|free_irq
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|sc-&gt;got_irq
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free skbuffs in the Rx queue */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LMC_RXDESCS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
suffix:semicolon
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|buffer1
op_assign
l_int|0xDEADBEEF
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|LMC_SKB_FREE
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
id|LMC_DEV_KFREE_SKB
(paren
id|skb
)paren
suffix:semicolon
)brace
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LMC_TXDESCS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sc-&gt;lmc_txq
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
id|LMC_DEV_KFREE_SKB
(paren
id|sc-&gt;lmc_txq
(braket
id|i
)braket
)paren
suffix:semicolon
id|sc-&gt;lmc_txq
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|lmc_led_off
(paren
id|sc
comma
id|LMC_MII16_LED_ALL
)paren
suffix:semicolon
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc-&gt;stats.tx_tbusy0
op_increment
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_ifdown out&quot;
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Interrupt handling routine.  This will take an incoming packet, or clean&n; * up after a trasmit.&n; */
DECL|function|lmc_interrupt
r_static
r_void
id|lmc_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
multiline_comment|/*fold00*/
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_instance
suffix:semicolon
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
id|u32
id|csr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s32
id|stat
suffix:semicolon
r_int
r_int
id|badtx
suffix:semicolon
id|u32
id|firstcsr
suffix:semicolon
r_int
id|max_work
op_assign
id|LMC_RXDESCS
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_interrupt in&quot;
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
)paren
suffix:semicolon
multiline_comment|/*&n;     * Read the csr to find what interupts we have (if any)&n;     */
id|csr
op_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure this is our interrupt&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|csr
op_amp
id|sc-&gt;lmc_intrmask
)paren
)paren
(brace
r_goto
id|lmc_int_fail_out
suffix:semicolon
)brace
id|firstcsr
op_assign
id|csr
suffix:semicolon
multiline_comment|/* always go through this loop at least once */
r_while
c_loop
(paren
id|csr
op_amp
id|sc-&gt;lmc_intrmask
)paren
(brace
multiline_comment|/*&n;         * Clear interupt bits, we handle all case below&n;         */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_status
comma
id|csr
)paren
suffix:semicolon
multiline_comment|/*&n;         * One of&n;         *  - Transmit process timed out CSR5&lt;1&gt;&n;         *  - Transmit jabber timeout    CSR5&lt;3&gt;&n;         *  - Transmit underflow         CSR5&lt;5&gt;&n;         *  - Transmit Receiver buffer unavailable CSR5&lt;7&gt;&n;         *  - Receive process stopped    CSR5&lt;8&gt;&n;         *  - Receive watchdog timeout   CSR5&lt;9&gt;&n;         *  - Early transmit interrupt   CSR5&lt;10&gt;&n;         *&n;         * Is this really right? Should we do a running reset for jabber?&n;         * (being a WAN card and all)&n;         */
r_if
c_cond
(paren
id|csr
op_amp
id|TULIP_STS_ABNRMLINTR
)paren
(brace
id|lmc_running_reset
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csr
op_amp
id|TULIP_STS_RXINTR
)paren
(brace
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;rx interupt&quot;
)paren
suffix:semicolon
id|lmc_rx
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csr
op_amp
(paren
id|TULIP_STS_TXINTR
op_or
id|TULIP_STS_TXNOBUF
op_or
id|TULIP_STS_TXSTOPPED
)paren
)paren
(brace
r_int
id|n_compl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset the transmit timeout detection flag -baz */
id|sc-&gt;stats.tx_NoCompleteCnt
op_assign
l_int|0
suffix:semicolon
id|badtx
op_assign
id|sc-&gt;lmc_taint_tx
suffix:semicolon
id|i
op_assign
id|badtx
op_mod
id|LMC_TXDESCS
suffix:semicolon
r_while
c_loop
(paren
(paren
id|badtx
OL
id|sc-&gt;lmc_next_tx
)paren
)paren
(brace
id|stat
op_assign
id|sc-&gt;lmc_txring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|LMC_EVENT_LOG
(paren
id|LMC_EVENT_XMTINT
comma
id|stat
comma
id|sc-&gt;lmc_txring
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;                 * If bit 31 is 1 the tulip owns it break out of the loop&n;                 */
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x80000000
)paren
r_break
suffix:semicolon
id|n_compl
op_increment
suffix:semicolon
multiline_comment|/* i.e., have an empty slot in ring */
multiline_comment|/*&n;                 * If we have no skbuff or have cleared it&n;                 * Already continue to the next buffer&n;                 */
r_if
c_cond
(paren
id|sc-&gt;lmc_txq
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;                 * Check the total error summary to look for any errors&n;                 */
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x8000
)paren
(brace
id|sc-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x4104
)paren
id|sc-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x0C00
)paren
id|sc-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x0200
)paren
id|sc-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x0002
)paren
id|sc-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20200
id|sc-&gt;stats.tx_bytes
op_add_assign
id|sc-&gt;lmc_txring
(braket
id|i
)braket
dot
id|length
op_amp
l_int|0x7ff
suffix:semicolon
macro_line|#endif
id|sc-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
singleline_comment|//                LMC_DEV_KFREE_SKB (sc-&gt;lmc_txq[i]);
id|dev_kfree_skb_irq
c_func
(paren
id|sc-&gt;lmc_txq
(braket
id|i
)braket
)paren
suffix:semicolon
id|sc-&gt;lmc_txq
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|badtx
op_increment
suffix:semicolon
id|i
op_assign
id|badtx
op_mod
id|LMC_TXDESCS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sc-&gt;lmc_next_tx
op_minus
id|badtx
OG
id|LMC_TXDESCS
)paren
(brace
id|printk
(paren
l_string|&quot;%s: out of sync pointer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|badtx
op_add_assign
id|LMC_TXDESCS
suffix:semicolon
)brace
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_TBUSY0
comma
id|n_compl
comma
l_int|0
)paren
suffix:semicolon
id|sc-&gt;lmc_txfull
op_assign
l_int|0
suffix:semicolon
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc-&gt;stats.tx_tbusy0
op_increment
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20363
id|mark_bh
(paren
id|NET_BH
)paren
suffix:semicolon
multiline_comment|/* Tell Linux to give me more packets */
macro_line|#endif
macro_line|#ifdef DEBUG
id|sc-&gt;stats.dirtyTx
op_assign
id|badtx
suffix:semicolon
id|sc-&gt;stats.lmc_next_tx
op_assign
id|sc-&gt;lmc_next_tx
suffix:semicolon
id|sc-&gt;stats.lmc_txfull
op_assign
id|sc-&gt;lmc_txfull
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20363
id|sc-&gt;stats.tbusy
op_assign
id|dev-&gt;tbusy
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|sc-&gt;lmc_taint_tx
op_assign
id|badtx
suffix:semicolon
multiline_comment|/*&n;             * Why was there a break here???&n;             */
)brace
multiline_comment|/* end handle transmit interrupt */
r_if
c_cond
(paren
id|csr
op_amp
id|TULIP_STS_SYSERROR
)paren
(brace
id|u32
id|error
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: system bus error csr: %#8.8x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|csr
)paren
suffix:semicolon
id|error
op_assign
id|csr
op_rshift
l_int|23
op_amp
l_int|0x7
suffix:semicolon
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
l_int|0x000
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Parity Fault (bad)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Master Abort (naughty)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x010
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Target Abort (not so naughty)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: This bus error code was supposed to be reserved!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|lmc_dec_reset
(paren
id|sc
)paren
suffix:semicolon
id|lmc_reset
(paren
id|sc
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET1
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
l_int|0
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET2
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|17
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_work
op_decrement
op_le
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;         * Get current csr status to make sure&n;         * we&squot;ve cleared all interupts&n;         */
id|csr
op_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
suffix:semicolon
)brace
multiline_comment|/* end interrupt loop */
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_INT
comma
id|firstcsr
comma
id|csr
)paren
suffix:semicolon
id|lmc_int_fail_out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_interrupt out&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|lmc_start_xmit
r_static
r_int
id|lmc_start_xmit
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
id|u32
id|flag
suffix:semicolon
r_int
id|entry
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|LMC_SPIN_FLAGS
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_start_xmit in&quot;
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the transmitter is busy&n;     * this must be the 5 second polling&n;     * from the kernel which called us.&n;     * Poke the chip and try to get it running&n;     *&n;     */
macro_line|#if LINUX_VERSION_CODE &lt; 0x20363
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_ne
l_int|0
)paren
(brace
id|u32
id|csr6
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Xmitter busy|&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;stats.tx_tbusy_calls
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|dev-&gt;trans_start
OL
id|TX_TIMEOUT
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|lmc_start_xmit_bug_out
suffix:semicolon
)brace
multiline_comment|/*&n;         * Chip seems to have locked up&n;         * Reset it&n;         * This whips out all our decriptor&n;         * table and starts from scartch&n;         */
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_XMTPRCTMO
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
id|sc-&gt;stats.tx_ProcTimeout
)paren
suffix:semicolon
id|lmc_running_reset
(paren
id|dev
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET1
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
l_int|0
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET2
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|17
)paren
)paren
suffix:semicolon
multiline_comment|/* restart the tx processes */
id|csr6
op_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_command
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|csr6
op_or
l_int|0x0002
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|csr6
op_or
l_int|0x2002
)paren
suffix:semicolon
multiline_comment|/* immediate transmit */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_txpoll
comma
l_int|0
)paren
suffix:semicolon
id|sc-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|sc-&gt;stats.tx_ProcTimeout
op_increment
suffix:semicolon
multiline_comment|/* -baz */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|lmc_start_xmit_bug_out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* normal path, tbusy known to be zero */
id|entry
op_assign
id|sc-&gt;lmc_next_tx
op_mod
id|LMC_TXDESCS
suffix:semicolon
id|sc-&gt;lmc_txq
(braket
id|entry
)braket
op_assign
id|skb
suffix:semicolon
id|sc-&gt;lmc_txring
(braket
id|entry
)braket
dot
id|buffer1
op_assign
id|virt_to_bus
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|LMC_CONSOLE_LOG
c_func
(paren
l_string|&quot;xmit&quot;
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
macro_line|#ifndef GCOM
multiline_comment|/* If the queue is less than half full, don&squot;t interrupt */
r_if
c_cond
(paren
id|sc-&gt;lmc_next_tx
op_minus
id|sc-&gt;lmc_taint_tx
OL
id|LMC_TXDESCS
op_div
l_int|2
)paren
(brace
multiline_comment|/* Do not interrupt on completion of this packet */
id|flag
op_assign
l_int|0x60000000
suffix:semicolon
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sc-&gt;lmc_next_tx
op_minus
id|sc-&gt;lmc_taint_tx
op_eq
id|LMC_TXDESCS
op_div
l_int|2
)paren
(brace
multiline_comment|/* This generates an interrupt on completion of this packet */
id|flag
op_assign
l_int|0xe0000000
suffix:semicolon
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sc-&gt;lmc_next_tx
op_minus
id|sc-&gt;lmc_taint_tx
OL
id|LMC_TXDESCS
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Do not interrupt on completion of this packet */
id|flag
op_assign
l_int|0x60000000
suffix:semicolon
id|LMC_XMITTER_FREE
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This generates an interrupt on completion of this packet */
id|flag
op_assign
l_int|0xe0000000
suffix:semicolon
id|sc-&gt;lmc_txfull
op_assign
l_int|1
suffix:semicolon
id|LMC_XMITTER_BUSY
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#else
id|flag
op_assign
id|LMC_TDES_INTERRUPT_ON_COMPLETION
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;lmc_next_tx
op_minus
id|sc-&gt;lmc_taint_tx
op_ge
id|LMC_TXDESCS
op_minus
l_int|1
)paren
(brace
multiline_comment|/* ring full, go busy */
id|sc-&gt;lmc_txfull
op_assign
l_int|1
suffix:semicolon
id|LMC_XMITTER_BUSY
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc-&gt;stats.tx_tbusy1
op_increment
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_TBUSY1
comma
id|entry
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|entry
op_eq
id|LMC_TXDESCS
op_minus
l_int|1
)paren
multiline_comment|/* last descriptor in ring */
id|flag
op_or_assign
id|LMC_TDES_END_OF_RING
suffix:semicolon
multiline_comment|/* flag as such for Tulip */
multiline_comment|/* don&squot;t pad small packets either */
id|flag
op_assign
id|sc-&gt;lmc_txring
(braket
id|entry
)braket
dot
id|length
op_assign
(paren
id|skb-&gt;len
)paren
op_or
id|flag
op_or
id|sc-&gt;TxDescriptControlInit
suffix:semicolon
multiline_comment|/* set the transmit timeout flag to be checked in&n;     * the watchdog timer handler. -baz&n;     */
id|sc-&gt;stats.tx_NoCompleteCnt
op_increment
suffix:semicolon
id|sc-&gt;lmc_next_tx
op_increment
suffix:semicolon
multiline_comment|/* give ownership to the chip */
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_XMT
comma
id|flag
comma
id|entry
)paren
suffix:semicolon
id|sc-&gt;lmc_txring
(braket
id|entry
)braket
dot
id|status
op_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* send now! */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_txpoll
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20363
id|lmc_start_xmit_bug_out
suffix:colon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_start_xmit_out&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|lmc_rx
r_static
r_int
id|lmc_rx
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rx_work_limit
op_assign
id|LMC_RXDESCS
suffix:semicolon
r_int
r_int
id|next_rx
suffix:semicolon
r_int
id|rxIntLoopCnt
suffix:semicolon
multiline_comment|/* debug -baz */
r_int
id|localLengthErrCnt
op_assign
l_int|0
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|nsb
suffix:semicolon
id|u16
id|len
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_rx in&quot;
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lmc_led_on
c_func
(paren
id|sc
comma
id|LMC_DS3_LED3
)paren
suffix:semicolon
id|rxIntLoopCnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* debug -baz */
id|i
op_assign
id|sc-&gt;lmc_next_rx
op_mod
id|LMC_RXDESCS
suffix:semicolon
id|next_rx
op_assign
id|sc-&gt;lmc_next_rx
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|status
)paren
op_amp
id|LMC_RDES_OWN_BIT
)paren
op_ne
id|DESC_OWNED_BY_DC21X4
)paren
(brace
id|rxIntLoopCnt
op_increment
suffix:semicolon
multiline_comment|/* debug -baz */
id|len
op_assign
(paren
(paren
id|stat
op_amp
id|LMC_RDES_FRAME_LENGTH
)paren
op_rshift
id|RDES_FRAME_LENGTH_BIT_NUMBER
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
l_int|0x0300
)paren
op_ne
l_int|0x0300
)paren
(brace
multiline_comment|/* Check first segment and last segment */
r_if
c_cond
(paren
(paren
id|stat
op_amp
l_int|0x0000ffff
)paren
op_ne
l_int|0x7fff
)paren
(brace
multiline_comment|/* Oversized frame */
id|sc-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_goto
id|skip_packet
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x00000008
)paren
(brace
multiline_comment|/* Catch a dribbling bit error */
id|sc-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|sc-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_goto
id|skip_packet
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x00000004
)paren
(brace
multiline_comment|/* Catch a CRC error by the Xilinx */
id|sc-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|sc-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_goto
id|skip_packet
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|LMC_PKT_BUF_SZ
)paren
(brace
id|sc-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
id|localLengthErrCnt
op_increment
suffix:semicolon
r_goto
id|skip_packet
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
id|sc-&gt;lmc_crcSize
op_plus
l_int|2
)paren
(brace
id|sc-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
id|sc-&gt;stats.rx_SmallPktCnt
op_increment
suffix:semicolon
id|localLengthErrCnt
op_increment
suffix:semicolon
r_goto
id|skip_packet
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x00004000
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Receiver descriptor error, receiver out of sync?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_sub_assign
id|sc-&gt;lmc_crcSize
suffix:semicolon
id|skb
op_assign
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;         * We ran out of memory at some point&n;         * just allocate an skb buff and continue.&n;         */
r_if
c_cond
(paren
id|skb
op_eq
l_int|0x0
)paren
(brace
id|nsb
op_assign
id|dev_alloc_skb
(paren
id|LMC_PKT_BUF_SZ
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsb
)paren
(brace
id|LMC_SKB_FREE
c_func
(paren
id|nsb
comma
l_int|1
)paren
suffix:semicolon
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_assign
id|nsb
suffix:semicolon
id|nsb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|buffer1
op_assign
id|virt_to_bus
(paren
id|nsb-&gt;tail
)paren
suffix:semicolon
)brace
id|sc-&gt;failed_recv_alloc
op_assign
l_int|1
suffix:semicolon
r_goto
id|skip_packet
suffix:semicolon
)brace
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|sc-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|LMC_CONSOLE_LOG
c_func
(paren
l_string|&quot;recv&quot;
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;         * I&squot;m not sure of the sanity of this&n;         * Packets could be arriving at a constant&n;         * 44.210mbits/sec and we&squot;re going to copy&n;         * them into a new buffer??&n;         */
r_if
c_cond
(paren
id|len
OG
(paren
id|LMC_MTU
op_minus
(paren
id|LMC_MTU
op_rshift
l_int|2
)paren
)paren
)paren
(brace
multiline_comment|/* len &gt; LMC_MTU * 0.75 */
multiline_comment|/*&n;             * If it&squot;s a large packet don&squot;t copy it just hand it up&n;             */
id|give_it_anyways
suffix:colon
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_assign
l_int|0x0
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|buffer1
op_assign
l_int|0x0
suffix:semicolon
id|skb_put
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|lmc_proto_type
c_func
(paren
id|sc
comma
id|skb
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_WAN_PPP
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
singleline_comment|//            skb-&gt;nh.raw = skb-&gt;data;
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|lmc_proto_netif
c_func
(paren
id|sc
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;             * This skb will be destroyed by the upper layers, make a new one&n;             */
id|nsb
op_assign
id|dev_alloc_skb
(paren
id|LMC_PKT_BUF_SZ
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsb
)paren
(brace
id|LMC_SKB_FREE
c_func
(paren
id|nsb
comma
l_int|1
)paren
suffix:semicolon
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_assign
id|nsb
suffix:semicolon
id|nsb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|buffer1
op_assign
id|virt_to_bus
(paren
id|nsb-&gt;tail
)paren
suffix:semicolon
multiline_comment|/* Transfered to 21140 below */
)brace
r_else
(brace
multiline_comment|/*&n;                 * We&squot;ve run out of memory, stop trying to allocate&n;                 * memory and exit the interupt handler&n;                 *&n;                 * The chip may run out of receivers and stop&n;                 * in which care we&squot;ll try to allocate the buffer&n;                 * again.  (once a second)&n;                 */
id|sc-&gt;stats.rx_BuffAllocErr
op_increment
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RCVINT
comma
id|stat
comma
id|len
)paren
suffix:semicolon
id|sc-&gt;failed_recv_alloc
op_assign
l_int|1
suffix:semicolon
r_goto
id|skip_out_of_mem
suffix:semicolon
)brace
)brace
r_else
(brace
id|nsb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nsb
)paren
(brace
r_goto
id|give_it_anyways
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|nsb
comma
id|len
)paren
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
id|nsb-&gt;protocol
op_assign
id|lmc_proto_type
c_func
(paren
id|sc
comma
id|skb
)paren
suffix:semicolon
id|nsb-&gt;mac.raw
op_assign
id|nsb-&gt;data
suffix:semicolon
singleline_comment|//            nsb-&gt;nh.raw = nsb-&gt;data;
id|nsb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|lmc_proto_netif
c_func
(paren
id|sc
comma
id|nsb
)paren
suffix:semicolon
)brace
id|skip_packet
suffix:colon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RCVINT
comma
id|stat
comma
id|len
)paren
suffix:semicolon
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|status
op_assign
id|DESC_OWNED_BY_DC21X4
suffix:semicolon
id|sc-&gt;lmc_next_rx
op_increment
suffix:semicolon
id|i
op_assign
id|sc-&gt;lmc_next_rx
op_mod
id|LMC_RXDESCS
suffix:semicolon
id|rx_work_limit
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|rx_work_limit
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* detect condition for LMC1000 where DSU cable attaches and fills&n;     * descriptors with bogus packets&n;     *&n;    if (localLengthErrCnt &gt; LMC_RXDESCS - 3) {&n;        sc-&gt;stats.rx_BadPktSurgeCnt++;&n;        LMC_EVENT_LOG(LMC_EVENT_BADPKTSURGE,&n;                      localLengthErrCnt,&n;                      sc-&gt;stats.rx_BadPktSurgeCnt);&n;    } */
multiline_comment|/* save max count of receive descriptors serviced */
r_if
c_cond
(paren
id|rxIntLoopCnt
OG
id|sc-&gt;stats.rxIntLoopCnt
)paren
(brace
id|sc-&gt;stats.rxIntLoopCnt
op_assign
id|rxIntLoopCnt
suffix:semicolon
multiline_comment|/* debug -baz */
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|rxIntLoopCnt
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LMC_RXDESCS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|status
op_amp
id|LMC_RDES_OWN_BIT
)paren
op_ne
id|DESC_OWNED_BY_DC21X4
)paren
(brace
id|rxIntLoopCnt
op_increment
suffix:semicolon
)brace
)brace
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RCVEND
comma
id|rxIntLoopCnt
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|lmc_led_off
c_func
(paren
id|sc
comma
id|LMC_DS3_LED3
)paren
suffix:semicolon
id|skip_out_of_mem
suffix:colon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_rx out&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lmc_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|lmc_get_stats
(paren
r_struct
id|net_device
op_star
id|dev
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
id|LMC_SPIN_FLAGS
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_get_stats in&quot;
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
id|sc-&gt;stats.rx_missed_errors
op_add_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_missed_frames
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_get_stats out&quot;
)paren
suffix:semicolon
r_return
(paren
r_struct
id|net_device_stats
op_star
)paren
op_amp
id|sc-&gt;stats
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
multiline_comment|/*fold00*/
(brace
id|printk
(paren
l_string|&quot;lmc: module loaded&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Have lmc_probe search for all the cards, and allocate devices */
r_if
c_cond
(paren
id|lmc_probe
(paren
l_int|NULL
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
multiline_comment|/*fold00*/
(brace
r_struct
id|net_device
op_star
id|dev
comma
op_star
id|next
suffix:semicolon
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
multiline_comment|/* we have no pointer to our devices, since they are all dynamically&n;     * allocated.  So, here we loop through all the network devices&n;     * looking for ours.  When found, dispose of them properly.&n;     */
r_for
c_loop
(paren
id|dev
op_assign
id|Lmc_root_dev
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|next
)paren
(brace
id|next
op_assign
(paren
(paren
id|lmc_softc_t
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|next_module
suffix:semicolon
multiline_comment|/* get it now before we deallocate it */
id|printk
(paren
l_string|&quot;%s: removing...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* close the syncppp stuff, and release irq. Close is run on unreg net */
id|lmc_close
(paren
id|dev
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|sc
op_ne
l_int|NULL
)paren
id|lmc_proto_detach
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* Remove the device from the linked list */
id|unregister_netdev
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Let go of the io region */
suffix:semicolon
id|release_region
(paren
id|dev-&gt;base_addr
comma
id|LMC_REG_RANGE
)paren
suffix:semicolon
multiline_comment|/* free our allocated structures. */
id|kfree
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|kfree
(paren
(paren
r_struct
id|ppp_device
op_star
)paren
id|dev
)paren
suffix:semicolon
id|dev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|Lmc_root_dev
op_assign
l_int|NULL
suffix:semicolon
id|printk
(paren
l_string|&quot;lmc module unloaded&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|lmc_mii_readreg
r_int
id|lmc_mii_readreg
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
r_int
id|devaddr
comma
r_int
id|regno
)paren
multiline_comment|/*fold00*/
(brace
r_int
id|i
suffix:semicolon
r_int
id|command
op_assign
(paren
l_int|0xf6
op_lshift
l_int|10
)paren
op_or
(paren
id|devaddr
op_lshift
l_int|5
)paren
op_or
id|regno
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_mii_readreg in&quot;
)paren
suffix:semicolon
id|LMC_MII_SYNC
(paren
id|sc
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_mii_readreg: done sync&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|15
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|dataval
op_assign
(paren
id|command
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
l_int|0x20000
suffix:colon
l_int|0
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
id|dataval
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
id|dataval
op_or
l_int|0x10000
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
)brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_mii_readreg: done1&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|19
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
l_int|0x40000
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_9
)paren
op_amp
l_int|0x80000
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
l_int|0x40000
op_or
l_int|0x10000
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
)brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_mii_readreg out&quot;
)paren
suffix:semicolon
r_return
(paren
id|retval
op_rshift
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
DECL|function|lmc_mii_writereg
r_void
id|lmc_mii_writereg
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
r_int
id|devaddr
comma
r_int
id|regno
comma
r_int
id|data
)paren
multiline_comment|/*fold00*/
(brace
r_int
id|i
op_assign
l_int|32
suffix:semicolon
r_int
id|command
op_assign
(paren
l_int|0x5002
op_lshift
l_int|16
)paren
op_or
(paren
id|devaddr
op_lshift
l_int|23
)paren
op_or
(paren
id|regno
op_lshift
l_int|18
)paren
op_or
id|data
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_mii_writereg in&quot;
)paren
suffix:semicolon
id|LMC_MII_SYNC
(paren
id|sc
)paren
suffix:semicolon
id|i
op_assign
l_int|31
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ge
l_int|0
)paren
(brace
r_int
id|datav
suffix:semicolon
r_if
c_cond
(paren
id|command
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|datav
op_assign
l_int|0x20000
suffix:semicolon
r_else
id|datav
op_assign
l_int|0x00000
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
id|datav
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
(paren
id|datav
op_or
l_int|0x10000
)paren
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
id|i
op_decrement
suffix:semicolon
)brace
id|i
op_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
l_int|0x40000
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_9
comma
l_int|0x50000
)paren
suffix:semicolon
id|lmc_delay
(paren
)paren
suffix:semicolon
multiline_comment|/* __SLOW_DOWN_IO; */
id|i
op_decrement
suffix:semicolon
)brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_mii_writereg out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_softreset
r_static
r_void
id|lmc_softreset
(paren
id|lmc_softc_t
op_star
r_const
id|sc
)paren
multiline_comment|/*fold00*/
(brace
r_int
id|i
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_softreset in&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the recieve rings and buffers. */
id|sc-&gt;lmc_txfull
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_next_rx
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_next_tx
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_taint_rx
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_taint_tx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Setup each one of the receiver buffers&n;     * allocate an skbuff for each one, setup the the descriptor table&n;     * and point each buffer at the next one&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LMC_RXDESCS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
(paren
id|LMC_PKT_BUF_SZ
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed to allocate receiver ring, will try again&bslash;n&quot;
comma
id|sc-&gt;name
)paren
suffix:semicolon
id|sc-&gt;failed_ring
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
op_assign
id|skb
suffix:semicolon
)brace
)brace
r_else
(brace
id|skb
op_assign
id|sc-&gt;lmc_rxq
(braket
id|i
)braket
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|sc-&gt;lmc_device
suffix:semicolon
id|LMC_SKB_FREE
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* owned by 21140 */
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* used to be PKT_BUF_SZ now uses skb since we loose some to head room */
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|length
op_assign
id|skb-&gt;end
op_minus
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* use to be tail which is dumb since you&squot;re thinking why write&n;         * to the end of the packj,et but since there&squot;s nothing there tail == data&n;         */
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|buffer1
op_assign
id|virt_to_bus
(paren
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* This is fair since the structure is static and we have the next address */
id|sc-&gt;lmc_rxring
(braket
id|i
)braket
dot
id|buffer2
op_assign
id|virt_to_bus
(paren
op_amp
id|sc-&gt;lmc_rxring
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Sets end of ring&n;     */
id|sc-&gt;lmc_rxring
(braket
id|i
op_minus
l_int|1
)braket
dot
id|length
op_or_assign
l_int|0x02000000
suffix:semicolon
multiline_comment|/* Set end of buffers flag */
id|sc-&gt;lmc_rxring
(braket
id|i
op_minus
l_int|1
)braket
dot
id|buffer2
op_assign
id|virt_to_bus
(paren
op_amp
id|sc-&gt;lmc_rxring
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Point back to the start */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_rxlist
comma
id|virt_to_bus
(paren
id|sc-&gt;lmc_rxring
)paren
)paren
suffix:semicolon
multiline_comment|/* write base address */
multiline_comment|/* Initialize the transmit rings and buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LMC_TXDESCS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sc-&gt;lmc_txq
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* have buffer */
id|dev_kfree_skb
c_func
(paren
id|sc-&gt;lmc_txq
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* free it */
id|sc-&gt;stats.tx_dropped
op_increment
suffix:semicolon
multiline_comment|/* We just dropped a packet */
)brace
id|sc-&gt;lmc_txq
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;lmc_txring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0x00000000
suffix:semicolon
id|sc-&gt;lmc_txring
(braket
id|i
)braket
dot
id|buffer2
op_assign
id|virt_to_bus
(paren
op_amp
id|sc-&gt;lmc_txring
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|sc-&gt;lmc_txring
(braket
id|i
op_minus
l_int|1
)braket
dot
id|buffer2
op_assign
id|virt_to_bus
(paren
op_amp
id|sc-&gt;lmc_txring
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_txlist
comma
id|virt_to_bus
(paren
id|sc-&gt;lmc_txring
)paren
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_softreset out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_set_config
r_static
r_int
id|lmc_set_config
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifmap
op_star
id|map
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_set_config in&quot;
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_set_config out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|lmc_gpio_mkinput
r_void
id|lmc_gpio_mkinput
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
id|u_int32_t
id|bits
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_gpio_mkinput in&quot;
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio_io
op_and_assign
op_complement
id|bits
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|TULIP_GP_PINSET
op_or
(paren
id|sc-&gt;lmc_gpio_io
)paren
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_gpio_mkinput out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_gpio_mkoutput
r_void
id|lmc_gpio_mkoutput
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
id|u_int32_t
id|bits
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_gpio_mkoutput in&quot;
)paren
suffix:semicolon
id|sc-&gt;lmc_gpio_io
op_or_assign
id|bits
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|TULIP_GP_PINSET
op_or
(paren
id|sc-&gt;lmc_gpio_io
)paren
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_gpio_mkoutput out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_led_on
r_void
id|lmc_led_on
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
id|u_int32_t
id|led
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_led_on in&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_complement
id|sc-&gt;lmc_miireg16
)paren
op_amp
id|led
)paren
(brace
multiline_comment|/* Already on! */
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_led_on aon out&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sc-&gt;lmc_miireg16
op_and_assign
op_complement
id|led
suffix:semicolon
id|lmc_mii_writereg
c_func
(paren
id|sc
comma
l_int|0
comma
l_int|16
comma
id|sc-&gt;lmc_miireg16
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_led_on out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_led_off
r_void
id|lmc_led_off
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
id|u_int32_t
id|led
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_led_off in&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;lmc_miireg16
op_amp
id|led
)paren
(brace
multiline_comment|/* Already set don&squot;t do anything */
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_led_off aoff out&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sc-&gt;lmc_miireg16
op_or_assign
id|led
suffix:semicolon
id|lmc_mii_writereg
c_func
(paren
id|sc
comma
l_int|0
comma
l_int|16
comma
id|sc-&gt;lmc_miireg16
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_led_off out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_reset
r_static
r_void
id|lmc_reset
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
)paren
multiline_comment|/*fold00*/
(brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_reset in&quot;
)paren
suffix:semicolon
id|sc-&gt;lmc_miireg16
op_or_assign
id|LMC_MII16_FIFO_RESET
suffix:semicolon
id|lmc_mii_writereg
c_func
(paren
id|sc
comma
l_int|0
comma
l_int|16
comma
id|sc-&gt;lmc_miireg16
)paren
suffix:semicolon
id|sc-&gt;lmc_miireg16
op_and_assign
op_complement
id|LMC_MII16_FIFO_RESET
suffix:semicolon
id|lmc_mii_writereg
c_func
(paren
id|sc
comma
l_int|0
comma
l_int|16
comma
id|sc-&gt;lmc_miireg16
)paren
suffix:semicolon
multiline_comment|/*&n;     * make some of the GPIO pins be outputs&n;     */
id|lmc_gpio_mkoutput
c_func
(paren
id|sc
comma
id|LMC_GEP_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;     * RESET low to force state reset.  This also forces&n;     * the transmitter clock to be internal, but we expect to reset&n;     * that later anyway.&n;     */
id|sc-&gt;lmc_gpio
op_and_assign
op_complement
(paren
id|LMC_GEP_RESET
)paren
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_gp
comma
id|sc-&gt;lmc_gpio
)paren
suffix:semicolon
multiline_comment|/*&n;     * hold for more than 10 microseconds&n;     */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/*&n;     * stop driving Xilinx-related signals&n;     */
id|lmc_gpio_mkinput
c_func
(paren
id|sc
comma
id|LMC_GEP_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;     * Call media specific init routine&n;     */
id|sc-&gt;lmc_media
op_member_access_from_pointer
id|init
c_func
(paren
id|sc
)paren
suffix:semicolon
id|sc-&gt;stats.resetCount
op_increment
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_reset out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_dec_reset
r_static
r_void
id|lmc_dec_reset
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
)paren
multiline_comment|/*fold00*/
(brace
id|u_int32_t
id|val
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_dec_reset in&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * disable all interrupts&n;     */
id|sc-&gt;lmc_intrmask
op_assign
l_int|0
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_intr
comma
id|sc-&gt;lmc_intrmask
)paren
suffix:semicolon
multiline_comment|/*&n;     * Reset the chip with a software reset command.&n;     * Wait 10 microseconds (actually 50 PCI cycles but at&n;     * 33MHz that comes to two microseconds but wait a&n;     * bit longer anyways)&n;     */
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_busmode
comma
id|TULIP_BUSMODE_SWRESET
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
macro_line|#ifdef __sparc__
id|sc-&gt;lmc_busmode
op_assign
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_busmode
)paren
suffix:semicolon
id|sc-&gt;lmc_busmode
op_assign
l_int|0x00100000
suffix:semicolon
id|sc-&gt;lmc_busmode
op_and_assign
op_complement
id|TULIP_BUSMODE_SWRESET
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_busmode
comma
id|sc-&gt;lmc_busmode
)paren
suffix:semicolon
macro_line|#endif
id|sc-&gt;lmc_cmdmode
op_assign
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_command
)paren
suffix:semicolon
multiline_comment|/*&n;     * We want:&n;     *   no ethernet address in frames we write&n;     *   disable padding (txdesc, padding disable)&n;     *   ignore runt frames (rdes0 bit 15)&n;     *   no receiver watchdog or transmitter jabber timer&n;     *       (csr15 bit 0,14 == 1)&n;     *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)&n;     */
id|sc-&gt;lmc_cmdmode
op_or_assign
(paren
id|TULIP_CMD_PROMISCUOUS
op_or
id|TULIP_CMD_FULLDUPLEX
op_or
id|TULIP_CMD_PASSBADPKT
op_or
id|TULIP_CMD_NOHEARTBEAT
op_or
id|TULIP_CMD_PORTSELECT
op_or
id|TULIP_CMD_RECEIVEALL
op_or
id|TULIP_CMD_MUSTBEONE
)paren
suffix:semicolon
id|sc-&gt;lmc_cmdmode
op_and_assign
op_complement
(paren
id|TULIP_CMD_OPERMODE
op_or
id|TULIP_CMD_THRESHOLDCTL
op_or
id|TULIP_CMD_STOREFWD
op_or
id|TULIP_CMD_TXTHRSHLDCTL
)paren
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_command
comma
id|sc-&gt;lmc_cmdmode
)paren
suffix:semicolon
multiline_comment|/*&n;     * disable receiver watchdog and transmit jabber&n;     */
id|val
op_assign
id|LMC_CSR_READ
c_func
(paren
id|sc
comma
id|csr_sia_general
)paren
suffix:semicolon
id|val
op_or_assign
(paren
id|TULIP_WATCHDOG_TXDISABLE
op_or
id|TULIP_WATCHDOG_RXDISABLE
)paren
suffix:semicolon
id|LMC_CSR_WRITE
c_func
(paren
id|sc
comma
id|csr_sia_general
comma
id|val
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_dec_reset out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_initcsrs
r_static
r_void
id|lmc_initcsrs
c_func
(paren
id|lmc_softc_t
op_star
r_const
id|sc
comma
id|lmc_csrptr_t
id|csr_base
comma
multiline_comment|/*fold00*/
r_int
id|csr_size
)paren
(brace
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_initcsrs in&quot;
)paren
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_busmode
op_assign
id|csr_base
op_plus
l_int|0
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_txpoll
op_assign
id|csr_base
op_plus
l_int|1
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_rxpoll
op_assign
id|csr_base
op_plus
l_int|2
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_rxlist
op_assign
id|csr_base
op_plus
l_int|3
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_txlist
op_assign
id|csr_base
op_plus
l_int|4
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_status
op_assign
id|csr_base
op_plus
l_int|5
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_command
op_assign
id|csr_base
op_plus
l_int|6
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_intr
op_assign
id|csr_base
op_plus
l_int|7
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_missed_frames
op_assign
id|csr_base
op_plus
l_int|8
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_9
op_assign
id|csr_base
op_plus
l_int|9
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_10
op_assign
id|csr_base
op_plus
l_int|10
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_11
op_assign
id|csr_base
op_plus
l_int|11
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_12
op_assign
id|csr_base
op_plus
l_int|12
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_13
op_assign
id|csr_base
op_plus
l_int|13
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_14
op_assign
id|csr_base
op_plus
l_int|14
op_star
id|csr_size
suffix:semicolon
id|sc-&gt;lmc_csrs.csr_15
op_assign
id|csr_base
op_plus
l_int|15
op_star
id|csr_size
suffix:semicolon
id|lmc_trace
c_func
(paren
id|sc-&gt;lmc_device
comma
l_string|&quot;lmc_initcsrs out&quot;
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20363
DECL|function|lmc_driver_timeout
r_static
r_void
id|lmc_driver_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/*fold00*/
id|lmc_softc_t
op_star
id|sc
suffix:semicolon
id|u32
id|csr6
suffix:semicolon
id|LMC_SPIN_FLAGS
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_driver_timeout in&quot;
)paren
suffix:semicolon
id|sc
op_assign
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Xmitter busy|&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sc-&gt;stats.tx_tbusy_calls
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|dev-&gt;trans_start
OL
id|TX_TIMEOUT
)paren
(brace
r_goto
id|bug_out
suffix:semicolon
)brace
multiline_comment|/*&n;     * Chip seems to have locked up&n;     * Reset it&n;     * This whips out all our decriptor&n;     * table and starts from scartch&n;     */
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_XMTPRCTMO
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
id|sc-&gt;stats.tx_ProcTimeout
)paren
suffix:semicolon
id|lmc_running_reset
(paren
id|dev
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET1
comma
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_status
)paren
comma
l_int|0
)paren
suffix:semicolon
id|LMC_EVENT_LOG
c_func
(paren
id|LMC_EVENT_RESET2
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|16
)paren
comma
id|lmc_mii_readreg
(paren
id|sc
comma
l_int|0
comma
l_int|17
)paren
)paren
suffix:semicolon
multiline_comment|/* restart the tx processes */
id|csr6
op_assign
id|LMC_CSR_READ
(paren
id|sc
comma
id|csr_command
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|csr6
op_or
l_int|0x0002
)paren
suffix:semicolon
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_command
comma
id|csr6
op_or
l_int|0x2002
)paren
suffix:semicolon
multiline_comment|/* immediate transmit */
id|LMC_CSR_WRITE
(paren
id|sc
comma
id|csr_txpoll
comma
l_int|0
)paren
suffix:semicolon
id|sc-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|sc-&gt;stats.tx_ProcTimeout
op_increment
suffix:semicolon
multiline_comment|/* -baz */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|bug_out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lmc_lock
comma
id|flags
)paren
suffix:semicolon
id|lmc_trace
c_func
(paren
id|dev
comma
l_string|&quot;lmc_driver_timout out&quot;
)paren
suffix:semicolon
)brace
DECL|function|lmc_setup
r_int
id|lmc_setup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*FOLD00*/
r_return
id|lmc_probe
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
