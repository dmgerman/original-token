multiline_comment|/*&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;(c) Copyright 1998 Building Number Three Ltd&n; *&t;(c) Copyright 2000 Red Hat Software&n; *&n; *&t;Development of this driver was funded by Equiinet Ltd&n; *&t;&t;&t;http://www.equiinet.com&n; *&n; *&t;ChangeLog:&n; *&n; *&t;Asynchronous mode dropped for 2.2. For 2.5 we will attempt the&n; *&t;unification of all the Z85x30 asynchronous drivers for real.&n; *&n; *&t;DMA now uses get_free_page as kmalloc buffers may span a 64K &n; *&t;boundary.&n; *&n; *&t;Performance&n; *&n; *&t;Z85230:&n; *&t;Non DMA you want a 486DX50 or better to do 64Kbits. 9600 baud&n; *&t;X.25 is not unrealistic on all machines. DMA mode can in theory&n; *&t;handle T1/E1 quite nicely. In practice the limit seems to be about&n; *&t;512Kbit-&gt;1Mbit depending on motherboard.&n; *&n; *&t;Z85C30:&n; *&t;64K will take DMA, 9600 baud X.25 should be ok.&n; *&n; *&t;Z8530:&n; *&t;Synchronous mode without DMA is unlikely to pass about 2400 baud.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|RT_LOCK
mdefine_line|#define RT_LOCK
DECL|macro|RT_UNLOCK
mdefine_line|#define RT_UNLOCK
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &quot;z85230.h&quot;
macro_line|#include &quot;syncppp.h&quot;
DECL|variable|z8530_buffer_lock
r_static
id|spinlock_t
id|z8530_buffer_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_read_port - Architecture specific interface function&n; *&t;@p: port to read&n; *&n; *&t;Provided port access methods. The Comtrol SV11 requires no delays&n; *&t;between accesses and uses PC I/O. Some drivers may need a 5uS delay&n; *&t;&n; *&t;In the longer term this should become an architecture specific&n; *&t;section so that this can become a generic driver interface for all&n; *&t;platforms. For now we only handle PC I/O ports with or without the&n; *&t;dread 5uS sanity delay.&n; *&n; *&t;The caller must hold sufficient locks to avoid violating the horrible&n; *&t;5uS delay rule.&n; */
DECL|function|z8530_read_port
r_extern
id|__inline__
r_int
id|z8530_read_port
c_func
(paren
r_int
r_int
id|p
)paren
(brace
id|u8
id|r
op_assign
id|inb
c_func
(paren
id|Z8530_PORT_OF
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_amp
id|Z8530_PORT_SLEEP
)paren
(brace
multiline_comment|/* gcc should figure this out efficiently ! */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_write_port - Architecture specific interface function&n; *&t;@p: port to write&n; *&t;@d: value to write&n; *&n; *&t;Write a value to a port with delays if need be. Note that the&n; *&t;caller must hold locks to avoid read/writes from other contexts&n; *&t;violating the 5uS rule&n; *&n; *&t;In the longer term this should become an architecture specific&n; *&t;section so that this can become a generic driver interface for all&n; *&t;platforms. For now we only handle PC I/O ports with or without the&n; *&t;dread 5uS sanity delay.&n; */
DECL|function|z8530_write_port
r_extern
id|__inline__
r_void
id|z8530_write_port
c_func
(paren
r_int
r_int
id|p
comma
id|u8
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|Z8530_PORT_OF
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_amp
id|Z8530_PORT_SLEEP
)paren
(brace
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|z8530_rx_done
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
suffix:semicolon
r_static
r_void
id|z8530_tx_done
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;read_zsreg - Read a register from a Z85230 &n; *&t;@c: Z8530 channel to read from (2 per chip)&n; *&t;@reg: Register to read&n; *&t;FIXME: Use a spinlock.&n; *&t;&n; *&t;Most of the Z8530 registers are indexed off the control registers.&n; *&t;A read is done by writing to the control register and reading the&n; *&t;register back. We do the locking needed to protect this &n; *&t;operation.&n; */
DECL|function|read_zsreg
r_extern
r_inline
id|u8
id|read_zsreg
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
id|u8
id|reg
)paren
(brace
id|u8
id|r
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
)paren
(brace
id|z8530_write_port
c_func
(paren
id|c-&gt;ctrlio
comma
id|reg
)paren
suffix:semicolon
)brace
id|r
op_assign
id|z8530_read_port
c_func
(paren
id|c-&gt;ctrlio
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;read_zsdata - Read the data port of a Z8530 channel&n; *&t;@c: The Z8530 channel to read the data port from&n; *&n; *&t;The data port provides fast access to some things. We still&n; *&t;have all the 5uS delays to worry about.&n; */
DECL|function|read_zsdata
r_extern
r_inline
id|u8
id|read_zsdata
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|u8
id|r
suffix:semicolon
id|r
op_assign
id|z8530_read_port
c_func
(paren
id|c-&gt;dataio
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_zsreg - Write to a Z8530 channel register&n; *&t;@c: The Z8530 channel&n; *&t;@reg: Register number&n; *&t;@val: Value to write&n; *&n; *&t;Write a value to an indexed register. Perform the locking needed&n; *&t;to honour the irritating delay rules. We know about register 0&n; *&t;being fast to access.&n; */
DECL|function|write_zsreg
r_extern
r_inline
r_void
id|write_zsreg
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
id|u8
id|reg
comma
id|u8
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
)paren
(brace
id|z8530_write_port
c_func
(paren
id|c-&gt;ctrlio
comma
id|reg
)paren
suffix:semicolon
)brace
id|z8530_write_port
c_func
(paren
id|c-&gt;ctrlio
comma
id|val
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_zsctrl - Write to a Z8530 control register&n; *&t;@c: The Z8530 channel&n; *&t;@val: Value to write&n; *&n; *&t;Write directly to the control register on the Z8530&n; */
DECL|function|write_zsctrl
r_extern
r_inline
r_void
id|write_zsctrl
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
id|u8
id|val
)paren
(brace
id|z8530_write_port
c_func
(paren
id|c-&gt;ctrlio
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_zsdata - Write to a Z8530 control register&n; *&t;@c: The Z8530 channel&n; *&t;@val: Value to write&n; *&n; *&t;Write directly to the data register on the Z8530&n; */
DECL|function|write_zsdata
r_extern
r_inline
r_void
id|write_zsdata
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
id|u8
id|val
)paren
(brace
id|z8530_write_port
c_func
(paren
id|c-&gt;dataio
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Register loading parameters for a dead port&n; */
DECL|variable|z8530_dead_port
id|u8
id|z8530_dead_port
(braket
)braket
op_assign
(brace
l_int|255
)brace
suffix:semicolon
DECL|variable|z8530_dead_port
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_dead_port
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Register loading parameters for currently supported circuit types&n; */
multiline_comment|/*&n; *&t;Data clocked by telco end. This is the correct data for the UK&n; *&t;&quot;kilostream&quot; service, and most other similar services.&n; */
DECL|variable|z8530_hdlc_kilostream
id|u8
id|z8530_hdlc_kilostream
(braket
)braket
op_assign
(brace
l_int|4
comma
id|SYNC_ENAB
op_or
id|SDLC
op_or
id|X1CLK
comma
l_int|2
comma
l_int|0
comma
multiline_comment|/* No vector */
l_int|1
comma
l_int|0
comma
l_int|3
comma
id|ENT_HM
op_or
id|RxCRC_ENAB
op_or
id|Rx8
comma
l_int|5
comma
id|TxCRC_ENAB
op_or
id|RTS
op_or
id|TxENAB
op_or
id|Tx8
op_or
id|DTR
comma
l_int|9
comma
l_int|0
comma
multiline_comment|/* Disable interrupts */
l_int|6
comma
l_int|0xFF
comma
l_int|7
comma
id|FLAG
comma
l_int|10
comma
id|ABUNDER
op_or
id|NRZ
op_or
id|CRCPS
comma
multiline_comment|/*MARKIDLE ??*/
l_int|11
comma
id|TCTRxCP
comma
l_int|14
comma
id|DISDPLL
comma
l_int|15
comma
id|DCDIE
op_or
id|SYNCIE
op_or
id|CTSIE
op_or
id|TxUIE
op_or
id|BRKIE
comma
l_int|1
comma
id|EXT_INT_ENAB
op_or
id|TxINT_ENAB
op_or
id|INT_ALL_Rx
comma
l_int|9
comma
id|NV
op_or
id|MIE
op_or
id|NORESET
comma
l_int|255
)brace
suffix:semicolon
DECL|variable|z8530_hdlc_kilostream
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_hdlc_kilostream
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;As above but for enhanced chips.&n; */
DECL|variable|z8530_hdlc_kilostream_85230
id|u8
id|z8530_hdlc_kilostream_85230
(braket
)braket
op_assign
(brace
l_int|4
comma
id|SYNC_ENAB
op_or
id|SDLC
op_or
id|X1CLK
comma
l_int|2
comma
l_int|0
comma
multiline_comment|/* No vector */
l_int|1
comma
l_int|0
comma
l_int|3
comma
id|ENT_HM
op_or
id|RxCRC_ENAB
op_or
id|Rx8
comma
l_int|5
comma
id|TxCRC_ENAB
op_or
id|RTS
op_or
id|TxENAB
op_or
id|Tx8
op_or
id|DTR
comma
l_int|9
comma
l_int|0
comma
multiline_comment|/* Disable interrupts */
l_int|6
comma
l_int|0xFF
comma
l_int|7
comma
id|FLAG
comma
l_int|10
comma
id|ABUNDER
op_or
id|NRZ
op_or
id|CRCPS
comma
multiline_comment|/* MARKIDLE?? */
l_int|11
comma
id|TCTRxCP
comma
l_int|14
comma
id|DISDPLL
comma
l_int|15
comma
id|DCDIE
op_or
id|SYNCIE
op_or
id|CTSIE
op_or
id|TxUIE
op_or
id|BRKIE
comma
l_int|1
comma
id|EXT_INT_ENAB
op_or
id|TxINT_ENAB
op_or
id|INT_ALL_Rx
comma
l_int|9
comma
id|NV
op_or
id|MIE
op_or
id|NORESET
comma
l_int|23
comma
l_int|3
comma
multiline_comment|/* Extended mode AUTO TX and EOM*/
l_int|255
)brace
suffix:semicolon
DECL|variable|z8530_hdlc_kilostream_85230
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_hdlc_kilostream_85230
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_flush_fifo - Flush on chip RX FIFO&n; *&t;@c: Channel to flush&n; *&n; *&t;Flush the receive FIFO. There is no specific option for this, we &n; *&t;blindly read bytes and discard them. Reading when there is no data&n; *&t;is harmless. The 8530 has a 4 byte FIFO, the 85230 has 8 bytes.&n; *&t;&n; *&t;All locking is handled for the caller. On return data may still be&n; *&t;present if it arrived during the flush.&n; */
DECL|function|z8530_flush_fifo
r_static
r_void
id|z8530_flush_fifo
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;dev-&gt;type
op_eq
id|Z85230
)paren
(brace
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;z8530_rtsdtr - Control the outgoing DTS/RTS line&n; *&t;@c: The Z8530 channel to control;&n; *&t;@set: 1 to set, 0 to clear&n; *&n; *&t;Sets or clears DTR/RTS on the requested line. All locking is handled&n; *&t;for the caller. For now we assume all boards use the actual RTS/DTR&n; *&t;on the chip. Apparently one or two don&squot;t. We&squot;ll scream about them&n; *&t;later.&n; */
DECL|function|z8530_rtsdtr
r_static
r_void
id|z8530_rtsdtr
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
r_int
id|set
)paren
(brace
r_if
c_cond
(paren
id|set
)paren
id|c-&gt;regs
(braket
l_int|5
)braket
op_or_assign
(paren
id|RTS
op_or
id|DTR
)paren
suffix:semicolon
r_else
id|c-&gt;regs
(braket
l_int|5
)braket
op_and_assign
op_complement
(paren
id|RTS
op_or
id|DTR
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R5
comma
id|c-&gt;regs
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_rx - Handle a PIO receive event&n; *&t;@c: Z8530 channel to process&n; *&n; *&t;Receive handler for receiving in PIO mode. This is much like the &n; *&t;async one but not quite the same or as complex&n; *&n; *&t;Note: Its intended that this handler can easily be separated from&n; *&t;the main code to run realtime. That&squot;ll be needed for some machines&n; *&t;(eg to ever clock 64kbits on a sparc ;)).&n; *&n; *&t;The RT_LOCK macros don&squot;t do anything now. Keep the code covered&n; *&t;by them as short as possible in all circumstances - clocks cost&n; *&t;baud. The interrupt handler is assumed to be atomic w.r.t. to&n; *&t;other code - this is true in the RT case too.&n; *&n; *&t;We only cover the sync cases for this. If you want 2Mbit async&n; *&t;do it yourself but consider medical assistance first. This non DMA &n; *&t;synchronous mode is portable code. The DMA mode assumes PCI like &n; *&t;ISA DMA&n; */
DECL|function|z8530_rx
r_static
r_void
id|z8530_rx
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|u8
id|ch
comma
id|stat
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* FIFO empty ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
op_amp
l_int|1
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|ch
op_assign
id|read_zsdata
c_func
(paren
id|c
)paren
suffix:semicolon
id|stat
op_assign
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Overrun ?&n;&t;&t; */
r_if
c_cond
(paren
id|c-&gt;count
OL
id|c-&gt;max
)paren
(brace
op_star
id|c-&gt;dptr
op_increment
op_assign
id|ch
suffix:semicolon
id|c-&gt;count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|END_FR
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Error ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|Rx_OVR
op_or
id|CRC_ERR
)paren
)paren
(brace
multiline_comment|/* Rewind the buffer and return */
r_if
c_cond
(paren
id|c-&gt;skb
)paren
(brace
id|c-&gt;dptr
op_assign
id|c-&gt;skb-&gt;data
suffix:semicolon
)brace
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|Rx_OVR
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: overrun&bslash;n&quot;
comma
id|c-&gt;dev-&gt;name
)paren
suffix:semicolon
id|c-&gt;rx_overrun
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|CRC_ERR
)paren
(brace
id|c-&gt;rx_crc_err
op_increment
suffix:semicolon
multiline_comment|/* printk(&quot;crc error&bslash;n&quot;); */
)brace
multiline_comment|/* Shove the frame upstream */
)brace
r_else
(brace
id|z8530_rx_done
c_func
(paren
id|c
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_Rx_CRC
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Clear irq&n;&t; */
id|write_zsctrl
c_func
(paren
id|c
comma
id|ERR_RES
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_tx - Handle a PIO transmit event&n; *&t;@c: Z8530 channel to process&n; *&n; *&t;Z8530 transmit interrupt handler for the PIO mode. The basic&n; *&t;idea is to attempt to keep the FIFO fed. We fill as many bytes&n; *&t;in as possible, its quite possible that we won&squot;t keep up with the&n; *&t;data rate otherwise.&n; */
DECL|function|z8530_tx
r_static
r_void
id|z8530_tx
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_while
c_loop
(paren
id|c-&gt;txcount
)paren
(brace
multiline_comment|/* FIFO full ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
op_amp
l_int|4
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|c-&gt;txcount
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Shovel out the byte&n;&t;&t; */
id|write_zsreg
c_func
(paren
id|c
comma
id|R8
comma
op_star
id|c-&gt;tx_ptr
op_increment
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_H_IUS
)paren
suffix:semicolon
multiline_comment|/* We are about to underflow */
r_if
c_cond
(paren
id|c-&gt;txcount
op_eq
l_int|0
)paren
(brace
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_EOM_L
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R10
comma
id|c-&gt;regs
(braket
l_int|10
)braket
op_amp
op_complement
id|ABUNDER
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;End of frame TX - fire another one&n;&t; */
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_Tx_P
)paren
suffix:semicolon
id|z8530_tx_done
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*&t;write_zsreg(c, R8, *c-&gt;tx_ptr++); */
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_status - Handle a PIO status exception&n; *&t;@chan: Z8530 channel to process&n; *&n; *&t;A status event occured in PIO synchronous mode. There are several&n; *&t;reasons the chip will bother us here. A transmit underrun means we&n; *&t;failed to feed the chip fast enough and just broke a packet. A DCD&n; *&t;change is a line up or down. We communicate that back to the protocol&n; *&t;layer for synchronous PPP to renegotiate.&n; */
DECL|function|z8530_status
r_static
r_void
id|z8530_status
c_func
(paren
r_struct
id|z8530_channel
op_star
id|chan
)paren
(brace
id|u8
id|status
op_assign
id|read_zsreg
c_func
(paren
id|chan
comma
id|R0
)paren
suffix:semicolon
id|u8
id|altered
op_assign
id|chan-&gt;status
op_xor
id|status
suffix:semicolon
id|chan-&gt;status
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TxEOM
)paren
(brace
multiline_comment|/*&t;&t;printk(&quot;%s: Tx underrun.&bslash;n&quot;, chan-&gt;dev-&gt;name); */
id|chan-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|chan
comma
id|ERR_RES
)paren
suffix:semicolon
id|z8530_tx_done
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|altered
op_amp
id|chan-&gt;dcdcheck
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|chan-&gt;dcdcheck
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: DCD raised&bslash;n&quot;
comma
id|chan-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|chan
comma
id|R3
comma
id|chan-&gt;regs
(braket
l_int|3
)braket
op_or
id|RxENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;netdevice
op_logical_and
(paren
(paren
id|chan-&gt;netdevice-&gt;type
op_eq
id|ARPHRD_HDLC
)paren
op_logical_or
(paren
id|chan-&gt;netdevice-&gt;type
op_eq
id|ARPHRD_PPP
)paren
)paren
)paren
(brace
id|sppp_reopen
c_func
(paren
id|chan-&gt;netdevice
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: DCD lost&bslash;n&quot;
comma
id|chan-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|chan
comma
id|R3
comma
id|chan-&gt;regs
(braket
l_int|3
)braket
op_amp
op_complement
id|RxENABLE
)paren
suffix:semicolon
id|z8530_flush_fifo
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
)brace
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
DECL|variable|z8530_sync
r_struct
id|z8530_irqhandler
id|z8530_sync
op_assign
(brace
id|z8530_rx
comma
id|z8530_tx
comma
id|z8530_status
)brace
suffix:semicolon
DECL|variable|z8530_sync
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_dma_rx - Handle a DMA RX event&n; *&t;@chan: Channel to handle&n; *&n; *&t;Non bus mastering DMA interfaces for the Z8x30 devices. This&n; *&t;is really pretty PC specific. The DMA mode means that most receive&n; *&t;events are handled by the DMA hardware. We get a kick here only if&n; *&t;a frame ended.&n; */
DECL|function|z8530_dma_rx
r_static
r_void
id|z8530_dma_rx
c_func
(paren
r_struct
id|z8530_channel
op_star
id|chan
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;rxdma_on
)paren
(brace
multiline_comment|/* Special condition check only */
id|u8
id|status
suffix:semicolon
id|read_zsreg
c_func
(paren
id|chan
comma
id|R7
)paren
suffix:semicolon
id|read_zsreg
c_func
(paren
id|chan
comma
id|R6
)paren
suffix:semicolon
id|status
op_assign
id|read_zsreg
c_func
(paren
id|chan
comma
id|R1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|END_FR
)paren
(brace
id|z8530_rx_done
c_func
(paren
id|chan
)paren
suffix:semicolon
multiline_comment|/* Fire up the next one */
)brace
id|write_zsctrl
c_func
(paren
id|chan
comma
id|ERR_RES
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* DMA is off right now, drain the slow way */
id|z8530_rx
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;z8530_dma_tx - Handle a DMA TX event&n; *&t;@chan:&t;The Z8530 channel to handle&n; *&n; *&t;We have received an interrupt while doing DMA transmissions. It&n; *&t;shouldn&squot;t happen. Scream loudly if it does.&n; */
DECL|function|z8530_dma_tx
r_static
r_void
id|z8530_dma_tx
c_func
(paren
r_struct
id|z8530_channel
op_star
id|chan
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;dma_tx
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Hey who turned the DMA off?&bslash;n&quot;
)paren
suffix:semicolon
id|z8530_tx
c_func
(paren
id|chan
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This shouldnt occur in DMA mode */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DMA tx - bogus event!&bslash;n&quot;
)paren
suffix:semicolon
id|z8530_tx
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_dma_status - Handle a DMA status exception&n; *&t;@chan: Z8530 channel to process&n; *&t;&n; *&t;A status event occured on the Z8530. We receive these for two reasons&n; *&t;when in DMA mode. Firstly if we finished a packet transfer we get one&n; *&t;and kick the next packet out. Secondly we may see a DCD change and&n; *&t;have to poke the protocol layer.&n; *&n; */
DECL|function|z8530_dma_status
r_static
r_void
id|z8530_dma_status
c_func
(paren
r_struct
id|z8530_channel
op_star
id|chan
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|status
op_assign
id|read_zsreg
c_func
(paren
id|chan
comma
id|R0
)paren
suffix:semicolon
id|u8
id|altered
op_assign
id|chan-&gt;status
op_xor
id|status
suffix:semicolon
id|chan-&gt;status
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;dma_tx
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|TxEOM
)paren
(brace
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|chan-&gt;txdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|chan-&gt;txdma
)paren
suffix:semicolon
id|chan-&gt;txdma_on
op_assign
l_int|0
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|z8530_tx_done
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|altered
op_amp
id|chan-&gt;dcdcheck
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|chan-&gt;dcdcheck
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: DCD raised&bslash;n&quot;
comma
id|chan-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|chan
comma
id|R3
comma
id|chan-&gt;regs
(braket
l_int|3
)braket
op_or
id|RxENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;netdevice
op_logical_and
(paren
(paren
id|chan-&gt;netdevice-&gt;type
op_eq
id|ARPHRD_HDLC
)paren
op_logical_or
(paren
id|chan-&gt;netdevice-&gt;type
op_eq
id|ARPHRD_PPP
)paren
)paren
)paren
(brace
id|sppp_reopen
c_func
(paren
id|chan-&gt;netdevice
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s:DCD lost&bslash;n&quot;
comma
id|chan-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|chan
comma
id|R3
comma
id|chan-&gt;regs
(braket
l_int|3
)braket
op_amp
op_complement
id|RxENABLE
)paren
suffix:semicolon
id|z8530_flush_fifo
c_func
(paren
id|chan
)paren
suffix:semicolon
)brace
)brace
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
DECL|variable|z8530_dma_sync
r_struct
id|z8530_irqhandler
id|z8530_dma_sync
op_assign
(brace
id|z8530_dma_rx
comma
id|z8530_dma_tx
comma
id|z8530_dma_status
)brace
suffix:semicolon
DECL|variable|z8530_dma_sync
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_dma_sync
)paren
suffix:semicolon
DECL|variable|z8530_txdma_sync
r_struct
id|z8530_irqhandler
id|z8530_txdma_sync
op_assign
(brace
id|z8530_rx
comma
id|z8530_dma_tx
comma
id|z8530_dma_status
)brace
suffix:semicolon
DECL|variable|z8530_txdma_sync
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_txdma_sync
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_rx_clear - Handle RX events from a stopped chip&n; *&t;@c: Z8530 channel to shut up&n; *&n; *&t;Receive interrupt vectors for a Z8530 that is in &squot;parked&squot; mode.&n; *&t;For machines with PCI Z85x30 cards, or level triggered interrupts&n; *&t;(eg the MacII) we must clear the interrupt cause or die.&n; */
DECL|function|z8530_rx_clear
r_static
r_void
id|z8530_rx_clear
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
multiline_comment|/*&n;&t; *&t;Data and status bytes&n;&t; */
id|u8
id|stat
suffix:semicolon
id|read_zsdata
c_func
(paren
id|c
)paren
suffix:semicolon
id|stat
op_assign
id|read_zsreg
c_func
(paren
id|c
comma
id|R1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|END_FR
)paren
(brace
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_Rx_CRC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Clear irq&n;&t; */
id|write_zsctrl
c_func
(paren
id|c
comma
id|ERR_RES
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_tx_clear - Handle TX events from a stopped chip&n; *&t;@c: Z8530 channel to shut up&n; *&n; *&t;Transmit interrupt vectors for a Z8530 that is in &squot;parked&squot; mode.&n; *&t;For machines with PCI Z85x30 cards, or level triggered interrupts&n; *&t;(eg the MacII) we must clear the interrupt cause or die.&n; */
DECL|function|z8530_tx_clear
r_static
r_void
id|z8530_tx_clear
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_Tx_P
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_status_clear - Handle status events from a stopped chip&n; *&t;@chan: Z8530 channel to shut up&n; *&n; *&t;Status interrupt vectors for a Z8530 that is in &squot;parked&squot; mode.&n; *&t;For machines with PCI Z85x30 cards, or level triggered interrupts&n; *&t;(eg the MacII) we must clear the interrupt cause or die.&n; */
DECL|function|z8530_status_clear
r_static
r_void
id|z8530_status_clear
c_func
(paren
r_struct
id|z8530_channel
op_star
id|chan
)paren
(brace
id|u8
id|status
op_assign
id|read_zsreg
c_func
(paren
id|chan
comma
id|R0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TxEOM
)paren
(brace
id|write_zsctrl
c_func
(paren
id|chan
comma
id|ERR_RES
)paren
suffix:semicolon
)brace
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|chan
comma
id|RES_H_IUS
)paren
suffix:semicolon
)brace
DECL|variable|z8530_nop
r_struct
id|z8530_irqhandler
id|z8530_nop
op_assign
(brace
id|z8530_rx_clear
comma
id|z8530_tx_clear
comma
id|z8530_status_clear
)brace
suffix:semicolon
DECL|variable|z8530_nop
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_nop
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_interrupt - Handle an interrupt from a Z8530&n; *&t;@irq: &t;Interrupt number&n; *&t;@dev_id: The Z8530 device that is interrupting.&n; *&t;@regs: unused&n; *&n; *&t;A Z85[2]30 device has stuck its hand in the air for attention.&n; *&t;We scan both the channels on the chip for events and then call&n; *&t;the channel specific call backs for each channel that has events.&n; *&t;We have to use callback functions because the two channels can be&n; *&t;in different modes.&n; */
DECL|function|z8530_interrupt
r_void
id|z8530_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|z8530_dev
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
id|u8
id|intr
suffix:semicolon
r_static
r_volatile
r_int
id|locker
op_assign
l_int|0
suffix:semicolon
r_int
id|work
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|locker
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IRQ re-enter&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|locker
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|work
OL
l_int|5000
)paren
(brace
r_struct
id|z8530_irqhandler
op_star
id|irqs
op_assign
id|dev-&gt;chanA.irqs
suffix:semicolon
id|intr
op_assign
id|read_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|intr
op_amp
(paren
id|CHARxIP
op_or
id|CHATxIP
op_or
id|CHAEXT
op_or
id|CHBRxIP
op_or
id|CHBTxIP
op_or
id|CHBEXT
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* This holds the IRQ status. On the 8530 you must read it from chan &n;&t;&t;   A even though it applies to the whole chip */
multiline_comment|/* Now walk the chip and see what it is wanting - it may be&n;&t;&t;   an IRQ for someone else remember */
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|CHARxIP
op_or
id|CHATxIP
op_or
id|CHAEXT
)paren
)paren
(brace
r_if
c_cond
(paren
id|intr
op_amp
id|CHARxIP
)paren
(brace
id|irqs
op_member_access_from_pointer
id|rx
c_func
(paren
op_amp
id|dev-&gt;chanA
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
id|CHATxIP
)paren
(brace
id|irqs
op_member_access_from_pointer
id|tx
c_func
(paren
op_amp
id|dev-&gt;chanA
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
id|CHAEXT
)paren
(brace
id|irqs
op_member_access_from_pointer
id|status
c_func
(paren
op_amp
id|dev-&gt;chanA
)paren
suffix:semicolon
)brace
)brace
id|irqs
op_assign
id|dev-&gt;chanB.irqs
suffix:semicolon
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|CHBRxIP
op_or
id|CHBTxIP
op_or
id|CHBEXT
)paren
)paren
(brace
r_if
c_cond
(paren
id|intr
op_amp
id|CHBRxIP
)paren
(brace
id|irqs
op_member_access_from_pointer
id|rx
c_func
(paren
op_amp
id|dev-&gt;chanB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
id|CHBTxIP
)paren
(brace
id|irqs
op_member_access_from_pointer
id|tx
c_func
(paren
op_amp
id|dev-&gt;chanB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
id|CHBEXT
)paren
(brace
id|irqs
op_member_access_from_pointer
id|status
c_func
(paren
op_amp
id|dev-&gt;chanB
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|work
op_eq
l_int|5000
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: interrupt jammed - abort(0x%X)!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|intr
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok all done */
id|locker
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_interrupt
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_interrupt
)paren
suffix:semicolon
DECL|variable|reg_init
r_static
r_char
id|reg_init
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x55
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_sync_open - Open a Z8530 channel for PIO&n; *&t;@dev:&t;The network interface we are using&n; *&t;@c:&t;The Z8530 channel to open in synchronous PIO mode&n; *&n; *&t;Switch a Z8530 into synchronous mode without DMA assist. We&n; *&t;raise the RTS/DTR and commence network operation.&n; */
DECL|function|z8530_sync_open
r_int
id|z8530_sync_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|c-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|c-&gt;mtu
op_assign
id|dev-&gt;mtu
op_plus
l_int|64
suffix:semicolon
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
id|c-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;skb2
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;irqs
op_assign
op_amp
id|z8530_sync
suffix:semicolon
multiline_comment|/* This loads the double buffer up */
id|z8530_rx_done
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Load the frame ring */
id|z8530_rx_done
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Load the backup frame */
id|z8530_rtsdtr
c_func
(paren
id|c
comma
l_int|1
)paren
suffix:semicolon
id|c-&gt;dma_tx
op_assign
l_int|0
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|TxINT_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
op_or
id|RxENABLE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_sync_open
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync_open
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_sync_close - Close a PIO Z8530 channel&n; *&t;@dev: Network device to close&n; *&t;@c: Z8530 channel to disassociate and move to idle&n; *&n; *&t;Close down a Z8530 interface and switch its interrupt handlers&n; *&t;to discard future events.&n; */
DECL|function|z8530_sync_close
r_int
id|z8530_sync_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|u8
id|chk
suffix:semicolon
id|c-&gt;irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|c-&gt;max
op_assign
l_int|0
suffix:semicolon
id|c-&gt;sync
op_assign
l_int|0
suffix:semicolon
id|chk
op_assign
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
)paren
suffix:semicolon
id|z8530_rtsdtr
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_sync_close
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync_close
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_sync_dma_open - Open a Z8530 for DMA I/O&n; *&t;@dev: The network device to attach&n; *&t;@c: The Z8530 channel to configure in sync DMA mode.&n; *&n; *&t;Set up a Z85x30 device for synchronous DMA in both directions. Two&n; *&t;ISA DMA channels must be available for this to work. We assume ISA&n; *&t;DMA driven I/O and PC limits on access.&n; */
DECL|function|z8530_sync_dma_open
r_int
id|z8530_sync_dma_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|c-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|c-&gt;mtu
op_assign
id|dev-&gt;mtu
op_plus
l_int|64
suffix:semicolon
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
id|c-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;skb2
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load the DMA interfaces up&n;&t; */
id|c-&gt;rxdma_on
op_assign
l_int|0
suffix:semicolon
id|c-&gt;txdma_on
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the DMA flip buffers. Limit by page size.&n;&t; *&t;Everyone runs 1500 mtu or less on wan links so this&n;&t; *&t;should be fine.&n;&t; */
r_if
c_cond
(paren
id|c-&gt;mtu
OG
id|PAGE_SIZE
op_div
l_int|2
)paren
(brace
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
id|c-&gt;rx_buf
(braket
l_int|0
)braket
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;rx_buf
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|c-&gt;rx_buf
(braket
l_int|1
)braket
op_assign
id|c-&gt;rx_buf
(braket
l_int|0
)braket
op_plus
id|PAGE_SIZE
op_div
l_int|2
suffix:semicolon
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|c-&gt;rx_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|c-&gt;rx_buf
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|c-&gt;tx_dma_buf
(braket
l_int|1
)braket
op_assign
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_plus
id|PAGE_SIZE
op_div
l_int|2
suffix:semicolon
id|c-&gt;tx_dma_used
op_assign
l_int|0
suffix:semicolon
id|c-&gt;dma_tx
op_assign
l_int|1
suffix:semicolon
id|c-&gt;dma_num
op_assign
l_int|0
suffix:semicolon
id|c-&gt;dma_ready
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Enable DMA control mode&n;&t; */
multiline_comment|/*&n;&t; *&t;TX DMA via DIR/REQ&n;&t; */
id|c-&gt;regs
(braket
id|R14
)braket
op_or_assign
id|DTRREQ
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R14
comma
id|c-&gt;regs
(braket
id|R14
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
id|TxINT_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;RX DMA via W/Req&n;&t; */
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|WT_FN_RDYFN
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|WT_RDY_RT
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|INT_ERR_Rx
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
id|TxINT_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|WT_RDY_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;DMA interrupts&n;&t; */
multiline_comment|/*&n;&t; *&t;Set up the DMA configuration&n;&t; */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|c-&gt;rxdma
comma
id|DMA_MODE_READ
op_or
l_int|0x10
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|c-&gt;rxdma
comma
id|virt_to_bus
c_func
(paren
id|c-&gt;rx_buf
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|c-&gt;rxdma
comma
id|c-&gt;mtu
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|c-&gt;txdma
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Select the DMA interrupt handlers&n;&t; */
id|c-&gt;rxdma_on
op_assign
l_int|1
suffix:semicolon
id|c-&gt;txdma_on
op_assign
l_int|1
suffix:semicolon
id|c-&gt;tx_dma_used
op_assign
l_int|1
suffix:semicolon
id|c-&gt;irqs
op_assign
op_amp
id|z8530_dma_sync
suffix:semicolon
id|z8530_rtsdtr
c_func
(paren
id|c
comma
l_int|1
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
op_or
id|RxENABLE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_sync_dma_open
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync_dma_open
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_sync_dma_close - Close down DMA I/O&n; *&t;@dev: Network device to detach&n; *&t;@c: Z8530 channel to move into discard mode&n; *&n; *&t;Shut down a DMA mode synchronous interface. Halt the DMA, and&n; *&t;free the buffers.&n; */
DECL|function|z8530_sync_dma_close
r_int
id|z8530_sync_dma_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
id|u8
id|chk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|c-&gt;irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|c-&gt;max
op_assign
l_int|0
suffix:semicolon
id|c-&gt;sync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Disable the PC DMA channels&n;&t; */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|c-&gt;rxdma_on
op_assign
l_int|0
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|c-&gt;txdma_on
op_assign
l_int|0
suffix:semicolon
id|c-&gt;tx_dma_used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Disable DMA control mode&n;&t; */
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
id|WT_RDY_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
(paren
id|WT_RDY_RT
op_or
id|WT_FN_RDYFN
op_or
id|INT_ERR_Rx
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|INT_ALL_Rx
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R14
)braket
op_and_assign
op_complement
id|DTRREQ
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R14
comma
id|c-&gt;regs
(braket
id|R14
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;rx_buf
(braket
l_int|0
)braket
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|c-&gt;rx_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|c-&gt;rx_buf
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|chk
op_assign
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
)paren
suffix:semicolon
id|z8530_rtsdtr
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_sync_dma_close
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync_dma_close
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_sync_txdma_open - Open a Z8530 for TX driven DMA&n; *&t;@dev: The network device to attach&n; *&t;@c: The Z8530 channel to configure in sync DMA mode.&n; *&n; *&t;Set up a Z85x30 device for synchronous DMA tranmission. One&n; *&t;ISA DMA channel must be available for this to work. The receive&n; *&t;side is run in PIO mode, but then it has the bigger FIFO.&n; */
DECL|function|z8530_sync_txdma_open
r_int
id|z8530_sync_txdma_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Opening sync interface for TX-DMA&bslash;n&quot;
)paren
suffix:semicolon
id|c-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|c-&gt;mtu
op_assign
id|dev-&gt;mtu
op_plus
l_int|64
suffix:semicolon
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
id|c-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;skb2
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load the PIO receive ring&n;&t; */
id|z8530_rx_done
c_func
(paren
id|c
)paren
suffix:semicolon
id|z8530_rx_done
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load the DMA interfaces up&n;&t; */
id|c-&gt;rxdma_on
op_assign
l_int|0
suffix:semicolon
id|c-&gt;txdma_on
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the DMA flip buffers. Limit by page size.&n;&t; *&t;Everyone runs 1500 mtu or less on wan links so this&n;&t; *&t;should be fine.&n;&t; */
r_if
c_cond
(paren
id|c-&gt;mtu
OG
id|PAGE_SIZE
op_div
l_int|2
)paren
(brace
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|c-&gt;tx_dma_buf
(braket
l_int|1
)braket
op_assign
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_plus
id|PAGE_SIZE
op_div
l_int|2
suffix:semicolon
id|c-&gt;tx_dma_used
op_assign
l_int|0
suffix:semicolon
id|c-&gt;dma_num
op_assign
l_int|0
suffix:semicolon
id|c-&gt;dma_ready
op_assign
l_int|1
suffix:semicolon
id|c-&gt;dma_tx
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Enable DMA control mode&n;&t; */
multiline_comment|/*&n;&t; *&t;TX DMA via DIR/REQ&n; &t; */
id|c-&gt;regs
(braket
id|R14
)braket
op_or_assign
id|DTRREQ
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R14
comma
id|c-&gt;regs
(braket
id|R14
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
id|TxINT_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set up the DMA configuration&n;&t; */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|c-&gt;txdma
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Select the DMA interrupt handlers&n;&t; */
id|c-&gt;rxdma_on
op_assign
l_int|0
suffix:semicolon
id|c-&gt;txdma_on
op_assign
l_int|1
suffix:semicolon
id|c-&gt;tx_dma_used
op_assign
l_int|1
suffix:semicolon
id|c-&gt;irqs
op_assign
op_amp
id|z8530_txdma_sync
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Loading RX&bslash;n&quot;
)paren
suffix:semicolon
id|z8530_rtsdtr
c_func
(paren
id|c
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Rx interrupts ON&bslash;n&quot;
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
op_or
id|RxENABLE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_sync_txdma_open
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync_txdma_open
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_sync_txdma_close - Close down a TX driven DMA channel&n; *&t;@dev: Network device to detach&n; *&t;@c: Z8530 channel to move into discard mode&n; *&n; *&t;Shut down a DMA/PIO split mode synchronous interface. Halt the DMA, &n; *&t;and  free the buffers.&n; */
DECL|function|z8530_sync_txdma_close
r_int
id|z8530_sync_txdma_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|chk
suffix:semicolon
id|c-&gt;irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|c-&gt;max
op_assign
l_int|0
suffix:semicolon
id|c-&gt;sync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Disable the PC DMA channels&n;&t; */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|c-&gt;txdma_on
op_assign
l_int|0
suffix:semicolon
id|c-&gt;tx_dma_used
op_assign
l_int|0
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Disable DMA control mode&n;&t; */
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
id|WT_RDY_ENAB
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_and_assign
op_complement
(paren
id|WT_RDY_RT
op_or
id|WT_FN_RDYFN
op_or
id|INT_ERR_Rx
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R1
)braket
op_or_assign
id|INT_ALL_Rx
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R1
comma
id|c-&gt;regs
(braket
id|R1
)braket
)paren
suffix:semicolon
id|c-&gt;regs
(braket
id|R14
)braket
op_and_assign
op_complement
id|DTRREQ
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R14
comma
id|c-&gt;regs
(braket
id|R14
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|c-&gt;tx_dma_buf
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|chk
op_assign
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
)paren
suffix:semicolon
id|z8530_rtsdtr
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_sync_txdma_close
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_sync_txdma_close
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Name strings for Z8530 chips. SGI claim to have a 130, Zilog deny&n; *&t;it exists...&n; */
DECL|variable|z8530_type_name
r_static
r_char
op_star
id|z8530_type_name
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_describe - Uniformly describe a Z8530 port&n; *&t;@dev: Z8530 device to describe&n; *&t;@mapping: string holding mapping type (eg &quot;I/O&quot; or &quot;Mem&quot;)&n; *&t;@io: the port value in question&n; *&n; *&t;Describe a Z8530 in a standard format. We must pass the I/O as&n; *&t;the port offset isnt predictable. The main reason for this function&n; *&t;is to try and get a common format of report.&n; */
DECL|function|z8530_describe
r_void
id|z8530_describe
c_func
(paren
r_struct
id|z8530_dev
op_star
id|dev
comma
r_char
op_star
id|mapping
comma
r_int
r_int
id|io
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s found at %s 0x%lX, IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|z8530_type_name
(braket
id|dev-&gt;type
)braket
comma
id|mapping
comma
id|Z8530_PORT_OF
c_func
(paren
id|io
)paren
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
DECL|variable|z8530_describe
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_describe
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_init - Initialise a Z8530 device&n; *&t;@dev: Z8530 device to initialise.&n; *&n; *&t;Configure up a Z8530/Z85C30 or Z85230 chip. We check the device&n; *&t;is present, identify the type and then program it to hopefully&n; *&t;keep quite and behave. This matters a lot, a Z8530 in the wrong&n; *&t;state will sometimes get into stupid modes generating 10Khz&n; *&t;interrupt streams and the like.&n; *&n; *&t;We set the interrupt handler up to discard any events, in case&n; *&t;we get them during reset or setp.&n; *&n; *&t;Return 0 for success, or a negative value indicating the problem&n; *&t;in errno form.&n; */
DECL|function|z8530_init
r_int
id|z8530_init
c_func
(paren
r_struct
id|z8530_dev
op_star
id|dev
)paren
(brace
multiline_comment|/* NOP the interrupt handlers first - we might get a&n;&t;   floating IRQ transition when we reset the chip */
id|dev-&gt;chanA.irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|dev-&gt;chanB.irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|dev-&gt;chanA.dcdcheck
op_assign
id|DCD
suffix:semicolon
id|dev-&gt;chanB.dcdcheck
op_assign
id|DCD
suffix:semicolon
multiline_comment|/* Reset the chip */
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R9
comma
l_int|0xC0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
multiline_comment|/* Now check its valid */
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R12
comma
l_int|0xAA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R12
)paren
op_ne
l_int|0xAA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R12
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R12
)paren
op_ne
l_int|0x55
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev-&gt;type
op_assign
id|Z8530
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See the application note.&n;&t; */
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R15
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we can set the low bit of R15 then&n;&t; *&t;the chip is enhanced.&n;&t; */
r_if
c_cond
(paren
id|read_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R15
)paren
op_eq
l_int|0x01
)paren
(brace
multiline_comment|/* This C30 versus 230 detect is from Klaus Kudielka&squot;s dmascc */
multiline_comment|/* Put a char in the fifo */
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R8
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R0
)paren
op_amp
id|Tx_BUF_EMP
)paren
(brace
id|dev-&gt;type
op_assign
id|Z85230
suffix:semicolon
)brace
multiline_comment|/* Has a FIFO */
r_else
id|dev-&gt;type
op_assign
id|Z85C30
suffix:semicolon
multiline_comment|/* Z85C30, 1 byte FIFO */
)brace
multiline_comment|/*&n;&t; *&t;The code assumes R7&squot; and friends are&n;&t; *&t;off. Use write_zsext() for these and keep&n;&t; *&t;this bit clear.&n;&t; */
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R15
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;At this point it looks like the chip is behaving&n;&t; */
id|memcpy
c_func
(paren
id|dev-&gt;chanA.regs
comma
id|reg_init
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;chanB.regs
comma
id|reg_init
comma
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_init
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_init
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_shutdown - Shutdown a Z8530 device&n; *&t;@dev: The Z8530 chip to shutdown&n; *&n; *&t;We set the interrupt handlers to silence any interrupts. We then &n; *&t;reset the chip and wait 100uS to be sure the reset completed. Just&n; *&t;in case the caller then tries to do stuff.&n; */
DECL|function|z8530_shutdown
r_int
id|z8530_shutdown
c_func
(paren
r_struct
id|z8530_dev
op_star
id|dev
)paren
(brace
multiline_comment|/* Reset the chip */
id|dev-&gt;chanA.irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|dev-&gt;chanB.irqs
op_assign
op_amp
id|z8530_nop
suffix:semicolon
id|write_zsreg
c_func
(paren
op_amp
id|dev-&gt;chanA
comma
id|R9
comma
l_int|0xC0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_shutdown
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_shutdown
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_channel_load - Load channel data&n; *&t;@c: Z8530 channel to configure&n; *&t;@rtable: table of register, value pairs&n; *&t;FIXME: ioctl to allow user uploaded tables&n; *&n; *&t;Load a Z8530 channel up from the system data. We use +16 to &n; *&t;indicate the &quot;prime&quot; registers. The value 255 terminates the&n; *&t;table.&n; */
DECL|function|z8530_channel_load
r_int
id|z8530_channel_load
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
id|u8
op_star
id|rtable
)paren
(brace
r_while
c_loop
(paren
op_star
id|rtable
op_ne
l_int|255
)paren
(brace
r_int
id|reg
op_assign
op_star
id|rtable
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|reg
OG
l_int|0x0F
)paren
(brace
id|write_zsreg
c_func
(paren
id|c
comma
id|R15
comma
id|c-&gt;regs
(braket
l_int|15
)braket
op_or
l_int|1
)paren
suffix:semicolon
)brace
id|write_zsreg
c_func
(paren
id|c
comma
id|reg
op_amp
l_int|0x0F
comma
op_star
id|rtable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OG
l_int|0x0F
)paren
(brace
id|write_zsreg
c_func
(paren
id|c
comma
id|R15
comma
id|c-&gt;regs
(braket
l_int|15
)braket
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
)brace
id|c-&gt;regs
(braket
id|reg
)braket
op_assign
op_star
id|rtable
op_increment
suffix:semicolon
)brace
id|c-&gt;rx_function
op_assign
id|z8530_null_rx
suffix:semicolon
id|c-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;tx_skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;tx_next_skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;mtu
op_assign
l_int|1500
suffix:semicolon
id|c-&gt;max
op_assign
l_int|0
suffix:semicolon
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
id|c-&gt;status
op_assign
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
suffix:semicolon
id|c-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R3
comma
id|c-&gt;regs
(braket
id|R3
)braket
op_or
id|RxENABLE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_channel_load
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_channel_load
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_tx_begin - Begin packet transmission&n; *&t;@c: The Z8530 channel to kick&n; *&n; *&t;This is the speed sensitive side of transmission. If we are called&n; *&t;and no buffer is being transmitted we commence the next buffer. If&n; *&t;nothing is queued we idle the sync. &n; *&n; *&t;Note: We are handling this code path in the interrupt path, keep it&n; *&t;fast or bad things will happen.&n; */
DECL|function|z8530_tx_begin
r_static
r_void
id|z8530_tx_begin
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;tx_skb
)paren
(brace
r_return
suffix:semicolon
)brace
id|c-&gt;tx_skb
op_assign
id|c-&gt;tx_next_skb
suffix:semicolon
id|c-&gt;tx_next_skb
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;tx_ptr
op_assign
id|c-&gt;tx_next_ptr
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|c-&gt;netdevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;tx_skb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Idle on */
r_if
c_cond
(paren
id|c-&gt;dma_tx
)paren
(brace
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Check if we crapped out.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|get_dma_residue
c_func
(paren
id|c-&gt;txdma
)paren
)paren
(brace
id|c-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|c-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
)brace
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|c-&gt;txcount
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;txcount
op_assign
id|c-&gt;tx_skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;dma_tx
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;FIXME. DMA is broken for the original 8530,&n;&t;&t;&t; *&t;on the older parts we need to set a flag and&n;&t;&t;&t; *&t;wait for a further TX interrupt to fire this&n;&t;&t;&t; *&t;stage off&t;&n;&t;&t;&t; */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;These two are needed by the 8530/85C30&n;&t;&t;&t; *&t;and must be issued when idling.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|c-&gt;dev-&gt;type
op_ne
id|Z85230
)paren
(brace
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_Tx_CRC
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_EOM_L
)paren
suffix:semicolon
)brace
id|write_zsreg
c_func
(paren
id|c
comma
id|R10
comma
id|c-&gt;regs
(braket
l_int|10
)braket
op_amp
op_complement
id|ABUNDER
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|c-&gt;txdma
comma
id|virt_to_bus
c_func
(paren
id|c-&gt;tx_ptr
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|c-&gt;txdma
comma
id|c-&gt;txcount
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|c-&gt;txdma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_EOM_L
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|c
comma
id|R5
comma
id|c-&gt;regs
(braket
id|R5
)braket
op_or
id|TxENAB
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ABUNDER off */
id|write_zsreg
c_func
(paren
id|c
comma
id|R10
comma
id|c-&gt;regs
(braket
l_int|10
)braket
)paren
suffix:semicolon
id|write_zsctrl
c_func
(paren
id|c
comma
id|RES_Tx_CRC
)paren
suffix:semicolon
singleline_comment|//???&t;&t;&t;write_zsctrl(c, RES_EOM_L);
r_while
c_loop
(paren
id|c-&gt;txcount
op_logical_and
(paren
id|read_zsreg
c_func
(paren
id|c
comma
id|R0
)paren
op_amp
id|Tx_BUF_EMP
)paren
)paren
(brace
id|write_zsreg
c_func
(paren
id|c
comma
id|R8
comma
op_star
id|c-&gt;tx_ptr
op_increment
)paren
suffix:semicolon
id|c-&gt;txcount
op_decrement
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;z8530_tx_done - TX complete callback&n; *&t;@c: The channel that completed a transmit.&n; *&n; *&t;This is called when we complete a packet send. We wake the queue,&n; *&t;start the next packet going and then free the buffer of the existing&n; *&t;packet. This code is fairly timing sensitive.&n; */
DECL|function|z8530_tx_done
r_static
r_void
id|z8530_tx_done
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|z8530_buffer_lock
comma
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|c-&gt;netdevice
)paren
suffix:semicolon
multiline_comment|/* Actually this can happen.*/
r_if
c_cond
(paren
id|c-&gt;tx_skb
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|z8530_buffer_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb
op_assign
id|c-&gt;tx_skb
suffix:semicolon
id|c-&gt;tx_skb
op_assign
l_int|NULL
suffix:semicolon
id|z8530_tx_begin
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|z8530_buffer_lock
comma
id|flags
)paren
suffix:semicolon
id|c-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|c-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_null_rx - Discard a packet&n; *&t;@c: The channel the packet arrived on&n; *&t;@skb: The buffer&n; *&n; *&t;We point the receive handler at this function when idle. Instead&n; *&t;of syncppp processing the frames we get to throw them away.&n; */
DECL|function|z8530_null_rx
r_void
id|z8530_null_rx
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|variable|z8530_null_rx
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_null_rx
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_rx_done - Receive completion callback&n; *&t;@c: The channel that completed a receive&n; *&n; *&t;A new packet is complete. Our goal here is to get back into receive&n; *&t;mode as fast as possible. On the Z85230 we could change to using&n; *&t;ESCC mode, but on the older chips we have no choice. We flip to the&n; *&t;new buffer immediately in DMA mode so that the DMA of the next&n; *&t;frame can occur while we are copying the previous buffer to an sk_buff&n; */
DECL|function|z8530_rx_done
r_static
r_void
id|z8530_rx_done
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|ct
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is our receive engine in DMA mode&n;&t; */
r_if
c_cond
(paren
id|c-&gt;rxdma_on
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Save the ready state and the buffer currently&n;&t;&t; *&t;being used as the DMA target&n;&t;&t; */
r_int
id|ready
op_assign
id|c-&gt;dma_ready
suffix:semicolon
r_int
r_char
op_star
id|rxb
op_assign
id|c-&gt;rx_buf
(braket
id|c-&gt;dma_num
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Complete this DMA. Neccessary to find the length&n;&t;&t; */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
id|c-&gt;rxdma_on
op_assign
l_int|0
suffix:semicolon
id|ct
op_assign
id|c-&gt;mtu
op_minus
id|get_dma_residue
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
OL
l_int|0
)paren
(brace
id|ct
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Shit happens.. */
id|c-&gt;dma_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Normal case: the other slot is free, start the next DMA&n;&t;&t; *&t;into it immediately.&n;&t;&t; */
r_if
c_cond
(paren
id|ready
)paren
(brace
id|c-&gt;dma_num
op_xor_assign
l_int|1
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|c-&gt;rxdma
comma
id|DMA_MODE_READ
op_or
l_int|0x10
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|c-&gt;rxdma
comma
id|virt_to_bus
c_func
(paren
id|c-&gt;rx_buf
(braket
id|c-&gt;dma_num
)braket
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|c-&gt;rxdma
comma
id|c-&gt;mtu
)paren
suffix:semicolon
id|c-&gt;rxdma_on
op_assign
l_int|1
suffix:semicolon
id|enable_dma
c_func
(paren
id|c-&gt;rxdma
)paren
suffix:semicolon
multiline_comment|/* Stop any frames that we missed the head of &n;&t;&t;&t;   from passing */
id|write_zsreg
c_func
(paren
id|c
comma
id|R0
comma
id|RES_Rx_CRC
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Can&squot;t occur as we dont reenable the DMA irq until&n;&t;&t;&t;   after the flip is done */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA flip overrun!&bslash;n&quot;
comma
id|c-&gt;netdevice-&gt;name
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Shove the old buffer into an sk_buff. We can&squot;t DMA&n;&t;&t; *&t;directly into one on a PC - it might be above the 16Mb&n;&t;&t; *&t;boundary. Optimisation - we could check to see if we&n;&t;&t; *&t;can avoid the copy. Optimisation 2 - make the memcpy&n;&t;&t; *&t;a copychecksum.&n;&t;&t; */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|c-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Memory squeeze.&bslash;n&quot;
comma
id|c-&gt;netdevice-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_put
c_func
(paren
id|skb
comma
id|ct
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|rxb
comma
id|ct
)paren
suffix:semicolon
id|c-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|c-&gt;stats.rx_bytes
op_add_assign
id|ct
suffix:semicolon
)brace
id|c-&gt;dma_ready
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|RT_LOCK
suffix:semicolon
id|skb
op_assign
id|c-&gt;skb
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;The game we play for non DMA is similar. We want to&n;&t;&t; *&t;get the controller set up for the next packet as fast&n;&t;&t; *&t;as possible. We potentially only have one byte + the&n;&t;&t; *&t;fifo length for this. Thus we want to flip to the new&n;&t;&t; *&t;buffer and then mess around copying and allocating&n;&t;&t; *&t;things. For the current case it doesn&squot;t matter but&n;&t;&t; *&t;if you build a system where the sync irq isnt blocked&n;&t;&t; *&t;by the kernel IRQ disable then you need only block the&n;&t;&t; *&t;sync IRQ for the RT_LOCK area.&n;&t;&t; *&t;&n;&t;&t; */
id|ct
op_assign
id|c-&gt;count
suffix:semicolon
id|c-&gt;skb
op_assign
id|c-&gt;skb2
suffix:semicolon
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
id|c-&gt;max
op_assign
id|c-&gt;mtu
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;skb
)paren
(brace
id|c-&gt;dptr
op_assign
id|c-&gt;skb-&gt;data
suffix:semicolon
id|c-&gt;max
op_assign
id|c-&gt;mtu
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;count
op_assign
l_int|0
suffix:semicolon
id|c-&gt;max
op_assign
l_int|0
suffix:semicolon
)brace
id|RT_UNLOCK
suffix:semicolon
id|c-&gt;skb2
op_assign
id|dev_alloc_skb
c_func
(paren
id|c-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;skb2
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: memory squeeze.&bslash;n&quot;
comma
id|c-&gt;netdevice-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_put
c_func
(paren
id|c-&gt;skb2
comma
id|c-&gt;mtu
)paren
suffix:semicolon
)brace
id|c-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|c-&gt;stats.rx_bytes
op_add_assign
id|ct
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If we received a frame we must now process it.&n;&t; */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|skb_trim
c_func
(paren
id|skb
comma
id|ct
)paren
suffix:semicolon
id|c
op_member_access_from_pointer
id|rx_function
c_func
(paren
id|c
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Lost a frame&bslash;n&quot;
comma
id|c-&gt;netdevice-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;spans_boundary - Check a packet can be ISA DMA&squot;d&n; *&t;@skb: The buffer to check&n; *&n; *&t;Returns true if the buffer cross a DMA boundary on a PC. The poor&n; *&t;thing can only DMA within a 64K block not across the edges of it.&n; */
DECL|function|spans_boundary
r_extern
r_inline
r_int
id|spans_boundary
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|a
op_assign
(paren
r_int
r_int
)paren
id|skb-&gt;data
suffix:semicolon
id|a
op_xor_assign
(paren
id|a
op_plus
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a
op_amp
l_int|0x00010000
)paren
(brace
multiline_comment|/* If the 64K bit is different.. */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;z8530_queue_xmit - Queue a packet&n; *&t;@c: The channel to use&n; *&t;@skb: The packet to kick down the channel&n; *&n; *&t;Queue a packet for transmission. Because we have rather&n; *&t;hard to hit interrupt latencies for the Z85230 per packet &n; *&t;even in DMA mode we do the flip to DMA buffer if needed here&n; *&t;not in the IRQ.&n; */
DECL|function|z8530_queue_xmit
r_int
id|z8530_queue_xmit
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|c-&gt;netdevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;tx_next_skb
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* PC SPECIFIC - DMA limits */
multiline_comment|/*&n;&t; *&t;If we will DMA the transmit and its gone over the ISA bus&n;&t; *&t;limit, then copy to the flip buffer&n;&t; */
r_if
c_cond
(paren
id|c-&gt;dma_tx
op_logical_and
(paren
(paren
r_int
r_int
)paren
(paren
id|virt_to_bus
c_func
(paren
id|skb-&gt;data
op_plus
id|skb-&gt;len
)paren
)paren
op_ge
l_int|16
op_star
l_int|1024
op_star
l_int|1024
op_logical_or
id|spans_boundary
c_func
(paren
id|skb
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Send the flip buffer, and flip the flippy bit.&n;&t;&t; *&t;We don&squot;t care which is used when just so long as&n;&t;&t; *&t;we never use the same buffer twice in a row. Since&n;&t;&t; *&t;only one buffer can be going out at a time the other&n;&t;&t; *&t;has to be safe.&n;&t;&t; */
id|c-&gt;tx_next_ptr
op_assign
id|c-&gt;tx_dma_buf
(braket
id|c-&gt;tx_dma_used
)braket
suffix:semicolon
id|c-&gt;tx_dma_used
op_xor_assign
l_int|1
suffix:semicolon
multiline_comment|/* Flip temp buffer */
id|memcpy
c_func
(paren
id|c-&gt;tx_next_ptr
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
r_else
id|c-&gt;tx_next_ptr
op_assign
id|skb-&gt;data
suffix:semicolon
id|RT_LOCK
suffix:semicolon
id|c-&gt;tx_next_skb
op_assign
id|skb
suffix:semicolon
id|RT_UNLOCK
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|z8530_buffer_lock
comma
id|flags
)paren
suffix:semicolon
id|z8530_tx_begin
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|z8530_buffer_lock
comma
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|c-&gt;netdevice
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|z8530_queue_xmit
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_queue_xmit
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;z8530_get_stats - Get network statistics&n; *&t;@c: The channel to use&n; *&n; *&t;Get the statistics block. We keep the statistics in software as&n; *&t;the chip doesn&squot;t do it for us.&n; */
DECL|function|z8530_get_stats
r_struct
id|net_device_stats
op_star
id|z8530_get_stats
c_func
(paren
r_struct
id|z8530_channel
op_star
id|c
)paren
(brace
r_return
op_amp
id|c-&gt;stats
suffix:semicolon
)brace
DECL|variable|z8530_get_stats
id|EXPORT_SYMBOL
c_func
(paren
id|z8530_get_stats
)paren
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*&n; *&t;Module support&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Generic Z85C30/Z85230 interface driver v0.02&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
eof
