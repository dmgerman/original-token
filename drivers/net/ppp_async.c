multiline_comment|/*&n; * PPP async serial channel driver for Linux.&n; *&n; * Copyright 1999 Paul Mackerras.&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * This driver provides the encapsulation and framing for sending&n; * and receiving PPP frames over async serial lines.  It relies on&n; * the generic PPP layer to give it frames to send and to process&n; * received frames.  It implements the PPP line discipline.&n; *&n; * Part of the code in this driver was inspired by the old async-only&n; * PPP driver, written by Michael Callahan and Al Longyear, and&n; * subsequently hacked by Paul Mackerras.&n; *&n; * ==FILEVERSION 990806==&n; */
multiline_comment|/* $Id$ */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/if_ppp.h&gt;
macro_line|#include &lt;linux/ppp_channel.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|PPP_VERSION
mdefine_line|#define PPP_VERSION&t;&quot;2.4.0&quot;
DECL|macro|OBUFSIZE
mdefine_line|#define OBUFSIZE&t;256
multiline_comment|/* Structure for storing local state. */
DECL|struct|asyncppp
r_struct
id|asyncppp
(brace
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|state
r_int
r_int
id|state
suffix:semicolon
DECL|member|rbits
r_int
r_int
id|rbits
suffix:semicolon
DECL|member|mru
r_int
id|mru
suffix:semicolon
DECL|member|busy
r_int
r_int
id|busy
suffix:semicolon
DECL|member|xaccm
id|u32
id|xaccm
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|raccm
id|u32
id|raccm
suffix:semicolon
DECL|member|bytes_sent
r_int
r_int
id|bytes_sent
suffix:semicolon
DECL|member|bytes_rcvd
r_int
r_int
id|bytes_rcvd
suffix:semicolon
DECL|member|tpkt
r_struct
id|sk_buff
op_star
id|tpkt
suffix:semicolon
DECL|member|tpkt_pos
r_int
id|tpkt_pos
suffix:semicolon
DECL|member|tfcs
id|u16
id|tfcs
suffix:semicolon
DECL|member|optr
r_int
r_char
op_star
id|optr
suffix:semicolon
DECL|member|olim
r_int
r_char
op_star
id|olim
suffix:semicolon
DECL|member|xq
r_struct
id|sk_buff_head
id|xq
suffix:semicolon
DECL|member|last_xmit
r_int
r_int
id|last_xmit
suffix:semicolon
DECL|member|rpkt
r_struct
id|sk_buff
op_star
id|rpkt
suffix:semicolon
DECL|member|rq
r_struct
id|sk_buff_head
id|rq
suffix:semicolon
DECL|member|rwait
id|wait_queue_head_t
id|rwait
suffix:semicolon
DECL|member|chan
r_struct
id|ppp_channel
id|chan
suffix:semicolon
multiline_comment|/* interface to generic ppp layer */
DECL|member|connected
r_int
id|connected
suffix:semicolon
DECL|member|obuf
r_int
r_char
id|obuf
(braket
id|OBUFSIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Bit numbers in busy */
DECL|macro|XMIT_BUSY
mdefine_line|#define XMIT_BUSY&t;0
DECL|macro|RECV_BUSY
mdefine_line|#define RECV_BUSY&t;1
DECL|macro|XMIT_WAKEUP
mdefine_line|#define XMIT_WAKEUP&t;2
DECL|macro|XMIT_FULL
mdefine_line|#define XMIT_FULL&t;3
multiline_comment|/* State bits */
DECL|macro|SC_TOSS
mdefine_line|#define SC_TOSS&t;&t;0x20000000
DECL|macro|SC_ESCAPE
mdefine_line|#define SC_ESCAPE&t;0x40000000
multiline_comment|/* Bits in rbits */
DECL|macro|SC_RCV_BITS
mdefine_line|#define SC_RCV_BITS&t;(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)
DECL|macro|PPPASYNC_MAX_RQLEN
mdefine_line|#define PPPASYNC_MAX_RQLEN&t;32&t;/* arbitrary */
DECL|variable|flag_time
r_static
r_int
id|flag_time
op_assign
id|HZ
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flag_time
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Prototypes.&n; */
r_static
r_int
id|ppp_async_encode
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_push
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ppp_async_flush_output
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ppp_async_input
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
suffix:semicolon
DECL|variable|async_ops
r_struct
id|ppp_channel_ops
id|async_ops
op_assign
(brace
id|ppp_async_send
)brace
suffix:semicolon
multiline_comment|/*&n; * Routines for locking and unlocking the transmit and receive paths.&n; */
r_static
r_inline
r_void
DECL|function|lock_path
id|lock_path
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_int
id|bit
)paren
(brace
r_do
(brace
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|bit
comma
op_amp
id|ap-&gt;busy
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
id|bit
comma
op_amp
id|ap-&gt;busy
)paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|trylock_path
id|trylock_path
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_int
id|bit
)paren
(brace
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|bit
comma
op_amp
id|ap-&gt;busy
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|unlock_path
id|unlock_path
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_int
id|bit
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|ap-&gt;busy
)paren
suffix:semicolon
)brace
DECL|macro|lock_xmit_path
mdefine_line|#define lock_xmit_path(ap)&t;lock_path(ap, XMIT_BUSY)
DECL|macro|trylock_xmit_path
mdefine_line|#define trylock_xmit_path(ap)&t;trylock_path(ap, XMIT_BUSY)
DECL|macro|unlock_xmit_path
mdefine_line|#define unlock_xmit_path(ap)&t;unlock_path(ap, XMIT_BUSY)
DECL|macro|lock_recv_path
mdefine_line|#define lock_recv_path(ap)&t;lock_path(ap, RECV_BUSY)
DECL|macro|trylock_recv_path
mdefine_line|#define trylock_recv_path(ap)&t;trylock_path(ap, RECV_BUSY)
DECL|macro|unlock_recv_path
mdefine_line|#define unlock_recv_path(ap)&t;unlock_path(ap, RECV_BUSY)
r_static
r_inline
r_void
DECL|function|flush_skb_queue
id|flush_skb_queue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|q
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines implementing the PPP line discipline.&n; */
multiline_comment|/*&n; * Called when a tty is put into PPP line discipline.&n; */
r_static
r_int
DECL|function|ppp_async_open
id|ppp_async_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
suffix:semicolon
id|ap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* initialize the asyncppp structure */
id|memset
c_func
(paren
id|ap
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ap
)paren
)paren
suffix:semicolon
id|ap-&gt;tty
op_assign
id|tty
suffix:semicolon
id|ap-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|0
)braket
op_assign
op_complement
l_int|0U
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|3
)braket
op_assign
l_int|0x60000000U
suffix:semicolon
id|ap-&gt;raccm
op_assign
op_complement
l_int|0U
suffix:semicolon
id|ap-&gt;optr
op_assign
id|ap-&gt;obuf
suffix:semicolon
id|ap-&gt;olim
op_assign
id|ap-&gt;obuf
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ap-&gt;xq
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ap-&gt;rwait
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|ap
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when the tty is put into another line discipline&n; * (or it hangs up).&n; */
r_static
r_void
DECL|function|ppp_async_close
id|ppp_async_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|lock_xmit_path
c_func
(paren
id|ap
)paren
suffix:semicolon
id|lock_recv_path
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;rpkt
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|ap-&gt;rpkt
)paren
suffix:semicolon
id|flush_skb_queue
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|flush_skb_queue
c_func
(paren
op_amp
id|ap-&gt;xq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;connected
)paren
id|ppp_unregister_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a PPP frame.  pppd can use this to negotiate over the&n; * channel before it joins it to a bundle.&n; */
r_static
id|ssize_t
DECL|function|ppp_async_read
id|ppp_async_read
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* should never happen */
id|add_wait_queue
c_func
(paren
op_amp
id|ap-&gt;rwait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ap-&gt;rwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|count
)paren
r_goto
id|outf
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
)paren
r_goto
id|outf
suffix:semicolon
id|ret
op_assign
id|skb-&gt;len
suffix:semicolon
id|outf
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a ppp frame.  pppd can use this to send frames over&n; * this particular channel.&n; */
r_static
id|ssize_t
DECL|function|ppp_async_write
id|ppp_async_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* should never happen */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|count
op_plus
l_int|2
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|ap-&gt;xq
comma
id|skb
)paren
suffix:semicolon
id|ppp_async_push
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ret
op_assign
id|count
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|ppp_async_ioctl
id|ppp_async_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_int
id|err
comma
id|val
suffix:semicolon
id|u32
id|accm
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* should never happen */
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCGFLAGS
suffix:colon
id|val
op_assign
id|ap-&gt;flags
op_or
id|ap-&gt;rbits
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSFLAGS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|ap-&gt;flags
op_assign
id|val
op_amp
op_complement
id|SC_RCV_BITS
suffix:semicolon
id|ap-&gt;rbits
op_assign
id|val
op_amp
id|SC_RCV_BITS
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;raccm
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;raccm
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|ap-&gt;xaccm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|accm
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|accm
)paren
)paren
)paren
r_break
suffix:semicolon
id|accm
(braket
l_int|2
)braket
op_and_assign
op_complement
l_int|0x40000000U
suffix:semicolon
multiline_comment|/* can&squot;t escape 0x5e */
id|accm
(braket
l_int|3
)braket
op_or_assign
l_int|0x60000000U
suffix:semicolon
multiline_comment|/* must escape 0x7d, 0x7e */
id|memcpy
c_func
(paren
id|ap-&gt;xaccm
comma
id|accm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGMRU
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;mru
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMRU
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
id|PPP_MRU
)paren
id|val
op_assign
id|PPP_MRU
suffix:semicolon
id|ap-&gt;mru
op_assign
id|val
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCATTACH
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EALREADY
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;connected
)paren
r_break
suffix:semicolon
id|ap-&gt;chan
dot
r_private
op_assign
id|ap
suffix:semicolon
id|ap-&gt;chan.ops
op_assign
op_amp
id|async_ops
suffix:semicolon
id|err
op_assign
id|ppp_register_channel
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|ap-&gt;connected
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCDETACH
suffix:colon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;connected
)paren
r_break
suffix:semicolon
id|ppp_unregister_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
id|ap-&gt;connected
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCFLSH
suffix:colon
multiline_comment|/* flush our buffers and the serial port&squot;s buffer */
r_if
c_cond
(paren
id|arg
op_eq
id|TCIFLUSH
op_logical_or
id|arg
op_eq
id|TCIOFLUSH
)paren
id|flush_skb_queue
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|TCIOFLUSH
op_logical_or
id|arg
op_eq
id|TCOFLUSH
)paren
id|ppp_async_flush_output
c_func
(paren
id|ap
)paren
suffix:semicolon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIONREAD
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
)paren
op_ne
l_int|0
)paren
id|val
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|ppp_async_poll
id|ppp_async_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* should never happen */
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|ap-&gt;rwait
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_or
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
r_static
r_int
DECL|function|ppp_async_room
id|ppp_async_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65535
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_async_receive
id|ppp_async_receive
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|trylock_recv_path
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ppp_async_input
c_func
(paren
id|ap
comma
id|buf
comma
id|flags
comma
id|count
)paren
suffix:semicolon
id|unlock_recv_path
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver.unthrottle
)paren
id|tty-&gt;driver
dot
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_async_wakeup
id|ppp_async_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppp_async_push
c_func
(paren
id|ap
)paren
op_logical_and
id|ap-&gt;connected
)paren
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
DECL|variable|ppp_ldisc
r_static
r_struct
id|tty_ldisc
id|ppp_ldisc
op_assign
(brace
id|magic
suffix:colon
id|TTY_LDISC_MAGIC
comma
id|name
suffix:colon
l_string|&quot;ppp&quot;
comma
id|open
suffix:colon
id|ppp_async_open
comma
id|close
suffix:colon
id|ppp_async_close
comma
id|read
suffix:colon
id|ppp_async_read
comma
id|write
suffix:colon
id|ppp_async_write
comma
id|ioctl
suffix:colon
id|ppp_async_ioctl
comma
id|poll
suffix:colon
id|ppp_async_poll
comma
id|receive_room
suffix:colon
id|ppp_async_room
comma
id|receive_buf
suffix:colon
id|ppp_async_receive
comma
id|write_wakeup
suffix:colon
id|ppp_async_wakeup
comma
)brace
suffix:semicolon
r_int
DECL|function|ppp_async_init
id|ppp_async_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_PPP
comma
op_amp
id|ppp_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP_async: error %d registering line disc.&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedures for encapsulation and framing.&n; */
DECL|variable|ppp_crc16_table
id|u16
id|ppp_crc16_table
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
DECL|variable|ppp_crc16_table
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_crc16_table
)paren
suffix:semicolon
DECL|macro|fcstab
mdefine_line|#define fcstab&t;ppp_crc16_table&t;&t;/* for PPP_FCS macro */
multiline_comment|/*&n; * Procedure to encode the data for async serial transmission.&n; * Does octet stuffing (escaping), puts the address/control bytes&n; * on if A/C compression is disabled, and does protocol compression.&n; * Assumes ap-&gt;tpkt != 0 on entry.&n; * Returns 1 if we finished the current frame, 0 otherwise.&n; */
DECL|macro|PUT_BYTE
mdefine_line|#define PUT_BYTE(ap, buf, c, islcp)&t;do {&t;&t;&bslash;&n;&t;if ((islcp &amp;&amp; c &lt; 0x20) || (ap-&gt;xaccm[c &gt;&gt; 5] &amp; (1 &lt;&lt; (c &amp; 0x1f)))) {&bslash;&n;&t;&t;*buf++ = PPP_ESCAPE;&t;&t;&t;&bslash;&n;&t;&t;*buf++ = c ^ 0x20;&t;&t;&t;&bslash;&n;&t;} else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*buf++ = c;&t;&t;&t;&t;&bslash;&n;} while (0)
r_static
r_int
DECL|function|ppp_async_encode
id|ppp_async_encode
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_int
id|fcs
comma
id|i
comma
id|count
comma
id|c
comma
id|proto
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
op_star
id|buflim
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|islcp
suffix:semicolon
id|buf
op_assign
id|ap-&gt;obuf
suffix:semicolon
id|ap-&gt;olim
op_assign
id|buf
suffix:semicolon
id|ap-&gt;optr
op_assign
id|buf
suffix:semicolon
id|i
op_assign
id|ap-&gt;tpkt_pos
suffix:semicolon
id|data
op_assign
id|ap-&gt;tpkt-&gt;data
suffix:semicolon
id|count
op_assign
id|ap-&gt;tpkt-&gt;len
suffix:semicolon
id|fcs
op_assign
id|ap-&gt;tfcs
suffix:semicolon
id|proto
op_assign
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * LCP packets with code values between 1 (configure-reqest)&n;&t; * and 7 (code-reject) must be sent as though no options&n;&t; * had been negotiated.&n;&t; */
id|islcp
op_assign
id|proto
op_eq
id|PPP_LCP
op_logical_and
l_int|1
op_le
id|data
(braket
l_int|2
)braket
op_logical_and
id|data
(braket
l_int|2
)braket
op_le
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Start of a new packet - insert the leading FLAG&n;&t;&t; * character if necessary.&n;&t;&t; */
r_if
c_cond
(paren
id|islcp
op_logical_or
id|flag_time
op_eq
l_int|0
op_logical_or
id|jiffies
op_minus
id|ap-&gt;last_xmit
op_ge
id|flag_time
)paren
op_star
id|buf
op_increment
op_assign
id|PPP_FLAG
suffix:semicolon
id|ap-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
id|fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put in the address/control bytes if necessary&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_eq
l_int|0
op_logical_or
id|islcp
)paren
(brace
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
l_int|0xff
comma
id|islcp
)paren
suffix:semicolon
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
l_int|0xff
)paren
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
l_int|0x03
comma
id|islcp
)paren
suffix:semicolon
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
l_int|0x03
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Once we put in the last byte, we need to put in the FCS&n;&t; * and closing flag, so make sure there is at least 7 bytes&n;&t; * of free space in the output buffer.&n;&t; */
id|buflim
op_assign
id|ap-&gt;obuf
op_plus
id|OBUFSIZE
op_minus
l_int|6
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|count
op_logical_and
id|buf
OL
id|buflim
)paren
(brace
id|c
op_assign
id|data
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
op_logical_and
id|c
op_eq
l_int|0
op_logical_and
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* compress protocol field */
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
id|c
)paren
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
id|c
comma
id|islcp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; * Remember where we are up to in this packet.&n;&t;&t; */
id|ap-&gt;olim
op_assign
id|buf
suffix:semicolon
id|ap-&gt;tpkt_pos
op_assign
id|i
suffix:semicolon
id|ap-&gt;tfcs
op_assign
id|fcs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished the packet.  Add the FCS and flag.&n;&t; */
id|fcs
op_assign
op_complement
id|fcs
suffix:semicolon
id|c
op_assign
id|fcs
op_amp
l_int|0xff
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
id|c
comma
id|islcp
)paren
suffix:semicolon
id|c
op_assign
(paren
id|fcs
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
id|c
comma
id|islcp
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|PPP_FLAG
suffix:semicolon
id|ap-&gt;olim
op_assign
id|buf
suffix:semicolon
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Transmit-side routines.&n; */
multiline_comment|/*&n; * Send a packet to the peer over an async tty line.&n; * Returns 1 iff the packet was accepted.&n; * If the packet was not accepted, we will call ppp_output_wakeup&n; * at some later time.&n; */
r_static
r_int
DECL|function|ppp_async_send
id|ppp_async_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
id|ppp_async_push
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;busy
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* already full */
id|ap-&gt;tpkt
op_assign
id|skb
suffix:semicolon
id|ap-&gt;tpkt_pos
op_assign
l_int|0
suffix:semicolon
id|ppp_async_push
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Push as much data as possible out to the tty.&n; */
r_static
r_int
DECL|function|ppp_async_push
id|ppp_async_push
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_int
id|avail
comma
id|sent
comma
id|done
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ap-&gt;tty
suffix:semicolon
r_int
id|tty_stuffed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trylock_xmit_path
c_func
(paren
id|ap
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;busy
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;busy
)paren
)paren
id|tty_stuffed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_stuffed
op_logical_and
id|ap-&gt;optr
OL
id|ap-&gt;olim
)paren
(brace
id|avail
op_assign
id|ap-&gt;olim
op_minus
id|ap-&gt;optr
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|sent
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|ap-&gt;optr
comma
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
l_int|0
)paren
r_goto
id|flush
suffix:semicolon
multiline_comment|/* error, e.g. loss of CD */
id|ap-&gt;optr
op_add_assign
id|sent
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
id|avail
)paren
id|tty_stuffed
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;optr
op_eq
id|ap-&gt;olim
op_logical_and
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ppp_async_encode
c_func
(paren
id|ap
)paren
)paren
(brace
multiline_comment|/* finished processing ap-&gt;tpkt */
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ap-&gt;xq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|0
)paren
(brace
id|ap-&gt;tpkt
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;busy
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* haven&squot;t made any progress */
id|unlock_xmit_path
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;busy
)paren
op_logical_or
(paren
op_logical_neg
id|tty_stuffed
op_logical_and
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trylock_xmit_path
c_func
(paren
id|ap
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|done
suffix:semicolon
id|flush
suffix:colon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;busy
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|ap-&gt;optr
op_assign
id|ap-&gt;olim
suffix:semicolon
id|unlock_xmit_path
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush output from our internal buffers.&n; * Called for the TCFLSH ioctl.&n; */
r_static
r_void
DECL|function|ppp_async_flush_output
id|ppp_async_flush_output
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|flush_skb_queue
c_func
(paren
op_amp
id|ap-&gt;xq
)paren
suffix:semicolon
id|lock_xmit_path
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ap-&gt;optr
op_assign
id|ap-&gt;olim
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;busy
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|unlock_xmit_path
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_logical_and
id|ap-&gt;connected
)paren
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive-side routines.&n; */
multiline_comment|/* see how many ordinary chars there are at the start of buf */
r_static
r_inline
r_int
DECL|function|scan_ordinary
id|scan_ordinary
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|i
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|PPP_ESCAPE
op_logical_or
id|c
op_eq
id|PPP_FLAG
op_logical_or
(paren
id|c
OL
l_int|0x20
op_logical_and
(paren
id|ap-&gt;raccm
op_amp
(paren
l_int|1
op_lshift
id|c
)paren
)paren
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* called when a flag is seen - do end-of-packet processing */
r_static
r_inline
r_void
DECL|function|process_input_packet
id|process_input_packet
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|len
comma
id|fcs
suffix:semicolon
r_int
id|code
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|ap-&gt;rpkt
suffix:semicolon
id|ap-&gt;rpkt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ap-&gt;state
op_amp
(paren
id|SC_TOSS
op_or
id|SC_ESCAPE
)paren
)paren
op_logical_or
id|skb
op_eq
l_int|0
)paren
(brace
id|ap-&gt;state
op_and_assign
op_complement
(paren
id|SC_TOSS
op_or
id|SC_ESCAPE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check the FCS */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|3
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* too short */
id|fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
op_decrement
id|len
)paren
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fcs
op_ne
id|PPP_GOODFCS
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* bad FCS */
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* check for address/control and protocol compression */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|PPP_ALLSTATIONS
op_logical_and
id|p
(braket
l_int|1
)braket
op_eq
id|PPP_UI
)paren
(brace
multiline_comment|/* chop off address/control */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|3
)paren
r_goto
id|err
suffix:semicolon
id|p
op_assign
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
(brace
multiline_comment|/* protocol is compressed */
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|2
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* all OK, give it to the generic layer or queue it */
r_if
c_cond
(paren
id|ap-&gt;connected
)paren
(brace
id|ppp_input
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|ap-&gt;rq
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* drop old frames if queue too long */
r_while
c_loop
(paren
id|ap-&gt;rq.qlen
OG
id|PPPASYNC_MAX_RQLEN
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ap-&gt;rq
)paren
)paren
op_ne
l_int|0
)paren
id|kfree
c_func
(paren
id|skb
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ap-&gt;rwait
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|err
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;connected
)paren
id|ppp_input_error
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|code
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|input_error
id|input_error
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_int
id|code
)paren
(brace
id|ap-&gt;state
op_or_assign
id|SC_TOSS
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;connected
)paren
id|ppp_input_error
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|code
)paren
suffix:semicolon
)brace
multiline_comment|/* called when the tty driver has data for us. */
r_static
r_void
DECL|function|ppp_async_input
id|ppp_async_input
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|c
comma
id|i
comma
id|j
comma
id|n
comma
id|s
comma
id|f
suffix:semicolon
r_int
r_char
op_star
id|sp
suffix:semicolon
multiline_comment|/* update bits used for 8-bit cleanness detection */
r_if
c_cond
(paren
op_complement
id|ap-&gt;rbits
op_amp
id|SC_RCV_BITS
)paren
(brace
id|s
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
op_logical_and
id|flags
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|s
op_or_assign
(paren
id|c
op_amp
l_int|0x80
)paren
ques
c_cond
id|SC_RCV_B7_1
suffix:colon
id|SC_RCV_B7_0
suffix:semicolon
id|c
op_assign
(paren
(paren
id|c
op_rshift
l_int|4
)paren
op_xor
id|c
)paren
op_amp
l_int|0xf
suffix:semicolon
id|s
op_or_assign
(paren
l_int|0x6996
op_amp
(paren
l_int|1
op_lshift
id|c
)paren
)paren
ques
c_cond
id|SC_RCV_ODDP
suffix:colon
id|SC_RCV_EVNP
suffix:semicolon
)brace
id|ap-&gt;rbits
op_or_assign
id|s
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/* scan through and see how many chars we can do in bulk */
r_if
c_cond
(paren
(paren
id|ap-&gt;state
op_amp
id|SC_ESCAPE
)paren
op_logical_and
id|buf
(braket
l_int|0
)braket
op_eq
id|PPP_ESCAPE
)paren
id|n
op_assign
l_int|1
suffix:semicolon
r_else
id|n
op_assign
id|scan_ordinary
c_func
(paren
id|ap
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|f
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
op_logical_and
(paren
id|ap-&gt;state
op_amp
id|SC_TOSS
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check the flags to see if any char had an error */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
(paren
id|f
op_assign
id|flags
(braket
id|j
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f
op_ne
l_int|0
)paren
(brace
multiline_comment|/* start tossing */
id|input_error
c_func
(paren
id|ap
comma
id|f
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
OG
l_int|0
op_logical_and
(paren
id|ap-&gt;state
op_amp
id|SC_TOSS
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* stuff the chars in the skb */
id|skb
op_assign
id|ap-&gt;rpkt
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
(brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|ap-&gt;mru
op_plus
id|PPP_HDRLEN
op_plus
l_int|2
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Try to get the payload 4-byte aligned */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_ne
id|PPP_ALLSTATIONS
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
suffix:semicolon
id|ap-&gt;rpkt
op_assign
id|skb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OG
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
(brace
multiline_comment|/* packet overflowed MRU */
id|input_error
c_func
(paren
id|ap
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|n
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sp
comma
id|buf
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;state
op_amp
id|SC_ESCAPE
)paren
(brace
id|sp
(braket
l_int|0
)braket
op_xor_assign
l_int|0x20
suffix:semicolon
id|ap-&gt;state
op_and_assign
op_complement
id|SC_ESCAPE
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|n
op_ge
id|count
)paren
r_break
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|PPP_FLAG
)paren
(brace
id|process_input_packet
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
id|PPP_ESCAPE
)paren
(brace
id|ap-&gt;state
op_or_assign
id|SC_ESCAPE
suffix:semicolon
)brace
multiline_comment|/* otherwise it&squot;s a char in the recv ACCM */
op_increment
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
)paren
id|flags
op_add_assign
id|n
suffix:semicolon
id|count
op_sub_assign
id|n
suffix:semicolon
)brace
r_return
suffix:semicolon
id|nomem
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPPasync: no memory (input pkt)&bslash;n&quot;
)paren
suffix:semicolon
id|input_error
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|ppp_async_init
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|tty_register_ldisc
c_func
(paren
id|N_PPP
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;failed to unregister PPP line discipline&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
