multiline_comment|/*  depca.c: A DIGITAL DEPCA  &amp; EtherWORKS ethernet driver for linux.&n;&n;    Written 1994, 1995 by David C. Davies.&n;&n;&n;                      Copyright 1994 David C. Davies&n;&t;&t;                   and &n;&t;&t;&t; United States Government&n;&t; (as represented by the Director, National Security Agency).  &n;&n;               Copyright 1995  Digital Equipment Corporation.&n;&n;&n;    This software may be used and distributed according to the terms of&n;    the GNU Public License, incorporated herein by reference.&n;&n;    This driver is written for the Digital Equipment Corporation series&n;    of DEPCA and EtherWORKS ethernet cards:&n;&n;        DEPCA       (the original)&n;    &t;DE100&n;    &t;DE101&n;&t;DE200 Turbo&n;&t;DE201 Turbo&n;&t;DE202 Turbo (TP BNC)&n;&t;DE210&n;&t;DE422       (EISA)&n;&n;    The  driver has been tested on DE100, DE200 and DE202 cards  in  a&n;    relatively busy network. The DE422 has been tested a little.&n;&n;    This  driver will NOT work   for the DE203,  DE204  and DE205 series  of&n;    cards,  since they have  a  new custom ASIC in   place of the AMD  LANCE&n;    chip.  See the &squot;ewrk3.c&squot;   driver in the  Linux  source tree for running&n;    those cards.&n;&n;    I have benchmarked the driver with a  DE100 at 595kB/s to (542kB/s from)&n;    a DECstation 5000/200.&n;&n;    The author may be reached at davies@maniac.ultranet.com&n;&n;    =========================================================================&n;&n;    The  driver was originally based  on   the &squot;lance.c&squot; driver from  Donald&n;    Becker   which  is included with  the  standard  driver distribution for&n;    linux.  V0.4  is  a complete  re-write  with only  the kernel  interface&n;    remaining from the original code.&n;&n;    1) Lance.c code in /linux/drivers/net/&n;    2) &quot;Ethernet/IEEE 802.3 Family. 1992 World Network Data Book/Handbook&quot;,&n;       AMD, 1992 [(800) 222-9323].&n;    3) &quot;Am79C90 CMOS Local Area Network Controller for Ethernet (C-LANCE)&quot;,&n;       AMD, Pub. #17881, May 1993.&n;    4) &quot;Am79C960 PCnet-ISA(tm), Single-Chip Ethernet Controller for ISA&quot;,&n;       AMD, Pub. #16907, May 1992&n;    5) &quot;DEC EtherWORKS LC Ethernet Controller Owners Manual&quot;,&n;       Digital Equipment corporation, 1990, Pub. #EK-DE100-OM.003&n;    6) &quot;DEC EtherWORKS Turbo Ethernet Controller Owners Manual&quot;,&n;       Digital Equipment corporation, 1990, Pub. #EK-DE200-OM.003&n;    7) &quot;DEPCA Hardware Reference Manual&quot;, Pub. #EK-DEPCA-PR&n;       Digital Equipment Corporation, 1989&n;    8) &quot;DEC EtherWORKS Turbo_(TP BNC) Ethernet Controller Owners Manual&quot;,&n;       Digital Equipment corporation, 1991, Pub. #EK-DE202-OM.001&n;    &n;&n;    Peter Bauer&squot;s depca.c (V0.5) was referred to when debugging V0.1 of this&n;    driver.&n;&n;    The original DEPCA  card requires that the  ethernet ROM address counter&n;    be enabled to count and has an 8 bit NICSR.  The ROM counter enabling is&n;    only  done when a  0x08 is read as the  first address octet (to minimise&n;    the chances  of writing over some  other hardware&squot;s  I/O register).  The&n;    NICSR accesses   have been changed  to  byte accesses  for all the cards&n;    supported by this driver, since there is only one  useful bit in the MSB&n;    (remote boot timeout) and it  is not used.  Also, there  is a maximum of&n;    only 48kB network  RAM for this  card.  My thanks  to Torbjorn Lindh for&n;    help debugging all this (and holding my feet to  the fire until I got it&n;    right).&n;&n;    The DE200  series  boards have  on-board 64kB  RAM for  use  as a shared&n;    memory network  buffer. Only the DE100  cards make use  of a  2kB buffer&n;    mode which has not  been implemented in  this driver (only the 32kB  and&n;    64kB modes are supported [16kB/48kB for the original DEPCA]).&n;&n;    At the most only 2 DEPCA cards can  be supported on  the ISA bus because&n;    there is only provision  for two I/O base addresses  on each card (0x300&n;    and 0x200). The I/O address is detected by searching for a byte sequence&n;    in the Ethernet station address PROM at the expected I/O address for the&n;    Ethernet  PROM.   The shared memory  base   address  is &squot;autoprobed&squot;  by&n;    looking  for the self  test PROM  and detecting the  card name.   When a&n;    second  DEPCA is  detected,  information  is   placed in the   base_addr&n;    variable of the  next device structure (which  is created if necessary),&n;    thus  enabling ethif_probe  initialization  for the device.  More than 2&n;    EISA cards can  be  supported, but  care will  be  needed assigning  the&n;    shared memory to ensure that each slot has the  correct IRQ, I/O address&n;    and shared memory address assigned.&n;&n;    ************************************************************************&n;&n;    NOTE: If you are using two  ISA DEPCAs, it is  important that you assign&n;    the base memory addresses correctly.   The  driver autoprobes I/O  0x300&n;    then 0x200.  The  base memory address for  the first device must be less&n;    than that of the second so that the auto probe will correctly assign the&n;    I/O and memory addresses on the same card.  I can&squot;t think of a way to do&n;    this unambiguously at the moment, since there is nothing on the cards to&n;    tie I/O and memory information together.&n;&n;    I am unable  to  test  2 cards   together for now,    so this  code   is&n;    unchecked. All reports, good or bad, are welcome.&n;&n;    ************************************************************************&n;&n;    The board IRQ   setting must be  at an  unused IRQ which  is auto-probed&n;    using Donald Becker&squot;s autoprobe routines. DEPCA and DE100 board IRQs are&n;    {2,3,4,5,7}, whereas the  DE200 is at {5,9,10,11,15}.  Note that IRQ2 is&n;    really IRQ9 in machines with 16 IRQ lines.&n;&n;    No 16MB memory  limitation should exist with this  driver as DMA is  not&n;    used and the common memory area is in low memory on the network card (my&n;    current system has 20MB and I&squot;ve not had problems yet).&n;&n;    The ability to load this driver as a loadable module has been added. To&n;    utilise this ability, you have to do &lt;8 things:&n;&n;    0) have a copy of the loadable modules code installed on your system.&n;    1) copy depca.c from the  /linux/drivers/net directory to your favourite&n;    temporary directory.&n;    2) if you wish, edit the  source code near  line 1530 to reflect the I/O&n;    address and IRQ you&squot;re using (see also 5).&n;    3) compile  depca.c, but include -DMODULE in  the command line to ensure&n;    that the correct bits are compiled (see end of source code).&n;    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a&n;    kernel with the depca configuration turned off and reboot.&n;    5) insmod depca.o [irq=7] [io=0x200] [mem=0xd0000] [adapter_name=DE100]&n;       [Alan Cox: Changed the code to allow command line irq/io assignments]&n;       [Dave Davies: Changed the code to allow command line mem/name&n;                                                                assignments]&n;    6) run the net startup bits for your eth?? interface manually &n;    (usually /etc/rc.inet[12] at boot time). &n;    7) enjoy!&n;&n;    Note that autoprobing is not allowed in loadable modules - the system is&n;    already up and running and you&squot;re messing with interrupts.&n;&n;    To unload a module, turn off the associated interface &n;    &squot;ifconfig eth?? down&squot; then &squot;rmmod depca&squot;.&n;&n;    To assign a base memory address for the shared memory  when running as a&n;    loadable module, see 5 above.  To include the adapter  name (if you have&n;    no PROM  but know the card name)  also see 5  above. Note that this last&n;    option  will not work  with kernel  built-in  depca&squot;s. &n;&n;    The shared memory assignment for a loadable module  makes sense to avoid&n;    the &squot;memory autoprobe&squot; picking the wrong shared memory  (for the case of&n;    2 depca&squot;s in a PC).&n;&n;    ************************************************************************&n;    Support for MCA EtherWORKS cards added 11-3-98.&n;    Verified to work with up to 2 DE212 cards in a system (although not&n;      fully stress-tested).  &n;&n;    Currently known bugs/limitations:&n;&n;    Note:  with the MCA stuff as a module, it trusts the MCA configuration,&n;           not the command line for IRQ and memory address.  You can&n;           specify them if you want, but it will throw your values out.&n;           You still have to pass the IO address it was configured as&n;           though.&n;&n;    ************************************************************************&n;    TO DO:&n;    ------&n;&n;&n;    Revision History&n;    ----------------&n;&n;    Version   Date        Description&n;  &n;      0.1     25-jan-94   Initial writing.&n;      0.2     27-jan-94   Added LANCE TX hardware buffer chaining.&n;      0.3      1-feb-94   Added multiple DEPCA support.&n;      0.31     4-feb-94   Added DE202 recognition.&n;      0.32    19-feb-94   Tidy up. Improve multi-DEPCA support.&n;      0.33    25-feb-94   Fix DEPCA ethernet ROM counter enable.&n;                          Add jabber packet fix from murf@perftech.com&n;&t;&t;&t;  and becker@super.org&n;      0.34     7-mar-94   Fix DEPCA max network memory RAM &amp; NICSR access.&n;      0.35     8-mar-94   Added DE201 recognition. Tidied up.&n;      0.351   30-apr-94   Added EISA support. Added DE422 recognition.&n;      0.36    16-may-94   DE422 fix released.&n;      0.37    22-jul-94   Added MODULE support&n;      0.38    15-aug-94   Added DBR ROM switch in depca_close(). &n;                          Multi DEPCA bug fix.&n;      0.38axp 15-sep-94   Special version for Alpha AXP Linux V1.0.&n;      0.381   12-dec-94   Added DE101 recognition, fix multicast bug.&n;      0.382    9-feb-95   Fix recognition bug reported by &lt;bkm@star.rl.ac.uk&gt;.&n;      0.383   22-feb-95   Fix for conflict with VESA SCSI reported by&n;                          &lt;stromain@alf.dec.com&gt;&n;      0.384   17-mar-95   Fix a ring full bug reported by &lt;bkm@star.rl.ac.uk&gt;&n;      0.385    3-apr-95   Fix a recognition bug reported by &n;                                                &lt;ryan.niemi@lastfrontier.com&gt;&n;      0.386   21-apr-95   Fix the last fix...sorry, must be galloping senility&n;      0.40    25-May-95   Rewrite for portability &amp; updated.&n;                          ALPHA support from &lt;jestabro@amt.tay1.dec.com&gt;&n;      0.41    26-Jun-95   Added verify_area() calls in depca_ioctl() from&n;                          suggestion by &lt;heiko@colossus.escape.de&gt;&n;      0.42    27-Dec-95   Add &squot;mem&squot; shared memory assignment for loadable &n;                          modules.&n;                          Add &squot;adapter_name&squot; for loadable modules when no PROM.&n;&t;&t;&t;  Both above from a suggestion by &n;&t;&t;&t;  &lt;pchen@woodruffs121.residence.gatech.edu&gt;.&n;&t;&t;&t;  Add new multicasting code.&n;      0.421   22-Apr-96&t;  Fix alloc_device() bug &lt;jari@markkus2.fimr.fi&gt;&n;      0.422   29-Apr-96&t;  Fix depca_hw_init() bug &lt;jari@markkus2.fimr.fi&gt;&n;      0.423    7-Jun-96   Fix module load bug &lt;kmg@barco.be&gt;&n;      0.43    16-Aug-96   Update alloc_device() to conform to de4x5.c&n;      0.44     1-Sep-97   Fix *_probe() to test check_region() first - bug&n;                           reported by &lt;mmogilvi@elbert.uccs.edu&gt;&n;      0.45     3-Nov-98   Added support for MCA EtherWORKS (DE210/DE212) cards&n;                           by &lt;tymm@computer.org&gt; &n;      0.451    5-Nov-98   Fixed mca stuff cuz I&squot;m a dummy. &lt;tymm@computer.org&gt;&n;      0.5     14-Nov-98   Re-spin for 2.1.x kernels.&n;      0.51    27-Jun-99   Correct received packet length for CRC from&n;                           report by &lt;worm@dkik.dk&gt;&n;      0.52    16-Oct-00   Fixes for 2.3 io memory accesses&n;                          Fix show-stopper (ints left masked) in depca_interrupt&n;&t;&t;&t;   by &lt;peterd@pnd-pc.demon.co.uk&gt;&n;&n;    =========================================================================&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;depca.c:v0.51 1999/6/27 davies@maniac.ultranet.com&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#ifdef CONFIG_MCA
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#endif
macro_line|#include &quot;depca.h&quot;
macro_line|#ifdef DEPCA_DEBUG
DECL|variable|depca_debug
r_static
r_int
id|depca_debug
op_assign
id|DEPCA_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|depca_debug
r_static
r_int
id|depca_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|macro|DEPCA_NDA
mdefine_line|#define DEPCA_NDA 0xffe0            /* No Device Address */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT (1*HZ)
multiline_comment|/*&n;** Ethernet PROM defines&n;*/
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
DECL|macro|ETH_PROM_SIG
mdefine_line|#define ETH_PROM_SIG    0xAA5500FFUL
multiline_comment|/*&n;** Set the number of Tx and Rx buffers. Ensure that the memory requested&n;** here is &lt;= to the amount of shared memory set up by the board switches.&n;** The number of descriptors MUST BE A POWER OF 2.&n;**&n;** total_memory = NUM_RX_DESC*(8+RX_BUFF_SZ) + NUM_TX_DESC*(8+TX_BUFF_SZ)&n;*/
DECL|macro|NUM_RX_DESC
mdefine_line|#define NUM_RX_DESC     8               /* Number of RX descriptors */
DECL|macro|NUM_TX_DESC
mdefine_line|#define NUM_TX_DESC     8               /* Number of TX descriptors */
DECL|macro|RX_BUFF_SZ
mdefine_line|#define RX_BUFF_SZ&t;1536            /* Buffer size for each Rx buffer */
DECL|macro|TX_BUFF_SZ
mdefine_line|#define TX_BUFF_SZ&t;1536            /* Buffer size for each Tx buffer */
DECL|macro|CRC_POLYNOMIAL_BE
mdefine_line|#define CRC_POLYNOMIAL_BE 0x04c11db7UL  /* Ethernet CRC, big endian */
DECL|macro|CRC_POLYNOMIAL_LE
mdefine_line|#define CRC_POLYNOMIAL_LE 0xedb88320UL  /* Ethernet CRC, little endian */
multiline_comment|/*&n;** EISA bus defines&n;*/
DECL|macro|DEPCA_EISA_IO_PORTS
mdefine_line|#define DEPCA_EISA_IO_PORTS 0x0c00       /* I/O port base address, slot 0 */
DECL|macro|MAX_EISA_SLOTS
mdefine_line|#define MAX_EISA_SLOTS 16
DECL|macro|EISA_SLOT_INC
mdefine_line|#define EISA_SLOT_INC 0x1000
multiline_comment|/*&n;** ISA Bus defines&n;*/
DECL|macro|DEPCA_RAM_BASE_ADDRESSES
mdefine_line|#define DEPCA_RAM_BASE_ADDRESSES {0xc0000,0xd0000,0xe0000,0x00000}
DECL|macro|DEPCA_IO_PORTS
mdefine_line|#define DEPCA_IO_PORTS {0x300, 0x200, 0}
DECL|macro|DEPCA_TOTAL_SIZE
mdefine_line|#define DEPCA_TOTAL_SIZE 0x10
DECL|variable|mem_chkd
r_static
r_int
id|mem_chkd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;** Adapter ID for the MCA EtherWORKS DE210/212 adapter&n;*/
DECL|macro|DE212_ID
mdefine_line|#define DE212_ID 0x6def
multiline_comment|/*&n;** Name &lt;-&gt; Adapter mapping&n;*/
DECL|macro|DEPCA_SIGNATURE
mdefine_line|#define DEPCA_SIGNATURE {&quot;DEPCA&quot;,&bslash;&n;&t;&t;&t; &quot;DE100&quot;,&quot;DE101&quot;,&bslash;&n;                         &quot;DE200&quot;,&quot;DE201&quot;,&quot;DE202&quot;,&bslash;&n;&t;&t;&t; &quot;DE210&quot;,&quot;DE212&quot;,&bslash;&n;                         &quot;DE422&quot;,&bslash;&n;                         &quot;&quot;}
r_static
r_enum
(brace
DECL|enumerator|DEPCA
DECL|enumerator|de100
DECL|enumerator|de101
DECL|enumerator|de200
DECL|enumerator|de201
DECL|enumerator|de202
DECL|enumerator|de210
DECL|enumerator|de212
DECL|enumerator|de422
DECL|enumerator|unknown
id|DEPCA
comma
id|de100
comma
id|de101
comma
id|de200
comma
id|de201
comma
id|de202
comma
id|de210
comma
id|de212
comma
id|de422
comma
id|unknown
DECL|variable|adapter
)brace
id|adapter
suffix:semicolon
multiline_comment|/*&n;** Miscellaneous info...&n;*/
DECL|macro|DEPCA_STRLEN
mdefine_line|#define DEPCA_STRLEN 16
DECL|macro|MAX_NUM_DEPCAS
mdefine_line|#define MAX_NUM_DEPCAS 2
multiline_comment|/*&n;** Memory Alignment. Each descriptor is 4 longwords long. To force a&n;** particular alignment on the TX descriptor, adjust DESC_SKIP_LEN and&n;** DESC_ALIGN. ALIGN aligns the start address of the private memory area&n;** and hence the RX descriptor ring&squot;s first entry. &n;*/
DECL|macro|ALIGN4
mdefine_line|#define ALIGN4      ((u_long)4 - 1)       /* 1 longword align */
DECL|macro|ALIGN8
mdefine_line|#define ALIGN8      ((u_long)8 - 1)       /* 2 longword (quadword) align */
DECL|macro|ALIGN
mdefine_line|#define ALIGN         ALIGN8              /* Keep the LANCE happy... */
multiline_comment|/*&n;** The DEPCA Rx and Tx ring descriptors. &n;*/
DECL|struct|depca_rx_desc
r_struct
id|depca_rx_desc
(brace
DECL|member|base
r_volatile
id|s32
id|base
suffix:semicolon
DECL|member|buf_length
id|s16
id|buf_length
suffix:semicolon
multiline_comment|/* This length is negative 2&squot;s complement! */
DECL|member|msg_length
id|s16
id|msg_length
suffix:semicolon
multiline_comment|/* This length is &quot;normal&quot;. */
)brace
suffix:semicolon
DECL|struct|depca_tx_desc
r_struct
id|depca_tx_desc
(brace
DECL|member|base
r_volatile
id|s32
id|base
suffix:semicolon
DECL|member|length
id|s16
id|length
suffix:semicolon
multiline_comment|/* This length is negative 2&squot;s complement! */
DECL|member|misc
id|s16
id|misc
suffix:semicolon
multiline_comment|/* Errors and TDR info */
)brace
suffix:semicolon
DECL|macro|LA_MASK
mdefine_line|#define LA_MASK 0x0000ffff      /* LANCE address mask for mapping network RAM&n;&t;&t;&t;&t;   to LANCE memory address space */
multiline_comment|/*&n;** The Lance initialization block, described in databook, in common memory.&n;*/
DECL|struct|depca_init
r_struct
id|depca_init
(brace
DECL|member|mode
id|u16
id|mode
suffix:semicolon
multiline_comment|/* Mode register */
DECL|member|phys_addr
id|u8
id|phys_addr
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* Physical ethernet address */
DECL|member|mcast_table
id|u8
id|mcast_table
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Multicast Hash Table. */
DECL|member|rx_ring
id|u32
id|rx_ring
suffix:semicolon
multiline_comment|/* Rx ring base pointer &amp; ring length */
DECL|member|tx_ring
id|u32
id|tx_ring
suffix:semicolon
multiline_comment|/* Tx ring base pointer &amp; ring length */
)brace
suffix:semicolon
DECL|macro|DEPCA_PKT_STAT_SZ
mdefine_line|#define DEPCA_PKT_STAT_SZ 16
DECL|macro|DEPCA_PKT_BIN_SZ
mdefine_line|#define DEPCA_PKT_BIN_SZ  128                /* Should be &gt;=100 unless you&n;                                                increase DEPCA_PKT_STAT_SZ */
DECL|struct|depca_private
r_struct
id|depca_private
(brace
DECL|member|devname
r_char
id|devname
(braket
id|DEPCA_STRLEN
)braket
suffix:semicolon
multiline_comment|/* Device Product String                  */
DECL|member|adapter_name
r_char
id|adapter_name
(braket
id|DEPCA_STRLEN
)braket
suffix:semicolon
multiline_comment|/* /proc/ioports string                  */
DECL|member|adapter
r_char
id|adapter
suffix:semicolon
multiline_comment|/* Adapter type                           */
DECL|member|mca_slot
r_char
id|mca_slot
suffix:semicolon
multiline_comment|/* MCA slot, if MCA else -1               */
DECL|member|init_block
r_struct
id|depca_init
id|init_block
suffix:semicolon
multiline_comment|/* Shadow Initialization block            */
multiline_comment|/* CPU address space fields */
DECL|member|rx_ring
r_struct
id|depca_rx_desc
op_star
id|rx_ring
suffix:semicolon
multiline_comment|/* Pointer to start of RX descriptor ring */
DECL|member|tx_ring
r_struct
id|depca_tx_desc
op_star
id|tx_ring
suffix:semicolon
multiline_comment|/* Pointer to start of TX descriptor ring */
DECL|member|rx_buff
r_void
op_star
id|rx_buff
(braket
id|NUM_RX_DESC
)braket
suffix:semicolon
multiline_comment|/* CPU virt address of sh&squot;d memory buffs  */
DECL|member|tx_buff
r_void
op_star
id|tx_buff
(braket
id|NUM_TX_DESC
)braket
suffix:semicolon
multiline_comment|/* CPU virt address of sh&squot;d memory buffs  */
DECL|member|sh_mem
r_void
op_star
id|sh_mem
suffix:semicolon
multiline_comment|/* CPU mapped virt address of device RAM  */
multiline_comment|/* Device address space fields */
DECL|member|device_ram_start
id|u_long
id|device_ram_start
suffix:semicolon
multiline_comment|/* Start of RAM in device addr space      */
multiline_comment|/* Offsets used in both address spaces */
DECL|member|rx_ring_offset
id|u_long
id|rx_ring_offset
suffix:semicolon
multiline_comment|/* Offset from start of RAM to rx_ring    */
DECL|member|tx_ring_offset
id|u_long
id|tx_ring_offset
suffix:semicolon
multiline_comment|/* Offset from start of RAM to tx_ring    */
DECL|member|buffs_offset
id|u_long
id|buffs_offset
suffix:semicolon
multiline_comment|/* LANCE Rx and Tx buffers start address. */
multiline_comment|/* Kernel-only (not device) fields */
DECL|member|rx_new
DECL|member|tx_new
r_int
id|rx_new
comma
id|tx_new
suffix:semicolon
multiline_comment|/* The next free ring entry               */
DECL|member|rx_old
DECL|member|tx_old
r_int
id|rx_old
comma
id|tx_old
suffix:semicolon
multiline_comment|/* The ring entries to be free()ed.       */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
r_struct
(brace
multiline_comment|/* Private stats counters                 */
DECL|member|bins
id|u32
id|bins
(braket
id|DEPCA_PKT_STAT_SZ
)braket
suffix:semicolon
DECL|member|unicast
id|u32
id|unicast
suffix:semicolon
DECL|member|multicast
id|u32
id|multicast
suffix:semicolon
DECL|member|broadcast
id|u32
id|broadcast
suffix:semicolon
DECL|member|excessive_collisions
id|u32
id|excessive_collisions
suffix:semicolon
DECL|member|tx_underruns
id|u32
id|tx_underruns
suffix:semicolon
DECL|member|excessive_underruns
id|u32
id|excessive_underruns
suffix:semicolon
DECL|member|pktStats
)brace
id|pktStats
suffix:semicolon
DECL|member|txRingMask
r_int
id|txRingMask
suffix:semicolon
multiline_comment|/* TX ring mask                           */
DECL|member|rxRingMask
r_int
id|rxRingMask
suffix:semicolon
multiline_comment|/* RX ring mask                           */
DECL|member|rx_rlen
id|s32
id|rx_rlen
suffix:semicolon
multiline_comment|/* log2(rxRingMask+1) for the descriptors */
DECL|member|tx_rlen
id|s32
id|tx_rlen
suffix:semicolon
multiline_comment|/* log2(txRingMask+1) for the descriptors */
)brace
suffix:semicolon
multiline_comment|/*&n;** The transmit ring full condition is described by the tx_old and tx_new&n;** pointers by:&n;**    tx_old            = tx_new    Empty ring&n;**    tx_old            = tx_new+1  Full ring&n;**    tx_old+txRingMask = tx_new    Full ring  (wrapped condition)&n;*/
DECL|macro|TX_BUFFS_AVAIL
mdefine_line|#define TX_BUFFS_AVAIL ((lp-&gt;tx_old&lt;=lp-&gt;tx_new)?&bslash;&n;&t;&t;&t; lp-&gt;tx_old+lp-&gt;txRingMask-lp-&gt;tx_new:&bslash;&n;                         lp-&gt;tx_old               -lp-&gt;tx_new-1)
multiline_comment|/*&n;** Public Functions&n;*/
r_static
r_int
id|depca_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|depca_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|depca_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|depca_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|depca_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;** Private functions&n;*/
r_static
r_int
id|depca_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
comma
r_int
id|mca_slot
)paren
suffix:semicolon
r_static
r_void
id|depca_init_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|LoadCSRs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|InitRestartDepca
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|DepcaSignature
c_func
(paren
r_char
op_star
id|name
comma
id|u_long
id|paddr
)paren
suffix:semicolon
r_static
r_int
id|DevicePresent
c_func
(paren
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
suffix:semicolon
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MCA      
r_static
r_void
id|mca_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
macro_line|#endif
r_static
r_struct
id|net_device
op_star
id|alloc_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_int
id|depca_dev_index
c_func
(paren
r_char
op_star
id|s
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
suffix:semicolon
r_static
r_int
id|load_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|depca_dbg_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|autoprobed
DECL|variable|loading_module
r_static
r_int
id|autoprobed
op_assign
l_int|1
comma
id|loading_module
op_assign
l_int|1
suffix:semicolon
macro_line|# else
DECL|variable|__initdata
r_static
id|u_char
id|de1xx_irq
(braket
)braket
id|__initdata
op_assign
(brace
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
id|u_char
id|de2xx_irq
(braket
)braket
id|__initdata
op_assign
(brace
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
id|u_char
id|de422_irq
(braket
)braket
id|__initdata
op_assign
(brace
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|depca_irq
r_static
id|u_char
op_star
id|depca_irq
suffix:semicolon
DECL|variable|autoprobed
DECL|variable|loading_module
r_static
r_int
id|autoprobed
comma
id|loading_module
suffix:semicolon
macro_line|#endif /* MODULE */
DECL|variable|name
r_static
r_char
id|name
(braket
id|DEPCA_STRLEN
)braket
suffix:semicolon
DECL|variable|num_depcas
DECL|variable|num_eth
r_static
r_int
id|num_depcas
comma
id|num_eth
suffix:semicolon
DECL|variable|mem
r_static
r_int
id|mem
suffix:semicolon
multiline_comment|/* For loadable module assignment&n;                                              use insmod mem=0x????? .... */
DECL|variable|adapter_name
r_static
r_char
op_star
id|adapter_name
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* If no PROM when loadable module&n;&t;&t;&t;&t;&t;      use insmod adapter_name=DE??? ...&n;&t;&t;&t;&t;&t;   */
multiline_comment|/*&n;** Miscellaneous defines...&n;*/
DECL|macro|STOP_DEPCA
mdefine_line|#define STOP_DEPCA &bslash;&n;    outw(CSR0, DEPCA_ADDR);&bslash;&n;    outw(STOP, DEPCA_DATA)
r_int
id|__init
DECL|function|depca_probe
id|depca_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|tmp
op_assign
id|num_depcas
comma
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iobase
op_eq
l_int|0
)paren
op_logical_and
id|loading_module
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Autoprobing is not supported when loading a module based driver.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_MCA      
id|mca_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
macro_line|#endif
id|isa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
id|eisa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|num_depcas
)paren
op_logical_and
(paren
id|iobase
op_ne
l_int|0
)paren
op_logical_and
id|loading_module
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: depca_probe() cannot find device at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Walk the device list to check that at least one device&n;    ** initialised OK&n;    */
r_for
c_loop
(paren
suffix:semicolon
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|dev-&gt;next
op_ne
l_int|NULL
)paren
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iobase
op_eq
l_int|0
)paren
id|autoprobed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|depca_hw_init
id|depca_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
comma
r_int
id|mca_slot
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|offset
comma
id|netRAM
comma
id|mem_len
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|s16
id|nicsr
suffix:semicolon
id|u_long
id|mem_start
op_assign
l_int|0
comma
id|mem_base
(braket
)braket
op_assign
id|DEPCA_RAM_BASE_ADDRESSES
suffix:semicolon
id|STOP_DEPCA
suffix:semicolon
id|nicsr
op_assign
id|inb
c_func
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
id|nicsr
op_assign
(paren
(paren
id|nicsr
op_amp
op_complement
id|SHE
op_amp
op_complement
id|RBE
op_amp
op_complement
id|IEN
)paren
op_or
id|IM
)paren
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
op_ne
id|STOP
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_do
(brace
id|strcpy
c_func
(paren
id|name
comma
(paren
id|adapter_name
ques
c_cond
id|adapter_name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|mem_start
op_assign
(paren
id|mem
ques
c_cond
id|mem
op_amp
l_int|0xf0000
suffix:colon
id|mem_base
(braket
id|mem_chkd
op_increment
)braket
)paren
suffix:semicolon
id|DepcaSignature
c_func
(paren
id|name
comma
id|mem_start
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|mem
op_logical_and
id|mem_base
(braket
id|mem_chkd
)braket
op_logical_and
(paren
id|adapter
op_eq
id|unknown
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|adapter
op_eq
id|unknown
)paren
op_logical_or
op_logical_neg
id|mem_start
)paren
(brace
multiline_comment|/* DEPCA device not found */
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
r_if
c_cond
(paren
id|mca_slot
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at 0x%04lx (MCA slot %d)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|ioaddr
comma
id|mca_slot
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ioaddr
op_amp
l_int|0x0fff
)paren
op_eq
id|DEPCA_EISA_IO_PORTS
)paren
(brace
multiline_comment|/* EISA slot address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at 0x%04lx (EISA slot %d)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|ioaddr
comma
(paren
r_int
)paren
(paren
(paren
id|ioaddr
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ISA port address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at 0x%04lx&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|ioaddr
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, h/w address &quot;
)paren
suffix:semicolon
id|status
op_assign
id|get_hw_addr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet address */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      which has an Ethernet PROM CRC error.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Set up the maximum amount of network RAM(kB) */
id|netRAM
op_assign
(paren
(paren
id|adapter
op_ne
id|DEPCA
)paren
ques
c_cond
l_int|64
suffix:colon
l_int|48
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nicsr
op_amp
id|_128KB
)paren
op_logical_and
(paren
id|adapter
op_eq
id|de422
)paren
)paren
id|netRAM
op_assign
l_int|128
suffix:semicolon
id|offset
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Shared Memory Base Address */
r_if
c_cond
(paren
id|nicsr
op_amp
id|BUF
)paren
(brace
id|offset
op_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* 32kbyte RAM offset*/
id|nicsr
op_and_assign
op_complement
id|BS
suffix:semicolon
multiline_comment|/* DEPCA RAM in top 32k */
id|netRAM
op_sub_assign
l_int|32
suffix:semicolon
)brace
id|mem_start
op_add_assign
id|offset
suffix:semicolon
multiline_comment|/* (E)ISA start address */
r_if
c_cond
(paren
(paren
id|mem_len
op_assign
(paren
id|NUM_RX_DESC
op_star
(paren
r_sizeof
(paren
r_struct
id|depca_rx_desc
)paren
op_plus
id|RX_BUFF_SZ
)paren
op_plus
id|NUM_TX_DESC
op_star
(paren
r_sizeof
(paren
r_struct
id|depca_tx_desc
)paren
op_plus
id|TX_BUFF_SZ
)paren
op_plus
r_sizeof
(paren
r_struct
id|depca_init
)paren
)paren
)paren
OG
(paren
id|netRAM
op_lshift
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;,&bslash;n       requests %dkB RAM: only %dkB is available!&bslash;n&quot;
comma
(paren
id|mem_len
op_rshift
l_int|10
)paren
comma
id|netRAM
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;,&bslash;n      has %dkB RAM at 0x%.5lx&quot;
comma
id|netRAM
comma
id|mem_start
)paren
suffix:semicolon
multiline_comment|/* Enable the shadow RAM. */
r_if
c_cond
(paren
id|adapter
op_ne
id|DEPCA
)paren
(brace
id|nicsr
op_or_assign
id|SHE
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
)brace
multiline_comment|/* Define the device private memory */
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|depca_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|depca_private
)paren
)paren
suffix:semicolon
id|lp-&gt;adapter
op_assign
id|adapter
suffix:semicolon
id|lp-&gt;mca_slot
op_assign
id|mca_slot
suffix:semicolon
id|lp-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|sprintf
c_func
(paren
id|lp-&gt;adapter_name
comma
l_string|&quot;%s (%s)&quot;
comma
id|name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|DEPCA_TOTAL_SIZE
comma
id|lp-&gt;adapter_name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;depca: I/O resource 0x%x @ 0x%lx busy&bslash;n&quot;
comma
id|DEPCA_TOTAL_SIZE
comma
id|ioaddr
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Initialisation Block */
id|lp-&gt;sh_mem
op_assign
id|ioremap
c_func
(paren
id|mem_start
comma
id|mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;sh_mem
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;depca: cannot remap ISA memory, aborting&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|lp-&gt;device_ram_start
op_assign
id|mem_start
op_amp
id|LA_MASK
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|depca_init
)paren
suffix:semicolon
multiline_comment|/* Tx &amp; Rx descriptors (aligned to a quadword boundary) */
id|offset
op_assign
(paren
id|offset
op_plus
id|ALIGN
)paren
op_amp
op_complement
id|ALIGN
suffix:semicolon
id|lp-&gt;rx_ring
op_assign
(paren
r_struct
id|depca_rx_desc
op_star
)paren
(paren
id|lp-&gt;sh_mem
op_plus
id|offset
)paren
suffix:semicolon
id|lp-&gt;rx_ring_offset
op_assign
id|offset
suffix:semicolon
id|offset
op_add_assign
(paren
r_sizeof
(paren
r_struct
id|depca_rx_desc
)paren
op_star
id|NUM_RX_DESC
)paren
suffix:semicolon
id|lp-&gt;tx_ring
op_assign
(paren
r_struct
id|depca_tx_desc
op_star
)paren
(paren
id|lp-&gt;sh_mem
op_plus
id|offset
)paren
suffix:semicolon
id|lp-&gt;tx_ring_offset
op_assign
id|offset
suffix:semicolon
id|offset
op_add_assign
(paren
r_sizeof
(paren
r_struct
id|depca_tx_desc
)paren
op_star
id|NUM_TX_DESC
)paren
suffix:semicolon
id|lp-&gt;buffs_offset
op_assign
id|offset
suffix:semicolon
multiline_comment|/* Finish initialising the ring information. */
id|lp-&gt;rxRingMask
op_assign
id|NUM_RX_DESC
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;txRingMask
op_assign
id|NUM_TX_DESC
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Calculate Tx/Rx RLEN size for the descriptors. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|lp-&gt;rxRingMask
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|lp-&gt;rx_rlen
op_assign
(paren
id|s32
)paren
(paren
id|i
op_lshift
l_int|29
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|lp-&gt;txRingMask
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|lp-&gt;tx_rlen
op_assign
(paren
id|s32
)paren
(paren
id|i
op_lshift
l_int|29
)paren
suffix:semicolon
multiline_comment|/* Load the initialisation block */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Initialise the control and status registers */
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Enable DEPCA board interrupts for autoprobing */
id|nicsr
op_assign
(paren
(paren
id|nicsr
op_amp
op_complement
id|IM
)paren
op_or
id|IEN
)paren
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
multiline_comment|/* To auto-IRQ we enable the initialization-done and DMA err,&n;&t;   interrupts. For now we will always get a DMA error. */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
macro_line|#ifndef MODULE
r_int
r_char
id|irqnum
suffix:semicolon
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Assign the correct irq list */
r_switch
c_cond
(paren
id|lp-&gt;adapter
)paren
(brace
r_case
id|DEPCA
suffix:colon
r_case
id|de100
suffix:colon
r_case
id|de101
suffix:colon
id|depca_irq
op_assign
id|de1xx_irq
suffix:semicolon
r_break
suffix:semicolon
r_case
id|de200
suffix:colon
r_case
id|de201
suffix:colon
r_case
id|de202
suffix:colon
r_case
id|de210
suffix:colon
r_case
id|de212
suffix:colon
id|depca_irq
op_assign
id|de2xx_irq
suffix:semicolon
r_break
suffix:semicolon
r_case
id|de422
suffix:colon
id|depca_irq
op_assign
id|de422_irq
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Trigger an initialization just for the interrupt. */
id|outw
c_func
(paren
id|INEA
op_or
id|INIT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|irqnum
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irqnum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and failed to detect IRQ line.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|dev-&gt;irq
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|depca_irq
(braket
id|i
)braket
)paren
op_logical_and
(paren
op_logical_neg
id|dev-&gt;irq
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irqnum
op_eq
id|depca_irq
(braket
id|i
)braket
)paren
(brace
id|dev-&gt;irq
op_assign
id|irqnum
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; and uses IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; but incorrect IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; and assigned IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The DEPCA-specific entries in the device structure. */
id|dev-&gt;open
op_assign
op_amp
id|depca_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|depca_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|depca_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|depca_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|depca_ioctl
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|depca_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the generic field of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Incorrectly initialised hardware */
id|release_region
c_func
(paren
id|ioaddr
comma
id|DEPCA_TOTAL_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|depca_open
id|depca_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s16
id|nicsr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|STOP_DEPCA
suffix:semicolon
id|nicsr
op_assign
id|inb
c_func
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
multiline_comment|/* Make sure the shadow RAM is enabled */
r_if
c_cond
(paren
id|lp-&gt;adapter
op_ne
id|DEPCA
)paren
(brace
id|nicsr
op_or_assign
id|SHE
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
)brace
multiline_comment|/* Re-initialize the DEPCA... */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|depca_dbg_open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|depca_interrupt
comma
l_int|0
comma
id|lp-&gt;adapter_name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;depca_open(): Requested IRQ%d is busy&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Enable DEPCA board interrupts and turn off LED */
id|nicsr
op_assign
(paren
(paren
id|nicsr
op_amp
op_complement
id|IM
op_amp
op_complement
id|LED
)paren
op_or
id|IEN
)paren
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|status
op_assign
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CSR0: 0x%4.4x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;nicsr: 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|DEPCA_NICSR
)paren
)paren
suffix:semicolon
)brace
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Initialize the lance Rx and Tx descriptor rings. */
r_static
r_void
DECL|function|depca_init_ring
id|depca_init_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|u_long
id|offset
suffix:semicolon
multiline_comment|/* Lock out other processes whilst setting up the hardware */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;rx_new
op_assign
id|lp-&gt;tx_new
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_old
op_assign
id|lp-&gt;tx_old
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the base address and length of each buffer in the ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|lp-&gt;rxRingMask
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
id|lp-&gt;buffs_offset
op_plus
id|i
op_star
id|RX_BUFF_SZ
suffix:semicolon
id|writel
c_func
(paren
(paren
id|lp-&gt;device_ram_start
op_plus
id|offset
)paren
op_or
id|R_OWN
comma
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|writew
c_func
(paren
op_minus
id|RX_BUFF_SZ
comma
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf_length
)paren
suffix:semicolon
id|lp-&gt;rx_buff
(braket
id|i
)braket
op_assign
id|lp-&gt;sh_mem
op_plus
id|offset
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|lp-&gt;txRingMask
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
id|lp-&gt;buffs_offset
op_plus
(paren
id|i
op_plus
id|lp-&gt;rxRingMask
op_plus
l_int|1
)paren
op_star
id|TX_BUFF_SZ
suffix:semicolon
id|writel
c_func
(paren
(paren
id|lp-&gt;device_ram_start
op_plus
id|offset
)paren
op_amp
l_int|0x00ffffff
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|lp-&gt;tx_buff
(braket
id|i
)braket
op_assign
id|lp-&gt;sh_mem
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/* Set up the initialization block */
id|lp-&gt;init_block.rx_ring
op_assign
(paren
id|lp-&gt;device_ram_start
op_plus
id|lp-&gt;rx_ring_offset
)paren
op_or
id|lp-&gt;rx_rlen
suffix:semicolon
id|lp-&gt;init_block.tx_ring
op_assign
(paren
id|lp-&gt;device_ram_start
op_plus
id|lp-&gt;tx_ring_offset
)paren
op_or
id|lp-&gt;tx_rlen
suffix:semicolon
id|SetMulticastFilter
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;init_block.phys_addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|lp-&gt;init_block.mode
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Enable the Tx and Rx */
)brace
DECL|function|depca_tx_timeout
r_static
r_void
id|depca_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: transmit timed out, status %04x, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|STOP_DEPCA
suffix:semicolon
id|depca_init_ring
(paren
id|dev
)paren
suffix:semicolon
id|LoadCSRs
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
id|InitRestartDepca
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;** Writes a socket buffer to TX descriptor ring and starts transmission &n;*/
DECL|function|depca_start_xmit
r_static
r_int
id|depca_start_xmit
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Transmitter timeout, serious problems. */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|1
)paren
r_goto
id|out
suffix:semicolon
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TX_BUFFS_AVAIL
)paren
(brace
multiline_comment|/* Fill in a Tx ring entry */
id|status
op_assign
id|load_packet
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* Trigger an immediate send demand. */
id|outw
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|outw
(paren
id|INEA
op_or
id|TDMD
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TX_BUFFS_AVAIL
)paren
id|netif_start_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** The DEPCA interrupt handler. &n;*/
DECL|function|depca_interrupt
r_static
r_void
id|depca_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|depca_private
op_star
id|lp
suffix:semicolon
id|s16
id|csr0
comma
id|nicsr
suffix:semicolon
id|u_long
id|ioaddr
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;depca_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|spin_lock
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* mask the DEPCA board interrupts and turn on the LED */
id|nicsr
op_assign
id|inb
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
id|nicsr
op_or_assign
(paren
id|IM
op_or
id|LED
)paren
suffix:semicolon
id|outb
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|outw
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|csr0
op_assign
id|inw
(paren
id|DEPCA_DATA
)paren
suffix:semicolon
multiline_comment|/* Acknowledge all of the current interrupt sources ASAP. */
id|outw
(paren
id|csr0
op_amp
id|INTE
comma
id|DEPCA_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr0
op_amp
id|RINT
)paren
multiline_comment|/* Rx interrupt (packet arrived) */
id|depca_rx
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr0
op_amp
id|TINT
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|depca_tx
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Any resources available? */
r_if
c_cond
(paren
(paren
id|TX_BUFFS_AVAIL
op_ge
l_int|0
)paren
op_logical_and
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Unmask the DEPCA board interrupts and turn off the LED */
id|nicsr
op_assign
(paren
id|nicsr
op_amp
op_complement
id|IM
op_amp
op_complement
id|LED
)paren
suffix:semicolon
id|outb
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|depca_rx
id|depca_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|entry
suffix:semicolon
id|s32
id|status
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|lp-&gt;rx_new
suffix:semicolon
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
)paren
op_amp
id|R_OWN
)paren
suffix:semicolon
id|entry
op_assign
id|lp-&gt;rx_new
)paren
(brace
id|status
op_assign
id|readl
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
)paren
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_STP
)paren
(brace
multiline_comment|/* Remember start of frame */
id|lp-&gt;rx_old
op_assign
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|R_ENP
)paren
(brace
multiline_comment|/* Valid frame status */
r_if
c_cond
(paren
id|status
op_amp
id|R_ERR
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|status
op_amp
id|R_FRAM
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_OFLO
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_CRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_BUFF
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_int
id|len
comma
id|pkt_len
op_assign
id|readw
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|msg_length
)paren
op_minus
l_int|4
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 16 byte align the IP header */
id|buf
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
id|lp-&gt;rx_old
)paren
(brace
multiline_comment|/* Wrapped buffer */
id|len
op_assign
(paren
id|lp-&gt;rxRingMask
op_minus
id|lp-&gt;rx_old
op_plus
l_int|1
)paren
op_star
id|RX_BUFF_SZ
suffix:semicolon
id|memcpy_fromio
c_func
(paren
id|buf
comma
id|lp-&gt;rx_buff
(braket
id|lp-&gt;rx_old
)braket
comma
id|len
)paren
suffix:semicolon
id|memcpy_fromio
c_func
(paren
id|buf
op_plus
id|len
comma
id|lp-&gt;rx_buff
(braket
l_int|0
)braket
comma
id|pkt_len
op_minus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Linear buffer */
id|memcpy_fromio
c_func
(paren
id|buf
comma
id|lp-&gt;rx_buff
(braket
id|lp-&gt;rx_old
)braket
comma
id|pkt_len
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;  ** Notify the upper protocol layers that there is another &n;&t;  ** packet to handle&n;&t;  */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** Update stats&n;&t;  */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|DEPCA_PKT_STAT_SZ
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OL
(paren
id|i
op_star
id|DEPCA_PKT_BIN_SZ
)paren
)paren
(brace
id|lp-&gt;pktStats.bins
(braket
id|i
)braket
op_increment
suffix:semicolon
id|i
op_assign
id|DEPCA_PKT_STAT_SZ
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast/Broadcast */
r_if
c_cond
(paren
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|2
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|lp-&gt;pktStats.broadcast
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|2
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
)paren
(brace
id|lp-&gt;pktStats.unicast
op_increment
suffix:semicolon
)brace
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_increment
suffix:semicolon
multiline_comment|/* Duplicates stats.rx_packets */
r_if
c_cond
(paren
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Reset counters */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, deferring packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Really, deferred. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Change buffer ownership for this last frame, back to the adapter */
r_for
c_loop
(paren
suffix:semicolon
id|lp-&gt;rx_old
op_ne
id|entry
suffix:semicolon
id|lp-&gt;rx_old
op_assign
(paren
op_increment
id|lp-&gt;rx_old
)paren
op_amp
id|lp-&gt;rxRingMask
)paren
(brace
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_old
)braket
dot
id|base
)paren
op_or
id|R_OWN
comma
op_amp
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_old
)braket
dot
id|base
)paren
suffix:semicolon
)brace
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
)paren
op_or
id|R_OWN
comma
op_amp
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Update entry information&n;    */
id|lp-&gt;rx_new
op_assign
(paren
op_increment
id|lp-&gt;rx_new
)paren
op_amp
id|lp-&gt;rxRingMask
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Buffer sent - check for buffer errors.&n;*/
r_static
r_int
DECL|function|depca_tx
id|depca_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|s32
id|status
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|lp-&gt;tx_old
suffix:semicolon
id|entry
op_ne
id|lp-&gt;tx_new
suffix:semicolon
id|entry
op_assign
id|lp-&gt;tx_old
)paren
(brace
id|status
op_assign
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
)paren
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
multiline_comment|/* Packet not yet sent! */
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|T_ERR
)paren
(brace
multiline_comment|/* An error occurred. */
id|status
op_assign
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|misc
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TMD3_RTRY
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TMD3_LCAR
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TMD3_LCOL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TMD3_UFLO
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|TMD3_BUFF
op_or
id|TMD3_UFLO
)paren
)paren
(brace
multiline_comment|/* Trigger an immediate send demand. */
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|INEA
op_or
id|TDMD
comma
id|DEPCA_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
(paren
id|T_MORE
op_or
id|T_ONE
)paren
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
multiline_comment|/* Update all the pointers */
id|lp-&gt;tx_old
op_assign
(paren
op_increment
id|lp-&gt;tx_old
)paren
op_amp
id|lp-&gt;txRingMask
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|depca_close
id|depca_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|s16
id|nicsr
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;  ** We stop the DEPCA here -- it occasionally polls&n;  ** memory if we don&squot;t. &n;  */
id|outw
c_func
(paren
id|STOP
comma
id|DEPCA_DATA
)paren
suffix:semicolon
multiline_comment|/*&n;  ** Give back the ROM in case the user wants to go to DOS&n;  */
r_if
c_cond
(paren
id|lp-&gt;adapter
op_ne
id|DEPCA
)paren
(brace
id|nicsr
op_assign
id|inb
c_func
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
id|nicsr
op_and_assign
op_complement
id|SHE
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  ** Free the associated irq&n;  */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|LoadCSRs
r_static
r_void
id|LoadCSRs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|outw
c_func
(paren
id|CSR1
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* initialisation block address LSW */
id|outw
c_func
(paren
(paren
id|u16
)paren
id|lp-&gt;device_ram_start
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR2
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* initialisation block address MSW */
id|outw
c_func
(paren
(paren
id|u16
)paren
(paren
id|lp-&gt;device_ram_start
op_rshift
l_int|16
)paren
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR3
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* ALE control */
id|outw
c_func
(paren
id|ACON
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* Point back to CSR0 */
r_return
suffix:semicolon
)brace
DECL|function|InitRestartDepca
r_static
r_int
id|InitRestartDepca
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy the shadow init_block to shared memory */
id|memcpy_toio
c_func
(paren
id|lp-&gt;sh_mem
comma
op_amp
id|lp-&gt;init_block
comma
r_sizeof
(paren
r_struct
id|depca_init
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* point back to CSR0 */
id|outw
c_func
(paren
id|INIT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
multiline_comment|/* initialize DEPCA */
multiline_comment|/* wait for lance to complete initialisation */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|100
)paren
op_logical_and
op_logical_neg
(paren
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
op_amp
id|IDON
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|100
)paren
(brace
multiline_comment|/* clear IDON by writing a &quot;1&quot;, enable interrupts and start lance */
id|outw
c_func
(paren
id|IDON
op_or
id|INEA
op_or
id|STRT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DEPCA open after %d ticks, init block 0x%08lx csr0 %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
comma
id|virt_to_phys
c_func
(paren
id|lp-&gt;sh_mem
)paren
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DEPCA unopen after %d ticks, init block 0x%08lx csr0 %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
comma
id|virt_to_phys
c_func
(paren
id|lp-&gt;sh_mem
)paren
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_struct
id|net_device_stats
op_star
DECL|function|depca_get_stats
id|depca_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Null body since there is no framing error counter */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n;** Set or clear the multicast filter for this adaptor.&n;*/
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;tx_old
op_ne
id|lp-&gt;tx_new
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait for the ring to empty */
id|STOP_DEPCA
suffix:semicolon
multiline_comment|/* Temporarily stop the depca.  */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Initialize the descriptor rings */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Set promiscuous mode */
id|lp-&gt;init_block.mode
op_or_assign
id|PROM
suffix:semicolon
)brace
r_else
(brace
id|SetMulticastFilter
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;init_block.mode
op_and_assign
op_complement
id|PROM
suffix:semicolon
multiline_comment|/* Unset promiscuous mode */
)brace
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reload CSR3 */
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Resume normal operation. */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unlock the TX ring */
)brace
)brace
multiline_comment|/*&n;** Calculate the hash code and update the logical address filter&n;** from a list of ethernet multicast addresses.&n;** Big endian crc one liner is mine, all mine, ha ha ha ha!&n;** LANCE calculates its hash codes big endian.&n;*/
DECL|function|SetMulticastFilter
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_char
op_star
id|addrs
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|bit
comma
id|byte
suffix:semicolon
id|u16
id|hashcode
suffix:semicolon
id|s32
id|crc
comma
id|poly
op_assign
id|CRC_POLYNOMIAL_BE
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* Set all multicast bits */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;init_block.mcast_table
(braket
id|i
)braket
op_assign
(paren
r_char
)paren
l_int|0xff
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Clear the multicast table */
id|lp-&gt;init_block.mcast_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add multicast addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
id|addrs
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|addrs
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* multicast address? */
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* init CRC for each address */
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
id|byte
OL
id|ETH_ALEN
suffix:semicolon
id|byte
op_increment
)paren
(brace
multiline_comment|/* for each address byte */
multiline_comment|/* process each address bit */
r_for
c_loop
(paren
id|bit
op_assign
op_star
id|addrs
op_increment
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
comma
id|bit
op_rshift_assign
l_int|1
)paren
(brace
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|1
)paren
op_xor
(paren
(paren
(paren
(paren
id|crc
OL
l_int|0
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_xor
id|bit
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
id|poly
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|hashcode
op_assign
(paren
id|crc
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hashcode is 6 LSb of CRC ... */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|5
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* ... in reverse order. */
id|hashcode
op_assign
(paren
id|hashcode
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|crc
op_rshift_assign
l_int|1
)paren
op_amp
l_int|1
)paren
suffix:semicolon
)brace
id|byte
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-5] -&gt; byte in filter */
id|bit
op_assign
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* bit[0-2] -&gt; bit in byte */
id|lp-&gt;init_block.mcast_table
(braket
id|byte
)braket
op_or_assign
id|bit
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MCA
multiline_comment|/*&n;** Microchannel bus I/O device probe&n;*/
r_static
r_void
id|__init
DECL|function|mca_probe
id|mca_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
r_char
id|pos
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|where
suffix:semicolon
r_int
r_int
id|iobase
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    ** See if we&squot;ve been here before.&n;    */
r_if
c_cond
(paren
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
op_logical_or
(paren
id|ioaddr
op_logical_and
op_logical_neg
id|loading_module
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|MCA_bus
)paren
(brace
multiline_comment|/*&n;&t;** Search for the adapter.  If an address has been given, search &n;&t;** specifically for the card at that address.  Otherwise find the&n;&t;** first card in the system.&n;&t;*/
r_while
c_loop
(paren
(paren
id|dev
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|DE212_ID
comma
id|slot
)paren
)paren
op_ne
id|MCA_NOTFOUND
)paren
)paren
(brace
id|pos
(braket
l_int|0
)braket
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
id|pos
(braket
l_int|1
)braket
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    ** IO of card is handled by bits 1 and 2 of pos0.    &n;&t;    **&n;&t;    **    bit2 bit1    IO&n;&t;    **       0    0    0x2c00&n;&t;    **       0    1    0x2c10&n;&t;    **       1    0    0x2c20&n;&t;    **       1    1    0x2c30&n;&t;    */
id|where
op_assign
(paren
id|pos
(braket
l_int|0
)braket
op_amp
l_int|6
)paren
op_rshift
l_int|1
suffix:semicolon
id|iobase
op_assign
l_int|0x2c00
op_plus
(paren
l_int|0x10
op_star
id|where
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioaddr
)paren
op_logical_and
(paren
id|ioaddr
op_ne
id|iobase
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;** Card was found, but not at the right IO location. Continue &n;&t;&t;** scanning from the next MCA slot up for another card.&n;&t;&t;*/
id|slot
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    ** Found the adapter we were looking for. Now start setting it up.&n;&t;    ** &n;&t;    ** First work on decoding the IRQ.  It&squot;s stored in the lower 4 bits&n;&t;    ** of pos1.  Bits are as follows (from the ADF file):&n;&t;    **&n;&t;    **      Bits           &n;&t;    **   3   2   1   0    IRQ &n;&t;    **   --------------------&n;&t;    **   0   0   1   0     5&n;&t;    **   0   0   0   1     9&n;&t;    **   0   1   0   0    10&n;&t;    **   1   0   0   0    11&n;&t;    **/
id|where
op_assign
id|pos
(braket
l_int|1
)braket
op_amp
l_int|0x0f
suffix:semicolon
r_switch
c_cond
(paren
id|where
)paren
(brace
r_case
l_int|1
suffix:colon
id|irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|irq
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|irq
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: mca_probe IRQ error.  You should never get here (%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|where
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    ** Shared memory address of adapter is stored in bits 3-5 of pos0.&n;&t;    ** They are mapped as follows:&n;&t;    **&n;&t;    **    Bit&n;&t;    **   5  4  3       Memory Addresses&n;&t;    **   0  0  0       C0000-CFFFF (64K)&n;&t;    **   1  0  0       C8000-CFFFF (32K)&n;&t;    **   0  0  1       D0000-DFFFF (64K)&n;&t;    **   1  0  1       D8000-DFFFF (32K)&n;&t;    **   0  1  0       E0000-EFFFF (64K)&n;&t;    **   1  1  0       E8000-EFFFF (32K)&n;&t;    */
id|where
op_assign
(paren
id|pos
(braket
l_int|0
)braket
op_amp
l_int|0x18
)paren
op_rshift
l_int|3
suffix:semicolon
id|mem
op_assign
l_int|0xc0000
op_plus
(paren
id|where
op_star
l_int|0x10000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
(brace
id|mem
op_add_assign
l_int|0x8000
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    ** Get everything allocated and initialized...  (almost just&n;&t;    ** like the ISA and EISA probes)&n;&t;    */
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;** If the MCA configuration says the card should be here,&n;&t;&t;** it really should be here.&n;&t;&t;*/
id|printk
c_func
(paren
id|KERN_ERR
"&quot;"
op_mod
id|s
suffix:colon
id|MCA
id|reports
id|card
id|at
l_int|0
id|x
op_mod
id|lx
id|but
id|it
id|is
op_logical_neg
id|responding
dot
"&bslash;"
id|n
"&quot;"
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|iobase
comma
id|DEPCA_TOTAL_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|depca_hw_init
c_func
(paren
id|dev
comma
id|iobase
comma
id|slot
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;** Adapter initialized correctly:  Name it in&n;&t;&t;&t;** /proc/mca.&n;&t;&t;&t;*/
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_string|&quot;DE210/212 Ethernet Adapter&quot;
)paren
suffix:semicolon
id|mca_mark_as_used
c_func
(paren
id|slot
)paren
suffix:semicolon
id|num_depcas
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|autoprobed
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: region already allocated at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    ** If this is a probe by a module, return after setting up the&n;&t;    ** given card.&n;&t;    */
r_if
c_cond
(paren
id|ioaddr
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;    ** Set up to check the next slot and loop.&n;&t;    */
id|slot
op_increment
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;** ISA bus I/O device probe&n;*/
r_static
r_void
id|__init
DECL|function|isa_probe
id|isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
op_assign
id|num_depcas
comma
id|maxSlots
suffix:semicolon
id|s32
id|ports
(braket
)braket
op_assign
id|DEPCA_IO_PORTS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
r_return
suffix:semicolon
multiline_comment|/* Been here before ! */
r_if
c_cond
(paren
id|ioaddr
OG
l_int|0x400
)paren
r_return
suffix:semicolon
multiline_comment|/* EISA Address */
r_if
c_cond
(paren
id|i
op_ge
id|MAX_NUM_DEPCAS
)paren
r_return
suffix:semicolon
multiline_comment|/* Too many ISA adapters */
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|maxSlots
op_assign
id|MAX_NUM_DEPCAS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|ports
(braket
id|i
)braket
op_assign
id|ioaddr
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
op_logical_and
id|ports
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ports
(braket
id|i
)braket
comma
id|DEPCA_TOTAL_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|ports
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|ports
(braket
id|i
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|depca_hw_init
c_func
(paren
id|dev
comma
id|ports
(braket
id|i
)braket
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|num_depcas
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|autoprobed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: region already allocated at 0x%04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ports
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually&n;** the motherboard. Upto 15 EISA devices are supported.&n;*/
r_static
r_void
id|__init
DECL|function|eisa_probe
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|maxSlots
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_char
id|name
(braket
id|DEPCA_STRLEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
r_return
suffix:semicolon
multiline_comment|/* Been here before ! */
r_if
c_cond
(paren
(paren
id|ioaddr
OL
l_int|0x400
)paren
op_logical_and
(paren
id|ioaddr
OG
l_int|0
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* ISA Address */
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EISA_SLOT_INC
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|i
op_assign
l_int|1
suffix:semicolon
id|maxSlots
op_assign
id|MAX_EISA_SLOTS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|i
op_assign
(paren
id|ioaddr
op_rshift
l_int|12
)paren
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|iobase
op_amp
l_int|0x0fff
)paren
op_eq
l_int|0
)paren
id|iobase
op_add_assign
id|DEPCA_EISA_IO_PORTS
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|iobase
comma
id|DEPCA_TOTAL_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID
)paren
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|depca_hw_init
c_func
(paren
id|dev
comma
id|iobase
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|num_depcas
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|autoprobed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: region already allocated at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Search the entire &squot;eth&squot; device list for a fixed probe. If a match isn&squot;t&n;** found then check for an autoprobe or unused device location. If they&n;** are not available then insert a new device structure at the end of&n;** the current list.&n;*/
r_static
r_struct
id|net_device
op_star
id|__init
DECL|function|alloc_device
id|alloc_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
(brace
r_struct
id|net_device
op_star
id|adev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|fixed
op_assign
l_int|0
comma
id|new_dev
op_assign
l_int|0
suffix:semicolon
id|num_eth
op_assign
id|depca_dev_index
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loading_module
)paren
r_return
id|dev
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;base_addr
op_eq
id|DEPCA_NDA
)paren
op_logical_or
(paren
id|dev-&gt;base_addr
op_eq
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|adev
)paren
(brace
id|adev
op_assign
id|dev
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_eq
id|iobase
)paren
)paren
(brace
id|fixed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|new_dev
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|dev-&gt;next-&gt;name
comma
l_string|&quot;eth&quot;
comma
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
id|new_dev
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_or
id|new_dev
op_logical_or
id|fixed
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
id|num_eth
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adev
op_logical_and
op_logical_neg
id|fixed
)paren
(brace
id|dev
op_assign
id|adev
suffix:semicolon
id|num_eth
op_assign
id|depca_dev_index
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
id|new_dev
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|dev-&gt;base_addr
op_ne
id|DEPCA_NDA
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_ne
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|fixed
)paren
op_logical_or
id|new_dev
)paren
(brace
id|num_eth
op_increment
suffix:semicolon
multiline_comment|/* New device */
id|dev
op_assign
id|insert_device
c_func
(paren
id|dev
comma
id|iobase
comma
id|depca_probe
)paren
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*&n;** If at end of eth device list and can&squot;t use current entry, malloc&n;** one up. If memory could not be allocated, print an error message.&n;*/
r_static
r_struct
id|net_device
op_star
id|__init
DECL|function|insert_device
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_struct
id|net_device
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eth%d: Device not initialised, insufficient memory&bslash;n&quot;
comma
id|num_eth
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_new
op_member_access_from_pointer
id|next
op_assign
id|dev-&gt;next
suffix:semicolon
id|dev-&gt;next
op_assign
r_new
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* point to the new device */
r_if
c_cond
(paren
id|num_eth
OG
l_int|9999
)paren
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth????&quot;
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|num_eth
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* assign the io address */
id|dev-&gt;init
op_assign
id|init
suffix:semicolon
multiline_comment|/* initialisation routine */
)brace
r_return
id|dev
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|depca_dev_index
id|depca_dev_index
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|s
suffix:semicolon
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|s
)paren
)paren
(brace
id|j
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
(paren
id|i
op_star
l_int|10
)paren
op_plus
(paren
op_star
id|s
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;** Look for a particular board name in the on-board Remote Diagnostics&n;** and Boot (readb) ROM. This will also give us a clue to the network RAM&n;** base address.&n;*/
r_static
r_void
id|__init
DECL|function|DepcaSignature
id|DepcaSignature
c_func
(paren
r_char
op_star
id|name
comma
id|u_long
id|paddr
)paren
(brace
id|u_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_const
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|DEPCA_SIGNATURE
suffix:semicolon
r_void
op_star
id|ptr
suffix:semicolon
r_char
id|tmpstr
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Copy the first 16 bytes of ROM */
id|ptr
op_assign
id|ioremap
c_func
(paren
id|paddr
op_plus
l_int|0xc000
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;depca: I/O remap failed at %lx&bslash;n&quot;
comma
id|paddr
op_plus
l_int|0xc000
)paren
suffix:semicolon
id|adapter
op_assign
id|unknown
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmpstr
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|ptr
op_plus
id|i
)paren
suffix:semicolon
)brace
id|iounmap
c_func
(paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* Check if PROM contains a valid string */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
op_logical_and
id|k
OL
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|signatures
(braket
id|i
)braket
(braket
id|k
)braket
op_eq
id|tmpstr
(braket
id|j
)braket
)paren
(brace
multiline_comment|/* track signature */
id|k
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Check if name string is valid, provided there&squot;s no PROM */
r_if
c_cond
(paren
op_star
id|name
op_logical_and
(paren
id|i
op_eq
id|unknown
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|signatures
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Update search results */
id|strcpy
c_func
(paren
id|name
comma
id|signatures
(braket
id|i
)braket
)paren
suffix:semicolon
id|adapter
op_assign
id|i
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Look for a special sequence in the Ethernet station address PROM that&n;** is common across all DEPCA products. Note that the original DEPCA needs&n;** its ROM address counter to be initialized and enabled. Only enable&n;** if the first address octet is a 0x08 - this minimises the chances of&n;** messing around with some other hardware, but it assumes that this DEPCA&n;** card initialized itself correctly.&n;** &n;** Search the Ethernet address ROM for the signature. Since the ROM address&n;** counter can start at an arbitrary point, the search must include the entire&n;** probe sequence length plus the (length_of_the_signature - 1).&n;** Stop the search IMMEDIATELY after the signature is found so that the&n;** PROM address counter is correctly positioned at the start of the&n;** ethernet address for later read out.&n;*/
r_static
r_int
id|__init
DECL|function|DevicePresent
id|DevicePresent
c_func
(paren
id|u_long
id|ioaddr
)paren
(brace
r_union
(brace
r_struct
(brace
id|u32
id|a
suffix:semicolon
id|u32
id|b
suffix:semicolon
)brace
id|llsig
suffix:semicolon
r_char
id|Sig
(braket
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
)braket
suffix:semicolon
)brace
id|dev
suffix:semicolon
r_int
id|sigLength
op_assign
l_int|0
suffix:semicolon
id|s8
id|data
suffix:semicolon
id|s16
id|nicsr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
multiline_comment|/* clear counter on DEPCA */
id|data
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
multiline_comment|/* read data */
r_if
c_cond
(paren
id|data
op_eq
l_int|0x08
)paren
(brace
multiline_comment|/* Enable counter on DEPCA */
id|nicsr
op_assign
id|inb
c_func
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
id|nicsr
op_or_assign
id|AAC
suffix:semicolon
id|outb
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
)brace
id|dev.llsig.a
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|dev.llsig.b
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|sigLength
op_assign
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.Sig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
r_if
c_cond
(paren
id|data
op_eq
id|dev.Sig
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* rare case.... */
id|j
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|sigLength
)paren
(brace
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* search failed */
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** The DE100 and DE101 PROM accesses were made non-standard for some bizarre&n;** reason: access the upper half of the PROM with x=0; access the lower half&n;** with x=1.&n;*/
r_static
r_int
id|__init
DECL|function|get_hw_addr
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|k
comma
id|tmp
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_short
id|j
comma
id|x
comma
id|chksum
suffix:semicolon
id|x
op_assign
(paren
(paren
(paren
id|adapter
op_eq
id|de100
)paren
op_logical_or
(paren
id|adapter
op_eq
id|de101
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
(brace
id|k
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
id|k
op_add_assign
(paren
id|u_char
)paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
op_plus
id|x
)paren
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
op_plus
id|x
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0xffff
)paren
id|k
op_assign
l_int|0
suffix:semicolon
id|chksum
op_assign
(paren
id|u_char
)paren
id|inb
c_func
(paren
id|DEPCA_PROM
op_plus
id|x
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|u_short
)paren
(paren
id|inb
c_func
(paren
id|DEPCA_PROM
op_plus
id|x
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ne
id|chksum
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Load a packet into the shared memory&n;*/
DECL|function|load_packet
r_static
r_int
id|load_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|entry
comma
id|end
comma
id|len
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* Ring around buffer number. */
id|end
op_assign
(paren
id|entry
op_plus
(paren
id|skb-&gt;len
op_minus
l_int|1
)paren
op_div
id|TX_BUFF_SZ
)paren
op_amp
id|lp-&gt;txRingMask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|base
)paren
op_amp
id|T_OWN
)paren
)paren
(brace
multiline_comment|/* Enough room? */
multiline_comment|/* &n;    ** Caution: the write order is important here... don&squot;t set up the&n;    ** ownership rights until all the other information is in place.&n;    */
r_if
c_cond
(paren
id|end
OL
id|entry
)paren
(brace
multiline_comment|/* wrapped buffer */
id|len
op_assign
(paren
id|lp-&gt;txRingMask
op_minus
id|entry
op_plus
l_int|1
)paren
op_star
id|TX_BUFF_SZ
suffix:semicolon
id|memcpy_toio
c_func
(paren
id|lp-&gt;tx_buff
(braket
id|entry
)braket
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
id|memcpy_toio
c_func
(paren
id|lp-&gt;tx_buff
(braket
l_int|0
)braket
comma
id|skb-&gt;data
op_plus
id|len
comma
id|skb-&gt;len
op_minus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* linear buffer */
id|memcpy_toio
c_func
(paren
id|lp-&gt;tx_buff
(braket
id|entry
)braket
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
multiline_comment|/* set up the buffer descriptors */
id|len
op_assign
(paren
id|skb-&gt;len
OL
id|ETH_ZLEN
)paren
ques
c_cond
id|ETH_ZLEN
suffix:colon
id|skb-&gt;len
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|entry
suffix:semicolon
id|i
op_ne
id|end
suffix:semicolon
id|i
op_assign
(paren
op_increment
id|i
)paren
op_amp
id|lp-&gt;txRingMask
)paren
(brace
multiline_comment|/* clean out flags */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
op_amp
op_complement
id|T_FLAGS
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x0000
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|misc
)paren
suffix:semicolon
multiline_comment|/* clears other error flags */
id|writew
c_func
(paren
op_minus
id|TX_BUFF_SZ
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* packet length in buffer */
id|len
op_sub_assign
id|TX_BUFF_SZ
suffix:semicolon
)brace
multiline_comment|/* clean out flags */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|base
)paren
op_amp
op_complement
id|T_FLAGS
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|base
)paren
suffix:semicolon
id|writew
c_func
(paren
l_int|0x0000
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|misc
)paren
suffix:semicolon
multiline_comment|/* clears other error flags */
id|writew
c_func
(paren
op_minus
id|len
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* packet length in last buff */
multiline_comment|/* start of packet */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
)paren
op_or
id|T_STP
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
)paren
suffix:semicolon
multiline_comment|/* end of packet */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|base
)paren
op_or
id|T_ENP
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|end
)braket
dot
id|base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|end
suffix:semicolon
id|i
op_ne
id|entry
suffix:semicolon
op_decrement
id|i
)paren
(brace
multiline_comment|/* ownership of packet */
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
op_or
id|T_OWN
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
id|lp-&gt;txRingMask
op_plus
l_int|1
suffix:semicolon
)brace
id|writel
c_func
(paren
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
)paren
op_or
id|T_OWN
comma
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
)paren
suffix:semicolon
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|end
)paren
op_amp
id|lp-&gt;txRingMask
suffix:semicolon
multiline_comment|/* update current pointers */
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Look for a particular board name in the EISA configuration space&n;*/
r_static
r_int
id|__init
DECL|function|EISA_signature
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
(brace
id|u_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|DEPCA_SIGNATURE
suffix:semicolon
r_char
id|ManCode
(braket
id|DEPCA_STRLEN
)braket
suffix:semicolon
r_union
(brace
id|s32
id|ID
suffix:semicolon
r_char
id|Id
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|Eisa
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
op_star
id|name
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|Eisa.ID
op_assign
id|inl
c_func
(paren
id|eisa_id
)paren
suffix:semicolon
id|ManCode
(braket
l_int|0
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|1
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
)paren
op_plus
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|3
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|2
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|4
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|3
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
(paren
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|ManCode
comma
id|signatures
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
id|ManCode
)paren
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|depca_dbg_open
r_static
r_void
id|depca_dbg_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|depca_init
op_star
id|p
op_assign
op_amp
id|lp-&gt;init_block
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
multiline_comment|/* Do not copy the shadow init block into shared memory */
multiline_comment|/* Debugging should not affect normal operation! */
multiline_comment|/* The shadow init block will get copied across during InitRestartDepca */
id|printk
c_func
(paren
l_string|&quot;%s: depca open with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor head addresses (CPU):&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        0x%lx  0x%lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|lp-&gt;rx_ring
comma
(paren
id|u_long
)paren
id|lp-&gt;tx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor addresses (CPU):&bslash;nRX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingMask
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx &quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingMask
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx &quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nDescriptor buffers (Device):&bslash;nRX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingMask
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8x  &quot;
comma
id|readl
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingMask
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8x  &quot;
comma
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Initialisation block at 0x%8.8lx(Phys)&bslash;n&quot;
comma
id|virt_to_phys
c_func
(paren
id|lp-&gt;sh_mem
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        mode: 0x%4.4x&bslash;n&quot;
comma
id|p-&gt;mode
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        physical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|p-&gt;phys_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&bslash;n&quot;
comma
id|p-&gt;phys_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        multicast hash table: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|p-&gt;mcast_table
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&bslash;n&quot;
comma
id|p-&gt;mcast_table
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        rx_ring at: 0x%8.8x&bslash;n&quot;
comma
id|p-&gt;rx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        tx_ring at: 0x%8.8x&bslash;n&quot;
comma
id|p-&gt;tx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffers (Phys): 0x%8.8lx&bslash;n&quot;
comma
id|virt_to_phys
c_func
(paren
id|lp-&gt;sh_mem
)paren
op_plus
id|lp-&gt;buffs_offset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ring size:&bslash;nRX: %d  Log2(rxRingMask): 0x%8.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rxRingMask
op_plus
l_int|1
comma
id|lp-&gt;rx_rlen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: %d  Log2(txRingMask): 0x%8.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;txRingMask
op_plus
l_int|1
comma
id|lp-&gt;tx_rlen
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR2
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CSR2&amp;1: 0x%4.4x&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR1
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%4.4x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR3
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CSR3: 0x%4.4x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Perform IOCTL call functions here. Some are privileged operations and the&n;** effective uid is checked in those cases.&n;** All multicast IOCTLs will not work here and are for testing purposes only.&n;*/
DECL|function|depca_ioctl
r_static
r_int
id|depca_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|depca_ioctl
op_star
id|ioc
op_assign
(paren
r_struct
id|depca_ioctl
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_union
(brace
id|u8
id|addr
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
)braket
suffix:semicolon
id|u16
id|sval
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
id|u32
id|lval
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|ioc-&gt;cmd
)paren
(brace
r_case
id|DEPCA_GET_HWADDR
suffix:colon
multiline_comment|/* Get the hardware address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|ETH_ALEN
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|ioc-&gt;data
comma
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_SET_HWADDR
suffix:colon
multiline_comment|/* Set the hardware address */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tmp.addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;tx_old
op_ne
id|lp-&gt;tx_new
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait for the ring to empty */
id|STOP_DEPCA
suffix:semicolon
multiline_comment|/* Temporarily stop the depca.  */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Initialize the descriptor rings */
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reload CSR3 */
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Resume normal operation. */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unlock the TX ring */
r_break
suffix:semicolon
r_case
id|DEPCA_SET_PROM
suffix:colon
multiline_comment|/* Set Promiscuous Mode */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;tx_old
op_ne
id|lp-&gt;tx_new
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait for the ring to empty */
id|STOP_DEPCA
suffix:semicolon
multiline_comment|/* Temporarily stop the depca.  */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Initialize the descriptor rings */
id|lp-&gt;init_block.mode
op_or_assign
id|PROM
suffix:semicolon
multiline_comment|/* Set promiscuous mode */
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reload CSR3 */
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Resume normal operation. */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unlock the TX ring */
r_break
suffix:semicolon
r_case
id|DEPCA_CLR_PROM
suffix:colon
multiline_comment|/* Clear Promiscuous Mode */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;tx_old
op_ne
id|lp-&gt;tx_new
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait for the ring to empty */
id|STOP_DEPCA
suffix:semicolon
multiline_comment|/* Temporarily stop the depca.  */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Initialize the descriptor rings */
id|lp-&gt;init_block.mode
op_and_assign
op_complement
id|PROM
suffix:semicolon
multiline_comment|/* Clear promiscuous mode */
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Reload CSR3 */
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Resume normal operation. */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unlock the TX ring */
r_break
suffix:semicolon
r_case
id|DEPCA_SAY_BOO
suffix:colon
multiline_comment|/* Say &quot;Boo!&quot; to the kernel log file */
id|printk
c_func
(paren
l_string|&quot;%s: Boo!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_GET_MCA
suffix:colon
multiline_comment|/* Get the multicast address table */
id|ioc-&gt;len
op_assign
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ioc-&gt;data
comma
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|lp-&gt;init_block.mcast_table
comma
id|ioc-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_SET_MCA
suffix:colon
multiline_comment|/* Set a multicast address */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
op_star
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
op_star
id|ioc-&gt;len
)paren
suffix:semicolon
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_CLR_MCA
suffix:colon
multiline_comment|/* Clear all multicast addresses */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_MCA_EN
suffix:colon
multiline_comment|/* Enable pass all multicast addressing */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_GET_STATS
suffix:colon
multiline_comment|/* Get the driver statistics */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ioc-&gt;data
comma
id|ioc-&gt;len
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
op_amp
id|lp-&gt;pktStats
comma
id|ioc-&gt;len
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEPCA_GET_REG
suffix:colon
multiline_comment|/* Get the DEPCA Registers */
id|i
op_assign
l_int|0
suffix:semicolon
id|tmp.sval
(braket
id|i
op_increment
)braket
op_assign
id|inw
c_func
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* status register */
id|tmp.sval
(braket
id|i
op_increment
)braket
op_assign
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tmp.sval
(braket
id|i
)braket
comma
op_amp
id|lp-&gt;init_block
comma
r_sizeof
(paren
r_struct
id|depca_init
)paren
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
id|i
op_plus
r_sizeof
(paren
r_struct
id|depca_init
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ioc-&gt;data
comma
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|thisDepca
r_static
r_struct
id|net_device
id|thisDepca
op_assign
(brace
l_string|&quot;&quot;
comma
multiline_comment|/* device name is inserted by /linux/drivers/net/net_init.c */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x200
comma
l_int|7
comma
multiline_comment|/* I/O address, IRQ */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|depca_probe
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* EDIT THESE LINE FOR YOUR CONFIGURATION */
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x200
suffix:semicolon
multiline_comment|/* Or use the irq= io= options to insmod */
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* See depca_probe() for autoprobe messages when a module */
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
id|thisDepca.irq
op_assign
id|irq
suffix:semicolon
id|thisDepca.base_addr
op_assign
id|io
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|thisDepca
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
id|thisDepca.priv
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
id|iounmap
c_func
(paren
id|lp-&gt;sh_mem
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MCA      
r_if
c_cond
(paren
id|lp-&gt;mca_slot
op_ne
op_minus
l_int|1
)paren
(brace
id|mca_mark_as_unused
c_func
(paren
id|lp-&gt;mca_slot
)paren
suffix:semicolon
)brace
macro_line|#endif                 
id|kfree
c_func
(paren
id|lp
)paren
suffix:semicolon
id|thisDepca.priv
op_assign
l_int|NULL
suffix:semicolon
)brace
id|thisDepca.irq
op_assign
l_int|0
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|thisDepca
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|thisDepca.base_addr
comma
id|DEPCA_TOTAL_SIZE
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -c depca.c&quot;&n; *&n; *  compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -c depca.c&quot;&n; * End:&n; */
eof
