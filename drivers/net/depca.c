multiline_comment|/*  depca.c: A DIGITAL DEPCA  &amp; EtherWORKS ethernet driver for linux.&n;&n;    Written 1994 by David C. Davies.&n;&n;&n;                      Copyright 1994 David C. Davies&n;&t;&t;                   and &n;&t;&t;&t; United States Government&n;&t; (as represented by the Director, National Security Agency).  &n;&n;&n;    This software may be used and distributed according to the terms of&n;    the GNU Public License, incorporated herein by reference.&n;&n;    This driver is written for the Digital Equipment Corporation series&n;    of DEPCA and EtherWORKS ethernet cards:&n;&n;        DEPCA       (the original)&n;    &t;DE100&n;&t;DE200 Turbo&n;&t;DE201 Turbo&n;&t;DE202 Turbo (TP BNC)&n;&t;DE210&n;&n;    The  driver has been tested on DE100, DE200 and DE202 cards  in  a&n;    relatively busy network.&n;&n;    This driver  will  not work  for the DE203,  DE204  and DE205 series  of&n;    cards, since they have a new custom ASIC in place of the AMD LANCE chip.&n;&n;    The author may be reached as davies@wanton.lkg.dec.com or&n;    Digital Equipment Corporation, 146 Main Street, Maynard MA 01754.&n;&n;    =========================================================================&n;    The driver was based on the &squot;lance.c&squot; driver from Donald Becker which is&n;    included with the standard driver distribution for linux. Modifications&n;    were made to most routines and the hardware recognition routines were&n;    written from scratch. Primary references used were:&n;&n;    1) Lance.c code in /linux/drivers/net/&n;    2) &quot;Ethernet/IEEE 802.3 Family. 1992 World Network Data Book/Handbook&quot;,&n;       AMD, 1992 [(800) 222-9323].&n;    3) &quot;Am79C90 CMOS Local Area Network Controller for Ethernet (C-LANCE)&quot;,&n;       AMD, Pub. #17881, May 1993.&n;    4) &quot;Am79C960 PCnet-ISA(tm), Single-Chip Ethernet Controller for ISA&quot;,&n;       AMD, Pub. #16907, May 1992&n;    5) &quot;DEC EtherWORKS LC Ethernet Controller Owners Manual&quot;,&n;       Digital Equipment corporation, 1990, Pub. #EK-DE100-OM.003&n;    6) &quot;DEC EtherWORKS Turbo Ethernet Controller Owners Manual&quot;,&n;       Digital Equipment corporation, 1990, Pub. #EK-DE200-OM.003&n;    7) &quot;DEPCA Hardware Reference Manual&quot;, Pub. #EK-DEPCA-PR&n;       Digital Equipment Corporation, 1989&n;    8) &quot;DEC EtherWORKS Turbo_(TP BNC) Ethernet Controller Owners Manual&quot;,&n;       Digital Equipment corporation, 1991, Pub. #EK-DE202-OM.001&n;    &n;    Peter Bauer&squot;s depca.c (V0.5) was referred to when debugging this driver.&n;    The hash filter code was  derived from Reference  3 and has been  tested&n;    only to the extent that the Table  A-1, page A-7,  was confirmed to fill&n;    the   filter bit   positions  correctly.  Hash   filtering  is  not  yet&n;    implemented in the current driver set.&n;&n;    The original DEPCA  card requires that  the ethernet ROM address counter&n;    be enabled to count and has an 8 bit NICSR.  The ROM counter enabling is&n;    only done when  a 0x08 is read as  the first address octet  (to minimise&n;    the chances of  writing over some other hardware&squot;s  I/O  register).  The&n;    size of the NICSR is tested by a word read: if  both bytes are the same,&n;    the register  is 8 bits wide.   Also,  there is a   maximum of only 48kB&n;    network  RAM for   this card.  My   thanks  to Torbjorn Lindh   for help&n;    debugging all this  (and holding  my  feet to the   fire until I got  it&n;    right).&n;&n;    The DE200  series  boards have  on-board 64kB  RAM for  use  as a shared&n;    memory network  buffer. Only the DE100  cards make use  of a  2kB buffer&n;    mode which has not  been implemented in  this driver (only the 32kB  and&n;    64kB modes are supported [16kB/48kB for the original DEPCA]).&n;&n;    At the  most only 2 DEPCA  cards can be supported  because there is only&n;    provision for two I/O base addresses on the cards (0x300 and 0x200). The&n;    base  address is  &squot;autoprobed&squot; by  looking  for  the self  test PROM and&n;    detecting the  card name.  The shared memory  base address is decoded by&n;    &squot;autoprobing&squot; the Ethernet PROM address information. The second DEPCA is&n;    detected and information placed  in the base_addr  variable of the  next&n;    device  structure   (which is created    if  necessary),  thus  enabling&n;    ethif_probe initialization for the device.&n;&n;    ************************************************************************&n;&n;    NOTE: If you are using two  DEPCAs, it is important  that you assign the&n;    base memory addresses  correctly.  The driver  autoprobes I/O 0x300 then&n;    0x200.  The base memory  address for the  first device must be less than&n;    that of the second so that the auto probe will  correctly assign the I/O&n;    and  memory addresses on  the same card.  I can&squot;t  think of  a way to do&n;    this unambiguously at the moment, since there is nothing on the cards to&n;    tie I/O and memory information together.&n;&n;    I am unable  to  test  2 cards   together for now,    so this  code   is&n;    unchecked. All reports, good or bad, are welcome.&n;&n;    ************************************************************************&n;&n;    The board IRQ   setting must be  at an  unused IRQ which  is auto-probed&n;    using Donald Becker&squot;s autoprobe routines. DEPCA and DE100 board IRQs are&n;    {2,3,4,5,7}, whereas the  DE200 is at {5,9,10,11,15}.  Note that IRQ2 is&n;    really IRQ9 in machines with 16 IRQ lines.&n;&n;    No 16MB memory  limitation should exist with this  driver as DMA is  not&n;    used and the common memory area is in low memory on the network card (my&n;    current system has 20MB and I&squot;ve not had problems yet).&n;&n;    TO DO:&n;    ------&n;&n;    1. Implement the 2k buffer mode - does anyone need it??&n;&n;    Revision History&n;    ----------------&n;&n;    Version   Date        Description&n;  &n;      0.1   25-jan-94     Initial writing.&n;      0.2   27-jan-94     Added LANCE TX buffer chaining.&n;      0.3    1-feb-94     Added multiple DEPCA support.&n;      0.31   4-feb-94     Added DE202 recognition.&n;      0.32  19-feb-94     Tidy up. Improve multi-DEPCA support.&n;      0.33  25-feb-94     Fix DEPCA ethernet ROM counter enable.&n;                          Add jabber packet fix from murf@perftech.com&n;&t;&t;&t;  and becker@super.org&n;      0.34   7-mar-94     Fix DEPCA max network memory RAM &amp; NICSR access.&n;      0.35   8-mar-94     Added DE201 recognition.&n;&n;    =========================================================================&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;depca.c:v0.35 3/8/94 davies@wanton.lkg.dec.com&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &quot;iow.h&quot;                    /* left in for pl13/14 compatibility... */
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;depca.h&quot;
macro_line|#ifdef DEPCA_DEBUG
DECL|variable|depca_debug
r_int
id|depca_debug
op_assign
id|DEPCA_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|depca_debug
r_int
id|depca_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifndef DEPCA_IRQ
multiline_comment|/*#define DEPCA_IRQ&t;{5,9,10,11,15,0}*/
DECL|macro|DEPCA_IRQ
mdefine_line|#define DEPCA_IRQ&t;5
macro_line|#endif
macro_line|#ifndef PROBE_LENGTH
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
macro_line|#endif
macro_line|#ifndef PROBE_SEQUENCE
DECL|macro|PROBE_SEQUENCE
mdefine_line|#define PROBE_SEQUENCE &quot;FF0055AAFF0055AA&quot;
macro_line|#endif
macro_line|#ifndef DEPCA_SIGNATURE
DECL|macro|DEPCA_SIGNATURE
mdefine_line|#define DEPCA_SIGNATURE {&quot;DEPCA&quot;,&quot;DE100&quot;,&quot;DE200&quot;,&quot;DE201&quot;,&quot;DE202&quot;,&quot;DE210&quot;,&quot;&quot;}
DECL|macro|DEPCA_NAME_LENGTH
mdefine_line|#define DEPCA_NAME_LENGTH 8
macro_line|#endif
macro_line|#ifndef DEPCA_RAM_BASE_ADDRESSES
DECL|macro|DEPCA_RAM_BASE_ADDRESSES
mdefine_line|#define DEPCA_RAM_BASE_ADDRESSES {0xc0000,0xd0000,0xe0000,0x00000}
macro_line|#endif
DECL|variable|mem_chkd
r_static
r_int
id|mem_chkd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* holds which base addrs have been */
multiline_comment|/* checked, for multi-DEPCA case */
macro_line|#ifndef DEPCA_IO_PORTS
DECL|macro|DEPCA_IO_PORTS
mdefine_line|#define DEPCA_IO_PORTS {0x300, 0x200, 0}
macro_line|#endif
macro_line|#ifndef DEPCA_TOTAL_SIZE
DECL|macro|DEPCA_TOTAL_SIZE
mdefine_line|#define DEPCA_TOTAL_SIZE 0x10
macro_line|#endif
macro_line|#ifndef MAX_NUM_DEPCAS
DECL|macro|MAX_NUM_DEPCAS
mdefine_line|#define MAX_NUM_DEPCAS 2
macro_line|#endif
multiline_comment|/*&n;** Set the number of Tx and Rx buffers. &n;*/
macro_line|#ifndef DEPCA_BUFFER_LOG_SZ
DECL|macro|RING_SIZE
mdefine_line|#define RING_SIZE&t;16              /* 16 buffers */
macro_line|#else
DECL|macro|RING_SIZE
mdefine_line|#define RING_SIZE&t;(1 &lt;&lt; (DEPCA_BUFFERS_LOG_SZ))
macro_line|#endif  /* DEPCA_BUFFER_LOG_SZ */
DECL|macro|PKT_BUF_SZ
mdefine_line|#define PKT_BUF_SZ&t;1544            /* Buffer size for each Tx/Rx buffer */
DECL|macro|PKT_SZ
mdefine_line|#define PKT_SZ   &t;1514            /* Maximum ethernet packet length */
DECL|macro|DAT_SZ
mdefine_line|#define DAT_SZ   &t;1500            /* Maximum ethernet data length */
DECL|macro|PKT_HDR_LEN
mdefine_line|#define PKT_HDR_LEN     14              /* Addresses and data length info */
macro_line|#ifdef HAVE_MULTICAST
macro_line|#ifndef CRC_POLYNOMIAL
DECL|macro|CRC_POLYNOMIAL
mdefine_line|#define CRC_POLYNOMIAL 0x04c11db7       /* Ethernet CRC polynomial */
macro_line|#endif /* CRC_POLYNOMIAL */
macro_line|#endif /* HAVE_MULTICAST */
multiline_comment|/*&n;** The DEPCA Rx and Tx ring descriptors. &n;*/
DECL|struct|depca_rx_head
r_struct
id|depca_rx_head
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
DECL|member|buf_length
r_int
id|buf_length
suffix:semicolon
multiline_comment|/* This length is negative 2&squot;s complement! */
DECL|member|msg_length
r_int
id|msg_length
suffix:semicolon
multiline_comment|/* This length is &quot;normal&quot;. */
)brace
suffix:semicolon
DECL|struct|depca_tx_head
r_struct
id|depca_tx_head
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
multiline_comment|/* This length is negative 2&squot;s complement! */
DECL|member|misc
r_int
id|misc
suffix:semicolon
multiline_comment|/* Errors and TDR info */
)brace
suffix:semicolon
DECL|struct|depca_ring_info
r_struct
id|depca_ring_info
(brace
)brace
suffix:semicolon
multiline_comment|/*&n;** The Lance initialization block, described in databook, in common memory.&n;*/
DECL|struct|depca_init
r_struct
id|depca_init
(brace
DECL|member|mode
r_int
r_int
id|mode
suffix:semicolon
multiline_comment|/* Mode register */
DECL|member|phys_addr
r_int
r_char
id|phys_addr
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* Physical ethernet address */
DECL|member|filter
r_int
r_int
id|filter
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Multicast filter. */
DECL|member|rx_ring
r_int
r_int
id|rx_ring
suffix:semicolon
multiline_comment|/* Rx ring base pointer &amp; ring length */
DECL|member|tx_ring
r_int
r_int
id|tx_ring
suffix:semicolon
multiline_comment|/* Tx ring base pointer &amp; ring length */
)brace
suffix:semicolon
DECL|struct|depca_private
r_struct
id|depca_private
(brace
DECL|member|devname
r_char
id|devname
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Not used */
DECL|member|rx_ring
r_struct
id|depca_rx_head
op_star
id|rx_ring
suffix:semicolon
multiline_comment|/* Pointer to start of RX descriptor ring */
DECL|member|tx_ring
r_struct
id|depca_tx_head
op_star
id|tx_ring
suffix:semicolon
multiline_comment|/* Pointer to start of TX descriptor ring */
DECL|member|init_block
r_struct
id|depca_init
id|init_block
suffix:semicolon
multiline_comment|/* Initialization block */
DECL|member|dma_buffs
r_int
id|dma_buffs
suffix:semicolon
multiline_comment|/* Start address of Rx and Tx buffers. */
DECL|member|cur_rx
DECL|member|cur_tx
r_int
id|cur_rx
comma
id|cur_tx
suffix:semicolon
multiline_comment|/* The next free ring entry */
DECL|member|dirty_rx
DECL|member|dirty_tx
r_int
id|dirty_rx
comma
id|dirty_tx
suffix:semicolon
multiline_comment|/* The ring entries to be free()ed. */
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
DECL|member|depca_na
r_char
id|depca_na
suffix:semicolon
multiline_comment|/* NICSR access width: 0=&gt;byte, 1=&gt;word */
DECL|member|ringSize
r_int
id|ringSize
suffix:semicolon
multiline_comment|/* ring size based on available memory */
DECL|member|rmask
r_int
id|rmask
suffix:semicolon
multiline_comment|/* modulus mask based on ring size */
DECL|member|rlen
r_int
id|rlen
suffix:semicolon
multiline_comment|/* log2(ringSize) for the descriptors */
)brace
suffix:semicolon
multiline_comment|/*&n;** Public Functions&n;*/
r_static
r_int
id|depca_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|depca_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_int
id|depca_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|depca_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;** Private functions&n;*/
r_static
r_int
id|depca_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|depca_init_ring
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|depca_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|LoadCSRs
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|InitRestartDepca
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_char
op_star
id|DepcaSignature
c_func
(paren
r_int
r_int
id|mem_addr
)paren
suffix:semicolon
r_static
r_int
id|DevicePresent
c_func
(paren
r_int
id|ioaddr
)paren
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_int
id|num_addrs
comma
r_char
op_star
id|addrs
comma
r_char
op_star
id|multicast_table
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|depca_na
r_static
r_int
id|depca_na
suffix:semicolon
DECL|variable|num_depcas
DECL|variable|num_eth
r_static
r_int
id|num_depcas
op_assign
l_int|0
comma
id|num_eth
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
multiline_comment|/*&n;** Miscellaneous defines...&n;*/
DECL|macro|STOP_DEPCA
mdefine_line|#define STOP_DEPCA &bslash;&n;    outw(CSR0, DEPCA_ADDR);&bslash;&n;    outw(STOP, DEPCA_DATA)
DECL|macro|GET_NICSR
mdefine_line|#define GET_NICSR(a,b) &bslash;&n;    if (depca_na) { &bslash;&n;      (a) = inw((b)); &bslash;&n;    } else { &bslash;&n;      (a) = inb((b)); &bslash;&n;    }
DECL|macro|PUT_NICSR
mdefine_line|#define PUT_NICSR(a,b) &bslash;&n;    if (depca_na) { &bslash;&n;      outw((a), (b)); &bslash;&n;    } else { &bslash;&n;      outb((a), (b)); &bslash;&n;    }
"&f;"
DECL|function|depca_probe
r_int
id|depca_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
id|DEPCA_IO_PORTS
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|device
op_star
id|eth0
op_assign
(paren
r_struct
id|device
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
(brace
multiline_comment|/* Check a single specified location. */
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|base_addr
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Is DEPCA really here? */
id|status
op_assign
id|depca_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|base_addr
OG
l_int|0
)paren
(brace
multiline_comment|/* Don&squot;t probe at all. */
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* First probe for the DEPCA test */
multiline_comment|/* pattern in ROM */
r_for
c_loop
(paren
id|status
op_assign
op_minus
id|ENODEV
comma
id|port
op_assign
op_amp
id|ports
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|port
op_logical_and
(paren
id|num_depcas
OL
id|MAX_NUM_DEPCAS
)paren
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
op_star
id|port
suffix:semicolon
macro_line|#ifdef HAVE_PORTRESERVE
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ioaddr
comma
id|DEPCA_TOTAL_SIZE
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|ioaddr
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|num_depcas
OG
l_int|0
)paren
(brace
multiline_comment|/* only gets here in autoprobe */
multiline_comment|/*&n;&t;    ** Check the device structures for an end of list or unused device&n;&t;    */
r_while
c_loop
(paren
id|dev-&gt;next
op_ne
(paren
r_struct
id|device
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;next-&gt;base_addr
op_eq
l_int|0xffe0
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* walk through eth device list */
id|num_eth
op_increment
suffix:semicolon
multiline_comment|/* increment eth device number */
)brace
multiline_comment|/*&n;&t;    ** If no more device structures, malloc one up. If memory could&n;&t;    ** not be allocated, print an error message.&n;&t;    ** &n;&t;    */
r_if
c_cond
(paren
id|dev-&gt;next
op_eq
(paren
r_struct
id|device
op_star
)paren
l_int|NULL
)paren
(brace
id|dev-&gt;next
op_assign
(paren
r_struct
id|device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;eth%d: Device not initialised, insufficient memory&bslash;n&quot;
comma
id|num_eth
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    ** If the memory was allocated, point to the new memory area&n;&t;    ** and initialize it (name, I/O address, next device (NULL) and&n;&t;    ** initialisation probe routine).&n;&t;    */
r_if
c_cond
(paren
(paren
id|dev-&gt;next
op_ne
(paren
r_struct
id|device
op_star
)paren
l_int|NULL
)paren
op_logical_and
(paren
id|num_eth
OG
l_int|0
)paren
op_logical_and
(paren
id|num_eth
OL
l_int|9999
)paren
)paren
(brace
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* point to the new device */
id|dev-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|dev
op_plus
r_sizeof
(paren
r_struct
id|device
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|num_eth
)paren
suffix:semicolon
multiline_comment|/* New device name */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
multiline_comment|/* assign the io address */
id|dev-&gt;next
op_assign
(paren
r_struct
id|device
op_star
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* mark the end of list */
id|dev-&gt;init
op_assign
op_amp
id|depca_probe
suffix:semicolon
multiline_comment|/* initialisation routine */
)brace
)brace
r_else
(brace
id|eth0
op_assign
id|dev
suffix:semicolon
multiline_comment|/* remember the first device */
id|status
op_assign
id|depca_probe1
c_func
(paren
id|dev
comma
id|ioaddr
)paren
suffix:semicolon
)brace
id|num_depcas
op_increment
suffix:semicolon
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|eth0
)paren
id|dev
op_assign
id|eth0
suffix:semicolon
multiline_comment|/* restore the first device */
)brace
r_if
c_cond
(paren
id|status
)paren
id|dev-&gt;base_addr
op_assign
id|base_addr
suffix:semicolon
r_return
id|status
suffix:semicolon
multiline_comment|/* ENODEV would be more accurate. */
)brace
r_static
r_int
DECL|function|depca_probe1
id|depca_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|mem_start
comma
id|mem_base
(braket
)braket
op_assign
id|DEPCA_RAM_BASE_ADDRESSES
suffix:semicolon
r_char
op_star
id|name
op_assign
(paren
r_char
op_star
)paren
l_int|NULL
suffix:semicolon
r_int
r_int
id|nicsr
comma
id|offset
comma
id|netRAM
suffix:semicolon
multiline_comment|/*&n;    ** Stop the DEPCA. Enable the DBR ROM and the ethernet ROM address counter&n;    ** (for the really old DEPCAs). Disable interrupts and remote boot.&n;    */
id|STOP_DEPCA
suffix:semicolon
id|GET_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|nicsr
op_assign
(paren
(paren
id|nicsr
op_amp
op_complement
id|SHE
op_amp
op_complement
id|RBE
op_amp
op_complement
id|IEN
)paren
op_or
id|AAC
op_or
id|IM
)paren
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
op_eq
id|STOP
)paren
(brace
multiline_comment|/* Now find out what kind of DEPCA we have. The DE100 uses a different&n;    ** addressing scheme for some registers compared to the DE2xx series.&n;    ** Note that a base address location is marked as checked if no DEPCA is&n;    ** there or one is found (when the search is immediately terminated). This&n;    ** shortens the search time a little for multiple DEPCAs.&n;    */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mem_base
(braket
id|i
)braket
op_logical_and
(paren
id|j
op_eq
l_int|0
)paren
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|mem_chkd
op_rshift
id|i
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* has the memory been checked? */
id|name
op_assign
id|DepcaSignature
c_func
(paren
id|mem_base
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* check for a DEPCA here */
id|mem_chkd
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
multiline_comment|/* mark location checked */
r_if
c_cond
(paren
op_star
id|name
op_ne
(paren
r_char
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* one found? */
id|j
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set exit flag */
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
multiline_comment|/* increment search index */
)brace
)brace
)brace
r_if
c_cond
(paren
op_star
id|name
op_ne
(paren
r_char
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* found a DEPCA device */
id|mem_start
op_assign
id|mem_base
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: DEPCA at %#3x is a %s, &quot;
comma
id|dev-&gt;name
comma
id|ioaddr
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* There is a 32 byte station address PROM at DEPCA_PROM address.&n;&t; The first six bytes are the station address. They can be read&n;&t; directly since the signature search set up the ROM address &n;&t; counter correctly just before this function.&n;&n;&t; For the DE100 we have to be careful about which port is used to&n;&t; read the ROM info.&n;      */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|name
comma
l_string|&quot;DE100&quot;
)paren
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
(brace
id|j
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ethernet address &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet address */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
op_plus
id|j
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
op_plus
id|j
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* leave ROM counter in known state */
id|j
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
)brace
macro_line|#ifdef HAVE_PORTRESERVE
id|snarf_region
c_func
(paren
id|ioaddr
comma
id|DEPCA_TOTAL_SIZE
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** Set up the maximum amount of network RAM(kB)&n;&t;*/
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|name
comma
l_string|&quot;DEPCA&quot;
)paren
op_eq
(paren
r_char
op_star
)paren
l_int|NULL
)paren
(brace
id|netRAM
op_assign
l_int|64
suffix:semicolon
)brace
r_else
(brace
id|netRAM
op_assign
l_int|48
suffix:semicolon
)brace
multiline_comment|/* &n;&t; ** Determine the base address for the DEPCA RAM from the NI-CSR&n;&t; ** and make up a DEPCA-specific-data structure. &n;        */
r_if
c_cond
(paren
id|nicsr
op_amp
id|BUF
)paren
(brace
id|offset
op_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* 32kbyte RAM offset*/
id|nicsr
op_and_assign
op_complement
id|BS
suffix:semicolon
multiline_comment|/* DEPCA RAM in top 32k */
id|printk
c_func
(paren
l_string|&quot;,&bslash;n      with %dkB RAM&quot;
comma
id|netRAM
op_minus
(paren
id|offset
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* 64k/48k bytes RAM */
id|printk
c_func
(paren
l_string|&quot;,&bslash;n      with %dkB RAM&quot;
comma
id|netRAM
)paren
suffix:semicolon
)brace
id|mem_start
op_add_assign
id|offset
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; starting at 0x%.5lx&quot;
comma
id|mem_start
)paren
suffix:semicolon
multiline_comment|/*&n;&t; ** Enable the shadow RAM.&n;&t;*/
id|nicsr
op_or_assign
id|SHE
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Calculate the ring size based on the available RAM&n;&t;** found above. Allocate an equal number of buffers, each&n;&t;** of size PKT_BUF_SZ (1544 bytes) to the Tx and Rx, allowing one&n;&t;** descriptor entry (8 bytes) for each buffer. Make sure&n;&t;** that this ring size is &lt;= RING_SIZE. The ring size must be&n;&t;** a power of 2.&n;&t;*/
id|j
op_assign
(paren
(paren
(paren
id|netRAM
op_lshift
l_int|10
)paren
op_minus
id|offset
op_minus
r_sizeof
(paren
r_struct
id|depca_private
)paren
)paren
op_div
(paren
id|PKT_BUF_SZ
op_plus
l_int|8
)paren
)paren
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|j
OG
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Hold the ring size information here before the depca&n;&t;** private structure is allocated. Need this for the memory&n;&t;** space calculations.&n;&t;*/
id|j
op_assign
l_int|1
op_lshift
id|i
suffix:semicolon
multiline_comment|/*&n;&t;** Set up memory information in the device structure.&n;&t;** Align the descriptor rings on an 8 byte (quadword) boundary.&n;&t;**&n;&t;**     depca_private area&n;&t;**     rx ring descriptors&n;&t;**     tx ring descriptors&n;&t;**     rx buffers&n;&t;**     tx buffers&n;&t;**&n;&t;*/
multiline_comment|/* private area &amp; initialise */
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
id|mem_start
op_plus
l_int|0x07
)paren
op_amp
op_complement
l_int|0x07
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|depca_private
)paren
)paren
suffix:semicolon
multiline_comment|/* Tx &amp; Rx descriptors (aligned to a quadword boundary) */
id|mem_start
op_assign
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dev-&gt;priv
op_plus
r_sizeof
(paren
r_struct
id|depca_private
)paren
)paren
op_plus
(paren
r_int
r_int
)paren
l_int|0x07
)paren
op_amp
(paren
r_int
r_int
)paren
op_complement
l_int|0x07
)paren
suffix:semicolon
id|lp-&gt;rx_ring
op_assign
(paren
r_struct
id|depca_rx_head
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
(paren
r_sizeof
(paren
r_struct
id|depca_rx_head
)paren
op_star
id|j
)paren
suffix:semicolon
id|lp-&gt;tx_ring
op_assign
(paren
r_struct
id|depca_tx_head
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
(paren
r_sizeof
(paren
r_struct
id|depca_tx_head
)paren
op_star
id|j
)paren
suffix:semicolon
id|lp-&gt;dma_buffs
op_assign
id|mem_start
op_amp
l_int|0x00ffffff
suffix:semicolon
id|mem_start
op_add_assign
(paren
id|PKT_BUF_SZ
op_star
id|j
)paren
suffix:semicolon
multiline_comment|/* (mem_start now points to the start of the Tx buffers) */
multiline_comment|/* Initialise the data structures */
id|memset
c_func
(paren
id|lp-&gt;rx_ring
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|depca_rx_head
)paren
op_star
id|j
)paren
suffix:semicolon
id|memset
c_func
(paren
id|lp-&gt;tx_ring
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|depca_tx_head
)paren
op_star
id|j
)paren
suffix:semicolon
multiline_comment|/* This should never happen. */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|lp-&gt;rx_ring
)paren
op_amp
l_int|0x07
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n **ERROR** DEPCA Rx and Tx descriptor rings not on a quadword boundary.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Finish initialising the ring information.&n;&t;*/
id|lp-&gt;ringSize
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ringSize
OG
id|RING_SIZE
)paren
id|lp-&gt;ringSize
op_assign
id|RING_SIZE
suffix:semicolon
id|lp-&gt;rmask
op_assign
id|lp-&gt;ringSize
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;** calculate the real RLEN size for the descriptors. It is&n;&t;** log2(ringSize).&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|lp-&gt;ringSize
suffix:semicolon
id|j
OG
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|lp-&gt;rlen
op_assign
(paren
r_int
r_int
)paren
(paren
id|i
op_lshift
l_int|29
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** load the initialisation block&n;&t;*/
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Initialise the control and status registers&n;&t;*/
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Store the NICSR width for this DEPCA&n;&t;*/
id|lp-&gt;depca_na
op_assign
id|depca_na
suffix:semicolon
multiline_comment|/*&n;&t;** Enable DEPCA board interrupts for autoprobing&n;&t;*/
id|nicsr
op_assign
(paren
(paren
id|nicsr
op_amp
op_complement
id|IM
)paren
op_or
id|IEN
)paren
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
multiline_comment|/* The DMA channel may be passed in on this parameter. */
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To auto-IRQ we enable the initialization-done and DMA err,&n;&t; interrupts. For now we will always get a DMA error. */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Trigger an initialization just for the interrupt. */
id|outw
c_func
(paren
id|INEA
op_or
id|INIT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and probed IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;. Failed to detect IRQ line.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;. Assigned IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|depca_debug
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The DEPCA-specific entries in the device structure. */
id|dev-&gt;open
op_assign
op_amp
id|depca_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|depca_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|depca_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|depca_get_stats
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
macro_line|#endif
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the generic field of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|depca_open
id|depca_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|nicsr
comma
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|depca_interrupt
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;depca_open(): Requested IRQ%d is busy&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;    ** Stop the DEPCA &amp; get the board status information.  &n;    */
id|depca_na
op_assign
id|lp-&gt;depca_na
suffix:semicolon
id|STOP_DEPCA
suffix:semicolon
id|GET_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
multiline_comment|/* &n;    ** Re-initialize the DEPCA... &n;    */
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* initialize the descriptor rings */
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: depca open with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor head addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t0x%8.8lx  0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rx_ring
comma
(paren
r_int
)paren
id|lp-&gt;tx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor addresses:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;ringSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t0x%8.8lx  0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Buffer addresses:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;ringSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t0x%8.8lx  0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
comma
(paren
r_int
)paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Initialisation block at 0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;init_block
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tmode: 0x%4.4x&bslash;n&quot;
comma
id|lp-&gt;init_block.mode
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tphysical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
(paren
r_int
)paren
id|lp-&gt;init_block.phys_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;tlogical address filter: 0x&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
(paren
r_int
)paren
id|lp-&gt;init_block.filter
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;trx_ring at: 0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;init_block.rx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;ttx_ring at: 0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;init_block.tx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dma_buffs: 0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;dma_buffs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ring size: %d&bslash;nMask: 0x%2.2x&bslash;nLog2(ringSize): 0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;ringSize
comma
(paren
r_char
)paren
id|lp-&gt;rmask
comma
(paren
r_int
)paren
id|lp-&gt;rlen
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR2
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CSR2&amp;1: 0x%4.4x&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR1
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%4.4x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR3
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CSR3: 0x%4.4x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Enable DEPCA board interrupts&n;    */
id|nicsr
op_assign
(paren
(paren
id|nicsr
op_amp
op_complement
id|IM
op_amp
op_complement
id|LED
)paren
op_or
id|SHE
op_or
id|IEN
)paren
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* ignore the return status */
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CSR0: 0x%4.4x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|GET_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;nicsr: 0x%4.4x&bslash;n&quot;
comma
id|nicsr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Always succeed */
)brace
multiline_comment|/* Initialize the lance Rx and Tx descriptor rings. */
r_static
r_void
DECL|function|depca_init_ring
id|depca_init_ring
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|lp-&gt;init_block.mode
op_assign
id|DTX
op_or
id|DRX
suffix:semicolon
multiline_comment|/* Disable Rx and Tx. */
id|lp-&gt;cur_rx
op_assign
id|lp-&gt;cur_tx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;dirty_rx
op_assign
id|lp-&gt;dirty_tx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the base addresses and length of each buffer in the ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;ringSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|base
op_assign
(paren
id|lp-&gt;dma_buffs
op_plus
id|i
op_star
id|PKT_BUF_SZ
)paren
op_or
id|R_OWN
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf_length
op_assign
op_minus
id|PKT_BUF_SZ
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|base
op_assign
(paren
id|lp-&gt;dma_buffs
op_plus
(paren
id|i
op_plus
id|lp-&gt;ringSize
)paren
op_star
id|PKT_BUF_SZ
)paren
op_amp
(paren
r_int
r_int
)paren
(paren
l_int|0x00ffffff
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up the initialization block */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;init_block.phys_addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;init_block.filter
(braket
id|i
)braket
op_assign
l_int|0x0000
suffix:semicolon
)brace
id|lp-&gt;init_block.rx_ring
op_assign
(paren
r_int
r_int
)paren
id|lp-&gt;rx_ring
op_or
id|lp-&gt;rlen
suffix:semicolon
id|lp-&gt;init_block.tx_ring
op_assign
(paren
r_int
r_int
)paren
id|lp-&gt;tx_ring
op_or
id|lp-&gt;rlen
suffix:semicolon
id|lp-&gt;init_block.mode
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Enable the Tx and Rx */
)brace
multiline_comment|/* &n;** Writes a socket buffer to TX descriptor ring and starts transmission &n;*/
r_static
r_int
DECL|function|depca_start_xmit
id|depca_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Transmitter timeout, serious problems. */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|10
)paren
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|STOP_DEPCA
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, status %4.4x, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
id|depca_init_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|LoadCSRs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|InitRestartDepca
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|depca_debug
OG
l_int|3
)paren
(brace
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: depca_start_xmit() called, csr0 %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping.  This could better be&n;       done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;    ** The TX buffer, skb, has to be copied into the local network RAM&n;    ** for the LANCE to access it. The skb may be at &gt; 16MB for large &n;    ** (memory) systems.&n;    */
(brace
multiline_comment|/* Fill in a Tx ring entry */
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
id|entry
op_assign
id|lp-&gt;cur_tx
op_increment
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|skbL
op_assign
id|skb-&gt;len
suffix:semicolon
r_char
op_star
id|p
op_assign
(paren
r_char
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|entry
op_and_assign
id|lp-&gt;rmask
suffix:semicolon
multiline_comment|/* Ring around buffer number. */
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_amp
l_int|0x00ffffff
)paren
suffix:semicolon
multiline_comment|/* Wait for a full ring to free up */
r_while
c_loop
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;      ** Caution: the write order is important here... don&squot;t set up the&n;      ** ownership rights until all the other information is in place.&n;      */
id|len
op_assign
(paren
(paren
id|skbL
OG
id|PKT_SZ
)paren
ques
c_cond
id|PKT_SZ
suffix:colon
id|skbL
)paren
suffix:semicolon
multiline_comment|/* skb too long */
r_if
c_cond
(paren
id|len
OL
id|ETH_ZLEN
)paren
id|len
op_assign
id|ETH_ZLEN
suffix:semicolon
multiline_comment|/* len too short */
id|skbL
op_sub_assign
id|len
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|length
op_assign
op_minus
id|len
suffix:semicolon
multiline_comment|/* Clears various error flags */
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|misc
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* copy the data from the socket buffer to the net memory */
id|memcpy
c_func
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|buf
)paren
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Hand over buffer ownership to the LANCE */
r_if
c_cond
(paren
id|skbL
op_le
l_int|0
)paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_or_assign
(paren
id|T_ENP
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_or_assign
(paren
id|T_OWN
op_or
id|T_STP
)paren
suffix:semicolon
multiline_comment|/* Trigger an immediate send demand. */
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|INEA
op_or
id|TDMD
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|p
op_add_assign
id|len
suffix:semicolon
id|skbL
OG
l_int|0
suffix:semicolon
id|p
op_add_assign
id|len
)paren
(brace
multiline_comment|/* Get new buffer pointer */
id|entry
op_assign
id|lp-&gt;cur_tx
op_increment
suffix:semicolon
id|entry
op_and_assign
id|lp-&gt;rmask
suffix:semicolon
multiline_comment|/* Ring around buffer number. */
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_amp
l_int|0x00ffffff
)paren
suffix:semicolon
multiline_comment|/* Wait for a full ring to free up */
r_while
c_loop
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
OL
l_int|0
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy ethernet header to the new buffer */
id|memcpy
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|buf
comma
id|skb-&gt;data
comma
id|PKT_HDR_LEN
)paren
suffix:semicolon
multiline_comment|/* Determine length of data buffer */
id|len
op_assign
(paren
(paren
id|skbL
OG
id|DAT_SZ
)paren
ques
c_cond
id|DAT_SZ
suffix:colon
id|skbL
)paren
suffix:semicolon
multiline_comment|/* skbL too long */
r_if
c_cond
(paren
id|len
OL
id|ETH_ZLEN
)paren
id|len
op_assign
id|ETH_ZLEN
suffix:semicolon
multiline_comment|/* len too short */
id|skbL
op_sub_assign
id|len
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|length
op_assign
op_minus
id|len
suffix:semicolon
multiline_comment|/* Clears various error flags */
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|misc
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* copy the data from the socket buffer to the net memory */
id|memcpy
c_func
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|buf
op_plus
id|PKT_HDR_LEN
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|p
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Hand over buffer ownership to the LANCE */
r_if
c_cond
(paren
id|skbL
op_le
l_int|0
)paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_or_assign
id|T_ENP
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_or_assign
id|T_OWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|depca_debug
OG
l_int|4
)paren
(brace
r_int
r_char
op_star
id|pkt
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
op_amp
l_int|0x00ffffff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: tx ring[%d], %#lx, sk_buf %#lx len %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|entry
comma
(paren
r_int
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|entry
)braket
comma
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|base
comma
op_minus
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|length
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:  Tx %2.2x %2.2x %2.2x ... %2.2x  %2.2x %2.2x %2.2x...%2.2x len %2.2x %2.2x  %2.2x %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt
(braket
l_int|0
)braket
comma
id|pkt
(braket
l_int|1
)braket
comma
id|pkt
(braket
l_int|2
)braket
comma
id|pkt
(braket
l_int|5
)braket
comma
id|pkt
(braket
l_int|6
)braket
comma
id|pkt
(braket
l_int|7
)braket
comma
id|pkt
(braket
l_int|8
)braket
comma
id|pkt
(braket
l_int|11
)braket
comma
id|pkt
(braket
l_int|12
)braket
comma
id|pkt
(braket
l_int|13
)braket
comma
id|pkt
(braket
l_int|14
)braket
comma
id|pkt
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the TX ring is full or not - &squot;tbusy&squot; cleared if not full. */
r_if
c_cond
(paren
id|lp-&gt;tx_ring
(braket
(paren
id|entry
op_plus
l_int|1
)paren
op_amp
id|lp-&gt;rmask
)braket
dot
id|base
op_ge
l_int|0
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** The DEPCA interrupt handler. &n;*/
r_static
r_void
DECL|function|depca_interrupt
id|depca_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|depca_private
op_star
id|lp
suffix:semicolon
r_int
id|csr0
comma
id|ioaddr
comma
id|nicsr
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;depca_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|depca_na
op_assign
id|lp-&gt;depca_na
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Re-entering the interrupt handler.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|MASK_INTERRUPTS
suffix:semicolon
multiline_comment|/* mask the DEPCA board interrupts and turn on the LED */
id|GET_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|nicsr
op_or_assign
(paren
id|IM
op_or
id|LED
)paren
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|csr0
op_assign
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
suffix:semicolon
multiline_comment|/* Acknowledge all of the current interrupt sources ASAP. */
id|outw
c_func
(paren
id|csr0
op_amp
op_complement
(paren
id|INEA
op_or
id|TDMD
op_or
id|STOP
op_or
id|STRT
op_or
id|INIT
)paren
comma
id|DEPCA_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: interrupt  csr0=%#2.2x new csr=%#2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|csr0
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr0
op_amp
id|RINT
)paren
multiline_comment|/* Rx interrupt (packet arrived) */
id|depca_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr0
op_amp
id|TINT
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|depca_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupts we&squot;ve handled. */
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|BABL
op_or
id|CERR
op_or
id|MISS
op_or
id|MERR
op_or
id|RINT
op_or
id|TINT
op_or
id|IDON
op_or
id|INEA
comma
id|DEPCA_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: exiting interrupt, csr%d=%#4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|DEPCA_ADDR
)paren
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Unmask the DEPCA board interrupts and turn off the LED */
id|nicsr
op_assign
(paren
id|nicsr
op_amp
op_complement
id|IM
op_amp
op_complement
id|LED
)paren
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|depca_rx
id|depca_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
op_assign
id|lp-&gt;cur_rx
op_amp
id|lp-&gt;rmask
suffix:semicolon
multiline_comment|/* If we own the next entry, it&squot;s a new packet. Send it up. */
r_for
c_loop
(paren
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
op_ge
l_int|0
suffix:semicolon
id|entry
op_assign
(paren
op_increment
id|lp-&gt;cur_rx
)paren
op_amp
id|lp-&gt;rmask
)paren
(brace
r_int
id|status
op_assign
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
op_rshift
l_int|16
suffix:semicolon
r_int
id|chained
suffix:semicolon
multiline_comment|/*&n;&t;** There is a tricky error noted by John Murphy, &lt;murf@perftech.com&gt;&n;&t;** to Russ Nelson: even with full-sized buffers, it&squot;s possible for a&n;&t;** jabber packet to use two buffers, with only the last one correctly&n;&t;** noting the error.&n;&t;*/
multiline_comment|/* Check for a chaining buffer */
id|chained
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|R_STP
)paren
(brace
id|chained
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;  ** Wait for next buffer to complete to check for errors. This&n;&t;  ** is slow but infrequent and allows for correct hardware buffer&n;&t;  ** chaining (whilst defeating the chaining&squot;s purpose).&n;&t;  */
r_while
c_loop
(paren
(paren
id|status
op_assign
(paren
id|lp-&gt;rx_ring
(braket
(paren
id|entry
op_plus
l_int|1
)paren
op_amp
id|lp-&gt;rmask
)braket
dot
id|base
op_rshift
l_int|16
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NB: &squot;status&squot; now comes from the buffer following &squot;entry&squot;. */
)brace
r_if
c_cond
(paren
id|status
op_amp
id|R_ERR
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|status
op_amp
id|R_FRAM
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_OFLO
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_CRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|R_BUFF
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer, compatible  with net-2e. */
r_int
id|pkt_len
op_assign
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|msg_length
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, deferring packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Really, deferred. */
r_break
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
(paren
r_int
r_char
op_star
)paren
(paren
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
op_amp
l_int|0x00ffffff
)paren
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* &n;&t;    ** Notify the upper protocol layers that there is another &n;&t;    ** packet to handle&n;&t;    */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
multiline_comment|/* turn over ownership of the current entry back to the LANCE */
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
op_or_assign
id|R_OWN
suffix:semicolon
r_if
c_cond
(paren
id|chained
op_logical_and
(paren
id|status
op_amp
id|R_ERR
)paren
)paren
(brace
multiline_comment|/* next entry also bad */
id|entry
op_assign
(paren
op_increment
id|lp-&gt;cur_rx
)paren
op_amp
id|lp-&gt;rmask
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|base
op_or_assign
id|R_OWN
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;    ** We should check that at least two ring entries are free.  If not,&n;    ** we should free one and mark stats-&gt;rx_dropped++. &n;    */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Buffer sent - check for buffer errors.&n;*/
r_static
r_int
DECL|function|depca_tx
id|depca_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|dirty_tx
op_assign
id|lp-&gt;dirty_tx
op_amp
id|lp-&gt;rmask
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Cleaning tx ring, dirty %d clean %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dirty_tx
comma
(paren
id|lp-&gt;cur_tx
op_amp
id|lp-&gt;rmask
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;  ** While the dirty entry is not the current one AND &n;  ** the LANCE doesn&squot;t own it... &n;  */
r_for
c_loop
(paren
suffix:semicolon
id|dirty_tx
op_ne
(paren
id|lp-&gt;cur_tx
op_amp
id|lp-&gt;rmask
)paren
op_logical_and
id|lp-&gt;tx_ring
(braket
id|dirty_tx
)braket
dot
id|base
OG
l_int|0
suffix:semicolon
id|dirty_tx
op_assign
op_increment
id|lp-&gt;dirty_tx
op_amp
id|lp-&gt;rmask
)paren
(brace
r_int
r_int
op_star
id|tmdp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|lp-&gt;tx_ring
(braket
id|dirty_tx
)braket
)paren
suffix:semicolon
r_int
id|status
op_assign
id|lp-&gt;tx_ring
(braket
id|dirty_tx
)braket
dot
id|base
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
multiline_comment|/* Packet not yet sent! */
id|printk
c_func
(paren
l_string|&quot;interrupt for packet not yet sent!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|T_ERR
)paren
(brace
multiline_comment|/* There was an major error, log it. */
r_int
id|err_status
op_assign
id|lp-&gt;tx_ring
(braket
id|dirty_tx
)braket
dot
id|misc
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err_status
op_amp
id|TMD3_RTRY
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err_status
op_amp
id|TMD3_LCAR
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err_status
op_amp
id|TMD3_LCOL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err_status
op_amp
id|TMD3_UFLO
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
multiline_comment|/* We should re-init() after the FIFO error. */
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
(paren
id|T_MORE
op_or
id|T_ONE
)paren
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|depca_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Tx done entry %d, %4.4lx %4.4lx %4.4lx %4.4lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dirty_tx
comma
id|tmdp
(braket
l_int|0
)braket
comma
id|tmdp
(braket
l_int|1
)braket
comma
id|tmdp
(braket
l_int|2
)braket
comma
id|tmdp
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*mark_bh(INET_BH);*/
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|depca_close
id|depca_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;    ** We stop the DEPCA here -- it occasionally polls&n;    ** memory if we don&squot;t. &n;    */
id|outw
c_func
(paren
id|STOP
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|LoadCSRs
r_static
r_void
id|LoadCSRs
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|outw
c_func
(paren
id|CSR1
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* initialisation block address LSW */
id|outw
c_func
(paren
(paren
r_int
r_int
)paren
(paren
r_int
r_int
)paren
op_amp
id|lp-&gt;init_block
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR2
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* initialisation block address MSW */
id|outw
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|lp-&gt;init_block
op_rshift
l_int|16
)paren
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR3
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* ALE control */
id|outw
c_func
(paren
id|ACON
comma
id|DEPCA_DATA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* point back to CSR0 */
)brace
DECL|function|InitRestartDepca
r_static
r_int
id|InitRestartDepca
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
multiline_comment|/* point back to CSR0 */
id|outw
c_func
(paren
id|INIT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
multiline_comment|/* initialize DEPCA */
multiline_comment|/* wait for lance to complete initialisation */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|100
)paren
op_logical_and
op_logical_neg
(paren
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
op_amp
id|IDON
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|100
)paren
(brace
multiline_comment|/* clear IDON by writing a &quot;1&quot;, enable interrupts and start lance */
id|outw
c_func
(paren
id|IDON
op_or
id|INEA
op_or
id|STRT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depca_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DEPCA open after %d ticks, init block %#lx csr0 %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;init_block
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: DEPCA unopened after %d ticks, init block %#lx csr0 %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;init_block
comma
id|inw
c_func
(paren
id|DEPCA_DATA
)paren
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_struct
id|enet_statistics
op_star
DECL|function|depca_get_stats
id|depca_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Null body since there is no framing error counter */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
macro_line|#ifdef HAVE_MULTICAST
multiline_comment|/*&n;** Set or clear the multicast filter for this adaptor.&n;** num_addrs == -1&t;Promiscuous mode, receive all packets&n;** num_addrs == 0&t;Normal mode, clear multicast list&n;** num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;** &t;&t;&t;best-effort filtering.&n;*/
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|depca_private
op_star
id|lp
op_assign
(paren
r_struct
id|depca_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* We take the simple way out and always enable promiscuous mode. */
id|STOP_DEPCA
suffix:semicolon
multiline_comment|/* Temporarily stop the depca.  */
id|lp-&gt;init_block.mode
op_assign
id|PROM
suffix:semicolon
multiline_comment|/* Set promiscuous mode */
r_if
c_cond
(paren
id|num_addrs
op_ge
l_int|0
)paren
(brace
r_int
id|multicast_table
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SetMulticastFilter
c_func
(paren
id|num_addrs
comma
(paren
r_char
op_star
)paren
id|addrs
comma
(paren
r_char
op_star
)paren
id|multicast_table
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t use the multicast table, but rely on upper-layer filtering. */
id|memset
c_func
(paren
id|multicast_table
comma
(paren
id|num_addrs
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
comma
r_sizeof
(paren
id|multicast_table
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;init_block.filter
(braket
id|i
)braket
op_assign
id|multicast_table
(braket
id|i
)braket
suffix:semicolon
)brace
id|lp-&gt;init_block.mode
op_and_assign
op_complement
id|PROM
suffix:semicolon
multiline_comment|/* Unset promiscuous mode */
)brace
r_else
(brace
id|lp-&gt;init_block.mode
op_or_assign
id|PROM
suffix:semicolon
multiline_comment|/* Set promiscuous mode */
)brace
id|outw
c_func
(paren
id|CSR0
comma
id|DEPCA_ADDR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|IDON
op_or
id|INEA
op_or
id|STRT
comma
id|DEPCA_DATA
)paren
suffix:semicolon
multiline_comment|/* Resume normal operation. */
)brace
multiline_comment|/*&n;** Calculate the hash code and update the logical address filter&n;** from a list of ethernet multicast addresses.&n;** Derived from a &squot;C&squot; program in the AMD data book:&n;** &quot;Am79C90 CMOS Local Area Network Controller for Ethernet (C-LANCE)&quot;, &n;** Pub #17781, Rev. A, May 1993&n;*/
DECL|function|SetMulticastFilter
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_int
id|num_addrs
comma
r_char
op_star
id|addrs
comma
r_char
op_star
id|multicast_table
)paren
(brace
r_char
id|j
comma
id|ctrl
comma
id|bit
comma
id|octet
comma
id|hashcode
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|CRC
comma
id|poly
op_assign
(paren
r_int
r_int
)paren
id|CRC_POLYNOMIAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_addrs
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
r_if
c_cond
(paren
(paren
(paren
r_char
)paren
op_star
(paren
id|addrs
op_plus
id|ETH_ALEN
op_star
id|i
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* is multicast address? */
id|CRC
op_assign
(paren
r_int
r_int
)paren
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* init CRC for each address */
r_for
c_loop
(paren
id|octet
op_assign
l_int|0
suffix:semicolon
id|octet
OL
id|ETH_ALEN
suffix:semicolon
id|octet
op_increment
)paren
(brace
multiline_comment|/* for each address octet */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* process each address bit */
id|bit
op_assign
(paren
(paren
(paren
r_char
)paren
op_star
(paren
id|addrs
op_plus
id|ETH_ALEN
op_star
id|i
op_plus
id|octet
)paren
)paren
op_rshift
id|j
)paren
op_amp
l_int|0x01
suffix:semicolon
id|ctrl
op_assign
(paren
(paren
id|CRC
OL
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* shift the control bit */
id|CRC
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* shift the CRC */
r_if
c_cond
(paren
id|bit
op_xor
id|ctrl
)paren
(brace
multiline_comment|/* (bit) XOR (control bit) */
id|CRC
op_xor_assign
id|poly
suffix:semicolon
multiline_comment|/* (CRC) XOR (polynomial) */
)brace
)brace
)brace
id|hashcode
op_assign
(paren
id|CRC
op_amp
l_int|0x00000001
)paren
suffix:semicolon
multiline_comment|/* hashcode is 6 LSb of CRC ... */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|5
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* ... in reverse order. */
id|hashcode
op_lshift_assign
l_int|1
suffix:semicolon
id|CRC
op_rshift_assign
l_int|1
suffix:semicolon
id|hashcode
op_or_assign
(paren
id|CRC
op_amp
l_int|0x00000001
)paren
suffix:semicolon
)brace
id|octet
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-5] -&gt; octet in filter */
multiline_comment|/* bit[0-2] -&gt; bit in octet */
id|multicast_table
(braket
id|octet
)braket
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif  /* HAVE_MULTICAST */
multiline_comment|/*&n;** Look for a particular board name in the on-board Remote Diagnostics&n;** and Boot (RDB) ROM. This will also give us a clue to the network RAM&n;** base address.&n;*/
DECL|function|DepcaSignature
r_static
r_char
op_star
id|DepcaSignature
c_func
(paren
r_int
r_int
id|mem_addr
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_static
r_char
id|signatures
(braket
)braket
(braket
id|DEPCA_NAME_LENGTH
)braket
op_assign
id|DEPCA_SIGNATURE
suffix:semicolon
r_static
r_char
id|thisName
(braket
id|DEPCA_NAME_LENGTH
)braket
suffix:semicolon
r_char
id|tmpstr
(braket
l_int|17
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* copy the first 16 bytes of ROM to */
id|tmpstr
(braket
id|i
)braket
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|mem_addr
op_plus
l_int|0xc000
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* a temporary string */
)brace
id|tmpstr
(braket
id|i
)braket
op_assign
(paren
r_char
)paren
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|thisName
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
(paren
r_char
)paren
l_int|NULL
op_logical_and
op_star
id|thisName
op_eq
(paren
r_char
)paren
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
op_logical_and
id|k
OL
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|signatures
(braket
id|i
)braket
(braket
id|k
)braket
op_eq
id|tmpstr
(braket
id|j
)braket
)paren
(brace
multiline_comment|/* track signature */
id|k
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|thisName
comma
id|signatures
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
id|thisName
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
multiline_comment|/*&n;** Look for a special sequence in the Ethernet station address PROM that&n;** is common across all DEPCA products. Note that the original DEPCA needs&n;** its ROM address counter to be initialized and enabled. Only enable&n;** if the first address octet is a 0x08 - this minimises the chances of&n;** messing around with some other hardware, but it assumes that this DEPCA&n;** card initialized itself correctly. It also assumes that all past and&n;** future DEPCA/EtherWORKS cards will have ethernet addresses beginning with&n;** a 0x08. The choice of byte or word addressing is made here based on whether&n;** word read of the NICSR returns two identical lower and upper bytes: if so&n;** the register is 8 bits wide.&n;*/
DECL|function|DevicePresent
r_static
r_int
id|DevicePresent
c_func
(paren
r_int
id|ioaddr
)paren
(brace
r_static
r_int
id|fp
op_assign
l_int|1
comma
id|sigLength
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|devSig
(braket
)braket
op_assign
id|PROBE_SEQUENCE
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
r_char
id|LSB
comma
id|MSB
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|nicsr
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|asc2hex
c_func
(paren
r_char
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;** Initialize the counter on a DEPCA card. Two reads to ensure DEPCA ethernet&n;** address counter is a) cleared and b) the correct data read.&n;*/
id|data
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
multiline_comment|/* clear counter */
id|data
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
multiline_comment|/* read data */
multiline_comment|/*&n;** Determine whether a byte or word access should be made on the NICSR.&n;** Since the I/O &squot;functions&squot; are actually in-line code, the choice not to use&n;** pointers to functions vs. just set a conditional, is made for us. This code&n;** assumes that the NICSR has an asymmetric bit pattern already in it.&n;*/
id|nicsr
op_assign
id|inw
c_func
(paren
id|DEPCA_NICSR
)paren
suffix:semicolon
id|LSB
op_assign
id|nicsr
op_amp
l_int|0xff
suffix:semicolon
id|MSB
op_assign
(paren
(paren
(paren
r_int
)paren
id|nicsr
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|MSB
op_eq
id|LSB
)paren
(brace
id|depca_na
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* byte accesses */
)brace
r_else
(brace
id|depca_na
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* word accesses */
)brace
multiline_comment|/*&n;** Enable counter&n;*/
r_if
c_cond
(paren
id|data
op_eq
l_int|0x08
)paren
(brace
id|nicsr
op_or_assign
id|AAC
suffix:semicolon
id|PUT_NICSR
c_func
(paren
id|nicsr
comma
id|DEPCA_NICSR
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;** Convert the ascii signature to a hex equivalent &amp; pack in place &n;*/
r_if
c_cond
(paren
id|fp
)paren
(brace
multiline_comment|/* only do this once!... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|devSig
(braket
id|i
)braket
op_ne
(paren
r_char
)paren
l_int|NULL
op_logical_and
op_logical_neg
id|status
suffix:semicolon
id|i
op_add_assign
l_int|2
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|devSig
(braket
id|i
)braket
op_assign
id|asc2hex
c_func
(paren
id|devSig
(braket
id|i
)braket
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|devSig
(braket
id|i
)braket
op_lshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|asc2hex
c_func
(paren
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|devSig
(braket
id|j
)braket
op_assign
id|devSig
(braket
id|i
)braket
op_plus
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|sigLength
op_assign
id|j
suffix:semicolon
id|fp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;** Search the Ethernet address ROM for the signature. Since the ROM address&n;** counter can start at an arbitrary point, the search must include the entire&n;** probe sequence length plus the length of the (signature - 1).&n;** Stop the search IMMEDIATELY after the signature is found so that the&n;** PROM address counter is correctly positioned at the start of the&n;** ethernet address for later read out.&n;*/
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|DEPCA_PROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devSig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|sigLength
)paren
(brace
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* search failed */
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|asc2hex
r_static
r_char
id|asc2hex
c_func
(paren
r_char
id|value
)paren
(brace
id|value
op_sub_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* normalise to 0..9 range */
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|value
OG
l_int|9
)paren
(brace
multiline_comment|/* but may not be 10..15 */
id|value
op_and_assign
l_int|0x1f
suffix:semicolon
multiline_comment|/* make A..F &amp; a..f be the same */
id|value
op_sub_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* normalise to 10..15 range */
r_if
c_cond
(paren
(paren
id|value
OL
l_int|0x0a
)paren
op_logical_or
(paren
id|value
OG
l_int|0x0f
)paren
)paren
(brace
multiline_comment|/* if outside range then... */
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ...signal error */
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* outside 0..9 range... */
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ...signal error */
)brace
r_return
id|value
suffix:semicolon
multiline_comment|/* return hex char or error */
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c depca.c&quot;&n; * End:&n; */
eof
