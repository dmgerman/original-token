multiline_comment|/*&n; * This file is derived from various .h and .c files from the zlib-1.0.4&n; * distribution by Jean-loup Gailly and Mark Adler, with some additions&n; * by Paul Mackerras to aid in implementing Deflate compression and&n; * decompression for PPP packets.  See zlib.h for conditions of&n; * distribution and use.&n; *&n; * Changes that have been made include:&n; * - added Z_PACKET_FLUSH (see zlib.h for details)&n; * - added inflateIncomp and deflateOutputPending&n; * - allow strm-&gt;next_out to be NULL, meaning discard the output&n; *&n; * $Id: zlib.c,v 1.3 1997/12/23 10:47:42 paulus Exp $&n; */
multiline_comment|/* &n; *  ==FILEVERSION 971210==&n; *&n; * This marker is used by the Linux installation script to determine&n; * whether an up-to-date version of this file is already installed.&n; */
DECL|macro|NO_DUMMY_DECL
mdefine_line|#define NO_DUMMY_DECL
DECL|macro|NO_ZCFUNCS
mdefine_line|#define NO_ZCFUNCS
DECL|macro|MY_ZCALLOC
mdefine_line|#define MY_ZCALLOC
macro_line|#if defined(__FreeBSD__) &amp;&amp; (defined(KERNEL) || defined(_KERNEL))
DECL|macro|inflate
mdefine_line|#define inflate&t;inflate_ppp&t;/* FreeBSD already has an inflate :-( */
macro_line|#endif
multiline_comment|/* +++ zutil.h */
multiline_comment|/* zutil.h -- internal interface and configuration of the compression library&n; * Copyright (C) 1995-1996 Jean-loup Gailly.&n; * For conditions of distribution and use, see copyright notice in zlib.h&n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/* From: zutil.h,v 1.16 1996/07/24 13:41:13 me Exp $ */
macro_line|#ifndef _Z_UTIL_H
DECL|macro|_Z_UTIL_H
mdefine_line|#define _Z_UTIL_H
macro_line|#include &quot;zlib.h&quot;
macro_line|#if defined(KERNEL) || defined(_KERNEL)
multiline_comment|/* Assume this is a *BSD or SVR4 kernel */
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/time.h&gt;
macro_line|#include &lt;sys/systm.h&gt;
DECL|macro|HAVE_MEMCPY
macro_line|#  define HAVE_MEMCPY
DECL|macro|memcpy
macro_line|#  define memcpy(d, s, n)&t;bcopy((s), (d), (n))
DECL|macro|memset
macro_line|#  define memset(d, v, n)&t;bzero((d), (n))
DECL|macro|memcmp
macro_line|#  define memcmp&t;&t;bcmp
macro_line|#else
macro_line|#if defined(__KERNEL__)
multiline_comment|/* Assume this is a Linux kernel */
macro_line|#include &lt;linux/string.h&gt;
DECL|macro|HAVE_MEMCPY
mdefine_line|#define HAVE_MEMCPY
macro_line|#else /* not kernel */
macro_line|#if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
macro_line|#   include &lt;stddef.h&gt;
macro_line|#   include &lt;errno.h&gt;
macro_line|#else
r_extern
r_int
id|errno
suffix:semicolon
macro_line|#endif
macro_line|#ifdef STDC
macro_line|#  include &lt;string.h&gt;
macro_line|#  include &lt;stdlib.h&gt;
macro_line|#endif
macro_line|#endif /* __KERNEL__ */
macro_line|#endif /* _KERNEL || KERNEL */
macro_line|#ifndef local
DECL|macro|local
macro_line|#  define local static
macro_line|#endif
multiline_comment|/* compile with -Dlocal if your debugger can&squot;t find static symbols */
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|uchf
r_typedef
id|uch
id|FAR
id|uchf
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ushf
r_typedef
id|ush
id|FAR
id|ushf
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
r_extern
r_const
r_char
op_star
id|z_errmsg
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* indexed by 2-zlib_error */
multiline_comment|/* (size given to avoid silly warnings with Visual C++) */
DECL|macro|ERR_MSG
mdefine_line|#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
DECL|macro|ERR_RETURN
mdefine_line|#define ERR_RETURN(strm,err) &bslash;&n;  return (strm-&gt;msg = (char*)ERR_MSG(err), (err))
multiline_comment|/* To be used only when the state is known to be valid */
multiline_comment|/* common constants */
macro_line|#ifndef DEF_WBITS
DECL|macro|DEF_WBITS
macro_line|#  define DEF_WBITS MAX_WBITS
macro_line|#endif
multiline_comment|/* default windowBits for decompression. MAX_WBITS is for compression only */
macro_line|#if MAX_MEM_LEVEL &gt;= 8
DECL|macro|DEF_MEM_LEVEL
macro_line|#  define DEF_MEM_LEVEL 8
macro_line|#else
DECL|macro|DEF_MEM_LEVEL
macro_line|#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
macro_line|#endif
multiline_comment|/* default memLevel */
DECL|macro|STORED_BLOCK
mdefine_line|#define STORED_BLOCK 0
DECL|macro|STATIC_TREES
mdefine_line|#define STATIC_TREES 1
DECL|macro|DYN_TREES
mdefine_line|#define DYN_TREES    2
multiline_comment|/* The three kinds of block type */
DECL|macro|MIN_MATCH
mdefine_line|#define MIN_MATCH  3
DECL|macro|MAX_MATCH
mdefine_line|#define MAX_MATCH  258
multiline_comment|/* The minimum and maximum match lengths */
DECL|macro|PRESET_DICT
mdefine_line|#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
multiline_comment|/* target dependencies */
macro_line|#ifdef MSDOS
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x00
macro_line|#  ifdef __TURBOC__
macro_line|#    include &lt;alloc.h&gt;
macro_line|#  else /* MSC or DJGPP */
macro_line|#    include &lt;malloc.h&gt;
macro_line|#  endif
macro_line|#endif
macro_line|#ifdef OS2
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x06
macro_line|#endif
macro_line|#ifdef WIN32 /* Window 95 &amp; Windows NT */
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x0b
macro_line|#endif
macro_line|#if defined(VAXC) || defined(VMS)
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x02
DECL|macro|FOPEN
macro_line|#  define FOPEN(name, mode) &bslash;&n;     fopen((name), (mode), &quot;mbc=60&quot;, &quot;ctx=stm&quot;, &quot;rfm=fix&quot;, &quot;mrs=512&quot;)
macro_line|#endif
macro_line|#ifdef AMIGA
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x01
macro_line|#endif
macro_line|#if defined(ATARI) || defined(atarist)
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x05
macro_line|#endif
macro_line|#ifdef MACOS
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x07
macro_line|#endif
macro_line|#ifdef __50SERIES /* Prime/PRIMOS */
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x0F
macro_line|#endif
macro_line|#ifdef TOPS20
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x0a
macro_line|#endif
macro_line|#if defined(_BEOS_) || defined(RISCOS)
DECL|macro|fdopen
macro_line|#  define fdopen(fd,mode) NULL /* No fdopen() */
macro_line|#endif
multiline_comment|/* Common defaults */
macro_line|#ifndef OS_CODE
DECL|macro|OS_CODE
macro_line|#  define OS_CODE  0x03  /* assume Unix */
macro_line|#endif
macro_line|#ifndef FOPEN
DECL|macro|FOPEN
macro_line|#  define FOPEN(name, mode) fopen((name), (mode))
macro_line|#endif
multiline_comment|/* functions */
macro_line|#ifdef HAVE_STRERROR
r_extern
r_char
op_star
id|strerror
id|OF
c_func
(paren
(paren
r_int
)paren
)paren
suffix:semicolon
DECL|macro|zstrerror
macro_line|#  define zstrerror(errnum) strerror(errnum)
macro_line|#else
DECL|macro|zstrerror
macro_line|#  define zstrerror(errnum) &quot;&quot;
macro_line|#endif
macro_line|#if defined(pyr)
DECL|macro|NO_MEMCPY
macro_line|#  define NO_MEMCPY
macro_line|#endif
macro_line|#if (defined(M_I86SM) || defined(M_I86MM)) &amp;&amp; !defined(_MSC_VER)
multiline_comment|/* Use our own functions for small and medium model with MSC &lt;= 5.0.&n;  * You may have to use the same strategy for Borland C (untested).&n;  */
DECL|macro|NO_MEMCPY
macro_line|#  define NO_MEMCPY
macro_line|#endif
macro_line|#if defined(STDC) &amp;&amp; !defined(HAVE_MEMCPY) &amp;&amp; !defined(NO_MEMCPY)
DECL|macro|HAVE_MEMCPY
macro_line|#  define HAVE_MEMCPY
macro_line|#endif
macro_line|#ifdef HAVE_MEMCPY
macro_line|#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
DECL|macro|zmemcpy
macro_line|#    define zmemcpy _fmemcpy
DECL|macro|zmemcmp
macro_line|#    define zmemcmp _fmemcmp
DECL|macro|zmemzero
macro_line|#    define zmemzero(dest, len) _fmemset(dest, 0, len)
macro_line|#  else
DECL|macro|zmemcpy
macro_line|#    define zmemcpy memcpy
DECL|macro|zmemcmp
macro_line|#    define zmemcmp memcmp
DECL|macro|zmemzero
macro_line|#    define zmemzero(dest, len) memset(dest, 0, len)
macro_line|#  endif
macro_line|#else
r_extern
r_void
id|zmemcpy
id|OF
c_func
(paren
(paren
id|Bytef
op_star
id|dest
comma
id|Bytef
op_star
id|source
comma
id|uInt
id|len
)paren
)paren
suffix:semicolon
r_extern
r_int
id|zmemcmp
id|OF
c_func
(paren
(paren
id|Bytef
op_star
id|s1
comma
id|Bytef
op_star
id|s2
comma
id|uInt
id|len
)paren
)paren
suffix:semicolon
r_extern
r_void
id|zmemzero
id|OF
c_func
(paren
(paren
id|Bytef
op_star
id|dest
comma
id|uInt
id|len
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Diagnostic functions */
macro_line|#ifdef DEBUG_ZLIB
macro_line|#  include &lt;stdio.h&gt;
macro_line|#  ifndef verbose
DECL|macro|verbose
macro_line|#    define verbose 0
macro_line|#  endif
r_extern
r_void
id|z_error
id|OF
c_func
(paren
(paren
r_char
op_star
id|m
)paren
)paren
suffix:semicolon
DECL|macro|Assert
macro_line|#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
DECL|macro|Trace
macro_line|#  define Trace(x) fprintf x
DECL|macro|Tracev
macro_line|#  define Tracev(x) {if (verbose) fprintf x ;}
DECL|macro|Tracevv
macro_line|#  define Tracevv(x) {if (verbose&gt;1) fprintf x ;}
DECL|macro|Tracec
macro_line|#  define Tracec(c,x) {if (verbose &amp;&amp; (c)) fprintf x ;}
DECL|macro|Tracecv
macro_line|#  define Tracecv(c,x) {if (verbose&gt;1 &amp;&amp; (c)) fprintf x ;}
macro_line|#else
DECL|macro|Assert
macro_line|#  define Assert(cond,msg)
DECL|macro|Trace
macro_line|#  define Trace(x)
DECL|macro|Tracev
macro_line|#  define Tracev(x)
DECL|macro|Tracevv
macro_line|#  define Tracevv(x)
DECL|macro|Tracec
macro_line|#  define Tracec(c,x)
DECL|macro|Tracecv
macro_line|#  define Tracecv(c,x)
macro_line|#endif
DECL|typedef|check_func
r_typedef
id|uLong
(paren
op_star
id|check_func
)paren
id|OF
c_func
(paren
(paren
id|uLong
id|check
comma
r_const
id|Bytef
op_star
id|buf
comma
id|uInt
id|len
)paren
)paren
suffix:semicolon
id|voidpf
id|zcalloc
id|OF
c_func
(paren
(paren
id|voidpf
id|opaque
comma
r_int
id|items
comma
r_int
id|size
)paren
)paren
suffix:semicolon
r_void
id|zcfree
id|OF
c_func
(paren
(paren
id|voidpf
id|opaque
comma
id|voidpf
id|ptr
)paren
)paren
suffix:semicolon
DECL|macro|ZALLOC
mdefine_line|#define ZALLOC(strm, items, size) &bslash;&n;           (*((strm)-&gt;zalloc))((strm)-&gt;opaque, (items), (size))
DECL|macro|ZFREE
mdefine_line|#define ZFREE(strm, addr)  (*((strm)-&gt;zfree))((strm)-&gt;opaque, (voidpf)(addr))
DECL|macro|TRY_FREE
mdefine_line|#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
macro_line|#endif /* _Z_UTIL_H */
multiline_comment|/* --- zutil.h */
multiline_comment|/* +++ deflate.h */
multiline_comment|/* deflate.h -- internal compression state&n; * Copyright (C) 1995-1996 Jean-loup Gailly&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/* From: deflate.h,v 1.10 1996/07/02 12:41:00 me Exp $ */
macro_line|#ifndef _DEFLATE_H
DECL|macro|_DEFLATE_H
mdefine_line|#define _DEFLATE_H
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* ===========================================================================&n; * Internal compression state.&n; */
DECL|macro|LENGTH_CODES
mdefine_line|#define LENGTH_CODES 29
multiline_comment|/* number of length codes, not counting the special END_BLOCK code */
DECL|macro|LITERALS
mdefine_line|#define LITERALS  256
multiline_comment|/* number of literal bytes 0..255 */
DECL|macro|L_CODES
mdefine_line|#define L_CODES (LITERALS+1+LENGTH_CODES)
multiline_comment|/* number of Literal or Length codes, including the END_BLOCK code */
DECL|macro|D_CODES
mdefine_line|#define D_CODES   30
multiline_comment|/* number of distance codes */
DECL|macro|BL_CODES
mdefine_line|#define BL_CODES  19
multiline_comment|/* number of codes used to transfer the bit lengths */
DECL|macro|HEAP_SIZE
mdefine_line|#define HEAP_SIZE (2*L_CODES+1)
multiline_comment|/* maximum heap size */
DECL|macro|MAX_BITS
mdefine_line|#define MAX_BITS 15
multiline_comment|/* All codes must not exceed MAX_BITS bits */
DECL|macro|INIT_STATE
mdefine_line|#define INIT_STATE    42
DECL|macro|BUSY_STATE
mdefine_line|#define BUSY_STATE   113
DECL|macro|FINISH_STATE
mdefine_line|#define FINISH_STATE 666
multiline_comment|/* Stream status */
multiline_comment|/* Data structure describing a single value and its code string. */
DECL|struct|ct_data_s
r_typedef
r_struct
id|ct_data_s
(brace
r_union
(brace
DECL|member|freq
id|ush
id|freq
suffix:semicolon
multiline_comment|/* frequency count */
DECL|member|code
id|ush
id|code
suffix:semicolon
multiline_comment|/* bit string */
DECL|member|fc
)brace
id|fc
suffix:semicolon
r_union
(brace
DECL|member|dad
id|ush
id|dad
suffix:semicolon
multiline_comment|/* father node in Huffman tree */
DECL|member|len
id|ush
id|len
suffix:semicolon
multiline_comment|/* length of bit string */
DECL|member|dl
)brace
id|dl
suffix:semicolon
DECL|typedef|ct_data
)brace
id|FAR
id|ct_data
suffix:semicolon
DECL|macro|Freq
mdefine_line|#define Freq fc.freq
DECL|macro|Code
mdefine_line|#define Code fc.code
DECL|macro|Dad
mdefine_line|#define Dad  dl.dad
DECL|macro|Len
mdefine_line|#define Len  dl.len
DECL|typedef|static_tree_desc
r_typedef
r_struct
id|static_tree_desc_s
id|static_tree_desc
suffix:semicolon
DECL|struct|tree_desc_s
r_typedef
r_struct
id|tree_desc_s
(brace
DECL|member|dyn_tree
id|ct_data
op_star
id|dyn_tree
suffix:semicolon
multiline_comment|/* the dynamic tree */
DECL|member|max_code
r_int
id|max_code
suffix:semicolon
multiline_comment|/* largest code with non zero frequency */
DECL|member|stat_desc
id|static_tree_desc
op_star
id|stat_desc
suffix:semicolon
multiline_comment|/* the corresponding static tree */
DECL|typedef|tree_desc
)brace
id|FAR
id|tree_desc
suffix:semicolon
DECL|typedef|Pos
r_typedef
id|ush
id|Pos
suffix:semicolon
DECL|typedef|Posf
r_typedef
id|Pos
id|FAR
id|Posf
suffix:semicolon
DECL|typedef|IPos
r_typedef
r_int
id|IPos
suffix:semicolon
multiline_comment|/* A Pos is an index in the character window. We use short instead of int to&n; * save space in the various tables. IPos is used only for parameter passing.&n; */
DECL|struct|deflate_state
r_typedef
r_struct
id|deflate_state
(brace
DECL|member|strm
id|z_streamp
id|strm
suffix:semicolon
multiline_comment|/* pointer back to this zlib stream */
DECL|member|status
r_int
id|status
suffix:semicolon
multiline_comment|/* as the name implies */
DECL|member|pending_buf
id|Bytef
op_star
id|pending_buf
suffix:semicolon
multiline_comment|/* output still pending */
DECL|member|pending_buf_size
id|ulg
id|pending_buf_size
suffix:semicolon
multiline_comment|/* size of pending_buf */
DECL|member|pending_out
id|Bytef
op_star
id|pending_out
suffix:semicolon
multiline_comment|/* next pending byte to output to the stream */
DECL|member|pending
r_int
id|pending
suffix:semicolon
multiline_comment|/* nb of bytes in the pending buffer */
DECL|member|noheader
r_int
id|noheader
suffix:semicolon
multiline_comment|/* suppress zlib header and adler32 */
DECL|member|data_type
id|Byte
id|data_type
suffix:semicolon
multiline_comment|/* UNKNOWN, BINARY or ASCII */
DECL|member|method
id|Byte
id|method
suffix:semicolon
multiline_comment|/* STORED (for zip only) or DEFLATED */
DECL|member|last_flush
r_int
id|last_flush
suffix:semicolon
multiline_comment|/* value of flush param for previous deflate call */
multiline_comment|/* used by deflate.c: */
DECL|member|w_size
id|uInt
id|w_size
suffix:semicolon
multiline_comment|/* LZ77 window size (32K by default) */
DECL|member|w_bits
id|uInt
id|w_bits
suffix:semicolon
multiline_comment|/* log2(w_size)  (8..16) */
DECL|member|w_mask
id|uInt
id|w_mask
suffix:semicolon
multiline_comment|/* w_size - 1 */
DECL|member|window
id|Bytef
op_star
id|window
suffix:semicolon
multiline_comment|/* Sliding window. Input bytes are read into the second half of the window,&n;     * and move to the first half later to keep a dictionary of at least wSize&n;     * bytes. With this organization, matches are limited to a distance of&n;     * wSize-MAX_MATCH bytes, but this ensures that IO is always&n;     * performed with a length multiple of the block size. Also, it limits&n;     * the window size to 64K, which is quite useful on MSDOS.&n;     * To do: use the user input buffer as sliding window.&n;     */
DECL|member|window_size
id|ulg
id|window_size
suffix:semicolon
multiline_comment|/* Actual size of window: 2*wSize, except when the user input buffer&n;     * is directly used as sliding window.&n;     */
DECL|member|prev
id|Posf
op_star
id|prev
suffix:semicolon
multiline_comment|/* Link to older string with same hash index. To limit the size of this&n;     * array to 64K, this link is maintained only for the last 32K strings.&n;     * An index in this array is thus a window index modulo 32K.&n;     */
DECL|member|head
id|Posf
op_star
id|head
suffix:semicolon
multiline_comment|/* Heads of the hash chains or NIL. */
DECL|member|ins_h
id|uInt
id|ins_h
suffix:semicolon
multiline_comment|/* hash index of string to be inserted */
DECL|member|hash_size
id|uInt
id|hash_size
suffix:semicolon
multiline_comment|/* number of elements in hash table */
DECL|member|hash_bits
id|uInt
id|hash_bits
suffix:semicolon
multiline_comment|/* log2(hash_size) */
DECL|member|hash_mask
id|uInt
id|hash_mask
suffix:semicolon
multiline_comment|/* hash_size-1 */
DECL|member|hash_shift
id|uInt
id|hash_shift
suffix:semicolon
multiline_comment|/* Number of bits by which ins_h must be shifted at each input&n;     * step. It must be such that after MIN_MATCH steps, the oldest&n;     * byte no longer takes part in the hash key, that is:&n;     *   hash_shift * MIN_MATCH &gt;= hash_bits&n;     */
DECL|member|block_start
r_int
id|block_start
suffix:semicolon
multiline_comment|/* Window position at the beginning of the current output block. Gets&n;     * negative when the window is moved backwards.&n;     */
DECL|member|match_length
id|uInt
id|match_length
suffix:semicolon
multiline_comment|/* length of best match */
DECL|member|prev_match
id|IPos
id|prev_match
suffix:semicolon
multiline_comment|/* previous match */
DECL|member|match_available
r_int
id|match_available
suffix:semicolon
multiline_comment|/* set if previous match exists */
DECL|member|strstart
id|uInt
id|strstart
suffix:semicolon
multiline_comment|/* start of string to insert */
DECL|member|match_start
id|uInt
id|match_start
suffix:semicolon
multiline_comment|/* start of matching string */
DECL|member|lookahead
id|uInt
id|lookahead
suffix:semicolon
multiline_comment|/* number of valid bytes ahead in window */
DECL|member|prev_length
id|uInt
id|prev_length
suffix:semicolon
multiline_comment|/* Length of the best match at previous step. Matches not greater than this&n;     * are discarded. This is used in the lazy match evaluation.&n;     */
DECL|member|max_chain_length
id|uInt
id|max_chain_length
suffix:semicolon
multiline_comment|/* To speed up deflation, hash chains are never searched beyond this&n;     * length.  A higher limit improves compression ratio but degrades the&n;     * speed.&n;     */
DECL|member|max_lazy_match
id|uInt
id|max_lazy_match
suffix:semicolon
multiline_comment|/* Attempt to find a better match only when the current match is strictly&n;     * smaller than this value. This mechanism is used only for compression&n;     * levels &gt;= 4.&n;     */
DECL|macro|max_insert_length
macro_line|#   define max_insert_length  max_lazy_match
multiline_comment|/* Insert new strings in the hash table only if the match length is not&n;     * greater than this length. This saves time but degrades compression.&n;     * max_insert_length is used only for compression levels &lt;= 3.&n;     */
DECL|member|level
r_int
id|level
suffix:semicolon
multiline_comment|/* compression level (1..9) */
DECL|member|strategy
r_int
id|strategy
suffix:semicolon
multiline_comment|/* favor or force Huffman coding*/
DECL|member|good_match
id|uInt
id|good_match
suffix:semicolon
multiline_comment|/* Use a faster search when the previous match is longer than this */
DECL|member|nice_match
r_int
id|nice_match
suffix:semicolon
multiline_comment|/* Stop searching when current match exceeds this */
multiline_comment|/* used by trees.c: */
multiline_comment|/* Didn&squot;t use ct_data typedef below to supress compiler warning */
DECL|member|dyn_ltree
r_struct
id|ct_data_s
id|dyn_ltree
(braket
id|HEAP_SIZE
)braket
suffix:semicolon
multiline_comment|/* literal and length tree */
DECL|member|dyn_dtree
r_struct
id|ct_data_s
id|dyn_dtree
(braket
l_int|2
op_star
id|D_CODES
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* distance tree */
DECL|member|bl_tree
r_struct
id|ct_data_s
id|bl_tree
(braket
l_int|2
op_star
id|BL_CODES
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Huffman tree for bit lengths */
DECL|member|l_desc
r_struct
id|tree_desc_s
id|l_desc
suffix:semicolon
multiline_comment|/* desc. for literal tree */
DECL|member|d_desc
r_struct
id|tree_desc_s
id|d_desc
suffix:semicolon
multiline_comment|/* desc. for distance tree */
DECL|member|bl_desc
r_struct
id|tree_desc_s
id|bl_desc
suffix:semicolon
multiline_comment|/* desc. for bit length tree */
DECL|member|bl_count
id|ush
id|bl_count
(braket
id|MAX_BITS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* number of codes at each bit length for an optimal tree */
DECL|member|heap
r_int
id|heap
(braket
l_int|2
op_star
id|L_CODES
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* heap used to build the Huffman trees */
DECL|member|heap_len
r_int
id|heap_len
suffix:semicolon
multiline_comment|/* number of elements in the heap */
DECL|member|heap_max
r_int
id|heap_max
suffix:semicolon
multiline_comment|/* element of largest frequency */
multiline_comment|/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.&n;     * The same heap array is used to build all trees.&n;     */
DECL|member|depth
id|uch
id|depth
(braket
l_int|2
op_star
id|L_CODES
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Depth of each subtree used as tie breaker for trees of equal frequency&n;     */
DECL|member|l_buf
id|uchf
op_star
id|l_buf
suffix:semicolon
multiline_comment|/* buffer for literals or lengths */
DECL|member|lit_bufsize
id|uInt
id|lit_bufsize
suffix:semicolon
multiline_comment|/* Size of match buffer for literals/lengths.  There are 4 reasons for&n;     * limiting lit_bufsize to 64K:&n;     *   - frequencies can be kept in 16 bit counters&n;     *   - if compression is not successful for the first block, all input&n;     *     data is still in the window so we can still emit a stored block even&n;     *     when input comes from standard input.  (This can also be done for&n;     *     all blocks if lit_bufsize is not greater than 32K.)&n;     *   - if compression is not successful for a file smaller than 64K, we can&n;     *     even emit a stored file instead of a stored block (saving 5 bytes).&n;     *     This is applicable only for zip (not gzip or zlib).&n;     *   - creating new Huffman trees less frequently may not provide fast&n;     *     adaptation to changes in the input data statistics. (Take for&n;     *     example a binary file with poorly compressible code followed by&n;     *     a highly compressible string table.) Smaller buffer sizes give&n;     *     fast adaptation but have of course the overhead of transmitting&n;     *     trees more frequently.&n;     *   - I can&squot;t count above 4&n;     */
DECL|member|last_lit
id|uInt
id|last_lit
suffix:semicolon
multiline_comment|/* running index in l_buf */
DECL|member|d_buf
id|ushf
op_star
id|d_buf
suffix:semicolon
multiline_comment|/* Buffer for distances. To simplify the code, d_buf and l_buf have&n;     * the same number of elements. To use different lengths, an extra flag&n;     * array would be necessary.&n;     */
DECL|member|opt_len
id|ulg
id|opt_len
suffix:semicolon
multiline_comment|/* bit length of current block with optimal trees */
DECL|member|static_len
id|ulg
id|static_len
suffix:semicolon
multiline_comment|/* bit length of current block with static trees */
DECL|member|compressed_len
id|ulg
id|compressed_len
suffix:semicolon
multiline_comment|/* total bit length of compressed file */
DECL|member|matches
id|uInt
id|matches
suffix:semicolon
multiline_comment|/* number of string matches in current block */
DECL|member|last_eob_len
r_int
id|last_eob_len
suffix:semicolon
multiline_comment|/* bit length of EOB code for last block */
macro_line|#ifdef DEBUG_ZLIB
DECL|member|bits_sent
id|ulg
id|bits_sent
suffix:semicolon
multiline_comment|/* bit length of the compressed data */
macro_line|#endif
DECL|member|bi_buf
id|ush
id|bi_buf
suffix:semicolon
multiline_comment|/* Output buffer. bits are inserted starting at the bottom (least&n;     * significant bits).&n;     */
DECL|member|bi_valid
r_int
id|bi_valid
suffix:semicolon
multiline_comment|/* Number of valid bits in bi_buf.  All bits above the last valid bit&n;     * are always zero.&n;     */
DECL|typedef|deflate_state
)brace
id|FAR
id|deflate_state
suffix:semicolon
multiline_comment|/* Output a byte on the stream.&n; * IN assertion: there is enough room in pending_buf.&n; */
DECL|macro|put_byte
mdefine_line|#define put_byte(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (c);}
DECL|macro|MIN_LOOKAHEAD
mdefine_line|#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
multiline_comment|/* Minimum amount of lookahead, except at the end of the input file.&n; * See deflate.c for comments about the MIN_MATCH+1.&n; */
DECL|macro|MAX_DIST
mdefine_line|#define MAX_DIST(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)
multiline_comment|/* In order to simplify the code, particularly on 16 bit machines, match&n; * distances are limited to MAX_DIST instead of WSIZE.&n; */
multiline_comment|/* in trees.c */
r_void
id|_tr_init
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
r_int
id|_tr_tally
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|dist
comma
r_int
id|lc
)paren
)paren
suffix:semicolon
id|ulg
id|_tr_flush_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|charf
op_star
id|buf
comma
id|ulg
id|stored_len
comma
r_int
id|eof
)paren
)paren
suffix:semicolon
r_void
id|_tr_align
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
r_void
id|_tr_stored_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|charf
op_star
id|buf
comma
id|ulg
id|stored_len
comma
r_int
id|eof
)paren
)paren
suffix:semicolon
r_void
id|_tr_stored_type_only
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* --- deflate.h */
multiline_comment|/* +++ deflate.c */
multiline_comment|/* deflate.c -- compress data using the deflation algorithm&n; * Copyright (C) 1995-1996 Jean-loup Gailly.&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/*&n; *  ALGORITHM&n; *&n; *      The &quot;deflation&quot; process depends on being able to identify portions&n; *      of the input text which are identical to earlier input (within a&n; *      sliding window trailing behind the input currently being processed).&n; *&n; *      The most straightforward technique turns out to be the fastest for&n; *      most input files: try all possible matches and select the longest.&n; *      The key feature of this algorithm is that insertions into the string&n; *      dictionary are very simple and thus fast, and deletions are avoided&n; *      completely. Insertions are performed at each input character, whereas&n; *      string matches are performed only when the previous match ends. So it&n; *      is preferable to spend more time in matches to allow very fast string&n; *      insertions and avoid deletions. The matching algorithm for small&n; *      strings is inspired from that of Rabin &amp; Karp. A brute force approach&n; *      is used to find longer strings when a small match has been found.&n; *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze&n; *      (by Leonid Broukhis).&n; *         A previous version of this file used a more sophisticated algorithm&n; *      (by Fiala and Greene) which is guaranteed to run in linear amortized&n; *      time, but has a larger average cost, uses more memory and is patented.&n; *      However the F&amp;G algorithm may be faster for some highly redundant&n; *      files if the parameter max_chain_length (described below) is too large.&n; *&n; *  ACKNOWLEDGEMENTS&n; *&n; *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and&n; *      I found it in &squot;freeze&squot; written by Leonid Broukhis.&n; *      Thanks to many people for bug reports and testing.&n; *&n; *  REFERENCES&n; *&n; *      Deutsch, L.P.,&quot;DEFLATE Compressed Data Format Specification&quot;.&n; *      Available in ftp://ds.internic.net/rfc/rfc1951.txt&n; *&n; *      A description of the Rabin and Karp algorithm is given in the book&n; *         &quot;Algorithms&quot; by R. Sedgewick, Addison-Wesley, p252.&n; *&n; *      Fiala,E.R., and Greene,D.H.&n; *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595&n; *&n; */
multiline_comment|/* From: deflate.c,v 1.15 1996/07/24 13:40:58 me Exp $ */
multiline_comment|/* #include &quot;deflate.h&quot; */
DECL|variable|deflate_copyright
r_char
id|deflate_copyright
(braket
)braket
op_assign
l_string|&quot; deflate 1.0.4 Copyright 1995-1996 Jean-loup Gailly &quot;
suffix:semicolon
multiline_comment|/*&n;  If you use the zlib library in a product, an acknowledgment is welcome&n;  in the documentation of your product. If for some reason you cannot&n;  include such an acknowledgment, I would appreciate that you keep this&n;  copyright string in the executable of your product.&n; */
multiline_comment|/* ===========================================================================&n; *  Function prototypes.&n; */
r_typedef
r_enum
(brace
DECL|enumerator|need_more
id|need_more
comma
multiline_comment|/* block not completed, need more input or more output */
DECL|enumerator|block_done
id|block_done
comma
multiline_comment|/* block flush performed */
DECL|enumerator|finish_started
id|finish_started
comma
multiline_comment|/* finish started, need only more output at next deflate */
DECL|enumerator|finish_done
id|finish_done
multiline_comment|/* finish done, accept no more input or output */
DECL|typedef|block_state
)brace
id|block_state
suffix:semicolon
DECL|typedef|compress_func
r_typedef
id|block_state
(paren
op_star
id|compress_func
)paren
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
)paren
suffix:semicolon
multiline_comment|/* Compression function. Returns the block state after the call. */
id|local
r_void
id|fill_window
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
id|block_state
id|deflate_stored
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
)paren
suffix:semicolon
id|local
id|block_state
id|deflate_fast
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
)paren
suffix:semicolon
id|local
id|block_state
id|deflate_slow
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|flush
)paren
)paren
suffix:semicolon
id|local
r_void
id|lm_init
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|putShortMSB
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|uInt
id|b
)paren
)paren
suffix:semicolon
id|local
r_void
id|flush_pending
id|OF
c_func
(paren
(paren
id|z_streamp
id|strm
)paren
)paren
suffix:semicolon
id|local
r_int
id|read_buf
id|OF
c_func
(paren
(paren
id|z_streamp
id|strm
comma
id|charf
op_star
id|buf
comma
r_int
id|size
)paren
)paren
suffix:semicolon
macro_line|#ifdef ASMV
r_void
id|match_init
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
multiline_comment|/* asm code initialization */
id|uInt
id|longest_match
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|cur_match
)paren
)paren
suffix:semicolon
macro_line|#else
id|local
id|uInt
id|longest_match
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|cur_match
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_ZLIB
id|local
r_void
id|check_match
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|IPos
id|start
comma
id|IPos
id|match
comma
r_int
id|length
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Local data&n; */
DECL|macro|NIL
mdefine_line|#define NIL 0
multiline_comment|/* Tail of hash chains */
macro_line|#ifndef TOO_FAR
DECL|macro|TOO_FAR
macro_line|#  define TOO_FAR 4096
macro_line|#endif
multiline_comment|/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
DECL|macro|MIN_LOOKAHEAD
mdefine_line|#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
multiline_comment|/* Minimum amount of lookahead, except at the end of the input file.&n; * See deflate.c for comments about the MIN_MATCH+1.&n; */
multiline_comment|/* Values for max_lazy_match, good_match and max_chain_length, depending on&n; * the desired pack level (0..9). The values given below have been tuned to&n; * exclude worst case performance for pathological files. Better values may be&n; * found for specific files.&n; */
DECL|struct|config_s
r_typedef
r_struct
id|config_s
(brace
DECL|member|good_length
id|ush
id|good_length
suffix:semicolon
multiline_comment|/* reduce lazy search above this match length */
DECL|member|max_lazy
id|ush
id|max_lazy
suffix:semicolon
multiline_comment|/* do not perform lazy search above this match length */
DECL|member|nice_length
id|ush
id|nice_length
suffix:semicolon
multiline_comment|/* quit search above this match length */
DECL|member|max_chain
id|ush
id|max_chain
suffix:semicolon
DECL|member|func
id|compress_func
id|func
suffix:semicolon
DECL|typedef|config
)brace
id|config
suffix:semicolon
DECL|variable|configuration_table
id|local
id|config
id|configuration_table
(braket
l_int|10
)braket
op_assign
(brace
multiline_comment|/*      good lazy nice chain */
multiline_comment|/* 0 */
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|deflate_stored
)brace
comma
multiline_comment|/* store only */
multiline_comment|/* 1 */
(brace
l_int|4
comma
l_int|4
comma
l_int|8
comma
l_int|4
comma
id|deflate_fast
)brace
comma
multiline_comment|/* maximum speed, no lazy matches */
multiline_comment|/* 2 */
(brace
l_int|4
comma
l_int|5
comma
l_int|16
comma
l_int|8
comma
id|deflate_fast
)brace
comma
multiline_comment|/* 3 */
(brace
l_int|4
comma
l_int|6
comma
l_int|32
comma
l_int|32
comma
id|deflate_fast
)brace
comma
multiline_comment|/* 4 */
(brace
l_int|4
comma
l_int|4
comma
l_int|16
comma
l_int|16
comma
id|deflate_slow
)brace
comma
multiline_comment|/* lazy matches */
multiline_comment|/* 5 */
(brace
l_int|8
comma
l_int|16
comma
l_int|32
comma
l_int|32
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 6 */
(brace
l_int|8
comma
l_int|16
comma
l_int|128
comma
l_int|128
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 7 */
(brace
l_int|8
comma
l_int|32
comma
l_int|128
comma
l_int|256
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 8 */
(brace
l_int|32
comma
l_int|128
comma
l_int|258
comma
l_int|1024
comma
id|deflate_slow
)brace
comma
multiline_comment|/* 9 */
(brace
l_int|32
comma
l_int|258
comma
l_int|258
comma
l_int|4096
comma
id|deflate_slow
)brace
)brace
suffix:semicolon
multiline_comment|/* maximum compression */
multiline_comment|/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4&n; * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different&n; * meaning.&n; */
DECL|macro|EQUAL
mdefine_line|#define EQUAL 0
multiline_comment|/* result of memcmp for equal strings */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|static_tree_desc_s
DECL|member|dummy
r_struct
id|static_tree_desc_s
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Update a hash value with the given input byte&n; * IN  assertion: all calls to to UPDATE_HASH are made with consecutive&n; *    input characters, so that a running hash key can be computed from the&n; *    previous key instead of complete recalculation each time.&n; */
DECL|macro|UPDATE_HASH
mdefine_line|#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)
multiline_comment|/* ===========================================================================&n; * Insert string str in the dictionary and set match_head to the previous head&n; * of the hash chain (the most recent string with same hash key). Return&n; * the previous length of the hash chain.&n; * IN  assertion: all calls to to INSERT_STRING are made with consecutive&n; *    input characters and the first MIN_MATCH bytes of str are valid&n; *    (except for the last MIN_MATCH-1 bytes of the input file).&n; */
DECL|macro|INSERT_STRING
mdefine_line|#define INSERT_STRING(s, str, match_head) &bslash;&n;   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), &bslash;&n;    s-&gt;prev[(str) &amp; s-&gt;w_mask] = match_head = s-&gt;head[s-&gt;ins_h], &bslash;&n;    s-&gt;head[s-&gt;ins_h] = (Pos)(str))
multiline_comment|/* ===========================================================================&n; * Initialize the hash table (avoiding 64K overflow for 16 bit systems).&n; * prev[] will be initialized on the fly.&n; */
DECL|macro|CLEAR_HASH
mdefine_line|#define CLEAR_HASH(s) &bslash;&n;    s-&gt;head[s-&gt;hash_size-1] = NIL; &bslash;&n;    zmemzero((charf *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));
multiline_comment|/* ========================================================================= */
DECL|function|deflateInit_
r_int
id|deflateInit_
c_func
(paren
id|strm
comma
id|level
comma
id|version
comma
id|stream_size
)paren
id|z_streamp
id|strm
suffix:semicolon
r_int
id|level
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_int
id|stream_size
suffix:semicolon
(brace
r_return
id|deflateInit2_
c_func
(paren
id|strm
comma
id|level
comma
id|Z_DEFLATED
comma
id|MAX_WBITS
comma
id|DEF_MEM_LEVEL
comma
id|Z_DEFAULT_STRATEGY
comma
id|version
comma
id|stream_size
)paren
suffix:semicolon
multiline_comment|/* To do: ignore strm-&gt;next_in if we use it as window */
)brace
multiline_comment|/* ========================================================================= */
DECL|function|deflateInit2_
r_int
id|deflateInit2_
c_func
(paren
id|strm
comma
id|level
comma
id|method
comma
id|windowBits
comma
id|memLevel
comma
id|strategy
comma
id|version
comma
id|stream_size
)paren
id|z_streamp
id|strm
suffix:semicolon
r_int
id|level
suffix:semicolon
r_int
id|method
suffix:semicolon
r_int
id|windowBits
suffix:semicolon
r_int
id|memLevel
suffix:semicolon
r_int
id|strategy
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_int
id|stream_size
suffix:semicolon
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|noheader
op_assign
l_int|0
suffix:semicolon
r_static
r_char
op_star
id|my_version
op_assign
id|ZLIB_VERSION
suffix:semicolon
id|ushf
op_star
id|overlay
suffix:semicolon
multiline_comment|/* We overlay pending_buf and d_buf+l_buf. This works since the average&n;     * output size for (length,distance) codes is &lt;= 24 bits.&n;     */
r_if
c_cond
(paren
id|version
op_eq
id|Z_NULL
op_logical_or
id|version
(braket
l_int|0
)braket
op_ne
id|my_version
(braket
l_int|0
)braket
op_logical_or
id|stream_size
op_ne
r_sizeof
(paren
id|z_stream
)paren
)paren
(brace
r_return
id|Z_VERSION_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|strm-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
macro_line|#ifndef NO_ZCFUNCS
r_if
c_cond
(paren
id|strm-&gt;zalloc
op_eq
id|Z_NULL
)paren
(brace
id|strm-&gt;zalloc
op_assign
id|zcalloc
suffix:semicolon
id|strm-&gt;opaque
op_assign
(paren
id|voidpf
)paren
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strm-&gt;zfree
op_eq
id|Z_NULL
)paren
id|strm-&gt;zfree
op_assign
id|zcfree
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|level
op_eq
id|Z_DEFAULT_COMPRESSION
)paren
id|level
op_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|windowBits
OL
l_int|0
)paren
(brace
multiline_comment|/* undocumented feature: suppress zlib header */
id|noheader
op_assign
l_int|1
suffix:semicolon
id|windowBits
op_assign
op_minus
id|windowBits
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memLevel
template_param
id|MAX_MEM_LEVEL
op_logical_or
id|method
op_ne
id|Z_DEFLATED
op_logical_or
id|windowBits
template_param
l_int|15
op_logical_or
id|level
template_param
l_int|9
op_logical_or
id|strategy
template_param
id|Z_HUFFMAN_ONLY
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|ZALLOC
c_func
(paren
id|strm
comma
l_int|1
comma
r_sizeof
(paren
id|deflate_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
id|Z_NULL
)paren
r_return
id|Z_MEM_ERROR
suffix:semicolon
id|strm-&gt;state
op_assign
(paren
r_struct
id|internal_state
id|FAR
op_star
)paren
id|s
suffix:semicolon
id|s-&gt;strm
op_assign
id|strm
suffix:semicolon
id|s-&gt;noheader
op_assign
id|noheader
suffix:semicolon
id|s-&gt;w_bits
op_assign
id|windowBits
suffix:semicolon
id|s-&gt;w_size
op_assign
l_int|1
op_lshift
id|s-&gt;w_bits
suffix:semicolon
id|s-&gt;w_mask
op_assign
id|s-&gt;w_size
op_minus
l_int|1
suffix:semicolon
id|s-&gt;hash_bits
op_assign
id|memLevel
op_plus
l_int|7
suffix:semicolon
id|s-&gt;hash_size
op_assign
l_int|1
op_lshift
id|s-&gt;hash_bits
suffix:semicolon
id|s-&gt;hash_mask
op_assign
id|s-&gt;hash_size
op_minus
l_int|1
suffix:semicolon
id|s-&gt;hash_shift
op_assign
(paren
(paren
id|s-&gt;hash_bits
op_plus
id|MIN_MATCH
op_minus
l_int|1
)paren
op_div
id|MIN_MATCH
)paren
suffix:semicolon
id|s-&gt;window
op_assign
(paren
id|Bytef
op_star
)paren
id|ZALLOC
c_func
(paren
id|strm
comma
id|s-&gt;w_size
comma
l_int|2
op_star
r_sizeof
(paren
id|Byte
)paren
)paren
suffix:semicolon
id|s-&gt;prev
op_assign
(paren
id|Posf
op_star
)paren
id|ZALLOC
c_func
(paren
id|strm
comma
id|s-&gt;w_size
comma
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|s-&gt;head
op_assign
(paren
id|Posf
op_star
)paren
id|ZALLOC
c_func
(paren
id|strm
comma
id|s-&gt;hash_size
comma
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|s-&gt;lit_bufsize
op_assign
l_int|1
op_lshift
(paren
id|memLevel
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* 16K elements by default */
id|overlay
op_assign
(paren
id|ushf
op_star
)paren
id|ZALLOC
c_func
(paren
id|strm
comma
id|s-&gt;lit_bufsize
comma
r_sizeof
(paren
id|ush
)paren
op_plus
l_int|2
)paren
suffix:semicolon
id|s-&gt;pending_buf
op_assign
(paren
id|uchf
op_star
)paren
id|overlay
suffix:semicolon
id|s-&gt;pending_buf_size
op_assign
(paren
id|ulg
)paren
id|s-&gt;lit_bufsize
op_star
(paren
r_sizeof
(paren
id|ush
)paren
op_plus
l_int|2L
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;window
op_eq
id|Z_NULL
op_logical_or
id|s-&gt;prev
op_eq
id|Z_NULL
op_logical_or
id|s-&gt;head
op_eq
id|Z_NULL
op_logical_or
id|s-&gt;pending_buf
op_eq
id|Z_NULL
)paren
(brace
id|strm-&gt;msg
op_assign
(paren
r_char
op_star
)paren
id|ERR_MSG
c_func
(paren
id|Z_MEM_ERROR
)paren
suffix:semicolon
id|deflateEnd
(paren
id|strm
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
)brace
id|s-&gt;d_buf
op_assign
id|overlay
op_plus
id|s-&gt;lit_bufsize
op_div
r_sizeof
(paren
id|ush
)paren
suffix:semicolon
id|s-&gt;l_buf
op_assign
id|s-&gt;pending_buf
op_plus
(paren
l_int|1
op_plus
r_sizeof
(paren
id|ush
)paren
)paren
op_star
id|s-&gt;lit_bufsize
suffix:semicolon
id|s-&gt;level
op_assign
id|level
suffix:semicolon
id|s-&gt;strategy
op_assign
id|strategy
suffix:semicolon
id|s-&gt;method
op_assign
(paren
id|Byte
)paren
id|method
suffix:semicolon
r_return
id|deflateReset
c_func
(paren
id|strm
)paren
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|deflateSetDictionary
r_int
id|deflateSetDictionary
(paren
id|strm
comma
id|dictionary
comma
id|dictLength
)paren
id|z_streamp
id|strm
suffix:semicolon
r_const
id|Bytef
op_star
id|dictionary
suffix:semicolon
id|uInt
id|dictLength
suffix:semicolon
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
id|uInt
id|length
op_assign
id|dictLength
suffix:semicolon
id|uInt
id|n
suffix:semicolon
id|IPos
id|hash_head
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|dictionary
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;status
op_ne
id|INIT_STATE
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|strm-&gt;adler
op_assign
id|adler32
c_func
(paren
id|strm-&gt;adler
comma
id|dictionary
comma
id|dictLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
id|MIN_MATCH
)paren
r_return
id|Z_OK
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
id|length
op_assign
id|MAX_DIST
c_func
(paren
id|s
)paren
suffix:semicolon
macro_line|#ifndef USE_DICT_HEAD
id|dictionary
op_add_assign
id|dictLength
op_minus
id|length
suffix:semicolon
multiline_comment|/* use the tail of the dictionary */
macro_line|#endif
)brace
id|zmemcpy
c_func
(paren
(paren
id|charf
op_star
)paren
id|s-&gt;window
comma
id|dictionary
comma
id|length
)paren
suffix:semicolon
id|s-&gt;strstart
op_assign
id|length
suffix:semicolon
id|s-&gt;block_start
op_assign
(paren
r_int
)paren
id|length
suffix:semicolon
multiline_comment|/* Insert all strings in the hash table (except for the last two bytes).&n;     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next&n;     * call of fill_window.&n;     */
id|s-&gt;ins_h
op_assign
id|s-&gt;window
(braket
l_int|0
)braket
suffix:semicolon
id|UPDATE_HASH
c_func
(paren
id|s
comma
id|s-&gt;ins_h
comma
id|s-&gt;window
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|length
op_minus
id|MIN_MATCH
suffix:semicolon
id|n
op_increment
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|n
comma
id|hash_head
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hash_head
)paren
id|hash_head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to make compiler happy */
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|deflateReset
r_int
id|deflateReset
(paren
id|strm
)paren
id|z_streamp
id|strm
suffix:semicolon
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;zalloc
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;zfree
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|strm-&gt;total_in
op_assign
id|strm-&gt;total_out
op_assign
l_int|0
suffix:semicolon
id|strm-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* use zfree if we ever allocate msg dynamically */
id|strm-&gt;data_type
op_assign
id|Z_UNKNOWN
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
id|s-&gt;pending
op_assign
l_int|0
suffix:semicolon
id|s-&gt;pending_out
op_assign
id|s-&gt;pending_buf
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;noheader
OL
l_int|0
)paren
(brace
id|s-&gt;noheader
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* was set to -1 by deflate(..., Z_FINISH); */
)brace
id|s-&gt;status
op_assign
id|s-&gt;noheader
ques
c_cond
id|BUSY_STATE
suffix:colon
id|INIT_STATE
suffix:semicolon
id|strm-&gt;adler
op_assign
l_int|1
suffix:semicolon
id|s-&gt;last_flush
op_assign
id|Z_NO_FLUSH
suffix:semicolon
id|_tr_init
c_func
(paren
id|s
)paren
suffix:semicolon
id|lm_init
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|deflateParams
r_int
id|deflateParams
c_func
(paren
id|strm
comma
id|level
comma
id|strategy
)paren
id|z_streamp
id|strm
suffix:semicolon
r_int
id|level
suffix:semicolon
r_int
id|strategy
suffix:semicolon
(brace
id|deflate_state
op_star
id|s
suffix:semicolon
id|compress_func
id|func
suffix:semicolon
r_int
id|err
op_assign
id|Z_OK
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|Z_DEFAULT_COMPRESSION
)paren
(brace
id|level
op_assign
l_int|6
suffix:semicolon
)brace
r_if
c_cond
(paren
id|level
template_param
l_int|9
op_logical_or
id|strategy
template_param
id|Z_HUFFMAN_ONLY
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|func
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|func
suffix:semicolon
r_if
c_cond
(paren
id|func
op_ne
id|configuration_table
(braket
id|level
)braket
dot
id|func
op_logical_and
id|strm-&gt;total_in
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Flush the last buffer: */
id|err
op_assign
id|deflate
c_func
(paren
id|strm
comma
id|Z_PARTIAL_FLUSH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;level
op_ne
id|level
)paren
(brace
id|s-&gt;level
op_assign
id|level
suffix:semicolon
id|s-&gt;max_lazy_match
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|max_lazy
suffix:semicolon
id|s-&gt;good_match
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|good_length
suffix:semicolon
id|s-&gt;nice_match
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|nice_length
suffix:semicolon
id|s-&gt;max_chain_length
op_assign
id|configuration_table
(braket
id|level
)braket
dot
id|max_chain
suffix:semicolon
)brace
id|s-&gt;strategy
op_assign
id|strategy
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* =========================================================================&n; * Put a short in the pending buffer. The 16-bit value is put in MSB order.&n; * IN assertion: the stream state is correct and there is enough room in&n; * pending_buf.&n; */
DECL|function|putShortMSB
id|local
r_void
id|putShortMSB
(paren
id|s
comma
id|b
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|uInt
id|b
suffix:semicolon
(brace
id|put_byte
c_func
(paren
id|s
comma
(paren
id|Byte
)paren
(paren
id|b
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|put_byte
c_func
(paren
id|s
comma
(paren
id|Byte
)paren
(paren
id|b
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* =========================================================================&n; * Flush as much pending output as possible. All deflate() output goes&n; * through this function so some applications may wish to modify it&n; * to avoid allocating a large strm-&gt;next_out buffer and copying into it.&n; * (See also read_buf()).&n; */
DECL|function|flush_pending
id|local
r_void
id|flush_pending
c_func
(paren
id|strm
)paren
id|z_streamp
id|strm
suffix:semicolon
(brace
id|deflate_state
op_star
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_int
id|len
op_assign
id|s-&gt;pending
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|strm-&gt;avail_out
)paren
id|len
op_assign
id|strm-&gt;avail_out
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|strm-&gt;next_out
op_ne
id|Z_NULL
)paren
(brace
id|zmemcpy
c_func
(paren
id|strm-&gt;next_out
comma
id|s-&gt;pending_out
comma
id|len
)paren
suffix:semicolon
id|strm-&gt;next_out
op_add_assign
id|len
suffix:semicolon
)brace
id|s-&gt;pending_out
op_add_assign
id|len
suffix:semicolon
id|strm-&gt;total_out
op_add_assign
id|len
suffix:semicolon
id|strm-&gt;avail_out
op_sub_assign
id|len
suffix:semicolon
id|s-&gt;pending
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;pending
op_eq
l_int|0
)paren
(brace
id|s-&gt;pending_out
op_assign
id|s-&gt;pending_buf
suffix:semicolon
)brace
)brace
multiline_comment|/* ========================================================================= */
DECL|function|deflate
r_int
id|deflate
(paren
id|strm
comma
id|flush
)paren
id|z_streamp
id|strm
suffix:semicolon
r_int
id|flush
suffix:semicolon
(brace
r_int
id|old_flush
suffix:semicolon
multiline_comment|/* value of flush param for previous deflate call */
id|deflate_state
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|flush
OG
id|Z_FINISH
op_logical_or
id|flush
OL
l_int|0
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
r_if
c_cond
(paren
(paren
id|strm-&gt;next_in
op_eq
id|Z_NULL
op_logical_and
id|strm-&gt;avail_in
op_ne
l_int|0
)paren
op_logical_or
(paren
id|s-&gt;status
op_eq
id|FINISH_STATE
op_logical_and
id|flush
op_ne
id|Z_FINISH
)paren
)paren
(brace
id|ERR_RETURN
c_func
(paren
id|strm
comma
id|Z_STREAM_ERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
id|ERR_RETURN
c_func
(paren
id|strm
comma
id|Z_BUF_ERROR
)paren
suffix:semicolon
id|s-&gt;strm
op_assign
id|strm
suffix:semicolon
multiline_comment|/* just in case */
id|old_flush
op_assign
id|s-&gt;last_flush
suffix:semicolon
id|s-&gt;last_flush
op_assign
id|flush
suffix:semicolon
multiline_comment|/* Write the zlib header */
r_if
c_cond
(paren
id|s-&gt;status
op_eq
id|INIT_STATE
)paren
(brace
id|uInt
id|header
op_assign
(paren
id|Z_DEFLATED
op_plus
(paren
(paren
id|s-&gt;w_bits
op_minus
l_int|8
)paren
op_lshift
l_int|4
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|uInt
id|level_flags
op_assign
(paren
id|s-&gt;level
op_minus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|level_flags
OG
l_int|3
)paren
id|level_flags
op_assign
l_int|3
suffix:semicolon
id|header
op_or_assign
(paren
id|level_flags
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;strstart
op_ne
l_int|0
)paren
id|header
op_or_assign
id|PRESET_DICT
suffix:semicolon
id|header
op_add_assign
l_int|31
op_minus
(paren
id|header
op_mod
l_int|31
)paren
suffix:semicolon
id|s-&gt;status
op_assign
id|BUSY_STATE
suffix:semicolon
id|putShortMSB
c_func
(paren
id|s
comma
id|header
)paren
suffix:semicolon
multiline_comment|/* Save the adler32 of the preset dictionary: */
r_if
c_cond
(paren
id|s-&gt;strstart
op_ne
l_int|0
)paren
(brace
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
id|strm-&gt;adler
op_assign
l_int|1L
suffix:semicolon
)brace
multiline_comment|/* Flush as much pending output as possible */
r_if
c_cond
(paren
id|s-&gt;pending
op_ne
l_int|0
)paren
(brace
id|flush_pending
c_func
(paren
id|strm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Since avail_out is 0, deflate will be called again with&n;&t;     * more output space, but possibly with both pending and&n;&t;     * avail_in equal to zero. There won&squot;t be anything to do,&n;&t;     * but this is not an error situation so make sure we&n;&t;     * return OK instead of BUF_ERROR at next call of deflate:&n;             */
id|s-&gt;last_flush
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* Make sure there is something to do and avoid duplicate consecutive&n;     * flushes. For repeated and useless calls with Z_FINISH, we keep&n;     * returning Z_STREAM_END instead of Z_BUFF_ERROR.&n;     */
)brace
r_else
r_if
c_cond
(paren
id|strm-&gt;avail_in
op_eq
l_int|0
op_logical_and
id|flush
op_le
id|old_flush
op_logical_and
id|flush
op_ne
id|Z_FINISH
)paren
(brace
id|ERR_RETURN
c_func
(paren
id|strm
comma
id|Z_BUF_ERROR
)paren
suffix:semicolon
)brace
multiline_comment|/* User must not provide more input after the first FINISH: */
r_if
c_cond
(paren
id|s-&gt;status
op_eq
id|FINISH_STATE
op_logical_and
id|strm-&gt;avail_in
op_ne
l_int|0
)paren
(brace
id|ERR_RETURN
c_func
(paren
id|strm
comma
id|Z_BUF_ERROR
)paren
suffix:semicolon
)brace
multiline_comment|/* Start a new block or continue the current one.&n;     */
r_if
c_cond
(paren
id|strm-&gt;avail_in
op_ne
l_int|0
op_logical_or
id|s-&gt;lookahead
op_ne
l_int|0
op_logical_or
(paren
id|flush
op_ne
id|Z_NO_FLUSH
op_logical_and
id|s-&gt;status
op_ne
id|FINISH_STATE
)paren
)paren
(brace
id|block_state
id|bstate
suffix:semicolon
id|bstate
op_assign
(paren
op_star
(paren
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|func
)paren
)paren
(paren
id|s
comma
id|flush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bstate
op_eq
id|finish_started
op_logical_or
id|bstate
op_eq
id|finish_done
)paren
(brace
id|s-&gt;status
op_assign
id|FINISH_STATE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bstate
op_eq
id|need_more
op_logical_or
id|bstate
op_eq
id|finish_started
)paren
(brace
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
(brace
id|s-&gt;last_flush
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* avoid BUF_ERROR next call, see above */
)brace
r_return
id|Z_OK
suffix:semicolon
multiline_comment|/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call&n;&t;     * of deflate should use the same flush parameter to make sure&n;&t;     * that the flush is complete. So we don&squot;t have to output an&n;&t;     * empty block here, this will be done at next call. This also&n;&t;     * ensures that for a very small output buffer, we emit at most&n;&t;     * one empty block.&n;&t;     */
)brace
r_if
c_cond
(paren
id|bstate
op_eq
id|block_done
)paren
(brace
r_if
c_cond
(paren
id|flush
op_eq
id|Z_PARTIAL_FLUSH
)paren
(brace
id|_tr_align
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flush
op_eq
id|Z_PACKET_FLUSH
)paren
(brace
multiline_comment|/* Output just the 3-bit `stored&squot; block type value,&n;&t;&t;   but not a zero length. */
id|_tr_stored_type_only
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* FULL_FLUSH or SYNC_FLUSH */
id|_tr_stored_block
c_func
(paren
id|s
comma
(paren
r_char
op_star
)paren
l_int|0
comma
l_int|0L
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* For a full flush, this empty block will be recognized&n;                 * as a special marker by inflate_sync().&n;                 */
r_if
c_cond
(paren
id|flush
op_eq
id|Z_FULL_FLUSH
)paren
(brace
id|CLEAR_HASH
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* forget history */
)brace
)brace
id|flush_pending
c_func
(paren
id|strm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm-&gt;avail_out
op_eq
l_int|0
)paren
(brace
id|s-&gt;last_flush
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* avoid BUF_ERROR at next call, see above */
r_return
id|Z_OK
suffix:semicolon
)brace
)brace
)brace
id|Assert
c_func
(paren
id|strm-&gt;avail_out
OG
l_int|0
comma
l_string|&quot;bug2&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
op_ne
id|Z_FINISH
)paren
r_return
id|Z_OK
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;noheader
)paren
r_return
id|Z_STREAM_END
suffix:semicolon
multiline_comment|/* Write the zlib trailer (adler32) */
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|putShortMSB
c_func
(paren
id|s
comma
(paren
id|uInt
)paren
(paren
id|strm-&gt;adler
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
id|flush_pending
c_func
(paren
id|strm
)paren
suffix:semicolon
multiline_comment|/* If avail_out is zero, the application will call deflate again&n;     * to flush the rest.&n;     */
id|s-&gt;noheader
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* write the trailer only once! */
r_return
id|s-&gt;pending
op_ne
l_int|0
ques
c_cond
id|Z_OK
suffix:colon
id|Z_STREAM_END
suffix:semicolon
)brace
multiline_comment|/* ========================================================================= */
DECL|function|deflateEnd
r_int
id|deflateEnd
(paren
id|strm
)paren
id|z_streamp
id|strm
suffix:semicolon
(brace
r_int
id|status
suffix:semicolon
id|deflate_state
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|s
op_assign
(paren
id|deflate_state
op_star
)paren
id|strm-&gt;state
suffix:semicolon
id|status
op_assign
id|s-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|INIT_STATE
op_logical_and
id|status
op_ne
id|BUSY_STATE
op_logical_and
id|status
op_ne
id|FINISH_STATE
)paren
(brace
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
multiline_comment|/* Deallocate in reverse order of allocations: */
id|TRY_FREE
c_func
(paren
id|strm
comma
id|s-&gt;pending_buf
)paren
suffix:semicolon
id|TRY_FREE
c_func
(paren
id|strm
comma
id|s-&gt;head
)paren
suffix:semicolon
id|TRY_FREE
c_func
(paren
id|strm
comma
id|s-&gt;prev
)paren
suffix:semicolon
id|TRY_FREE
c_func
(paren
id|strm
comma
id|s-&gt;window
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|strm
comma
id|s
)paren
suffix:semicolon
id|strm-&gt;state
op_assign
id|Z_NULL
suffix:semicolon
r_return
id|status
op_eq
id|BUSY_STATE
ques
c_cond
id|Z_DATA_ERROR
suffix:colon
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* =========================================================================&n; * Copy the source state to the destination state.&n; */
DECL|function|deflateCopy
r_int
id|deflateCopy
(paren
id|dest
comma
id|source
)paren
id|z_streamp
id|dest
suffix:semicolon
id|z_streamp
id|source
suffix:semicolon
(brace
id|deflate_state
op_star
id|ds
suffix:semicolon
id|deflate_state
op_star
id|ss
suffix:semicolon
id|ushf
op_star
id|overlay
suffix:semicolon
r_if
c_cond
(paren
id|source
op_eq
id|Z_NULL
op_logical_or
id|dest
op_eq
id|Z_NULL
op_logical_or
id|source-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|ss
op_assign
(paren
id|deflate_state
op_star
)paren
id|source-&gt;state
suffix:semicolon
op_star
id|dest
op_assign
op_star
id|source
suffix:semicolon
id|ds
op_assign
(paren
id|deflate_state
op_star
)paren
id|ZALLOC
c_func
(paren
id|dest
comma
l_int|1
comma
r_sizeof
(paren
id|deflate_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ds
op_eq
id|Z_NULL
)paren
r_return
id|Z_MEM_ERROR
suffix:semicolon
id|dest-&gt;state
op_assign
(paren
r_struct
id|internal_state
id|FAR
op_star
)paren
id|ds
suffix:semicolon
op_star
id|ds
op_assign
op_star
id|ss
suffix:semicolon
id|ds-&gt;strm
op_assign
id|dest
suffix:semicolon
id|ds-&gt;window
op_assign
(paren
id|Bytef
op_star
)paren
id|ZALLOC
c_func
(paren
id|dest
comma
id|ds-&gt;w_size
comma
l_int|2
op_star
r_sizeof
(paren
id|Byte
)paren
)paren
suffix:semicolon
id|ds-&gt;prev
op_assign
(paren
id|Posf
op_star
)paren
id|ZALLOC
c_func
(paren
id|dest
comma
id|ds-&gt;w_size
comma
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|ds-&gt;head
op_assign
(paren
id|Posf
op_star
)paren
id|ZALLOC
c_func
(paren
id|dest
comma
id|ds-&gt;hash_size
comma
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|overlay
op_assign
(paren
id|ushf
op_star
)paren
id|ZALLOC
c_func
(paren
id|dest
comma
id|ds-&gt;lit_bufsize
comma
r_sizeof
(paren
id|ush
)paren
op_plus
l_int|2
)paren
suffix:semicolon
id|ds-&gt;pending_buf
op_assign
(paren
id|uchf
op_star
)paren
id|overlay
suffix:semicolon
r_if
c_cond
(paren
id|ds-&gt;window
op_eq
id|Z_NULL
op_logical_or
id|ds-&gt;prev
op_eq
id|Z_NULL
op_logical_or
id|ds-&gt;head
op_eq
id|Z_NULL
op_logical_or
id|ds-&gt;pending_buf
op_eq
id|Z_NULL
)paren
(brace
id|deflateEnd
(paren
id|dest
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
)brace
multiline_comment|/* ??? following zmemcpy doesn&squot;t work for 16-bit MSDOS */
id|zmemcpy
c_func
(paren
id|ds-&gt;window
comma
id|ss-&gt;window
comma
id|ds-&gt;w_size
op_star
l_int|2
op_star
r_sizeof
(paren
id|Byte
)paren
)paren
suffix:semicolon
id|zmemcpy
c_func
(paren
id|ds-&gt;prev
comma
id|ss-&gt;prev
comma
id|ds-&gt;w_size
op_star
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|zmemcpy
c_func
(paren
id|ds-&gt;head
comma
id|ss-&gt;head
comma
id|ds-&gt;hash_size
op_star
r_sizeof
(paren
id|Pos
)paren
)paren
suffix:semicolon
id|zmemcpy
c_func
(paren
id|ds-&gt;pending_buf
comma
id|ss-&gt;pending_buf
comma
(paren
id|uInt
)paren
id|ds-&gt;pending_buf_size
)paren
suffix:semicolon
id|ds-&gt;pending_out
op_assign
id|ds-&gt;pending_buf
op_plus
(paren
id|ss-&gt;pending_out
op_minus
id|ss-&gt;pending_buf
)paren
suffix:semicolon
id|ds-&gt;d_buf
op_assign
id|overlay
op_plus
id|ds-&gt;lit_bufsize
op_div
r_sizeof
(paren
id|ush
)paren
suffix:semicolon
id|ds-&gt;l_buf
op_assign
id|ds-&gt;pending_buf
op_plus
(paren
l_int|1
op_plus
r_sizeof
(paren
id|ush
)paren
)paren
op_star
id|ds-&gt;lit_bufsize
suffix:semicolon
id|ds-&gt;l_desc.dyn_tree
op_assign
id|ds-&gt;dyn_ltree
suffix:semicolon
id|ds-&gt;d_desc.dyn_tree
op_assign
id|ds-&gt;dyn_dtree
suffix:semicolon
id|ds-&gt;bl_desc.dyn_tree
op_assign
id|ds-&gt;bl_tree
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Return the number of bytes of output which are immediately available&n; * for output from the decompressor.&n; */
DECL|function|deflateOutputPending
r_int
id|deflateOutputPending
(paren
id|strm
)paren
id|z_streamp
id|strm
suffix:semicolon
(brace
r_if
c_cond
(paren
id|strm
op_eq
id|Z_NULL
op_logical_or
id|strm-&gt;state
op_eq
id|Z_NULL
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
(paren
id|deflate_state
op_star
)paren
(paren
id|strm-&gt;state
)paren
)paren
op_member_access_from_pointer
id|pending
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Read a new buffer from the current input stream, update the adler32&n; * and total number of bytes read.  All deflate() input goes through&n; * this function so some applications may wish to modify it to avoid&n; * allocating a large strm-&gt;next_in buffer and copying from it.&n; * (See also flush_pending()).&n; */
DECL|function|read_buf
id|local
r_int
id|read_buf
c_func
(paren
id|strm
comma
id|buf
comma
id|size
)paren
id|z_streamp
id|strm
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
r_int
id|size
suffix:semicolon
(brace
r_int
id|len
op_assign
id|strm-&gt;avail_in
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|size
)paren
id|len
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|strm-&gt;avail_in
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|deflate_state
op_star
)paren
(paren
id|strm-&gt;state
)paren
)paren
op_member_access_from_pointer
id|noheader
)paren
(brace
id|strm-&gt;adler
op_assign
id|adler32
c_func
(paren
id|strm-&gt;adler
comma
id|strm-&gt;next_in
comma
id|len
)paren
suffix:semicolon
)brace
id|zmemcpy
c_func
(paren
id|buf
comma
id|strm-&gt;next_in
comma
id|len
)paren
suffix:semicolon
id|strm-&gt;next_in
op_add_assign
id|len
suffix:semicolon
id|strm-&gt;total_in
op_add_assign
id|len
suffix:semicolon
r_return
(paren
r_int
)paren
id|len
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Initialize the &quot;longest match&quot; routines for a new zlib stream&n; */
DECL|function|lm_init
id|local
r_void
id|lm_init
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|s-&gt;window_size
op_assign
(paren
id|ulg
)paren
l_int|2L
op_star
id|s-&gt;w_size
suffix:semicolon
id|CLEAR_HASH
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Set the default configuration parameters:&n;     */
id|s-&gt;max_lazy_match
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|max_lazy
suffix:semicolon
id|s-&gt;good_match
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|good_length
suffix:semicolon
id|s-&gt;nice_match
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|nice_length
suffix:semicolon
id|s-&gt;max_chain_length
op_assign
id|configuration_table
(braket
id|s-&gt;level
)braket
dot
id|max_chain
suffix:semicolon
id|s-&gt;strstart
op_assign
l_int|0
suffix:semicolon
id|s-&gt;block_start
op_assign
l_int|0L
suffix:semicolon
id|s-&gt;lookahead
op_assign
l_int|0
suffix:semicolon
id|s-&gt;match_length
op_assign
id|s-&gt;prev_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
id|s-&gt;match_available
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ins_h
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef ASMV
id|match_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize the asm code */
macro_line|#endif
)brace
multiline_comment|/* ===========================================================================&n; * Set match_start to the longest match starting at the given string and&n; * return its length. Matches shorter or equal to prev_length are discarded,&n; * in which case the result is equal to prev_length and match_start is&n; * garbage.&n; * IN assertions: cur_match is the head of the hash chain for the current&n; *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1&n; * OUT assertion: the match length is not greater than s-&gt;lookahead.&n; */
macro_line|#ifndef ASMV
multiline_comment|/* For 80x86 and 680x0, an optimized version will be provided in match.asm or&n; * match.S. The code will be functionally equivalent.&n; */
DECL|function|longest_match
id|local
id|uInt
id|longest_match
c_func
(paren
id|s
comma
id|cur_match
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|IPos
id|cur_match
suffix:semicolon
multiline_comment|/* current match */
(brace
r_int
id|chain_length
op_assign
id|s-&gt;max_chain_length
suffix:semicolon
multiline_comment|/* max hash chain length */
r_register
id|Bytef
op_star
id|scan
op_assign
id|s-&gt;window
op_plus
id|s-&gt;strstart
suffix:semicolon
multiline_comment|/* current string */
r_register
id|Bytef
op_star
id|match
suffix:semicolon
multiline_comment|/* matched string */
r_register
r_int
id|len
suffix:semicolon
multiline_comment|/* length of current match */
r_int
id|best_len
op_assign
id|s-&gt;prev_length
suffix:semicolon
multiline_comment|/* best match length so far */
r_int
id|nice_match
op_assign
id|s-&gt;nice_match
suffix:semicolon
multiline_comment|/* stop if match long enough */
id|IPos
id|limit
op_assign
id|s-&gt;strstart
OG
(paren
id|IPos
)paren
id|MAX_DIST
c_func
(paren
id|s
)paren
ques
c_cond
id|s-&gt;strstart
op_minus
(paren
id|IPos
)paren
id|MAX_DIST
c_func
(paren
id|s
)paren
suffix:colon
id|NIL
suffix:semicolon
multiline_comment|/* Stop when cur_match becomes &lt;= limit. To simplify the code,&n;     * we prevent matches with the string of window index 0.&n;     */
id|Posf
op_star
id|prev
op_assign
id|s-&gt;prev
suffix:semicolon
id|uInt
id|wmask
op_assign
id|s-&gt;w_mask
suffix:semicolon
macro_line|#ifdef UNALIGNED_OK
multiline_comment|/* Compare two bytes at a time. Note: this is not always beneficial.&n;     * Try with and without -DUNALIGNED_OK to check.&n;     */
r_register
id|Bytef
op_star
id|strend
op_assign
id|s-&gt;window
op_plus
id|s-&gt;strstart
op_plus
id|MAX_MATCH
op_minus
l_int|1
suffix:semicolon
r_register
id|ush
id|scan_start
op_assign
op_star
(paren
id|ushf
op_star
)paren
id|scan
suffix:semicolon
r_register
id|ush
id|scan_end
op_assign
op_star
(paren
id|ushf
op_star
)paren
(paren
id|scan
op_plus
id|best_len
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_register
id|Bytef
op_star
id|strend
op_assign
id|s-&gt;window
op_plus
id|s-&gt;strstart
op_plus
id|MAX_MATCH
suffix:semicolon
r_register
id|Byte
id|scan_end1
op_assign
id|scan
(braket
id|best_len
op_minus
l_int|1
)braket
suffix:semicolon
r_register
id|Byte
id|scan_end
op_assign
id|scan
(braket
id|best_len
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.&n;     * It is easy to get rid of this optimization if necessary.&n;     */
id|Assert
c_func
(paren
id|s-&gt;hash_bits
op_ge
l_int|8
op_logical_and
id|MAX_MATCH
op_eq
l_int|258
comma
l_string|&quot;Code too clever&quot;
)paren
suffix:semicolon
multiline_comment|/* Do not waste too much time if we already have a good match: */
r_if
c_cond
(paren
id|s-&gt;prev_length
op_ge
id|s-&gt;good_match
)paren
(brace
id|chain_length
op_rshift_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Do not look for matches beyond the end of the input. This is necessary&n;     * to make deflate deterministic.&n;     */
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|nice_match
OG
id|s-&gt;lookahead
)paren
id|nice_match
op_assign
id|s-&gt;lookahead
suffix:semicolon
id|Assert
c_func
(paren
(paren
id|ulg
)paren
id|s-&gt;strstart
op_le
id|s-&gt;window_size
op_minus
id|MIN_LOOKAHEAD
comma
l_string|&quot;need lookahead&quot;
)paren
suffix:semicolon
r_do
(brace
id|Assert
c_func
(paren
id|cur_match
OL
id|s-&gt;strstart
comma
l_string|&quot;no future&quot;
)paren
suffix:semicolon
id|match
op_assign
id|s-&gt;window
op_plus
id|cur_match
suffix:semicolon
multiline_comment|/* Skip to next match if the match length cannot increase&n;         * or if the match length is less than 2:&n;         */
macro_line|#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)
multiline_comment|/* This code assumes sizeof(unsigned short) == 2. Do not use&n;         * UNALIGNED_OK if your compiler uses a different size.&n;         */
r_if
c_cond
(paren
op_star
(paren
id|ushf
op_star
)paren
(paren
id|match
op_plus
id|best_len
op_minus
l_int|1
)paren
op_ne
id|scan_end
op_logical_or
op_star
(paren
id|ushf
op_star
)paren
id|match
op_ne
id|scan_start
)paren
r_continue
suffix:semicolon
multiline_comment|/* It is not necessary to compare scan[2] and match[2] since they are&n;         * always equal when the other bytes match, given that the hash keys&n;         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at&n;         * strstart+3, +5, ... up to strstart+257. We check for insufficient&n;         * lookahead only every 4th comparison; the 128th check will be made&n;         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is&n;         * necessary to put more guard bytes at the end of the window, or&n;         * to check more often for insufficient lookahead.&n;         */
id|Assert
c_func
(paren
id|scan
(braket
l_int|2
)braket
op_eq
id|match
(braket
l_int|2
)braket
comma
l_string|&quot;scan[2]?&quot;
)paren
suffix:semicolon
id|scan
op_increment
comma
id|match
op_increment
suffix:semicolon
r_do
(brace
)brace
r_while
c_loop
(paren
op_star
(paren
id|ushf
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ushf
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
op_star
(paren
id|ushf
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ushf
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
op_star
(paren
id|ushf
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ushf
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
op_star
(paren
id|ushf
op_star
)paren
(paren
id|scan
op_add_assign
l_int|2
)paren
op_eq
op_star
(paren
id|ushf
op_star
)paren
(paren
id|match
op_add_assign
l_int|2
)paren
op_logical_and
id|scan
OL
id|strend
)paren
suffix:semicolon
multiline_comment|/* The funny &quot;do {}&quot; generates better code on most compilers */
multiline_comment|/* Here, scan &lt;= window+strstart+257 */
id|Assert
c_func
(paren
id|scan
op_le
id|s-&gt;window
op_plus
(paren
r_int
)paren
(paren
id|s-&gt;window_size
op_minus
l_int|1
)paren
comma
l_string|&quot;wild scan&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|scan
op_eq
op_star
id|match
)paren
id|scan
op_increment
suffix:semicolon
id|len
op_assign
(paren
id|MAX_MATCH
op_minus
l_int|1
)paren
op_minus
(paren
r_int
)paren
(paren
id|strend
op_minus
id|scan
)paren
suffix:semicolon
id|scan
op_assign
id|strend
op_minus
(paren
id|MAX_MATCH
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#else /* UNALIGNED_OK */
r_if
c_cond
(paren
id|match
(braket
id|best_len
)braket
op_ne
id|scan_end
op_logical_or
id|match
(braket
id|best_len
op_minus
l_int|1
)braket
op_ne
id|scan_end1
op_logical_or
op_star
id|match
op_ne
op_star
id|scan
op_logical_or
op_star
op_increment
id|match
op_ne
id|scan
(braket
l_int|1
)braket
)paren
r_continue
suffix:semicolon
multiline_comment|/* The check at best_len-1 can be removed because it will be made&n;         * again later. (This heuristic is not always a win.)&n;         * It is not necessary to compare scan[2] and match[2] since they&n;         * are always equal when the other bytes match, given that&n;         * the hash keys are equal and that HASH_BITS &gt;= 8.&n;         */
id|scan
op_add_assign
l_int|2
comma
id|match
op_increment
suffix:semicolon
id|Assert
c_func
(paren
op_star
id|scan
op_eq
op_star
id|match
comma
l_string|&quot;match[2]?&quot;
)paren
suffix:semicolon
multiline_comment|/* We check for insufficient lookahead only every 8th comparison;&n;         * the 256th check will be made at strstart+258.&n;         */
r_do
(brace
)brace
r_while
c_loop
(paren
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
op_star
op_increment
id|scan
op_eq
op_star
op_increment
id|match
op_logical_and
id|scan
OL
id|strend
)paren
suffix:semicolon
id|Assert
c_func
(paren
id|scan
op_le
id|s-&gt;window
op_plus
(paren
r_int
)paren
(paren
id|s-&gt;window_size
op_minus
l_int|1
)paren
comma
l_string|&quot;wild scan&quot;
)paren
suffix:semicolon
id|len
op_assign
id|MAX_MATCH
op_minus
(paren
r_int
)paren
(paren
id|strend
op_minus
id|scan
)paren
suffix:semicolon
id|scan
op_assign
id|strend
op_minus
id|MAX_MATCH
suffix:semicolon
macro_line|#endif /* UNALIGNED_OK */
r_if
c_cond
(paren
id|len
OG
id|best_len
)paren
(brace
id|s-&gt;match_start
op_assign
id|cur_match
suffix:semicolon
id|best_len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|nice_match
)paren
r_break
suffix:semicolon
macro_line|#ifdef UNALIGNED_OK
id|scan_end
op_assign
op_star
(paren
id|ushf
op_star
)paren
(paren
id|scan
op_plus
id|best_len
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#else
id|scan_end1
op_assign
id|scan
(braket
id|best_len
op_minus
l_int|1
)braket
suffix:semicolon
id|scan_end
op_assign
id|scan
(braket
id|best_len
)braket
suffix:semicolon
macro_line|#endif
)brace
)brace
r_while
c_loop
(paren
(paren
id|cur_match
op_assign
id|prev
(braket
id|cur_match
op_amp
id|wmask
)braket
)paren
OG
id|limit
op_logical_and
op_decrement
id|chain_length
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|best_len
op_le
id|s-&gt;lookahead
)paren
r_return
id|best_len
suffix:semicolon
r_return
id|s-&gt;lookahead
suffix:semicolon
)brace
macro_line|#endif /* ASMV */
macro_line|#ifdef DEBUG_ZLIB
multiline_comment|/* ===========================================================================&n; * Check that the match at match_start is indeed a match.&n; */
DECL|function|check_match
id|local
r_void
id|check_match
c_func
(paren
id|s
comma
id|start
comma
id|match
comma
id|length
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|IPos
id|start
comma
id|match
suffix:semicolon
r_int
id|length
suffix:semicolon
(brace
multiline_comment|/* check that the match is indeed a match */
r_if
c_cond
(paren
id|zmemcmp
c_func
(paren
(paren
id|charf
op_star
)paren
id|s-&gt;window
op_plus
id|match
comma
(paren
id|charf
op_star
)paren
id|s-&gt;window
op_plus
id|start
comma
id|length
)paren
op_ne
id|EQUAL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; start %u, match %u, length %d&bslash;n&quot;
comma
id|start
comma
id|match
comma
id|length
)paren
suffix:semicolon
r_do
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%c%c&quot;
comma
id|s-&gt;window
(braket
id|match
op_increment
)braket
comma
id|s-&gt;window
(braket
id|start
op_increment
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|length
op_ne
l_int|0
)paren
suffix:semicolon
id|z_error
c_func
(paren
l_string|&quot;invalid match&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|z_verbose
OG
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;&bslash;[%d,%d]&quot;
comma
id|start
op_minus
id|match
comma
id|length
)paren
suffix:semicolon
r_do
(brace
id|putc
c_func
(paren
id|s-&gt;window
(braket
id|start
op_increment
)braket
comma
id|stderr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|length
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|check_match
macro_line|#  define check_match(s, start, match, length)
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Fill the window when the lookahead becomes insufficient.&n; * Updates strstart and lookahead.&n; *&n; * IN assertion: lookahead &lt; MIN_LOOKAHEAD&n; * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD&n; *    At least one byte has been read, or avail_in == 0; reads are&n; *    performed for at least two bytes (required for the zip translate_eol&n; *    option -- not supported here).&n; */
DECL|function|fill_window
id|local
r_void
id|fill_window
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_register
r_int
id|n
comma
id|m
suffix:semicolon
r_register
id|Posf
op_star
id|p
suffix:semicolon
r_int
id|more
suffix:semicolon
multiline_comment|/* Amount of free space at the end of the window. */
id|uInt
id|wsize
op_assign
id|s-&gt;w_size
suffix:semicolon
r_do
(brace
id|more
op_assign
(paren
r_int
)paren
(paren
id|s-&gt;window_size
op_minus
(paren
id|ulg
)paren
id|s-&gt;lookahead
op_minus
(paren
id|ulg
)paren
id|s-&gt;strstart
)paren
suffix:semicolon
multiline_comment|/* Deal with !@#$% 64K limit: */
r_if
c_cond
(paren
id|more
op_eq
l_int|0
op_logical_and
id|s-&gt;strstart
op_eq
l_int|0
op_logical_and
id|s-&gt;lookahead
op_eq
l_int|0
)paren
(brace
id|more
op_assign
id|wsize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|more
op_eq
(paren
r_int
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Very unlikely, but possible on 16 bit machine if strstart == 0&n;             * and lookahead == 1 (input done one byte at time)&n;             */
id|more
op_decrement
suffix:semicolon
multiline_comment|/* If the window is almost full and there is insufficient lookahead,&n;         * move the upper half to the lower one to make room in the upper half.&n;         */
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;strstart
op_ge
id|wsize
op_plus
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
id|zmemcpy
c_func
(paren
(paren
id|charf
op_star
)paren
id|s-&gt;window
comma
(paren
id|charf
op_star
)paren
id|s-&gt;window
op_plus
id|wsize
comma
(paren
r_int
)paren
id|wsize
)paren
suffix:semicolon
id|s-&gt;match_start
op_sub_assign
id|wsize
suffix:semicolon
id|s-&gt;strstart
op_sub_assign
id|wsize
suffix:semicolon
multiline_comment|/* we now have strstart &gt;= MAX_DIST */
id|s-&gt;block_start
op_sub_assign
(paren
r_int
)paren
id|wsize
suffix:semicolon
multiline_comment|/* Slide the hash table (could be avoided with 32 bit values&n;               at the expense of memory usage). We slide even when level == 0&n;               to keep the hash table consistent if we switch back to level &gt; 0&n;               later. (Using level 0 permanently is not an optimal usage of&n;               zlib, so we don&squot;t care about this pathological case.)&n;             */
id|n
op_assign
id|s-&gt;hash_size
suffix:semicolon
id|p
op_assign
op_amp
id|s-&gt;head
(braket
id|n
)braket
suffix:semicolon
r_do
(brace
id|m
op_assign
op_star
op_decrement
id|p
suffix:semicolon
op_star
id|p
op_assign
(paren
id|Pos
)paren
(paren
id|m
op_ge
id|wsize
ques
c_cond
id|m
op_minus
id|wsize
suffix:colon
id|NIL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|n
)paren
suffix:semicolon
id|n
op_assign
id|wsize
suffix:semicolon
id|p
op_assign
op_amp
id|s-&gt;prev
(braket
id|n
)braket
suffix:semicolon
r_do
(brace
id|m
op_assign
op_star
op_decrement
id|p
suffix:semicolon
op_star
id|p
op_assign
(paren
id|Pos
)paren
(paren
id|m
op_ge
id|wsize
ques
c_cond
id|m
op_minus
id|wsize
suffix:colon
id|NIL
)paren
suffix:semicolon
multiline_comment|/* If n is not on any hash chain, prev[n] is garbage but&n;                 * its value will never be used.&n;                 */
)brace
r_while
c_loop
(paren
op_decrement
id|n
)paren
suffix:semicolon
id|more
op_add_assign
id|wsize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;strm-&gt;avail_in
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* If there was no sliding:&n;         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;&n;         *    more == window_size - lookahead - strstart&n;         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)&n;         * =&gt; more &gt;= window_size - 2*WSIZE + 2&n;         * In the BIG_MEM or MMAP case (not yet supported),&n;         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;&n;         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.&n;         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.&n;         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.&n;         */
id|Assert
c_func
(paren
id|more
op_ge
l_int|2
comma
l_string|&quot;more &lt; 2&quot;
)paren
suffix:semicolon
id|n
op_assign
id|read_buf
c_func
(paren
id|s-&gt;strm
comma
(paren
id|charf
op_star
)paren
id|s-&gt;window
op_plus
id|s-&gt;strstart
op_plus
id|s-&gt;lookahead
comma
id|more
)paren
suffix:semicolon
id|s-&gt;lookahead
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Initialize the hash value now that we have some input: */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|s-&gt;ins_h
op_assign
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
suffix:semicolon
id|UPDATE_HASH
c_func
(paren
id|s
comma
id|s-&gt;ins_h
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_plus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if MIN_MATCH != 3
id|Call
id|UPDATE_HASH
c_func
(paren
)paren
id|MIN_MATCH
op_minus
l_int|3
id|more
id|times
macro_line|#endif
)brace
multiline_comment|/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,&n;         * but this is not important since only literal bytes will be emitted.&n;         */
)brace
r_while
c_loop
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
op_logical_and
id|s-&gt;strm-&gt;avail_in
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Flush the current block, with given end-of-file flag.&n; * IN assertion: strstart is set to the end of the current match.&n; */
DECL|macro|FLUSH_BLOCK_ONLY
mdefine_line|#define FLUSH_BLOCK_ONLY(s, eof) { &bslash;&n;   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? &bslash;&n;                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : &bslash;&n;                   (charf *)Z_NULL), &bslash;&n;&t;&t;(ulg)((long)s-&gt;strstart - s-&gt;block_start), &bslash;&n;&t;&t;(eof)); &bslash;&n;   s-&gt;block_start = s-&gt;strstart; &bslash;&n;   flush_pending(s-&gt;strm); &bslash;&n;   Tracev((stderr,&quot;[FLUSH]&quot;)); &bslash;&n;}
multiline_comment|/* Same but force premature exit if necessary. */
DECL|macro|FLUSH_BLOCK
mdefine_line|#define FLUSH_BLOCK(s, eof) { &bslash;&n;   FLUSH_BLOCK_ONLY(s, eof); &bslash;&n;   if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; &bslash;&n;}
multiline_comment|/* ===========================================================================&n; * Copy without compression as much as possible from the input stream, return&n; * the current block state.&n; * This function does not insert new strings in the dictionary since&n; * uncompressible data is probably not useful. This function is used&n; * only for the level=0 compression option.&n; * NOTE: this function should be optimized to avoid extra copying from&n; * window to pending_buf.&n; */
DECL|function|deflate_stored
id|local
id|block_state
id|deflate_stored
c_func
(paren
id|s
comma
id|flush
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|flush
suffix:semicolon
(brace
multiline_comment|/* Stored blocks are limited to 0xffff bytes, pending_buf is limited&n;     * to pending_buf_size, and each stored block has a 5 byte header:&n;     */
id|ulg
id|max_block_size
op_assign
l_int|0xffff
suffix:semicolon
id|ulg
id|max_start
suffix:semicolon
r_if
c_cond
(paren
id|max_block_size
OG
id|s-&gt;pending_buf_size
op_minus
l_int|5
)paren
(brace
id|max_block_size
op_assign
id|s-&gt;pending_buf_size
op_minus
l_int|5
suffix:semicolon
)brace
multiline_comment|/* Copy as much as possible from input to output: */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Fill the window as much as possible: */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_le
l_int|1
)paren
(brace
id|Assert
c_func
(paren
id|s-&gt;strstart
OL
id|s-&gt;w_size
op_plus
id|MAX_DIST
c_func
(paren
id|s
)paren
op_logical_or
id|s-&gt;block_start
op_ge
(paren
r_int
)paren
id|s-&gt;w_size
comma
l_string|&quot;slide too late&quot;
)paren
suffix:semicolon
id|fill_window
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
op_logical_and
id|flush
op_eq
id|Z_NO_FLUSH
)paren
r_return
id|need_more
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* flush the current block */
)brace
id|Assert
c_func
(paren
id|s-&gt;block_start
op_ge
l_int|0L
comma
l_string|&quot;block gone&quot;
)paren
suffix:semicolon
id|s-&gt;strstart
op_add_assign
id|s-&gt;lookahead
suffix:semicolon
id|s-&gt;lookahead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Emit a stored block if pending_buf will be full: */
id|max_start
op_assign
id|s-&gt;block_start
op_plus
id|max_block_size
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;strstart
op_eq
l_int|0
op_logical_or
(paren
id|ulg
)paren
id|s-&gt;strstart
op_ge
id|max_start
)paren
(brace
multiline_comment|/* strstart == 0 is possible when wraparound on 16-bit machine */
id|s-&gt;lookahead
op_assign
(paren
id|uInt
)paren
(paren
id|s-&gt;strstart
op_minus
id|max_start
)paren
suffix:semicolon
id|s-&gt;strstart
op_assign
(paren
id|uInt
)paren
id|max_start
suffix:semicolon
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush if we may have to slide, otherwise block_start may become&n;         * negative and the data will be gone:&n;         */
r_if
c_cond
(paren
id|s-&gt;strstart
op_minus
(paren
id|uInt
)paren
id|s-&gt;block_start
op_ge
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
id|flush
op_eq
id|Z_FINISH
)paren
suffix:semicolon
r_return
id|flush
op_eq
id|Z_FINISH
ques
c_cond
id|finish_done
suffix:colon
id|block_done
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Compress as much as possible from the input stream, return the current&n; * block state.&n; * This function does not perform lazy evaluation of matches and inserts&n; * new strings in the dictionary only for unmatched strings or for short&n; * matches. It is used only for the fast compression options.&n; */
DECL|function|deflate_fast
id|local
id|block_state
id|deflate_fast
c_func
(paren
id|s
comma
id|flush
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|flush
suffix:semicolon
(brace
id|IPos
id|hash_head
op_assign
id|NIL
suffix:semicolon
multiline_comment|/* head of the hash chain */
r_int
id|bflush
suffix:semicolon
multiline_comment|/* set if current block must be flushed */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Make sure that we always have enough lookahead, except&n;         * at the end of the input file. We need MAX_MATCH bytes&n;         * for the next match, plus MIN_MATCH bytes to insert the&n;         * string following the next match.&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
)paren
(brace
id|fill_window
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
op_logical_and
id|flush
op_eq
id|Z_NO_FLUSH
)paren
(brace
r_return
id|need_more
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* flush the current block */
)brace
multiline_comment|/* Insert the string window[strstart .. strstart+2] in the&n;         * dictionary, and set hash_head to the head of the hash chain:&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the longest match, discarding those &lt;= prev_length.&n;         * At this point we have always match_length &lt; MIN_MATCH&n;         */
r_if
c_cond
(paren
id|hash_head
op_ne
id|NIL
op_logical_and
id|s-&gt;strstart
op_minus
id|hash_head
op_le
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* To simplify the code, we prevent matches with the string&n;             * of window index 0 (in particular we have to avoid a match&n;             * of the string with itself at the start of the input file).&n;             */
r_if
c_cond
(paren
id|s-&gt;strategy
op_ne
id|Z_HUFFMAN_ONLY
)paren
(brace
id|s-&gt;match_length
op_assign
id|longest_match
(paren
id|s
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* longest_match() sets match_start */
)brace
r_if
c_cond
(paren
id|s-&gt;match_length
op_ge
id|MIN_MATCH
)paren
(brace
id|check_match
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|s-&gt;match_start
comma
id|s-&gt;match_length
)paren
suffix:semicolon
id|bflush
op_assign
id|_tr_tally
c_func
(paren
id|s
comma
id|s-&gt;strstart
op_minus
id|s-&gt;match_start
comma
id|s-&gt;match_length
op_minus
id|MIN_MATCH
)paren
suffix:semicolon
id|s-&gt;lookahead
op_sub_assign
id|s-&gt;match_length
suffix:semicolon
multiline_comment|/* Insert new strings in the hash table only if the match length&n;             * is not too large. This saves time but degrades compression.&n;             */
r_if
c_cond
(paren
id|s-&gt;match_length
op_le
id|s-&gt;max_insert_length
op_logical_and
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|s-&gt;match_length
op_decrement
suffix:semicolon
multiline_comment|/* string at strstart already in hash table */
r_do
(brace
id|s-&gt;strstart
op_increment
suffix:semicolon
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
multiline_comment|/* strstart never exceeds WSIZE-MAX_MATCH, so there are&n;                     * always MIN_MATCH bytes ahead.&n;                     */
)brace
r_while
c_loop
(paren
op_decrement
id|s-&gt;match_length
op_ne
l_int|0
)paren
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;strstart
op_add_assign
id|s-&gt;match_length
suffix:semicolon
id|s-&gt;match_length
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ins_h
op_assign
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
suffix:semicolon
id|UPDATE_HASH
c_func
(paren
id|s
comma
id|s-&gt;ins_h
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_plus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if MIN_MATCH != 3
id|Call
id|UPDATE_HASH
c_func
(paren
)paren
id|MIN_MATCH
op_minus
l_int|3
id|more
id|times
macro_line|#endif
multiline_comment|/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not&n;                 * matter since it will be recomputed at next deflate call.&n;                 */
)brace
)brace
r_else
(brace
multiline_comment|/* No match, output a literal byte */
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
)paren
)paren
suffix:semicolon
id|bflush
op_assign
id|_tr_tally
(paren
id|s
comma
l_int|0
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
)braket
)paren
suffix:semicolon
id|s-&gt;lookahead
op_decrement
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bflush
)paren
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
id|flush
op_eq
id|Z_FINISH
)paren
suffix:semicolon
r_return
id|flush
op_eq
id|Z_FINISH
ques
c_cond
id|finish_done
suffix:colon
id|block_done
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Same as above, but achieves better compression. We use a lazy&n; * evaluation for matches: a match is finally adopted only if there is&n; * no better match at the next window position.&n; */
DECL|function|deflate_slow
id|local
id|block_state
id|deflate_slow
c_func
(paren
id|s
comma
id|flush
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|flush
suffix:semicolon
(brace
id|IPos
id|hash_head
op_assign
id|NIL
suffix:semicolon
multiline_comment|/* head of hash chain */
r_int
id|bflush
suffix:semicolon
multiline_comment|/* set if current block must be flushed */
multiline_comment|/* Process the input block. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Make sure that we always have enough lookahead, except&n;         * at the end of the input file. We need MAX_MATCH bytes&n;         * for the next match, plus MIN_MATCH bytes to insert the&n;         * string following the next match.&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
)paren
(brace
id|fill_window
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;lookahead
OL
id|MIN_LOOKAHEAD
op_logical_and
id|flush
op_eq
id|Z_NO_FLUSH
)paren
(brace
r_return
id|need_more
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;lookahead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* flush the current block */
)brace
multiline_comment|/* Insert the string window[strstart .. strstart+2] in the&n;         * dictionary, and set hash_head to the head of the hash chain:&n;         */
r_if
c_cond
(paren
id|s-&gt;lookahead
op_ge
id|MIN_MATCH
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the longest match, discarding those &lt;= prev_length.&n;         */
id|s-&gt;prev_length
op_assign
id|s-&gt;match_length
comma
id|s-&gt;prev_match
op_assign
id|s-&gt;match_start
suffix:semicolon
id|s-&gt;match_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hash_head
op_ne
id|NIL
op_logical_and
id|s-&gt;prev_length
OL
id|s-&gt;max_lazy_match
op_logical_and
id|s-&gt;strstart
op_minus
id|hash_head
op_le
id|MAX_DIST
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* To simplify the code, we prevent matches with the string&n;             * of window index 0 (in particular we have to avoid a match&n;             * of the string with itself at the start of the input file).&n;             */
r_if
c_cond
(paren
id|s-&gt;strategy
op_ne
id|Z_HUFFMAN_ONLY
)paren
(brace
id|s-&gt;match_length
op_assign
id|longest_match
(paren
id|s
comma
id|hash_head
)paren
suffix:semicolon
)brace
multiline_comment|/* longest_match() sets match_start */
r_if
c_cond
(paren
id|s-&gt;match_length
op_le
l_int|5
op_logical_and
(paren
id|s-&gt;strategy
op_eq
id|Z_FILTERED
op_logical_or
(paren
id|s-&gt;match_length
op_eq
id|MIN_MATCH
op_logical_and
id|s-&gt;strstart
op_minus
id|s-&gt;match_start
OG
id|TOO_FAR
)paren
)paren
)paren
(brace
multiline_comment|/* If prev_match is also MIN_MATCH, match_start is garbage&n;                 * but we will ignore the current match anyway.&n;                 */
id|s-&gt;match_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* If there was a match at the previous step and the current&n;         * match is not better, output the previous match:&n;         */
r_if
c_cond
(paren
id|s-&gt;prev_length
op_ge
id|MIN_MATCH
op_logical_and
id|s-&gt;match_length
op_le
id|s-&gt;prev_length
)paren
(brace
id|uInt
id|max_insert
op_assign
id|s-&gt;strstart
op_plus
id|s-&gt;lookahead
op_minus
id|MIN_MATCH
suffix:semicolon
multiline_comment|/* Do not insert strings in hash table beyond this. */
id|check_match
c_func
(paren
id|s
comma
id|s-&gt;strstart
op_minus
l_int|1
comma
id|s-&gt;prev_match
comma
id|s-&gt;prev_length
)paren
suffix:semicolon
id|bflush
op_assign
id|_tr_tally
c_func
(paren
id|s
comma
id|s-&gt;strstart
op_minus
l_int|1
op_minus
id|s-&gt;prev_match
comma
id|s-&gt;prev_length
op_minus
id|MIN_MATCH
)paren
suffix:semicolon
multiline_comment|/* Insert in hash table all strings up to the end of the match.&n;             * strstart-1 and strstart are already inserted. If there is not&n;             * enough lookahead, the last two strings are not inserted in&n;             * the hash table.&n;             */
id|s-&gt;lookahead
op_sub_assign
id|s-&gt;prev_length
op_minus
l_int|1
suffix:semicolon
id|s-&gt;prev_length
op_sub_assign
l_int|2
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_increment
id|s-&gt;strstart
op_le
id|max_insert
)paren
(brace
id|INSERT_STRING
c_func
(paren
id|s
comma
id|s-&gt;strstart
comma
id|hash_head
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|s-&gt;prev_length
op_ne
l_int|0
)paren
suffix:semicolon
id|s-&gt;match_available
op_assign
l_int|0
suffix:semicolon
id|s-&gt;match_length
op_assign
id|MIN_MATCH
op_minus
l_int|1
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bflush
)paren
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;match_available
)paren
(brace
multiline_comment|/* If there was no match at the previous position, output a&n;             * single literal. If there was a match but the current match&n;             * is longer, truncate the previous match to a single literal.&n;             */
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_tr_tally
(paren
id|s
comma
l_int|0
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
)paren
(brace
id|FLUSH_BLOCK_ONLY
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
)brace
id|s-&gt;strstart
op_increment
suffix:semicolon
id|s-&gt;lookahead
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;strm-&gt;avail_out
op_eq
l_int|0
)paren
r_return
id|need_more
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is no previous match to compare with, wait for&n;             * the next step to decide.&n;             */
id|s-&gt;match_available
op_assign
l_int|1
suffix:semicolon
id|s-&gt;strstart
op_increment
suffix:semicolon
id|s-&gt;lookahead
op_decrement
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|flush
op_ne
id|Z_NO_FLUSH
comma
l_string|&quot;no flush?&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;match_available
)paren
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|_tr_tally
(paren
id|s
comma
l_int|0
comma
id|s-&gt;window
(braket
id|s-&gt;strstart
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|s-&gt;match_available
op_assign
l_int|0
suffix:semicolon
)brace
id|FLUSH_BLOCK
c_func
(paren
id|s
comma
id|flush
op_eq
id|Z_FINISH
)paren
suffix:semicolon
r_return
id|flush
op_eq
id|Z_FINISH
ques
c_cond
id|finish_done
suffix:colon
id|block_done
suffix:semicolon
)brace
multiline_comment|/* --- deflate.c */
multiline_comment|/* +++ trees.c */
multiline_comment|/* trees.c -- output deflated data using Huffman coding&n; * Copyright (C) 1995-1996 Jean-loup Gailly&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/*&n; *  ALGORITHM&n; *&n; *      The &quot;deflation&quot; process uses several Huffman trees. The more&n; *      common source values are represented by shorter bit sequences.&n; *&n; *      Each code tree is stored in a compressed form which is itself&n; * a Huffman encoding of the lengths of all the code strings (in&n; * ascending order by source values).  The actual code strings are&n; * reconstructed from the lengths in the inflate process, as described&n; * in the deflate specification.&n; *&n; *  REFERENCES&n; *&n; *      Deutsch, L.P.,&quot;&squot;Deflate&squot; Compressed Data Format Specification&quot;.&n; *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc&n; *&n; *      Storer, James A.&n; *          Data Compression:  Methods and Theory, pp. 49-50.&n; *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.&n; *&n; *      Sedgewick, R.&n; *          Algorithms, p290.&n; *          Addison-Wesley, 1983. ISBN 0-201-06672-6.&n; */
multiline_comment|/* From: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */
multiline_comment|/* #include &quot;deflate.h&quot; */
macro_line|#ifdef DEBUG_ZLIB
macro_line|#  include &lt;ctype.h&gt;
macro_line|#endif
multiline_comment|/* ===========================================================================&n; * Constants&n; */
DECL|macro|MAX_BL_BITS
mdefine_line|#define MAX_BL_BITS 7
multiline_comment|/* Bit length codes must not exceed MAX_BL_BITS bits */
DECL|macro|END_BLOCK
mdefine_line|#define END_BLOCK 256
multiline_comment|/* end of block literal code */
DECL|macro|REP_3_6
mdefine_line|#define REP_3_6      16
multiline_comment|/* repeat previous bit length 3-6 times (2 bits of repeat count) */
DECL|macro|REPZ_3_10
mdefine_line|#define REPZ_3_10    17
multiline_comment|/* repeat a zero length 3-10 times  (3 bits of repeat count) */
DECL|macro|REPZ_11_138
mdefine_line|#define REPZ_11_138  18
multiline_comment|/* repeat a zero length 11-138 times  (7 bits of repeat count) */
DECL|variable|extra_lbits
id|local
r_int
id|extra_lbits
(braket
id|LENGTH_CODES
)braket
multiline_comment|/* extra bits for each length code */
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|extra_dbits
id|local
r_int
id|extra_dbits
(braket
id|D_CODES
)braket
multiline_comment|/* extra bits for each distance code */
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|6
comma
l_int|6
comma
l_int|7
comma
l_int|7
comma
l_int|8
comma
l_int|8
comma
l_int|9
comma
l_int|9
comma
l_int|10
comma
l_int|10
comma
l_int|11
comma
l_int|11
comma
l_int|12
comma
l_int|12
comma
l_int|13
comma
l_int|13
)brace
suffix:semicolon
DECL|variable|extra_blbits
id|local
r_int
id|extra_blbits
(braket
id|BL_CODES
)braket
multiline_comment|/* extra bits for each bit length code */
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|3
comma
l_int|7
)brace
suffix:semicolon
DECL|variable|bl_order
id|local
id|uch
id|bl_order
(braket
id|BL_CODES
)braket
op_assign
(brace
l_int|16
comma
l_int|17
comma
l_int|18
comma
l_int|0
comma
l_int|8
comma
l_int|7
comma
l_int|9
comma
l_int|6
comma
l_int|10
comma
l_int|5
comma
l_int|11
comma
l_int|4
comma
l_int|12
comma
l_int|3
comma
l_int|13
comma
l_int|2
comma
l_int|14
comma
l_int|1
comma
l_int|15
)brace
suffix:semicolon
multiline_comment|/* The lengths of the bit length codes are sent in order of decreasing&n; * probability, to avoid transmitting the lengths for unused bit length codes.&n; */
DECL|macro|Buf_size
mdefine_line|#define Buf_size (8 * 2*sizeof(char))
multiline_comment|/* Number of bits used within bi_buf. (bi_buf might be implemented on&n; * more than 16 bits on some systems.)&n; */
multiline_comment|/* ===========================================================================&n; * Local data. These are initialized only once.&n; */
DECL|variable|static_ltree
id|local
id|ct_data
id|static_ltree
(braket
id|L_CODES
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* The static literal tree. Since the bit lengths are imposed, there is no&n; * need for the L_CODES extra codes used during heap construction. However&n; * The codes 286 and 287 are needed to build a canonical tree (see _tr_init&n; * below).&n; */
DECL|variable|static_dtree
id|local
id|ct_data
id|static_dtree
(braket
id|D_CODES
)braket
suffix:semicolon
multiline_comment|/* The static distance tree. (Actually a trivial tree since all codes use&n; * 5 bits.)&n; */
DECL|variable|dist_code
id|local
id|uch
id|dist_code
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* distance codes. The first 256 values correspond to the distances&n; * 3 .. 258, the last 256 values correspond to the top 8 bits of&n; * the 15 bit distances.&n; */
DECL|variable|length_code
id|local
id|uch
id|length_code
(braket
id|MAX_MATCH
op_minus
id|MIN_MATCH
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* length code for each normalized match length (0 == MIN_MATCH) */
DECL|variable|base_length
id|local
r_int
id|base_length
(braket
id|LENGTH_CODES
)braket
suffix:semicolon
multiline_comment|/* First normalized length for each code (0 = MIN_MATCH) */
DECL|variable|base_dist
id|local
r_int
id|base_dist
(braket
id|D_CODES
)braket
suffix:semicolon
multiline_comment|/* First normalized distance for each code (0 = distance of 1) */
DECL|struct|static_tree_desc_s
r_struct
id|static_tree_desc_s
(brace
DECL|member|static_tree
id|ct_data
op_star
id|static_tree
suffix:semicolon
multiline_comment|/* static tree or NULL */
DECL|member|extra_bits
id|intf
op_star
id|extra_bits
suffix:semicolon
multiline_comment|/* extra bits for each code or NULL */
DECL|member|extra_base
r_int
id|extra_base
suffix:semicolon
multiline_comment|/* base index for extra_bits */
DECL|member|elems
r_int
id|elems
suffix:semicolon
multiline_comment|/* max number of elements in the tree */
DECL|member|max_length
r_int
id|max_length
suffix:semicolon
multiline_comment|/* max bit length for the codes */
)brace
suffix:semicolon
DECL|variable|static_l_desc
id|local
id|static_tree_desc
id|static_l_desc
op_assign
(brace
id|static_ltree
comma
id|extra_lbits
comma
id|LITERALS
op_plus
l_int|1
comma
id|L_CODES
comma
id|MAX_BITS
)brace
suffix:semicolon
DECL|variable|static_d_desc
id|local
id|static_tree_desc
id|static_d_desc
op_assign
(brace
id|static_dtree
comma
id|extra_dbits
comma
l_int|0
comma
id|D_CODES
comma
id|MAX_BITS
)brace
suffix:semicolon
DECL|variable|static_bl_desc
id|local
id|static_tree_desc
id|static_bl_desc
op_assign
(brace
(paren
id|ct_data
op_star
)paren
l_int|0
comma
id|extra_blbits
comma
l_int|0
comma
id|BL_CODES
comma
id|MAX_BL_BITS
)brace
suffix:semicolon
multiline_comment|/* ===========================================================================&n; * Local (static) routines in this file.&n; */
id|local
r_void
id|tr_static_init
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
id|local
r_void
id|init_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|pqdownheap
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|tree
comma
r_int
id|k
)paren
)paren
suffix:semicolon
id|local
r_void
id|gen_bitlen
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|tree_desc
op_star
id|desc
)paren
)paren
suffix:semicolon
id|local
r_void
id|gen_codes
id|OF
c_func
(paren
(paren
id|ct_data
op_star
id|tree
comma
r_int
id|max_code
comma
id|ushf
op_star
id|bl_count
)paren
)paren
suffix:semicolon
id|local
r_void
id|build_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|tree_desc
op_star
id|desc
)paren
)paren
suffix:semicolon
id|local
r_void
id|scan_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|tree
comma
r_int
id|max_code
)paren
)paren
suffix:semicolon
id|local
r_void
id|send_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|tree
comma
r_int
id|max_code
)paren
)paren
suffix:semicolon
id|local
r_int
id|build_bl_tree
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|send_all_trees
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|lcodes
comma
r_int
id|dcodes
comma
r_int
id|blcodes
)paren
)paren
suffix:semicolon
id|local
r_void
id|compress_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|ct_data
op_star
id|ltree
comma
id|ct_data
op_star
id|dtree
)paren
)paren
suffix:semicolon
id|local
r_void
id|set_data_type
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_int
id|bi_reverse
id|OF
c_func
(paren
(paren
r_int
id|value
comma
r_int
id|length
)paren
)paren
suffix:semicolon
id|local
r_void
id|bi_windup
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|bi_flush
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
)paren
)paren
suffix:semicolon
id|local
r_void
id|copy_block
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
id|charf
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|header
)paren
)paren
suffix:semicolon
macro_line|#ifndef DEBUG_ZLIB
DECL|macro|send_code
macro_line|#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
multiline_comment|/* Send a code of the given tree. c and tree must not have side effects */
macro_line|#else /* DEBUG_ZLIB */
DECL|macro|send_code
macro_line|#  define send_code(s, c, tree) &bslash;&n;     { if (verbose&gt;2) fprintf(stderr,&quot;&bslash;ncd %3d &quot;,(c)); &bslash;&n;       send_bits(s, tree[c].Code, tree[c].Len); }
macro_line|#endif
DECL|macro|d_code
mdefine_line|#define d_code(dist) &bslash;&n;   ((dist) &lt; 256 ? dist_code[dist] : dist_code[256+((dist)&gt;&gt;7)])
multiline_comment|/* Mapping from a distance to a distance code. dist is the distance - 1 and&n; * must not have side effects. dist_code[256] and dist_code[257] are never&n; * used.&n; */
multiline_comment|/* ===========================================================================&n; * Output a short LSB first on the stream.&n; * IN assertion: there is enough room in pendingBuf.&n; */
DECL|macro|put_short
mdefine_line|#define put_short(s, w) { &bslash;&n;    put_byte(s, (uch)((w) &amp; 0xff)); &bslash;&n;    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); &bslash;&n;}
multiline_comment|/* ===========================================================================&n; * Send a value on a given number of bits.&n; * IN assertion: length &lt;= 16 and value fits in length bits.&n; */
macro_line|#ifdef DEBUG_ZLIB
id|local
r_void
id|send_bits
id|OF
c_func
(paren
(paren
id|deflate_state
op_star
id|s
comma
r_int
id|value
comma
r_int
id|length
)paren
)paren
suffix:semicolon
DECL|function|send_bits
id|local
r_void
id|send_bits
c_func
(paren
id|s
comma
id|value
comma
id|length
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|value
suffix:semicolon
multiline_comment|/* value to send */
r_int
id|length
suffix:semicolon
multiline_comment|/* number of bits */
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot; l %2d v %4x &quot;
comma
id|length
comma
id|value
)paren
)paren
suffix:semicolon
id|Assert
c_func
(paren
id|length
OG
l_int|0
op_logical_and
id|length
op_le
l_int|15
comma
l_string|&quot;invalid length&quot;
)paren
suffix:semicolon
id|s-&gt;bits_sent
op_add_assign
(paren
id|ulg
)paren
id|length
suffix:semicolon
multiline_comment|/* If not enough room in bi_buf, use (valid) bits from bi_buf and&n;     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))&n;     * unused bits in value.&n;     */
r_if
c_cond
(paren
id|s-&gt;bi_valid
OG
(paren
r_int
)paren
id|Buf_size
op_minus
id|length
)paren
(brace
id|s-&gt;bi_buf
op_or_assign
(paren
id|value
op_lshift
id|s-&gt;bi_valid
)paren
suffix:semicolon
id|put_short
c_func
(paren
id|s
comma
id|s-&gt;bi_buf
)paren
suffix:semicolon
id|s-&gt;bi_buf
op_assign
(paren
id|ush
)paren
id|value
op_rshift
(paren
id|Buf_size
op_minus
id|s-&gt;bi_valid
)paren
suffix:semicolon
id|s-&gt;bi_valid
op_add_assign
id|length
op_minus
id|Buf_size
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;bi_buf
op_or_assign
id|value
op_lshift
id|s-&gt;bi_valid
suffix:semicolon
id|s-&gt;bi_valid
op_add_assign
id|length
suffix:semicolon
)brace
)brace
macro_line|#else /* !DEBUG_ZLIB */
DECL|macro|send_bits
mdefine_line|#define send_bits(s, value, length) &bslash;&n;{ int len = length;&bslash;&n;  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {&bslash;&n;    int val = value;&bslash;&n;    s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);&bslash;&n;    put_short(s, s-&gt;bi_buf);&bslash;&n;    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);&bslash;&n;    s-&gt;bi_valid += len - Buf_size;&bslash;&n;  } else {&bslash;&n;    s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;&bslash;&n;    s-&gt;bi_valid += len;&bslash;&n;  }&bslash;&n;}
macro_line|#endif /* DEBUG_ZLIB */
DECL|macro|MAX
mdefine_line|#define MAX(a,b) (a &gt;= b ? a : b)
multiline_comment|/* the arguments must not have side effects */
multiline_comment|/* ===========================================================================&n; * Initialize the various &squot;constant&squot; tables. In a multi-threaded environment,&n; * this function may be called by two threads concurrently, but this is&n; * harmless since both invocations do exactly the same thing.&n; */
DECL|function|tr_static_init
id|local
r_void
id|tr_static_init
c_func
(paren
)paren
(brace
r_static
r_int
id|static_init_done
op_assign
l_int|0
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over tree elements */
r_int
id|bits
suffix:semicolon
multiline_comment|/* bit counter */
r_int
id|length
suffix:semicolon
multiline_comment|/* length value */
r_int
id|code
suffix:semicolon
multiline_comment|/* code value */
r_int
id|dist
suffix:semicolon
multiline_comment|/* distance index */
id|ush
id|bl_count
(braket
id|MAX_BITS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* number of codes at each bit length for an optimal tree */
r_if
c_cond
(paren
id|static_init_done
)paren
r_return
suffix:semicolon
multiline_comment|/* Initialize the mapping length (0..255) -&gt; length code (0..28) */
id|length
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|code
op_assign
l_int|0
suffix:semicolon
id|code
OL
id|LENGTH_CODES
op_minus
l_int|1
suffix:semicolon
id|code
op_increment
)paren
(brace
id|base_length
(braket
id|code
)braket
op_assign
id|length
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
(paren
l_int|1
op_lshift
id|extra_lbits
(braket
id|code
)braket
)paren
suffix:semicolon
id|n
op_increment
)paren
(brace
id|length_code
(braket
id|length
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|length
op_eq
l_int|256
comma
l_string|&quot;tr_static_init: length != 256&quot;
)paren
suffix:semicolon
multiline_comment|/* Note that the length 255 (match length 258) can be represented&n;     * in two different ways: code 284 + 5 bits or code 285, so we&n;     * overwrite length_code[255] to use the best encoding:&n;     */
id|length_code
(braket
id|length
op_minus
l_int|1
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
multiline_comment|/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */
id|dist
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|code
op_assign
l_int|0
suffix:semicolon
id|code
OL
l_int|16
suffix:semicolon
id|code
op_increment
)paren
(brace
id|base_dist
(braket
id|code
)braket
op_assign
id|dist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
(paren
l_int|1
op_lshift
id|extra_dbits
(braket
id|code
)braket
)paren
suffix:semicolon
id|n
op_increment
)paren
(brace
id|dist_code
(braket
id|dist
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|dist
op_eq
l_int|256
comma
l_string|&quot;tr_static_init: dist != 256&quot;
)paren
suffix:semicolon
id|dist
op_rshift_assign
l_int|7
suffix:semicolon
multiline_comment|/* from now on, all distances are divided by 128 */
r_for
c_loop
(paren
suffix:semicolon
id|code
OL
id|D_CODES
suffix:semicolon
id|code
op_increment
)paren
(brace
id|base_dist
(braket
id|code
)braket
op_assign
id|dist
op_lshift
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
(paren
l_int|1
op_lshift
(paren
id|extra_dbits
(braket
id|code
)braket
op_minus
l_int|7
)paren
)paren
suffix:semicolon
id|n
op_increment
)paren
(brace
id|dist_code
(braket
l_int|256
op_plus
id|dist
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|code
suffix:semicolon
)brace
)brace
id|Assert
(paren
id|dist
op_eq
l_int|256
comma
l_string|&quot;tr_static_init: 256+dist != 512&quot;
)paren
suffix:semicolon
multiline_comment|/* Construct the codes of the static literal tree */
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|bits
op_le
id|MAX_BITS
suffix:semicolon
id|bits
op_increment
)paren
id|bl_count
(braket
id|bits
)braket
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|143
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|8
comma
id|bl_count
(braket
l_int|8
)braket
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|255
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|9
comma
id|bl_count
(braket
l_int|9
)braket
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|279
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|7
comma
id|bl_count
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|n
op_le
l_int|287
)paren
id|static_ltree
(braket
id|n
op_increment
)braket
dot
id|Len
op_assign
l_int|8
comma
id|bl_count
(braket
l_int|8
)braket
op_increment
suffix:semicolon
multiline_comment|/* Codes 286 and 287 do not exist, but we must include them in the&n;     * tree construction to get a canonical Huffman tree (longest code&n;     * all ones)&n;     */
id|gen_codes
c_func
(paren
(paren
id|ct_data
op_star
)paren
id|static_ltree
comma
id|L_CODES
op_plus
l_int|1
comma
id|bl_count
)paren
suffix:semicolon
multiline_comment|/* The static distance tree is trivial: */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|D_CODES
suffix:semicolon
id|n
op_increment
)paren
(brace
id|static_dtree
(braket
id|n
)braket
dot
id|Len
op_assign
l_int|5
suffix:semicolon
id|static_dtree
(braket
id|n
)braket
dot
id|Code
op_assign
id|bi_reverse
c_func
(paren
(paren
r_int
)paren
id|n
comma
l_int|5
)paren
suffix:semicolon
)brace
id|static_init_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Initialize the tree data structures for a new zlib stream.&n; */
DECL|function|_tr_init
r_void
id|_tr_init
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|tr_static_init
c_func
(paren
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_assign
l_int|0L
suffix:semicolon
id|s-&gt;l_desc.dyn_tree
op_assign
id|s-&gt;dyn_ltree
suffix:semicolon
id|s-&gt;l_desc.stat_desc
op_assign
op_amp
id|static_l_desc
suffix:semicolon
id|s-&gt;d_desc.dyn_tree
op_assign
id|s-&gt;dyn_dtree
suffix:semicolon
id|s-&gt;d_desc.stat_desc
op_assign
op_amp
id|static_d_desc
suffix:semicolon
id|s-&gt;bl_desc.dyn_tree
op_assign
id|s-&gt;bl_tree
suffix:semicolon
id|s-&gt;bl_desc.stat_desc
op_assign
op_amp
id|static_bl_desc
suffix:semicolon
id|s-&gt;bi_buf
op_assign
l_int|0
suffix:semicolon
id|s-&gt;bi_valid
op_assign
l_int|0
suffix:semicolon
id|s-&gt;last_eob_len
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* enough lookahead for inflate */
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_assign
l_int|0L
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the first block of the first file: */
id|init_block
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Initialize a new block.&n; */
DECL|function|init_block
id|local
r_void
id|init_block
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over tree elements */
multiline_comment|/* Initialize the trees. */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|L_CODES
suffix:semicolon
id|n
op_increment
)paren
id|s-&gt;dyn_ltree
(braket
id|n
)braket
dot
id|Freq
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|D_CODES
suffix:semicolon
id|n
op_increment
)paren
id|s-&gt;dyn_dtree
(braket
id|n
)braket
dot
id|Freq
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|BL_CODES
suffix:semicolon
id|n
op_increment
)paren
id|s-&gt;bl_tree
(braket
id|n
)braket
dot
id|Freq
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dyn_ltree
(braket
id|END_BLOCK
)braket
dot
id|Freq
op_assign
l_int|1
suffix:semicolon
id|s-&gt;opt_len
op_assign
id|s-&gt;static_len
op_assign
l_int|0L
suffix:semicolon
id|s-&gt;last_lit
op_assign
id|s-&gt;matches
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|SMALLEST
mdefine_line|#define SMALLEST 1
multiline_comment|/* Index within the heap array of least frequent node in the Huffman tree */
multiline_comment|/* ===========================================================================&n; * Remove the smallest element from the heap and recreate the heap with&n; * one less element. Updates heap and heap_len.&n; */
DECL|macro|pqremove
mdefine_line|#define pqremove(s, tree, top) &bslash;&n;{&bslash;&n;    top = s-&gt;heap[SMALLEST]; &bslash;&n;    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; &bslash;&n;    pqdownheap(s, tree, SMALLEST); &bslash;&n;}
multiline_comment|/* ===========================================================================&n; * Compares to subtrees, using the tree depth as tie breaker when&n; * the subtrees have equal frequency. This minimizes the worst case length.&n; */
DECL|macro|smaller
mdefine_line|#define smaller(tree, n, m, depth) &bslash;&n;   (tree[n].Freq &lt; tree[m].Freq || &bslash;&n;   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))
multiline_comment|/* ===========================================================================&n; * Restore the heap property by moving down the tree starting at node k,&n; * exchanging a node with the smallest of its two sons if necessary, stopping&n; * when the heap property is re-established (each father smaller than its&n; * two sons).&n; */
DECL|function|pqdownheap
id|local
r_void
id|pqdownheap
c_func
(paren
id|s
comma
id|tree
comma
id|k
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to restore */
r_int
id|k
suffix:semicolon
multiline_comment|/* node to move down */
(brace
r_int
id|v
op_assign
id|s-&gt;heap
(braket
id|k
)braket
suffix:semicolon
r_int
id|j
op_assign
id|k
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* left son of k */
r_while
c_loop
(paren
id|j
op_le
id|s-&gt;heap_len
)paren
(brace
multiline_comment|/* Set j to the smallest of the two sons: */
r_if
c_cond
(paren
id|j
OL
id|s-&gt;heap_len
op_logical_and
id|smaller
c_func
(paren
id|tree
comma
id|s-&gt;heap
(braket
id|j
op_plus
l_int|1
)braket
comma
id|s-&gt;heap
(braket
id|j
)braket
comma
id|s-&gt;depth
)paren
)paren
(brace
id|j
op_increment
suffix:semicolon
)brace
multiline_comment|/* Exit if v is smaller than both sons */
r_if
c_cond
(paren
id|smaller
c_func
(paren
id|tree
comma
id|v
comma
id|s-&gt;heap
(braket
id|j
)braket
comma
id|s-&gt;depth
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Exchange v with the smallest son */
id|s-&gt;heap
(braket
id|k
)braket
op_assign
id|s-&gt;heap
(braket
id|j
)braket
suffix:semicolon
id|k
op_assign
id|j
suffix:semicolon
multiline_comment|/* And continue down the tree, setting j to the left son of k */
id|j
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|s-&gt;heap
(braket
id|k
)braket
op_assign
id|v
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Compute the optimal bit lengths for a tree and update the total bit length&n; * for the current block.&n; * IN assertion: the fields freq and dad are set, heap[heap_max] and&n; *    above are the tree nodes sorted by increasing frequency.&n; * OUT assertions: the field len is set to the optimal bit length, the&n; *     array bl_count contains the frequencies for each bit length.&n; *     The length opt_len is updated; static_len is also updated if stree is&n; *     not null.&n; */
DECL|function|gen_bitlen
id|local
r_void
id|gen_bitlen
c_func
(paren
id|s
comma
id|desc
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|tree_desc
op_star
id|desc
suffix:semicolon
multiline_comment|/* the tree descriptor */
(brace
id|ct_data
op_star
id|tree
op_assign
id|desc-&gt;dyn_tree
suffix:semicolon
r_int
id|max_code
op_assign
id|desc-&gt;max_code
suffix:semicolon
id|ct_data
op_star
id|stree
op_assign
id|desc-&gt;stat_desc-&gt;static_tree
suffix:semicolon
id|intf
op_star
id|extra
op_assign
id|desc-&gt;stat_desc-&gt;extra_bits
suffix:semicolon
r_int
id|base
op_assign
id|desc-&gt;stat_desc-&gt;extra_base
suffix:semicolon
r_int
id|max_length
op_assign
id|desc-&gt;stat_desc-&gt;max_length
suffix:semicolon
r_int
id|h
suffix:semicolon
multiline_comment|/* heap index */
r_int
id|n
comma
id|m
suffix:semicolon
multiline_comment|/* iterate over the tree elements */
r_int
id|bits
suffix:semicolon
multiline_comment|/* bit length */
r_int
id|xbits
suffix:semicolon
multiline_comment|/* extra bits */
id|ush
id|f
suffix:semicolon
multiline_comment|/* frequency */
r_int
id|overflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of elements with bit length too large */
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|bits
op_le
id|MAX_BITS
suffix:semicolon
id|bits
op_increment
)paren
id|s-&gt;bl_count
(braket
id|bits
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* In a first pass, compute the optimal bit lengths (which may&n;     * overflow in the case of the bit length tree).&n;     */
id|tree
(braket
id|s-&gt;heap
(braket
id|s-&gt;heap_max
)braket
)braket
dot
id|Len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* root of the heap */
r_for
c_loop
(paren
id|h
op_assign
id|s-&gt;heap_max
op_plus
l_int|1
suffix:semicolon
id|h
OL
id|HEAP_SIZE
suffix:semicolon
id|h
op_increment
)paren
(brace
id|n
op_assign
id|s-&gt;heap
(braket
id|h
)braket
suffix:semicolon
id|bits
op_assign
id|tree
(braket
id|tree
(braket
id|n
)braket
dot
id|Dad
)braket
dot
id|Len
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bits
OG
id|max_length
)paren
id|bits
op_assign
id|max_length
comma
id|overflow
op_increment
suffix:semicolon
id|tree
(braket
id|n
)braket
dot
id|Len
op_assign
(paren
id|ush
)paren
id|bits
suffix:semicolon
multiline_comment|/* We overwrite tree[n].Dad which is no longer needed */
r_if
c_cond
(paren
id|n
OG
id|max_code
)paren
r_continue
suffix:semicolon
multiline_comment|/* not a leaf node */
id|s-&gt;bl_count
(braket
id|bits
)braket
op_increment
suffix:semicolon
id|xbits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|base
)paren
id|xbits
op_assign
id|extra
(braket
id|n
op_minus
id|base
)braket
suffix:semicolon
id|f
op_assign
id|tree
(braket
id|n
)braket
dot
id|Freq
suffix:semicolon
id|s-&gt;opt_len
op_add_assign
(paren
id|ulg
)paren
id|f
op_star
(paren
id|bits
op_plus
id|xbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stree
)paren
id|s-&gt;static_len
op_add_assign
(paren
id|ulg
)paren
id|f
op_star
(paren
id|stree
(braket
id|n
)braket
dot
id|Len
op_plus
id|xbits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|overflow
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbit length overflow&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* This happens for example on obj2 and pic of the Calgary corpus */
multiline_comment|/* Find the first bit length which could increase: */
r_do
(brace
id|bits
op_assign
id|max_length
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;bl_count
(braket
id|bits
)braket
op_eq
l_int|0
)paren
id|bits
op_decrement
suffix:semicolon
id|s-&gt;bl_count
(braket
id|bits
)braket
op_decrement
suffix:semicolon
multiline_comment|/* move one leaf down the tree */
id|s-&gt;bl_count
(braket
id|bits
op_plus
l_int|1
)braket
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* move one overflow item as its brother */
id|s-&gt;bl_count
(braket
id|max_length
)braket
op_decrement
suffix:semicolon
multiline_comment|/* The brother of the overflow item also moves one step up,&n;         * but this does not affect bl_count[max_length]&n;         */
id|overflow
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|overflow
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Now recompute all bit lengths, scanning in increasing frequency.&n;     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all&n;     * lengths instead of fixing only the wrong ones. This idea is taken&n;     * from &squot;ar&squot; written by Haruhiko Okumura.)&n;     */
r_for
c_loop
(paren
id|bits
op_assign
id|max_length
suffix:semicolon
id|bits
op_ne
l_int|0
suffix:semicolon
id|bits
op_decrement
)paren
(brace
id|n
op_assign
id|s-&gt;bl_count
(braket
id|bits
)braket
suffix:semicolon
r_while
c_loop
(paren
id|n
op_ne
l_int|0
)paren
(brace
id|m
op_assign
id|s-&gt;heap
(braket
op_decrement
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
id|max_code
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tree
(braket
id|m
)braket
dot
id|Len
op_ne
(paren
r_int
)paren
id|bits
)paren
(brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;code %d bits %d-&gt;%d&bslash;n&quot;
comma
id|m
comma
id|tree
(braket
id|m
)braket
dot
id|Len
comma
id|bits
)paren
)paren
suffix:semicolon
id|s-&gt;opt_len
op_add_assign
(paren
(paren
r_int
)paren
id|bits
op_minus
(paren
r_int
)paren
id|tree
(braket
id|m
)braket
dot
id|Len
)paren
op_star
(paren
r_int
)paren
id|tree
(braket
id|m
)braket
dot
id|Freq
suffix:semicolon
id|tree
(braket
id|m
)braket
dot
id|Len
op_assign
(paren
id|ush
)paren
id|bits
suffix:semicolon
)brace
id|n
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Generate the codes for a given tree and bit counts (which need not be&n; * optimal).&n; * IN assertion: the array bl_count contains the bit length statistics for&n; * the given tree and the field len is set for all tree elements.&n; * OUT assertion: the field code is set for all tree elements of non&n; *     zero code length.&n; */
DECL|function|gen_codes
id|local
r_void
id|gen_codes
(paren
id|tree
comma
id|max_code
comma
id|bl_count
)paren
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to decorate */
r_int
id|max_code
suffix:semicolon
multiline_comment|/* largest code with non zero frequency */
id|ushf
op_star
id|bl_count
suffix:semicolon
multiline_comment|/* number of codes at each bit length */
(brace
id|ush
id|next_code
(braket
id|MAX_BITS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* next code value for each bit length */
id|ush
id|code
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* running code value */
r_int
id|bits
suffix:semicolon
multiline_comment|/* bit index */
r_int
id|n
suffix:semicolon
multiline_comment|/* code index */
multiline_comment|/* The distribution counts are first used to generate the code values&n;     * without bit reversal.&n;     */
r_for
c_loop
(paren
id|bits
op_assign
l_int|1
suffix:semicolon
id|bits
op_le
id|MAX_BITS
suffix:semicolon
id|bits
op_increment
)paren
(brace
id|next_code
(braket
id|bits
)braket
op_assign
id|code
op_assign
(paren
id|code
op_plus
id|bl_count
(braket
id|bits
op_minus
l_int|1
)braket
)paren
op_lshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check that the bit counts in bl_count are consistent. The last code&n;     * must be all ones.&n;     */
id|Assert
(paren
id|code
op_plus
id|bl_count
(braket
id|MAX_BITS
)braket
op_minus
l_int|1
op_eq
(paren
l_int|1
op_lshift
id|MAX_BITS
)paren
op_minus
l_int|1
comma
l_string|&quot;inconsistent bit counts&quot;
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ngen_codes: max_code %d &quot;
comma
id|max_code
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|max_code
suffix:semicolon
id|n
op_increment
)paren
(brace
r_int
id|len
op_assign
id|tree
(braket
id|n
)braket
dot
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Now reverse the bits */
id|tree
(braket
id|n
)braket
dot
id|Code
op_assign
id|bi_reverse
c_func
(paren
id|next_code
(braket
id|len
)braket
op_increment
comma
id|len
)paren
suffix:semicolon
id|Tracecv
c_func
(paren
id|tree
op_ne
id|static_ltree
comma
(paren
id|stderr
comma
l_string|&quot;&bslash;nn %3d %c l %2d c %4x (%x) &quot;
comma
id|n
comma
(paren
id|isgraph
c_func
(paren
id|n
)paren
ques
c_cond
id|n
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|len
comma
id|tree
(braket
id|n
)braket
dot
id|Code
comma
id|next_code
(braket
id|len
)braket
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Construct one Huffman tree and assigns the code bit strings and lengths.&n; * Update the total bit length for the current block.&n; * IN assertion: the field freq is set for all tree elements.&n; * OUT assertions: the fields len and code are set to the optimal bit length&n; *     and corresponding code. The length opt_len is updated; static_len is&n; *     also updated if stree is not null. The field max_code is set.&n; */
DECL|function|build_tree
id|local
r_void
id|build_tree
c_func
(paren
id|s
comma
id|desc
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|tree_desc
op_star
id|desc
suffix:semicolon
multiline_comment|/* the tree descriptor */
(brace
id|ct_data
op_star
id|tree
op_assign
id|desc-&gt;dyn_tree
suffix:semicolon
id|ct_data
op_star
id|stree
op_assign
id|desc-&gt;stat_desc-&gt;static_tree
suffix:semicolon
r_int
id|elems
op_assign
id|desc-&gt;stat_desc-&gt;elems
suffix:semicolon
r_int
id|n
comma
id|m
suffix:semicolon
multiline_comment|/* iterate over heap elements */
r_int
id|max_code
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* largest code with non zero frequency */
r_int
id|node
suffix:semicolon
multiline_comment|/* new node being created */
multiline_comment|/* Construct the initial heap, with least frequent element in&n;     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].&n;     * heap[0] is not used.&n;     */
id|s-&gt;heap_len
op_assign
l_int|0
comma
id|s-&gt;heap_max
op_assign
id|HEAP_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|elems
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tree
(braket
id|n
)braket
dot
id|Freq
op_ne
l_int|0
)paren
(brace
id|s-&gt;heap
(braket
op_increment
(paren
id|s-&gt;heap_len
)paren
)braket
op_assign
id|max_code
op_assign
id|n
suffix:semicolon
id|s-&gt;depth
(braket
id|n
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tree
(braket
id|n
)braket
dot
id|Len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* The pkzip format requires that at least one distance code exists,&n;     * and that at least one bit should be sent even if there is only one&n;     * possible code. So to avoid special checks later on we force at least&n;     * two codes of non zero frequency.&n;     */
r_while
c_loop
(paren
id|s-&gt;heap_len
OL
l_int|2
)paren
(brace
id|node
op_assign
id|s-&gt;heap
(braket
op_increment
(paren
id|s-&gt;heap_len
)paren
)braket
op_assign
(paren
id|max_code
OL
l_int|2
ques
c_cond
op_increment
id|max_code
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tree
(braket
id|node
)braket
dot
id|Freq
op_assign
l_int|1
suffix:semicolon
id|s-&gt;depth
(braket
id|node
)braket
op_assign
l_int|0
suffix:semicolon
id|s-&gt;opt_len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|stree
)paren
id|s-&gt;static_len
op_sub_assign
id|stree
(braket
id|node
)braket
dot
id|Len
suffix:semicolon
multiline_comment|/* node is 0 or 1 so it does not have extra bits */
)brace
id|desc-&gt;max_code
op_assign
id|max_code
suffix:semicolon
multiline_comment|/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,&n;     * establish sub-heaps of increasing lengths:&n;     */
r_for
c_loop
(paren
id|n
op_assign
id|s-&gt;heap_len
op_div
l_int|2
suffix:semicolon
id|n
op_ge
l_int|1
suffix:semicolon
id|n
op_decrement
)paren
id|pqdownheap
c_func
(paren
id|s
comma
id|tree
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* Construct the Huffman tree by repeatedly combining the least two&n;     * frequent nodes.&n;     */
id|node
op_assign
id|elems
suffix:semicolon
multiline_comment|/* next internal node of the tree */
r_do
(brace
id|pqremove
c_func
(paren
id|s
comma
id|tree
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* n = node of least frequency */
id|m
op_assign
id|s-&gt;heap
(braket
id|SMALLEST
)braket
suffix:semicolon
multiline_comment|/* m = node of next least frequency */
id|s-&gt;heap
(braket
op_decrement
(paren
id|s-&gt;heap_max
)paren
)braket
op_assign
id|n
suffix:semicolon
multiline_comment|/* keep the nodes sorted by frequency */
id|s-&gt;heap
(braket
op_decrement
(paren
id|s-&gt;heap_max
)paren
)braket
op_assign
id|m
suffix:semicolon
multiline_comment|/* Create a new node father of n and m */
id|tree
(braket
id|node
)braket
dot
id|Freq
op_assign
id|tree
(braket
id|n
)braket
dot
id|Freq
op_plus
id|tree
(braket
id|m
)braket
dot
id|Freq
suffix:semicolon
id|s-&gt;depth
(braket
id|node
)braket
op_assign
(paren
id|uch
)paren
(paren
id|MAX
c_func
(paren
id|s-&gt;depth
(braket
id|n
)braket
comma
id|s-&gt;depth
(braket
id|m
)braket
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|tree
(braket
id|n
)braket
dot
id|Dad
op_assign
id|tree
(braket
id|m
)braket
dot
id|Dad
op_assign
(paren
id|ush
)paren
id|node
suffix:semicolon
macro_line|#ifdef DUMP_BL_TREE
r_if
c_cond
(paren
id|tree
op_eq
id|s-&gt;bl_tree
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;nnode %d(%d), sons %d(%d) %d(%d)&quot;
comma
id|node
comma
id|tree
(braket
id|node
)braket
dot
id|Freq
comma
id|n
comma
id|tree
(braket
id|n
)braket
dot
id|Freq
comma
id|m
comma
id|tree
(braket
id|m
)braket
dot
id|Freq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* and insert the new node in the heap */
id|s-&gt;heap
(braket
id|SMALLEST
)braket
op_assign
id|node
op_increment
suffix:semicolon
id|pqdownheap
c_func
(paren
id|s
comma
id|tree
comma
id|SMALLEST
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|s-&gt;heap_len
op_ge
l_int|2
)paren
suffix:semicolon
id|s-&gt;heap
(braket
op_decrement
(paren
id|s-&gt;heap_max
)paren
)braket
op_assign
id|s-&gt;heap
(braket
id|SMALLEST
)braket
suffix:semicolon
multiline_comment|/* At this point, the fields freq and dad are set. We can now&n;     * generate the bit lengths.&n;     */
id|gen_bitlen
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
id|desc
)paren
suffix:semicolon
multiline_comment|/* The field len is now set, we can generate the bit codes */
id|gen_codes
(paren
(paren
id|ct_data
op_star
)paren
id|tree
comma
id|max_code
comma
id|s-&gt;bl_count
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Scan a literal or distance tree to determine the frequencies of the codes&n; * in the bit length tree.&n; */
DECL|function|scan_tree
id|local
r_void
id|scan_tree
(paren
id|s
comma
id|tree
comma
id|max_code
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to be scanned */
r_int
id|max_code
suffix:semicolon
multiline_comment|/* and its largest code of non zero frequency */
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over all tree elements */
r_int
id|prevlen
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* last emitted length */
r_int
id|curlen
suffix:semicolon
multiline_comment|/* length of current code */
r_int
id|nextlen
op_assign
id|tree
(braket
l_int|0
)braket
dot
id|Len
suffix:semicolon
multiline_comment|/* length of next code */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* repeat count of the current code */
r_int
id|max_count
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* max repeat count */
r_int
id|min_count
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* min repeat count */
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
id|tree
(braket
id|max_code
op_plus
l_int|1
)braket
dot
id|Len
op_assign
(paren
id|ush
)paren
l_int|0xffff
suffix:semicolon
multiline_comment|/* guard */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|max_code
suffix:semicolon
id|n
op_increment
)paren
(brace
id|curlen
op_assign
id|nextlen
suffix:semicolon
id|nextlen
op_assign
id|tree
(braket
id|n
op_plus
l_int|1
)braket
dot
id|Len
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
id|max_count
op_logical_and
id|curlen
op_eq
id|nextlen
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OL
id|min_count
)paren
(brace
id|s-&gt;bl_tree
(braket
id|curlen
)braket
dot
id|Freq
op_add_assign
id|count
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|curlen
op_ne
id|prevlen
)paren
id|s-&gt;bl_tree
(braket
id|curlen
)braket
dot
id|Freq
op_increment
suffix:semicolon
id|s-&gt;bl_tree
(braket
id|REP_3_6
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
op_le
l_int|10
)paren
(brace
id|s-&gt;bl_tree
(braket
id|REPZ_3_10
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;bl_tree
(braket
id|REPZ_11_138
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
id|prevlen
op_assign
id|curlen
suffix:semicolon
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
(brace
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_eq
id|nextlen
)paren
(brace
id|max_count
op_assign
l_int|6
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|max_count
op_assign
l_int|7
comma
id|min_count
op_assign
l_int|4
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Send a literal or distance tree in compressed form, using the codes in&n; * bl_tree.&n; */
DECL|function|send_tree
id|local
r_void
id|send_tree
(paren
id|s
comma
id|tree
comma
id|max_code
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|tree
suffix:semicolon
multiline_comment|/* the tree to be scanned */
r_int
id|max_code
suffix:semicolon
multiline_comment|/* and its largest code of non zero frequency */
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* iterates over all tree elements */
r_int
id|prevlen
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* last emitted length */
r_int
id|curlen
suffix:semicolon
multiline_comment|/* length of current code */
r_int
id|nextlen
op_assign
id|tree
(braket
l_int|0
)braket
dot
id|Len
suffix:semicolon
multiline_comment|/* length of next code */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* repeat count of the current code */
r_int
id|max_count
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* max repeat count */
r_int
id|min_count
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* min repeat count */
multiline_comment|/* tree[max_code+1].Len = -1; */
multiline_comment|/* guard already set */
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|max_code
suffix:semicolon
id|n
op_increment
)paren
(brace
id|curlen
op_assign
id|nextlen
suffix:semicolon
id|nextlen
op_assign
id|tree
(braket
id|n
op_plus
l_int|1
)braket
dot
id|Len
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
id|max_count
op_logical_and
id|curlen
op_eq
id|nextlen
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OL
id|min_count
)paren
(brace
r_do
(brace
id|send_code
c_func
(paren
id|s
comma
id|curlen
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|curlen
op_ne
id|prevlen
)paren
(brace
id|send_code
c_func
(paren
id|s
comma
id|curlen
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
id|Assert
c_func
(paren
id|count
op_ge
l_int|3
op_logical_and
id|count
op_le
l_int|6
comma
l_string|&quot; 3_6?&quot;
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|REP_3_6
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|count
op_minus
l_int|3
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
op_le
l_int|10
)paren
(brace
id|send_code
c_func
(paren
id|s
comma
id|REPZ_3_10
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|count
op_minus
l_int|3
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|send_code
c_func
(paren
id|s
comma
id|REPZ_11_138
comma
id|s-&gt;bl_tree
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|count
op_minus
l_int|11
comma
l_int|7
)paren
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
id|prevlen
op_assign
id|curlen
suffix:semicolon
r_if
c_cond
(paren
id|nextlen
op_eq
l_int|0
)paren
(brace
id|max_count
op_assign
l_int|138
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|curlen
op_eq
id|nextlen
)paren
(brace
id|max_count
op_assign
l_int|6
comma
id|min_count
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|max_count
op_assign
l_int|7
comma
id|min_count
op_assign
l_int|4
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Construct the Huffman tree for the bit lengths and return the index in&n; * bl_order of the last bit length code to send.&n; */
DECL|function|build_bl_tree
id|local
r_int
id|build_bl_tree
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_int
id|max_blindex
suffix:semicolon
multiline_comment|/* index of last bit length code of non zero freq */
multiline_comment|/* Determine the bit length frequencies for literal and distance trees */
id|scan_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_ltree
comma
id|s-&gt;l_desc.max_code
)paren
suffix:semicolon
id|scan_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_dtree
comma
id|s-&gt;d_desc.max_code
)paren
suffix:semicolon
multiline_comment|/* Build the bit length tree: */
id|build_tree
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
(paren
op_amp
(paren
id|s-&gt;bl_desc
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* opt_len now includes the length of the tree representations, except&n;     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.&n;     */
multiline_comment|/* Determine the number of bit length codes to send. The pkzip format&n;     * requires that at least 4 bit length codes be sent. (appnote.txt says&n;     * 3 but the actual value used is 4.)&n;     */
r_for
c_loop
(paren
id|max_blindex
op_assign
id|BL_CODES
op_minus
l_int|1
suffix:semicolon
id|max_blindex
op_ge
l_int|3
suffix:semicolon
id|max_blindex
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;bl_tree
(braket
id|bl_order
(braket
id|max_blindex
)braket
)braket
dot
id|Len
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Update opt_len to include the bit length tree and counts */
id|s-&gt;opt_len
op_add_assign
l_int|3
op_star
(paren
id|max_blindex
op_plus
l_int|1
)paren
op_plus
l_int|5
op_plus
l_int|5
op_plus
l_int|4
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ndyn trees: dyn %ld, stat %ld&quot;
comma
id|s-&gt;opt_len
comma
id|s-&gt;static_len
)paren
)paren
suffix:semicolon
r_return
id|max_blindex
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Send the header for a block using dynamic Huffman trees: the counts, the&n; * lengths of the bit length codes, the literal tree and the distance tree.&n; * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.&n; */
DECL|function|send_all_trees
id|local
r_void
id|send_all_trees
c_func
(paren
id|s
comma
id|lcodes
comma
id|dcodes
comma
id|blcodes
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|lcodes
comma
id|dcodes
comma
id|blcodes
suffix:semicolon
multiline_comment|/* number of codes for each tree */
(brace
r_int
id|rank
suffix:semicolon
multiline_comment|/* index in bl_order */
id|Assert
(paren
id|lcodes
op_ge
l_int|257
op_logical_and
id|dcodes
op_ge
l_int|1
op_logical_and
id|blcodes
op_ge
l_int|4
comma
l_string|&quot;not enough codes&quot;
)paren
suffix:semicolon
id|Assert
(paren
id|lcodes
op_le
id|L_CODES
op_logical_and
id|dcodes
op_le
id|D_CODES
op_logical_and
id|blcodes
op_le
id|BL_CODES
comma
l_string|&quot;too many codes&quot;
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbl counts: &quot;
)paren
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|lcodes
op_minus
l_int|257
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* not +255 as stated in appnote.txt */
id|send_bits
c_func
(paren
id|s
comma
id|dcodes
op_minus
l_int|1
comma
l_int|5
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|blcodes
op_minus
l_int|4
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* not -3 as stated in appnote.txt */
r_for
c_loop
(paren
id|rank
op_assign
l_int|0
suffix:semicolon
id|rank
OL
id|blcodes
suffix:semicolon
id|rank
op_increment
)paren
(brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbl code %2d &quot;
comma
id|bl_order
(braket
id|rank
)braket
)paren
)paren
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|s-&gt;bl_tree
(braket
id|bl_order
(braket
id|rank
)braket
)braket
dot
id|Len
comma
l_int|3
)paren
suffix:semicolon
)brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nbl tree: sent %ld&quot;
comma
id|s-&gt;bits_sent
)paren
)paren
suffix:semicolon
id|send_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_ltree
comma
id|lcodes
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* literal tree */
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nlit tree: sent %ld&quot;
comma
id|s-&gt;bits_sent
)paren
)paren
suffix:semicolon
id|send_tree
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_dtree
comma
id|dcodes
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* distance tree */
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ndist tree: sent %ld&quot;
comma
id|s-&gt;bits_sent
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Send a stored block&n; */
DECL|function|_tr_stored_block
r_void
id|_tr_stored_block
c_func
(paren
id|s
comma
id|buf
comma
id|stored_len
comma
id|eof
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
multiline_comment|/* input block */
id|ulg
id|stored_len
suffix:semicolon
multiline_comment|/* length of input block */
r_int
id|eof
suffix:semicolon
multiline_comment|/* true if this is the last block for a file */
(brace
id|send_bits
c_func
(paren
id|s
comma
(paren
id|STORED_BLOCK
op_lshift
l_int|1
)paren
op_plus
id|eof
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* send block type */
id|s-&gt;compressed_len
op_assign
(paren
id|s-&gt;compressed_len
op_plus
l_int|3
op_plus
l_int|7
)paren
op_amp
(paren
id|ulg
)paren
op_complement
l_int|7L
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
(paren
id|stored_len
op_plus
l_int|4
)paren
op_lshift
l_int|3
suffix:semicolon
id|copy_block
c_func
(paren
id|s
comma
id|buf
comma
(paren
r_int
)paren
id|stored_len
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* with header */
)brace
multiline_comment|/* Send just the `stored block&squot; type code without any length bytes or data.&n; */
DECL|function|_tr_stored_type_only
r_void
id|_tr_stored_type_only
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|send_bits
c_func
(paren
id|s
comma
(paren
id|STORED_BLOCK
op_lshift
l_int|1
)paren
comma
l_int|3
)paren
suffix:semicolon
id|bi_windup
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_assign
(paren
id|s-&gt;compressed_len
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|7L
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Send one empty static block to give enough lookahead for inflate.&n; * This takes 10 bits, of which 7 may remain in the bit buffer.&n; * The current inflate code requires 9 bits of lookahead. If the&n; * last two codes for the previous block (real code plus EOB) were coded&n; * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode&n; * the last real code. In this case we send two empty static blocks instead&n; * of one. (There are no problems if the previous block is stored or fixed.)&n; * To simplify the code, we assume the worst case of last real code encoded&n; * on one bit only.&n; */
DECL|function|_tr_align
r_void
id|_tr_align
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
id|send_bits
c_func
(paren
id|s
comma
id|STATIC_TREES
op_lshift
l_int|1
comma
l_int|3
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|END_BLOCK
comma
id|static_ltree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|10L
suffix:semicolon
multiline_comment|/* 3 for block type, 7 for EOB */
id|bi_flush
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Of the 10 bits for the empty block, we have already sent&n;     * (10 - bi_valid) bits. The lookahead for the last real code (before&n;     * the EOB of the previous block) was thus at least one plus the length&n;     * of the EOB plus what we have just sent of the empty static block.&n;     */
r_if
c_cond
(paren
l_int|1
op_plus
id|s-&gt;last_eob_len
op_plus
l_int|10
op_minus
id|s-&gt;bi_valid
OL
l_int|9
)paren
(brace
id|send_bits
c_func
(paren
id|s
comma
id|STATIC_TREES
op_lshift
l_int|1
comma
l_int|3
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|END_BLOCK
comma
id|static_ltree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|10L
suffix:semicolon
id|bi_flush
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|s-&gt;last_eob_len
op_assign
l_int|7
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Determine the best encoding for the current block: dynamic trees, static&n; * trees or store, and output the encoded block to the zip file. This function&n; * returns the total compressed length for the file so far.&n; */
DECL|function|_tr_flush_block
id|ulg
id|_tr_flush_block
c_func
(paren
id|s
comma
id|buf
comma
id|stored_len
comma
id|eof
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
multiline_comment|/* input block, or NULL if too old */
id|ulg
id|stored_len
suffix:semicolon
multiline_comment|/* length of input block */
r_int
id|eof
suffix:semicolon
multiline_comment|/* true if this is the last block for a file */
(brace
id|ulg
id|opt_lenb
comma
id|static_lenb
suffix:semicolon
multiline_comment|/* opt_len and static_len in bytes */
r_int
id|max_blindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of last bit length code of non zero freq */
multiline_comment|/* Build the Huffman trees unless a stored block is forced */
r_if
c_cond
(paren
id|s-&gt;level
OG
l_int|0
)paren
(brace
multiline_comment|/* Check if the file is ascii or binary */
r_if
c_cond
(paren
id|s-&gt;data_type
op_eq
id|Z_UNKNOWN
)paren
id|set_data_type
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Construct the literal and distance trees */
id|build_tree
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
(paren
op_amp
(paren
id|s-&gt;l_desc
)paren
)paren
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nlit data: dyn %ld, stat %ld&quot;
comma
id|s-&gt;opt_len
comma
id|s-&gt;static_len
)paren
)paren
suffix:semicolon
id|build_tree
c_func
(paren
id|s
comma
(paren
id|tree_desc
op_star
)paren
(paren
op_amp
(paren
id|s-&gt;d_desc
)paren
)paren
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ndist data: dyn %ld, stat %ld&quot;
comma
id|s-&gt;opt_len
comma
id|s-&gt;static_len
)paren
)paren
suffix:semicolon
multiline_comment|/* At this point, opt_len and static_len are the total bit lengths of&n;&t; * the compressed block data, excluding the tree representations.&n;&t; */
multiline_comment|/* Build the bit length tree for the above two trees, and get the index&n;&t; * in bl_order of the last bit length code to send.&n;&t; */
id|max_blindex
op_assign
id|build_bl_tree
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Determine the best encoding. Compute first the block length in bytes*/
id|opt_lenb
op_assign
(paren
id|s-&gt;opt_len
op_plus
l_int|3
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|static_lenb
op_assign
(paren
id|s-&gt;static_len
op_plus
l_int|3
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u &quot;
comma
id|opt_lenb
comma
id|s-&gt;opt_len
comma
id|static_lenb
comma
id|s-&gt;static_len
comma
id|stored_len
comma
id|s-&gt;last_lit
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|static_lenb
op_le
id|opt_lenb
)paren
id|opt_lenb
op_assign
id|static_lenb
suffix:semicolon
)brace
r_else
(brace
id|Assert
c_func
(paren
id|buf
op_ne
(paren
r_char
op_star
)paren
l_int|0
comma
l_string|&quot;lost buf&quot;
)paren
suffix:semicolon
id|opt_lenb
op_assign
id|static_lenb
op_assign
id|stored_len
op_plus
l_int|5
suffix:semicolon
multiline_comment|/* force a stored block */
)brace
multiline_comment|/* If compression failed and this is the first and last block,&n;     * and if the .zip file can be seeked (to rewrite the local header),&n;     * the whole file is transformed into a stored file:&n;     */
macro_line|#ifdef STORED_FILE_OK
macro_line|#  ifdef FORCE_STORED_FILE
r_if
c_cond
(paren
id|eof
op_logical_and
id|s-&gt;compressed_len
op_eq
l_int|0L
)paren
(brace
multiline_comment|/* force stored file */
macro_line|#  else
r_if
c_cond
(paren
id|stored_len
op_le
id|opt_lenb
op_logical_and
id|eof
op_logical_and
id|s-&gt;compressed_len
op_eq
l_int|0L
op_logical_and
id|seekable
c_func
(paren
)paren
)paren
(brace
macro_line|#  endif
multiline_comment|/* Since LIT_BUFSIZE &lt;= 2*WSIZE, the input data must be there: */
r_if
c_cond
(paren
id|buf
op_eq
(paren
id|charf
op_star
)paren
l_int|0
)paren
id|error
(paren
l_string|&quot;block vanished&quot;
)paren
suffix:semicolon
id|copy_block
c_func
(paren
id|s
comma
id|buf
comma
(paren
r_int
)paren
id|stored_len
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* without header */
id|s-&gt;compressed_len
op_assign
id|stored_len
op_lshift
l_int|3
suffix:semicolon
id|s-&gt;method
op_assign
id|STORED
suffix:semicolon
)brace
r_else
macro_line|#endif /* STORED_FILE_OK */
macro_line|#ifdef FORCE_STORED
r_if
c_cond
(paren
id|buf
op_ne
(paren
r_char
op_star
)paren
l_int|0
)paren
(brace
multiline_comment|/* force stored block */
macro_line|#else
r_if
c_cond
(paren
id|stored_len
op_plus
l_int|4
op_le
id|opt_lenb
op_logical_and
id|buf
op_ne
(paren
r_char
op_star
)paren
l_int|0
)paren
(brace
multiline_comment|/* 4: two words for the lengths */
macro_line|#endif
multiline_comment|/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.&n;         * Otherwise we can&squot;t have processed more than WSIZE input bytes since&n;         * the last block flush, because compression would have been&n;         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to&n;         * transform a block into a stored block.&n;         */
id|_tr_stored_block
c_func
(paren
id|s
comma
id|buf
comma
id|stored_len
comma
id|eof
)paren
suffix:semicolon
macro_line|#ifdef FORCE_STATIC
)brace
r_else
r_if
c_cond
(paren
id|static_lenb
op_ge
l_int|0
)paren
(brace
multiline_comment|/* force static trees */
macro_line|#else
)brace
r_else
r_if
c_cond
(paren
id|static_lenb
op_eq
id|opt_lenb
)paren
(brace
macro_line|#endif
id|send_bits
c_func
(paren
id|s
comma
(paren
id|STATIC_TREES
op_lshift
l_int|1
)paren
op_plus
id|eof
comma
l_int|3
)paren
suffix:semicolon
id|compress_block
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|static_ltree
comma
(paren
id|ct_data
op_star
)paren
id|static_dtree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|3
op_plus
id|s-&gt;static_len
suffix:semicolon
)brace
r_else
(brace
id|send_bits
c_func
(paren
id|s
comma
(paren
id|DYN_TREES
op_lshift
l_int|1
)paren
op_plus
id|eof
comma
l_int|3
)paren
suffix:semicolon
id|send_all_trees
c_func
(paren
id|s
comma
id|s-&gt;l_desc.max_code
op_plus
l_int|1
comma
id|s-&gt;d_desc.max_code
op_plus
l_int|1
comma
id|max_blindex
op_plus
l_int|1
)paren
suffix:semicolon
id|compress_block
c_func
(paren
id|s
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_ltree
comma
(paren
id|ct_data
op_star
)paren
id|s-&gt;dyn_dtree
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|3
op_plus
id|s-&gt;opt_len
suffix:semicolon
)brace
id|Assert
(paren
id|s-&gt;compressed_len
op_eq
id|s-&gt;bits_sent
comma
l_string|&quot;bad compressed size&quot;
)paren
suffix:semicolon
id|init_block
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eof
)paren
(brace
id|bi_windup
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;compressed_len
op_add_assign
l_int|7
suffix:semicolon
multiline_comment|/* align on byte boundary */
)brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;ncomprlen %lu(%lu) &quot;
comma
id|s-&gt;compressed_len
op_rshift
l_int|3
comma
id|s-&gt;compressed_len
op_minus
l_int|7
op_star
id|eof
)paren
)paren
suffix:semicolon
r_return
id|s-&gt;compressed_len
op_rshift
l_int|3
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Save the match info and tally the frequency counts. Return true if&n; * the current block must be flushed.&n; */
DECL|function|_tr_tally
r_int
id|_tr_tally
(paren
id|s
comma
id|dist
comma
id|lc
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
r_int
id|dist
suffix:semicolon
multiline_comment|/* distance of matched string */
r_int
id|lc
suffix:semicolon
multiline_comment|/* match length-MIN_MATCH or unmatched char (if dist==0) */
(brace
id|s-&gt;d_buf
(braket
id|s-&gt;last_lit
)braket
op_assign
(paren
id|ush
)paren
id|dist
suffix:semicolon
id|s-&gt;l_buf
(braket
id|s-&gt;last_lit
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|lc
suffix:semicolon
r_if
c_cond
(paren
id|dist
op_eq
l_int|0
)paren
(brace
multiline_comment|/* lc is the unmatched char */
id|s-&gt;dyn_ltree
(braket
id|lc
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;matches
op_increment
suffix:semicolon
multiline_comment|/* Here, lc is the match length - MIN_MATCH */
id|dist
op_decrement
suffix:semicolon
multiline_comment|/* dist = match distance - 1 */
id|Assert
c_func
(paren
(paren
id|ush
)paren
id|dist
OL
(paren
id|ush
)paren
id|MAX_DIST
c_func
(paren
id|s
)paren
op_logical_and
(paren
id|ush
)paren
id|lc
op_le
(paren
id|ush
)paren
(paren
id|MAX_MATCH
op_minus
id|MIN_MATCH
)paren
op_logical_and
(paren
id|ush
)paren
id|d_code
c_func
(paren
id|dist
)paren
OL
(paren
id|ush
)paren
id|D_CODES
comma
l_string|&quot;_tr_tally: bad match&quot;
)paren
suffix:semicolon
id|s-&gt;dyn_ltree
(braket
id|length_code
(braket
id|lc
)braket
op_plus
id|LITERALS
op_plus
l_int|1
)braket
dot
id|Freq
op_increment
suffix:semicolon
id|s-&gt;dyn_dtree
(braket
id|d_code
c_func
(paren
id|dist
)paren
)braket
dot
id|Freq
op_increment
suffix:semicolon
)brace
multiline_comment|/* Try to guess if it is profitable to stop the current block here */
r_if
c_cond
(paren
id|s-&gt;level
OG
l_int|2
op_logical_and
(paren
id|s-&gt;last_lit
op_amp
l_int|0xfff
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Compute an upper bound for the compressed length */
id|ulg
id|out_length
op_assign
(paren
id|ulg
)paren
id|s-&gt;last_lit
op_star
l_int|8L
suffix:semicolon
id|ulg
id|in_length
op_assign
(paren
id|ulg
)paren
(paren
(paren
r_int
)paren
id|s-&gt;strstart
op_minus
id|s-&gt;block_start
)paren
suffix:semicolon
r_int
id|dcode
suffix:semicolon
r_for
c_loop
(paren
id|dcode
op_assign
l_int|0
suffix:semicolon
id|dcode
OL
id|D_CODES
suffix:semicolon
id|dcode
op_increment
)paren
(brace
id|out_length
op_add_assign
(paren
id|ulg
)paren
id|s-&gt;dyn_dtree
(braket
id|dcode
)braket
dot
id|Freq
op_star
(paren
l_int|5L
op_plus
id|extra_dbits
(braket
id|dcode
)braket
)paren
suffix:semicolon
)brace
id|out_length
op_rshift_assign
l_int|3
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;nlast_lit %u, in %ld, out ~%ld(%ld%%) &quot;
comma
id|s-&gt;last_lit
comma
id|in_length
comma
id|out_length
comma
l_int|100L
op_minus
id|out_length
op_star
l_int|100L
op_div
id|in_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;matches
OL
id|s-&gt;last_lit
op_div
l_int|2
op_logical_and
id|out_length
OL
id|in_length
op_div
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|s-&gt;last_lit
op_eq
id|s-&gt;lit_bufsize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* We avoid equality with lit_bufsize because of wraparound at 64K&n;     * on 16 bit machines and because stored blocks are restricted to&n;     * 64K-1 bytes.&n;     */
)brace
multiline_comment|/* ===========================================================================&n; * Send the block data compressed using the given Huffman trees&n; */
DECL|function|compress_block
id|local
r_void
id|compress_block
c_func
(paren
id|s
comma
id|ltree
comma
id|dtree
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|ct_data
op_star
id|ltree
suffix:semicolon
multiline_comment|/* literal tree */
id|ct_data
op_star
id|dtree
suffix:semicolon
multiline_comment|/* distance tree */
(brace
r_int
id|dist
suffix:semicolon
multiline_comment|/* distance of matched string */
r_int
id|lc
suffix:semicolon
multiline_comment|/* match length or unmatched char (if dist == 0) */
r_int
id|lx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* running index in l_buf */
r_int
id|code
suffix:semicolon
multiline_comment|/* the code to send */
r_int
id|extra
suffix:semicolon
multiline_comment|/* number of extra bits to send */
r_if
c_cond
(paren
id|s-&gt;last_lit
op_ne
l_int|0
)paren
r_do
(brace
id|dist
op_assign
id|s-&gt;d_buf
(braket
id|lx
)braket
suffix:semicolon
id|lc
op_assign
id|s-&gt;l_buf
(braket
id|lx
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dist
op_eq
l_int|0
)paren
(brace
id|send_code
c_func
(paren
id|s
comma
id|lc
comma
id|ltree
)paren
suffix:semicolon
multiline_comment|/* send a literal byte */
id|Tracecv
c_func
(paren
id|isgraph
c_func
(paren
id|lc
)paren
comma
(paren
id|stderr
comma
l_string|&quot; &squot;%c&squot; &quot;
comma
id|lc
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Here, lc is the match length - MIN_MATCH */
id|code
op_assign
id|length_code
(braket
id|lc
)braket
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|code
op_plus
id|LITERALS
op_plus
l_int|1
comma
id|ltree
)paren
suffix:semicolon
multiline_comment|/* send the length code */
id|extra
op_assign
id|extra_lbits
(braket
id|code
)braket
suffix:semicolon
r_if
c_cond
(paren
id|extra
op_ne
l_int|0
)paren
(brace
id|lc
op_sub_assign
id|base_length
(braket
id|code
)braket
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|lc
comma
id|extra
)paren
suffix:semicolon
multiline_comment|/* send the extra length bits */
)brace
id|dist
op_decrement
suffix:semicolon
multiline_comment|/* dist is now the match distance - 1 */
id|code
op_assign
id|d_code
c_func
(paren
id|dist
)paren
suffix:semicolon
id|Assert
(paren
id|code
OL
id|D_CODES
comma
l_string|&quot;bad d_code&quot;
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|code
comma
id|dtree
)paren
suffix:semicolon
multiline_comment|/* send the distance code */
id|extra
op_assign
id|extra_dbits
(braket
id|code
)braket
suffix:semicolon
r_if
c_cond
(paren
id|extra
op_ne
l_int|0
)paren
(brace
id|dist
op_sub_assign
id|base_dist
(braket
id|code
)braket
suffix:semicolon
id|send_bits
c_func
(paren
id|s
comma
id|dist
comma
id|extra
)paren
suffix:semicolon
multiline_comment|/* send the extra distance bits */
)brace
)brace
multiline_comment|/* literal or match pair ? */
multiline_comment|/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
id|Assert
c_func
(paren
id|s-&gt;pending
OL
id|s-&gt;lit_bufsize
op_plus
l_int|2
op_star
id|lx
comma
l_string|&quot;pendingBuf overflow&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lx
OL
id|s-&gt;last_lit
)paren
suffix:semicolon
id|send_code
c_func
(paren
id|s
comma
id|END_BLOCK
comma
id|ltree
)paren
suffix:semicolon
id|s-&gt;last_eob_len
op_assign
id|ltree
(braket
id|END_BLOCK
)braket
dot
id|Len
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Set the data type to ASCII or BINARY, using a crude approximation:&n; * binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.&n; * IN assertion: the fields freq of dyn_ltree are set and the total of all&n; * frequencies does not exceed 64K (to fit in an int on 16 bit machines).&n; */
DECL|function|set_data_type
id|local
r_void
id|set_data_type
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|ascii_freq
op_assign
l_int|0
suffix:semicolon
r_int
id|bin_freq
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
l_int|7
)paren
id|bin_freq
op_add_assign
id|s-&gt;dyn_ltree
(braket
id|n
op_increment
)braket
dot
id|Freq
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
l_int|128
)paren
id|ascii_freq
op_add_assign
id|s-&gt;dyn_ltree
(braket
id|n
op_increment
)braket
dot
id|Freq
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
id|LITERALS
)paren
id|bin_freq
op_add_assign
id|s-&gt;dyn_ltree
(braket
id|n
op_increment
)braket
dot
id|Freq
suffix:semicolon
id|s-&gt;data_type
op_assign
(paren
id|Byte
)paren
(paren
id|bin_freq
OG
(paren
id|ascii_freq
op_rshift
l_int|2
)paren
ques
c_cond
id|Z_BINARY
suffix:colon
id|Z_ASCII
)paren
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Reverse the first len bits of a code, using straightforward code (a faster&n; * method would use a table)&n; * IN assertion: 1 &lt;= len &lt;= 15&n; */
DECL|function|bi_reverse
id|local
r_int
id|bi_reverse
c_func
(paren
id|code
comma
id|len
)paren
r_int
id|code
suffix:semicolon
multiline_comment|/* the value to invert */
r_int
id|len
suffix:semicolon
multiline_comment|/* its bit length */
(brace
r_register
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|res
op_or_assign
id|code
op_amp
l_int|1
suffix:semicolon
id|code
op_rshift_assign
l_int|1
comma
id|res
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|len
OG
l_int|0
)paren
suffix:semicolon
r_return
id|res
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Flush the bit buffer, keeping at most 7 bits in it.&n; */
DECL|function|bi_flush
id|local
r_void
id|bi_flush
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_if
c_cond
(paren
id|s-&gt;bi_valid
op_eq
l_int|16
)paren
(brace
id|put_short
c_func
(paren
id|s
comma
id|s-&gt;bi_buf
)paren
suffix:semicolon
id|s-&gt;bi_buf
op_assign
l_int|0
suffix:semicolon
id|s-&gt;bi_valid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;bi_valid
op_ge
l_int|8
)paren
(brace
id|put_byte
c_func
(paren
id|s
comma
(paren
id|Byte
)paren
id|s-&gt;bi_buf
)paren
suffix:semicolon
id|s-&gt;bi_buf
op_rshift_assign
l_int|8
suffix:semicolon
id|s-&gt;bi_valid
op_sub_assign
l_int|8
suffix:semicolon
)brace
)brace
multiline_comment|/* ===========================================================================&n; * Flush the bit buffer and align the output on a byte boundary&n; */
DECL|function|bi_windup
id|local
r_void
id|bi_windup
c_func
(paren
id|s
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
(brace
r_if
c_cond
(paren
id|s-&gt;bi_valid
OG
l_int|8
)paren
(brace
id|put_short
c_func
(paren
id|s
comma
id|s-&gt;bi_buf
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;bi_valid
OG
l_int|0
)paren
(brace
id|put_byte
c_func
(paren
id|s
comma
(paren
id|Byte
)paren
id|s-&gt;bi_buf
)paren
suffix:semicolon
)brace
id|s-&gt;bi_buf
op_assign
l_int|0
suffix:semicolon
id|s-&gt;bi_valid
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_assign
(paren
id|s-&gt;bits_sent
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ===========================================================================&n; * Copy a stored block, storing first the length and its&n; * one&squot;s complement if requested.&n; */
DECL|function|copy_block
id|local
r_void
id|copy_block
c_func
(paren
id|s
comma
id|buf
comma
id|len
comma
id|header
)paren
id|deflate_state
op_star
id|s
suffix:semicolon
id|charf
op_star
id|buf
suffix:semicolon
multiline_comment|/* the input data */
r_int
id|len
suffix:semicolon
multiline_comment|/* its length */
r_int
id|header
suffix:semicolon
multiline_comment|/* true if block header must be written */
(brace
id|bi_windup
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* align on byte boundary */
id|s-&gt;last_eob_len
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* enough lookahead for inflate */
r_if
c_cond
(paren
id|header
)paren
(brace
id|put_short
c_func
(paren
id|s
comma
(paren
id|ush
)paren
id|len
)paren
suffix:semicolon
id|put_short
c_func
(paren
id|s
comma
(paren
id|ush
)paren
op_complement
id|len
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_add_assign
l_int|2
op_star
l_int|16
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_ZLIB
id|s-&gt;bits_sent
op_add_assign
(paren
id|ulg
)paren
id|len
op_lshift
l_int|3
suffix:semicolon
macro_line|#endif
multiline_comment|/* bundle up the put_byte(s, *buf++) calls */
id|zmemcpy
c_func
(paren
op_amp
id|s-&gt;pending_buf
(braket
id|s-&gt;pending
)braket
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|s-&gt;pending
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* --- trees.c */
multiline_comment|/* +++ inflate.c */
multiline_comment|/* inflate.c -- zlib interface to inflate modules&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* +++ infblock.h */
multiline_comment|/* infblock.h -- header to use infblock.c&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
r_struct
id|inflate_blocks_state
suffix:semicolon
DECL|typedef|inflate_blocks_statef
r_typedef
r_struct
id|inflate_blocks_state
id|FAR
id|inflate_blocks_statef
suffix:semicolon
r_extern
id|inflate_blocks_statef
op_star
id|inflate_blocks_new
id|OF
c_func
(paren
(paren
id|z_streamp
id|z
comma
id|check_func
id|c
comma
multiline_comment|/* check function */
id|uInt
id|w
)paren
)paren
suffix:semicolon
multiline_comment|/* window size */
r_extern
r_int
id|inflate_blocks
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_streamp
comma
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* initial return code */
r_extern
r_void
id|inflate_blocks_reset
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_streamp
comma
id|uLongf
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* check value on output */
r_extern
r_int
id|inflate_blocks_free
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_streamp
comma
id|uLongf
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* check value on output */
r_extern
r_void
id|inflate_set_dictionary
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
id|s
comma
r_const
id|Bytef
op_star
id|d
comma
multiline_comment|/* dictionary */
id|uInt
id|n
)paren
)paren
suffix:semicolon
multiline_comment|/* dictionary length */
r_extern
r_int
id|inflate_addhistory
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_streamp
)paren
)paren
suffix:semicolon
r_extern
r_int
id|inflate_packet_flush
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* --- infblock.h */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|inflate_blocks_state
DECL|member|dummy
r_struct
id|inflate_blocks_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
multiline_comment|/* inflate private state */
DECL|struct|internal_state
r_struct
id|internal_state
(brace
multiline_comment|/* mode */
r_enum
(brace
DECL|enumerator|METHOD
id|METHOD
comma
multiline_comment|/* waiting for method byte */
DECL|enumerator|FLAG
id|FLAG
comma
multiline_comment|/* waiting for flag byte */
DECL|enumerator|DICT4
id|DICT4
comma
multiline_comment|/* four dictionary check bytes to go */
DECL|enumerator|DICT3
id|DICT3
comma
multiline_comment|/* three dictionary check bytes to go */
DECL|enumerator|DICT2
id|DICT2
comma
multiline_comment|/* two dictionary check bytes to go */
DECL|enumerator|DICT1
id|DICT1
comma
multiline_comment|/* one dictionary check byte to go */
DECL|enumerator|DICT0
id|DICT0
comma
multiline_comment|/* waiting for inflateSetDictionary */
DECL|enumerator|BLOCKS
id|BLOCKS
comma
multiline_comment|/* decompressing blocks */
DECL|enumerator|CHECK4
id|CHECK4
comma
multiline_comment|/* four check bytes to go */
DECL|enumerator|CHECK3
id|CHECK3
comma
multiline_comment|/* three check bytes to go */
DECL|enumerator|CHECK2
id|CHECK2
comma
multiline_comment|/* two check bytes to go */
DECL|enumerator|CHECK1
id|CHECK1
comma
multiline_comment|/* one check byte to go */
DECL|enumerator|DONE
id|DONE
comma
multiline_comment|/* finished check, done */
DECL|enumerator|BAD
id|BAD
)brace
multiline_comment|/* got an error--stay here */
DECL|member|mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate mode */
multiline_comment|/* mode dependent information */
r_union
(brace
DECL|member|method
id|uInt
id|method
suffix:semicolon
multiline_comment|/* if FLAGS, method byte */
r_struct
(brace
DECL|member|was
id|uLong
id|was
suffix:semicolon
multiline_comment|/* computed check value */
DECL|member|need
id|uLong
id|need
suffix:semicolon
multiline_comment|/* stream check value */
DECL|member|check
)brace
id|check
suffix:semicolon
multiline_comment|/* if CHECK, check values to compare */
DECL|member|marker
id|uInt
id|marker
suffix:semicolon
multiline_comment|/* if BAD, inflateSync&squot;s marker bytes count */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
multiline_comment|/* mode independent information */
DECL|member|nowrap
r_int
id|nowrap
suffix:semicolon
multiline_comment|/* flag for no wrapper */
DECL|member|wbits
id|uInt
id|wbits
suffix:semicolon
multiline_comment|/* log2(window size)  (8..15, defaults to 15) */
id|inflate_blocks_statef
DECL|member|blocks
op_star
id|blocks
suffix:semicolon
multiline_comment|/* current inflate_blocks state */
)brace
suffix:semicolon
DECL|function|inflateReset
r_int
id|inflateReset
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
id|uLong
id|c
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|z-&gt;total_in
op_assign
id|z-&gt;total_out
op_assign
l_int|0
suffix:semicolon
id|z-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|z-&gt;state-&gt;nowrap
ques
c_cond
id|BLOCKS
suffix:colon
id|METHOD
suffix:semicolon
id|inflate_blocks_reset
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|c
)paren
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflateEnd
r_int
id|inflateEnd
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
id|uLong
id|c
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;zfree
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;blocks
op_ne
id|Z_NULL
)paren
id|inflate_blocks_free
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|c
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|z-&gt;state
)paren
suffix:semicolon
id|z-&gt;state
op_assign
id|Z_NULL
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: end&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflateInit2_
r_int
id|inflateInit2_
c_func
(paren
id|z
comma
id|w
comma
id|version
comma
id|stream_size
)paren
id|z_streamp
id|z
suffix:semicolon
r_int
id|w
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_int
id|stream_size
suffix:semicolon
(brace
r_if
c_cond
(paren
id|version
op_eq
id|Z_NULL
op_logical_or
id|version
(braket
l_int|0
)braket
op_ne
id|ZLIB_VERSION
(braket
l_int|0
)braket
op_logical_or
id|stream_size
op_ne
r_sizeof
(paren
id|z_stream
)paren
)paren
r_return
id|Z_VERSION_ERROR
suffix:semicolon
multiline_comment|/* initialize state */
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|z-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
macro_line|#ifndef NO_ZCFUNCS
r_if
c_cond
(paren
id|z-&gt;zalloc
op_eq
id|Z_NULL
)paren
(brace
id|z-&gt;zalloc
op_assign
id|zcalloc
suffix:semicolon
id|z-&gt;opaque
op_assign
(paren
id|voidpf
)paren
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|z-&gt;zfree
op_eq
id|Z_NULL
)paren
id|z-&gt;zfree
op_assign
id|zcfree
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|z-&gt;state
op_assign
(paren
r_struct
id|internal_state
id|FAR
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
l_int|1
comma
r_sizeof
(paren
r_struct
id|internal_state
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
r_return
id|Z_MEM_ERROR
suffix:semicolon
id|z-&gt;state-&gt;blocks
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* handle undocumented nowrap option (no zlib header or check) */
id|z-&gt;state-&gt;nowrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|w
OL
l_int|0
)paren
(brace
id|w
op_assign
op_minus
id|w
suffix:semicolon
id|z-&gt;state-&gt;nowrap
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set window size */
r_if
c_cond
(paren
id|w
template_param
l_int|15
)paren
(brace
id|inflateEnd
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|z-&gt;state-&gt;wbits
op_assign
(paren
id|uInt
)paren
id|w
suffix:semicolon
multiline_comment|/* create inflate_blocks state */
r_if
c_cond
(paren
(paren
id|z-&gt;state-&gt;blocks
op_assign
id|inflate_blocks_new
c_func
(paren
id|z
comma
id|z-&gt;state-&gt;nowrap
ques
c_cond
id|Z_NULL
suffix:colon
id|adler32
comma
(paren
id|uInt
)paren
l_int|1
op_lshift
id|w
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|inflateEnd
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
)brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: allocated&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* reset state */
id|inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflateInit_
r_int
id|inflateInit_
c_func
(paren
id|z
comma
id|version
comma
id|stream_size
)paren
id|z_streamp
id|z
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_int
id|stream_size
suffix:semicolon
(brace
r_return
id|inflateInit2_
c_func
(paren
id|z
comma
id|DEF_WBITS
comma
id|version
comma
id|stream_size
)paren
suffix:semicolon
)brace
DECL|macro|NEEDBYTE
mdefine_line|#define NEEDBYTE {if(z-&gt;avail_in==0)goto empty;r=Z_OK;}
DECL|macro|NEXTBYTE
mdefine_line|#define NEXTBYTE (z-&gt;avail_in--,z-&gt;total_in++,*z-&gt;next_in++)
DECL|function|inflate
r_int
id|inflate
c_func
(paren
id|z
comma
id|f
)paren
id|z_streamp
id|z
suffix:semicolon
r_int
id|f
suffix:semicolon
(brace
r_int
id|r
suffix:semicolon
id|uInt
id|b
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;next_in
op_eq
id|Z_NULL
op_logical_or
id|f
OL
l_int|0
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|r
op_assign
id|Z_BUF_ERROR
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|z-&gt;state-&gt;mode
)paren
(brace
r_case
id|METHOD
suffix:colon
id|NEEDBYTE
r_if
c_cond
(paren
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_assign
id|NEXTBYTE
)paren
op_amp
l_int|0xf
)paren
op_ne
id|Z_DEFLATED
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;unknown compression method&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_rshift
l_int|4
)paren
op_plus
l_int|8
OG
id|z-&gt;state-&gt;wbits
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid window size&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|FLAG
suffix:semicolon
r_case
id|FLAG
suffix:colon
id|NEEDBYTE
id|b
op_assign
id|NEXTBYTE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_lshift
l_int|8
)paren
op_plus
id|b
)paren
op_mod
l_int|31
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incorrect header check&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: zlib header ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|b
op_amp
id|PRESET_DICT
)paren
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|DICT4
suffix:semicolon
r_case
id|DICT4
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|24
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT3
suffix:semicolon
r_case
id|DICT3
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|16
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT2
suffix:semicolon
r_case
id|DICT2
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|8
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT1
suffix:semicolon
r_case
id|DICT1
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
suffix:semicolon
id|z-&gt;adler
op_assign
id|z-&gt;state-&gt;sub.check.need
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT0
suffix:semicolon
r_return
id|Z_NEED_DICT
suffix:semicolon
r_case
id|DICT0
suffix:colon
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;need dictionary&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_case
id|BLOCKS
suffix:colon
id|r
op_assign
id|inflate_blocks
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
id|Z_PACKET_FLUSH
op_logical_and
id|z-&gt;avail_in
op_eq
l_int|0
op_logical_and
id|z-&gt;avail_out
op_ne
l_int|0
)paren
id|r
op_assign
id|inflate_packet_flush
c_func
(paren
id|z-&gt;state-&gt;blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
op_ne
id|Z_STREAM_END
)paren
r_return
id|r
suffix:semicolon
id|r
op_assign
id|Z_OK
suffix:semicolon
id|inflate_blocks_reset
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|z-&gt;state-&gt;sub.check.was
)paren
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;nowrap
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|DONE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|CHECK4
suffix:semicolon
r_case
id|CHECK4
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|24
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK3
suffix:semicolon
r_case
id|CHECK3
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|16
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK2
suffix:semicolon
r_case
id|CHECK2
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|8
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK1
suffix:semicolon
r_case
id|CHECK1
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;sub.check.was
op_ne
id|z-&gt;state-&gt;sub.check.need
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incorrect data check&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: zlib check ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DONE
suffix:semicolon
r_case
id|DONE
suffix:colon
r_return
id|Z_STREAM_END
suffix:semicolon
r_case
id|BAD
suffix:colon
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_default
suffix:colon
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|empty
suffix:colon
r_if
c_cond
(paren
id|f
op_ne
id|Z_PACKET_FLUSH
)paren
r_return
id|r
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;need more for packet flush&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_return
id|Z_DATA_ERROR
suffix:semicolon
)brace
DECL|function|inflateSetDictionary
r_int
id|inflateSetDictionary
c_func
(paren
id|z
comma
id|dictionary
comma
id|dictLength
)paren
id|z_streamp
id|z
suffix:semicolon
r_const
id|Bytef
op_star
id|dictionary
suffix:semicolon
id|uInt
id|dictLength
suffix:semicolon
(brace
id|uInt
id|length
op_assign
id|dictLength
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state-&gt;mode
op_ne
id|DICT0
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|adler32
c_func
(paren
l_int|1L
comma
id|dictionary
comma
id|dictLength
)paren
op_ne
id|z-&gt;adler
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|z-&gt;adler
op_assign
l_int|1L
suffix:semicolon
r_if
c_cond
(paren
id|length
op_ge
(paren
(paren
id|uInt
)paren
l_int|1
op_lshift
id|z-&gt;state-&gt;wbits
)paren
)paren
(brace
id|length
op_assign
(paren
l_int|1
op_lshift
id|z-&gt;state-&gt;wbits
)paren
op_minus
l_int|1
suffix:semicolon
id|dictionary
op_add_assign
id|dictLength
op_minus
id|length
suffix:semicolon
)brace
id|inflate_set_dictionary
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|dictionary
comma
id|length
)paren
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine adds the data at next_in/avail_in to the output history&n; * without performing any output.  The output buffer must be &quot;caught up&quot;;&n; * i.e. no pending output (hence s-&gt;read equals s-&gt;write), and the state must&n; * be BLOCKS (i.e. we should be willing to see the start of a series of&n; * BLOCKS).  On exit, the output will also be caught up, and the checksum&n; * will have been updated if need be.&n; */
DECL|function|inflateIncomp
r_int
id|inflateIncomp
c_func
(paren
id|z
)paren
id|z_stream
op_star
id|z
suffix:semicolon
(brace
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|BLOCKS
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_return
id|inflate_addhistory
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
)paren
suffix:semicolon
)brace
DECL|function|inflateSync
r_int
id|inflateSync
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of bytes to look at */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer to bytes */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* number of marker bytes found in a row */
id|uLong
id|r
comma
id|w
suffix:semicolon
multiline_comment|/* temporaries to save total_in and total_out */
multiline_comment|/* set up */
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|BAD
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n
op_assign
id|z-&gt;avail_in
)paren
op_eq
l_int|0
)paren
r_return
id|Z_BUF_ERROR
suffix:semicolon
id|p
op_assign
id|z-&gt;next_in
suffix:semicolon
id|m
op_assign
id|z-&gt;state-&gt;sub.marker
suffix:semicolon
multiline_comment|/* search */
r_while
c_loop
(paren
id|n
op_logical_and
id|m
OL
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
(paren
id|Byte
)paren
(paren
id|m
OL
l_int|2
ques
c_cond
l_int|0
suffix:colon
l_int|0xff
)paren
)paren
id|m
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|p
)paren
id|m
op_assign
l_int|0
suffix:semicolon
r_else
id|m
op_assign
l_int|4
op_minus
id|m
suffix:semicolon
id|p
op_increment
comma
id|n
op_decrement
suffix:semicolon
)brace
multiline_comment|/* restore */
id|z-&gt;total_in
op_add_assign
id|p
op_minus
id|z-&gt;next_in
suffix:semicolon
id|z-&gt;next_in
op_assign
id|p
suffix:semicolon
id|z-&gt;avail_in
op_assign
id|n
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
id|m
suffix:semicolon
multiline_comment|/* return no joy or set up to restart on a new block */
r_if
c_cond
(paren
id|m
op_ne
l_int|4
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|r
op_assign
id|z-&gt;total_in
suffix:semicolon
id|w
op_assign
id|z-&gt;total_out
suffix:semicolon
id|inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
id|z-&gt;total_in
op_assign
id|r
suffix:semicolon
id|z-&gt;total_out
op_assign
id|w
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|macro|NEEDBYTE
macro_line|#undef NEEDBYTE
DECL|macro|NEXTBYTE
macro_line|#undef NEXTBYTE
multiline_comment|/* --- inflate.c */
multiline_comment|/* +++ infblock.c */
multiline_comment|/* infblock.c -- interpret and process block types to last block&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* #include &quot;infblock.h&quot; */
multiline_comment|/* +++ inftrees.h */
multiline_comment|/* inftrees.h -- header to use inftrees.c&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/* Huffman code lookup table entry--this entry is four bytes for machines&n;   that have 16-bit pointers (e.g. PC&squot;s in the small or medium model). */
DECL|typedef|inflate_huft
r_typedef
r_struct
id|inflate_huft_s
id|FAR
id|inflate_huft
suffix:semicolon
DECL|struct|inflate_huft_s
r_struct
id|inflate_huft_s
(brace
r_union
(brace
r_struct
(brace
DECL|member|Exop
id|Byte
id|Exop
suffix:semicolon
multiline_comment|/* number of extra bits or operation */
DECL|member|Bits
id|Byte
id|Bits
suffix:semicolon
multiline_comment|/* number of bits in this code or subcode */
DECL|member|what
)brace
id|what
suffix:semicolon
DECL|member|pad
id|Bytef
op_star
id|pad
suffix:semicolon
multiline_comment|/* pad structure to a power of 2 (4 bytes for */
DECL|member|word
)brace
id|word
suffix:semicolon
multiline_comment|/*  16-bit, 8 bytes for 32-bit machines) */
r_union
(brace
DECL|member|Base
id|uInt
id|Base
suffix:semicolon
multiline_comment|/* literal, length base, or distance base */
DECL|member|Next
id|inflate_huft
op_star
id|Next
suffix:semicolon
multiline_comment|/* pointer to next level of table */
DECL|member|more
)brace
id|more
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
r_extern
id|uInt
id|inflate_hufts
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|inflate_trees_bits
id|OF
c_func
(paren
(paren
id|uIntf
op_star
comma
multiline_comment|/* 19 code lengths */
id|uIntf
op_star
comma
multiline_comment|/* bits tree desired/actual depth */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* bits tree result */
id|z_streamp
)paren
)paren
suffix:semicolon
multiline_comment|/* for zalloc, zfree functions */
r_extern
r_int
id|inflate_trees_dynamic
id|OF
c_func
(paren
(paren
id|uInt
comma
multiline_comment|/* number of literal/length codes */
id|uInt
comma
multiline_comment|/* number of distance codes */
id|uIntf
op_star
comma
multiline_comment|/* that many (total) code lengths */
id|uIntf
op_star
comma
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
comma
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* distance tree result */
id|z_streamp
)paren
)paren
suffix:semicolon
multiline_comment|/* for zalloc, zfree functions */
r_extern
r_int
id|inflate_trees_fixed
id|OF
c_func
(paren
(paren
id|uIntf
op_star
comma
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
comma
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* distance tree result */
r_extern
r_int
id|inflate_trees_free
id|OF
c_func
(paren
(paren
id|inflate_huft
op_star
comma
multiline_comment|/* tables to free */
id|z_streamp
)paren
)paren
suffix:semicolon
multiline_comment|/* for zfree function */
multiline_comment|/* --- inftrees.h */
multiline_comment|/* +++ infcodes.h */
multiline_comment|/* infcodes.h -- header to use infcodes.c&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
r_struct
id|inflate_codes_state
suffix:semicolon
DECL|typedef|inflate_codes_statef
r_typedef
r_struct
id|inflate_codes_state
id|FAR
id|inflate_codes_statef
suffix:semicolon
r_extern
id|inflate_codes_statef
op_star
id|inflate_codes_new
id|OF
c_func
(paren
(paren
id|uInt
comma
id|uInt
comma
id|inflate_huft
op_star
comma
id|inflate_huft
op_star
comma
id|z_streamp
)paren
)paren
suffix:semicolon
r_extern
r_int
id|inflate_codes
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_streamp
comma
r_int
)paren
)paren
suffix:semicolon
r_extern
r_void
id|inflate_codes_free
id|OF
c_func
(paren
(paren
id|inflate_codes_statef
op_star
comma
id|z_streamp
)paren
)paren
suffix:semicolon
multiline_comment|/* --- infcodes.h */
multiline_comment|/* +++ infutil.h */
multiline_comment|/* infutil.h -- types and macros common to blocks and codes&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
macro_line|#ifndef _INFUTIL_H
DECL|macro|_INFUTIL_H
mdefine_line|#define _INFUTIL_H
r_typedef
r_enum
(brace
DECL|enumerator|TYPE
id|TYPE
comma
multiline_comment|/* get type bits (3, including end bit) */
DECL|enumerator|LENS
id|LENS
comma
multiline_comment|/* get lengths for stored */
DECL|enumerator|STORED
id|STORED
comma
multiline_comment|/* processing stored block */
DECL|enumerator|TABLE
id|TABLE
comma
multiline_comment|/* get table lengths */
DECL|enumerator|BTREE
id|BTREE
comma
multiline_comment|/* get bit lengths tree for a dynamic block */
DECL|enumerator|DTREE
id|DTREE
comma
multiline_comment|/* get length, distance trees for a dynamic block */
DECL|enumerator|CODES
id|CODES
comma
multiline_comment|/* processing fixed or dynamic block */
DECL|enumerator|DRY
id|DRY
comma
multiline_comment|/* output remaining window bytes */
DECL|enumerator|DONEB
id|DONEB
comma
multiline_comment|/* finished last block, done */
DECL|enumerator|BADB
id|BADB
)brace
multiline_comment|/* got a data error--stuck here */
DECL|typedef|inflate_block_mode
id|inflate_block_mode
suffix:semicolon
multiline_comment|/* inflate blocks semi-private state */
DECL|struct|inflate_blocks_state
r_struct
id|inflate_blocks_state
(brace
multiline_comment|/* mode */
DECL|member|mode
id|inflate_block_mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate_block mode */
multiline_comment|/* mode dependent information */
r_union
(brace
DECL|member|left
id|uInt
id|left
suffix:semicolon
multiline_comment|/* if STORED, bytes left to copy */
r_struct
(brace
DECL|member|table
id|uInt
id|table
suffix:semicolon
multiline_comment|/* table lengths (14 bits) */
DECL|member|index
id|uInt
id|index
suffix:semicolon
multiline_comment|/* index into blens (or border) */
DECL|member|blens
id|uIntf
op_star
id|blens
suffix:semicolon
multiline_comment|/* bit lengths of codes */
DECL|member|bb
id|uInt
id|bb
suffix:semicolon
multiline_comment|/* bit length tree depth */
DECL|member|tb
id|inflate_huft
op_star
id|tb
suffix:semicolon
multiline_comment|/* bit length decoding tree */
DECL|member|trees
)brace
id|trees
suffix:semicolon
multiline_comment|/* if DTREE, decoding info for trees */
r_struct
(brace
DECL|member|tl
id|inflate_huft
op_star
id|tl
suffix:semicolon
DECL|member|td
id|inflate_huft
op_star
id|td
suffix:semicolon
multiline_comment|/* trees to free */
id|inflate_codes_statef
DECL|member|codes
op_star
id|codes
suffix:semicolon
DECL|member|decode
)brace
id|decode
suffix:semicolon
multiline_comment|/* if CODES, current state */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
DECL|member|last
id|uInt
id|last
suffix:semicolon
multiline_comment|/* true if this block is the last block */
multiline_comment|/* mode independent information */
DECL|member|bitk
id|uInt
id|bitk
suffix:semicolon
multiline_comment|/* bits in bit buffer */
DECL|member|bitb
id|uLong
id|bitb
suffix:semicolon
multiline_comment|/* bit buffer */
DECL|member|window
id|Bytef
op_star
id|window
suffix:semicolon
multiline_comment|/* sliding window */
DECL|member|end
id|Bytef
op_star
id|end
suffix:semicolon
multiline_comment|/* one byte after sliding window */
DECL|member|read
id|Bytef
op_star
id|read
suffix:semicolon
multiline_comment|/* window read pointer */
DECL|member|write
id|Bytef
op_star
id|write
suffix:semicolon
multiline_comment|/* window write pointer */
DECL|member|checkfn
id|check_func
id|checkfn
suffix:semicolon
multiline_comment|/* check function */
DECL|member|check
id|uLong
id|check
suffix:semicolon
multiline_comment|/* check on output */
)brace
suffix:semicolon
multiline_comment|/* defines for inflate input/output */
multiline_comment|/*   update pointers and return */
DECL|macro|UPDBITS
mdefine_line|#define UPDBITS {s-&gt;bitb=b;s-&gt;bitk=k;}
DECL|macro|UPDIN
mdefine_line|#define UPDIN {z-&gt;avail_in=n;z-&gt;total_in+=p-z-&gt;next_in;z-&gt;next_in=p;}
DECL|macro|UPDOUT
mdefine_line|#define UPDOUT {s-&gt;write=q;}
DECL|macro|UPDATE
mdefine_line|#define UPDATE {UPDBITS UPDIN UPDOUT}
DECL|macro|LEAVE
mdefine_line|#define LEAVE {UPDATE return inflate_flush(s,z,r);}
multiline_comment|/*   get bytes and bits */
DECL|macro|LOADIN
mdefine_line|#define LOADIN {p=z-&gt;next_in;n=z-&gt;avail_in;b=s-&gt;bitb;k=s-&gt;bitk;}
DECL|macro|NEEDBYTE
mdefine_line|#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
DECL|macro|NEXTBYTE
mdefine_line|#define NEXTBYTE (n--,*p++)
DECL|macro|NEEDBITS
mdefine_line|#define NEEDBITS(j) {while(k&lt;(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)&lt;&lt;k;k+=8;}}
DECL|macro|DUMPBITS
mdefine_line|#define DUMPBITS(j) {b&gt;&gt;=(j);k-=(j);}
multiline_comment|/*   output bytes */
DECL|macro|WAVAIL
mdefine_line|#define WAVAIL (uInt)(q&lt;s-&gt;read?s-&gt;read-q-1:s-&gt;end-q)
DECL|macro|LOADOUT
mdefine_line|#define LOADOUT {q=s-&gt;write;m=(uInt)WAVAIL;}
DECL|macro|WWRAP
mdefine_line|#define WWRAP {if(q==s-&gt;end&amp;&amp;s-&gt;read!=s-&gt;window){q=s-&gt;window;m=(uInt)WAVAIL;}}
DECL|macro|FLUSH
mdefine_line|#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
DECL|macro|NEEDOUT
mdefine_line|#define NEEDOUT {if(m==0){WWRAP if(m==0){FLUSH WWRAP if(m==0) LEAVE}}r=Z_OK;}
DECL|macro|OUTBYTE
mdefine_line|#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
multiline_comment|/*   load local pointers */
DECL|macro|LOAD
mdefine_line|#define LOAD {LOADIN LOADOUT}
multiline_comment|/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
r_extern
id|uInt
id|inflate_mask
(braket
l_int|17
)braket
suffix:semicolon
multiline_comment|/* copy as much as possible from the sliding window to the output area */
r_extern
r_int
id|inflate_flush
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_streamp
comma
r_int
)paren
)paren
suffix:semicolon
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|internal_state
DECL|member|dummy
r_struct
id|internal_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
macro_line|#endif
multiline_comment|/* --- infutil.h */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|inflate_codes_state
DECL|member|dummy
r_struct
id|inflate_codes_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
multiline_comment|/* Table for deflate from PKZIP&squot;s appnote.txt. */
DECL|variable|border
id|local
r_const
id|uInt
id|border
(braket
)braket
op_assign
(brace
multiline_comment|/* Order of the bit length code lengths */
l_int|16
comma
l_int|17
comma
l_int|18
comma
l_int|0
comma
l_int|8
comma
l_int|7
comma
l_int|9
comma
l_int|6
comma
l_int|10
comma
l_int|5
comma
l_int|11
comma
l_int|4
comma
l_int|12
comma
l_int|3
comma
l_int|13
comma
l_int|2
comma
l_int|14
comma
l_int|1
comma
l_int|15
)brace
suffix:semicolon
multiline_comment|/*&n;   Notes beyond the 1.93a appnote.txt:&n;&n;   1. Distance pointers never point before the beginning of the output&n;      stream.&n;   2. Distance pointers can point back across blocks, up to 32k away.&n;   3. There is an implied maximum of 7 bits for the bit length table and&n;      15 bits for the actual data.&n;   4. If only one code exists, then it is encoded using one bit.  (Zero&n;      would be more efficient, but perhaps a little confusing.)  If two&n;      codes exist, they are coded using one bit each (0 and 1).&n;   5. There is no way of sending zero distance codes--a dummy must be&n;      sent if there are none.  (History: a pre 2.0 version of PKZIP would&n;      store blocks with no distance codes, but this was discovered to be&n;      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow&n;      zero distance codes, which is sent as one code of zero bits in&n;      length.&n;   6. There are up to 286 literal/length codes.  Code 256 represents the&n;      end-of-block.  Note however that the static length tree defines&n;      288 codes just to fill out the Huffman codes.  Codes 286 and 287&n;      cannot be used though, since there is no length base or extra bits&n;      defined for them.  Similarily, there are up to 30 distance codes.&n;      However, static trees define 32 codes (all 5 bits) to fill out the&n;      Huffman codes, but the last two had better not show up in the data.&n;   7. Unzip can check dynamic Huffman blocks for complete code sets.&n;      The exception is that a single code would not be complete (see #4).&n;   8. The five bits following the block type is really the number of&n;      literal codes sent minus 257.&n;   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits&n;      (1+6+6).  Therefore, to output three times the length, you output&n;      three codes (1+1+1), whereas to output four times the same length,&n;      you only need two codes (1+3).  Hmm.&n;  10. In the tree reconstruction algorithm, Code = Code + Increment&n;      only if BitLength(i) is not zero.  (Pretty obvious.)&n;  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)&n;  12. Note: length code 284 can represent 227-258, but length code 285&n;      really is 258.  The last length deserves its own, short code&n;      since it gets used a lot in very redundant files.  The length&n;      258 is special since 258 - 3 (the min match length) is 255.&n;  13. The literal/length and distance code bit lengths are read as a&n;      single stream of lengths.  It is possible (and advantageous) for&n;      a repeat code (16, 17, or 18) to go across the boundary between&n;      the two sets of lengths.&n; */
DECL|function|inflate_blocks_reset
r_void
id|inflate_blocks_reset
c_func
(paren
id|s
comma
id|z
comma
id|c
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
id|uLongf
op_star
id|c
suffix:semicolon
(brace
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
op_star
id|c
op_assign
id|s-&gt;check
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_eq
id|BTREE
op_logical_or
id|s-&gt;mode
op_eq
id|DTREE
)paren
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;sub.trees.blens
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_eq
id|CODES
)paren
(brace
id|inflate_codes_free
c_func
(paren
id|s-&gt;sub.decode.codes
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.td
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.tl
comma
id|z
)paren
suffix:semicolon
)brace
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
id|s-&gt;bitk
op_assign
l_int|0
suffix:semicolon
id|s-&gt;bitb
op_assign
l_int|0
suffix:semicolon
id|s-&gt;read
op_assign
id|s-&gt;write
op_assign
id|s-&gt;window
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|z-&gt;adler
op_assign
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
l_int|0L
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:   blocks reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|inflate_blocks_new
id|inflate_blocks_statef
op_star
id|inflate_blocks_new
c_func
(paren
id|z
comma
id|c
comma
id|w
)paren
id|z_streamp
id|z
suffix:semicolon
id|check_func
id|c
suffix:semicolon
id|uInt
id|w
suffix:semicolon
(brace
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
(paren
id|inflate_blocks_statef
op_star
)paren
id|ZALLOC
(paren
id|z
comma
l_int|1
comma
r_sizeof
(paren
r_struct
id|inflate_blocks_state
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
r_return
id|s
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;window
op_assign
(paren
id|Bytef
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
l_int|1
comma
id|w
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|ZFREE
c_func
(paren
id|z
comma
id|s
)paren
suffix:semicolon
r_return
id|Z_NULL
suffix:semicolon
)brace
id|s-&gt;end
op_assign
id|s-&gt;window
op_plus
id|w
suffix:semicolon
id|s-&gt;checkfn
op_assign
id|c
suffix:semicolon
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:   blocks allocated&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inflate_blocks_reset
c_func
(paren
id|s
comma
id|z
comma
op_amp
id|s-&gt;check
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ZLIB
r_extern
id|uInt
id|inflate_hufts
suffix:semicolon
macro_line|#endif
DECL|function|inflate_blocks
r_int
id|inflate_blocks
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
r_int
id|r
suffix:semicolon
(brace
id|uInt
id|t
suffix:semicolon
multiline_comment|/* temporary storage */
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
multiline_comment|/* copy input/output information to locals (UPDATE macro restores) */
id|LOAD
multiline_comment|/* process input based on current state */
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|s-&gt;mode
)paren
(brace
r_case
id|TYPE
suffix:colon
id|NEEDBITS
c_func
(paren
l_int|3
)paren
id|t
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|7
suffix:semicolon
id|s-&gt;last
op_assign
id|t
op_amp
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|t
op_rshift
l_int|1
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* stored */
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:     stored block%s&bslash;n&quot;
comma
id|s-&gt;last
ques
c_cond
l_string|&quot; (last)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|t
op_assign
id|k
op_amp
l_int|7
suffix:semicolon
multiline_comment|/* go to byte boundary */
id|DUMPBITS
c_func
(paren
id|t
)paren
id|s-&gt;mode
op_assign
id|LENS
suffix:semicolon
multiline_comment|/* get length of stored block */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* fixed */
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:     fixed codes block%s&bslash;n&quot;
comma
id|s-&gt;last
ques
c_cond
l_string|&quot; (last)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
(brace
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
id|inflate_trees_fixed
c_func
(paren
op_amp
id|bl
comma
op_amp
id|bd
comma
op_amp
id|tl
comma
op_amp
id|td
)paren
suffix:semicolon
id|s-&gt;sub.decode.codes
op_assign
id|inflate_codes_new
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;sub.decode.codes
op_eq
id|Z_NULL
)paren
(brace
id|r
op_assign
id|Z_MEM_ERROR
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.decode.tl
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* don&squot;t try to free these */
id|s-&gt;sub.decode.td
op_assign
id|Z_NULL
suffix:semicolon
)brace
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;mode
op_assign
id|CODES
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* dynamic */
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:     dynamic codes block%s&bslash;n&quot;
comma
id|s-&gt;last
ques
c_cond
l_string|&quot; (last)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;mode
op_assign
id|TABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* illegal */
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid block type&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
r_break
suffix:semicolon
r_case
id|LENS
suffix:colon
id|NEEDBITS
c_func
(paren
l_int|32
)paren
r_if
c_cond
(paren
(paren
(paren
(paren
op_complement
id|b
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
op_ne
(paren
id|b
op_amp
l_int|0xffff
)paren
)paren
(brace
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid stored block lengths&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.left
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|0xffff
suffix:semicolon
id|b
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dump bits */
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       stored length %u&bslash;n&quot;
comma
id|s-&gt;sub.left
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|s-&gt;sub.left
ques
c_cond
id|STORED
suffix:colon
(paren
id|s-&gt;last
ques
c_cond
id|DRY
suffix:colon
id|TYPE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STORED
suffix:colon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
id|LEAVE
id|NEEDOUT
id|t
op_assign
id|s-&gt;sub.left
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|n
)paren
id|t
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|m
)paren
id|t
op_assign
id|m
suffix:semicolon
id|zmemcpy
c_func
(paren
id|q
comma
id|p
comma
id|t
)paren
suffix:semicolon
id|p
op_add_assign
id|t
suffix:semicolon
id|n
op_sub_assign
id|t
suffix:semicolon
id|q
op_add_assign
id|t
suffix:semicolon
id|m
op_sub_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sub.left
op_sub_assign
id|t
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       stored end, %lu total out&bslash;n&quot;
comma
id|z-&gt;total_out
op_plus
(paren
id|q
op_ge
id|s-&gt;read
ques
c_cond
id|q
op_minus
id|s-&gt;read
suffix:colon
(paren
id|s-&gt;end
op_minus
id|s-&gt;read
)paren
op_plus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|s-&gt;last
ques
c_cond
id|DRY
suffix:colon
id|TYPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TABLE
suffix:colon
id|NEEDBITS
c_func
(paren
l_int|14
)paren
id|s-&gt;sub.trees.table
op_assign
id|t
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|0x3fff
suffix:semicolon
macro_line|#ifndef PKZIP_BUG_WORKAROUND
r_if
c_cond
(paren
(paren
id|t
op_amp
l_int|0x1f
)paren
OG
l_int|29
op_logical_or
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
OG
l_int|29
)paren
(brace
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;too many length or distance symbols&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
macro_line|#endif
id|t
op_assign
l_int|258
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
l_int|19
)paren
id|t
op_assign
l_int|19
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sub.trees.blens
op_assign
(paren
id|uIntf
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
id|t
comma
r_sizeof
(paren
id|uInt
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|r
op_assign
id|Z_MEM_ERROR
suffix:semicolon
id|LEAVE
)brace
id|DUMPBITS
c_func
(paren
l_int|14
)paren
id|s-&gt;sub.trees.index
op_assign
l_int|0
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       table sizes ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|BTREE
suffix:semicolon
r_case
id|BTREE
suffix:colon
r_while
c_loop
(paren
id|s-&gt;sub.trees.index
OL
l_int|4
op_plus
(paren
id|s-&gt;sub.trees.table
op_rshift
l_int|10
)paren
)paren
(brace
id|NEEDBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;sub.trees.blens
(braket
id|border
(braket
id|s-&gt;sub.trees.index
op_increment
)braket
)braket
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|7
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
)brace
r_while
c_loop
(paren
id|s-&gt;sub.trees.index
OL
l_int|19
)paren
id|s-&gt;sub.trees.blens
(braket
id|border
(braket
id|s-&gt;sub.trees.index
op_increment
)braket
)braket
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sub.trees.bb
op_assign
l_int|7
suffix:semicolon
id|t
op_assign
id|inflate_trees_bits
c_func
(paren
id|s-&gt;sub.trees.blens
comma
op_amp
id|s-&gt;sub.trees.bb
comma
op_amp
id|s-&gt;sub.trees.tb
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|Z_OK
)paren
(brace
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;sub.trees.blens
)paren
suffix:semicolon
id|r
op_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.trees.index
op_assign
l_int|0
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       bits tree ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|DTREE
suffix:semicolon
r_case
id|DTREE
suffix:colon
r_while
c_loop
(paren
id|t
op_assign
id|s-&gt;sub.trees.table
comma
id|s-&gt;sub.trees.index
OL
l_int|258
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
)paren
(brace
id|inflate_huft
op_star
id|h
suffix:semicolon
id|uInt
id|i
comma
id|j
comma
id|c
suffix:semicolon
id|t
op_assign
id|s-&gt;sub.trees.bb
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|t
)paren
id|h
op_assign
id|s-&gt;sub.trees.tb
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|t
)braket
)paren
suffix:semicolon
id|t
op_assign
id|h-&gt;word.what.Bits
suffix:semicolon
id|c
op_assign
id|h-&gt;more.Base
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|16
)paren
(brace
id|DUMPBITS
c_func
(paren
id|t
)paren
id|s-&gt;sub.trees.blens
(braket
id|s-&gt;sub.trees.index
op_increment
)braket
op_assign
id|c
suffix:semicolon
)brace
r_else
multiline_comment|/* c == 16..18 */
(brace
id|i
op_assign
id|c
op_eq
l_int|18
ques
c_cond
l_int|7
suffix:colon
id|c
op_minus
l_int|14
suffix:semicolon
id|j
op_assign
id|c
op_eq
l_int|18
ques
c_cond
l_int|11
suffix:colon
l_int|3
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|t
op_plus
id|i
)paren
id|DUMPBITS
c_func
(paren
id|t
)paren
id|j
op_add_assign
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|i
)braket
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|i
)paren
id|i
op_assign
id|s-&gt;sub.trees.index
suffix:semicolon
id|t
op_assign
id|s-&gt;sub.trees.table
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
id|j
OG
l_int|258
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
op_logical_or
(paren
id|c
op_eq
l_int|16
op_logical_and
id|i
OL
l_int|1
)paren
)paren
(brace
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.trees.tb
comma
id|z
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;sub.trees.blens
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid bit length repeat&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
id|c
op_assign
id|c
op_eq
l_int|16
ques
c_cond
id|s-&gt;sub.trees.blens
(braket
id|i
op_minus
l_int|1
)braket
suffix:colon
l_int|0
suffix:semicolon
r_do
(brace
id|s-&gt;sub.trees.blens
(braket
id|i
op_increment
)braket
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|j
)paren
suffix:semicolon
id|s-&gt;sub.trees.index
op_assign
id|i
suffix:semicolon
)brace
)brace
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.trees.tb
comma
id|z
)paren
suffix:semicolon
id|s-&gt;sub.trees.tb
op_assign
id|Z_NULL
suffix:semicolon
(brace
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
id|inflate_codes_statef
op_star
id|c
suffix:semicolon
id|bl
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* must be &lt;= 9 for lookahead assumptions */
id|bd
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* must be &lt;= 9 for lookahead assumptions */
id|t
op_assign
id|s-&gt;sub.trees.table
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
id|inflate_hufts
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|t
op_assign
id|inflate_trees_dynamic
c_func
(paren
l_int|257
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
comma
l_int|1
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
comma
id|s-&gt;sub.trees.blens
comma
op_amp
id|bl
comma
op_amp
id|bd
comma
op_amp
id|tl
comma
op_amp
id|td
comma
id|z
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;sub.trees.blens
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|Z_OK
)paren
(brace
r_if
c_cond
(paren
id|t
op_eq
(paren
id|uInt
)paren
id|Z_DATA_ERROR
)paren
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|r
op_assign
id|t
suffix:semicolon
id|LEAVE
)brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       trees ok, %d * %d bytes used&bslash;n&quot;
comma
id|inflate_hufts
comma
r_sizeof
(paren
id|inflate_huft
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|inflate_codes_new
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|inflate_trees_free
c_func
(paren
id|td
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|tl
comma
id|z
)paren
suffix:semicolon
id|r
op_assign
id|Z_MEM_ERROR
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.decode.codes
op_assign
id|c
suffix:semicolon
id|s-&gt;sub.decode.tl
op_assign
id|tl
suffix:semicolon
id|s-&gt;sub.decode.td
op_assign
id|td
suffix:semicolon
)brace
id|s-&gt;mode
op_assign
id|CODES
suffix:semicolon
r_case
id|CODES
suffix:colon
id|UPDATE
r_if
c_cond
(paren
(paren
id|r
op_assign
id|inflate_codes
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
)paren
op_ne
id|Z_STREAM_END
)paren
r_return
id|inflate_flush
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
suffix:semicolon
id|r
op_assign
id|Z_OK
suffix:semicolon
id|inflate_codes_free
c_func
(paren
id|s-&gt;sub.decode.codes
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.td
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.tl
comma
id|z
)paren
suffix:semicolon
id|LOAD
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       codes end, %lu total out&bslash;n&quot;
comma
id|z-&gt;total_out
op_plus
(paren
id|q
op_ge
id|s-&gt;read
ques
c_cond
id|q
op_minus
id|s-&gt;read
suffix:colon
(paren
id|s-&gt;end
op_minus
id|s-&gt;read
)paren
op_plus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;last
)paren
(brace
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|7
)paren
multiline_comment|/* return unused byte, if any */
(brace
id|Assert
c_func
(paren
id|k
OL
l_int|16
comma
l_string|&quot;inflate_codes grabbed too many bytes&quot;
)paren
id|k
op_sub_assign
l_int|8
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|p
op_decrement
suffix:semicolon
multiline_comment|/* can always return one */
)brace
id|s-&gt;mode
op_assign
id|DRY
suffix:semicolon
r_case
id|DRY
suffix:colon
id|FLUSH
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
id|LEAVE
id|s-&gt;mode
op_assign
id|DONEB
suffix:semicolon
r_case
id|DONEB
suffix:colon
id|r
op_assign
id|Z_STREAM_END
suffix:semicolon
id|LEAVE
r_case
id|BADB
suffix:colon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_default
suffix:colon
id|r
op_assign
id|Z_STREAM_ERROR
suffix:semicolon
id|LEAVE
)brace
)brace
DECL|function|inflate_blocks_free
r_int
id|inflate_blocks_free
c_func
(paren
id|s
comma
id|z
comma
id|c
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
id|uLongf
op_star
id|c
suffix:semicolon
(brace
id|inflate_blocks_reset
c_func
(paren
id|s
comma
id|z
comma
id|c
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;window
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|s
)paren
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:   blocks freed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflate_set_dictionary
r_void
id|inflate_set_dictionary
c_func
(paren
id|s
comma
id|d
comma
id|n
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
r_const
id|Bytef
op_star
id|d
suffix:semicolon
id|uInt
id|n
suffix:semicolon
(brace
id|zmemcpy
c_func
(paren
(paren
id|charf
op_star
)paren
id|s-&gt;window
comma
id|d
comma
id|n
)paren
suffix:semicolon
id|s-&gt;read
op_assign
id|s-&gt;write
op_assign
id|s-&gt;window
op_plus
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine adds the data at next_in/avail_in to the output history&n; * without performing any output.  The output buffer must be &quot;caught up&quot;;&n; * i.e. no pending output (hence s-&gt;read equals s-&gt;write), and the state must&n; * be BLOCKS (i.e. we should be willing to see the start of a series of&n; * BLOCKS).  On exit, the output will also be caught up, and the checksum&n; * will have been updated if need be.&n; */
DECL|function|inflate_addhistory
r_int
id|inflate_addhistory
c_func
(paren
id|s
comma
id|z
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
multiline_comment|/* NOT USED HERE */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
multiline_comment|/* NOT USED HERE */
id|uInt
id|t
suffix:semicolon
multiline_comment|/* temporary storage */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_ne
id|TYPE
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
multiline_comment|/* we&squot;re ready to rock */
id|LOAD
multiline_comment|/* while there is input ready, copy to output buffer, moving&n;     * pointers as needed.&n;     */
r_while
c_loop
(paren
id|n
)paren
(brace
id|t
op_assign
id|n
suffix:semicolon
multiline_comment|/* how many to do */
multiline_comment|/* is there room until end of buffer? */
r_if
c_cond
(paren
id|t
OG
id|m
)paren
id|t
op_assign
id|m
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|t
)paren
suffix:semicolon
id|zmemcpy
c_func
(paren
id|q
comma
id|p
comma
id|t
)paren
suffix:semicolon
id|q
op_add_assign
id|t
suffix:semicolon
id|p
op_add_assign
id|t
suffix:semicolon
id|n
op_sub_assign
id|t
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|t
suffix:semicolon
id|s-&gt;read
op_assign
id|q
suffix:semicolon
multiline_comment|/* drag read pointer forward */
multiline_comment|/*      WWRAP  */
multiline_comment|/* expand WWRAP macro by hand to handle s-&gt;read */
r_if
c_cond
(paren
id|q
op_eq
id|s-&gt;end
)paren
(brace
id|s-&gt;read
op_assign
id|q
op_assign
id|s-&gt;window
suffix:semicolon
id|m
op_assign
id|WAVAIL
suffix:semicolon
)brace
)brace
id|UPDATE
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * At the end of a Deflate-compressed PPP packet, we expect to have seen&n; * a `stored&squot; block type value but not the (zero) length bytes.&n; */
DECL|function|inflate_packet_flush
r_int
id|inflate_packet_flush
c_func
(paren
id|s
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
(brace
r_if
c_cond
(paren
id|s-&gt;mode
op_ne
id|LENS
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* --- infblock.c */
multiline_comment|/* +++ inftrees.c */
multiline_comment|/* inftrees.c -- generate Huffman trees for efficient decoding&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* #include &quot;inftrees.h&quot; */
DECL|variable|inflate_copyright
r_char
id|inflate_copyright
(braket
)braket
op_assign
l_string|&quot; inflate 1.0.4 Copyright 1995-1996 Mark Adler &quot;
suffix:semicolon
multiline_comment|/*&n;  If you use the zlib library in a product, an acknowledgment is welcome&n;  in the documentation of your product. If for some reason you cannot&n;  include such an acknowledgment, I would appreciate that you keep this&n;  copyright string in the executable of your product.&n; */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|internal_state
DECL|member|dummy
r_struct
id|internal_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
multiline_comment|/* simplify the use of the inflate_huft type with some defines */
DECL|macro|base
mdefine_line|#define base more.Base
DECL|macro|next
mdefine_line|#define next more.Next
DECL|macro|exop
mdefine_line|#define exop word.what.Exop
DECL|macro|bits
mdefine_line|#define bits word.what.Bits
id|local
r_int
id|huft_build
id|OF
c_func
(paren
(paren
id|uIntf
op_star
comma
multiline_comment|/* code lengths in bits */
id|uInt
comma
multiline_comment|/* number of codes */
id|uInt
comma
multiline_comment|/* number of &quot;simple&quot; codes */
r_const
id|uIntf
op_star
comma
multiline_comment|/* list of base values for non-simple codes */
r_const
id|uIntf
op_star
comma
multiline_comment|/* list of extra bits for non-simple codes */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* result: starting table */
id|uIntf
op_star
comma
multiline_comment|/* maximum lookup bits (returns actual) */
id|z_streamp
)paren
)paren
suffix:semicolon
multiline_comment|/* for zalloc function */
id|local
id|voidpf
id|falloc
id|OF
c_func
(paren
(paren
id|voidpf
comma
multiline_comment|/* opaque pointer (not used) */
id|uInt
comma
multiline_comment|/* number of items */
id|uInt
)paren
)paren
suffix:semicolon
multiline_comment|/* size of item */
multiline_comment|/* Tables for deflate from PKZIP&squot;s appnote.txt. */
DECL|variable|cplens
id|local
r_const
id|uInt
id|cplens
(braket
l_int|31
)braket
op_assign
(brace
multiline_comment|/* Copy lengths for literal codes 257..285 */
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|13
comma
l_int|15
comma
l_int|17
comma
l_int|19
comma
l_int|23
comma
l_int|27
comma
l_int|31
comma
l_int|35
comma
l_int|43
comma
l_int|51
comma
l_int|59
comma
l_int|67
comma
l_int|83
comma
l_int|99
comma
l_int|115
comma
l_int|131
comma
l_int|163
comma
l_int|195
comma
l_int|227
comma
l_int|258
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* see note #13 above about 258 */
DECL|variable|cplext
id|local
r_const
id|uInt
id|cplext
(braket
l_int|31
)braket
op_assign
(brace
multiline_comment|/* Extra bits for literal codes 257..285 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|0
comma
l_int|112
comma
l_int|112
)brace
suffix:semicolon
multiline_comment|/* 112==invalid */
DECL|variable|cpdist
id|local
r_const
id|uInt
id|cpdist
(braket
l_int|30
)braket
op_assign
(brace
multiline_comment|/* Copy offsets for distance codes 0..29 */
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|13
comma
l_int|17
comma
l_int|25
comma
l_int|33
comma
l_int|49
comma
l_int|65
comma
l_int|97
comma
l_int|129
comma
l_int|193
comma
l_int|257
comma
l_int|385
comma
l_int|513
comma
l_int|769
comma
l_int|1025
comma
l_int|1537
comma
l_int|2049
comma
l_int|3073
comma
l_int|4097
comma
l_int|6145
comma
l_int|8193
comma
l_int|12289
comma
l_int|16385
comma
l_int|24577
)brace
suffix:semicolon
DECL|variable|cpdext
id|local
r_const
id|uInt
id|cpdext
(braket
l_int|30
)braket
op_assign
(brace
multiline_comment|/* Extra bits for distance codes */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|6
comma
l_int|6
comma
l_int|7
comma
l_int|7
comma
l_int|8
comma
l_int|8
comma
l_int|9
comma
l_int|9
comma
l_int|10
comma
l_int|10
comma
l_int|11
comma
l_int|11
comma
l_int|12
comma
l_int|12
comma
l_int|13
comma
l_int|13
)brace
suffix:semicolon
multiline_comment|/*&n;   Huffman code decoding is performed using a multi-level table lookup.&n;   The fastest way to decode is to simply build a lookup table whose&n;   size is determined by the longest code.  However, the time it takes&n;   to build this table can also be a factor if the data being decoded&n;   is not very long.  The most common codes are necessarily the&n;   shortest codes, so those codes dominate the decoding time, and hence&n;   the speed.  The idea is you can have a shorter table that decodes the&n;   shorter, more probable codes, and then point to subsidiary tables for&n;   the longer codes.  The time it costs to decode the longer codes is&n;   then traded against the time it takes to make longer tables.&n;&n;   This results of this trade are in the variables lbits and dbits&n;   below.  lbits is the number of bits the first level table for literal/&n;   length codes can decode in one step, and dbits is the same thing for&n;   the distance codes.  Subsequent tables are also less than or equal to&n;   those sizes.  These values may be adjusted either when all of the&n;   codes are shorter than that, in which case the longest code length in&n;   bits is used, or when the shortest code is *longer* than the requested&n;   table size, in which case the length of the shortest code in bits is&n;   used.&n;&n;   There are two different values for the two tables, since they code a&n;   different number of possibilities each.  The literal/length table&n;   codes 286 possible values, or in a flat code, a little over eight&n;   bits.  The distance table codes 30 possible values, or a little less&n;   than five bits, flat.  The optimum values for speed end up being&n;   about one bit more than those, so lbits is 8+1 and dbits is 5+1.&n;   The optimum values may differ though from machine to machine, and&n;   possibly even between compilers.  Your mileage may vary.&n; */
multiline_comment|/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
DECL|macro|BMAX
mdefine_line|#define BMAX 15         /* maximum bit length of any code */
DECL|macro|N_MAX
mdefine_line|#define N_MAX 288       /* maximum number of codes in any set */
macro_line|#ifdef DEBUG_ZLIB
DECL|variable|inflate_hufts
id|uInt
id|inflate_hufts
suffix:semicolon
macro_line|#endif
DECL|function|huft_build
id|local
r_int
id|huft_build
c_func
(paren
id|b
comma
id|n
comma
id|s
comma
id|d
comma
id|e
comma
id|t
comma
id|m
comma
id|zs
)paren
id|uIntf
op_star
id|b
suffix:semicolon
multiline_comment|/* code lengths in bits (all assumed &lt;= BMAX) */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of codes (assumed &lt;= N_MAX) */
id|uInt
id|s
suffix:semicolon
multiline_comment|/* number of simple-valued codes (0..s-1) */
r_const
id|uIntf
op_star
id|d
suffix:semicolon
multiline_comment|/* list of base values for non-simple codes */
r_const
id|uIntf
op_star
id|e
suffix:semicolon
multiline_comment|/* list of extra bits for non-simple codes */
id|inflate_huft
op_star
id|FAR
op_star
id|t
suffix:semicolon
multiline_comment|/* result: starting table */
id|uIntf
op_star
id|m
suffix:semicolon
multiline_comment|/* maximum lookup bits, returns actual */
id|z_streamp
id|zs
suffix:semicolon
multiline_comment|/* for zalloc function */
multiline_comment|/* Given a list of code lengths and a maximum table size, make a set of&n;   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR&n;   if the given code set is incomplete (the tables are still built in this&n;   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of&n;   lengths), or Z_MEM_ERROR if not enough memory. */
(brace
id|uInt
id|a
suffix:semicolon
multiline_comment|/* counter for codes of length k */
id|uInt
id|c
(braket
id|BMAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bit length count table */
id|uInt
id|f
suffix:semicolon
multiline_comment|/* i repeats in table every f entries */
r_int
id|g
suffix:semicolon
multiline_comment|/* maximum code length */
r_int
id|h
suffix:semicolon
multiline_comment|/* table level */
r_register
id|uInt
id|i
suffix:semicolon
multiline_comment|/* counter, current code */
r_register
id|uInt
id|j
suffix:semicolon
multiline_comment|/* counter */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in current code */
r_int
id|l
suffix:semicolon
multiline_comment|/* bits per table (returned in m) */
r_register
id|uIntf
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer into c[], b[], or v[] */
id|inflate_huft
op_star
id|q
suffix:semicolon
multiline_comment|/* points to current table */
r_struct
id|inflate_huft_s
id|r
suffix:semicolon
multiline_comment|/* table entry for structure assignment */
id|inflate_huft
op_star
id|u
(braket
id|BMAX
)braket
suffix:semicolon
multiline_comment|/* table stack */
id|uInt
id|v
(braket
id|N_MAX
)braket
suffix:semicolon
multiline_comment|/* values in order of bit length */
r_register
r_int
id|w
suffix:semicolon
multiline_comment|/* bits before this table == (l * h) */
id|uInt
id|x
(braket
id|BMAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bit offsets, then code stack */
id|uIntf
op_star
id|xp
suffix:semicolon
multiline_comment|/* pointer into x */
r_int
id|y
suffix:semicolon
multiline_comment|/* number of dummy codes added */
id|uInt
id|z
suffix:semicolon
multiline_comment|/* number of entries in current table */
multiline_comment|/* Generate counts for each bit length */
id|p
op_assign
id|c
suffix:semicolon
DECL|macro|C0
mdefine_line|#define C0 *p++ = 0;
DECL|macro|C2
mdefine_line|#define C2 C0 C0 C0 C0
DECL|macro|C4
mdefine_line|#define C4 C2 C2 C2 C2
id|C4
multiline_comment|/* clear c[]--assume BMAX+1 is 16 */
id|p
op_assign
id|b
suffix:semicolon
id|i
op_assign
id|n
suffix:semicolon
r_do
(brace
id|c
(braket
op_star
id|p
op_increment
)braket
op_increment
suffix:semicolon
multiline_comment|/* assume all entries &lt;= BMAX */
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
(braket
l_int|0
)braket
op_eq
id|n
)paren
multiline_comment|/* null input--all zero length codes */
(brace
op_star
id|t
op_assign
(paren
id|inflate_huft
op_star
)paren
id|Z_NULL
suffix:semicolon
op_star
id|m
op_assign
l_int|0
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* Find minimum and maximum length, bound *m by those */
id|l
op_assign
op_star
id|m
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|BMAX
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|c
(braket
id|j
)braket
)paren
r_break
suffix:semicolon
id|k
op_assign
id|j
suffix:semicolon
multiline_comment|/* minimum code length */
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|l
OL
id|j
)paren
id|l
op_assign
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|BMAX
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|c
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|g
op_assign
id|i
suffix:semicolon
multiline_comment|/* maximum code length */
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|l
OG
id|i
)paren
id|l
op_assign
id|i
suffix:semicolon
op_star
id|m
op_assign
id|l
suffix:semicolon
multiline_comment|/* Adjust last length count to fill out codes, if needed */
r_for
c_loop
(paren
id|y
op_assign
l_int|1
op_lshift
id|j
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
comma
id|y
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|y
op_sub_assign
id|c
(braket
id|j
)braket
)paren
OL
l_int|0
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|y
op_sub_assign
id|c
(braket
id|i
)braket
)paren
OL
l_int|0
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|c
(braket
id|i
)braket
op_add_assign
id|y
suffix:semicolon
multiline_comment|/* Generate starting offsets into the value table for each length */
id|x
(braket
l_int|1
)braket
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|c
op_plus
l_int|1
suffix:semicolon
id|xp
op_assign
id|x
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
(brace
multiline_comment|/* note that i == g from above */
op_star
id|xp
op_increment
op_assign
(paren
id|j
op_add_assign
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/* Make a table of values in order of bit lengths */
id|p
op_assign
id|b
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|j
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
id|v
(braket
id|x
(braket
id|j
)braket
op_increment
)braket
op_assign
id|i
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
OL
id|n
)paren
suffix:semicolon
id|n
op_assign
id|x
(braket
id|g
)braket
suffix:semicolon
multiline_comment|/* set n to length of v */
multiline_comment|/* Generate the Huffman codes and for each, make the table entries */
id|x
(braket
l_int|0
)braket
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first Huffman code is zero */
id|p
op_assign
id|v
suffix:semicolon
multiline_comment|/* grab values in bit order */
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no tables yet--level -1 */
id|w
op_assign
op_minus
id|l
suffix:semicolon
multiline_comment|/* bits decoded == (l * h) */
id|u
(braket
l_int|0
)braket
op_assign
(paren
id|inflate_huft
op_star
)paren
id|Z_NULL
suffix:semicolon
multiline_comment|/* just to keep compilers happy */
id|q
op_assign
(paren
id|inflate_huft
op_star
)paren
id|Z_NULL
suffix:semicolon
multiline_comment|/* ditto */
id|z
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ditto */
multiline_comment|/* go through the bit lengths (k already is bits in shortest code) */
r_for
c_loop
(paren
suffix:semicolon
id|k
op_le
id|g
suffix:semicolon
id|k
op_increment
)paren
(brace
id|a
op_assign
id|c
(braket
id|k
)braket
suffix:semicolon
r_while
c_loop
(paren
id|a
op_decrement
)paren
(brace
multiline_comment|/* here i is the Huffman code of length k bits for value *p */
multiline_comment|/* make tables up to required level */
r_while
c_loop
(paren
id|k
OG
id|w
op_plus
id|l
)paren
(brace
id|h
op_increment
suffix:semicolon
id|w
op_add_assign
id|l
suffix:semicolon
multiline_comment|/* previous table always l bits */
multiline_comment|/* compute minimum size table less than or equal to l bits */
id|z
op_assign
id|g
op_minus
id|w
suffix:semicolon
id|z
op_assign
id|z
OG
(paren
id|uInt
)paren
id|l
ques
c_cond
id|l
suffix:colon
id|z
suffix:semicolon
multiline_comment|/* table size upper limit */
r_if
c_cond
(paren
(paren
id|f
op_assign
l_int|1
op_lshift
(paren
id|j
op_assign
id|k
op_minus
id|w
)paren
)paren
OG
id|a
op_plus
l_int|1
)paren
multiline_comment|/* try a k-w bit table */
(brace
multiline_comment|/* too few codes for k-w bit table */
id|f
op_sub_assign
id|a
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* deduct codes from patterns left */
id|xp
op_assign
id|c
op_plus
id|k
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|z
)paren
r_while
c_loop
(paren
op_increment
id|j
OL
id|z
)paren
multiline_comment|/* try smaller tables up to z bits */
(brace
r_if
c_cond
(paren
(paren
id|f
op_lshift_assign
l_int|1
)paren
op_le
op_star
op_increment
id|xp
)paren
r_break
suffix:semicolon
multiline_comment|/* enough codes to use up j bits */
id|f
op_sub_assign
op_star
id|xp
suffix:semicolon
multiline_comment|/* else deduct codes from patterns */
)brace
)brace
id|z
op_assign
l_int|1
op_lshift
id|j
suffix:semicolon
multiline_comment|/* table entries for j-bit table */
multiline_comment|/* allocate and link in new table */
r_if
c_cond
(paren
(paren
id|q
op_assign
(paren
id|inflate_huft
op_star
)paren
id|ZALLOC
(paren
id|zs
comma
id|z
op_plus
l_int|1
comma
r_sizeof
(paren
id|inflate_huft
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
r_if
c_cond
(paren
id|h
)paren
id|inflate_trees_free
c_func
(paren
id|u
(braket
l_int|0
)braket
comma
id|zs
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
multiline_comment|/* not enough memory */
)brace
macro_line|#ifdef DEBUG_ZLIB
id|inflate_hufts
op_add_assign
id|z
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
op_star
id|t
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* link to list for huft_free() */
op_star
(paren
id|t
op_assign
op_amp
(paren
id|q-&gt;next
)paren
)paren
op_assign
id|Z_NULL
suffix:semicolon
id|u
(braket
id|h
)braket
op_assign
op_increment
id|q
suffix:semicolon
multiline_comment|/* table starts after link */
multiline_comment|/* connect to last table, if there is one */
r_if
c_cond
(paren
id|h
)paren
(brace
id|x
(braket
id|h
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/* save pattern for backing up */
id|r.bits
op_assign
(paren
id|Byte
)paren
id|l
suffix:semicolon
multiline_comment|/* bits to dump before this table */
id|r.exop
op_assign
(paren
id|Byte
)paren
id|j
suffix:semicolon
multiline_comment|/* bits in this table */
id|r.next
op_assign
id|q
suffix:semicolon
multiline_comment|/* pointer to this table */
id|j
op_assign
id|i
op_rshift
(paren
id|w
op_minus
id|l
)paren
suffix:semicolon
multiline_comment|/* (get around Turbo C bug) */
id|u
(braket
id|h
op_minus
l_int|1
)braket
(braket
id|j
)braket
op_assign
id|r
suffix:semicolon
multiline_comment|/* connect to last table */
)brace
)brace
multiline_comment|/* set up table entry in r */
id|r.bits
op_assign
(paren
id|Byte
)paren
(paren
id|k
op_minus
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|v
op_plus
id|n
)paren
id|r.exop
op_assign
l_int|128
op_plus
l_int|64
suffix:semicolon
multiline_comment|/* out of values--invalid code */
r_else
r_if
c_cond
(paren
op_star
id|p
OL
id|s
)paren
(brace
id|r.exop
op_assign
(paren
id|Byte
)paren
(paren
op_star
id|p
OL
l_int|256
ques
c_cond
l_int|0
suffix:colon
l_int|32
op_plus
l_int|64
)paren
suffix:semicolon
multiline_comment|/* 256 is end-of-block */
id|r.base
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* simple code is just the value */
)brace
r_else
(brace
id|r.exop
op_assign
(paren
id|Byte
)paren
(paren
id|e
(braket
op_star
id|p
op_minus
id|s
)braket
op_plus
l_int|16
op_plus
l_int|64
)paren
suffix:semicolon
multiline_comment|/* non-simple--look up in lists */
id|r.base
op_assign
id|d
(braket
op_star
id|p
op_increment
op_minus
id|s
)braket
suffix:semicolon
)brace
multiline_comment|/* fill code-like entries with r */
id|f
op_assign
l_int|1
op_lshift
(paren
id|k
op_minus
id|w
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_rshift
id|w
suffix:semicolon
id|j
OL
id|z
suffix:semicolon
id|j
op_add_assign
id|f
)paren
id|q
(braket
id|j
)braket
op_assign
id|r
suffix:semicolon
multiline_comment|/* backwards increment the k-bit code i */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
op_lshift
(paren
id|k
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_amp
id|j
suffix:semicolon
id|j
op_rshift_assign
l_int|1
)paren
id|i
op_xor_assign
id|j
suffix:semicolon
id|i
op_xor_assign
id|j
suffix:semicolon
multiline_comment|/* backup over finished tables */
r_while
c_loop
(paren
(paren
id|i
op_amp
(paren
(paren
l_int|1
op_lshift
id|w
)paren
op_minus
l_int|1
)paren
)paren
op_ne
id|x
(braket
id|h
)braket
)paren
(brace
id|h
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t need to update q */
id|w
op_sub_assign
id|l
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Return Z_BUF_ERROR if we were given an incomplete table */
r_return
id|y
op_ne
l_int|0
op_logical_and
id|g
op_ne
l_int|1
ques
c_cond
id|Z_BUF_ERROR
suffix:colon
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflate_trees_bits
r_int
id|inflate_trees_bits
c_func
(paren
id|c
comma
id|bb
comma
id|tb
comma
id|z
)paren
id|uIntf
op_star
id|c
suffix:semicolon
multiline_comment|/* 19 code lengths */
id|uIntf
op_star
id|bb
suffix:semicolon
multiline_comment|/* bits tree desired/actual depth */
id|inflate_huft
op_star
id|FAR
op_star
id|tb
suffix:semicolon
multiline_comment|/* bits tree result */
id|z_streamp
id|z
suffix:semicolon
multiline_comment|/* for zfree function */
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|huft_build
c_func
(paren
id|c
comma
l_int|19
comma
l_int|19
comma
(paren
id|uIntf
op_star
)paren
id|Z_NULL
comma
(paren
id|uIntf
op_star
)paren
id|Z_NULL
comma
id|tb
comma
id|bb
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;oversubscribed dynamic bit lengths tree&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_eq
id|Z_BUF_ERROR
op_logical_or
op_star
id|bb
op_eq
l_int|0
)paren
(brace
id|inflate_trees_free
c_func
(paren
op_star
id|tb
comma
id|z
)paren
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incomplete dynamic bit lengths tree&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|inflate_trees_dynamic
r_int
id|inflate_trees_dynamic
c_func
(paren
id|nl
comma
id|nd
comma
id|c
comma
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
id|uInt
id|nl
suffix:semicolon
multiline_comment|/* number of literal/length codes */
id|uInt
id|nd
suffix:semicolon
multiline_comment|/* number of distance codes */
id|uIntf
op_star
id|c
suffix:semicolon
multiline_comment|/* that many (total) code lengths */
id|uIntf
op_star
id|bl
suffix:semicolon
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
id|bd
suffix:semicolon
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
id|tl
suffix:semicolon
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
id|td
suffix:semicolon
multiline_comment|/* distance tree result */
id|z_streamp
id|z
suffix:semicolon
multiline_comment|/* for zfree function */
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* build literal/length tree */
id|r
op_assign
id|huft_build
c_func
(paren
id|c
comma
id|nl
comma
l_int|257
comma
id|cplens
comma
id|cplext
comma
id|tl
comma
id|bl
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|Z_OK
op_logical_or
op_star
id|bl
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;oversubscribed literal/length tree&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_ne
id|Z_MEM_ERROR
)paren
(brace
id|inflate_trees_free
c_func
(paren
op_star
id|tl
comma
id|z
)paren
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incomplete literal/length tree&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* build distance tree */
id|r
op_assign
id|huft_build
c_func
(paren
id|c
op_plus
id|nl
comma
id|nd
comma
l_int|0
comma
id|cpdist
comma
id|cpdext
comma
id|td
comma
id|bd
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|Z_OK
op_logical_or
(paren
op_star
id|bd
op_eq
l_int|0
op_logical_and
id|nl
OG
l_int|257
)paren
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;oversubscribed distance tree&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_eq
id|Z_BUF_ERROR
)paren
(brace
macro_line|#ifdef PKZIP_BUG_WORKAROUND
id|r
op_assign
id|Z_OK
suffix:semicolon
)brace
macro_line|#else
id|inflate_trees_free
c_func
(paren
op_star
id|td
comma
id|z
)paren
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incomplete distance tree&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r
op_ne
id|Z_MEM_ERROR
)paren
(brace
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;empty distance tree with lengths&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
id|inflate_trees_free
c_func
(paren
op_star
id|tl
comma
id|z
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* done */
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* build fixed tables only once--keep them here */
DECL|variable|fixed_built
id|local
r_int
id|fixed_built
op_assign
l_int|0
suffix:semicolon
DECL|macro|FIXEDH
mdefine_line|#define FIXEDH 530      /* number of hufts used by fixed tables */
DECL|variable|fixed_mem
id|local
id|inflate_huft
id|fixed_mem
(braket
id|FIXEDH
)braket
suffix:semicolon
DECL|variable|fixed_bl
id|local
id|uInt
id|fixed_bl
suffix:semicolon
DECL|variable|fixed_bd
id|local
id|uInt
id|fixed_bd
suffix:semicolon
DECL|variable|fixed_tl
id|local
id|inflate_huft
op_star
id|fixed_tl
suffix:semicolon
DECL|variable|fixed_td
id|local
id|inflate_huft
op_star
id|fixed_td
suffix:semicolon
DECL|function|falloc
id|local
id|voidpf
id|falloc
c_func
(paren
id|q
comma
id|n
comma
id|s
)paren
id|voidpf
id|q
suffix:semicolon
multiline_comment|/* opaque pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of items */
id|uInt
id|s
suffix:semicolon
multiline_comment|/* size of item */
(brace
id|Assert
c_func
(paren
id|s
op_eq
r_sizeof
(paren
id|inflate_huft
)paren
op_logical_and
id|n
op_le
op_star
(paren
id|intf
op_star
)paren
id|q
comma
l_string|&quot;inflate_trees falloc overflow&quot;
)paren
suffix:semicolon
op_star
(paren
id|intf
op_star
)paren
id|q
op_sub_assign
id|n
op_plus
id|s
op_minus
id|s
suffix:semicolon
multiline_comment|/* s-s to avoid warning */
r_return
(paren
id|voidpf
)paren
(paren
id|fixed_mem
op_plus
op_star
(paren
id|intf
op_star
)paren
id|q
)paren
suffix:semicolon
)brace
DECL|function|inflate_trees_fixed
r_int
id|inflate_trees_fixed
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
)paren
id|uIntf
op_star
id|bl
suffix:semicolon
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
id|bd
suffix:semicolon
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
id|tl
suffix:semicolon
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
id|td
suffix:semicolon
multiline_comment|/* distance tree result */
(brace
multiline_comment|/* build fixed tables if not already (multiple overlapped executions ok) */
r_if
c_cond
(paren
op_logical_neg
id|fixed_built
)paren
(brace
r_int
id|k
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|c
(braket
l_int|288
)braket
suffix:semicolon
multiline_comment|/* length list for huft_build */
id|z_stream
id|z
suffix:semicolon
multiline_comment|/* for falloc function */
r_int
id|f
op_assign
id|FIXEDH
suffix:semicolon
multiline_comment|/* number of hufts left in fixed_mem */
multiline_comment|/* set up fake z_stream for memory routines */
id|z.zalloc
op_assign
id|falloc
suffix:semicolon
id|z.zfree
op_assign
id|Z_NULL
suffix:semicolon
id|z.opaque
op_assign
(paren
id|voidpf
)paren
op_amp
id|f
suffix:semicolon
multiline_comment|/* literal table */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|144
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
l_int|256
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|9
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
l_int|280
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|7
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
l_int|288
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|8
suffix:semicolon
id|fixed_bl
op_assign
l_int|7
suffix:semicolon
id|huft_build
c_func
(paren
id|c
comma
l_int|288
comma
l_int|257
comma
id|cplens
comma
id|cplext
comma
op_amp
id|fixed_tl
comma
op_amp
id|fixed_bl
comma
op_amp
id|z
)paren
suffix:semicolon
multiline_comment|/* distance table */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|30
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|5
suffix:semicolon
id|fixed_bd
op_assign
l_int|5
suffix:semicolon
id|huft_build
c_func
(paren
id|c
comma
l_int|30
comma
l_int|0
comma
id|cpdist
comma
id|cpdext
comma
op_amp
id|fixed_td
comma
op_amp
id|fixed_bd
comma
op_amp
id|z
)paren
suffix:semicolon
multiline_comment|/* done */
id|Assert
c_func
(paren
id|f
op_eq
l_int|0
comma
l_string|&quot;invalid build of fixed tables&quot;
)paren
suffix:semicolon
id|fixed_built
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|bl
op_assign
id|fixed_bl
suffix:semicolon
op_star
id|bd
op_assign
id|fixed_bd
suffix:semicolon
op_star
id|tl
op_assign
id|fixed_tl
suffix:semicolon
op_star
id|td
op_assign
id|fixed_td
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflate_trees_free
r_int
id|inflate_trees_free
c_func
(paren
id|t
comma
id|z
)paren
id|inflate_huft
op_star
id|t
suffix:semicolon
multiline_comment|/* table to free */
id|z_streamp
id|z
suffix:semicolon
multiline_comment|/* for zfree function */
multiline_comment|/* Free the malloc&squot;ed tables built by huft_build(), which makes a linked&n;   list of the tables it made, with the links in a dummy first entry of&n;   each table. */
(brace
r_register
id|inflate_huft
op_star
id|p
comma
op_star
id|q
comma
op_star
id|r
suffix:semicolon
multiline_comment|/* Reverse linked list */
id|p
op_assign
id|Z_NULL
suffix:semicolon
id|q
op_assign
id|t
suffix:semicolon
r_while
c_loop
(paren
id|q
op_ne
id|Z_NULL
)paren
(brace
id|r
op_assign
(paren
id|q
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
id|q
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|next
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|q
suffix:semicolon
id|q
op_assign
id|r
suffix:semicolon
)brace
multiline_comment|/* Go through linked list, freeing from the malloced (t[-1]) address. */
r_while
c_loop
(paren
id|p
op_ne
id|Z_NULL
)paren
(brace
id|q
op_assign
(paren
op_decrement
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|p
)paren
suffix:semicolon
id|p
op_assign
id|q
suffix:semicolon
)brace
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* --- inftrees.c */
multiline_comment|/* +++ infcodes.c */
multiline_comment|/* infcodes.c -- process literals and length/distance pairs&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* #include &quot;inftrees.h&quot; */
multiline_comment|/* #include &quot;infblock.h&quot; */
multiline_comment|/* #include &quot;infcodes.h&quot; */
multiline_comment|/* #include &quot;infutil.h&quot; */
multiline_comment|/* +++ inffast.h */
multiline_comment|/* inffast.h -- header to use inffast.c&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
r_extern
r_int
id|inflate_fast
id|OF
c_func
(paren
(paren
id|uInt
comma
id|uInt
comma
id|inflate_huft
op_star
comma
id|inflate_huft
op_star
comma
id|inflate_blocks_statef
op_star
comma
id|z_streamp
)paren
)paren
suffix:semicolon
multiline_comment|/* --- inffast.h */
multiline_comment|/* simplify the use of the inflate_huft type with some defines */
DECL|macro|base
mdefine_line|#define base more.Base
DECL|macro|next
mdefine_line|#define next more.Next
DECL|macro|exop
mdefine_line|#define exop word.what.Exop
DECL|macro|bits
mdefine_line|#define bits word.what.Bits
multiline_comment|/* inflate codes private state */
DECL|struct|inflate_codes_state
r_struct
id|inflate_codes_state
(brace
multiline_comment|/* mode */
r_enum
(brace
multiline_comment|/* waiting for &quot;i:&quot;=input, &quot;o:&quot;=output, &quot;x:&quot;=nothing */
DECL|enumerator|START
id|START
comma
multiline_comment|/* x: set up for LEN */
DECL|enumerator|LEN
id|LEN
comma
multiline_comment|/* i: get length/literal/eob next */
DECL|enumerator|LENEXT
id|LENEXT
comma
multiline_comment|/* i: getting length extra (have base) */
DECL|enumerator|DIST
id|DIST
comma
multiline_comment|/* i: get distance next */
DECL|enumerator|DISTEXT
id|DISTEXT
comma
multiline_comment|/* i: getting distance extra */
DECL|enumerator|COPY
id|COPY
comma
multiline_comment|/* o: copying bytes in window, waiting for space */
DECL|enumerator|LIT
id|LIT
comma
multiline_comment|/* o: got literal, waiting for output space */
DECL|enumerator|WASH
id|WASH
comma
multiline_comment|/* o: got eob, possibly still output waiting */
DECL|enumerator|END
id|END
comma
multiline_comment|/* x: got eob and all data flushed */
DECL|enumerator|BADCODE
id|BADCODE
)brace
multiline_comment|/* x: got error */
DECL|member|mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate_codes mode */
multiline_comment|/* mode dependent information */
DECL|member|len
id|uInt
id|len
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|tree
id|inflate_huft
op_star
id|tree
suffix:semicolon
multiline_comment|/* pointer into tree */
DECL|member|need
id|uInt
id|need
suffix:semicolon
multiline_comment|/* bits needed */
DECL|member|code
)brace
id|code
suffix:semicolon
multiline_comment|/* if LEN or DIST, where in tree */
DECL|member|lit
id|uInt
id|lit
suffix:semicolon
multiline_comment|/* if LIT, literal */
r_struct
(brace
DECL|member|get
id|uInt
id|get
suffix:semicolon
multiline_comment|/* bits to get for extra */
DECL|member|dist
id|uInt
id|dist
suffix:semicolon
multiline_comment|/* distance back to copy from */
DECL|member|copy
)brace
id|copy
suffix:semicolon
multiline_comment|/* if EXT or COPY, where and how much */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
multiline_comment|/* mode independent information */
DECL|member|lbits
id|Byte
id|lbits
suffix:semicolon
multiline_comment|/* ltree bits decoded per branch */
DECL|member|dbits
id|Byte
id|dbits
suffix:semicolon
multiline_comment|/* dtree bits decoder per branch */
DECL|member|ltree
id|inflate_huft
op_star
id|ltree
suffix:semicolon
multiline_comment|/* literal/length/eob tree */
DECL|member|dtree
id|inflate_huft
op_star
id|dtree
suffix:semicolon
multiline_comment|/* distance tree */
)brace
suffix:semicolon
DECL|function|inflate_codes_new
id|inflate_codes_statef
op_star
id|inflate_codes_new
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
suffix:semicolon
id|inflate_huft
op_star
id|td
suffix:semicolon
multiline_comment|/* need separate declaration for Borland C++ */
id|z_streamp
id|z
suffix:semicolon
(brace
id|inflate_codes_statef
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
(paren
id|inflate_codes_statef
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
l_int|1
comma
r_sizeof
(paren
r_struct
id|inflate_codes_state
)paren
)paren
)paren
op_ne
id|Z_NULL
)paren
(brace
id|c-&gt;mode
op_assign
id|START
suffix:semicolon
id|c-&gt;lbits
op_assign
(paren
id|Byte
)paren
id|bl
suffix:semicolon
id|c-&gt;dbits
op_assign
(paren
id|Byte
)paren
id|bd
suffix:semicolon
id|c-&gt;ltree
op_assign
id|tl
suffix:semicolon
id|c-&gt;dtree
op_assign
id|td
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       codes new&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|inflate_codes
r_int
id|inflate_codes
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
r_int
id|r
suffix:semicolon
(brace
id|uInt
id|j
suffix:semicolon
multiline_comment|/* temporary storage */
id|inflate_huft
op_star
id|t
suffix:semicolon
multiline_comment|/* temporary pointer */
id|uInt
id|e
suffix:semicolon
multiline_comment|/* extra bits or operation */
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
id|Bytef
op_star
id|f
suffix:semicolon
multiline_comment|/* pointer to copy strings from */
id|inflate_codes_statef
op_star
id|c
op_assign
id|s-&gt;sub.decode.codes
suffix:semicolon
multiline_comment|/* codes state */
multiline_comment|/* copy input/output information to locals (UPDATE macro restores) */
id|LOAD
multiline_comment|/* process input and output based on current state */
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|c-&gt;mode
)paren
(brace
multiline_comment|/* waiting for &quot;i:&quot;=input, &quot;o:&quot;=output, &quot;x:&quot;=nothing */
r_case
id|START
suffix:colon
multiline_comment|/* x: set up for LEN */
macro_line|#ifndef SLOW
r_if
c_cond
(paren
id|m
op_ge
l_int|258
op_logical_and
id|n
op_ge
l_int|10
)paren
(brace
id|UPDATE
id|r
op_assign
id|inflate_fast
c_func
(paren
id|c-&gt;lbits
comma
id|c-&gt;dbits
comma
id|c-&gt;ltree
comma
id|c-&gt;dtree
comma
id|s
comma
id|z
)paren
suffix:semicolon
id|LOAD
r_if
c_cond
(paren
id|r
op_ne
id|Z_OK
)paren
(brace
id|c-&gt;mode
op_assign
id|r
op_eq
id|Z_STREAM_END
ques
c_cond
id|WASH
suffix:colon
id|BADCODE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* !SLOW */
id|c-&gt;sub.code.need
op_assign
id|c-&gt;lbits
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|c-&gt;ltree
suffix:semicolon
id|c-&gt;mode
op_assign
id|LEN
suffix:semicolon
r_case
id|LEN
suffix:colon
multiline_comment|/* i: get length/literal/eob next */
id|j
op_assign
id|c-&gt;sub.code.need
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|t
op_assign
id|c-&gt;sub.code.tree
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|e
op_assign
(paren
id|uInt
)paren
(paren
id|t-&gt;exop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_eq
l_int|0
)paren
multiline_comment|/* literal */
(brace
id|c-&gt;sub.lit
op_assign
id|t-&gt;base
suffix:semicolon
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
id|t-&gt;base
op_ge
l_int|0x20
op_logical_and
id|t-&gt;base
OL
l_int|0x7f
ques
c_cond
l_string|&quot;inflate:         literal &squot;%c&squot;&bslash;n&quot;
suffix:colon
l_string|&quot;inflate:         literal 0x%02x&bslash;n&quot;
comma
id|t-&gt;base
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|LIT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
multiline_comment|/* length */
(brace
id|c-&gt;sub.copy.get
op_assign
id|e
op_amp
l_int|15
suffix:semicolon
id|c-&gt;len
op_assign
id|t-&gt;base
suffix:semicolon
id|c-&gt;mode
op_assign
id|LENEXT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
multiline_comment|/* next table */
(brace
id|c-&gt;sub.code.need
op_assign
id|e
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|t-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e
op_amp
l_int|32
)paren
multiline_comment|/* end of block */
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         end of block&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|WASH
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c-&gt;mode
op_assign
id|BADCODE
suffix:semicolon
multiline_comment|/* invalid code */
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid literal/length code&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_case
id|LENEXT
suffix:colon
multiline_comment|/* i: getting length extra (have base) */
id|j
op_assign
id|c-&gt;sub.copy.get
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|c-&gt;len
op_add_assign
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|j
)paren
id|c-&gt;sub.code.need
op_assign
id|c-&gt;dbits
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|c-&gt;dtree
suffix:semicolon
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         length %u&bslash;n&quot;
comma
id|c-&gt;len
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|DIST
suffix:semicolon
r_case
id|DIST
suffix:colon
multiline_comment|/* i: get distance next */
id|j
op_assign
id|c-&gt;sub.code.need
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|t
op_assign
id|c-&gt;sub.code.tree
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|e
op_assign
(paren
id|uInt
)paren
(paren
id|t-&gt;exop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
multiline_comment|/* distance */
(brace
id|c-&gt;sub.copy.get
op_assign
id|e
op_amp
l_int|15
suffix:semicolon
id|c-&gt;sub.copy.dist
op_assign
id|t-&gt;base
suffix:semicolon
id|c-&gt;mode
op_assign
id|DISTEXT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
multiline_comment|/* next table */
(brace
id|c-&gt;sub.code.need
op_assign
id|e
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|t-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c-&gt;mode
op_assign
id|BADCODE
suffix:semicolon
multiline_comment|/* invalid code */
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid distance code&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_case
id|DISTEXT
suffix:colon
multiline_comment|/* i: getting distance extra */
id|j
op_assign
id|c-&gt;sub.copy.get
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|c-&gt;sub.copy.dist
op_add_assign
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|j
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         distance %u&bslash;n&quot;
comma
id|c-&gt;sub.copy.dist
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|COPY
suffix:semicolon
r_case
id|COPY
suffix:colon
multiline_comment|/* o: copying bytes in window, waiting for space */
macro_line|#ifndef __TURBOC__ /* Turbo C bug for following expression */
id|f
op_assign
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
OL
id|c-&gt;sub.copy.dist
ques
c_cond
id|s-&gt;end
op_minus
(paren
id|c-&gt;sub.copy.dist
op_minus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
suffix:colon
id|q
op_minus
id|c-&gt;sub.copy.dist
suffix:semicolon
macro_line|#else
id|f
op_assign
id|q
op_minus
id|c-&gt;sub.copy.dist
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
OL
id|c-&gt;sub.copy.dist
)paren
id|f
op_assign
id|s-&gt;end
op_minus
(paren
id|c-&gt;sub.copy.dist
op_minus
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|c-&gt;len
)paren
(brace
id|NEEDOUT
id|OUTBYTE
c_func
(paren
op_star
id|f
op_increment
)paren
r_if
c_cond
(paren
id|f
op_eq
id|s-&gt;end
)paren
id|f
op_assign
id|s-&gt;window
suffix:semicolon
id|c-&gt;len
op_decrement
suffix:semicolon
)brace
id|c-&gt;mode
op_assign
id|START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LIT
suffix:colon
multiline_comment|/* o: got literal, waiting for output space */
id|NEEDOUT
id|OUTBYTE
c_func
(paren
id|c-&gt;sub.lit
)paren
id|c-&gt;mode
op_assign
id|START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WASH
suffix:colon
multiline_comment|/* o: got eob, possibly more output */
id|FLUSH
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
id|LEAVE
id|c-&gt;mode
op_assign
id|END
suffix:semicolon
r_case
id|END
suffix:colon
id|r
op_assign
id|Z_STREAM_END
suffix:semicolon
id|LEAVE
r_case
id|BADCODE
suffix:colon
multiline_comment|/* x: got error */
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_default
suffix:colon
id|r
op_assign
id|Z_STREAM_ERROR
suffix:semicolon
id|LEAVE
)brace
)brace
DECL|function|inflate_codes_free
r_void
id|inflate_codes_free
c_func
(paren
id|c
comma
id|z
)paren
id|inflate_codes_statef
op_star
id|c
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
(brace
id|ZFREE
c_func
(paren
id|z
comma
id|c
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       codes free&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* --- infcodes.c */
multiline_comment|/* +++ infutil.c */
multiline_comment|/* inflate_util.c -- data and routines common to blocks and codes&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* #include &quot;infblock.h&quot; */
multiline_comment|/* #include &quot;inftrees.h&quot; */
multiline_comment|/* #include &quot;infcodes.h&quot; */
multiline_comment|/* #include &quot;infutil.h&quot; */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|inflate_codes_state
DECL|member|dummy
r_struct
id|inflate_codes_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
multiline_comment|/* And&squot;ing with mask[n] masks the lower n bits */
DECL|variable|inflate_mask
id|uInt
id|inflate_mask
(braket
l_int|17
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x0001
comma
l_int|0x0003
comma
l_int|0x0007
comma
l_int|0x000f
comma
l_int|0x001f
comma
l_int|0x003f
comma
l_int|0x007f
comma
l_int|0x00ff
comma
l_int|0x01ff
comma
l_int|0x03ff
comma
l_int|0x07ff
comma
l_int|0x0fff
comma
l_int|0x1fff
comma
l_int|0x3fff
comma
l_int|0x7fff
comma
l_int|0xffff
)brace
suffix:semicolon
multiline_comment|/* copy as much as possible from the sliding window to the output area */
DECL|function|inflate_flush
r_int
id|inflate_flush
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
r_int
id|r
suffix:semicolon
(brace
id|uInt
id|n
suffix:semicolon
id|Bytef
op_star
id|p
suffix:semicolon
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* local copies of source and destination pointers */
id|p
op_assign
id|z-&gt;next_out
suffix:semicolon
id|q
op_assign
id|s-&gt;read
suffix:semicolon
multiline_comment|/* compute number of bytes to copy as far as end of window */
id|n
op_assign
(paren
id|uInt
)paren
(paren
(paren
id|q
op_le
id|s-&gt;write
ques
c_cond
id|s-&gt;write
suffix:colon
id|s-&gt;end
)paren
op_minus
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|z-&gt;avail_out
)paren
id|n
op_assign
id|z-&gt;avail_out
suffix:semicolon
r_if
c_cond
(paren
id|n
op_logical_and
id|r
op_eq
id|Z_BUF_ERROR
)paren
id|r
op_assign
id|Z_OK
suffix:semicolon
multiline_comment|/* update counters */
id|z-&gt;avail_out
op_sub_assign
id|n
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|z-&gt;adler
op_assign
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* copy as far as end of window */
r_if
c_cond
(paren
id|p
op_ne
id|Z_NULL
)paren
(brace
id|zmemcpy
c_func
(paren
id|p
comma
id|q
comma
id|n
)paren
suffix:semicolon
id|p
op_add_assign
id|n
suffix:semicolon
)brace
id|q
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* see if more to copy at beginning of window */
r_if
c_cond
(paren
id|q
op_eq
id|s-&gt;end
)paren
(brace
multiline_comment|/* wrap pointers */
id|q
op_assign
id|s-&gt;window
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;write
op_eq
id|s-&gt;end
)paren
id|s-&gt;write
op_assign
id|s-&gt;window
suffix:semicolon
multiline_comment|/* compute bytes to copy */
id|n
op_assign
(paren
id|uInt
)paren
(paren
id|s-&gt;write
op_minus
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|z-&gt;avail_out
)paren
id|n
op_assign
id|z-&gt;avail_out
suffix:semicolon
r_if
c_cond
(paren
id|n
op_logical_and
id|r
op_eq
id|Z_BUF_ERROR
)paren
id|r
op_assign
id|Z_OK
suffix:semicolon
multiline_comment|/* update counters */
id|z-&gt;avail_out
op_sub_assign
id|n
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|z-&gt;adler
op_assign
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* copy */
r_if
c_cond
(paren
id|p
op_ne
id|Z_NULL
)paren
(brace
id|zmemcpy
c_func
(paren
id|p
comma
id|q
comma
id|n
)paren
suffix:semicolon
id|p
op_add_assign
id|n
suffix:semicolon
)brace
id|q
op_add_assign
id|n
suffix:semicolon
)brace
multiline_comment|/* update pointers */
id|z-&gt;next_out
op_assign
id|p
suffix:semicolon
id|s-&gt;read
op_assign
id|q
suffix:semicolon
multiline_comment|/* done */
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* --- infutil.c */
multiline_comment|/* +++ inffast.c */
multiline_comment|/* inffast.c -- process literals and length/distance pairs fast&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* #include &quot;zutil.h&quot; */
multiline_comment|/* #include &quot;inftrees.h&quot; */
multiline_comment|/* #include &quot;infblock.h&quot; */
multiline_comment|/* #include &quot;infcodes.h&quot; */
multiline_comment|/* #include &quot;infutil.h&quot; */
multiline_comment|/* #include &quot;inffast.h&quot; */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|inflate_codes_state
DECL|member|dummy
r_struct
id|inflate_codes_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
multiline_comment|/* simplify the use of the inflate_huft type with some defines */
DECL|macro|base
mdefine_line|#define base more.Base
DECL|macro|next
mdefine_line|#define next more.Next
DECL|macro|exop
mdefine_line|#define exop word.what.Exop
DECL|macro|bits
mdefine_line|#define bits word.what.Bits
multiline_comment|/* macros for bit input with no checking and for returning unused bytes */
DECL|macro|GRABBITS
mdefine_line|#define GRABBITS(j) {while(k&lt;(j)){b|=((uLong)NEXTBYTE)&lt;&lt;k;k+=8;}}
DECL|macro|UNGRAB
mdefine_line|#define UNGRAB {n+=(c=k&gt;&gt;3);p-=c;k&amp;=7;}
multiline_comment|/* Called with number of bytes left to write in window at least 258&n;   (the maximum string length) and number of input bytes available&n;   at least ten.  The ten bytes are six bytes for the longest length/&n;   distance pair plus four bytes for overloading the bit buffer. */
DECL|function|inflate_fast
r_int
id|inflate_fast
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|s
comma
id|z
)paren
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
suffix:semicolon
id|inflate_huft
op_star
id|td
suffix:semicolon
multiline_comment|/* need separate declaration for Borland C++ */
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_streamp
id|z
suffix:semicolon
(brace
id|inflate_huft
op_star
id|t
suffix:semicolon
multiline_comment|/* temporary pointer */
id|uInt
id|e
suffix:semicolon
multiline_comment|/* extra bits or operation */
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
id|uInt
id|ml
suffix:semicolon
multiline_comment|/* mask for literal/length tree */
id|uInt
id|md
suffix:semicolon
multiline_comment|/* mask for distance tree */
id|uInt
id|c
suffix:semicolon
multiline_comment|/* bytes to copy */
id|uInt
id|d
suffix:semicolon
multiline_comment|/* distance back to copy from */
id|Bytef
op_star
id|r
suffix:semicolon
multiline_comment|/* copy source pointer */
multiline_comment|/* load input, output, bit values */
id|LOAD
multiline_comment|/* initialize masks */
id|ml
op_assign
id|inflate_mask
(braket
id|bl
)braket
suffix:semicolon
id|md
op_assign
id|inflate_mask
(braket
id|bd
)braket
suffix:semicolon
multiline_comment|/* do until not enough input or output space for fast loop */
r_do
(brace
multiline_comment|/* assume called with m &gt;= 258 &amp;&amp; n &gt;= 10 */
multiline_comment|/* get literal/length code */
id|GRABBITS
c_func
(paren
l_int|20
)paren
multiline_comment|/* max bits for literal/length code */
r_if
c_cond
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|tl
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|ml
)paren
)paren
op_member_access_from_pointer
id|exop
)paren
op_eq
l_int|0
)paren
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
id|t-&gt;base
op_ge
l_int|0x20
op_logical_and
id|t-&gt;base
OL
l_int|0x7f
ques
c_cond
l_string|&quot;inflate:         * literal &squot;%c&squot;&bslash;n&quot;
suffix:colon
l_string|&quot;inflate:         * literal 0x%02x&bslash;n&quot;
comma
id|t-&gt;base
)paren
)paren
suffix:semicolon
op_star
id|q
op_increment
op_assign
(paren
id|Byte
)paren
id|t-&gt;base
suffix:semicolon
id|m
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_do
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
(brace
multiline_comment|/* get extra bits for length */
id|e
op_and_assign
l_int|15
suffix:semicolon
id|c
op_assign
id|t-&gt;base
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|e
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         * length %u&bslash;n&quot;
comma
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* decode distance base of block to copy */
id|GRABBITS
c_func
(paren
l_int|15
)paren
suffix:semicolon
multiline_comment|/* max bits for distance code */
id|e
op_assign
(paren
id|t
op_assign
id|td
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|md
)paren
)paren
op_member_access_from_pointer
id|exop
suffix:semicolon
r_do
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
(brace
multiline_comment|/* get extra bits to add to distance base */
id|e
op_and_assign
l_int|15
suffix:semicolon
id|GRABBITS
c_func
(paren
id|e
)paren
multiline_comment|/* get extra bits (up to 13) */
id|d
op_assign
id|t-&gt;base
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|e
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         * distance %u&bslash;n&quot;
comma
id|d
)paren
)paren
suffix:semicolon
multiline_comment|/* do the copy */
id|m
op_sub_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
op_ge
id|d
)paren
multiline_comment|/* offset before dest */
(brace
multiline_comment|/*  just copy */
id|r
op_assign
id|q
op_minus
id|d
suffix:semicolon
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
id|c
op_decrement
suffix:semicolon
multiline_comment|/* minimum count is three, */
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
id|c
op_decrement
suffix:semicolon
multiline_comment|/*  so unroll loop a little */
)brace
r_else
multiline_comment|/* else offset after destination */
(brace
id|e
op_assign
id|d
op_minus
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
suffix:semicolon
multiline_comment|/* bytes from offset to end */
id|r
op_assign
id|s-&gt;end
op_minus
id|e
suffix:semicolon
multiline_comment|/* pointer to offset */
r_if
c_cond
(paren
id|c
OG
id|e
)paren
multiline_comment|/* if source crosses, */
(brace
id|c
op_sub_assign
id|e
suffix:semicolon
multiline_comment|/* copy to end of window */
r_do
(brace
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|e
)paren
suffix:semicolon
id|r
op_assign
id|s-&gt;window
suffix:semicolon
multiline_comment|/* copy rest from start of window */
)brace
)brace
r_do
(brace
multiline_comment|/* copy all or what&squot;s left */
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
id|e
op_assign
(paren
id|t
op_assign
id|t-&gt;next
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
)paren
op_member_access_from_pointer
id|exop
suffix:semicolon
r_else
(brace
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid distance code&quot;
suffix:semicolon
id|UNGRAB
id|UPDATE
r_return
id|Z_DATA_ERROR
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|t-&gt;next
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
)paren
op_member_access_from_pointer
id|exop
)paren
op_eq
l_int|0
)paren
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
id|t-&gt;base
op_ge
l_int|0x20
op_logical_and
id|t-&gt;base
OL
l_int|0x7f
ques
c_cond
l_string|&quot;inflate:         * literal &squot;%c&squot;&bslash;n&quot;
suffix:colon
l_string|&quot;inflate:         * literal 0x%02x&bslash;n&quot;
comma
id|t-&gt;base
)paren
)paren
suffix:semicolon
op_star
id|q
op_increment
op_assign
(paren
id|Byte
)paren
id|t-&gt;base
suffix:semicolon
id|m
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|e
op_amp
l_int|32
)paren
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         * end of block&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|UNGRAB
id|UPDATE
r_return
id|Z_STREAM_END
suffix:semicolon
)brace
r_else
(brace
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid literal/length code&quot;
suffix:semicolon
id|UNGRAB
id|UPDATE
r_return
id|Z_DATA_ERROR
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|m
op_ge
l_int|258
op_logical_and
id|n
op_ge
l_int|10
)paren
suffix:semicolon
multiline_comment|/* not enough input or output--restore pointers and return */
id|UNGRAB
id|UPDATE
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* --- inffast.c */
multiline_comment|/* +++ zutil.c */
multiline_comment|/* zutil.c -- target dependent utility functions for the compression library&n; * Copyright (C) 1995-1996 Jean-loup Gailly.&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* From: zutil.c,v 1.17 1996/07/24 13:41:12 me Exp $ */
multiline_comment|/* #include &quot;zutil.h&quot; */
macro_line|#ifndef NO_DUMMY_DECL
DECL|struct|internal_state
DECL|member|dummy
r_struct
id|internal_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
macro_line|#endif
macro_line|#ifndef STDC
r_extern
r_void
m_exit
id|OF
c_func
(paren
(paren
r_int
)paren
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|z_errmsg
r_const
r_char
op_star
id|z_errmsg
(braket
l_int|10
)braket
op_assign
(brace
l_string|&quot;need dictionary&quot;
comma
multiline_comment|/* Z_NEED_DICT       2  */
l_string|&quot;stream end&quot;
comma
multiline_comment|/* Z_STREAM_END      1  */
l_string|&quot;&quot;
comma
multiline_comment|/* Z_OK              0  */
l_string|&quot;file error&quot;
comma
multiline_comment|/* Z_ERRNO         (-1) */
l_string|&quot;stream error&quot;
comma
multiline_comment|/* Z_STREAM_ERROR  (-2) */
l_string|&quot;data error&quot;
comma
multiline_comment|/* Z_DATA_ERROR    (-3) */
l_string|&quot;insufficient memory&quot;
comma
multiline_comment|/* Z_MEM_ERROR     (-4) */
l_string|&quot;buffer error&quot;
comma
multiline_comment|/* Z_BUF_ERROR     (-5) */
l_string|&quot;incompatible version&quot;
comma
multiline_comment|/* Z_VERSION_ERROR (-6) */
l_string|&quot;&quot;
)brace
suffix:semicolon
DECL|function|zlibVersion
r_const
r_char
op_star
id|zlibVersion
c_func
(paren
)paren
(brace
r_return
id|ZLIB_VERSION
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ZLIB
DECL|function|z_error
r_void
id|z_error
(paren
id|m
)paren
r_char
op_star
id|m
suffix:semicolon
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|m
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef HAVE_MEMCPY
DECL|function|zmemcpy
r_void
id|zmemcpy
c_func
(paren
id|dest
comma
id|source
comma
id|len
)paren
id|Bytef
op_star
id|dest
suffix:semicolon
id|Bytef
op_star
id|source
suffix:semicolon
id|uInt
id|len
suffix:semicolon
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_do
(brace
op_star
id|dest
op_increment
op_assign
op_star
id|source
op_increment
suffix:semicolon
multiline_comment|/* ??? to be unrolled */
)brace
r_while
c_loop
(paren
op_decrement
id|len
op_ne
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|zmemcmp
r_int
id|zmemcmp
c_func
(paren
id|s1
comma
id|s2
comma
id|len
)paren
id|Bytef
op_star
id|s1
suffix:semicolon
id|Bytef
op_star
id|s2
suffix:semicolon
id|uInt
id|len
suffix:semicolon
(brace
id|uInt
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s1
(braket
id|j
)braket
op_ne
id|s2
(braket
id|j
)braket
)paren
r_return
l_int|2
op_star
(paren
id|s1
(braket
id|j
)braket
OG
id|s2
(braket
id|j
)braket
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zmemzero
r_void
id|zmemzero
c_func
(paren
id|dest
comma
id|len
)paren
id|Bytef
op_star
id|dest
suffix:semicolon
id|uInt
id|len
suffix:semicolon
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_do
(brace
op_star
id|dest
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ??? to be unrolled */
)brace
r_while
c_loop
(paren
op_decrement
id|len
op_ne
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef __TURBOC__
macro_line|#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) &amp;&amp; !defined(__32BIT__)
multiline_comment|/* Small and medium model in Turbo C are for now limited to near allocation&n; * with reduced MAX_WBITS and MAX_MEM_LEVEL&n; */
DECL|macro|MY_ZCALLOC
macro_line|#  define MY_ZCALLOC
multiline_comment|/* Turbo C malloc() does not allow dynamic allocation of 64K bytes&n; * and farmalloc(64K) returns a pointer with an offset of 8, so we&n; * must fix the pointer. Warning: the pointer must be put back to its&n; * original form in order to free it, use zcfree().&n; */
DECL|macro|MAX_PTR
mdefine_line|#define MAX_PTR 10
multiline_comment|/* 10*64K = 640K */
DECL|variable|next_ptr
id|local
r_int
id|next_ptr
op_assign
l_int|0
suffix:semicolon
DECL|struct|ptr_table_s
r_typedef
r_struct
id|ptr_table_s
(brace
DECL|member|org_ptr
id|voidpf
id|org_ptr
suffix:semicolon
DECL|member|new_ptr
id|voidpf
id|new_ptr
suffix:semicolon
DECL|typedef|ptr_table
)brace
id|ptr_table
suffix:semicolon
DECL|variable|table
id|local
id|ptr_table
id|table
(braket
id|MAX_PTR
)braket
suffix:semicolon
multiline_comment|/* This table is used to remember the original form of pointers&n; * to large buffers (64K). Such pointers are normalized with a zero offset.&n; * Since MSDOS is not a preemptive multitasking OS, this table is not&n; * protected from concurrent access. This hack doesn&squot;t work anyway on&n; * a protected system like OS/2. Use Microsoft C instead.&n; */
DECL|function|zcalloc
id|voidpf
id|zcalloc
(paren
id|voidpf
id|opaque
comma
r_int
id|items
comma
r_int
id|size
)paren
(brace
id|voidpf
id|buf
op_assign
id|opaque
suffix:semicolon
multiline_comment|/* just to make some compilers happy */
id|ulg
id|bsize
op_assign
(paren
id|ulg
)paren
id|items
op_star
id|size
suffix:semicolon
multiline_comment|/* If we allocate less than 65520 bytes, we assume that farmalloc&n;     * will return a usable pointer which doesn&squot;t have to be normalized.&n;     */
r_if
c_cond
(paren
id|bsize
OL
l_int|65520L
)paren
(brace
id|buf
op_assign
id|farmalloc
c_func
(paren
id|bsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|ush
op_star
)paren
op_amp
id|buf
op_ne
l_int|0
)paren
r_return
id|buf
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|farmalloc
c_func
(paren
id|bsize
op_plus
l_int|16L
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
op_logical_or
id|next_ptr
op_ge
id|MAX_PTR
)paren
r_return
l_int|NULL
suffix:semicolon
id|table
(braket
id|next_ptr
)braket
dot
id|org_ptr
op_assign
id|buf
suffix:semicolon
multiline_comment|/* Normalize the pointer to seg:0 */
op_star
(paren
(paren
id|ush
op_star
)paren
op_amp
id|buf
op_plus
l_int|1
)paren
op_add_assign
(paren
(paren
id|ush
)paren
(paren
(paren
id|uch
op_star
)paren
id|buf
op_minus
l_int|0
)paren
op_plus
l_int|15
)paren
op_rshift
l_int|4
suffix:semicolon
op_star
(paren
id|ush
op_star
)paren
op_amp
id|buf
op_assign
l_int|0
suffix:semicolon
id|table
(braket
id|next_ptr
op_increment
)braket
dot
id|new_ptr
op_assign
id|buf
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|zcfree
r_void
id|zcfree
(paren
id|voidpf
id|opaque
comma
id|voidpf
id|ptr
)paren
(brace
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|ush
op_star
)paren
op_amp
id|ptr
op_ne
l_int|0
)paren
(brace
multiline_comment|/* object &lt; 64K */
id|farfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Find the original pointer */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|next_ptr
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptr
op_ne
id|table
(braket
id|n
)braket
dot
id|new_ptr
)paren
r_continue
suffix:semicolon
id|farfree
c_func
(paren
id|table
(braket
id|n
)braket
dot
id|org_ptr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|n
OL
id|next_ptr
)paren
(brace
id|table
(braket
id|n
op_minus
l_int|1
)braket
op_assign
id|table
(braket
id|n
)braket
suffix:semicolon
)brace
id|next_ptr
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ptr
op_assign
id|opaque
suffix:semicolon
multiline_comment|/* just to make some compilers happy */
id|Assert
c_func
(paren
l_int|0
comma
l_string|&quot;zcfree: ptr not found&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* __TURBOC__ */
macro_line|#if defined(M_I86) &amp;&amp; !defined(__32BIT__)
multiline_comment|/* Microsoft C in 16-bit mode */
DECL|macro|MY_ZCALLOC
macro_line|#  define MY_ZCALLOC
macro_line|#if (!defined(_MSC_VER) || (_MSC_VER &lt; 600))
DECL|macro|_halloc
macro_line|#  define _halloc  halloc
DECL|macro|_hfree
macro_line|#  define _hfree   hfree
macro_line|#endif
DECL|function|zcalloc
id|voidpf
id|zcalloc
(paren
id|voidpf
id|opaque
comma
r_int
id|items
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|opaque
)paren
id|opaque
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to make compiler happy */
r_return
id|_halloc
c_func
(paren
(paren
r_int
)paren
id|items
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|zcfree
r_void
id|zcfree
(paren
id|voidpf
id|opaque
comma
id|voidpf
id|ptr
)paren
(brace
r_if
c_cond
(paren
id|opaque
)paren
id|opaque
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to make compiler happy */
id|_hfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
macro_line|#endif /* MSC */
macro_line|#ifndef MY_ZCALLOC /* Any system without a special alloc function */
macro_line|#ifndef STDC
r_extern
id|voidp
id|calloc
id|OF
c_func
(paren
(paren
id|uInt
id|items
comma
id|uInt
id|size
)paren
)paren
suffix:semicolon
r_extern
r_void
id|free
id|OF
c_func
(paren
(paren
id|voidpf
id|ptr
)paren
)paren
suffix:semicolon
macro_line|#endif
DECL|function|zcalloc
id|voidpf
id|zcalloc
(paren
id|opaque
comma
id|items
comma
id|size
)paren
id|voidpf
id|opaque
suffix:semicolon
r_int
id|items
suffix:semicolon
r_int
id|size
suffix:semicolon
(brace
r_if
c_cond
(paren
id|opaque
)paren
id|items
op_add_assign
id|size
op_minus
id|size
suffix:semicolon
multiline_comment|/* make compiler happy */
r_return
(paren
id|voidpf
)paren
id|calloc
c_func
(paren
id|items
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|zcfree
r_void
id|zcfree
(paren
id|opaque
comma
id|ptr
)paren
id|voidpf
id|opaque
suffix:semicolon
id|voidpf
id|ptr
suffix:semicolon
(brace
id|free
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opaque
)paren
r_return
suffix:semicolon
multiline_comment|/* make compiler happy */
)brace
macro_line|#endif /* MY_ZCALLOC */
multiline_comment|/* --- zutil.c */
multiline_comment|/* +++ adler32.c */
multiline_comment|/* adler32.c -- compute the Adler-32 checksum of a data stream&n; * Copyright (C) 1995-1996 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* From: adler32.c,v 1.10 1996/05/22 11:52:18 me Exp $ */
multiline_comment|/* #include &quot;zlib.h&quot; */
DECL|macro|BASE
mdefine_line|#define BASE 65521L /* largest prime smaller than 65536 */
DECL|macro|NMAX
mdefine_line|#define NMAX 5552
multiline_comment|/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) &lt;= 2^32-1 */
DECL|macro|DO1
mdefine_line|#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
DECL|macro|DO2
mdefine_line|#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
DECL|macro|DO4
mdefine_line|#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
DECL|macro|DO8
mdefine_line|#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
DECL|macro|DO16
mdefine_line|#define DO16(buf)   DO8(buf,0); DO8(buf,8);
multiline_comment|/* ========================================================================= */
DECL|function|adler32
id|uLong
id|adler32
c_func
(paren
id|adler
comma
id|buf
comma
id|len
)paren
id|uLong
id|adler
suffix:semicolon
r_const
id|Bytef
op_star
id|buf
suffix:semicolon
id|uInt
id|len
suffix:semicolon
(brace
r_int
r_int
id|s1
op_assign
id|adler
op_amp
l_int|0xffff
suffix:semicolon
r_int
r_int
id|s2
op_assign
(paren
id|adler
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
id|Z_NULL
)paren
r_return
l_int|1L
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|k
op_assign
id|len
OL
id|NMAX
ques
c_cond
id|len
suffix:colon
id|NMAX
suffix:semicolon
id|len
op_sub_assign
id|k
suffix:semicolon
r_while
c_loop
(paren
id|k
op_ge
l_int|16
)paren
(brace
id|DO16
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|16
suffix:semicolon
id|k
op_sub_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ne
l_int|0
)paren
r_do
(brace
id|s1
op_add_assign
op_star
id|buf
op_increment
suffix:semicolon
id|s2
op_add_assign
id|s1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|k
)paren
suffix:semicolon
id|s1
op_mod_assign
id|BASE
suffix:semicolon
id|s2
op_mod_assign
id|BASE
suffix:semicolon
)brace
r_return
(paren
id|s2
op_lshift
l_int|16
)paren
op_or
id|s1
suffix:semicolon
)brace
multiline_comment|/* --- adler32.c */
eof
