multiline_comment|/*&n; *&n; *    Copyright (c) 1999 Grant Erickson &lt;grant@lcse.umn.edu&gt;&n; *&n; *    Module name: oaknet.c&n; *&n; *    Description:&n; *      Driver for the National Semiconductor DP83902AV Ethernet controller&n; *      on-board the IBM PowerPC &quot;Oak&quot; evaluation board. Adapted from the&n; *      various other 8390 drivers written by Donald Becker and Paul Gortmaker.&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;asm/board.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;8390.h&quot;
multiline_comment|/* Preprocessor Defines */
macro_line|#if !defined(TRUE) || TRUE != 1
DECL|macro|TRUE
mdefine_line|#define&t;TRUE&t;1
macro_line|#endif
macro_line|#if !defined(FALSE) || FALSE != 0
DECL|macro|FALSE
mdefine_line|#define&t;FALSE&t;0
macro_line|#endif
DECL|macro|OAKNET_CMD
mdefine_line|#define&t;OAKNET_CMD     &t;&t;0x00
DECL|macro|OAKNET_DATA
mdefine_line|#define OAKNET_DATA&t;&t;0x10&t;/* NS-defined port window offset. */
DECL|macro|OAKNET_RESET
mdefine_line|#define OAKNET_RESET&t;&t;0x1f&t;/* A read resets, a write clears. */
DECL|macro|OAKNET_START_PG
mdefine_line|#define&t;OAKNET_START_PG&t;&t;0x20&t;/* First page of TX buffer */
DECL|macro|OAKNET_STOP_PG
mdefine_line|#define&t;OAKNET_STOP_PG&t;&t;0x40&t;/* Last pagge +1 of RX ring */
DECL|macro|OAKNET_BASE
mdefine_line|#define&t;OAKNET_BASE&t;&t;(dev-&gt;base_addr)
DECL|macro|OAKNET_WAIT
mdefine_line|#define&t;OAKNET_WAIT&t;&t;(2 * HZ / 100)&t;/* 20 ms */
multiline_comment|/* Global Variables */
macro_line|#if defined(MODULE)
DECL|variable|oaknet_devs
r_static
r_struct
id|net_device
op_star
id|oaknet_devs
suffix:semicolon
macro_line|#endif
multiline_comment|/* Function Prototypes */
r_static
r_int
id|oaknet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|oaknet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|oaknet_reset_8390
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|oaknet_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
suffix:semicolon
r_static
r_void
id|oaknet_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|oaknet_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
suffix:semicolon
r_static
r_void
id|oaknet_dma_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
multiline_comment|/*&n; * int oaknet_init()&n; *&n; * Description:&n; *   This routine performs all the necessary platform-specific initiali-&n; *   zation and set-up for the IBM &quot;Oak&quot; evaluation board&squot;s National&n; *   Semiconductor DP83902AV &quot;ST-NIC&quot; Ethernet controller.&n; *&n; * Input(s):&n; *   N/A&n; *&n; * Output(s):&n; *   N/A&n; *&n; * Returns:&n; *   0 if OK, otherwise system error number on error.&n; *&n; */
r_int
DECL|function|oaknet_init
id|oaknet_init
c_func
(paren
r_void
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
r_int
id|reg0
comma
id|regd
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|OAKNET_IO_BASE
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;National DP83902AV&quot;
suffix:semicolon
id|bd_t
op_star
id|bip
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
multiline_comment|/* Quick register check to see if the device is really there. */
r_if
c_cond
(paren
(paren
id|reg0
op_assign
id|inb_p
c_func
(paren
id|ioaddr
)paren
)paren
op_eq
l_int|0xFF
)paren
r_return
(paren
id|ENODEV
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * That worked. Now a more thorough check, using the multicast&n;&t; * address registers, that the device is definitely out there&n;&t; * and semi-functional.&n;&t; */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
op_plus
id|E8390_STOP
comma
id|ioaddr
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|regd
op_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
l_int|0x0D
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xFF
comma
id|ioaddr
op_plus
l_int|0x0D
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
comma
id|ioaddr
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
multiline_comment|/* It&squot;s no good. Fix things back up and leave. */
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER0
)paren
op_ne
l_int|0
)paren
(brace
id|outb_p
c_func
(paren
id|reg0
comma
id|ioaddr
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|regd
comma
id|ioaddr
op_plus
l_int|0x0D
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;re dependent on the 8390 generic driver module, make&n;&t; * sure its symbols are loaded.&n;&t; */
r_if
c_cond
(paren
id|load_8390_module
c_func
(paren
l_string|&quot;oaknet.c&quot;
)paren
)paren
r_return
(paren
op_minus
id|ENOSYS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re not using the old-style probing API, so we have to allocate&n;&t; * our own device structure.&n;&t; */
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if defined(MODULE)
id|oaknet_devs
op_assign
id|dev
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * This controller is on an embedded board, so the base address&n;&t; * and interrupt assignments are pre-assigned and unchageable.&n;&t; */
id|dev-&gt;base_addr
op_assign
id|OAKNET_IO_BASE
suffix:semicolon
id|dev-&gt;irq
op_assign
id|OAKNET_INT
suffix:semicolon
multiline_comment|/* Allocate 8390-specific device-private area and fields. */
r_if
c_cond
(paren
id|ethdev_init
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; unable to get memory for dev-&gt;priv.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Just to be safe, reset the card as we cannot really* be sure&n;&t; * what state it was last left in.&n;&t; */
id|oaknet_reset_8390
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable all chip interrupts for now and ACK all pending&n;&t; * interrupts.&n;&t; */
id|outb_p
c_func
(paren
l_int|0x0
comma
id|ioaddr
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xFF
comma
id|ioaddr
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Attempt to get the interrupt line */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|ei_interrupt
comma
l_int|0
comma
id|name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to request interrupt %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|EAGAIN
)paren
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|OAKNET_IO_SIZE
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* Tell the world about what and where we&squot;ve found. */
id|printk
c_func
(paren
l_string|&quot;%s: %s at&quot;
comma
id|dev-&gt;name
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETHER_ADDR_LEN
suffix:semicolon
op_increment
id|i
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|bip-&gt;bi_enetaddr
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c%.2x&quot;
comma
(paren
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, found at %#lx, using IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* Set up some required driver fields and then we&squot;re done. */
id|ei_status.name
op_assign
id|name
suffix:semicolon
id|ei_status.word16
op_assign
id|FALSE
suffix:semicolon
id|ei_status.tx_start_page
op_assign
id|OAKNET_START_PG
suffix:semicolon
id|ei_status.rx_start_page
op_assign
id|OAKNET_START_PG
op_plus
id|TX_PAGES
suffix:semicolon
id|ei_status.stop_page
op_assign
id|OAKNET_STOP_PG
suffix:semicolon
id|ei_status.reset_8390
op_assign
op_amp
id|oaknet_reset_8390
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|oaknet_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|oaknet_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|oaknet_get_8390_hdr
suffix:semicolon
id|dev-&gt;open
op_assign
id|oaknet_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|oaknet_close
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
id|FALSE
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * static int oaknet_open()&n; *&n; * Description:&n; *   This routine is a modest wrapper around ei_open, the 8390-generic,&n; *   driver open routine. This just increments the module usage count&n; *   and passes along the status from ei_open.&n; *&n; * Input(s):&n; *  *dev - Pointer to the device structure for this driver.&n; *&n; * Output(s):&n; *  *dev - Pointer to the device structure for this driver, potentially&n; *         modified by ei_open.&n; *&n; * Returns:&n; *   0 if OK, otherwise &lt; 0 on error.&n; *&n; */
r_static
r_int
DECL|function|oaknet_open
id|oaknet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|status
op_assign
id|ei_open
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * static int oaknet_close()&n; *&n; * Description:&n; *   This routine is a modest wrapper around ei_close, the 8390-generic,&n; *   driver close routine. This just decrements the module usage count&n; *   and passes along the status from ei_close.&n; *&n; * Input(s):&n; *  *dev - Pointer to the device structure for this driver.&n; *&n; * Output(s):&n; *  *dev - Pointer to the device structure for this driver, potentially&n; *         modified by ei_close.&n; *&n; * Returns:&n; *   0 if OK, otherwise &lt; 0 on error.&n; *&n; */
r_static
r_int
DECL|function|oaknet_close
id|oaknet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|status
op_assign
id|ei_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * static void oaknet_reset_8390()&n; *&n; * Description:&n; *   This routine resets the DP83902 chip.&n; *&n; * Input(s):&n; *  *dev - &n; *&n; * Output(s):&n; *   N/A&n; *&n; * Returns:&n; *   N/A&n; *&n; */
r_static
r_void
DECL|function|oaknet_reset_8390
id|oaknet_reset_8390
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|base
op_assign
id|OAKNET_BASE
suffix:semicolon
r_int
r_int
id|start
op_assign
id|jiffies
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|base
op_plus
id|OAKNET_RESET
)paren
comma
id|base
op_plus
id|OAKNET_RESET
)paren
suffix:semicolon
id|ei_status.txing
op_assign
l_int|0
suffix:semicolon
id|ei_status.dmaing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This check shouldn&squot;t be necessary eventually */
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_ISR
)paren
op_amp
id|ENISR_RESET
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jiffies
op_minus
id|start
OG
id|OAKNET_WAIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset didn&squot;t complete&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|outb_p
c_func
(paren
id|ENISR_RESET
comma
id|base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* ACK reset interrupt */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX - Document me.&n; */
r_static
r_void
DECL|function|oaknet_get_8390_hdr
id|oaknet_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
r_int
id|base
op_assign
id|OAKNET_BASE
suffix:semicolon
multiline_comment|/*&n;&t; * This should NOT happen. If it does, it is the LAST thing you&squot;ll&n;&t; * see.&n;&t; */
r_if
c_cond
(paren
id|ei_status.dmaing
)paren
(brace
id|oaknet_dma_error
c_func
(paren
id|dev
comma
l_string|&quot;oaknet_get_8390_hdr&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ei_status.dmaing
op_or_assign
l_int|0x01
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
id|outb_p
c_func
(paren
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
comma
id|base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|base
op_plus
id|EN0_RSARLO
)paren
suffix:semicolon
multiline_comment|/* On page boundary */
id|outb_p
c_func
(paren
id|ring_page
comma
id|base
op_plus
id|EN0_RSARHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_RREAD
op_plus
id|E8390_START
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|insw
c_func
(paren
id|base
op_plus
id|OAKNET_DATA
comma
id|hdr
comma
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_else
id|insb
c_func
(paren
id|base
op_plus
id|OAKNET_DATA
comma
id|hdr
comma
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_RDC
comma
id|base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* ACK Remote DMA interrupt */
id|ei_status.dmaing
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX - Document me.&n; */
r_static
r_void
DECL|function|oaknet_block_input
id|oaknet_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
r_int
id|base
op_assign
id|OAKNET_BASE
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * This should NOT happen. If it does, it is the LAST thing you&squot;ll&n;&t; * see.&n;&t; */
r_if
c_cond
(paren
id|ei_status.dmaing
)paren
(brace
id|oaknet_dma_error
c_func
(paren
id|dev
comma
l_string|&quot;oaknet_block_input&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ei_status.dmaing
op_or_assign
l_int|0x01
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|count
op_amp
l_int|0xff
comma
id|base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|count
op_rshift
l_int|8
comma
id|base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ring_offset
op_amp
l_int|0xff
comma
id|base
op_plus
id|EN0_RSARLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ring_offset
op_rshift
l_int|8
comma
id|base
op_plus
id|EN0_RSARHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_RREAD
op_plus
id|E8390_START
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_status.word16
)paren
(brace
id|insw
c_func
(paren
id|base
op_plus
id|OAKNET_DATA
comma
id|buf
comma
id|count
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_amp
l_int|0x01
)paren
(brace
id|buf
(braket
id|count
op_minus
l_int|1
)braket
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|OAKNET_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|insb
c_func
(paren
id|base
op_plus
id|OAKNET_DATA
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|ENISR_RDC
comma
id|base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* ACK Remote DMA interrupt */
id|ei_status.dmaing
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX - Document me.&n; */
r_static
r_void
DECL|function|oaknet_block_output
id|oaknet_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
id|base
op_assign
id|OAKNET_BASE
suffix:semicolon
r_int
id|bug
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_int
r_char
id|lobyte
suffix:semicolon
multiline_comment|/* Round the count up for word writes. */
r_if
c_cond
(paren
id|ei_status.word16
op_logical_and
(paren
id|count
op_amp
l_int|0x1
)paren
)paren
id|count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * This should NOT happen. If it does, it is the LAST thing you&squot;ll&n;&t; * see.&n;&t; */
r_if
c_cond
(paren
id|ei_status.dmaing
)paren
(brace
id|oaknet_dma_error
c_func
(paren
id|dev
comma
l_string|&quot;oaknet_block_output&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ei_status.dmaing
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* Make sure we are in page 0. */
id|outb_p
c_func
(paren
id|E8390_PAGE0
op_plus
id|E8390_START
op_plus
id|E8390_NODMA
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The 83902 documentation states that the processor needs to&n;&t; * do a &quot;dummy read&quot; before doing the remote write to work&n;&t; * around a chip bug they don&squot;t feel like fixing.&n;&t; */
id|bug
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_int
id|rdhi
suffix:semicolon
r_int
r_int
id|rdlo
suffix:semicolon
multiline_comment|/* Now the normal output. */
id|outb_p
c_func
(paren
id|ENISR_RDC
comma
id|base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|count
op_amp
l_int|0xff
comma
id|base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|count
op_rshift
l_int|8
comma
id|base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|base
op_plus
id|EN0_RSARLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|start_page
comma
id|base
op_plus
id|EN0_RSARHI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bug
op_increment
)paren
r_break
suffix:semicolon
multiline_comment|/* Perform the dummy read */
id|rdhi
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_CRDAHI
)paren
suffix:semicolon
id|rdlo
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_CRDALO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_RREAD
op_plus
id|E8390_START
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_int
id|nrdhi
suffix:semicolon
r_int
r_int
id|nrdlo
suffix:semicolon
id|nrdhi
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_CRDAHI
)paren
suffix:semicolon
id|nrdlo
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_CRDALO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rdhi
op_ne
id|nrdhi
)paren
op_logical_or
(paren
id|rdlo
op_ne
id|nrdlo
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
id|outb_p
c_func
(paren
id|E8390_RWRITE
op_plus
id|E8390_START
comma
id|base
op_plus
id|OAKNET_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_status.word16
)paren
(brace
id|outsw
c_func
(paren
id|OAKNET_BASE
op_plus
id|OAKNET_DATA
comma
id|buf
comma
id|count
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outsb
c_func
(paren
id|OAKNET_BASE
op_plus
id|OAKNET_DATA
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
id|start
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|lobyte
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_ISR
)paren
)paren
op_amp
id|ENISR_RDC
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jiffies
op_minus
id|start
OG
id|OAKNET_WAIT
)paren
(brace
r_int
r_char
id|hicnt
comma
id|locnt
suffix:semicolon
id|hicnt
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_CRDAHI
)paren
suffix:semicolon
id|locnt
op_assign
id|inb_p
c_func
(paren
id|base
op_plus
id|EN0_CRDALO
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: timeout waiting for Tx RDC, stat = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lobyte
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tstart address 0x%x, current address 0x%x, count %d&bslash;n&quot;
comma
(paren
id|start_page
op_lshift
l_int|8
)paren
comma
(paren
id|hicnt
op_lshift
l_int|8
)paren
op_or
id|locnt
comma
id|count
)paren
suffix:semicolon
id|oaknet_reset_8390
c_func
(paren
id|dev
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|outb_p
c_func
(paren
id|ENISR_RDC
comma
id|base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
id|ei_status.dmaing
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|oaknet_dma_error
id|oaknet_dma_error
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: DMAing conflict in %s.&quot;
l_string|&quot;[DMAstat:%d][irqlock:%d][intr:%ld]&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|ei_status.dmaing
comma
id|ei_status.irqlock
comma
id|dev-&gt;interrupt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if defined(MODULE)
multiline_comment|/*&n; * Oak Ethernet module load interface.&n; */
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|oaknet_devs
op_ne
l_int|NULL
)paren
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
id|status
op_assign
id|oaknet_init
c_func
(paren
)paren
id|lock_8390_module
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Oak Ethernet module unload interface.&n; */
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|oaknet_devs
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|oaknet_devs-&gt;priv
op_ne
l_int|NULL
)paren
(brace
r_int
id|ioaddr
op_assign
id|oaknet_devs-&gt;base_addr
suffix:semicolon
r_void
op_star
id|priv
op_assign
id|oaknet_devs-&gt;priv
suffix:semicolon
id|free_irq
c_func
(paren
id|oaknet_devs-&gt;irq
comma
id|oaknet_devs
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|ioaddr
comma
id|OAKNET_IO_SIZE
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|oaknet_dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
id|oaknet_devs
op_assign
l_int|NULL
suffix:semicolon
id|unlock_8390_module
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
