multiline_comment|/* &n;net-3-driver for the SKNET MCA-based cards&n;&n;This is an extension to the Linux operating system, and is covered by the&n;same Gnu Public License that covers that work.&n;&n;Copyright 1999 by Alfred Arnold (alfred@ccac.rwth-aachen.de, aarnold@elsa.de)&n;&n;This driver is based both on the 3C523 driver and the SK_G16 driver.&n;&n;paper sources:&n;  &squot;PC Hardware: Aufbau, Funktionsweise, Programmierung&squot; by &n;  Hans-Peter Messmer for the basic Microchannel stuff&n;  &n;  &squot;Linux Geraetetreiber&squot; by Allesandro Rubini, Kalle Dalheimer&n;  for help on Ethernet driver programming&n;&n;  &squot;Ethernet/IEEE 802.3 Family 1992 World Network Data Book/Handbook&squot; by AMD&n;  for documentation on the AM7990 LANCE&n;&n;  &squot;SKNET Personal Technisches Manual&squot;, Version 1.2 by Schneider&amp;Koch&n;  for documentation on the Junior board&n;&n;  &squot;SK-NET MC2+ Technical Manual&quot;, Version 1.1 by Schneider&amp;Koch for&n;  documentation on the MC2 bord&n;  &n;  A big thank you to the S&amp;K support for providing me so quickly with&n;  documentation!&n;&n;  Also see http://www.syskonnect.com/&n;&n;  Missing things:&n;&n;  -&gt; set debug level via ioctl instead of compile-time switches&n;  -&gt; I didn&squot;t follow the development of the 2.1.x kernels, so my&n;     assumptions about which things changed with which kernel version &n;     are probably nonsense&n;&n;History:&n;  May 16th, 1999&n;  &t;startup&n;  May 22st, 1999&n;&t;added private structure, methods&n;        begun building data structures in RAM&n;  May 23nd, 1999&n;&t;can receive frames, send frames&n;  May 24th, 1999&n;        modularized intialization of LANCE&n;        loadable as module&n;&t;still Tx problem :-(&n;  May 26th, 1999&n;  &t;MC2 works&n;  &t;support for multiple devices&n;  &t;display media type for MC2+&n;  May 28th, 1999&n;&t;fixed problem in GetLANCE leaving interrupts turned off&n;        increase TX queue to 4 packets to improve send performance&n;  May 29th, 1999&n;&t;a few corrections in statistics, caught rcvr overruns &n;        reinitialization of LANCE/board in critical situations&n;        MCA info implemented&n;&t;implemented LANCE multicast filter&n;  Jun 6th, 1999&n;&t;additions for Linux 2.2&n;  Dec 25th, 1999&n;  &t;unfortunately there seem to be newer MC2+ boards that react&n;  &t;on IRQ 3/5/9/10 instead of 3/5/10/11, so we have to autoprobe&n;  &t;in questionable cases...&n;  Dec 28th, 1999&n;&t;integrated patches from David Weinehall &amp; Bill Wendling for 2.3&n;&t;kernels (isa_...functions).  Things are defined in a way that&n;        it still works with 2.0.x 8-)&n;  Dec 30th, 1999&n;&t;added handling of the remaining interrupt conditions.  That&n;        should cure the spurious hangs.&n;  Jan 30th, 2000&n;&t;newer kernels automatically probe more than one board, so the&n;&t;&squot;startslot&squot; as a variable is also needed here&n;  June 1st, 2000&n;&t;added changes for recent 2.3 kernels&n;&n; *************************************************************************/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
DECL|macro|_SK_MCA_DRIVER_
mdefine_line|#define _SK_MCA_DRIVER_
macro_line|#include &quot;sk_mca.h&quot;
multiline_comment|/* ------------------------------------------------------------------------&n; * global static data - not more since we can handle multiple boards and&n; * have to pack all state info into the device struct!&n; * ------------------------------------------------------------------------ */
DECL|variable|MediaNames
r_static
r_char
op_star
id|MediaNames
(braket
id|Media_Count
)braket
op_assign
(brace
l_string|&quot;10Base2&quot;
comma
l_string|&quot;10BaseT&quot;
comma
l_string|&quot;10Base5&quot;
comma
l_string|&quot;Unknown&quot;
)brace
suffix:semicolon
DECL|variable|poly
r_static
r_int
r_char
id|poly
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------&n; * private subfunctions&n; * ------------------------------------------------------------------------ */
multiline_comment|/* dump parts of shared memory - only needed during debugging */
macro_line|#ifdef DEBUG
DECL|function|dumpmem
r_static
r_void
id|dumpmem
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u32
id|start
comma
id|u32
id|len
)paren
(brace
r_int
id|z
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|len
suffix:semicolon
id|z
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|z
op_amp
l_int|15
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%04x:&quot;
comma
id|z
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|SKMCA_READB
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|start
op_plus
id|z
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
op_amp
l_int|15
)paren
op_eq
l_int|15
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* print exact time - ditto */
DECL|function|PrTime
r_static
r_void
id|PrTime
c_func
(paren
r_void
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%9d:%06d: &quot;
comma
id|tv.tv_sec
comma
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* deduce resources out of POS registers */
DECL|function|getaddrs
r_static
r_void
id|getaddrs
c_func
(paren
r_int
id|slot
comma
r_int
id|junior
comma
r_int
op_star
id|base
comma
r_int
op_star
id|irq
comma
id|skmca_medium
op_star
id|medium
)paren
(brace
id|u_char
id|pos0
comma
id|pos1
comma
id|pos2
suffix:semicolon
r_if
c_cond
(paren
id|junior
)paren
(brace
id|pos0
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
op_star
id|base
op_assign
(paren
(paren
id|pos0
op_amp
l_int|0x0e
)paren
op_lshift
l_int|13
)paren
op_plus
l_int|0xc0000
suffix:semicolon
op_star
id|irq
op_assign
(paren
(paren
id|pos0
op_amp
l_int|0x10
)paren
op_rshift
l_int|4
)paren
op_plus
l_int|10
suffix:semicolon
op_star
id|medium
op_assign
id|Media_Unknown
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* reset POS 104 Bits 0+1 so the shared memory region goes to the&n;&t;&t;   configured area between 640K and 1M.  Afterwards, enable the MC2.&n;&t;&t;   I really don&squot;t know what rode SK to do this... */
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|4
comma
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
op_amp
l_int|0xfc
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|2
comma
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
id|pos1
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
suffix:semicolon
id|pos2
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
op_star
id|base
op_assign
(paren
(paren
id|pos1
op_amp
l_int|0x07
)paren
op_lshift
l_int|14
)paren
op_plus
l_int|0xc0000
suffix:semicolon
r_switch
c_cond
(paren
id|pos2
op_amp
l_int|0x0c
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|irq
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|irq
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
id|irq
op_assign
op_minus
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
op_star
id|irq
op_assign
op_minus
l_int|11
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|medium
op_assign
(paren
id|pos2
op_rshift
l_int|6
)paren
op_amp
l_int|3
suffix:semicolon
)brace
)brace
multiline_comment|/* check for both cards:&n;   When the MC2 is turned off, it was configured for more than 15MB RAM,&n;   is disabled and won&squot;t get detected using the standard probe.  We&n;   therefore have to scan the slots manually :-( */
DECL|function|dofind
r_static
r_int
id|dofind
c_func
(paren
r_int
op_star
id|junior
comma
r_int
id|firstslot
)paren
(brace
r_int
id|slot
suffix:semicolon
r_int
r_int
id|id
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
id|firstslot
suffix:semicolon
id|slot
OL
id|MCA_MAX_SLOT_NR
suffix:semicolon
id|slot
op_increment
)paren
(brace
id|id
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|0
)paren
op_plus
(paren
(paren
(paren
r_int
r_int
)paren
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|1
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
op_star
id|junior
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|SKNET_MCA_ID
)paren
r_return
id|slot
suffix:semicolon
op_star
id|junior
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|SKNET_JUNIOR_MCA_ID
)paren
r_return
id|slot
suffix:semicolon
)brace
r_return
id|MCA_NOTFOUND
suffix:semicolon
)brace
multiline_comment|/* reset the whole board */
DECL|function|ResetBoard
r_static
r_void
id|ResetBoard
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|SKMCA_WRITEB
c_func
(paren
id|CTRL_RESET_ON
comma
id|priv-&gt;ctrladdr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|SKMCA_WRITEB
c_func
(paren
id|CTRL_RESET_OFF
comma
id|priv-&gt;ctrladdr
)paren
suffix:semicolon
)brace
multiline_comment|/* wait for LANCE interface to become not busy */
DECL|function|WaitLANCE
r_static
r_int
id|WaitLANCE
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|t
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|SKMCA_READB
c_func
(paren
id|priv-&gt;ctrladdr
)paren
op_amp
id|STAT_IO_BUSY
)paren
op_eq
id|STAT_IO_BUSY
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|t
OG
l_int|1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: LANCE access timeout&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set LANCE register - must be atomic */
DECL|function|SetLANCE
r_static
r_void
id|SetLANCE
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u16
id|addr
comma
id|u16
id|value
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* disable interrupts */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait until no transfer is pending */
id|WaitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* transfer register address to RAP */
id|SKMCA_WRITEB
c_func
(paren
id|CTRL_RESET_OFF
op_or
id|CTRL_RW_WRITE
op_or
id|CTRL_ADR_RAP
comma
id|priv-&gt;ctrladdr
)paren
suffix:semicolon
id|SKMCA_WRITEW
c_func
(paren
id|addr
comma
id|priv-&gt;ioregaddr
)paren
suffix:semicolon
id|SKMCA_WRITEB
c_func
(paren
id|IOCMD_GO
comma
id|priv-&gt;cmdaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WaitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* transfer data to register */
id|SKMCA_WRITEB
c_func
(paren
id|CTRL_RESET_OFF
op_or
id|CTRL_RW_WRITE
op_or
id|CTRL_ADR_DATA
comma
id|priv-&gt;ctrladdr
)paren
suffix:semicolon
id|SKMCA_WRITEW
c_func
(paren
id|value
comma
id|priv-&gt;ioregaddr
)paren
suffix:semicolon
id|SKMCA_WRITEB
c_func
(paren
id|IOCMD_GO
comma
id|priv-&gt;cmdaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WaitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* reenable interrupts */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* get LANCE register */
DECL|function|GetLANCE
r_static
id|u16
id|GetLANCE
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u16
id|addr
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|res
suffix:semicolon
multiline_comment|/* disable interrupts */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait until no transfer is pending */
id|WaitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* transfer register address to RAP */
id|SKMCA_WRITEB
c_func
(paren
id|CTRL_RESET_OFF
op_or
id|CTRL_RW_WRITE
op_or
id|CTRL_ADR_RAP
comma
id|priv-&gt;ctrladdr
)paren
suffix:semicolon
id|SKMCA_WRITEW
c_func
(paren
id|addr
comma
id|priv-&gt;ioregaddr
)paren
suffix:semicolon
id|SKMCA_WRITEB
c_func
(paren
id|IOCMD_GO
comma
id|priv-&gt;cmdaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WaitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* transfer data from register */
id|SKMCA_WRITEB
c_func
(paren
id|CTRL_RESET_OFF
op_or
id|CTRL_RW_READ
op_or
id|CTRL_ADR_DATA
comma
id|priv-&gt;ctrladdr
)paren
suffix:semicolon
id|SKMCA_WRITEB
c_func
(paren
id|IOCMD_GO
comma
id|priv-&gt;cmdaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WaitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
id|res
op_assign
id|SKMCA_READW
c_func
(paren
id|priv-&gt;ioregaddr
)paren
suffix:semicolon
multiline_comment|/* reenable interrupts */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* build up descriptors in shared RAM */
DECL|function|InitDscrs
r_static
r_void
id|InitDscrs
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|u32
id|bufaddr
suffix:semicolon
multiline_comment|/* Set up Tx descriptors. The board has only 16K RAM so bits 16..23&n;&t;   are always 0. */
id|bufaddr
op_assign
id|RAM_DATABASE
suffix:semicolon
(brace
id|LANCE_TxDescr
id|descr
suffix:semicolon
r_int
id|z
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|TXCOUNT
suffix:semicolon
id|z
op_increment
)paren
(brace
id|descr.LowAddr
op_assign
id|bufaddr
suffix:semicolon
id|descr.Flags
op_assign
l_int|0
suffix:semicolon
id|descr.Len
op_assign
l_int|0xf000
suffix:semicolon
id|descr.Status
op_assign
l_int|0
suffix:semicolon
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|RAM_TXBASE
op_plus
(paren
id|z
op_star
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
comma
op_amp
id|descr
comma
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
suffix:semicolon
id|SKMCA_SETIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|bufaddr
comma
l_int|0
comma
id|RAM_BUFSIZE
)paren
suffix:semicolon
id|bufaddr
op_add_assign
id|RAM_BUFSIZE
suffix:semicolon
)brace
)brace
multiline_comment|/* do the same for the Rx descriptors */
(brace
id|LANCE_RxDescr
id|descr
suffix:semicolon
r_int
id|z
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|RXCOUNT
suffix:semicolon
id|z
op_increment
)paren
(brace
id|descr.LowAddr
op_assign
id|bufaddr
suffix:semicolon
id|descr.Flags
op_assign
id|RXDSCR_FLAGS_OWN
suffix:semicolon
id|descr.MaxLen
op_assign
op_minus
id|RAM_BUFSIZE
suffix:semicolon
id|descr.Len
op_assign
l_int|0
suffix:semicolon
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|RAM_RXBASE
op_plus
(paren
id|z
op_star
r_sizeof
(paren
id|LANCE_RxDescr
)paren
)paren
comma
op_amp
id|descr
comma
r_sizeof
(paren
id|LANCE_RxDescr
)paren
)paren
suffix:semicolon
id|SKMCA_SETIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|bufaddr
comma
l_int|0
comma
id|RAM_BUFSIZE
)paren
suffix:semicolon
id|bufaddr
op_add_assign
id|RAM_BUFSIZE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* calculate the hash bit position for a given multicast address&n;   taken more or less directly from the AMD datasheet... */
DECL|function|UpdateCRC
r_static
r_void
id|UpdateCRC
c_func
(paren
r_int
r_char
op_star
id|CRC
comma
r_int
id|bit
)paren
(brace
r_int
id|j
suffix:semicolon
multiline_comment|/* shift CRC one bit */
id|memmove
c_func
(paren
id|CRC
op_plus
l_int|1
comma
id|CRC
comma
l_int|32
op_star
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
id|CRC
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if bit XOR controlbit = 1, set CRC = CRC XOR polynomial */
r_if
c_cond
(paren
id|bit
op_xor
id|CRC
(braket
l_int|32
)braket
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_increment
)paren
id|CRC
(braket
id|j
)braket
op_xor_assign
id|poly
(braket
id|j
)braket
suffix:semicolon
)brace
DECL|function|GetHash
r_static
r_int
r_int
id|GetHash
c_func
(paren
r_char
op_star
id|address
)paren
(brace
r_int
r_char
id|CRC
(braket
l_int|33
)braket
suffix:semicolon
r_int
id|i
comma
id|byte
comma
id|hashcode
suffix:semicolon
multiline_comment|/* a multicast address has bit 0 in the first byte set */
r_if
c_cond
(paren
(paren
id|address
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* initialize CRC */
id|memset
c_func
(paren
id|CRC
comma
l_int|1
comma
r_sizeof
(paren
id|CRC
)paren
)paren
suffix:semicolon
multiline_comment|/* loop through address bits */
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
id|byte
OL
l_int|6
suffix:semicolon
id|byte
op_increment
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|UpdateCRC
c_func
(paren
id|CRC
comma
(paren
id|address
(braket
id|byte
)braket
op_rshift
id|i
)paren
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hashcode is the 6 least significant bits of the CRC */
id|hashcode
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|hashcode
op_assign
(paren
id|hashcode
op_lshift
l_int|1
)paren
op_plus
id|CRC
(braket
id|i
)braket
suffix:semicolon
r_return
id|hashcode
suffix:semicolon
)brace
multiline_comment|/* feed ready-built initialization block into LANCE */
DECL|function|InitLANCE
r_static
r_void
id|InitLANCE
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* build up descriptors. */
id|InitDscrs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* next RX descriptor to be read is the first one.  Since the LANCE&n;&t;   will start from the beginning after initialization, we have to &n;&t;   reset out pointers too. */
id|priv-&gt;nextrx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no TX descriptors active */
id|priv-&gt;nexttxput
op_assign
id|priv-&gt;nexttxdone
op_assign
id|priv-&gt;txbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set up the LANCE bus control register - constant for SKnet boards */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR3
comma
id|CSR3_BSWAP_OFF
op_or
id|CSR3_ALE_LOW
op_or
id|CSR3_BCON_HOLD
)paren
suffix:semicolon
multiline_comment|/* write address of initialization block into LANCE */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR1
comma
id|RAM_INITBASE
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR2
comma
(paren
id|RAM_INITBASE
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t get ready until the LANCE has read the init block */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* let LANCE read the initialization block.  LANCE is ready&n;&t;   when we receive the corresponding interrupt. */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|CSR0_INEA
op_or
id|CSR0_INIT
)paren
suffix:semicolon
)brace
multiline_comment|/* stop the LANCE so we can reinitialize it */
DECL|function|StopLANCE
r_static
r_void
id|StopLANCE
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
multiline_comment|/* can&squot;t take frames any more */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* disable interrupts, stop it */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|CSR0_STOP
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize card and LANCE for proper operation */
DECL|function|InitBoard
r_static
r_void
id|InitBoard
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|LANCE_InitBlock
id|block
suffix:semicolon
multiline_comment|/* Lay out the shared RAM - first we create the init block for the LANCE.&n;&t;   We do not overwrite it later because we need it again when we switch&n;&t;   promiscous mode on/off. */
id|block.Mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|block.Mode
op_or_assign
id|LANCE_INIT_PROM
suffix:semicolon
id|memcpy
c_func
(paren
id|block.PAdr
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
id|memset
c_func
(paren
id|block.LAdrF
comma
l_int|0
comma
r_sizeof
(paren
id|block.LAdrF
)paren
)paren
suffix:semicolon
id|block.RdrP
op_assign
(paren
id|RAM_RXBASE
op_amp
l_int|0xffffff
)paren
op_or
(paren
id|LRXCOUNT
op_lshift
l_int|29
)paren
suffix:semicolon
id|block.TdrP
op_assign
(paren
id|RAM_TXBASE
op_amp
l_int|0xffffff
)paren
op_or
(paren
id|LTXCOUNT
op_lshift
l_int|29
)paren
suffix:semicolon
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|RAM_INITBASE
comma
op_amp
id|block
comma
r_sizeof
(paren
id|block
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize LANCE. Implicitly sets up other structures in RAM. */
id|InitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* deinitialize card and LANCE */
DECL|function|DeinitBoard
r_static
r_void
id|DeinitBoard
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
multiline_comment|/* stop LANCE */
id|StopLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* reset board */
id|ResetBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* probe for device&squot;s irq */
DECL|function|ProbeIRQ
r_static
r_int
id|ProbeIRQ
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
r_int
r_int
id|imaskval
comma
id|njiffies
comma
id|irq
suffix:semicolon
id|u16
id|csr0val
suffix:semicolon
multiline_comment|/* enable all interrupts */
id|imaskval
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize the board. Wait for interrupt &squot;Initialization done&squot;. */
id|ResetBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
id|InitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
id|njiffies
op_assign
id|jiffies
op_plus
l_int|100
suffix:semicolon
r_do
(brace
id|csr0val
op_assign
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
id|csr0val
op_amp
id|CSR0_IDON
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|jiffies
op_ne
id|njiffies
)paren
)paren
suffix:semicolon
multiline_comment|/* turn of interrupts again */
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|imaskval
)paren
suffix:semicolon
multiline_comment|/* if we found something, ack the interrupt */
r_if
c_cond
(paren
id|irq
)paren
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|csr0val
op_or
id|CSR0_IDON
)paren
suffix:semicolon
multiline_comment|/* back to idle state */
id|DeinitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * interrupt handler(s)&n; * ------------------------------------------------------------------------ */
multiline_comment|/* LANCE has read initialization block -&gt; start it */
DECL|function|irqstart_handler
r_static
id|u16
id|irqstart_handler
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u16
id|oldcsr0
)paren
(brace
multiline_comment|/* now we&squot;re ready to transmit */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* reset IDON bit, start LANCE */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|oldcsr0
op_or
id|CSR0_IDON
op_or
id|CSR0_STRT
)paren
suffix:semicolon
r_return
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
)brace
multiline_comment|/* did we loose blocks due to a FIFO overrun ? */
DECL|function|irqmiss_handler
r_static
id|u16
id|irqmiss_handler
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u16
id|oldcsr0
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* update statistics */
id|priv-&gt;stat.rx_fifo_errors
op_increment
suffix:semicolon
multiline_comment|/* reset MISS bit */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|oldcsr0
op_or
id|CSR0_MISS
)paren
suffix:semicolon
r_return
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
)brace
multiline_comment|/* receive interrupt */
DECL|function|irqrx_handler
r_static
id|u16
id|irqrx_handler
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u16
id|oldcsr0
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|LANCE_RxDescr
id|descr
suffix:semicolon
r_int
r_int
id|descraddr
suffix:semicolon
multiline_comment|/* run through queue until we reach a descriptor we do not own */
id|descraddr
op_assign
id|RAM_RXBASE
op_plus
(paren
id|priv-&gt;nextrx
op_star
r_sizeof
(paren
id|LANCE_RxDescr
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* read descriptor */
id|SKMCA_FROMIO
c_func
(paren
op_amp
id|descr
comma
id|dev-&gt;mem_start
op_plus
id|descraddr
comma
r_sizeof
(paren
id|LANCE_RxDescr
)paren
)paren
suffix:semicolon
multiline_comment|/* if we reach a descriptor we do not own, we&squot;re done */
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|RXDSCR_FLAGS_OWN
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#ifdef DEBUG
id|PrTime
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Receive packet on descr %d len %d&bslash;n&quot;
comma
id|priv-&gt;nextrx
comma
id|descr.Len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* erroneous packet ? */
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|RXDSCR_FLAGS_ERR
)paren
op_ne
l_int|0
)paren
(brace
id|priv-&gt;stat.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|RXDSCR_FLAGS_CRC
)paren
op_ne
l_int|0
)paren
id|priv-&gt;stat.rx_crc_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|RXDSCR_FLAGS_CRC
)paren
op_ne
l_int|0
)paren
id|priv-&gt;stat.rx_frame_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|RXDSCR_FLAGS_OFLO
)paren
op_ne
l_int|0
)paren
id|priv-&gt;stat.rx_fifo_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* good packet ? */
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|descr.Len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
id|priv-&gt;stat.rx_dropped
op_increment
suffix:semicolon
r_else
(brace
id|SKMCA_FROMIO
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|descr.Len
)paren
comma
id|dev-&gt;mem_start
op_plus
id|descr.LowAddr
comma
id|descr.Len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
id|priv-&gt;stat.rx_packets
op_increment
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020119&t;/* byte counters for &gt;= 2.1.25 */
id|priv-&gt;stat.rx_bytes
op_add_assign
id|descr.Len
suffix:semicolon
macro_line|#endif
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* give descriptor back to LANCE */
id|descr.Len
op_assign
l_int|0
suffix:semicolon
id|descr.Flags
op_or_assign
id|RXDSCR_FLAGS_OWN
suffix:semicolon
multiline_comment|/* update descriptor in shared RAM */
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|descraddr
comma
op_amp
id|descr
comma
r_sizeof
(paren
id|LANCE_RxDescr
)paren
)paren
suffix:semicolon
multiline_comment|/* go to next descriptor */
id|priv-&gt;nextrx
op_increment
suffix:semicolon
id|descraddr
op_add_assign
r_sizeof
(paren
id|LANCE_RxDescr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;nextrx
op_ge
id|RXCOUNT
)paren
(brace
id|priv-&gt;nextrx
op_assign
l_int|0
suffix:semicolon
id|descraddr
op_assign
id|RAM_RXBASE
suffix:semicolon
)brace
)brace
multiline_comment|/* reset RINT bit */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|oldcsr0
op_or
id|CSR0_RINT
)paren
suffix:semicolon
r_return
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
)brace
multiline_comment|/* transmit interrupt */
DECL|function|irqtx_handler
r_static
id|u16
id|irqtx_handler
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
id|u16
id|oldcsr0
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|LANCE_TxDescr
id|descr
suffix:semicolon
r_int
r_int
id|descraddr
suffix:semicolon
multiline_comment|/* check descriptors at most until no busy one is left */
id|descraddr
op_assign
id|RAM_TXBASE
op_plus
(paren
id|priv-&gt;nexttxdone
op_star
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|priv-&gt;txbusy
OG
l_int|0
)paren
(brace
multiline_comment|/* read descriptor */
id|SKMCA_FROMIO
c_func
(paren
op_amp
id|descr
comma
id|dev-&gt;mem_start
op_plus
id|descraddr
comma
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
suffix:semicolon
multiline_comment|/* if the LANCE still owns this one, we&squot;ve worked out all sent packets */
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|TXDSCR_FLAGS_OWN
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#ifdef DEBUG
id|PrTime
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Send packet done on descr %d&bslash;n&quot;
comma
id|priv-&gt;nexttxdone
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* update statistics */
r_if
c_cond
(paren
(paren
id|descr.Flags
op_amp
id|TXDSCR_FLAGS_ERR
)paren
op_eq
l_int|0
)paren
(brace
id|priv-&gt;stat.tx_packets
op_increment
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020119&t;/* byte counters for &gt;= 2.1.25 */
id|priv-&gt;stat.tx_bytes
op_increment
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|priv-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|descr.Status
op_amp
id|TXDSCR_STATUS_UFLO
)paren
op_ne
l_int|0
)paren
(brace
id|priv-&gt;stat.tx_fifo_errors
op_increment
suffix:semicolon
id|InitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|descr.Status
op_amp
id|TXDSCR_STATUS_LCOL
)paren
op_ne
l_int|0
)paren
id|priv-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|descr.Status
op_amp
id|TXDSCR_STATUS_LCAR
)paren
op_ne
l_int|0
)paren
id|priv-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|descr.Status
op_amp
id|TXDSCR_STATUS_RTRY
)paren
op_ne
l_int|0
)paren
id|priv-&gt;stat.tx_aborted_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* go to next descriptor */
id|priv-&gt;nexttxdone
op_increment
suffix:semicolon
id|descraddr
op_add_assign
r_sizeof
(paren
id|LANCE_TxDescr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;nexttxdone
op_ge
id|TXCOUNT
)paren
(brace
id|priv-&gt;nexttxdone
op_assign
l_int|0
suffix:semicolon
id|descraddr
op_assign
id|RAM_TXBASE
suffix:semicolon
)brace
id|priv-&gt;txbusy
op_decrement
suffix:semicolon
)brace
multiline_comment|/* reset TX interrupt bit */
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|oldcsr0
op_or
id|CSR0_TINT
)paren
suffix:semicolon
id|oldcsr0
op_assign
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
multiline_comment|/* at least one descriptor is freed.  Therefore we can accept&n;&t;   a new one */
multiline_comment|/* inform upper layers we&squot;re in business again */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
macro_line|#endif
r_return
id|oldcsr0
suffix:semicolon
)brace
multiline_comment|/* general interrupt entry */
DECL|function|irq_handler
r_static
r_void
id|irq_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|device
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|SKMCA_NETDEV
op_star
id|dev
op_assign
(paren
r_struct
id|SKMCA_NETDEV
op_star
)paren
id|device
suffix:semicolon
id|u16
id|csr0val
suffix:semicolon
multiline_comment|/* read CSR0 to get interrupt cause */
id|csr0val
op_assign
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
multiline_comment|/* in case we&squot;re not meant... */
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_INTR
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
macro_line|#if 0
id|set_bit
c_func
(paren
id|LINK_STATE_RXSEM
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* loop through the interrupt bits until everything is clear */
r_do
(brace
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_IDON
)paren
op_ne
l_int|0
)paren
id|csr0val
op_assign
id|irqstart_handler
c_func
(paren
id|dev
comma
id|csr0val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_RINT
)paren
op_ne
l_int|0
)paren
id|csr0val
op_assign
id|irqrx_handler
c_func
(paren
id|dev
comma
id|csr0val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_MISS
)paren
op_ne
l_int|0
)paren
id|csr0val
op_assign
id|irqmiss_handler
c_func
(paren
id|dev
comma
id|csr0val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_TINT
)paren
op_ne
l_int|0
)paren
id|csr0val
op_assign
id|irqtx_handler
c_func
(paren
id|dev
comma
id|csr0val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_MERR
)paren
op_ne
l_int|0
)paren
(brace
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|csr0val
op_or
id|CSR0_MERR
)paren
suffix:semicolon
id|csr0val
op_assign
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|csr0val
op_amp
id|CSR0_BABL
)paren
op_ne
l_int|0
)paren
(brace
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|csr0val
op_or
id|CSR0_BABL
)paren
suffix:semicolon
id|csr0val
op_assign
id|GetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|csr0val
op_amp
id|CSR0_INTR
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
macro_line|#if 0
id|clear_bit
c_func
(paren
id|LINK_STATE_RXSEM
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * driver methods&n; * ------------------------------------------------------------------------ */
multiline_comment|/* MCA info */
DECL|function|skmca_getinfo
r_static
r_int
id|skmca_getinfo
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|slot
comma
r_void
op_star
id|d
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_struct
id|SKMCA_NETDEV
op_star
id|dev
op_assign
(paren
r_struct
id|SKMCA_NETDEV
op_star
)paren
id|d
suffix:semicolon
id|skmca_priv
op_star
id|priv
suffix:semicolon
multiline_comment|/* can&squot;t say anything about an uninitialized device... */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
id|len
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
id|len
suffix:semicolon
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* print info */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IRQ: %d&bslash;n&quot;
comma
id|priv-&gt;realirq
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Memory: %#lx-%#lx&bslash;n&quot;
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Transceiver: %s&bslash;n&quot;
comma
id|MediaNames
(braket
id|priv-&gt;medium
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Device: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MAC address:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot; %02x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|buf
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* open driver.  Means also initialization and start of LANCE */
DECL|function|skmca_open
r_static
r_int
id|skmca_open
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
r_int
id|result
suffix:semicolon
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* register resources - only necessary for IRQ */
id|result
op_assign
id|request_irq
c_func
(paren
id|priv-&gt;realirq
comma
id|irq_handler
comma
id|SA_SHIRQ
op_or
id|SA_SAMPLE_RANDOM
comma
l_string|&quot;sk_mca&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: failed to register irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
id|priv-&gt;realirq
suffix:semicolon
multiline_comment|/* set up the card and LANCE */
id|InitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* set up flags */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* close driver.  Shut down board and free allocated resources */
DECL|function|skmca_close
r_static
r_int
id|skmca_close
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
multiline_comment|/* turn off board */
id|DeinitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* release resources */
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02032a)
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* transmit a block. */
DECL|function|skmca_tx
r_static
r_int
id|skmca_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|LANCE_TxDescr
id|descr
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
id|tmplen
comma
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* if we get called with a NULL descriptor, the Ethernet layer thinks &n;&t;   our card is stuck an we should reset it.  We&squot;ll do this completely: */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|DeinitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
id|InitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t try to free the block here ;-) */
)brace
multiline_comment|/* is there space in the Tx queue ? If no, the upper layer gave us a&n;&t;   packet in spite of us not being ready and is really in trouble.&n;&t;   We&squot;ll do the dropping for him: */
r_if
c_cond
(paren
id|priv-&gt;txbusy
op_ge
id|TXCOUNT
)paren
(brace
id|priv-&gt;stat.tx_dropped
op_increment
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|tx_done
suffix:semicolon
)brace
multiline_comment|/* get TX descriptor */
id|address
op_assign
id|RAM_TXBASE
op_plus
(paren
id|priv-&gt;nexttxput
op_star
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
suffix:semicolon
id|SKMCA_FROMIO
c_func
(paren
op_amp
id|descr
comma
id|dev-&gt;mem_start
op_plus
id|address
comma
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
suffix:semicolon
multiline_comment|/* enter packet length as 2s complement - assure minimum length */
id|tmplen
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|tmplen
OL
l_int|60
)paren
id|tmplen
op_assign
l_int|60
suffix:semicolon
id|descr.Len
op_assign
l_int|65536
op_minus
id|tmplen
suffix:semicolon
multiline_comment|/* copy filler into RAM - in case we&squot;re filling up... &n;&t;   we&squot;re filling a bit more than necessary, but that doesn&squot;t harm&n;&t;   since the buffer is far larger... */
r_if
c_cond
(paren
id|tmplen
OG
id|skb-&gt;len
)paren
(brace
r_char
op_star
id|fill
op_assign
l_string|&quot;NetBSD is a nice OS too! &quot;
suffix:semicolon
r_int
r_int
id|destoffs
op_assign
l_int|0
comma
id|l
op_assign
id|strlen
c_func
(paren
id|fill
)paren
suffix:semicolon
r_while
c_loop
(paren
id|destoffs
OL
id|tmplen
)paren
(brace
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|descr.LowAddr
op_plus
id|destoffs
comma
id|fill
comma
id|l
)paren
suffix:semicolon
id|destoffs
op_add_assign
id|l
suffix:semicolon
)brace
)brace
multiline_comment|/* do the real data copying */
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|descr.LowAddr
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* hand descriptor over to LANCE - this is the first and last chunk */
id|descr.Flags
op_assign
id|TXDSCR_FLAGS_OWN
op_or
id|TXDSCR_FLAGS_STP
op_or
id|TXDSCR_FLAGS_ENP
suffix:semicolon
macro_line|#ifdef DEBUG
id|PrTime
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Send packet on descr %d len %d&bslash;n&quot;
comma
id|priv-&gt;nexttxput
comma
id|skb-&gt;len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* one more descriptor busy */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|priv-&gt;nexttxput
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;nexttxput
op_ge
id|TXCOUNT
)paren
id|priv-&gt;nexttxput
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txbusy
op_increment
suffix:semicolon
multiline_comment|/* are we saturated ? */
r_if
c_cond
(paren
id|priv-&gt;txbusy
op_ge
id|TXCOUNT
)paren
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* write descriptor back to RAM */
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|address
comma
op_amp
id|descr
comma
r_sizeof
(paren
id|LANCE_TxDescr
)paren
)paren
suffix:semicolon
multiline_comment|/* if no descriptors were active, give the LANCE a hint to read it&n;&t;   immediately */
r_if
c_cond
(paren
id|priv-&gt;txbusy
op_eq
l_int|0
)paren
id|SetLANCE
c_func
(paren
id|dev
comma
id|LANCE_CSR0
comma
id|CSR0_INEA
op_or
id|CSR0_TDMD
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|tx_done
suffix:colon
multiline_comment|/* When did that change exactly ? */
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020200
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* return pointer to Ethernet statistics */
DECL|function|skmca_stats
r_static
r_struct
id|net_device_stats
op_star
id|skmca_stats
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|skmca_priv
op_star
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
(paren
id|priv-&gt;stat
)paren
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t support runtime reconfiguration, since an MCA card can&n;   be unambigously identified by its POS registers. */
DECL|function|skmca_config
r_static
r_int
id|skmca_config
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
comma
r_struct
id|ifmap
op_star
id|map
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* switch receiver mode.  We use the LANCE&squot;s multicast filter to prefilter&n;   multicast addresses. */
DECL|function|skmca_set_multicast_list
r_static
r_void
id|skmca_set_multicast_list
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
id|LANCE_InitBlock
id|block
suffix:semicolon
multiline_comment|/* first stop the LANCE... */
id|StopLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* ...then modify the initialization block... */
id|SKMCA_FROMIO
c_func
(paren
op_amp
id|block
comma
id|dev-&gt;mem_start
op_plus
id|RAM_INITBASE
comma
r_sizeof
(paren
id|block
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|block.Mode
op_or_assign
id|LANCE_INIT_PROM
suffix:semicolon
r_else
id|block.Mode
op_and_assign
op_complement
id|LANCE_INIT_PROM
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* get all multicasts */
id|memset
c_func
(paren
id|block.LAdrF
comma
l_int|8
comma
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* get selected/no multicasts */
r_struct
id|dev_mc_list
op_star
id|mptr
suffix:semicolon
r_int
id|code
suffix:semicolon
id|memset
c_func
(paren
id|block.LAdrF
comma
l_int|8
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mptr
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mptr
op_ne
l_int|NULL
suffix:semicolon
id|mptr
op_assign
id|mptr-&gt;next
)paren
(brace
id|code
op_assign
id|GetHash
c_func
(paren
id|mptr-&gt;dmi_addr
)paren
suffix:semicolon
id|block.LAdrF
(braket
(paren
id|code
op_rshift
l_int|3
)paren
op_amp
l_int|7
)braket
op_or_assign
l_int|1
op_lshift
(paren
id|code
op_amp
l_int|7
)paren
suffix:semicolon
)brace
)brace
id|SKMCA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|RAM_INITBASE
comma
op_amp
id|block
comma
r_sizeof
(paren
id|block
)paren
)paren
suffix:semicolon
multiline_comment|/* ...then reinit LANCE with the correct flags */
id|InitLANCE
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * hardware check&n; * ------------------------------------------------------------------------ */
DECL|variable|startslot
r_static
r_int
id|startslot
suffix:semicolon
multiline_comment|/* counts through slots when probing multiple devices */
DECL|function|skmca_probe
r_int
id|skmca_probe
c_func
(paren
r_struct
id|SKMCA_NETDEV
op_star
id|dev
)paren
(brace
r_int
id|force_detect
op_assign
l_int|0
suffix:semicolon
r_int
id|junior
comma
id|slot
comma
id|i
suffix:semicolon
r_int
id|base
op_assign
l_int|0
comma
id|irq
op_assign
l_int|0
suffix:semicolon
id|skmca_priv
op_star
id|priv
suffix:semicolon
id|skmca_medium
id|medium
suffix:semicolon
multiline_comment|/* can&squot;t work without an MCA bus ;-) */
r_if
c_cond
(paren
id|MCA_bus
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* start address of 1 --&gt; forced detection */
r_if
c_cond
(paren
id|dev-&gt;mem_start
op_eq
l_int|1
)paren
id|force_detect
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* search through slots */
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
id|base
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
)brace
id|slot
op_assign
id|dofind
c_func
(paren
op_amp
id|junior
comma
id|startslot
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* deduce card addresses */
id|getaddrs
c_func
(paren
id|slot
comma
id|junior
comma
op_amp
id|base
comma
op_amp
id|irq
comma
op_amp
id|medium
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020300
multiline_comment|/* slot already in use ? */
r_if
c_cond
(paren
id|mca_is_adapter_used
c_func
(paren
id|slot
)paren
)paren
(brace
id|slot
op_assign
id|dofind
c_func
(paren
op_amp
id|junior
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* were we looking for something different ? */
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
op_logical_or
(paren
id|dev-&gt;mem_start
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
op_logical_and
(paren
id|dev-&gt;irq
op_ne
id|irq
)paren
)paren
(brace
id|slot
op_assign
id|dofind
c_func
(paren
op_amp
id|junior
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_start
op_ne
l_int|0
)paren
op_logical_and
(paren
id|dev-&gt;mem_start
op_ne
id|base
)paren
)paren
(brace
id|slot
op_assign
id|dofind
c_func
(paren
op_amp
id|junior
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* found something that matches */
r_break
suffix:semicolon
)brace
multiline_comment|/* nothing found ? */
r_if
c_cond
(paren
id|slot
op_eq
op_minus
l_int|1
)paren
r_return
(paren
(paren
id|base
op_ne
l_int|0
)paren
op_logical_or
(paren
id|irq
op_ne
l_int|0
)paren
)paren
ques
c_cond
id|ENXIO
suffix:colon
id|ENODEV
suffix:semicolon
multiline_comment|/* make procfs entries */
r_if
c_cond
(paren
id|junior
)paren
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_string|&quot;SKNET junior MC2 Ethernet Adapter&quot;
)paren
suffix:semicolon
r_else
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_string|&quot;SKNET MC2+ Ethernet Adapter&quot;
)paren
suffix:semicolon
id|mca_set_adapter_procfn
c_func
(paren
id|slot
comma
(paren
id|MCA_ProcFn
)paren
id|skmca_getinfo
comma
id|dev
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020200
id|mca_mark_as_used
c_func
(paren
id|slot
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* announce success */
id|printk
c_func
(paren
l_string|&quot;%s: SKNet %s adapter found in slot %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|junior
ques
c_cond
l_string|&quot;Junior MC2&quot;
suffix:colon
l_string|&quot;MC2+&quot;
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* allocate structure */
id|priv
op_assign
id|dev-&gt;priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|skmca_priv
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|priv-&gt;slot
op_assign
id|slot
suffix:semicolon
id|priv-&gt;macbase
op_assign
id|base
op_plus
l_int|0x3fc0
suffix:semicolon
id|priv-&gt;ioregaddr
op_assign
id|base
op_plus
l_int|0x3ff0
suffix:semicolon
id|priv-&gt;ctrladdr
op_assign
id|base
op_plus
l_int|0x3ff2
suffix:semicolon
id|priv-&gt;cmdaddr
op_assign
id|base
op_plus
l_int|0x3ff3
suffix:semicolon
id|priv-&gt;medium
op_assign
id|medium
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|priv-&gt;stat
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
multiline_comment|/* set base + irq for this device (irq not allocated so far) */
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|base
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|base
op_plus
l_int|0x4000
suffix:semicolon
multiline_comment|/* autoprobe ? */
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
r_int
id|nirq
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: ambigous POS bit combination, must probe for IRQ...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|nirq
op_assign
id|ProbeIRQ
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nirq
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: IRQ probe failed, assuming IRQ %d&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;realirq
op_assign
op_minus
id|irq
)paren
suffix:semicolon
r_else
id|priv-&gt;realirq
op_assign
id|nirq
suffix:semicolon
)brace
r_else
id|priv-&gt;realirq
op_assign
id|irq
suffix:semicolon
multiline_comment|/* set methods */
id|dev-&gt;open
op_assign
id|skmca_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|skmca_close
suffix:semicolon
id|dev-&gt;set_config
op_assign
id|skmca_config
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|skmca_tx
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|skmca_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|skmca_set_multicast_list
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_MULTICAST
suffix:semicolon
multiline_comment|/* generic setup */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* copy out MAC address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|SKMCA_READB
c_func
(paren
id|priv-&gt;macbase
op_plus
(paren
id|i
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* print config */
id|printk
c_func
(paren
l_string|&quot;%s: IRQ %d, memory %#lx-%#lx, &quot;
l_string|&quot;MAC address %02x:%02x:%02x:%02x:%02x:%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;realirq
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s medium&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|MediaNames
(braket
id|priv-&gt;medium
)braket
)paren
suffix:semicolon
multiline_comment|/* reset board */
id|ResetBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
id|startslot
op_assign
id|slot
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * modularization support&n; * ------------------------------------------------------------------------ */
macro_line|#ifdef MODULE
DECL|macro|DEVMAX
mdefine_line|#define DEVMAX 5
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x020369)
DECL|variable|moddevs
r_static
r_struct
id|SKMCA_NETDEV
id|moddevs
(braket
id|DEVMAX
)braket
op_assign
(brace
(brace
l_string|&quot;    &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
l_string|&quot;    &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
l_string|&quot;    &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
l_string|&quot;    &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
l_string|&quot;    &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
)brace
suffix:semicolon
macro_line|#else
DECL|variable|NameSpace
r_static
r_char
id|NameSpace
(braket
l_int|8
op_star
id|DEVMAX
)braket
suffix:semicolon
DECL|variable|moddevs
r_static
r_struct
id|SKMCA_NETDEV
id|moddevs
(braket
id|DEVMAX
)braket
op_assign
(brace
(brace
id|NameSpace
op_plus
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
id|NameSpace
op_plus
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
id|NameSpace
op_plus
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
id|NameSpace
op_plus
l_int|24
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
comma
(brace
id|NameSpace
op_plus
l_int|32
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|skmca_probe
)brace
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|irq
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
DECL|variable|io
r_int
id|io
op_assign
l_int|0
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|z
comma
id|res
suffix:semicolon
id|startslot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|DEVMAX
suffix:semicolon
id|z
op_increment
)paren
(brace
id|strcpy
c_func
(paren
id|moddevs
(braket
id|z
)braket
dot
id|name
comma
l_string|&quot;     &quot;
)paren
suffix:semicolon
id|res
op_assign
id|register_netdev
c_func
(paren
id|moddevs
op_plus
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
l_int|0
)paren
r_return
(paren
id|z
OG
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|SKMCA_NETDEV
op_star
id|dev
suffix:semicolon
id|skmca_priv
op_star
id|priv
suffix:semicolon
r_int
id|z
suffix:semicolon
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot unload, module in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|DEVMAX
suffix:semicolon
id|z
op_increment
)paren
(brace
id|dev
op_assign
id|moddevs
op_plus
id|z
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_ne
l_int|NULL
)paren
(brace
id|priv
op_assign
(paren
id|skmca_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|DeinitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020200
id|mca_mark_as_unused
c_func
(paren
id|priv-&gt;slot
)paren
suffix:semicolon
macro_line|#endif
id|mca_set_adapter_procfn
c_func
(paren
id|priv-&gt;slot
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
eof
