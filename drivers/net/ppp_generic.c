multiline_comment|/*&n; * Generic PPP layer for Linux.&n; *&n; * Copyright 1999-2000 Paul Mackerras.&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * The generic PPP layer handles the PPP network interfaces, the&n; * /dev/ppp device, packet and VJ compression, and multilink.&n; * It talks to PPP `channels&squot; via the interface defined in&n; * include/linux/ppp_channel.h.  Channels provide the basic means for&n; * sending and receiving PPP frames on some kind of communications&n; * channel.&n; *&n; * Part of the code in this driver was inspired by the old async-only&n; * PPP driver, written by Michael Callahan and Al Longyear, and&n; * subsequently hacked by Paul Mackerras.&n; *&n; * ==FILEVERSION 20000417==&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/if_ppp.h&gt;
macro_line|#include &lt;linux/ppp_channel.h&gt;
macro_line|#include &lt;linux/ppp-comp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;net/slhc_vj.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|PPP_VERSION
mdefine_line|#define PPP_VERSION&t;&quot;2.4.1&quot;
multiline_comment|/*&n; * Network protocols we support.&n; */
DECL|macro|NP_IP
mdefine_line|#define NP_IP&t;0&t;&t;/* Internet Protocol V4 */
DECL|macro|NP_IPV6
mdefine_line|#define NP_IPV6&t;1&t;&t;/* Internet Protocol V6 */
DECL|macro|NP_IPX
mdefine_line|#define NP_IPX&t;2&t;&t;/* IPX protocol */
DECL|macro|NP_AT
mdefine_line|#define NP_AT&t;3&t;&t;/* Appletalk protocol */
DECL|macro|NUM_NP
mdefine_line|#define NUM_NP&t;4&t;&t;/* Number of NPs. */
DECL|macro|MPHDRLEN
mdefine_line|#define MPHDRLEN&t;6&t;/* multilink protocol header length */
DECL|macro|MPHDRLEN_SSN
mdefine_line|#define MPHDRLEN_SSN&t;4&t;/* ditto with short sequence numbers */
DECL|macro|MIN_FRAG_SIZE
mdefine_line|#define MIN_FRAG_SIZE&t;64
multiline_comment|/*&n; * An instance of /dev/ppp can be associated with either a ppp&n; * interface unit or a ppp channel.  In both cases, file-&gt;private_data&n; * points to one of these.&n; */
DECL|struct|ppp_file
r_struct
id|ppp_file
(brace
r_enum
(brace
DECL|enumerator|INTERFACE
DECL|enumerator|CHANNEL
id|INTERFACE
op_assign
l_int|1
comma
id|CHANNEL
DECL|member|kind
)brace
id|kind
suffix:semicolon
DECL|member|xq
r_struct
id|sk_buff_head
id|xq
suffix:semicolon
multiline_comment|/* pppd transmit queue */
DECL|member|rq
r_struct
id|sk_buff_head
id|rq
suffix:semicolon
multiline_comment|/* receive queue for pppd */
DECL|member|rwait
id|wait_queue_head_t
id|rwait
suffix:semicolon
multiline_comment|/* for poll on reading /dev/ppp */
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
multiline_comment|/* # refs (incl /dev/ppp attached) */
DECL|member|hdrlen
r_int
id|hdrlen
suffix:semicolon
multiline_comment|/* space to leave for headers */
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* link in all_* list */
DECL|member|index
r_int
id|index
suffix:semicolon
multiline_comment|/* interface unit / channel number */
)brace
suffix:semicolon
DECL|macro|PF_TO_X
mdefine_line|#define PF_TO_X(pf, X)&t;((X *)((char *)(pf)-(unsigned long)(&amp;((X *)0)-&gt;file)))
DECL|macro|PF_TO_PPP
mdefine_line|#define PF_TO_PPP(pf)&t;&t;PF_TO_X(pf, struct ppp)
DECL|macro|PF_TO_CHANNEL
mdefine_line|#define PF_TO_CHANNEL(pf)&t;PF_TO_X(pf, struct channel)
DECL|macro|ROUNDUP
mdefine_line|#define ROUNDUP(n, x)&t;&t;(((n) + (x) - 1) / (x))
multiline_comment|/*&n; * Data structure describing one ppp unit.&n; * A ppp unit corresponds to a ppp network interface device&n; * and represents a multilink bundle.&n; * It can have 0 or more ppp channels connected to it.&n; */
DECL|struct|ppp
r_struct
id|ppp
(brace
DECL|member|file
r_struct
id|ppp_file
id|file
suffix:semicolon
multiline_comment|/* stuff for read/write/poll */
DECL|member|channels
r_struct
id|list_head
id|channels
suffix:semicolon
multiline_comment|/* list of attached channels */
DECL|member|n_channels
r_int
id|n_channels
suffix:semicolon
multiline_comment|/* how many channels are attached */
DECL|member|rlock
id|spinlock_t
id|rlock
suffix:semicolon
multiline_comment|/* lock for receive side */
DECL|member|wlock
id|spinlock_t
id|wlock
suffix:semicolon
multiline_comment|/* lock for transmit side */
DECL|member|mru
r_int
id|mru
suffix:semicolon
multiline_comment|/* max receive unit */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* control bits */
DECL|member|xstate
r_int
r_int
id|xstate
suffix:semicolon
multiline_comment|/* transmit state bits */
DECL|member|rstate
r_int
r_int
id|rstate
suffix:semicolon
multiline_comment|/* receive state bits */
DECL|member|debug
r_int
id|debug
suffix:semicolon
multiline_comment|/* debug flags */
DECL|member|vj
r_struct
id|slcompress
op_star
id|vj
suffix:semicolon
multiline_comment|/* state for VJ header compression */
DECL|member|npmode
r_enum
id|NPmode
id|npmode
(braket
id|NUM_NP
)braket
suffix:semicolon
multiline_comment|/* what to do with each net proto */
DECL|member|xmit_pending
r_struct
id|sk_buff
op_star
id|xmit_pending
suffix:semicolon
multiline_comment|/* a packet ready to go out */
DECL|member|xcomp
r_struct
id|compressor
op_star
id|xcomp
suffix:semicolon
multiline_comment|/* transmit packet compressor */
DECL|member|xc_state
r_void
op_star
id|xc_state
suffix:semicolon
multiline_comment|/* its internal state */
DECL|member|rcomp
r_struct
id|compressor
op_star
id|rcomp
suffix:semicolon
multiline_comment|/* receive decompressor */
DECL|member|rc_state
r_void
op_star
id|rc_state
suffix:semicolon
multiline_comment|/* its internal state */
DECL|member|last_xmit
r_int
r_int
id|last_xmit
suffix:semicolon
multiline_comment|/* jiffies when last pkt sent */
DECL|member|last_recv
r_int
r_int
id|last_recv
suffix:semicolon
multiline_comment|/* jiffies when last pkt rcvd */
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* network interface device */
macro_line|#ifdef CONFIG_PPP_MULTILINK
DECL|member|nxchan
r_int
id|nxchan
suffix:semicolon
multiline_comment|/* next channel to send something on */
DECL|member|nxseq
id|u32
id|nxseq
suffix:semicolon
multiline_comment|/* next sequence number to send */
DECL|member|mrru
r_int
id|mrru
suffix:semicolon
multiline_comment|/* MP: max reconst. receive unit */
DECL|member|nextseq
id|u32
id|nextseq
suffix:semicolon
multiline_comment|/* MP: seq no of next packet */
DECL|member|minseq
id|u32
id|minseq
suffix:semicolon
multiline_comment|/* MP: min of most recent seqnos */
DECL|member|mrq
r_struct
id|sk_buff_head
id|mrq
suffix:semicolon
multiline_comment|/* MP: receive reconstruction queue */
macro_line|#endif /* CONFIG_PPP_MULTILINK */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* statistics */
)brace
suffix:semicolon
multiline_comment|/*&n; * Bits in flags: SC_NO_TCP_CCID, SC_CCP_OPEN, SC_CCP_UP, SC_LOOP_TRAFFIC,&n; * SC_MULTILINK, SC_MP_SHORTSEQ, SC_MP_XSHORTSEQ, SC_COMP_TCP, SC_REJ_COMP_TCP.&n; * Bits in rstate: SC_DECOMP_RUN, SC_DC_ERROR, SC_DC_FERROR.&n; * Bits in xstate: SC_COMP_RUN&n; */
DECL|macro|SC_FLAG_BITS
mdefine_line|#define SC_FLAG_BITS&t;(SC_NO_TCP_CCID|SC_CCP_OPEN|SC_CCP_UP|SC_LOOP_TRAFFIC &bslash;&n;&t;&t;&t; |SC_MULTILINK|SC_MP_SHORTSEQ|SC_MP_XSHORTSEQ &bslash;&n;&t;&t;&t; |SC_COMP_TCP|SC_REJ_COMP_TCP)
multiline_comment|/*&n; * Private data structure for each channel.&n; * This includes the data structure used for multilink.&n; */
DECL|struct|channel
r_struct
id|channel
(brace
DECL|member|file
r_struct
id|ppp_file
id|file
suffix:semicolon
multiline_comment|/* stuff for read/write/poll */
DECL|member|chan
r_struct
id|ppp_channel
op_star
id|chan
suffix:semicolon
multiline_comment|/* public channel data structure */
DECL|member|downl
id|spinlock_t
id|downl
suffix:semicolon
multiline_comment|/* protects `chan&squot;, file.xq dequeue */
DECL|member|ppp
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
multiline_comment|/* ppp unit we&squot;re connected to */
DECL|member|clist
r_struct
id|list_head
id|clist
suffix:semicolon
multiline_comment|/* link in list of channels per unit */
DECL|member|upl
id|rwlock_t
id|upl
suffix:semicolon
multiline_comment|/* protects `ppp&squot; and `ulist&squot; */
macro_line|#ifdef CONFIG_PPP_MULTILINK
DECL|member|avail
id|u8
id|avail
suffix:semicolon
multiline_comment|/* flag used in multilink stuff */
DECL|member|had_frag
id|u8
id|had_frag
suffix:semicolon
multiline_comment|/* &gt;= 1 fragments have been sent */
DECL|member|lastseq
id|u32
id|lastseq
suffix:semicolon
multiline_comment|/* MP: last sequence # received */
macro_line|#endif /* CONFIG_PPP_MULTILINK */
)brace
suffix:semicolon
multiline_comment|/*&n; * SMP locking issues:&n; * Both the ppp.rlock and ppp.wlock locks protect the ppp.channels&n; * list and the ppp.n_channels field, you need to take both locks&n; * before you modify them.&n; * The lock ordering is: channel.upl -&gt; ppp.wlock -&gt; ppp.rlock -&gt;&n; * channel.downl.&n; */
multiline_comment|/*&n; * all_ppp_lock protects the all_ppp_units.&n; * It also ensures that finding a ppp unit in the all_ppp_units list&n; * and updating its file.refcnt field is atomic.&n; */
DECL|variable|all_ppp_lock
r_static
id|spinlock_t
id|all_ppp_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|all_ppp_units
)paren
suffix:semicolon
multiline_comment|/*&n; * all_channels_lock protects all_channels and last_channel_index,&n; * and the atomicity of find a channel and updating its file.refcnt&n; * field.&n; */
DECL|variable|all_channels_lock
r_static
id|spinlock_t
id|all_channels_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|all_channels
)paren
suffix:semicolon
DECL|variable|last_channel_index
r_static
r_int
id|last_channel_index
suffix:semicolon
multiline_comment|/* Get the PPP protocol number from a skb */
DECL|macro|PPP_PROTO
mdefine_line|#define PPP_PROTO(skb)&t;(((skb)-&gt;data[0] &lt;&lt; 8) + (skb)-&gt;data[1])
multiline_comment|/* We limit the length of ppp-&gt;file.rq to this (arbitrary) value */
DECL|macro|PPP_MAX_RQLEN
mdefine_line|#define PPP_MAX_RQLEN&t;32
multiline_comment|/*&n; * Maximum number of multilink fragments queued up.&n; * This has to be large enough to cope with the maximum latency of&n; * the slowest channel relative to the others.  Strictly it should&n; * depend on the number of channels and their characteristics.&n; */
DECL|macro|PPP_MP_MAX_QLEN
mdefine_line|#define PPP_MP_MAX_QLEN&t;128
multiline_comment|/* Multilink header bits. */
DECL|macro|B
mdefine_line|#define B&t;0x80&t;&t;/* this fragment begins a packet */
DECL|macro|E
mdefine_line|#define E&t;0x40&t;&t;/* this fragment ends a packet */
multiline_comment|/* Compare multilink sequence numbers (assumed to be 32 bits wide) */
DECL|macro|seq_before
mdefine_line|#define seq_before(a, b)&t;((s32)((a) - (b)) &lt; 0)
DECL|macro|seq_after
mdefine_line|#define seq_after(a, b)&t;&t;((s32)((a) - (b)) &gt; 0)
multiline_comment|/* Prototypes. */
r_static
id|ssize_t
id|ppp_file_read
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
id|ssize_t
id|ppp_file_write
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|ppp_unattached_ioctl
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ppp_xmit_process
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_send_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|ppp_push
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_channel_push
c_func
(paren
r_struct
id|channel
op_star
id|pch
)paren
suffix:semicolon
r_static
r_void
id|ppp_receive_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|channel
op_star
id|pch
)paren
suffix:semicolon
r_static
r_void
id|ppp_receive_error
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_void
id|ppp_receive_nonmp_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_struct
id|sk_buff
op_star
id|ppp_decompress_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPP_MULTILINK
r_static
r_void
id|ppp_receive_mp_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|channel
op_star
id|pch
)paren
suffix:semicolon
r_static
r_void
id|ppp_mp_insert
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_struct
id|sk_buff
op_star
id|ppp_mp_reconstruct
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_int
id|ppp_mp_explode
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPP_MULTILINK */
r_static
r_int
id|ppp_set_compress
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ppp_ccp_peek
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|inbound
)paren
suffix:semicolon
r_static
r_void
id|ppp_ccp_closed
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_struct
id|compressor
op_star
id|find_compressor
c_func
(paren
r_int
id|type
)paren
suffix:semicolon
r_static
r_void
id|ppp_get_stats
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_stats
op_star
id|st
)paren
suffix:semicolon
r_static
r_struct
id|ppp
op_star
id|ppp_create_interface
c_func
(paren
r_int
id|unit
comma
r_int
op_star
id|retp
)paren
suffix:semicolon
r_static
r_void
id|init_ppp_file
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_int
id|kind
)paren
suffix:semicolon
r_static
r_void
id|ppp_destroy_interface
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
suffix:semicolon
r_static
r_struct
id|ppp
op_star
id|ppp_find_unit
c_func
(paren
r_int
id|unit
)paren
suffix:semicolon
r_static
r_struct
id|channel
op_star
id|ppp_find_channel
c_func
(paren
r_int
id|unit
)paren
suffix:semicolon
r_static
r_int
id|ppp_connect_channel
c_func
(paren
r_struct
id|channel
op_star
id|pch
comma
r_int
id|unit
)paren
suffix:semicolon
r_static
r_int
id|ppp_disconnect_channel
c_func
(paren
r_struct
id|channel
op_star
id|pch
)paren
suffix:semicolon
r_static
r_void
id|ppp_destroy_channel
c_func
(paren
r_struct
id|channel
op_star
id|pch
)paren
suffix:semicolon
multiline_comment|/* Translates a PPP protocol number to a NP index (NP == network protocol) */
DECL|function|proto_to_npindex
r_static
r_inline
r_int
id|proto_to_npindex
c_func
(paren
r_int
id|proto
)paren
(brace
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|PPP_IP
suffix:colon
r_return
id|NP_IP
suffix:semicolon
r_case
id|PPP_IPV6
suffix:colon
r_return
id|NP_IPV6
suffix:semicolon
r_case
id|PPP_IPX
suffix:colon
r_return
id|NP_IPX
suffix:semicolon
r_case
id|PPP_AT
suffix:colon
r_return
id|NP_AT
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Translates an NP index into a PPP protocol number */
DECL|variable|npindex_to_proto
r_static
r_const
r_int
id|npindex_to_proto
(braket
id|NUM_NP
)braket
op_assign
(brace
id|PPP_IP
comma
id|PPP_IPV6
comma
id|PPP_IPX
comma
id|PPP_AT
comma
)brace
suffix:semicolon
multiline_comment|/* Translates an ethertype into an NP index */
DECL|function|ethertype_to_npindex
r_static
r_inline
r_int
id|ethertype_to_npindex
c_func
(paren
r_int
id|ethertype
)paren
(brace
r_switch
c_cond
(paren
id|ethertype
)paren
(brace
r_case
id|ETH_P_IP
suffix:colon
r_return
id|NP_IP
suffix:semicolon
r_case
id|ETH_P_IPV6
suffix:colon
r_return
id|NP_IPV6
suffix:semicolon
r_case
id|ETH_P_IPX
suffix:colon
r_return
id|NP_IPX
suffix:semicolon
r_case
id|ETH_P_PPPTALK
suffix:colon
r_case
id|ETH_P_ATALK
suffix:colon
r_return
id|NP_AT
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Translates an NP index into an ethertype */
DECL|variable|npindex_to_ethertype
r_static
r_const
r_int
id|npindex_to_ethertype
(braket
id|NUM_NP
)braket
op_assign
(brace
id|ETH_P_IP
comma
id|ETH_P_IPV6
comma
id|ETH_P_IPX
comma
id|ETH_P_PPPTALK
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Locking shorthand.&n; */
DECL|macro|ppp_xmit_lock
mdefine_line|#define ppp_xmit_lock(ppp)&t;spin_lock_bh(&amp;(ppp)-&gt;wlock)
DECL|macro|ppp_xmit_unlock
mdefine_line|#define ppp_xmit_unlock(ppp)&t;spin_unlock_bh(&amp;(ppp)-&gt;wlock)
DECL|macro|ppp_recv_lock
mdefine_line|#define ppp_recv_lock(ppp)&t;spin_lock_bh(&amp;(ppp)-&gt;rlock)
DECL|macro|ppp_recv_unlock
mdefine_line|#define ppp_recv_unlock(ppp)&t;spin_unlock_bh(&amp;(ppp)-&gt;rlock)
DECL|macro|ppp_lock
mdefine_line|#define ppp_lock(ppp)&t;&t;do { ppp_xmit_lock(ppp); &bslash;&n;&t;&t;&t;&t;     ppp_recv_lock(ppp); } while (0)
DECL|macro|ppp_unlock
mdefine_line|#define ppp_unlock(ppp)&t;&t;do { ppp_recv_unlock(ppp); &bslash;&n;&t;&t;&t;&t;     ppp_xmit_unlock(ppp); } while (0)
multiline_comment|/*&n; * /dev/ppp device routines.&n; * The /dev/ppp device is used by pppd to control the ppp unit.&n; * It supports the read, write, ioctl and poll functions.&n; * Open instances of /dev/ppp can be in one of three states:&n; * unattached, attached to a ppp unit, or attached to a ppp channel.&n; */
DECL|function|ppp_open
r_static
r_int
id|ppp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/*&n;&t; * This could (should?) be enforced by the permissions on /dev/ppp.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppp_release
r_static
r_int
id|ppp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|ppp_file
op_star
id|pf
op_assign
(paren
r_struct
id|ppp_file
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf
op_ne
l_int|0
)paren
(brace
id|file-&gt;private_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pf-&gt;refcnt
)paren
)paren
(brace
r_switch
c_cond
(paren
id|pf-&gt;kind
)paren
(brace
r_case
id|INTERFACE
suffix:colon
id|ppp_destroy_interface
c_func
(paren
id|PF_TO_PPP
c_func
(paren
id|pf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CHANNEL
suffix:colon
id|ppp_destroy_channel
c_func
(paren
id|PF_TO_CHANNEL
c_func
(paren
id|pf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppp_read
r_static
id|ssize_t
id|ppp_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ppp_file
op_star
id|pf
op_assign
(paren
r_struct
id|ppp_file
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|ppp_file_read
c_func
(paren
id|pf
comma
id|file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|ppp_file_read
r_static
id|ssize_t
id|ppp_file_read
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|pf
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* not currently attached */
id|add_wait_queue
c_func
(paren
op_amp
id|pf-&gt;rwait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|pf-&gt;rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_break
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;kind
op_eq
id|CHANNEL
op_logical_and
id|PF_TO_CHANNEL
c_func
(paren
id|pf
)paren
op_member_access_from_pointer
id|chan
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|pf-&gt;rwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|count
)paren
r_goto
id|outf
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
)paren
r_goto
id|outf
suffix:semicolon
id|ret
op_assign
id|skb-&gt;len
suffix:semicolon
id|outf
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ppp_write
r_static
id|ssize_t
id|ppp_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ppp_file
op_star
id|pf
op_assign
(paren
r_struct
id|ppp_file
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|ppp_file_write
c_func
(paren
id|pf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|ppp_file_write
r_static
id|ssize_t
id|ppp_file_write
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|pf
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|count
op_plus
id|pf-&gt;hdrlen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|pf-&gt;hdrlen
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|pf-&gt;xq
comma
id|skb
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pf-&gt;kind
)paren
(brace
r_case
id|INTERFACE
suffix:colon
id|ppp_xmit_process
c_func
(paren
id|PF_TO_PPP
c_func
(paren
id|pf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CHANNEL
suffix:colon
id|ppp_channel_push
c_func
(paren
id|PF_TO_CHANNEL
c_func
(paren
id|pf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|count
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - fine */
DECL|function|ppp_poll
r_static
r_int
r_int
id|ppp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|ppp_file
op_star
id|pf
op_assign
(paren
r_struct
id|ppp_file
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|pf
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|pf-&gt;rwait
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|pf-&gt;rq
)paren
op_ne
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;kind
op_eq
id|CHANNEL
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|PF_TO_CHANNEL
c_func
(paren
id|pf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;chan
op_eq
l_int|0
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
DECL|function|ppp_ioctl
r_static
r_int
id|ppp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ppp_file
op_star
id|pf
op_assign
(paren
r_struct
id|ppp_file
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EFAULT
comma
id|val
comma
id|val2
comma
id|i
suffix:semicolon
r_struct
id|ppp_idle
id|idle
suffix:semicolon
r_struct
id|npioctl
id|npi
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_struct
id|slcompress
op_star
id|vj
suffix:semicolon
r_if
c_cond
(paren
id|pf
op_eq
l_int|0
)paren
r_return
id|ppp_unattached_ioctl
c_func
(paren
id|pf
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;kind
op_eq
id|CHANNEL
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|PF_TO_CHANNEL
c_func
(paren
id|pf
)paren
suffix:semicolon
r_struct
id|ppp_channel
op_star
id|chan
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCCONNECT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|unit
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
id|ppp_connect_channel
c_func
(paren
id|pch
comma
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCDISCONN
suffix:colon
id|err
op_assign
id|ppp_disconnect_channel
c_func
(paren
id|pch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCDETACH
suffix:colon
id|file-&gt;private_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pf-&gt;refcnt
)paren
)paren
id|ppp_destroy_channel
c_func
(paren
id|pch
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|spin_lock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
id|chan
op_assign
id|pch-&gt;chan
suffix:semicolon
id|err
op_assign
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_logical_and
id|chan-&gt;ops-&gt;ioctl
)paren
id|err
op_assign
id|chan-&gt;ops
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|chan
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pf-&gt;kind
op_ne
id|INTERFACE
)paren
(brace
multiline_comment|/* can&squot;t happen */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: not interface or channel??&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ppp
op_assign
id|PF_TO_PPP
c_func
(paren
id|pf
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCDETACH
suffix:colon
id|file-&gt;private_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pf-&gt;refcnt
)paren
)paren
id|ppp_destroy_interface
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMRU
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|ppp-&gt;mru
op_assign
id|val
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSFLAGS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|ppp_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
op_complement
id|val
op_amp
id|SC_CCP_OPEN
)paren
id|ppp_ccp_closed
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;flags
op_assign
id|val
op_amp
id|SC_FLAG_BITS
suffix:semicolon
id|ppp_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGFLAGS
suffix:colon
id|val
op_assign
id|ppp-&gt;flags
op_or
id|ppp-&gt;xstate
op_or
id|ppp-&gt;rstate
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSCOMPRESS
suffix:colon
id|err
op_assign
id|ppp_set_compress
c_func
(paren
id|ppp
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGUNIT
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp-&gt;file.index
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSDEBUG
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|ppp-&gt;debug
op_assign
id|val
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGDEBUG
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp-&gt;debug
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGIDLE
suffix:colon
id|idle.xmit_idle
op_assign
(paren
id|jiffies
op_minus
id|ppp-&gt;last_xmit
)paren
op_div
id|HZ
suffix:semicolon
id|idle.recv_idle
op_assign
(paren
id|jiffies
op_minus
id|ppp-&gt;last_recv
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|idle
comma
r_sizeof
(paren
id|idle
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMAXCID
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|val2
op_assign
l_int|15
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_rshift
l_int|16
)paren
op_ne
l_int|0
)paren
(brace
id|val2
op_assign
id|val
op_rshift
l_int|16
suffix:semicolon
id|val
op_and_assign
l_int|0xffff
suffix:semicolon
)brace
id|vj
op_assign
id|slhc_init
c_func
(paren
id|val2
op_plus
l_int|1
comma
id|val
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vj
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: no memory (VJ compressor)&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ppp_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;vj
op_ne
l_int|0
)paren
id|slhc_free
c_func
(paren
id|ppp-&gt;vj
)paren
suffix:semicolon
id|ppp-&gt;vj
op_assign
id|vj
suffix:semicolon
id|ppp_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGNPMODE
suffix:colon
r_case
id|PPPIOCSNPMODE
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|npi
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|npi
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
id|proto_to_npindex
c_func
(paren
id|npi.protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
id|i
op_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|PPPIOCGNPMODE
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|npi.mode
op_assign
id|ppp-&gt;npmode
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|npi
comma
r_sizeof
(paren
id|npi
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|ppp-&gt;npmode
(braket
id|i
)braket
op_assign
id|npi.mode
suffix:semicolon
multiline_comment|/* we may be able to transmit more packets now (??) */
id|netif_wake_queue
c_func
(paren
id|ppp-&gt;dev
)paren
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_PPP_MULTILINK
r_case
id|PPPIOCSMRRU
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|ppp_recv_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;mrru
op_assign
id|val
suffix:semicolon
id|ppp_recv_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_PPP_MULTILINK */
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|ppp_unattached_ioctl
r_static
r_int
id|ppp_unattached_ioctl
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|unit
comma
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
r_struct
id|channel
op_star
id|chan
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCNEWUNIT
suffix:colon
multiline_comment|/* Create a new ppp unit */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|unit
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|ppp
op_assign
id|ppp_create_interface
c_func
(paren
id|unit
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|file-&gt;private_data
op_assign
op_amp
id|ppp-&gt;file
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp-&gt;file.index
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCATTACH
suffix:colon
multiline_comment|/* Attach to an existing ppp unit */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|unit
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
id|ppp
op_assign
id|ppp_find_unit
c_func
(paren
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|0
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ppp-&gt;file.refcnt
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|file-&gt;private_data
op_assign
op_amp
id|ppp-&gt;file
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCATTCHAN
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|unit
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|all_channels_lock
)paren
suffix:semicolon
id|chan
op_assign
id|ppp_find_channel
c_func
(paren
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_ne
l_int|0
)paren
id|atomic_inc
c_func
(paren
op_amp
id|chan-&gt;file.refcnt
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|all_channels_lock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|file-&gt;private_data
op_assign
op_amp
id|chan-&gt;file
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ppp_device_fops
r_static
r_struct
id|file_operations
id|ppp_device_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|ppp_read
comma
id|write
suffix:colon
id|ppp_write
comma
id|poll
suffix:colon
id|ppp_poll
comma
id|ioctl
suffix:colon
id|ppp_ioctl
comma
id|open
suffix:colon
id|ppp_open
comma
id|release
suffix:colon
id|ppp_release
)brace
suffix:semicolon
DECL|macro|PPP_MAJOR
mdefine_line|#define PPP_MAJOR&t;108
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
multiline_comment|/* Called at boot time if ppp is compiled into the kernel,&n;   or at module load time (from init_module) if compiled as a module. */
DECL|function|ppp_init
r_int
id|__init
id|ppp_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PPP generic driver version &quot;
id|PPP_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|devfs_register_chrdev
c_func
(paren
id|PPP_MAJOR
comma
l_string|&quot;ppp&quot;
comma
op_amp
id|ppp_device_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;failed to register PPP device (%d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|devfs_handle
op_assign
id|devfs_register
c_func
(paren
l_int|NULL
comma
l_string|&quot;ppp&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|PPP_MAJOR
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|ppp_device_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Network interface unit routines.&n; */
r_static
r_int
DECL|function|ppp_start_xmit
id|ppp_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
(paren
r_struct
id|ppp
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|npi
comma
id|proto
suffix:semicolon
r_int
r_char
op_star
id|pp
suffix:semicolon
id|npi
op_assign
id|ethertype_to_npindex
c_func
(paren
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|npi
OL
l_int|0
)paren
r_goto
id|outf
suffix:semicolon
multiline_comment|/* Drop, accept or reject the packet */
r_switch
c_cond
(paren
id|ppp-&gt;npmode
(braket
id|npi
)braket
)paren
(brace
r_case
id|NPMODE_PASS
suffix:colon
r_break
suffix:semicolon
r_case
id|NPMODE_QUEUE
suffix:colon
multiline_comment|/* it would be nice to have a way to tell the network&n;&t;&t;   system to queue this one up for later. */
r_goto
id|outf
suffix:semicolon
r_case
id|NPMODE_DROP
suffix:colon
r_case
id|NPMODE_ERROR
suffix:colon
r_goto
id|outf
suffix:semicolon
)brace
multiline_comment|/* Put the 2-byte PPP protocol number on the front,&n;&t;   making sure there is room for the address and control fields. */
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|PPP_HDRLEN
)paren
(brace
r_struct
id|sk_buff
op_star
id|ns
suffix:semicolon
id|ns
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
id|dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ns
op_eq
l_int|0
)paren
r_goto
id|outf
suffix:semicolon
id|skb_reserve
c_func
(paren
id|ns
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|ns
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|ns
suffix:semicolon
)brace
id|pp
op_assign
id|skb_push
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|proto
op_assign
id|npindex_to_proto
(braket
id|npi
)braket
suffix:semicolon
id|pp
(braket
l_int|0
)braket
op_assign
id|proto
op_rshift
l_int|8
suffix:semicolon
id|pp
(braket
l_int|1
)braket
op_assign
id|proto
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|ppp-&gt;file.xq
comma
id|skb
)paren
suffix:semicolon
id|ppp_xmit_process
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|outf
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.tx_dropped
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|net_device_stats
op_star
DECL|function|ppp_net_stats
id|ppp_net_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
(paren
r_struct
id|ppp
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|ppp-&gt;stats
suffix:semicolon
)brace
r_static
r_int
DECL|function|ppp_net_ioctl
id|ppp_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_void
op_star
id|addr
op_assign
(paren
r_void
op_star
)paren
id|ifr-&gt;ifr_ifru.ifru_data
suffix:semicolon
r_struct
id|ppp_stats
id|stats
suffix:semicolon
r_struct
id|ppp_comp_stats
id|cstats
suffix:semicolon
r_char
op_star
id|vers
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGPPPSTATS
suffix:colon
id|ppp_get_stats
c_func
(paren
id|ppp
comma
op_amp
id|stats
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|addr
comma
op_amp
id|stats
comma
r_sizeof
(paren
id|stats
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGPPPCSTATS
suffix:colon
id|memset
c_func
(paren
op_amp
id|cstats
comma
l_int|0
comma
r_sizeof
(paren
id|cstats
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;xc_state
op_ne
l_int|0
)paren
id|ppp-&gt;xcomp
op_member_access_from_pointer
id|comp_stat
c_func
(paren
id|ppp-&gt;xc_state
comma
op_amp
id|cstats.c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;rc_state
op_ne
l_int|0
)paren
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|decomp_stat
c_func
(paren
id|ppp-&gt;rc_state
comma
op_amp
id|cstats.d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|addr
comma
op_amp
id|cstats
comma
r_sizeof
(paren
id|cstats
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGPPPVER
suffix:colon
id|vers
op_assign
id|PPP_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|addr
comma
id|vers
comma
id|strlen
c_func
(paren
id|vers
)paren
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_int
DECL|function|ppp_net_init
id|ppp_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;hard_header_len
op_assign
id|PPP_HDRLEN
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|PPP_MTU
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ppp_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ppp_net_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|ppp_net_ioctl
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|3
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_PPP
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
op_or
id|IFF_MULTICAST
suffix:semicolon
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Transmit-side routines.&n; */
multiline_comment|/*&n; * Called to do any work queued up on the transmit side&n; * that can now be done.&n; */
r_static
r_void
DECL|function|ppp_xmit_process
id|ppp_xmit_process
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ppp_xmit_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp_push
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ppp-&gt;xmit_pending
op_eq
l_int|0
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;file.xq
)paren
)paren
op_ne
l_int|0
)paren
id|ppp_send_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* If there&squot;s no work left to do, tell the core net&n;&t;   code that we can accept some more. */
r_if
c_cond
(paren
id|ppp-&gt;xmit_pending
op_eq
l_int|0
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|ppp-&gt;file.xq
)paren
op_eq
l_int|0
op_logical_and
id|ppp-&gt;dev
op_ne
l_int|0
)paren
id|netif_wake_queue
c_func
(paren
id|ppp-&gt;dev
)paren
suffix:semicolon
id|ppp_xmit_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Compress and send a frame.&n; * The caller should have locked the xmit path,&n; * and xmit_pending should be 0.&n; */
r_static
r_void
DECL|function|ppp_send_frame
id|ppp_send_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|proto
op_assign
id|PPP_PROTO
c_func
(paren
id|skb
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_char
op_star
id|cp
suffix:semicolon
op_increment
id|ppp-&gt;stats.tx_packets
suffix:semicolon
id|ppp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
op_minus
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|PPP_IP
suffix:colon
r_if
c_cond
(paren
id|ppp-&gt;vj
op_eq
l_int|0
op_logical_or
(paren
id|ppp-&gt;flags
op_amp
id|SC_COMP_TCP
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* try to do VJ TCP header compression */
id|new_skb
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
id|ppp-&gt;dev-&gt;hard_header_len
op_minus
l_int|2
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: no memory (VJ comp pkt)&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|new_skb
comma
id|ppp-&gt;dev-&gt;hard_header_len
op_minus
l_int|2
)paren
suffix:semicolon
id|cp
op_assign
id|skb-&gt;data
op_plus
l_int|2
suffix:semicolon
id|len
op_assign
id|slhc_compress
c_func
(paren
id|ppp-&gt;vj
comma
id|cp
comma
id|skb-&gt;len
op_minus
l_int|2
comma
id|new_skb-&gt;data
op_plus
l_int|2
comma
op_amp
id|cp
comma
op_logical_neg
(paren
id|ppp-&gt;flags
op_amp
id|SC_NO_TCP_CCID
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
id|skb-&gt;data
op_plus
l_int|2
)paren
(brace
multiline_comment|/* didn&squot;t compress */
id|kfree_skb
c_func
(paren
id|new_skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cp
(braket
l_int|0
)braket
op_amp
id|SL_TYPE_COMPRESSED_TCP
)paren
(brace
id|proto
op_assign
id|PPP_VJC_COMP
suffix:semicolon
id|cp
(braket
l_int|0
)braket
op_and_assign
op_complement
id|SL_TYPE_COMPRESSED_TCP
suffix:semicolon
)brace
r_else
(brace
id|proto
op_assign
id|PPP_VJC_UNCOMP
suffix:semicolon
id|cp
(braket
l_int|0
)braket
op_assign
id|skb-&gt;data
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|new_skb
suffix:semicolon
id|cp
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|cp
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|cp
(braket
l_int|1
)braket
op_assign
id|proto
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PPP_CCP
suffix:colon
multiline_comment|/* peek at outbound CCP frames */
id|ppp_ccp_peek
c_func
(paren
id|ppp
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* try to do packet compression */
r_if
c_cond
(paren
(paren
id|ppp-&gt;xstate
op_amp
id|SC_COMP_RUN
)paren
op_logical_and
id|ppp-&gt;xc_state
op_ne
l_int|0
op_logical_and
id|proto
op_ne
id|PPP_LCP
op_logical_and
id|proto
op_ne
id|PPP_CCP
)paren
(brace
id|new_skb
op_assign
id|alloc_skb
c_func
(paren
id|ppp-&gt;dev-&gt;mtu
op_plus
id|ppp-&gt;dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: no memory (comp pkt)&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppp-&gt;dev-&gt;hard_header_len
OG
id|PPP_HDRLEN
)paren
id|skb_reserve
c_func
(paren
id|new_skb
comma
id|ppp-&gt;dev-&gt;hard_header_len
op_minus
id|PPP_HDRLEN
)paren
suffix:semicolon
multiline_comment|/* compressor still expects A/C bytes in hdr */
id|len
op_assign
id|ppp-&gt;xcomp
op_member_access_from_pointer
id|compress
c_func
(paren
id|ppp-&gt;xc_state
comma
id|skb-&gt;data
op_minus
l_int|2
comma
id|new_skb-&gt;data
comma
id|skb-&gt;len
op_plus
l_int|2
comma
id|ppp-&gt;dev-&gt;mtu
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|new_skb
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* pull off A/C bytes */
)brace
r_else
(brace
multiline_comment|/* didn&squot;t compress, or CCP not up yet */
id|kfree_skb
c_func
(paren
id|new_skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for data packets, record the time */
r_if
c_cond
(paren
id|proto
OL
l_int|0x8000
)paren
id|ppp-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; * If we are waiting for traffic (demand dialling),&n;&t; * queue it up for pppd to receive.&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_LOOP_TRAFFIC
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;file.rq.qlen
OG
id|PPP_MAX_RQLEN
)paren
r_goto
id|drop
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|ppp-&gt;file.rq
comma
id|skb
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ppp-&gt;file.rwait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ppp-&gt;xmit_pending
op_assign
id|skb
suffix:semicolon
id|ppp_push
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
suffix:semicolon
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.tx_errors
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to send the frame in xmit_pending.&n; * The caller should have the xmit path locked.&n; */
r_static
r_void
DECL|function|ppp_push
id|ppp_push
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_struct
id|channel
op_star
id|pch
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|ppp-&gt;xmit_pending
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|list
op_assign
op_amp
id|ppp-&gt;channels
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|list
)paren
)paren
(brace
multiline_comment|/* nowhere to send the packet, just drop it */
id|ppp-&gt;xmit_pending
op_assign
l_int|0
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_MULTILINK
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* not doing multilink: send it down the first channel */
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|pch
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|channel
comma
id|clist
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;chan
)paren
(brace
r_if
c_cond
(paren
id|pch-&gt;chan-&gt;ops
op_member_access_from_pointer
id|start_xmit
c_func
(paren
id|pch-&gt;chan
comma
id|skb
)paren
)paren
id|ppp-&gt;xmit_pending
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* channel got unregistered */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp-&gt;xmit_pending
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPP_MULTILINK
multiline_comment|/* Multilink: fragment the packet over as many links&n;&t;   as can take the packet at the moment. */
r_if
c_cond
(paren
op_logical_neg
id|ppp_mp_explode
c_func
(paren
id|ppp
comma
id|skb
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_PPP_MULTILINK */
id|ppp-&gt;xmit_pending
op_assign
l_int|0
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPP_MULTILINK
multiline_comment|/*&n; * Divide a packet to be transmitted into fragments and&n; * send them out the individual links.&n; */
DECL|function|ppp_mp_explode
r_static
r_int
id|ppp_mp_explode
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|nch
comma
id|len
comma
id|fragsize
suffix:semicolon
r_int
id|i
comma
id|bits
comma
id|hdrlen
comma
id|mtu
suffix:semicolon
r_int
id|flen
comma
id|fnb
suffix:semicolon
r_int
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_struct
id|channel
op_star
id|pch
suffix:semicolon
r_struct
id|sk_buff
op_star
id|frag
suffix:semicolon
r_struct
id|ppp_channel
op_star
id|chan
suffix:semicolon
id|nch
op_assign
l_int|0
suffix:semicolon
id|hdrlen
op_assign
(paren
id|ppp-&gt;flags
op_amp
id|SC_MP_XSHORTSEQ
)paren
ques
c_cond
id|MPHDRLEN_SSN
suffix:colon
id|MPHDRLEN
suffix:semicolon
id|list
op_assign
op_amp
id|ppp-&gt;channels
suffix:semicolon
r_while
c_loop
(paren
(paren
id|list
op_assign
id|list-&gt;next
)paren
op_ne
op_amp
id|ppp-&gt;channels
)paren
(brace
id|pch
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|channel
comma
id|clist
)paren
suffix:semicolon
id|nch
op_add_assign
id|pch-&gt;avail
op_assign
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|pch-&gt;file.xq
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If a channel hasn&squot;t had a fragment yet, it has to get&n;&t;&t; * one before we send any fragments on later channels.&n;&t;&t; * If it can&squot;t take a fragment now, don&squot;t give any&n;&t;&t; * to subsequent channels.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pch-&gt;had_frag
op_logical_and
op_logical_neg
id|pch-&gt;avail
)paren
(brace
r_while
c_loop
(paren
(paren
id|list
op_assign
id|list-&gt;next
)paren
op_ne
op_amp
id|ppp-&gt;channels
)paren
(brace
id|pch
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|channel
comma
id|clist
)paren
suffix:semicolon
id|pch-&gt;avail
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nch
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* can&squot;t take now, leave it in xmit_pending */
multiline_comment|/* Do protocol field compression (XXX this should be optional) */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0
)paren
(brace
op_increment
id|p
suffix:semicolon
op_decrement
id|len
suffix:semicolon
)brace
multiline_comment|/* decide on fragment size */
id|fragsize
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|nch
OG
l_int|1
)paren
(brace
r_int
id|maxch
op_assign
id|ROUNDUP
c_func
(paren
id|len
comma
id|MIN_FRAG_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nch
OG
id|maxch
)paren
id|nch
op_assign
id|maxch
suffix:semicolon
id|fragsize
op_assign
id|ROUNDUP
c_func
(paren
id|fragsize
comma
id|nch
)paren
suffix:semicolon
)brace
multiline_comment|/* skip to the channel after the one we last used&n;&t;   and start at that one */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ppp-&gt;nxchan
suffix:semicolon
op_increment
id|i
)paren
(brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|ppp-&gt;channels
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* create a fragment for each channel */
id|bits
op_assign
id|B
suffix:semicolon
r_do
(brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
op_amp
id|ppp-&gt;channels
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pch
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|channel
comma
id|clist
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pch-&gt;avail
)paren
r_continue
suffix:semicolon
multiline_comment|/* check the channel&squot;s mtu and whether it is still attached. */
id|spin_lock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;chan
op_eq
l_int|0
op_logical_or
(paren
id|mtu
op_assign
id|pch-&gt;chan-&gt;mtu
)paren
OL
id|hdrlen
)paren
(brace
multiline_comment|/* can&squot;t use this channel */
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
id|pch-&gt;avail
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|nch
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We have to create multiple fragments for this channel&n;&t;&t; * if fragsize is greater than the channel&squot;s mtu.&n;&t;&t; */
r_if
c_cond
(paren
id|fragsize
OG
id|len
)paren
id|fragsize
op_assign
id|len
suffix:semicolon
r_for
c_loop
(paren
id|flen
op_assign
id|fragsize
suffix:semicolon
id|flen
OG
l_int|0
suffix:semicolon
id|flen
op_sub_assign
id|fnb
)paren
(brace
id|fnb
op_assign
id|flen
suffix:semicolon
r_if
c_cond
(paren
id|fnb
OG
id|mtu
op_plus
l_int|2
op_minus
id|hdrlen
)paren
id|fnb
op_assign
id|mtu
op_plus
l_int|2
op_minus
id|hdrlen
suffix:semicolon
r_if
c_cond
(paren
id|fnb
op_ge
id|len
)paren
id|bits
op_or_assign
id|E
suffix:semicolon
id|frag
op_assign
id|alloc_skb
c_func
(paren
id|fnb
op_plus
id|hdrlen
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag
op_eq
l_int|0
)paren
r_goto
id|noskb
suffix:semicolon
id|q
op_assign
id|skb_put
c_func
(paren
id|frag
comma
id|fnb
op_plus
id|hdrlen
)paren
suffix:semicolon
multiline_comment|/* make the MP header */
id|q
(braket
l_int|0
)braket
op_assign
id|PPP_MP
op_rshift
l_int|8
suffix:semicolon
id|q
(braket
l_int|1
)braket
op_assign
id|PPP_MP
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_MP_XSHORTSEQ
)paren
(brace
id|q
(braket
l_int|2
)braket
op_assign
id|bits
op_plus
(paren
(paren
id|ppp-&gt;nxseq
op_rshift
l_int|8
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|q
(braket
l_int|3
)braket
op_assign
id|ppp-&gt;nxseq
suffix:semicolon
)brace
r_else
(brace
id|q
(braket
l_int|2
)braket
op_assign
id|bits
suffix:semicolon
id|q
(braket
l_int|3
)braket
op_assign
id|ppp-&gt;nxseq
op_rshift
l_int|16
suffix:semicolon
id|q
(braket
l_int|4
)braket
op_assign
id|ppp-&gt;nxseq
op_rshift
l_int|8
suffix:semicolon
id|q
(braket
l_int|5
)braket
op_assign
id|ppp-&gt;nxseq
suffix:semicolon
)brace
multiline_comment|/* copy the data in */
id|memcpy
c_func
(paren
id|q
op_plus
id|hdrlen
comma
id|p
comma
id|fnb
)paren
suffix:semicolon
multiline_comment|/* try to send it down the channel */
id|chan
op_assign
id|pch-&gt;chan
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;ops
op_member_access_from_pointer
id|start_xmit
c_func
(paren
id|chan
comma
id|frag
)paren
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|pch-&gt;file.xq
comma
id|frag
)paren
suffix:semicolon
id|pch-&gt;had_frag
op_assign
l_int|1
suffix:semicolon
id|p
op_add_assign
id|fnb
suffix:semicolon
id|len
op_sub_assign
id|fnb
suffix:semicolon
op_increment
id|ppp-&gt;nxseq
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
id|ppp-&gt;nxchan
op_assign
id|i
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|noskb
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;debug
op_amp
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: no memory (fragment)&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.tx_errors
suffix:semicolon
op_increment
id|ppp-&gt;nxseq
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* abandon the frame */
)brace
macro_line|#endif /* CONFIG_PPP_MULTILINK */
multiline_comment|/*&n; * Try to send data out on a channel.&n; */
r_static
r_void
DECL|function|ppp_channel_push
id|ppp_channel_push
c_func
(paren
r_struct
id|channel
op_star
id|pch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;chan
op_ne
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|pch-&gt;file.xq
)paren
OG
l_int|0
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|pch-&gt;file.xq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pch-&gt;chan-&gt;ops
op_member_access_from_pointer
id|start_xmit
c_func
(paren
id|pch-&gt;chan
comma
id|skb
)paren
)paren
(brace
multiline_comment|/* put the packet back and try again later */
id|skb_queue_head
c_func
(paren
op_amp
id|pch-&gt;file.xq
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* channel got deregistered */
id|skb_queue_purge
c_func
(paren
op_amp
id|pch-&gt;file.xq
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
multiline_comment|/* see if there is anything from the attached unit to be sent */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|pch-&gt;file.xq
)paren
op_eq
l_int|0
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
id|ppp
op_assign
id|pch-&gt;ppp
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|0
)paren
id|ppp_xmit_process
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Receive-side routines.&n; */
multiline_comment|/* misuse a few fields of the skb for MP reconstruction */
DECL|macro|sequence
mdefine_line|#define sequence&t;priority
DECL|macro|BEbits
mdefine_line|#define BEbits&t;&t;cb[0]
r_static
r_inline
r_void
DECL|function|ppp_do_recv
id|ppp_do_recv
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|channel
op_star
id|pch
)paren
(brace
id|ppp_recv_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
multiline_comment|/* ppp-&gt;dev == 0 means interface is closing down */
r_if
c_cond
(paren
id|ppp-&gt;dev
op_ne
l_int|0
)paren
id|ppp_receive_frame
c_func
(paren
id|ppp
comma
id|skb
comma
id|pch
)paren
suffix:semicolon
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_recv_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
r_void
DECL|function|ppp_input
id|ppp_input
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_int
id|proto
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
op_logical_or
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|proto
op_assign
id|PPP_PROTO
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;ppp
op_eq
l_int|0
op_logical_or
id|proto
op_ge
l_int|0xc000
op_logical_or
id|proto
op_eq
id|PPP_CCPFRAG
)paren
(brace
multiline_comment|/* put it on the channel queue */
id|skb_queue_tail
c_func
(paren
op_amp
id|pch-&gt;file.rq
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* drop old frames if queue too long */
r_while
c_loop
(paren
id|pch-&gt;file.rq.qlen
OG
id|PPP_MAX_RQLEN
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|pch-&gt;file.rq
)paren
)paren
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pch-&gt;file.rwait
)paren
suffix:semicolon
)brace
r_else
(brace
id|ppp_do_recv
c_func
(paren
id|pch-&gt;ppp
comma
id|skb
comma
id|pch
)paren
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
)brace
multiline_comment|/* Put a 0-length skb in the receive queue as an error indication */
r_void
DECL|function|ppp_input_error
id|ppp_input_error
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
id|code
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;ppp
op_ne
l_int|0
)paren
(brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|0
)paren
(brace
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* probably unnecessary */
id|skb-&gt;cb
(braket
l_int|0
)braket
op_assign
id|code
suffix:semicolon
id|ppp_do_recv
c_func
(paren
id|pch-&gt;ppp
comma
id|skb
comma
id|pch
)paren
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We come in here to process a received frame.&n; * The receive side of the ppp unit is locked.&n; */
r_static
r_void
DECL|function|ppp_receive_frame
id|ppp_receive_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|channel
op_star
id|pch
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
l_int|2
)paren
(brace
macro_line|#ifdef CONFIG_PPP_MULTILINK
multiline_comment|/* XXX do channel-level decompression here */
r_if
c_cond
(paren
id|PPP_PROTO
c_func
(paren
id|skb
)paren
op_eq
id|PPP_MP
)paren
id|ppp_receive_mp_frame
c_func
(paren
id|ppp
comma
id|skb
comma
id|pch
)paren
suffix:semicolon
r_else
macro_line|#endif /* CONFIG_PPP_MULTILINK */
id|ppp_receive_nonmp_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
multiline_comment|/* note: a 0-length skb is used as an error indication */
op_increment
id|ppp-&gt;stats.rx_length_errors
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_receive_error
id|ppp_receive_error
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
op_increment
id|ppp-&gt;stats.rx_errors
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;vj
op_ne
l_int|0
)paren
id|slhc_toss
c_func
(paren
id|ppp-&gt;vj
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_receive_nonmp_frame
id|ppp_receive_nonmp_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|ns
suffix:semicolon
r_int
id|proto
comma
id|len
comma
id|npi
suffix:semicolon
multiline_comment|/*&n;&t; * Decompress the frame, if compressed.&n;&t; * Note that some decompressors need to see uncompressed frames&n;&t; * that come in as well as compressed frames.&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;rc_state
op_ne
l_int|0
op_logical_and
(paren
id|ppp-&gt;rstate
op_amp
id|SC_DECOMP_RUN
)paren
op_logical_and
(paren
id|ppp-&gt;rstate
op_amp
(paren
id|SC_DC_FERROR
op_or
id|SC_DC_ERROR
)paren
)paren
op_eq
l_int|0
)paren
id|skb
op_assign
id|ppp_decompress_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
id|proto
op_assign
id|PPP_PROTO
c_func
(paren
id|skb
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|PPP_VJC_COMP
suffix:colon
multiline_comment|/* decompress VJ compressed packets */
r_if
c_cond
(paren
id|ppp-&gt;vj
op_eq
l_int|0
op_logical_or
(paren
id|ppp-&gt;flags
op_amp
id|SC_REJ_COMP_TCP
)paren
)paren
r_goto
id|err
suffix:semicolon
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|skb
)paren
OL
l_int|124
)paren
(brace
multiline_comment|/* copy to a new sk_buff with more tailroom */
id|ns
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ns
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: no memory (VJ decomp)&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|ns
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|ns
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|ns
suffix:semicolon
)brace
id|len
op_assign
id|slhc_uncompress
c_func
(paren
id|ppp-&gt;vj
comma
id|skb-&gt;data
op_plus
l_int|2
comma
id|skb-&gt;len
op_minus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;PPP: VJ decompression error&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|len
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|skb-&gt;len
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
op_minus
id|skb-&gt;len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|len
OL
id|skb-&gt;len
)paren
id|skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|proto
op_assign
id|PPP_IP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPP_VJC_UNCOMP
suffix:colon
r_if
c_cond
(paren
id|ppp-&gt;vj
op_eq
l_int|0
op_logical_or
(paren
id|ppp-&gt;flags
op_amp
id|SC_REJ_COMP_TCP
)paren
)paren
r_goto
id|err
suffix:semicolon
r_if
c_cond
(paren
id|slhc_remember
c_func
(paren
id|ppp-&gt;vj
comma
id|skb-&gt;data
op_plus
l_int|2
comma
id|skb-&gt;len
op_minus
l_int|2
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: VJ uncompressed error&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|proto
op_assign
id|PPP_IP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPP_CCP
suffix:colon
id|ppp_ccp_peek
c_func
(paren
id|ppp
comma
id|skb
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|ppp-&gt;stats.rx_packets
suffix:semicolon
id|ppp-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
op_minus
l_int|2
suffix:semicolon
id|npi
op_assign
id|proto_to_npindex
c_func
(paren
id|proto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|npi
OL
l_int|0
)paren
(brace
multiline_comment|/* control or unknown frame - pass it to pppd */
id|skb_queue_tail
c_func
(paren
op_amp
id|ppp-&gt;file.rq
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* limit queue length by dropping old frames */
r_while
c_loop
(paren
id|ppp-&gt;file.rq.qlen
OG
id|PPP_MAX_RQLEN
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ppp-&gt;file.rq
)paren
)paren
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* wake up any process polling or blocking on read */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ppp-&gt;file.rwait
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* network protocol frame - give it to the kernel */
id|ppp-&gt;last_recv
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppp-&gt;dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
l_int|0
op_logical_or
id|ppp-&gt;npmode
(braket
id|npi
)braket
op_ne
id|NPMODE_PASS
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* chop off protocol */
id|skb-&gt;dev
op_assign
id|ppp-&gt;dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|npindex_to_ethertype
(braket
id|npi
)braket
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
id|err
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|ppp_decompress_frame
id|ppp_decompress_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|proto
op_assign
id|PPP_PROTO
c_func
(paren
id|skb
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|ns
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_eq
id|PPP_COMP
)paren
(brace
id|ns
op_assign
id|dev_alloc_skb
c_func
(paren
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ns
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_decompress_frame: no memory&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* the decompressor still expects the A/C bytes in the hdr */
id|len
op_assign
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|decompress
c_func
(paren
id|ppp-&gt;rc_state
comma
id|skb-&gt;data
op_minus
l_int|2
comma
id|skb-&gt;len
op_plus
l_int|2
comma
id|ns-&gt;data
comma
id|ppp-&gt;mru
op_plus
id|PPP_HDRLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
multiline_comment|/* Pass the compressed frame to pppd as an&n;&t;&t;&t;   error indication. */
r_if
c_cond
(paren
id|len
op_eq
id|DECOMP_FATALERROR
)paren
id|ppp-&gt;rstate
op_or_assign
id|SC_DC_FERROR
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|ns
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* pull off the A/C bytes */
)brace
r_else
(brace
multiline_comment|/* Uncompressed frame - pass to decompressor so it&n;&t;&t;   can update its dictionary if necessary. */
r_if
c_cond
(paren
id|ppp-&gt;rcomp-&gt;incomp
)paren
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|incomp
c_func
(paren
id|ppp-&gt;rc_state
comma
id|skb-&gt;data
op_minus
l_int|2
comma
id|skb-&gt;len
op_plus
l_int|2
)paren
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
id|err
suffix:colon
id|ppp-&gt;rstate
op_or_assign
id|SC_DC_ERROR
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PPP_MULTILINK
multiline_comment|/*&n; * Receive a multilink frame.&n; * We put it on the reconstruction queue and then pull off&n; * as many completed frames as we can.&n; */
r_static
r_void
DECL|function|ppp_receive_mp_frame
id|ppp_receive_mp_frame
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|channel
op_star
id|pch
)paren
(brace
id|u32
id|mask
comma
id|seq
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
id|mphdrlen
op_assign
(paren
id|ppp-&gt;flags
op_amp
id|SC_MP_SHORTSEQ
)paren
ques
c_cond
id|MPHDRLEN_SSN
suffix:colon
id|MPHDRLEN
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|mphdrlen
op_plus
l_int|1
op_logical_or
id|ppp-&gt;mrru
op_eq
l_int|0
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* no good, throw it away */
multiline_comment|/* Decode sequence number and begin/end bits */
r_if
c_cond
(paren
id|ppp-&gt;flags
op_amp
id|SC_MP_SHORTSEQ
)paren
(brace
id|seq
op_assign
(paren
(paren
id|skb-&gt;data
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
l_int|3
)braket
suffix:semicolon
id|mask
op_assign
l_int|0xfff
suffix:semicolon
)brace
r_else
(brace
id|seq
op_assign
(paren
id|skb-&gt;data
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|skb-&gt;data
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
l_int|5
)braket
suffix:semicolon
id|mask
op_assign
l_int|0xffffff
suffix:semicolon
)brace
id|skb-&gt;BEbits
op_assign
id|skb-&gt;data
(braket
l_int|2
)braket
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|mphdrlen
)paren
suffix:semicolon
multiline_comment|/* pull off PPP and MP headers */
multiline_comment|/*&n;&t; * Do protocol ID decompression on the first fragment of each packet.&n;&t; */
r_if
c_cond
(paren
(paren
id|skb-&gt;BEbits
op_amp
id|B
)paren
op_logical_and
(paren
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
op_star
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Expand sequence number to 32 bits, making it as close&n;&t; * as possible to ppp-&gt;minseq.&n;&t; */
id|seq
op_or_assign
id|ppp-&gt;minseq
op_amp
op_complement
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|ppp-&gt;minseq
op_minus
id|seq
)paren
OG
(paren
r_int
)paren
(paren
id|mask
op_rshift
l_int|1
)paren
)paren
id|seq
op_add_assign
id|mask
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|seq
op_minus
id|ppp-&gt;minseq
)paren
OG
(paren
r_int
)paren
(paren
id|mask
op_rshift
l_int|1
)paren
)paren
id|seq
op_sub_assign
id|mask
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* should never happen */
id|skb-&gt;sequence
op_assign
id|seq
suffix:semicolon
id|pch-&gt;lastseq
op_assign
id|seq
suffix:semicolon
multiline_comment|/*&n;&t; * If this packet comes before the next one we were expecting,&n;&t; * drop it.&n;&t; */
r_if
c_cond
(paren
id|seq_before
c_func
(paren
id|seq
comma
id|ppp-&gt;nextseq
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.rx_dropped
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reevaluate minseq, the minimum over all channels of the&n;&t; * last sequence number received on each channel.  Because of&n;&t; * the increasing sequence number rule, we know that any fragment&n;&t; * before `minseq&squot; which hasn&squot;t arrived is never going to arrive.&n;&t; * The list of channels can&squot;t change because we have the receive&n;&t; * side of the ppp unit locked.&n;&t; */
r_for
c_loop
(paren
id|l
op_assign
id|ppp-&gt;channels.next
suffix:semicolon
id|l
op_ne
op_amp
id|ppp-&gt;channels
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
(brace
r_struct
id|channel
op_star
id|ch
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|channel
comma
id|clist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seq_before
c_func
(paren
id|ch-&gt;lastseq
comma
id|seq
)paren
)paren
id|seq
op_assign
id|ch-&gt;lastseq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seq_before
c_func
(paren
id|ppp-&gt;minseq
comma
id|seq
)paren
)paren
id|ppp-&gt;minseq
op_assign
id|seq
suffix:semicolon
multiline_comment|/* Put the fragment on the reconstruction queue */
id|ppp_mp_insert
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* If the queue is getting long, don&squot;t wait any longer for packets&n;&t;   before the start of the queue. */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|ppp-&gt;mrq
)paren
op_ge
id|PPP_MP_MAX_QLEN
op_logical_and
id|seq_before
c_func
(paren
id|ppp-&gt;minseq
comma
id|ppp-&gt;mrq.next-&gt;sequence
)paren
)paren
id|ppp-&gt;minseq
op_assign
id|ppp-&gt;mrq.next-&gt;sequence
suffix:semicolon
multiline_comment|/* Pull completed packets off the queue and receive them. */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|ppp_mp_reconstruct
c_func
(paren
id|ppp
)paren
)paren
op_ne
l_int|0
)paren
id|ppp_receive_nonmp_frame
c_func
(paren
id|ppp
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a fragment on the MP reconstruction queue.&n; * The queue is ordered by increasing sequence number.&n; */
r_static
r_void
DECL|function|ppp_mp_insert
id|ppp_mp_insert
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|p
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
op_amp
id|ppp-&gt;mrq
suffix:semicolon
id|u32
id|seq
op_assign
id|skb-&gt;sequence
suffix:semicolon
multiline_comment|/* N.B. we don&squot;t need to lock the list lock because we have the&n;&t;   ppp unit receive-side lock. */
r_for
c_loop
(paren
id|p
op_assign
id|list-&gt;next
suffix:semicolon
id|p
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
r_if
c_cond
(paren
id|seq_before
c_func
(paren
id|seq
comma
id|p-&gt;sequence
)paren
)paren
r_break
suffix:semicolon
id|__skb_insert
c_func
(paren
id|skb
comma
id|p-&gt;prev
comma
id|p
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reconstruct a packet from the MP fragment queue.&n; * We go through increasing sequence numbers until we find a&n; * complete packet, or we get to the sequence number for a fragment&n; * which hasn&squot;t arrived but might still do so.&n; */
r_struct
id|sk_buff
op_star
DECL|function|ppp_mp_reconstruct
id|ppp_mp_reconstruct
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|u32
id|seq
op_assign
id|ppp-&gt;nextseq
suffix:semicolon
id|u32
id|minseq
op_assign
id|ppp-&gt;minseq
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
op_amp
id|ppp-&gt;mrq
suffix:semicolon
r_struct
id|sk_buff
op_star
id|p
comma
op_star
id|next
suffix:semicolon
r_struct
id|sk_buff
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|lost
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;mrru
op_eq
l_int|0
)paren
multiline_comment|/* do nothing until mrru is set */
r_return
l_int|NULL
suffix:semicolon
id|head
op_assign
id|list-&gt;next
suffix:semicolon
id|tail
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|head
suffix:semicolon
id|p
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|p
op_assign
id|next
)paren
(brace
id|next
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|seq_before
c_func
(paren
id|p-&gt;sequence
comma
id|seq
)paren
)paren
(brace
multiline_comment|/* this can&squot;t happen, anyway ignore the skb */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppp_mp_reconstruct bad seq %u &lt; %u&bslash;n&quot;
comma
id|p-&gt;sequence
comma
id|seq
)paren
suffix:semicolon
id|head
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;sequence
op_ne
id|seq
)paren
(brace
multiline_comment|/* Fragment `seq&squot; is missing.  If it is after&n;&t;&t;&t;   minseq, it might arrive later, so stop here. */
r_if
c_cond
(paren
id|seq_after
c_func
(paren
id|seq
comma
id|minseq
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Fragment `seq&squot; is lost, keep going. */
id|lost
op_assign
l_int|1
suffix:semicolon
id|seq
op_assign
id|seq_before
c_func
(paren
id|minseq
comma
id|p-&gt;sequence
)paren
ques
c_cond
id|minseq
op_plus
l_int|1
suffix:colon
id|p-&gt;sequence
suffix:semicolon
id|next
op_assign
id|p
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * At this point we know that all the fragments from&n;&t;&t; * ppp-&gt;nextseq to seq are either present or lost.&n;&t;&t; * Also, there are no complete packets in the queue&n;&t;&t; * that have no missing fragments and end before this&n;&t;&t; * fragment.&n;&t;&t; */
multiline_comment|/* B bit set indicates this fragment starts a packet */
r_if
c_cond
(paren
id|p-&gt;BEbits
op_amp
id|B
)paren
(brace
id|head
op_assign
id|p
suffix:semicolon
id|lost
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
id|len
op_add_assign
id|p-&gt;len
suffix:semicolon
multiline_comment|/* Got a complete packet yet? */
r_if
c_cond
(paren
id|lost
op_eq
l_int|0
op_logical_and
(paren
id|p-&gt;BEbits
op_amp
id|E
)paren
op_logical_and
(paren
id|head-&gt;BEbits
op_amp
id|B
)paren
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|ppp-&gt;mrru
op_plus
l_int|2
)paren
(brace
op_increment
id|ppp-&gt;stats.rx_length_errors
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;PPP: reconstructed packet&quot;
l_string|&quot; is too long (%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
op_eq
id|head
)paren
(brace
multiline_comment|/* fragment is complete packet - reuse skb */
id|tail
op_assign
id|p
suffix:semicolon
id|skb
op_assign
id|skb_get
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
op_increment
id|ppp-&gt;stats.rx_missed_errors
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;PPP: no memory for &quot;
l_string|&quot;reconstructed packet&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|tail
op_assign
id|p
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ppp-&gt;nextseq
op_assign
id|seq
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If this is the ending fragment of a packet,&n;&t;&t; * and we haven&squot;t found a complete valid packet yet,&n;&t;&t; * we can discard up to and including this fragment.&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;BEbits
op_amp
id|E
)paren
id|head
op_assign
id|next
suffix:semicolon
op_increment
id|seq
suffix:semicolon
)brace
multiline_comment|/* If we have a complete packet, copy it all into one skb. */
r_if
c_cond
(paren
id|tail
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If we have discarded any fragments,&n;&t;&t;   signal a receive error. */
r_if
c_cond
(paren
id|head-&gt;sequence
op_ne
id|ppp-&gt;nextseq
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;debug
op_amp
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  missed pkts %u..%u&bslash;n&quot;
comma
id|ppp-&gt;nextseq
comma
id|head-&gt;sequence
op_minus
l_int|1
)paren
suffix:semicolon
op_increment
id|ppp-&gt;stats.rx_dropped
suffix:semicolon
id|ppp_receive_error
c_func
(paren
id|ppp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|head
op_ne
id|tail
)paren
multiline_comment|/* copy to a single skb */
r_for
c_loop
(paren
id|p
op_assign
id|head
suffix:semicolon
id|p
op_ne
id|tail-&gt;next
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|p-&gt;len
)paren
comma
id|p-&gt;data
comma
id|p-&gt;len
)paren
suffix:semicolon
id|ppp-&gt;nextseq
op_assign
id|tail-&gt;sequence
op_plus
l_int|1
suffix:semicolon
id|head
op_assign
id|tail-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Discard all the skbuffs that we have copied the data out of&n;&t;   or that we can&squot;t use. */
r_while
c_loop
(paren
(paren
id|p
op_assign
id|list-&gt;next
)paren
op_ne
id|head
)paren
(brace
id|__skb_unlink
c_func
(paren
id|p
comma
id|list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PPP_MULTILINK */
multiline_comment|/*&n; * Channel interface.&n; */
multiline_comment|/*&n; * Create a new, unattached ppp channel.&n; */
r_int
DECL|function|ppp_register_channel
id|ppp_register_channel
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
)paren
(brace
r_struct
id|channel
op_star
id|pch
suffix:semicolon
id|pch
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|channel
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|pch
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|channel
)paren
)paren
suffix:semicolon
id|pch-&gt;ppp
op_assign
l_int|NULL
suffix:semicolon
id|pch-&gt;chan
op_assign
id|chan
suffix:semicolon
id|chan-&gt;ppp
op_assign
id|pch
suffix:semicolon
id|init_ppp_file
c_func
(paren
op_amp
id|pch-&gt;file
comma
id|CHANNEL
)paren
suffix:semicolon
id|pch-&gt;file.hdrlen
op_assign
id|chan-&gt;hdrlen
suffix:semicolon
macro_line|#ifdef CONFIG_PPP_MULTILINK
id|pch-&gt;lastseq
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_PPP_MULTILINK */
id|spin_lock_init
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
id|pch-&gt;upl
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|all_channels_lock
)paren
suffix:semicolon
id|pch-&gt;file.index
op_assign
op_increment
id|last_channel_index
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pch-&gt;file.list
comma
op_amp
id|all_channels
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|all_channels_lock
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the index of a channel.&n; */
DECL|function|ppp_channel_index
r_int
id|ppp_channel_index
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_return
id|pch-&gt;file.index
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the PPP unit number to which a channel is connected.&n; */
DECL|function|ppp_unit_number
r_int
id|ppp_unit_number
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_int
id|unit
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_ne
l_int|0
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;ppp
op_ne
l_int|0
)paren
id|unit
op_assign
id|pch-&gt;ppp-&gt;file.index
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
)brace
r_return
id|unit
suffix:semicolon
)brace
multiline_comment|/*&n; * Disconnect a channel from the generic layer.&n; * This can be called from mainline or BH/softirq level.&n; */
r_void
DECL|function|ppp_unregister_channel
id|ppp_unregister_channel
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* should never happen */
id|chan-&gt;ppp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This ensures that we have returned from any calls into the&n;&t; * the channel&squot;s start_xmit or ioctl routine before we proceed.&n;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
id|pch-&gt;chan
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
id|ppp_disconnect_channel
c_func
(paren
id|pch
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pch-&gt;file.rwait
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|all_channels_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pch-&gt;file.list
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|all_channels_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pch-&gt;file.refcnt
)paren
)paren
id|ppp_destroy_channel
c_func
(paren
id|pch
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Callback from a channel when it can accept more to transmit.&n; * This should be called at BH/softirq level, not interrupt level.&n; */
r_void
DECL|function|ppp_output_wakeup
id|ppp_output_wakeup
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|ppp_channel_push
c_func
(paren
id|pch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is basically temporary compatibility stuff.&n; */
id|ssize_t
DECL|function|ppp_channel_read
id|ppp_channel_read
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|ppp_file_read
c_func
(paren
op_amp
id|pch-&gt;file
comma
id|file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
id|ssize_t
DECL|function|ppp_channel_write
id|ppp_channel_write
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|ppp_file_write
c_func
(paren
op_amp
id|pch-&gt;file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - fine */
r_int
r_int
DECL|function|ppp_channel_poll
id|ppp_channel_poll
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
id|mask
op_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_ne
l_int|0
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|pch-&gt;file.rwait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|pch-&gt;file.rq
)paren
op_ne
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
DECL|function|ppp_channel_ioctl
r_int
id|ppp_channel_ioctl
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|channel
op_star
id|pch
op_assign
id|chan-&gt;ppp
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOTTY
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pch
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCATTACH
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|unit
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
id|ppp_connect_channel
c_func
(paren
id|pch
comma
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCDETACH
suffix:colon
id|err
op_assign
id|ppp_disconnect_channel
c_func
(paren
id|pch
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Compression control.&n; */
multiline_comment|/* Process the PPPIOCSCOMPRESS ioctl. */
r_static
r_int
DECL|function|ppp_set_compress
id|ppp_set_compress
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|compressor
op_star
id|cp
suffix:semicolon
r_struct
id|ppp_option_data
id|data
suffix:semicolon
r_void
op_star
id|state
suffix:semicolon
r_int
r_char
id|ccp_option
(braket
id|CCP_MAX_OPTION_LENGTH
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_char
id|modname
(braket
l_int|32
)braket
suffix:semicolon
macro_line|#endif
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|data
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|data
)paren
)paren
op_logical_or
(paren
id|data.length
op_le
id|CCP_MAX_OPTION_LENGTH
op_logical_and
id|copy_from_user
c_func
(paren
id|ccp_option
comma
id|data.ptr
comma
id|data.length
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|data.length
OG
id|CCP_MAX_OPTION_LENGTH
op_logical_or
id|ccp_option
(braket
l_int|1
)braket
template_param
id|data.length
)paren
r_goto
id|out
suffix:semicolon
id|cp
op_assign
id|find_compressor
c_func
(paren
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|cp
op_eq
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|modname
comma
l_string|&quot;ppp-compress-%d&quot;
comma
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|request_module
c_func
(paren
id|modname
)paren
suffix:semicolon
id|cp
op_assign
id|find_compressor
c_func
(paren
id|ccp_option
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KMOD */
r_if
c_cond
(paren
id|cp
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|data.transmit
)paren
(brace
id|ppp_xmit_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;xstate
op_and_assign
op_complement
id|SC_COMP_RUN
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;xc_state
op_ne
l_int|0
)paren
(brace
id|ppp-&gt;xcomp
op_member_access_from_pointer
id|comp_free
c_func
(paren
id|ppp-&gt;xc_state
)paren
suffix:semicolon
id|ppp-&gt;xc_state
op_assign
l_int|0
suffix:semicolon
)brace
id|ppp_xmit_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|state
op_assign
id|cp
op_member_access_from_pointer
id|comp_alloc
c_func
(paren
id|ccp_option
comma
id|data.length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
l_int|0
)paren
(brace
id|ppp_xmit_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;xcomp
op_assign
id|cp
suffix:semicolon
id|ppp-&gt;xc_state
op_assign
id|state
suffix:semicolon
id|ppp_xmit_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|ppp_recv_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;rstate
op_and_assign
op_complement
id|SC_DECOMP_RUN
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;rc_state
op_ne
l_int|0
)paren
(brace
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|decomp_free
c_func
(paren
id|ppp-&gt;rc_state
)paren
suffix:semicolon
id|ppp-&gt;rc_state
op_assign
l_int|0
suffix:semicolon
)brace
id|ppp_recv_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|state
op_assign
id|cp
op_member_access_from_pointer
id|decomp_alloc
c_func
(paren
id|ccp_option
comma
id|data.length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
l_int|0
)paren
(brace
id|ppp_recv_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp-&gt;rcomp
op_assign
id|cp
suffix:semicolon
id|ppp-&gt;rc_state
op_assign
id|state
suffix:semicolon
id|ppp_recv_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Look at a CCP packet and update our state accordingly.&n; * We assume the caller has the xmit or recv path locked.&n; */
r_static
r_void
DECL|function|ppp_ccp_peek
id|ppp_ccp_peek
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|inbound
)paren
(brace
r_int
r_char
op_star
id|dp
op_assign
id|skb-&gt;data
op_plus
l_int|2
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|CCP_HDRLEN
op_plus
l_int|2
op_logical_or
id|skb-&gt;len
OL
(paren
id|len
op_assign
id|CCP_LENGTH
c_func
(paren
id|dp
)paren
)paren
op_plus
l_int|2
)paren
r_return
suffix:semicolon
multiline_comment|/* too short */
r_switch
c_cond
(paren
id|CCP_CODE
c_func
(paren
id|dp
)paren
)paren
(brace
r_case
id|CCP_CONFREQ
suffix:colon
r_case
id|CCP_TERMREQ
suffix:colon
r_case
id|CCP_TERMACK
suffix:colon
multiline_comment|/*&n;&t;&t; * CCP is going down - disable compression.&n;&t;&t; */
r_if
c_cond
(paren
id|inbound
)paren
id|ppp-&gt;rstate
op_and_assign
op_complement
id|SC_DECOMP_RUN
suffix:semicolon
r_else
id|ppp-&gt;xstate
op_and_assign
op_complement
id|SC_COMP_RUN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CCP_CONFACK
suffix:colon
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
(paren
id|SC_CCP_OPEN
op_or
id|SC_CCP_UP
)paren
)paren
op_ne
id|SC_CCP_OPEN
)paren
r_break
suffix:semicolon
id|dp
op_add_assign
id|CCP_HDRLEN
suffix:semicolon
id|len
op_sub_assign
id|CCP_HDRLEN
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|CCP_OPT_MINLEN
op_logical_or
id|len
OL
id|CCP_OPT_LENGTH
c_func
(paren
id|dp
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|inbound
)paren
(brace
multiline_comment|/* we will start receiving compressed packets */
r_if
c_cond
(paren
id|ppp-&gt;rc_state
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|decomp_init
c_func
(paren
id|ppp-&gt;rc_state
comma
id|dp
comma
id|len
comma
id|ppp-&gt;file.index
comma
l_int|0
comma
id|ppp-&gt;mru
comma
id|ppp-&gt;debug
)paren
)paren
(brace
id|ppp-&gt;rstate
op_or_assign
id|SC_DECOMP_RUN
suffix:semicolon
id|ppp-&gt;rstate
op_and_assign
op_complement
(paren
id|SC_DC_ERROR
op_or
id|SC_DC_FERROR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we will soon start sending compressed packets */
r_if
c_cond
(paren
id|ppp-&gt;xc_state
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;xcomp
op_member_access_from_pointer
id|comp_init
c_func
(paren
id|ppp-&gt;xc_state
comma
id|dp
comma
id|len
comma
id|ppp-&gt;file.index
comma
l_int|0
comma
id|ppp-&gt;debug
)paren
)paren
id|ppp-&gt;xstate
op_or_assign
id|SC_COMP_RUN
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CCP_RESETACK
suffix:colon
multiline_comment|/* reset the [de]compressor */
r_if
c_cond
(paren
(paren
id|ppp-&gt;flags
op_amp
id|SC_CCP_UP
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|inbound
)paren
(brace
r_if
c_cond
(paren
id|ppp-&gt;rc_state
op_logical_and
(paren
id|ppp-&gt;rstate
op_amp
id|SC_DECOMP_RUN
)paren
)paren
(brace
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|decomp_reset
c_func
(paren
id|ppp-&gt;rc_state
)paren
suffix:semicolon
id|ppp-&gt;rstate
op_and_assign
op_complement
id|SC_DC_ERROR
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ppp-&gt;xc_state
op_logical_and
(paren
id|ppp-&gt;xstate
op_amp
id|SC_COMP_RUN
)paren
)paren
id|ppp-&gt;xcomp
op_member_access_from_pointer
id|comp_reset
c_func
(paren
id|ppp-&gt;xc_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Free up compression resources. */
r_static
r_void
DECL|function|ppp_ccp_closed
id|ppp_ccp_closed
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
id|ppp-&gt;flags
op_and_assign
op_complement
(paren
id|SC_CCP_OPEN
op_or
id|SC_CCP_UP
)paren
suffix:semicolon
id|ppp-&gt;xstate
op_and_assign
op_complement
id|SC_COMP_RUN
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;xc_state
)paren
(brace
id|ppp-&gt;xcomp
op_member_access_from_pointer
id|comp_free
c_func
(paren
id|ppp-&gt;xc_state
)paren
suffix:semicolon
id|ppp-&gt;xc_state
op_assign
l_int|0
suffix:semicolon
)brace
id|ppp-&gt;xstate
op_and_assign
op_complement
id|SC_DECOMP_RUN
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;rc_state
)paren
(brace
id|ppp-&gt;rcomp
op_member_access_from_pointer
id|decomp_free
c_func
(paren
id|ppp-&gt;rc_state
)paren
suffix:semicolon
id|ppp-&gt;rc_state
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* List of compressors. */
r_static
id|LIST_HEAD
c_func
(paren
id|compressor_list
)paren
suffix:semicolon
DECL|variable|compressor_list_lock
r_static
id|spinlock_t
id|compressor_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|struct|compressor_entry
r_struct
id|compressor_entry
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|comp
r_struct
id|compressor
op_star
id|comp
suffix:semicolon
)brace
suffix:semicolon
r_static
r_struct
id|compressor_entry
op_star
DECL|function|find_comp_entry
id|find_comp_entry
c_func
(paren
r_int
id|proto
)paren
(brace
r_struct
id|compressor_entry
op_star
id|ce
suffix:semicolon
r_struct
id|list_head
op_star
id|list
op_assign
op_amp
id|compressor_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|list
op_assign
id|list-&gt;next
)paren
op_ne
op_amp
id|compressor_list
)paren
(brace
id|ce
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|compressor_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;comp-&gt;compress_proto
op_eq
id|proto
)paren
r_return
id|ce
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Register a compressor */
r_int
DECL|function|ppp_register_compressor
id|ppp_register_compressor
c_func
(paren
r_struct
id|compressor
op_star
id|cp
)paren
(brace
r_struct
id|compressor_entry
op_star
id|ce
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|compressor_list_lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|find_comp_entry
c_func
(paren
id|cp-&gt;compress_proto
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ce
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|compressor_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|ce-&gt;comp
op_assign
id|cp
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|ce-&gt;list
comma
op_amp
id|compressor_list
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|compressor_list_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Unregister a compressor */
r_void
DECL|function|ppp_unregister_compressor
id|ppp_unregister_compressor
c_func
(paren
r_struct
id|compressor
op_star
id|cp
)paren
(brace
r_struct
id|compressor_entry
op_star
id|ce
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|compressor_list_lock
)paren
suffix:semicolon
id|ce
op_assign
id|find_comp_entry
c_func
(paren
id|cp-&gt;compress_proto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
op_ne
l_int|0
op_logical_and
id|ce-&gt;comp
op_eq
id|cp
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|ce-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ce
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|compressor_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Find a compressor. */
r_static
r_struct
id|compressor
op_star
DECL|function|find_compressor
id|find_compressor
c_func
(paren
r_int
id|type
)paren
(brace
r_struct
id|compressor_entry
op_star
id|ce
suffix:semicolon
r_struct
id|compressor
op_star
id|cp
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|compressor_list_lock
)paren
suffix:semicolon
id|ce
op_assign
id|find_comp_entry
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
op_ne
l_int|0
)paren
id|cp
op_assign
id|ce-&gt;comp
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|compressor_list_lock
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*&n; * Miscelleneous stuff.&n; */
r_static
r_void
DECL|function|ppp_get_stats
id|ppp_get_stats
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
comma
r_struct
id|ppp_stats
op_star
id|st
)paren
(brace
r_struct
id|slcompress
op_star
id|vj
op_assign
id|ppp-&gt;vj
suffix:semicolon
id|memset
c_func
(paren
id|st
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|st
)paren
)paren
suffix:semicolon
id|st-&gt;p.ppp_ipackets
op_assign
id|ppp-&gt;stats.rx_packets
suffix:semicolon
id|st-&gt;p.ppp_ierrors
op_assign
id|ppp-&gt;stats.rx_errors
suffix:semicolon
id|st-&gt;p.ppp_ibytes
op_assign
id|ppp-&gt;stats.rx_bytes
suffix:semicolon
id|st-&gt;p.ppp_opackets
op_assign
id|ppp-&gt;stats.tx_packets
suffix:semicolon
id|st-&gt;p.ppp_oerrors
op_assign
id|ppp-&gt;stats.tx_errors
suffix:semicolon
id|st-&gt;p.ppp_obytes
op_assign
id|ppp-&gt;stats.tx_bytes
suffix:semicolon
r_if
c_cond
(paren
id|vj
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|st-&gt;vj.vjs_packets
op_assign
id|vj-&gt;sls_o_compressed
op_plus
id|vj-&gt;sls_o_uncompressed
suffix:semicolon
id|st-&gt;vj.vjs_compressed
op_assign
id|vj-&gt;sls_o_compressed
suffix:semicolon
id|st-&gt;vj.vjs_searches
op_assign
id|vj-&gt;sls_o_searches
suffix:semicolon
id|st-&gt;vj.vjs_misses
op_assign
id|vj-&gt;sls_o_misses
suffix:semicolon
id|st-&gt;vj.vjs_errorin
op_assign
id|vj-&gt;sls_i_error
suffix:semicolon
id|st-&gt;vj.vjs_tossed
op_assign
id|vj-&gt;sls_i_tossed
suffix:semicolon
id|st-&gt;vj.vjs_uncompressedin
op_assign
id|vj-&gt;sls_i_uncompressed
suffix:semicolon
id|st-&gt;vj.vjs_compressedin
op_assign
id|vj-&gt;sls_i_compressed
suffix:semicolon
)brace
multiline_comment|/*&n; * Stuff for handling the lists of ppp units and channels&n; * and for initialization.&n; */
multiline_comment|/*&n; * Create a new ppp interface unit.  Fails if it can&squot;t allocate memory&n; * or if there is already a unit with the requested number.&n; * unit == -1 means allocate a new number.&n; */
r_static
r_struct
id|ppp
op_star
DECL|function|ppp_create_interface
id|ppp_create_interface
c_func
(paren
r_int
id|unit
comma
r_int
op_star
id|retp
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_int
id|last_unit
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
id|list
op_assign
op_amp
id|all_ppp_units
suffix:semicolon
r_while
c_loop
(paren
(paren
id|list
op_assign
id|list-&gt;next
)paren
op_ne
op_amp
id|all_ppp_units
)paren
(brace
id|ppp
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|ppp
comma
id|file.list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit
template_param
id|last_unit
op_plus
l_int|1
)paren
op_logical_or
(paren
id|unit
op_ge
l_int|0
op_logical_and
id|unit
OL
id|ppp-&gt;file.index
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_eq
id|ppp-&gt;file.index
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* unit already exists */
id|last_unit
op_assign
id|ppp-&gt;file.index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
OL
l_int|0
)paren
id|unit
op_assign
id|last_unit
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Create a new ppp structure and link it before `list&squot;. */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ppp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ppp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|ppp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ppp
)paren
)paren
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|ppp-&gt;file.index
op_assign
id|unit
suffix:semicolon
id|ppp-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|init_ppp_file
c_func
(paren
op_amp
id|ppp-&gt;file
comma
id|INTERFACE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_NP
suffix:semicolon
op_increment
id|i
)paren
id|ppp-&gt;npmode
(braket
id|i
)braket
op_assign
id|NPMODE_PASS
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ppp-&gt;channels
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ppp-&gt;rlock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ppp-&gt;wlock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPP_MULTILINK
id|ppp-&gt;minseq
op_assign
op_minus
l_int|1
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ppp-&gt;mrq
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPP_MULTILINK */
id|ppp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev-&gt;init
op_assign
id|ppp_net_init
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;ppp%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|ppp
suffix:semicolon
id|dev-&gt;features
op_or_assign
id|NETIF_F_DYNALLOC
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|register_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: couldn&squot;t register device (%d)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|ppp-&gt;file.list
comma
id|list-&gt;prev
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
op_star
id|retp
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|ppp
op_assign
l_int|0
suffix:semicolon
r_return
id|ppp
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a ppp_file structure.&n; */
r_static
r_void
DECL|function|init_ppp_file
id|init_ppp_file
c_func
(paren
r_struct
id|ppp_file
op_star
id|pf
comma
r_int
id|kind
)paren
(brace
id|pf-&gt;kind
op_assign
id|kind
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|pf-&gt;xq
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|pf-&gt;rq
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pf-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pf-&gt;rwait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free up all the resources used by a ppp interface unit.&n; */
DECL|function|ppp_destroy_interface
r_static
r_void
id|ppp_destroy_interface
c_func
(paren
r_struct
id|ppp
op_star
id|ppp
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ppp-&gt;file.list
)paren
suffix:semicolon
multiline_comment|/* Last fd open to this ppp unit is being closed or detached:&n;&t;   mark the interface down, free the ppp unit */
id|ppp_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|ppp_ccp_closed
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;vj
)paren
(brace
id|slhc_free
c_func
(paren
id|ppp-&gt;vj
)paren
suffix:semicolon
id|ppp-&gt;vj
op_assign
l_int|0
suffix:semicolon
)brace
id|skb_queue_purge
c_func
(paren
op_amp
id|ppp-&gt;file.xq
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|ppp-&gt;file.rq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPP_MULTILINK
id|skb_queue_purge
c_func
(paren
op_amp
id|ppp-&gt;mrq
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPP_MULTILINK */
id|dev
op_assign
id|ppp-&gt;dev
suffix:semicolon
id|ppp-&gt;dev
op_assign
l_int|0
suffix:semicolon
id|ppp_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We can&squot;t acquire any new channels (since we have the&n;&t; * all_ppp_lock) so if n_channels is 0, we can free the&n;&t; * ppp structure.  Otherwise we leave it around until the&n;&t; * last channel disconnects from it.&n;&t; */
r_if
c_cond
(paren
id|ppp-&gt;n_channels
op_eq
l_int|0
)paren
id|kfree
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate an existing ppp unit.&n; * The caller should have locked the all_ppp_lock.&n; */
r_static
r_struct
id|ppp
op_star
DECL|function|ppp_find_unit
id|ppp_find_unit
c_func
(paren
r_int
id|unit
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|list
op_assign
op_amp
id|all_ppp_units
suffix:semicolon
r_while
c_loop
(paren
(paren
id|list
op_assign
id|list-&gt;next
)paren
op_ne
op_amp
id|all_ppp_units
)paren
(brace
id|ppp
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|ppp
comma
id|file.list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp-&gt;file.index
op_eq
id|unit
)paren
r_return
id|ppp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate an existing ppp channel.&n; * The caller should have locked the all_channels_lock.&n; */
r_static
r_struct
id|channel
op_star
DECL|function|ppp_find_channel
id|ppp_find_channel
c_func
(paren
r_int
id|unit
)paren
(brace
r_struct
id|channel
op_star
id|pch
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|list
op_assign
op_amp
id|all_channels
suffix:semicolon
r_while
c_loop
(paren
(paren
id|list
op_assign
id|list-&gt;next
)paren
op_ne
op_amp
id|all_channels
)paren
(brace
id|pch
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|channel
comma
id|file.list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;file.index
op_eq
id|unit
)paren
r_return
id|pch
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Connect a PPP channel to a PPP interface unit.&n; */
r_static
r_int
DECL|function|ppp_connect_channel
id|ppp_connect_channel
c_func
(paren
r_struct
id|channel
op_star
id|pch
comma
r_int
id|unit
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
id|ppp
op_assign
id|ppp_find_unit
c_func
(paren
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;ppp
op_ne
l_int|0
)paren
r_goto
id|outw
suffix:semicolon
id|ppp_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;chan
op_eq
l_int|0
)paren
multiline_comment|/* need to check this?? */
r_goto
id|outr
suffix:semicolon
r_if
c_cond
(paren
id|pch-&gt;file.hdrlen
OG
id|ppp-&gt;file.hdrlen
)paren
id|ppp-&gt;file.hdrlen
op_assign
id|pch-&gt;file.hdrlen
suffix:semicolon
id|hdrlen
op_assign
id|pch-&gt;file.hdrlen
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* for protocol bytes */
r_if
c_cond
(paren
id|ppp-&gt;dev
op_logical_and
id|hdrlen
OG
id|ppp-&gt;dev-&gt;hard_header_len
)paren
id|ppp-&gt;dev-&gt;hard_header_len
op_assign
id|hdrlen
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pch-&gt;clist
comma
op_amp
id|ppp-&gt;channels
)paren
suffix:semicolon
op_increment
id|ppp-&gt;n_channels
suffix:semicolon
id|pch-&gt;ppp
op_assign
id|ppp
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|outr
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;downl
)paren
suffix:semicolon
id|ppp_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|outw
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|all_ppp_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Disconnect a channel from its ppp unit.&n; */
r_static
r_int
DECL|function|ppp_disconnect_channel
id|ppp_disconnect_channel
c_func
(paren
r_struct
id|channel
op_star
id|pch
)paren
(brace
r_struct
id|ppp
op_star
id|ppp
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
id|dead
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
id|ppp
op_assign
id|pch-&gt;ppp
suffix:semicolon
r_if
c_cond
(paren
id|ppp
op_ne
l_int|0
)paren
(brace
multiline_comment|/* remove it from the ppp unit&squot;s list */
id|pch-&gt;ppp
op_assign
l_int|NULL
suffix:semicolon
id|ppp_lock
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pch-&gt;clist
)paren
suffix:semicolon
op_decrement
id|ppp-&gt;n_channels
suffix:semicolon
id|dead
op_assign
id|ppp-&gt;dev
op_eq
l_int|0
op_logical_and
id|ppp-&gt;n_channels
op_eq
l_int|0
suffix:semicolon
id|ppp_unlock
c_func
(paren
id|ppp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dead
)paren
multiline_comment|/* Last disconnect from a ppp unit&n;&t;&t;&t;   that is already dead: free it. */
id|kfree
c_func
(paren
id|ppp
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|pch-&gt;upl
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Free up the resources used by a ppp channel.&n; */
DECL|function|ppp_destroy_channel
r_static
r_void
id|ppp_destroy_channel
c_func
(paren
r_struct
id|channel
op_star
id|pch
)paren
(brace
id|skb_queue_purge
c_func
(paren
op_amp
id|pch-&gt;file.xq
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|pch-&gt;file.rq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pch
)paren
suffix:semicolon
)brace
DECL|function|ppp_cleanup
r_void
id|__exit
id|ppp_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* should never happen */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|all_ppp_units
)paren
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|all_channels
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: removing module but units remain!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_chrdev
c_func
(paren
id|PPP_MAJOR
comma
l_string|&quot;ppp&quot;
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP: failed to unregister PPP device&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_handle
)paren
suffix:semicolon
)brace
DECL|variable|ppp_init
id|module_init
c_func
(paren
id|ppp_init
)paren
suffix:semicolon
DECL|variable|ppp_cleanup
id|module_exit
c_func
(paren
id|ppp_cleanup
)paren
suffix:semicolon
DECL|variable|ppp_register_channel
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_register_channel
)paren
suffix:semicolon
DECL|variable|ppp_unregister_channel
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_unregister_channel
)paren
suffix:semicolon
DECL|variable|ppp_channel_index
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_channel_index
)paren
suffix:semicolon
DECL|variable|ppp_unit_number
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_unit_number
)paren
suffix:semicolon
DECL|variable|ppp_input
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_input
)paren
suffix:semicolon
DECL|variable|ppp_input_error
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_input_error
)paren
suffix:semicolon
DECL|variable|ppp_output_wakeup
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_output_wakeup
)paren
suffix:semicolon
DECL|variable|ppp_register_compressor
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_register_compressor
)paren
suffix:semicolon
DECL|variable|ppp_unregister_compressor
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_unregister_compressor
)paren
suffix:semicolon
DECL|variable|ppp_channel_read
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_channel_read
)paren
suffix:semicolon
DECL|variable|ppp_channel_write
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_channel_write
)paren
suffix:semicolon
DECL|variable|ppp_channel_poll
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_channel_poll
)paren
suffix:semicolon
DECL|variable|ppp_channel_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|ppp_channel_ioctl
)paren
suffix:semicolon
DECL|variable|all_ppp_units
id|EXPORT_SYMBOL
c_func
(paren
id|all_ppp_units
)paren
suffix:semicolon
multiline_comment|/* for debugging */
DECL|variable|all_channels
id|EXPORT_SYMBOL
c_func
(paren
id|all_channels
)paren
suffix:semicolon
multiline_comment|/* for debugging */
eof
