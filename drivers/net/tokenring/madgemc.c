multiline_comment|/*&n; *  madgemc.c: Driver for the Madge Smart 16/4 MC16 MCA token ring card.&n; *&n; *  Written 2000 by Adam Fritzler&n; *&n; *  This software may be used and distributed according to the terms&n; *  of the GNU Public License, incorporated herein by reference.&n; *&n; *  This driver module supports the following cards:&n; *      - Madge Smart 16/4 Ringnode MC16&n; *&t;- Madge Smart 16/4 Ringnode MC32 (??)&n; *&n; *  Maintainer(s):&n; *    AF&t;Adam Fritzler&t;&t;mid@auk.cx&n; *&n; *  Modification History:&n; *&t;16-Jan-00&t;AF&t;Created&n; *&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;madgemc.c: v0.91 23/01/2000 by Adam Fritzler&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/trdevice.h&gt;
macro_line|#include &quot;tms380tr.h&quot;
macro_line|#include &quot;madgemc.h&quot;            /* Madge-specific constants */
DECL|macro|MADGEMC_IO_EXTENT
mdefine_line|#define MADGEMC_IO_EXTENT 32
DECL|macro|MADGEMC_SIF_OFFSET
mdefine_line|#define MADGEMC_SIF_OFFSET 0x08
DECL|struct|madgemc_card
r_struct
id|madgemc_card
(brace
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/*&n;&t; * These are read from the BIA ROM.&n;&t; */
DECL|member|manid
r_int
r_int
id|manid
suffix:semicolon
DECL|member|cardtype
r_int
r_int
id|cardtype
suffix:semicolon
DECL|member|cardrev
r_int
r_int
id|cardrev
suffix:semicolon
DECL|member|ramsize
r_int
r_int
id|ramsize
suffix:semicolon
multiline_comment|/*&n;&t; * These are read from the MCA POS registers.  &n;&t; */
DECL|member|burstmode
r_int
r_int
id|burstmode
suffix:colon
l_int|2
suffix:semicolon
DECL|member|fairness
r_int
r_int
id|fairness
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0 = Fair, 1 = Unfair */
DECL|member|arblevel
r_int
r_int
id|arblevel
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ringspeed
r_int
r_int
id|ringspeed
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* 0 = 4mb, 1 = 16, 2 = Auto/none */
DECL|member|cabletype
r_int
r_int
id|cabletype
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0 = RJ45, 1 = DB9 */
DECL|member|next
r_struct
id|madgemc_card
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|madgemc_card_list
r_static
r_struct
id|madgemc_card
op_star
id|madgemc_card_list
op_assign
l_int|NULL
suffix:semicolon
r_int
id|madgemc_probe
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|madgemc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|madgemc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|madgemc_chipset_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|madgemc_read_rom
c_func
(paren
r_struct
id|madgemc_card
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
r_int
id|madgemc_setnselout_pins
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|madgemc_setcabletype
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|type
)paren
suffix:semicolon
r_static
r_int
id|madgemc_mcaproc
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|slot
comma
r_void
op_star
id|d
)paren
suffix:semicolon
r_static
r_void
id|madgemc_setregpage
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|page
)paren
suffix:semicolon
r_static
r_void
id|madgemc_setsifsel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|val
)paren
suffix:semicolon
r_static
r_void
id|madgemc_setint
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|val
)paren
suffix:semicolon
r_static
r_void
id|madgemc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; * These work around paging, however they dont guarentee you&squot;re on the&n; * right page.&n; */
DECL|macro|SIFREADB
mdefine_line|#define SIFREADB(reg) (inb(dev-&gt;base_addr + ((reg&lt;0x8)?reg:reg-0x8)))
DECL|macro|SIFWRITEB
mdefine_line|#define SIFWRITEB(val, reg) (outb(val, dev-&gt;base_addr + ((reg&lt;0x8)?reg:reg-0x8)))
DECL|macro|SIFREADW
mdefine_line|#define SIFREADW(reg) (inw(dev-&gt;base_addr + ((reg&lt;0x8)?reg:reg-0x8)))
DECL|macro|SIFWRITEW
mdefine_line|#define SIFWRITEW(val, reg) (outw(val, dev-&gt;base_addr + ((reg&lt;0x8)?reg:reg-0x8)))
multiline_comment|/*&n; * Read a byte-length value from the register.&n; */
DECL|function|madgemc_sifreadb
r_static
r_int
r_int
id|madgemc_sifreadb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|reg
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0x8
)paren
id|ret
op_assign
id|SIFREADB
c_func
(paren
id|reg
)paren
suffix:semicolon
r_else
(brace
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
id|SIFREADB
c_func
(paren
id|reg
)paren
suffix:semicolon
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a byte-length value to a register.&n; */
DECL|function|madgemc_sifwriteb
r_static
r_void
id|madgemc_sifwriteb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|val
comma
r_int
r_int
id|reg
)paren
(brace
r_if
c_cond
(paren
id|reg
OL
l_int|0x8
)paren
id|SIFWRITEB
c_func
(paren
id|val
comma
id|reg
)paren
suffix:semicolon
r_else
(brace
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|SIFWRITEB
c_func
(paren
id|val
comma
id|reg
)paren
suffix:semicolon
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a word-length value from a register&n; */
DECL|function|madgemc_sifreadw
r_static
r_int
r_int
id|madgemc_sifreadw
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|reg
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0x8
)paren
id|ret
op_assign
id|SIFREADW
c_func
(paren
id|reg
)paren
suffix:semicolon
r_else
(brace
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
id|SIFREADW
c_func
(paren
id|reg
)paren
suffix:semicolon
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a word-length value to a register.&n; */
DECL|function|madgemc_sifwritew
r_static
r_void
id|madgemc_sifwritew
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|val
comma
r_int
r_int
id|reg
)paren
(brace
r_if
c_cond
(paren
id|reg
OL
l_int|0x8
)paren
id|SIFWRITEW
c_func
(paren
id|val
comma
id|reg
)paren
suffix:semicolon
r_else
(brace
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|SIFWRITEW
c_func
(paren
id|val
comma
id|reg
)paren
suffix:semicolon
id|madgemc_setregpage
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|madgemc_probe
r_int
id|__init
id|madgemc_probe
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|versionprinted
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|net_local
op_star
id|tp
suffix:semicolon
r_struct
id|madgemc_card
op_star
id|card
suffix:semicolon
r_int
id|i
comma
id|slot
op_assign
l_int|0
suffix:semicolon
id|__u8
id|posreg
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MCA_bus
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_ne
id|MCA_NOTFOUND
)paren
(brace
multiline_comment|/*&n;&t;&t; * Currently we only support the MC16/32 (MCA ID 002d)&n;&t;&t; */
id|slot
op_assign
id|mca_find_unused_adapter
c_func
(paren
l_int|0x002d
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|MCA_NOTFOUND
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we get here, we have an adapter.&n;&t;&t; */
r_if
c_cond
(paren
id|versionprinted
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|init_trdev
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;madgemc: unable to allocate dev space&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fetch MCA config registers&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|posreg
(braket
id|i
)braket
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
id|i
op_plus
l_int|2
)paren
suffix:semicolon
)brace
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|madgemc_card
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;madgemc: unable to allocate card struct&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|card-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Parse configuration information.  This all comes&n;&t;&t; * directly from the publicly available @002d.ADF.&n;&t;&t; * Get it from Madge or your local ADF library.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * Base address &n;&t;&t; */
id|dev-&gt;base_addr
op_assign
l_int|0x0a20
op_plus
(paren
(paren
id|posreg
(braket
l_int|2
)braket
op_amp
id|MC16_POS2_ADDR2
)paren
ques
c_cond
l_int|0x0400
suffix:colon
l_int|0
)paren
op_plus
(paren
(paren
id|posreg
(braket
l_int|0
)braket
op_amp
id|MC16_POS0_ADDR1
)paren
ques
c_cond
l_int|0x1000
suffix:colon
l_int|0
)paren
op_plus
(paren
(paren
id|posreg
(braket
l_int|3
)braket
op_amp
id|MC16_POS3_ADDR3
)paren
ques
c_cond
l_int|0x2000
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Interrupt line&n;&t;&t; */
r_switch
c_cond
(paren
id|posreg
(braket
l_int|0
)braket
op_rshift
l_int|6
)paren
(brace
multiline_comment|/* upper two bits */
r_case
l_int|0x1
suffix:colon
id|dev-&gt;irq
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2
suffix:colon
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* IRQ 2 = IRQ 9 */
r_case
l_int|0x3
suffix:colon
id|dev-&gt;irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: invalid IRQ&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|getout
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|MADGEMC_IO_EXTENT
comma
l_string|&quot;madgemc&quot;
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* why is this not working? */
r_if
c_cond
(paren
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|MADGEMC_IO_EXTENT
comma
l_string|&quot;madgemc&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;madgemc: unable to setup Smart MC in slot %d because of I/O base conflict at 0x%04lx&bslash;n&quot;
comma
id|slot
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_add_assign
id|MADGEMC_SIF_OFFSET
suffix:semicolon
r_goto
id|getout
suffix:semicolon
)brace
macro_line|#endif
id|dev-&gt;base_addr
op_add_assign
id|MADGEMC_SIF_OFFSET
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Arbitration Level&n;&t;&t; */
id|card-&gt;arblevel
op_assign
(paren
(paren
id|posreg
(braket
l_int|0
)braket
op_rshift
l_int|1
)paren
op_amp
l_int|0x7
)paren
op_plus
l_int|8
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Burst mode and Fairness&n;&t;&t; */
id|card-&gt;burstmode
op_assign
(paren
(paren
id|posreg
(braket
l_int|2
)braket
op_rshift
l_int|6
)paren
op_amp
l_int|0x3
)paren
suffix:semicolon
id|card-&gt;fairness
op_assign
(paren
(paren
id|posreg
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ring Speed&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|posreg
(braket
l_int|1
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x1
)paren
id|card-&gt;ringspeed
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* not selected */
r_else
r_if
c_cond
(paren
(paren
id|posreg
(braket
l_int|2
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|0x1
)paren
id|card-&gt;ringspeed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 16Mb */
r_else
id|card-&gt;ringspeed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 4Mb */
multiline_comment|/* &n;&t;&t; * Cable type&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|posreg
(braket
l_int|1
)braket
op_rshift
l_int|6
)paren
op_amp
l_int|0x1
)paren
id|card-&gt;cabletype
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* STP/DB9 */
r_else
id|card-&gt;cabletype
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* UTP/RJ-45 */
multiline_comment|/* &n;&t;&t; * ROM Info. This requires us to actually twiddle&n;&t;&t; * bits on the card, so we must ensure above that &n;&t;&t; * the base address is free of conflict (request_region above).&n;&t;&t; */
id|madgemc_read_rom
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;manid
op_ne
l_int|0x4d
)paren
(brace
multiline_comment|/* something went wrong */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Madge MC ROM read failed (unknown manufacturer ID %02x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|card-&gt;manid
)paren
suffix:semicolon
r_goto
id|getout
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card-&gt;cardtype
op_ne
l_int|0x08
)paren
op_logical_and
(paren
id|card-&gt;cardtype
op_ne
l_int|0x0d
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Madge MC ROM read failed (unknown card ID %02x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|card-&gt;cardtype
)paren
suffix:semicolon
r_goto
id|getout
suffix:semicolon
)brace
multiline_comment|/* All cards except Rev 0 and 1 MC16&squot;s have 256kb of RAM */
r_if
c_cond
(paren
(paren
id|card-&gt;cardtype
op_eq
l_int|0x08
)paren
op_logical_and
(paren
id|card-&gt;cardrev
op_le
l_int|0x01
)paren
)paren
id|card-&gt;ramsize
op_assign
l_int|128
suffix:semicolon
r_else
id|card-&gt;ramsize
op_assign
l_int|256
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s Rev %d at 0x%04lx IRQ %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|card-&gt;cardtype
op_eq
l_int|0x08
)paren
ques
c_cond
id|MADGEMC16_CARDNAME
suffix:colon
id|MADGEMC32_CARDNAME
comma
id|card-&gt;cardrev
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;cardtype
op_eq
l_int|0x0d
)paren
id|printk
c_func
(paren
l_string|&quot;%s:     Warning: MC32 support is experimental and highly untested&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;ringspeed
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Unknown */
id|printk
c_func
(paren
l_string|&quot;%s:     Warning: Ring speed not set in POS -- Please run the reference disk and set it!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|card-&gt;ringspeed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* default to 16mb */
)brace
id|printk
c_func
(paren
l_string|&quot;%s:     RAM Size: %dKB&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|card-&gt;ramsize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:     Ring Speed: %dMb/sec on %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|card-&gt;ringspeed
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|4
comma
id|card-&gt;cabletype
ques
c_cond
l_string|&quot;STP/DB9&quot;
suffix:colon
l_string|&quot;UTP/RJ-45&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:     Arbitration Level: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|card-&gt;arblevel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:     Burst Mode: &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|card-&gt;burstmode
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Cycle steal&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Limited burst&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Delayed release&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Immediate release&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; (%s)&bslash;n&quot;
comma
(paren
id|card-&gt;fairness
)paren
ques
c_cond
l_string|&quot;Unfair&quot;
suffix:colon
l_string|&quot;Fair&quot;
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Enable SIF before we assign the interrupt handler,&n;&t;&t; * just in case we get spurious interrupts that need&n;&t;&t; * handling.&n;&t;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
multiline_comment|/* sanity */
id|madgemc_setsifsel
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|madgemc_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;madgemc&quot;
comma
id|dev
)paren
)paren
(brace
r_goto
id|getout
suffix:semicolon
)brace
id|madgemc_chipset_init
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* enables interrupts! */
id|madgemc_setcabletype
c_func
(paren
id|dev
comma
id|card-&gt;cabletype
)paren
suffix:semicolon
multiline_comment|/* Setup MCA structures */
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
(paren
id|card-&gt;cardtype
op_eq
l_int|0x08
)paren
ques
c_cond
id|MADGEMC16_CARDNAME
suffix:colon
id|MADGEMC32_CARDNAME
)paren
suffix:semicolon
id|mca_set_adapter_procfn
c_func
(paren
id|slot
comma
id|madgemc_mcaproc
comma
id|dev
)paren
suffix:semicolon
id|mca_mark_as_used
c_func
(paren
id|slot
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:     Ring Station Address: &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;:%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmsdev_init
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get memory for dev-&gt;priv.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|tp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* &n;&t;&t; * The MC16 is physically a 32bit card.  However, Madge&n;&t;&t; * insists on calling it 16bit, so I&squot;ll assume here that&n;&t;&t; * they know what they&squot;re talking about.  Cut off DMA&n;&t;&t; * at 16mb.&n;&t;&t; */
id|tp-&gt;dmalimit
op_assign
id|ISA_MAX_ADDRESS
suffix:semicolon
multiline_comment|/* XXX: ?? */
id|tp-&gt;setnselout
op_assign
id|madgemc_setnselout_pins
suffix:semicolon
id|tp-&gt;sifwriteb
op_assign
id|madgemc_sifwriteb
suffix:semicolon
id|tp-&gt;sifreadb
op_assign
id|madgemc_sifreadb
suffix:semicolon
id|tp-&gt;sifwritew
op_assign
id|madgemc_sifwritew
suffix:semicolon
id|tp-&gt;sifreadw
op_assign
id|madgemc_sifreadw
suffix:semicolon
id|tp-&gt;DataRate
op_assign
(paren
id|card-&gt;ringspeed
)paren
ques
c_cond
id|SPEED_16
suffix:colon
id|SPEED_4
suffix:semicolon
id|memcpy
c_func
(paren
id|tp-&gt;ProductID
comma
l_string|&quot;Madge MCA 16/4    &quot;
comma
id|PROD_ID_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|madgemc_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|madgemc_close
suffix:semicolon
r_if
c_cond
(paren
id|register_trdev
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Enlist in the card list */
id|card-&gt;next
op_assign
id|madgemc_card_list
suffix:semicolon
id|madgemc_card_list
op_assign
id|card
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;madgemc: register_trdev() returned non-zero.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|slot
op_increment
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* successful, try to find another */
id|getout
suffix:colon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
op_minus
id|MADGEMC_SIF_OFFSET
comma
id|MADGEMC_IO_EXTENT
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* release_trdev? */
id|slot
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|madgemc_card_list
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle interrupts generated by the card&n; *&n; * The MicroChannel Madge cards need slightly more handling&n; * after an interrupt than other TMS380 cards do.&n; *&n; * First we must make sure it was this card that generated the&n; * interrupt (since interrupt sharing is allowed).  Then,&n; * because we&squot;re using level-triggered interrupts (as is&n; * standard on MCA), we must toggle the interrupt line&n; * on the card in order to claim and acknowledge the interrupt.&n; * Once that is done, the interrupt should be handlable in&n; * the normal tms380tr_interrupt() routine.&n; *&n; * There&squot;s two ways we can check to see if the interrupt is ours,&n; * both with their own disadvantages...&n; *&n; * 1)  &t;Read in the SIFSTS register from the TMS controller.  This&n; *&t;is guarenteed to be accurate, however, there&squot;s a fairly&n; *&t;large performance penalty for doing so: the Madge chips&n; *&t;must request the register from the Eagle, the Eagle must&n; *&t;read them from its internal bus, and then take the route&n; *&t;back out again, for a 16bit read.  &n; *&n; * 2)&t;Use the MC_CONTROL_REG0_SINTR bit from the Madge ASICs.&n; *&t;The major disadvantage here is that the accuracy of the&n; *&t;bit is in question.  However, it cuts out the extra read&n; *&t;cycles it takes to read the Eagle&squot;s SIF, as its only an&n; *&t;8bit read, and theoretically the Madge bit is directly&n; *&t;connected to the interrupt latch coming out of the Eagle&n; *&t;hardware (that statement is not verified).  &n; *&n; * I can&squot;t determine which of these methods has the best win.  For now,&n; * we make a compromise.  Use the Madge way for the first interrupt,&n; * which should be the fast-path, and then once we hit the first &n; * interrupt, keep on trying using the SIF method until we&squot;ve&n; * exhausted all contiguous interrupts.&n; *&n; */
DECL|function|madgemc_interrupt
r_static
r_void
id|madgemc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|pending
comma
id|reg1
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_id
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;madgemc_interrupt: was not passed a dev_id!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
multiline_comment|/* Make sure its really us. -- the Madge way */
id|pending
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pending
op_amp
id|MC_CONTROL_REG0_SINTR
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* not our interrupt */
multiline_comment|/*&n;&t; * Since we&squot;re level-triggered, we may miss the rising edge&n;&t; * of the next interrupt while we&squot;re off handling this one,&n;&t; * so keep checking until the SIF verifies that it has nothing&n;&t; * left for us to do.&n;&t; */
id|pending
op_assign
id|STS_SYSTEM_IRQ
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|pending
op_amp
id|STS_SYSTEM_IRQ
)paren
(brace
multiline_comment|/* Toggle the interrupt to reset the latch on card */
id|reg1
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg1
op_xor
id|MC_CONTROL_REG1_SINTEN
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg1
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
multiline_comment|/* Continue handling as normal */
id|tms380tr_interrupt
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|pending
op_assign
id|SIFREADW
c_func
(paren
id|SIFSTS
)paren
suffix:semicolon
multiline_comment|/* restart - the SIF way */
)brace
r_else
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* not reachable */
)brace
multiline_comment|/*&n; * Set the card to the prefered ring speed.&n; *&n; * Unlike newer cards, the MC16/32 have their speed selection&n; * circuit connected to the Madge ASICs and not to the TMS380&n; * NSELOUT pins. Set the ASIC bits correctly here, and return &n; * zero to leave the TMS NSELOUT bits unaffected.&n; *&n; */
DECL|function|madgemc_setnselout_pins
r_int
r_int
id|madgemc_setnselout_pins
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_char
id|reg1
suffix:semicolon
r_struct
id|net_local
op_star
id|tp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|reg1
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;DataRate
op_eq
id|SPEED_16
)paren
(brace
id|reg1
op_or_assign
id|MC_CONTROL_REG1_SPEED_SEL
suffix:semicolon
)brace
multiline_comment|/* add for 16mb */
r_else
r_if
c_cond
(paren
id|reg1
op_amp
id|MC_CONTROL_REG1_SPEED_SEL
)paren
id|reg1
op_xor_assign
id|MC_CONTROL_REG1_SPEED_SEL
suffix:semicolon
multiline_comment|/* remove for 4mb */
id|outb
c_func
(paren
id|reg1
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no change */
)brace
multiline_comment|/*&n; * Set the register page.  This equates to the SRSX line&n; * on the TMS380Cx6.&n; *&n; * Register selection is normally done via three contiguous&n; * bits.  However, some boards (such as the MC16/32) use only&n; * two bits, plus a seperate bit in the glue chip.  This&n; * sets the SRSX bit (the top bit).  See page 4-17 in the&n; * Yellow Book for which registers are affected.&n; *&n; */
DECL|function|madgemc_setregpage
r_static
r_void
id|madgemc_setregpage
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|page
)paren
(brace
r_static
r_int
id|reg1
op_assign
l_int|0
suffix:semicolon
id|reg1
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_eq
l_int|0
)paren
op_logical_and
(paren
id|reg1
op_amp
id|MC_CONTROL_REG1_SRSX
)paren
)paren
(brace
id|outb
c_func
(paren
id|reg1
op_xor
id|MC_CONTROL_REG1_SRSX
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|page
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
id|reg1
op_or
id|MC_CONTROL_REG1_SRSX
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
)brace
id|reg1
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * The SIF registers are not mapped into register space by default&n; * Set this to 1 to map them, 0 to map the BIA ROM.&n; *&n; */
DECL|function|madgemc_setsifsel
r_static
r_void
id|madgemc_setsifsel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|val
)paren
(brace
r_int
r_int
id|reg0
suffix:semicolon
id|reg0
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_eq
l_int|0
)paren
op_logical_and
(paren
id|reg0
op_amp
id|MC_CONTROL_REG0_SIFSEL
)paren
)paren
(brace
id|outb
c_func
(paren
id|reg0
op_xor
id|MC_CONTROL_REG0_SIFSEL
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|val
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
id|reg0
op_or
id|MC_CONTROL_REG0_SIFSEL
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
)brace
id|reg0
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable SIF interrupts&n; *&n; * This does not enable interrupts in the SIF, but rather&n; * enables SIF interrupts to be passed onto the host.&n; *&n; */
DECL|function|madgemc_setint
r_static
r_void
id|madgemc_setint
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|val
)paren
(brace
r_int
r_int
id|reg1
suffix:semicolon
id|reg1
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_eq
l_int|0
)paren
op_logical_and
(paren
id|reg1
op_amp
id|MC_CONTROL_REG1_SINTEN
)paren
)paren
(brace
id|outb
c_func
(paren
id|reg1
op_xor
id|MC_CONTROL_REG1_SINTEN
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|val
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
id|reg1
op_or
id|MC_CONTROL_REG1_SINTEN
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Cable type is set via control register 7. Bit zero high&n; * for UTP, low for STP.&n; */
DECL|function|madgemc_setcabletype
r_static
r_void
id|madgemc_setcabletype
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|type
)paren
(brace
id|outb
c_func
(paren
(paren
id|type
op_eq
l_int|0
)paren
ques
c_cond
id|MC_CONTROL_REG7_CABLEUTP
suffix:colon
id|MC_CONTROL_REG7_CABLESTP
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG7
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable the functions of the Madge chipset needed for&n; * full working order. &n; */
DECL|function|madgemc_chipset_init
r_static
r_int
id|madgemc_chipset_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
multiline_comment|/* pull SRESET low */
id|tms380tr_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for card to reset */
multiline_comment|/* bring back into normal operating mode */
id|outb
c_func
(paren
id|MC_CONTROL_REG1_NSRESET
comma
id|dev-&gt;base_addr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
multiline_comment|/* map SIF registers */
id|madgemc_setsifsel
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* enable SIF interrupts */
id|madgemc_setint
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable the board, and put back into power-up state.&n; */
DECL|function|madgemc_chipset_close
r_void
id|madgemc_chipset_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* disable interrupts */
id|madgemc_setint
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* unmap SIF registers */
id|madgemc_setsifsel
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the card type (MC16 or MC32) from the card.&n; *&n; * The configuration registers are stored in two seperate&n; * pages.  Pages are flipped by clearing bit 3 of CONTROL_REG0 (PAGE)&n; * for page zero, or setting bit 3 for page one.&n; *&n; * Page zero contains the following data:&n; *&t;Byte 0: Manufacturer ID (0x4D -- ASCII &quot;M&quot;)&n; *&t;Byte 1: Card type:&n; *&t;&t;&t;0x08 for MC16&n; *&t;&t;&t;0x0D for MC32&n; *&t;Byte 2: Card revision&n; *&t;Byte 3: Mirror of POS config register 0&n; *&t;Byte 4: Mirror of POS 1&n; *&t;Byte 5: Mirror of POS 2&n; *&n; * Page one contains the following data:&n; *&t;Byte 0: Unused&n; *&t;Byte 1-6: BIA, MSB to LSB.&n; *&n; * Note that to read the BIA, we must unmap the SIF registers&n; * by clearing bit 2 of CONTROL_REG0 (SIFSEL), as the data&n; * will reside in the same logical location.  For this reason,&n; * _never_ read the BIA while the Eagle processor is running!&n; * The SIF will be completely inaccessible until the BIA operation&n; * is complete.&n; *&n; */
DECL|function|madgemc_read_rom
r_static
r_void
id|madgemc_read_rom
c_func
(paren
r_struct
id|madgemc_card
op_star
id|card
)paren
(brace
r_int
r_int
id|ioaddr
suffix:semicolon
r_int
r_char
id|reg0
comma
id|reg1
comma
id|tmpreg0
comma
id|i
suffix:semicolon
id|ioaddr
op_assign
id|card-&gt;dev-&gt;base_addr
suffix:semicolon
id|reg0
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
id|reg1
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
multiline_comment|/* Switch to page zero and unmap SIF */
id|tmpreg0
op_assign
id|reg0
op_amp
op_complement
(paren
id|MC_CONTROL_REG0_PAGE
op_plus
id|MC_CONTROL_REG0_SIFSEL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tmpreg0
comma
id|ioaddr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
id|card-&gt;manid
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MC_ROM_MANUFACTURERID
)paren
suffix:semicolon
id|card-&gt;cardtype
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MC_ROM_ADAPTERID
)paren
suffix:semicolon
id|card-&gt;cardrev
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MC_ROM_REVISION
)paren
suffix:semicolon
multiline_comment|/* Switch to rom page one */
id|outb
c_func
(paren
id|tmpreg0
op_or
id|MC_CONTROL_REG0_PAGE
comma
id|ioaddr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
multiline_comment|/* Read BIA */
id|card-&gt;dev-&gt;addr_len
op_assign
l_int|6
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|card-&gt;dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MC_ROM_BIA_START
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Restore original register values */
id|outb
c_func
(paren
id|reg0
comma
id|ioaddr
op_plus
id|MC_CONTROL_REG0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg1
comma
id|ioaddr
op_plus
id|MC_CONTROL_REG1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|madgemc_open
r_static
r_int
id|madgemc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/*&n;&t; * Go ahead and reinitialize the chipset again, just to &n;&t; * make sure we didn&squot;t get left in a bad state.&n;&t; */
id|madgemc_chipset_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|tms380tr_open
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|madgemc_close
r_static
r_int
id|madgemc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|tms380tr_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|madgemc_chipset_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Give some details available from /proc/mca/slotX&n; */
DECL|function|madgemc_mcaproc
r_static
r_int
id|madgemc_mcaproc
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|slot
comma
r_void
op_star
id|d
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|d
suffix:semicolon
r_struct
id|madgemc_card
op_star
id|curcard
op_assign
id|madgemc_card_list
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|curcard
)paren
(brace
multiline_comment|/* search for card struct */
r_if
c_cond
(paren
id|curcard-&gt;dev
op_eq
id|dev
)paren
r_break
suffix:semicolon
id|curcard
op_assign
id|curcard-&gt;next
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;-------&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curcard
)paren
(brace
r_struct
id|net_local
op_star
id|tp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Card Revision: %d&bslash;n&quot;
comma
id|curcard-&gt;cardrev
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;RAM Size: %dkb&bslash;n&quot;
comma
id|curcard-&gt;ramsize
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Cable type: %s&bslash;n&quot;
comma
(paren
id|curcard-&gt;cabletype
)paren
ques
c_cond
l_string|&quot;STP/DB9&quot;
suffix:colon
l_string|&quot;UTP/RJ-45&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Configured ring speed: %dMb/sec&bslash;n&quot;
comma
(paren
id|curcard-&gt;ringspeed
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|4
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Running ring speed: %dMb/sec&bslash;n&quot;
comma
(paren
id|tp-&gt;DataRate
op_eq
id|SPEED_16
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|4
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Device: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IO Port: 0x%04lx&bslash;n&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IRQ: %d&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Arbitration Level: %d&bslash;n&quot;
comma
id|curcard-&gt;arblevel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Burst Mode: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|curcard-&gt;burstmode
)paren
(brace
r_case
l_int|0
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Cycle steal&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Limited burst&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Delayed release&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Immediate release&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot; (%s)&bslash;n&quot;
comma
(paren
id|curcard-&gt;fairness
)paren
ques
c_cond
l_string|&quot;Unfair&quot;
suffix:colon
l_string|&quot;Fair&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Ring Station Address: &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Card not configured&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Probe for cards. */
r_if
c_cond
(paren
id|madgemc_probe
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;madgemc.c: No cards found.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* lock_tms380_module(); */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|madgemc_card
op_star
id|this_card
suffix:semicolon
r_while
c_loop
(paren
id|madgemc_card_list
)paren
(brace
id|dev
op_assign
id|madgemc_card_list-&gt;dev
suffix:semicolon
id|unregister_trdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
op_minus
id|MADGEMC_SIF_OFFSET
comma
id|MADGEMC_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|this_card
op_assign
id|madgemc_card_list
suffix:semicolon
id|madgemc_card_list
op_assign
id|this_card-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|this_card
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock_tms380_module(); */
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -DMODVERSIONS  -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer -I/usr/src/linux/drivers/net/tokenring/ -c madgemc.c&quot;&n; *  alt-compile-command: &quot;gcc -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer -I/usr/src/linux/drivers/net/tokenring/ -c madgemc.c&quot;&n; *  c-set-style &quot;K&amp;R&quot;&n; *  c-indent-level: 8&n; *  c-basic-offset: 8&n; *  tab-width: 8&n; * End:&n; */
eof
