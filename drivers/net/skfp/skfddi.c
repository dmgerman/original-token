multiline_comment|/*&n; * File Name:&n; *   skfddi.c&n; *&n; * Copyright Information:&n; *   Copyright SysKonnect 1998,1999.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; * Abstract:&n; *   A Linux device driver supporting the SysKonnect FDDI PCI controller&n; *   familie.&n; *&n; * Maintainers:&n; *   CG    Christoph Goos (cgoos@syskonnect.de)&n; *&n; * Contributors:&n; *   DM    David S. Miller&n; *&n; * Address all question to:&n; *   linux@syskonnect.de&n; *&n; * The technical manual for the adapters is available from SysKonnect&squot;s&n; * web pages: www.syskonnect.com&n; * Goto &quot;Support&quot; and search Knowledge Base for &quot;manual&quot;.&n; *&n; * Driver Architecture:&n; *   The driver architecture is based on the DEC FDDI driver by&n; *   Lawrence V. Stefani and several ethernet drivers.&n; *   I also used an existing Windows NT miniport driver.&n; *   All hardware dependant fuctions are handled by the SysKonnect&n; *   Hardware Module.&n; *   The only headerfiles that are directly related to this source&n; *   are skfddi.c, h/types.h, h/osdef1st.h, h/targetos.h.&n; *   The others belong to the SysKonnect FDDI Hardware Module and&n; *   should better not be changed.&n; * NOTE:&n; *   Compiling this driver produces some warnings, but I did not fix&n; *   this, because the Hardware Module source is used for different&n; *   drivers, and fixing it for Linux might bring problems on other&n; *   projects. To keep the source common for all those drivers (and&n; *   thus simplify fixes to it), please do not clean it up!&n; *&n; * Modification History:&n; *              Date            Name    Description&n; *              02-Mar-98       CG&t;Created.&n; *&n; *&t;&t;10-Mar-99&t;CG&t;Support for 2.2.x added.&n; *&t;&t;25-Mar-99&t;CG&t;Corrected IRQ routing for SMP (APIC)&n; *&t;&t;26-Oct-99&t;CG&t;Fixed compilation error on 2.2.13&n; *&t;&t;12-Nov-99&t;CG&t;Source code release&n; *&t;&t;22-Nov-99&t;CG&t;Included in kernel source.&n; *&t;&t;07-May-00&t;DM&t;64 bit fixes, new dma interface&n; *&n; * Compilation options (-Dxxx):&n; *              DRIVERDEBUG     print lots of messages to log file&n; *              DUMPPACKETS     print received/transmitted packets to logfile&n; * &n; * Tested cpu architectures:&n; *&t;- i386&n; *&t;- sparc64&n; */
multiline_comment|/* Version information string - should be updated prior to */
multiline_comment|/* each new release!!! */
DECL|macro|VERSION
mdefine_line|#define VERSION&t;&t;&quot;2.06&quot;
DECL|variable|boot_msg
r_static
r_const
r_char
op_star
id|boot_msg
op_assign
l_string|&quot;SysKonnect FDDI PCI Adapter driver v&quot;
id|VERSION
l_string|&quot; for&bslash;n&quot;
l_string|&quot;  SK-55xx/SK-58xx adapters (SK-NET FDDI-FP/UP/LP)&quot;
suffix:semicolon
multiline_comment|/* Include files */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;&t;
singleline_comment|// isdigit
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/fddidevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include&t;&quot;h/types.h&quot;
DECL|macro|ADDR
macro_line|#undef ADDR&t;&t;&t;
singleline_comment|// undo Linux definition
macro_line|#include&t;&quot;h/skfbi.h&quot;
macro_line|#include&t;&quot;h/fddi.h&quot;
macro_line|#include&t;&quot;h/smc.h&quot;
macro_line|#include&t;&quot;h/smtstate.h&quot;
singleline_comment|// Define global routines
r_int
id|skfp_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
singleline_comment|// Define module-wide (static) routines
r_static
r_struct
id|net_device
op_star
id|alloc_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
suffix:semicolon
r_static
r_int
id|fddi_dev_index
c_func
(paren
r_int
r_char
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|init_dev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|link_modules
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device
op_star
id|tmp
)paren
suffix:semicolon
r_static
r_int
id|skfp_driver_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|skfp_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|skfp_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|skfp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|skfp_ctl_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|skfp_ctl_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|skfp_ctl_set_multicast_list_wo_lock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|skfp_ctl_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
id|skfp_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|skfp_send_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|send_queued_packets
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_static
r_void
id|CheckSourceAddress
c_func
(paren
r_int
r_char
op_star
id|frame
comma
r_int
r_char
op_star
id|hw_addr
)paren
suffix:semicolon
r_static
r_void
id|ResetAdapter
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
singleline_comment|// Functions needed by the hardware module
r_void
op_star
id|mac_drv_get_space
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_int
id|size
)paren
suffix:semicolon
r_void
op_star
id|mac_drv_get_desc_mem
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_int
id|size
)paren
suffix:semicolon
r_int
r_int
id|mac_drv_virt2phys
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_void
op_star
id|virt
)paren
suffix:semicolon
r_int
r_int
id|dma_master
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_void
op_star
id|virt
comma
r_int
id|len
comma
r_int
id|flag
)paren
suffix:semicolon
r_void
id|dma_complete
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_union
id|s_fp_descr
op_star
id|descr
comma
r_int
id|flag
)paren
suffix:semicolon
r_void
id|mac_drv_tx_complete
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_txd
op_star
id|txd
)paren
suffix:semicolon
r_void
id|llc_restart_tx
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_void
id|mac_drv_rx_complete
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
comma
r_int
id|frag_count
comma
r_int
id|len
)paren
suffix:semicolon
r_void
id|mac_drv_requeue_rxd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
comma
r_int
id|frag_count
)paren
suffix:semicolon
r_void
id|mac_drv_fill_rxd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_void
id|mac_drv_clear_rxd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
comma
r_int
id|frag_count
)paren
suffix:semicolon
r_int
id|mac_drv_rx_init
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|len
comma
r_int
id|fc
comma
r_char
op_star
id|look_ahead
comma
r_int
id|la_len
)paren
suffix:semicolon
r_void
id|smt_timer_poll
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_void
id|ring_status_indication
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_long
id|status
)paren
suffix:semicolon
r_int
r_int
id|smt_get_time
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|smt_stat_counter
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|stat
)paren
suffix:semicolon
r_void
id|cfm_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|c_state
)paren
suffix:semicolon
r_void
id|ecm_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|e_state
)paren
suffix:semicolon
r_void
id|pcm_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|plc
comma
r_int
id|p_state
)paren
suffix:semicolon
r_void
id|rmt_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|r_state
)paren
suffix:semicolon
r_void
id|drv_reset_indication
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_void
id|dump_data
c_func
(paren
r_int
r_char
op_star
id|Data
comma
r_int
id|length
)paren
suffix:semicolon
singleline_comment|// External functions from the hardware module
r_extern
id|u_int
id|mac_drv_check_space
c_func
(paren
)paren
suffix:semicolon
r_extern
r_void
id|read_address
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_char
op_star
id|mac_addr
)paren
suffix:semicolon
r_extern
r_void
id|card_stop
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_extern
r_int
id|mac_drv_init
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_extern
r_void
id|hwm_tx_frag
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_char
id|far
op_star
id|virt
comma
id|u_long
id|phys
comma
r_int
id|len
comma
r_int
id|frame_status
)paren
suffix:semicolon
r_extern
r_int
id|hwm_tx_init
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_char
id|fc
comma
r_int
id|frag_count
comma
r_int
id|frame_len
comma
r_int
id|frame_status
)paren
suffix:semicolon
r_extern
r_int
id|init_smt
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_char
op_star
id|mac_addr
)paren
suffix:semicolon
r_extern
r_void
id|fddi_isr
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_extern
r_void
id|hwm_rx_frag
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_char
id|far
op_star
id|virt
comma
id|u_long
id|phys
comma
r_int
id|len
comma
r_int
id|frame_status
)paren
suffix:semicolon
r_extern
r_void
id|mac_drv_rx_mode
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|mode
)paren
suffix:semicolon
r_extern
r_void
id|mac_drv_clear_tx_queue
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_extern
r_void
id|mac_drv_clear_rx_queue
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_extern
r_void
id|mac_clear_multicast
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
r_extern
r_void
id|enable_tx_irq
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_short
id|queue
)paren
suffix:semicolon
r_extern
r_void
id|mac_drv_clear_txd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
suffix:semicolon
singleline_comment|// Define module-wide (static) variables
DECL|variable|num_boards
r_static
r_int
id|num_boards
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* total number of adapters configured */
DECL|variable|num_fddi
r_static
r_int
id|num_fddi
op_assign
l_int|0
suffix:semicolon
DECL|variable|autoprobed
r_static
r_int
id|autoprobed
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|unlink_modules
c_func
(paren
r_struct
id|net_device
op_star
id|p
)paren
suffix:semicolon
DECL|variable|loading_module
r_static
r_int
id|loading_module
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|loading_module
r_static
r_int
id|loading_module
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// MODULE
macro_line|#ifdef DRIVERDEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(s, args...) printk(s, ## args)
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(s, args...)
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// DRIVERDEBUG
DECL|macro|PRIV
mdefine_line|#define PRIV(dev) (&amp;(((struct s_smc *)dev-&gt;priv)-&gt;os))
multiline_comment|/*&n; * ==============&n; * = skfp_probe =&n; * ==============&n; *   &n; * Overview:&n; *   Probes for supported FDDI PCI controllers&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This routine is called by the OS for each FDDI device name (fddi0,&n; *   fddi1,...,fddi6, fddi7) specified in drivers/net/Space.c.&n; *   If loaded as a module, it will detect and initialize all &n; *   adapters the first time it is called.&n; *&n; *   Let&squot;s say that skfp_probe() is getting called to initialize fddi0.&n; *   Furthermore, let&squot;s say there are three supported controllers in the&n; *   system.  Before skfp_probe() leaves, devices fddi0, fddi1, and fddi2&n; *   will be initialized and a global flag will be set to indicate that&n; *   skfp_probe() has already been called.&n; *&n; *   However...the OS doesn&squot;t know that we&squot;ve already initialized&n; *   devices fddi1 and fddi2 so skfp_probe() gets called again and again&n; *   until it reaches the end of the device list for FDDI (presently,&n; *   fddi7).  It&squot;s important that the driver &quot;pretend&quot; to probe for&n; *   devices fddi1 and fddi2 and return success.  Devices fddi3&n; *   through fddi7 will return failure since they weren&squot;t initialized.&n; *&n; *   This algorithm seems to work for the time being.  As other FDDI&n; *   drivers are written for Linux, a more generic approach (perhaps&n; *   similar to the Ethernet card approach) may need to be implemented.&n; *   &n; * Return Codes:&n; *   0           - This device (fddi0, fddi1, etc) configured successfully&n; *   -ENODEV - No devices present, or no SysKonnect FDDI PCI device&n; *                         present for this device name&n; *&n; *&n; * Side Effects:&n; *   Device structures for FDDI adapters (fddi0, fddi1, etc) are&n; *   initialized and the board resources are read and stored in&n; *   the device structure.&n; */
DECL|function|skfp_probe
r_int
id|skfp_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* used in for loops */
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* PCI device structure */
macro_line|#ifndef MEM_MAPPED_IO
id|u16
id|port
suffix:semicolon
multiline_comment|/* temporary I/O (port) address */
r_int
id|port_len
suffix:semicolon
multiline_comment|/* length of port address range (in bytes) */
macro_line|#else
r_int
r_int
id|port
suffix:semicolon
macro_line|#endif
id|u16
id|command
suffix:semicolon
multiline_comment|/* PCI Configuration space Command register val */
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
multiline_comment|/* board pointer */
r_struct
id|net_device
op_star
id|tmp
op_assign
id|dev
suffix:semicolon
id|u8
id|first_dev_used
op_assign
l_int|0
suffix:semicolon
id|u16
id|SubSysId
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering skfp_probe&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify whether we&squot;re going through skfp_probe() again&n;&t; *&n;&t; * If so, see if we&squot;re going through for a subsequent fddi device that&n;&t; * we&squot;ve already initialized.  If we are, return success (0).  If not,&n;&t; * return failure (-ENODEV).&n;&t; */
r_if
c_cond
(paren
id|autoprobed
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Already entered skfp_probe&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;fddi&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_ne
l_int|0
)paren
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
)brace
id|autoprobed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set global flag */
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|boot_msg
)paren
suffix:semicolon
multiline_comment|/* Scan for Syskonnect FDDI PCI controllers */
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* is PCI BIOS even present? */
id|printk
c_func
(paren
l_string|&quot;no PCI BIOS present&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SKFP_MAX_NUM_BOARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// scan for PCI cards
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Check device %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_SK
comma
id|PCI_DEVICE_ID_SK_FP
comma
id|pdev
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_continue
suffix:semicolon
macro_line|#ifndef MEM_MAPPED_IO
multiline_comment|/* Verify that I/O enable bit is set (PCI slot is enabled) */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
op_eq
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;I/O enable bit not set!&quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot; Verify that slot is enabled&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Turn off memory mapped space and enable mastering */
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Command Reg: %04x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
id|command
op_and_assign
op_complement
id|PCI_COMMAND_MEMORY
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
multiline_comment|/* Read I/O base address from PCI Configuration Space */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_1
comma
op_amp
id|port
)paren
suffix:semicolon
id|port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
singleline_comment|// clear I/O bit (bit 0)
multiline_comment|/* Verify port address range is not already being used */
id|port_len
op_assign
id|FP_IO_LEN
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|port
comma
id|port_len
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;I/O range allocated to adapter&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (0x%X-0x%X) is already being used!&bslash;n&quot;
comma
id|port
comma
(paren
id|port
op_plus
id|port_len
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* Verify that MEM enable bit is set (PCI slot is enabled) */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
op_eq
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;MEMORY-I/O enable bit not set!&quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot; Verify that slot is enabled&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Turn off IO mapped space and enable mastering */
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Command Reg: %04x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
id|command
op_and_assign
op_complement
id|PCI_COMMAND_IO
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
id|port
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|port
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|port
comma
l_int|0x4000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skfp:  Unable to map MEMORY register, &quot;
l_string|&quot;FDDI adapter will be disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
op_logical_neg
id|loading_module
)paren
op_logical_or
id|first_dev_used
)paren
(brace
multiline_comment|/* Allocate a device structure for this adapter */
id|tmp
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|port
)paren
suffix:semicolon
)brace
id|first_dev_used
op_assign
l_int|1
suffix:semicolon
singleline_comment|// only significant first time
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_SUBSYSTEM_ID
comma
op_amp
id|SubSysId
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|loading_module
)paren
id|link_modules
c_func
(paren
id|dev
comma
id|tmp
)paren
suffix:semicolon
id|dev
op_assign
id|tmp
suffix:semicolon
id|init_dev
c_func
(paren
id|dev
comma
id|port
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
multiline_comment|/* Initialize board structure with bus-specific info */
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|smc-&gt;os.dev
op_assign
id|dev
suffix:semicolon
id|smc-&gt;os.bus_type
op_assign
id|SK_BUS_TYPE_PCI
suffix:semicolon
id|smc-&gt;os.pdev
op_assign
op_star
id|pdev
suffix:semicolon
id|smc-&gt;os.QueueSkb
op_assign
id|MAX_TX_QUEUE_LEN
suffix:semicolon
id|smc-&gt;os.MaxFrameSize
op_assign
id|MAX_FRAME_SIZE
suffix:semicolon
id|smc-&gt;os.dev
op_assign
id|dev
suffix:semicolon
id|smc-&gt;hw.slot
op_assign
op_minus
l_int|1
suffix:semicolon
id|smc-&gt;os.ResetRequested
op_assign
id|FALSE
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|smc-&gt;os.SendSkbQueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skfp_driver_init
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
singleline_comment|// only increment global board 
singleline_comment|// count on success
id|num_boards
op_increment
suffix:semicolon
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|FP_IO_LEN
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SubSysId
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x5500
op_logical_or
(paren
id|SubSysId
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x5800
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: SysKonnect FDDI PCI adapter&quot;
l_string|&quot; found (SK-%04X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|SubSysId
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: FDDI PCI adapter found&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|i
op_assign
id|SKFP_MAX_NUM_BOARDS
suffix:semicolon
singleline_comment|// stop search
)brace
)brace
singleline_comment|// if (dev != NULL)
)brace
singleline_comment|// for SKFP_MAX_NUM_BOARDS
multiline_comment|/*&n;&t; * If we&squot;re at this point we&squot;re going through skfp_probe() for the&n;&t; * first time. Return success (0) if we&squot;ve initialized 1 or more&n;&t; * boards. Otherwise, return failure (-ENODEV).&n;&t; */
r_if
c_cond
(paren
id|num_boards
OG
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;no SysKonnect FDDI adapter found&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// skfp_probe
multiline_comment|/************************&n; *&n; * Search the entire &squot;fddi&squot; device list for a fixed probe. If a match isn&squot;t&n; * found then check for an autoprobe or unused device location. If they&n; * are not available then insert a new device structure at the end of&n; * the current list.&n; *&n; ************************/
DECL|function|alloc_device
r_static
r_struct
id|net_device
op_star
id|alloc_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
(brace
r_struct
id|net_device
op_star
id|adev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|fixed
op_assign
l_int|0
comma
id|new_dev
op_assign
l_int|0
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering alloc_device&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|dev
suffix:semicolon
id|num_fddi
op_assign
id|fddi_dev_index
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loading_module
)paren
(brace
id|num_fddi
op_increment
suffix:semicolon
id|dev
op_assign
id|insert_device
c_func
(paren
id|dev
comma
id|skfp_probe
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;base_addr
op_eq
id|NO_ADDRESS
)paren
op_logical_or
(paren
id|dev-&gt;base_addr
op_eq
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|adev
)paren
(brace
id|adev
op_assign
id|dev
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_eq
id|iobase
)paren
)paren
(brace
id|fixed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|new_dev
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|dev-&gt;next-&gt;name
comma
l_string|&quot;fddi&quot;
comma
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
id|new_dev
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_or
id|new_dev
op_logical_or
id|fixed
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
id|num_fddi
op_increment
suffix:semicolon
)brace
singleline_comment|// while (1)
r_if
c_cond
(paren
id|adev
op_logical_and
op_logical_neg
id|fixed
)paren
(brace
id|dev
op_assign
id|adev
suffix:semicolon
id|num_fddi
op_assign
id|fddi_dev_index
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
id|new_dev
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|dev-&gt;base_addr
op_ne
id|NO_ADDRESS
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_ne
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|fixed
)paren
op_logical_or
id|new_dev
)paren
(brace
id|num_fddi
op_increment
suffix:semicolon
multiline_comment|/* New device */
id|dev
op_assign
id|insert_device
c_func
(paren
id|dev
comma
id|skfp_probe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;priv
)paren
(brace
multiline_comment|/* Allocate space for private board structure */
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|s_smc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Could not allocate memory for&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; private board structure!&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* clear structure */
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|s_smc
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|dev
suffix:semicolon
)brace
singleline_comment|// alloc_device
multiline_comment|/************************&n; *&n; * Initialize device structure&n; *&n; ************************/
DECL|function|init_dev
r_static
r_void
id|init_dev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
(brace
multiline_comment|/* Initialize new device structure */
id|dev-&gt;rmem_end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* shared memory isn&squot;t used */
id|dev-&gt;rmem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* shared memory isn&squot;t used */
id|dev-&gt;mem_end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* shared memory isn&squot;t used */
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* shared memory isn&squot;t used */
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* save port (I/O) base address */
id|dev-&gt;if_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not applicable to FDDI adapters */
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bus Master DMA doesn&squot;t require channel */
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|skfp_ctl_get_stats
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|skfp_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|skfp_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|skfp_send_pkt
suffix:semicolon
id|dev-&gt;hard_header
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set in fddi_setup() */
id|dev-&gt;rebuild_header
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set in fddi_setup() */
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|skfp_ctl_set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
op_amp
id|skfp_ctl_set_mac_address
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|skfp_ioctl
suffix:semicolon
id|dev-&gt;set_config
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not supported for now &amp;&amp;&amp; */
id|dev-&gt;header_cache_update
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not supported */
id|dev-&gt;change_mtu
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set in fddi_setup() */
multiline_comment|/* Initialize remaining device structure information */
id|fddi_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
singleline_comment|// init_device
multiline_comment|/************************&n; *&n; * If at end of fddi device list and can&squot;t use current entry, malloc&n; * one up. If memory could not be allocated, print an error message.&n; *&n;************************/
DECL|function|insert_device
r_static
r_struct
id|net_device
op_star
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_struct
id|net_device
op_star
r_new
suffix:semicolon
r_int
id|len
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering insert_device&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|net_device
)paren
op_plus
r_sizeof
(paren
r_struct
id|s_smc
)paren
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fddi%d: Device not initialised, insufficient memory&bslash;n&quot;
comma
id|num_fddi
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
r_new
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|priv
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
(paren
r_new
op_plus
l_int|1
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|init
op_assign
id|init
suffix:semicolon
multiline_comment|/* initialisation routine */
r_if
c_cond
(paren
op_logical_neg
id|loading_module
)paren
(brace
r_new
op_member_access_from_pointer
id|next
op_assign
id|dev-&gt;next
suffix:semicolon
id|dev-&gt;next
op_assign
r_new
suffix:semicolon
)brace
multiline_comment|/* create new device name */
r_if
c_cond
(paren
id|num_fddi
OG
l_int|999
)paren
(brace
id|sprintf
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
l_string|&quot;fddi????&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
l_string|&quot;fddi%d&quot;
comma
id|num_fddi
)paren
suffix:semicolon
)brace
)brace
r_return
r_new
suffix:semicolon
)brace
singleline_comment|// insert_device
multiline_comment|/************************&n; *&n; * Get the number of a &quot;fddiX&quot; string&n; *&n; ************************/
DECL|function|fddi_dev_index
r_static
r_int
id|fddi_dev_index
c_func
(paren
r_int
r_char
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|s
suffix:semicolon
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|s
)paren
)paren
(brace
id|j
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
(paren
id|i
op_star
l_int|10
)paren
op_plus
(paren
op_star
id|s
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
singleline_comment|// fddi_dev_index
multiline_comment|/************************&n; *&n; * Used if loaded as module only. Link the device structures&n; * together. Needed to release them all at unload.&n; *&n;************************/
DECL|function|link_modules
r_static
r_void
id|link_modules
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device
op_star
id|tmp
)paren
(brace
r_struct
id|net_device
op_star
id|p
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_while
c_loop
(paren
(paren
(paren
r_struct
id|s_smc
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|os.next_module
)paren
(brace
id|p
op_assign
(paren
(paren
r_struct
id|s_smc
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|os.next_module
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_ne
id|tmp
)paren
(brace
(paren
(paren
r_struct
id|s_smc
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|os.next_module
op_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
(paren
(paren
r_struct
id|s_smc
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|os.next_module
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
singleline_comment|// link_modules
multiline_comment|/*&n; * ====================&n; * = skfp_driver_init =&n; * ====================&n; *   &n; * Overview:&n; *   Initializes remaining adapter board structure information&n; *   and makes sure adapter is in a safe state prior to skfp_open().&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This function allocates additional resources such as the host memory&n; *   blocks needed by the adapter.&n; *   The adapter is also reset. The OS must call skfp_open() to open &n; *   the adapter and bring it on-line.&n; *&n; * Return Codes:&n; *    0 - initialization succeeded&n; *   -1 - initialization failed&n; */
DECL|function|skfp_driver_init
r_static
r_int
id|skfp_driver_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|s_smc
op_star
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|skfddi_priv
op_star
id|bp
op_assign
id|PRIV
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u8
id|val
suffix:semicolon
multiline_comment|/* used for I/O read/writes */
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering skfp_driver_init&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// set the io address in private structures
id|bp-&gt;base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|smc-&gt;hw.iop
op_assign
id|dev-&gt;base_addr
suffix:semicolon
singleline_comment|// Get the interrupt level from the PCI Configuration Table
id|val
op_assign
id|dev-&gt;irq
suffix:semicolon
id|smc-&gt;hw.irq
op_assign
id|val
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|bp-&gt;DriverLock
)paren
suffix:semicolon
singleline_comment|// Allocate invalid frame
id|bp-&gt;LocalRxBuffer
op_assign
id|pci_alloc_consistent
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|MAX_FRAME_SIZE
comma
op_amp
id|bp-&gt;LocalRxBufferDMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;LocalRxBuffer
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;could not allocate mem for &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;LocalRxBuffer: %d byte&bslash;n&quot;
comma
id|MAX_FRAME_SIZE
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
singleline_comment|// Determine the required size of the &squot;shared&squot; memory area.
id|bp-&gt;SharedMemSize
op_assign
id|mac_drv_check_space
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Memory for HWM: %ld&bslash;n&quot;
comma
id|bp-&gt;SharedMemSize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;SharedMemSize
OG
l_int|0
)paren
(brace
id|bp-&gt;SharedMemSize
op_add_assign
l_int|16
suffix:semicolon
singleline_comment|// for descriptor alignment
id|bp-&gt;SharedMemAddr
op_assign
id|pci_alloc_consistent
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|bp-&gt;SharedMemSize
comma
op_amp
id|bp-&gt;SharedMemDMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;SharedMemSize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;could not allocate mem for &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hardware module: %ld byte&bslash;n&quot;
comma
id|bp-&gt;SharedMemSize
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|bp-&gt;SharedMemHeap
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Nothing used yet.
)brace
r_else
(brace
id|bp-&gt;SharedMemAddr
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;SharedMemHeap
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// SharedMemSize &gt; 0
id|memset
c_func
(paren
id|bp-&gt;SharedMemAddr
comma
l_int|0
comma
id|bp-&gt;SharedMemSize
)paren
suffix:semicolon
id|card_stop
c_func
(paren
id|smc
)paren
suffix:semicolon
singleline_comment|// Reset adapter.
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;mac_drv_init()..&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mac_drv_init
c_func
(paren
id|smc
)paren
op_ne
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;mac_drv_init() failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|read_address
c_func
(paren
id|smc
comma
l_int|NULL
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;HW-Addr: %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|smc-&gt;hw.fddi_canon_addr.a
(braket
l_int|0
)braket
comma
id|smc-&gt;hw.fddi_canon_addr.a
(braket
l_int|1
)braket
comma
id|smc-&gt;hw.fddi_canon_addr.a
(braket
l_int|2
)braket
comma
id|smc-&gt;hw.fddi_canon_addr.a
(braket
l_int|3
)braket
comma
id|smc-&gt;hw.fddi_canon_addr.a
(braket
l_int|4
)braket
comma
id|smc-&gt;hw.fddi_canon_addr.a
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|smc-&gt;hw.fddi_canon_addr.a
comma
l_int|6
)paren
suffix:semicolon
id|smt_reset_defaults
c_func
(paren
id|smc
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|bp-&gt;SharedMemAddr
)paren
(brace
id|pci_free_consistent
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|bp-&gt;SharedMemSize
comma
id|bp-&gt;SharedMemAddr
comma
id|bp-&gt;SharedMemDMA
)paren
suffix:semicolon
id|bp-&gt;SharedMemAddr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp-&gt;LocalRxBuffer
)paren
(brace
id|pci_free_consistent
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|MAX_FRAME_SIZE
comma
id|bp-&gt;LocalRxBuffer
comma
id|bp-&gt;LocalRxBufferDMA
)paren
suffix:semicolon
id|bp-&gt;LocalRxBuffer
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
singleline_comment|// skfp_driver_init
multiline_comment|/*&n; * =============&n; * = skfp_open =&n; * =============&n; *   &n; * Overview:&n; *   Opens the adapter&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This function brings the adapter to an operational state.&n; *&n; * Return Codes:&n; *   0           - Adapter was successfully opened&n; *   -EAGAIN - Could not register IRQ&n; */
DECL|function|skfp_open
r_static
r_int
id|skfp_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|s_smc
op_star
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering skfp_open&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Register IRQ - support shared interrupts by passing device ptr */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|skfp_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Requested IRQ %d is busy&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set current address to factory MAC address&n;&t; *&n;&t; * Note: We&squot;ve already done this step in skfp_driver_init.&n;&t; *       However, it&squot;s possible that a user has set a node&n;&t; *               address override, then closed and reopened the&n;&t; *               adapter.  Unless we reset the device address field&n;&t; *               now, we&squot;ll continue to use the existing modified&n;&t; *               address.&n;&t; */
id|read_address
c_func
(paren
id|smc
comma
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|smc-&gt;hw.fddi_canon_addr.a
comma
l_int|6
)paren
suffix:semicolon
id|init_smt
c_func
(paren
id|smc
comma
l_int|NULL
)paren
suffix:semicolon
id|smt_online
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
id|STI_FBI
c_func
(paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* Clear local multicast address tables */
id|mac_clear_multicast
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* Disable promiscuous filter settings */
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|RX_DISABLE_PROMISC
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|// skfp_open
multiline_comment|/*&n; * ==============&n; * = skfp_close =&n; * ==============&n; *   &n; * Overview:&n; *   Closes the device/module.&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This routine closes the adapter and brings it to a safe state.&n; *   The interrupt service routine is deregistered with the OS.&n; *   The adapter can be opened again with another call to skfp_open().&n; *&n; * Return Codes:&n; *   Always return 0.&n; *&n; * Assumptions:&n; *   No further requests for this adapter are made after this routine is&n; *   called.  skfp_open() can be called to reset and reinitialize the&n; *   adapter.&n; */
DECL|function|skfp_close
r_static
r_int
id|skfp_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|s_smc
op_star
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skfddi_priv
op_star
id|bp
op_assign
id|PRIV
c_func
(paren
id|dev
)paren
suffix:semicolon
id|CLI_FBI
c_func
(paren
)paren
suffix:semicolon
id|smt_reset_defaults
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
id|card_stop
c_func
(paren
id|smc
)paren
suffix:semicolon
id|mac_drv_clear_tx_queue
c_func
(paren
id|smc
)paren
suffix:semicolon
id|mac_drv_clear_rx_queue
c_func
(paren
id|smc
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Deregister (free) IRQ */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|bp-&gt;SendSkbQueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|bp-&gt;QueueSkb
op_increment
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|// skfp_close
multiline_comment|/*&n; * ==================&n; * = skfp_interrupt =&n; * ==================&n; *   &n; * Overview:&n; *   Interrupt processing routine&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   irq        - interrupt vector&n; *   dev_id     - pointer to device information&n; *       regs   - pointer to registers structure&n; *&n; * Functional Description:&n; *   This routine calls the interrupt processing routine for this adapter.  It&n; *   disables and reenables adapter interrupts, as appropriate.  We can support&n; *   shared interrupts since the incoming dev_id pointer provides our device&n; *   structure context. All the real work is done in the hardware module.&n; *&n; * Return Codes:&n; *   None&n; *&n; * Assumptions:&n; *   The interrupt acknowledgement at the hardware level (eg. ACKing the PIC&n; *   on Intel-based systems) is done by the operating system outside this&n; *   routine.&n; *&n; *       System interrupts are enabled through this call.&n; *&n; * Side Effects:&n; *   Interrupts are disabled, then reenabled at the adapter.&n; */
DECL|function|skfp_interrupt
r_void
id|skfp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
multiline_comment|/* private board structure pointer */
id|skfddi_priv
op_star
id|bp
op_assign
id|PRIV
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: irq %d for unknown device&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
singleline_comment|// IRQs enabled or disabled ?
r_if
c_cond
(paren
id|inpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_IMSK
)paren
)paren
op_eq
l_int|0
)paren
(brace
singleline_comment|// IRQs are disabled: must be shared interrupt
r_return
suffix:semicolon
)brace
singleline_comment|// Note: At this point, IRQs are enabled.
r_if
c_cond
(paren
(paren
id|inpd
c_func
(paren
id|ISR_A
)paren
op_amp
id|smc-&gt;hw.is_imask
)paren
op_eq
l_int|0
)paren
(brace
singleline_comment|// IRQ?
singleline_comment|// Adapter did not issue an IRQ: must be shared interrupt
r_return
suffix:semicolon
)brace
id|CLI_FBI
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// Disable IRQs from our adapter.
id|spin_lock
c_func
(paren
op_amp
id|bp-&gt;DriverLock
)paren
suffix:semicolon
singleline_comment|// Call interrupt handler in hardware module (HWM).
id|fddi_isr
c_func
(paren
id|smc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;os.ResetRequested
)paren
(brace
id|ResetAdapter
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smc-&gt;os.ResetRequested
op_assign
id|FALSE
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|bp-&gt;DriverLock
)paren
suffix:semicolon
id|STI_FBI
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// Enable IRQs from our adapter.
r_return
suffix:semicolon
)brace
singleline_comment|// skfp_interrupt
multiline_comment|/*&n; * ======================&n; * = skfp_ctl_get_stats =&n; * ======================&n; *   &n; * Overview:&n; *   Get statistics for FDDI adapter&n; *  &n; * Returns:&n; *   Pointer to FDDI statistics structure&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   Gets current MIB objects from adapter, then&n; *   returns FDDI statistics structure as defined&n; *   in if_fddi.h.&n; *&n; *   Note: Since the FDDI statistics structure is&n; *   still new and the device structure doesn&squot;t&n; *   have an FDDI-specific get statistics handler,&n; *   we&squot;ll return the FDDI statistics structure as&n; *   a pointer to an Ethernet statistics structure.&n; *   That way, at least the first part of the statistics&n; *   structure can be decoded properly.&n; *   We&squot;ll have to pay attention to this routine as the&n; *   device structure becomes more mature and LAN media&n; *   independent.&n; *&n; */
DECL|function|skfp_ctl_get_stats
r_struct
id|net_device_stats
op_star
id|skfp_ctl_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|s_smc
op_star
id|bp
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Fill the bp-&gt;stats structure with driver-maintained counters */
id|bp-&gt;os.MacStat.port_bs_flag
(braket
l_int|0
)braket
op_assign
l_int|0x1234
suffix:semicolon
id|bp-&gt;os.MacStat.port_bs_flag
(braket
l_int|1
)braket
op_assign
l_int|0x5678
suffix:semicolon
singleline_comment|// goos: need to fill out fddi statistic
macro_line|#if 0
multiline_comment|/* Get FDDI SMT MIB objects */
multiline_comment|/* Fill the bp-&gt;stats structure with the SMT MIB object values */
id|memcpy
c_func
(paren
id|bp-&gt;stats.smt_station_id
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_id
comma
r_sizeof
(paren
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_id
)paren
)paren
suffix:semicolon
id|bp-&gt;stats.smt_op_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_op_version_id
suffix:semicolon
id|bp-&gt;stats.smt_hi_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_hi_version_id
suffix:semicolon
id|bp-&gt;stats.smt_lo_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_lo_version_id
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.smt_user_data
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_user_data
comma
r_sizeof
(paren
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_user_data
)paren
)paren
suffix:semicolon
id|bp-&gt;stats.smt_mib_version_id
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_mib_version_id
suffix:semicolon
id|bp-&gt;stats.smt_mac_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_mac_ct
suffix:semicolon
id|bp-&gt;stats.smt_non_master_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_non_master_ct
suffix:semicolon
id|bp-&gt;stats.smt_master_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_master_ct
suffix:semicolon
id|bp-&gt;stats.smt_available_paths
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_available_paths
suffix:semicolon
id|bp-&gt;stats.smt_config_capabilities
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_config_capabilities
suffix:semicolon
id|bp-&gt;stats.smt_config_policy
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_config_policy
suffix:semicolon
id|bp-&gt;stats.smt_connection_policy
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_connection_policy
suffix:semicolon
id|bp-&gt;stats.smt_t_notify
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_t_notify
suffix:semicolon
id|bp-&gt;stats.smt_stat_rpt_policy
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_stat_rpt_policy
suffix:semicolon
id|bp-&gt;stats.smt_trace_max_expiration
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_trace_max_expiration
suffix:semicolon
id|bp-&gt;stats.smt_bypass_present
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_bypass_present
suffix:semicolon
id|bp-&gt;stats.smt_ecm_state
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_ecm_state
suffix:semicolon
id|bp-&gt;stats.smt_cf_state
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_cf_state
suffix:semicolon
id|bp-&gt;stats.smt_remote_disconnect_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_remote_disconnect_flag
suffix:semicolon
id|bp-&gt;stats.smt_station_status
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_status
suffix:semicolon
id|bp-&gt;stats.smt_peer_wrap_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_peer_wrap_flag
suffix:semicolon
id|bp-&gt;stats.smt_time_stamp
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_msg_time_stamp.ls
suffix:semicolon
id|bp-&gt;stats.smt_transition_time_stamp
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_transition_time_stamp.ls
suffix:semicolon
id|bp-&gt;stats.mac_frame_status_functions
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_status_functions
suffix:semicolon
id|bp-&gt;stats.mac_t_max_capability
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_max_capability
suffix:semicolon
id|bp-&gt;stats.mac_tvx_capability
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_tvx_capability
suffix:semicolon
id|bp-&gt;stats.mac_available_paths
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_available_paths
suffix:semicolon
id|bp-&gt;stats.mac_current_path
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_current_path
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_upstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_upstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_downstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_downstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_old_upstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_old_upstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_old_downstream_nbr
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_old_downstream_nbr
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|bp-&gt;stats.mac_dup_address_test
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_dup_address_test
suffix:semicolon
id|bp-&gt;stats.mac_requested_paths
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_requested_paths
suffix:semicolon
id|bp-&gt;stats.mac_downstream_port_type
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_downstream_port_type
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.mac_smt_address
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_smt_address
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|bp-&gt;stats.mac_t_req
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_req
suffix:semicolon
id|bp-&gt;stats.mac_t_neg
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_neg
suffix:semicolon
id|bp-&gt;stats.mac_t_max
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_max
suffix:semicolon
id|bp-&gt;stats.mac_tvx_value
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_tvx_value
suffix:semicolon
id|bp-&gt;stats.mac_frame_error_threshold
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_threshold
suffix:semicolon
id|bp-&gt;stats.mac_frame_error_ratio
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_ratio
suffix:semicolon
id|bp-&gt;stats.mac_rmt_state
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_rmt_state
suffix:semicolon
id|bp-&gt;stats.mac_da_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_da_flag
suffix:semicolon
id|bp-&gt;stats.mac_una_da_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_unda_flag
suffix:semicolon
id|bp-&gt;stats.mac_frame_error_flag
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_flag
suffix:semicolon
id|bp-&gt;stats.mac_ma_unitdata_available
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_ma_unitdata_available
suffix:semicolon
id|bp-&gt;stats.mac_hardware_present
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_hardware_present
suffix:semicolon
id|bp-&gt;stats.mac_ma_unitdata_enable
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_ma_unitdata_enable
suffix:semicolon
id|bp-&gt;stats.path_tvx_lower_bound
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_tvx_lower_bound
suffix:semicolon
id|bp-&gt;stats.path_t_max_lower_bound
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_t_max_lower_bound
suffix:semicolon
id|bp-&gt;stats.path_max_t_req
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_max_t_req
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;stats.path_configuration
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_configuration
comma
r_sizeof
(paren
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_configuration
)paren
)paren
suffix:semicolon
id|bp-&gt;stats.port_my_type
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_my_type
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_my_type
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_my_type
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_neighbor_type
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_neighbor_type
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_neighbor_type
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_neighbor_type
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_policies
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_policies
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_policies
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_policies
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_mac_indicated
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_indicated
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_mac_indicated
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_indicated
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_current_path
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_current_path
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_current_path
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_current_path
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;stats.port_requested_paths
(braket
l_int|0
op_star
l_int|3
)braket
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_requested_paths
(braket
l_int|0
)braket
comma
l_int|3
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|bp-&gt;stats.port_requested_paths
(braket
l_int|1
op_star
l_int|3
)braket
comma
op_amp
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_requested_paths
(braket
l_int|1
)braket
comma
l_int|3
)paren
suffix:semicolon
id|bp-&gt;stats.port_mac_placement
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_placement
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_mac_placement
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_placement
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_available_paths
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_available_paths
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_available_paths
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_available_paths
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_pmd_class
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pmd_class
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_pmd_class
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pmd_class
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_capabilities
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_capabilities
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_connection_capabilities
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_capabilities
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_bs_flag
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_bs_flag
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_bs_flag
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_bs_flag
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_estimate
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_estimate
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_estimate
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_estimate
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_cutoff
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_cutoff
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_cutoff
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_cutoff
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_alarm
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_alarm
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_alarm
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_alarm
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_connect_state
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connect_state
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_connect_state
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connect_state
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_pcm_state
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pcm_state
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_pcm_state
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pcm_state
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_pc_withhold
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pc_withhold
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_pc_withhold
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pc_withhold
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_flag
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_flag
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_ler_flag
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_flag
(braket
l_int|1
)braket
suffix:semicolon
id|bp-&gt;stats.port_hardware_present
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_hardware_present
(braket
l_int|0
)braket
suffix:semicolon
id|bp-&gt;stats.port_hardware_present
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_hardware_present
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Fill the bp-&gt;stats structure with the FDDI counter values */
id|bp-&gt;stats.mac_frame_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.frame_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_copied_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.copied_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_transmit_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.transmit_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_error_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.error_cnt.ls
suffix:semicolon
id|bp-&gt;stats.mac_lost_cts
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lost_cnt.ls
suffix:semicolon
id|bp-&gt;stats.port_lct_fail_cts
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lct_rejects
(braket
l_int|0
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lct_fail_cts
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lct_rejects
(braket
l_int|1
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_reject_cts
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lem_rejects
(braket
l_int|0
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_reject_cts
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lem_rejects
(braket
l_int|1
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_cts
(braket
l_int|0
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.link_errors
(braket
l_int|0
)braket
dot
id|ls
suffix:semicolon
id|bp-&gt;stats.port_lem_cts
(braket
l_int|1
)braket
op_assign
id|bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.link_errors
(braket
l_int|1
)braket
dot
id|ls
suffix:semicolon
macro_line|#endif
r_return
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
op_amp
id|bp-&gt;os.MacStat
)paren
suffix:semicolon
)brace
singleline_comment|// ctl_get_stat
multiline_comment|/*&n; * ==============================&n; * = skfp_ctl_set_multicast_list =&n; * ==============================&n; *   &n; * Overview:&n; *   Enable/Disable LLC frame promiscuous mode reception&n; *   on the adapter and/or update multicast address table.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   This function acquires the driver lock and only calls&n; *   skfp_ctl_set_multicast_list_wo_lock then.&n; *   This routine follows a fairly simple algorithm for setting the&n; *   adapter filters and CAM:&n; *&n; *      if IFF_PROMISC flag is set&n; *              enable promiscuous mode&n; *      else&n; *              disable promiscuous mode&n; *              if number of multicast addresses &lt;= max. multicast number&n; *                      add mc addresses to adapter table&n; *              else&n; *                      enable promiscuous mode&n; *              update adapter filters&n; *&n; * Assumptions:&n; *   Multicast addresses are presented in canonical (LSB) format.&n; *&n; * Side Effects:&n; *   On-board adapter filters are updated.&n; */
DECL|function|skfp_ctl_set_multicast_list
r_static
r_void
id|skfp_ctl_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
id|PRIV
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|Flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
id|skfp_ctl_set_multicast_list_wo_lock
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// skfp_ctl_set_multicast_list
DECL|function|skfp_ctl_set_multicast_list_wo_lock
r_static
r_void
id|skfp_ctl_set_multicast_list_wo_lock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|s_smc
op_star
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
multiline_comment|/* ptr to multicast addr entry */
r_int
id|i
suffix:semicolon
multiline_comment|/* Enable promiscuous mode, if necessary */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|RX_ENABLE_PROMISC
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;PROMISCUOUS MODE ENABLED&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Else, update multicast address table */
r_else
(brace
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|RX_DISABLE_PROMISC
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;PROMISCUOUS MODE DISABLED&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Reset all MC addresses
id|mac_clear_multicast
c_func
(paren
id|smc
)paren
suffix:semicolon
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|RX_DISABLE_ALLMULTI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|RX_ENABLE_ALLMULTI
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;ENABLE ALL MC ADDRESSES&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;mc_count
op_le
id|FPMAX_MULTICAST
)paren
(brace
multiline_comment|/* use exact filtering */
singleline_comment|// point to first multicast addr
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac_add_multicast
c_func
(paren
id|smc
comma
id|dmi-&gt;dmi_addr
comma
l_int|1
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;ENABLE MC ADDRESS:&quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot; %02x %02x %02x &quot;
comma
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|1
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%02x %02x %02x&bslash;n&quot;
comma
id|dmi-&gt;dmi_addr
(braket
l_int|3
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|4
)braket
comma
id|dmi-&gt;dmi_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
)brace
singleline_comment|// for
)brace
r_else
(brace
singleline_comment|// more MC addresses than HW supports
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|RX_ENABLE_ALLMULTI
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;ENABLE ALL MC ADDRESSES&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// no MC addresses
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;DISABLE ALL MC ADDRESSES&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Update adapter filters */
id|mac_update_multicast
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
singleline_comment|// skfp_ctl_set_multicast_list_wo_lock
multiline_comment|/*&n; * ===========================&n; * = skfp_ctl_set_mac_address =&n; * ===========================&n; *   &n; * Overview:&n; *   set new mac address on adapter and update dev_addr field in device table.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   dev  - pointer to device information&n; *   addr - pointer to sockaddr structure containing unicast address to set&n; *&n; * Assumptions:&n; *   The address pointed to by addr-&gt;sa_data is a valid unicast&n; *   address and is presented in canonical (LSB) format.&n; */
DECL|function|skfp_ctl_set_mac_address
r_static
r_int
id|skfp_ctl_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|s_smc
op_star
id|smc
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sockaddr
op_star
id|p_sockaddr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr
suffix:semicolon
id|skfddi_priv
op_star
id|bp
op_assign
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
suffix:semicolon
r_int
r_int
id|Flags
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|p_sockaddr-&gt;sa_data
comma
id|FDDI_K_ALEN
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
id|ResetAdapter
c_func
(paren
id|smc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* always return zero */
)brace
singleline_comment|// skfp_ctl_set_mac_address
multiline_comment|/*&n; * ==============&n; * = skfp_ioctl =&n; * ==============&n; *   &n; * Overview:&n; *&n; * Perform IOCTL call functions here. Some are privileged operations and the&n; * effective uid is checked in those cases.&n; *  &n; * Returns:&n; *   status value&n; *   0 - success&n; *   other - failure&n; *       &n; * Arguments:&n; *   dev  - pointer to device information&n; *   rq - pointer to ioctl request structure&n; *   cmd - ?&n; *&n; */
DECL|function|skfp_ioctl
r_static
r_int
id|skfp_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
id|skfddi_priv
op_star
id|lp
op_assign
id|PRIV
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|s_skfp_ioctl
id|ioc
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|ioc
comma
id|rq-&gt;ifr_data
comma
r_sizeof
(paren
r_struct
id|s_skfp_ioctl
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ioc.cmd
)paren
(brace
r_case
id|SKFP_GET_STATS
suffix:colon
multiline_comment|/* Get the driver statistics */
id|ioc.len
op_assign
r_sizeof
(paren
id|lp-&gt;MacStat
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|ioc.data
comma
id|skfp_ctl_get_stats
c_func
(paren
id|dev
)paren
comma
id|ioc.len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SKFP_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|memset
c_func
(paren
op_amp
id|lp-&gt;MacStat
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;MacStat
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ioctl for %s: unknow cmd: %04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ioc.cmd
)paren
suffix:semicolon
)brace
singleline_comment|// switch
r_return
id|status
suffix:semicolon
)brace
singleline_comment|// skfp_ioctl
multiline_comment|/*&n; * =====================&n; * = skfp_send_pkt     =&n; * =====================&n; *   &n; * Overview:&n; *   Queues a packet for transmission and try to transmit it.&n; *  &n; * Returns:&n; *   Condition code&n; *       &n; * Arguments:&n; *   skb - pointer to sk_buff to queue for transmission&n; *   dev - pointer to device information&n; *&n; * Functional Description:&n; *   Here we assume that an incoming skb transmit request&n; *   is contained in a single physically contiguous buffer&n; *   in which the virtual address of the start of packet&n; *   (skb-&gt;data) can be converted to a physical address&n; *   by using pci_map_single().&n; *&n; *   We have an internal queue for packets we can not send &n; *   immediately. Packets in this queue can be given to the &n; *   adapter if transmit buffers are freed.&n; *&n; *   We can&squot;t free the skb until after it&squot;s been DMA&squot;d&n; *   out by the adapter, so we&squot;ll keep it in the driver and&n; *   return it in mac_drv_tx_complete.&n; *&n; * Return Codes:&n; *   0 - driver has queued and/or sent packet&n; *       1 - caller should requeue the sk_buff for later transmission&n; *&n; * Assumptions:&n; *   The entire packet is stored in one physically&n; *   contiguous buffer which is not cached and whose&n; *   32-bit physical address can be determined.&n; *&n; *   It&squot;s vital that this routine is NOT reentered for the&n; *   same board and that the OS is not in another section of&n; *   code (eg. skfp_interrupt) for the same board on a&n; *   different thread.&n; *&n; * Side Effects:&n; *   None&n; */
DECL|function|skfp_send_pkt
r_static
r_int
id|skfp_send_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
id|PRIV
c_func
(paren
id|dev
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;skfp_send_pkt&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that incoming transmit request is OK&n;&t; *&n;&t; * Note: The packet size check is consistent with other&n;&t; *               Linux device drivers, although the correct packet&n;&t; *               size should be verified before calling the&n;&t; *               transmit routine.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb-&gt;len
op_ge
id|FDDI_K_LLC_ZLEN
op_logical_and
id|skb-&gt;len
op_le
id|FDDI_K_LLC_LEN
)paren
)paren
(brace
id|bp-&gt;MacStat.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* bump error counter */
singleline_comment|// dequeue packets from xmt queue and send them
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* return &quot;success&quot; */
)brace
r_if
c_cond
(paren
id|bp-&gt;QueueSkb
op_eq
l_int|0
)paren
(brace
singleline_comment|// return with tbusy set: queue full
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|bp-&gt;QueueSkb
op_decrement
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|bp-&gt;SendSkbQueue
comma
id|skb
)paren
suffix:semicolon
id|send_queued_packets
c_func
(paren
(paren
r_struct
id|s_smc
op_star
)paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;QueueSkb
op_eq
l_int|0
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// skfp_send_pkt
multiline_comment|/*&n; * =======================&n; * = send_queued_packets =&n; * =======================&n; *   &n; * Overview:&n; *   Send packets from the driver queue as long as there are some and&n; *   transmit resources are available.&n; *  &n; * Returns:&n; *   None&n; *       &n; * Arguments:&n; *   smc - pointer to smc (adapter) structure&n; *&n; * Functional Description:&n; *   Take a packet from queue if there is any. If not, then we are done.&n; *   Check if there are resources to send the packet. If not, requeue it&n; *   and exit. &n; *   Set packet descriptor flags and give packet to adapter.&n; *   Check if any send resources can be freed (we do not use the&n; *   transmit complete interrupt).&n; */
DECL|function|send_queued_packets
r_static
r_void
id|send_queued_packets
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
id|fc
suffix:semicolon
r_int
id|queue
suffix:semicolon
r_struct
id|s_smt_fp_txd
op_star
id|txd
suffix:semicolon
singleline_comment|// Current TxD.
id|dma_addr_t
id|dma_address
suffix:semicolon
r_int
r_int
id|Flags
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
singleline_comment|// HWM tx frame status.
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;send queued packets&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
singleline_comment|// send first buffer from queue
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|bp-&gt;SendSkbQueue
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;queue empty&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// queue empty !
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
id|fc
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|queue
op_assign
(paren
id|fc
op_amp
id|FC_SYNC_BIT
)paren
ques
c_cond
id|QUEUE_S
suffix:colon
id|QUEUE_A0
suffix:semicolon
macro_line|#ifdef ESS
singleline_comment|// Check if the frame may/must be sent as a synchronous frame.
r_if
c_cond
(paren
(paren
id|fc
op_amp
op_complement
(paren
id|FC_SYNC_BIT
op_or
id|FC_LLC_PRIOR
)paren
)paren
op_eq
id|FC_ASYNC_LLC
)paren
(brace
singleline_comment|// It&squot;s an LLC frame.
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;ess.sync_bw_available
)paren
id|fc
op_and_assign
op_complement
id|FC_SYNC_BIT
suffix:semicolon
singleline_comment|// No bandwidth available.
r_else
(brace
singleline_comment|// Bandwidth is available.
r_if
c_cond
(paren
id|smc-&gt;mib.fddiESSSynchTxMode
)paren
(brace
singleline_comment|// Send as sync. frame.
id|fc
op_or_assign
id|FC_SYNC_BIT
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// ESS
id|frame_status
op_assign
id|hwm_tx_init
c_func
(paren
id|smc
comma
id|fc
comma
l_int|1
comma
id|skb-&gt;len
comma
id|queue
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|frame_status
op_amp
(paren
id|LOC_TX
op_or
id|LAN_TX
)paren
)paren
op_eq
l_int|0
)paren
(brace
singleline_comment|// Unable to send the frame.
r_if
c_cond
(paren
(paren
id|frame_status
op_amp
id|RING_DOWN
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// Ring is down.
id|PRINTK
c_func
(paren
l_string|&quot;Tx attempt while ring down.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|frame_status
op_amp
id|OUT_OF_TXD
)paren
op_ne
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: out of TXDs.&bslash;n&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: out of transmit resources&quot;
comma
id|bp-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
singleline_comment|// Note: We will retry the operation as soon as
singleline_comment|// transmit resources become available.
id|skb_queue_head
c_func
(paren
op_amp
id|bp-&gt;SendSkbQueue
comma
id|skb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
r_return
suffix:semicolon
singleline_comment|// Packet has been queued.
)brace
singleline_comment|// if (unable to send frame)
id|bp-&gt;QueueSkb
op_increment
suffix:semicolon
singleline_comment|// one packet less in local queue
singleline_comment|// source address in packet ?
id|CheckSourceAddress
c_func
(paren
id|skb-&gt;data
comma
id|smc-&gt;hw.fddi_canon_addr.a
)paren
suffix:semicolon
id|txd
op_assign
(paren
r_struct
id|s_smt_fp_txd
op_star
)paren
id|HWM_GET_CURR_TXD
c_func
(paren
id|smc
comma
id|queue
)paren
suffix:semicolon
id|dma_address
op_assign
id|pci_map_single
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
id|LAN_TX
)paren
(brace
id|txd-&gt;txd_os.skb
op_assign
id|skb
suffix:semicolon
singleline_comment|// save skb
id|txd-&gt;txd_os.dma_addr
op_assign
id|dma_address
suffix:semicolon
singleline_comment|// save dma mapping
)brace
id|hwm_tx_frag
c_func
(paren
id|smc
comma
id|skb-&gt;data
comma
id|dma_address
comma
id|skb-&gt;len
comma
id|frame_status
op_or
id|FIRST_FRAG
op_or
id|LAST_FRAG
op_or
id|EN_IRQ_EOF
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|frame_status
op_amp
id|LAN_TX
)paren
)paren
(brace
singleline_comment|// local only frame
id|pci_unmap_single
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|dma_address
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|bp-&gt;DriverLock
comma
id|Flags
)paren
suffix:semicolon
)brace
singleline_comment|// for
r_return
suffix:semicolon
singleline_comment|// never reached
)brace
singleline_comment|// send_queued_packets
multiline_comment|/************************&n; * &n; * CheckSourceAddress&n; *&n; * Verify if the source address is set. Insert it if necessary.&n; *&n; ************************/
DECL|function|CheckSourceAddress
r_void
id|CheckSourceAddress
c_func
(paren
r_int
r_char
op_star
id|frame
comma
r_int
r_char
op_star
id|hw_addr
)paren
(brace
r_int
r_char
id|SRBit
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|frame
(braket
l_int|1
op_plus
l_int|6
)braket
)paren
op_amp
op_complement
l_int|0x01
)paren
op_ne
l_int|0
)paren
singleline_comment|// source routing bit
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|frame
(braket
l_int|1
op_plus
l_int|10
)braket
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|SRBit
op_assign
id|frame
(braket
l_int|1
op_plus
l_int|6
)braket
op_amp
l_int|0x01
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|frame
(braket
l_int|1
op_plus
l_int|6
)braket
comma
id|hw_addr
comma
l_int|6
)paren
suffix:semicolon
id|frame
(braket
l_int|8
)braket
op_or_assign
id|SRBit
suffix:semicolon
)brace
singleline_comment|// CheckSourceAddress
multiline_comment|/************************&n; *&n; *&t;ResetAdapter&n; *&n; *&t;Reset the adapter and bring it back to operational mode.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|ResetAdapter
r_static
r_void
id|ResetAdapter
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;[fddi: ResetAdapter]&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Stop the adapter.
id|card_stop
c_func
(paren
id|smc
)paren
suffix:semicolon
singleline_comment|// Stop all activity.
singleline_comment|// Clear the transmit and receive descriptor queues.
id|mac_drv_clear_tx_queue
c_func
(paren
id|smc
)paren
suffix:semicolon
id|mac_drv_clear_rx_queue
c_func
(paren
id|smc
)paren
suffix:semicolon
singleline_comment|// Restart the adapter.
id|smt_reset_defaults
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// Initialize the SMT module.
id|init_smt
c_func
(paren
id|smc
comma
(paren
id|smc-&gt;os.dev
)paren
op_member_access_from_pointer
id|dev_addr
)paren
suffix:semicolon
singleline_comment|// Initialize the hardware.
id|smt_online
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// Insert into the ring again.
id|STI_FBI
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// Restore original receive mode (multicasts, promiscuous, etc.).
id|skfp_ctl_set_multicast_list_wo_lock
c_func
(paren
id|smc-&gt;os.dev
)paren
suffix:semicolon
)brace
singleline_comment|// ResetAdapter
singleline_comment|//--------------- functions called by hardware module ----------------
multiline_comment|/************************&n; *&n; *&t;llc_restart_tx&n; *&n; *&t;The hardware driver calls this routine when the transmit complete&n; *&t;interrupt bits (end of frame) for the synchronous or asynchronous&n; *&t;queue is set.&n; *&n; * NOTE The hardware driver calls this function also if no packets are queued.&n; *&t;The routine must be able to handle this case.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|llc_restart_tx
r_void
id|llc_restart_tx
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;[llc_restart_tx]&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Try to send queued packets
id|spin_unlock
c_func
(paren
op_amp
id|bp-&gt;DriverLock
)paren
suffix:semicolon
id|send_queued_packets
c_func
(paren
id|smc
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bp-&gt;DriverLock
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|bp-&gt;dev
)paren
suffix:semicolon
singleline_comment|// system may send again if it was blocked
)brace
singleline_comment|// llc_restart_tx
multiline_comment|/************************&n; *&n; *&t;mac_drv_get_space&n; *&n; *&t;The hardware module calls this function to allocate the memory&n; *&t;for the SMT MBufs if the define MB_OUTSIDE_SMC is specified.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;size - Size of memory in bytes to allocate.&n; * Out&n; *&t;!= 0&t;A pointer to the virtual address of the allocated memory.&n; *&t;== 0&t;Allocation error.&n; *&n; ************************/
DECL|function|mac_drv_get_space
r_void
op_star
id|mac_drv_get_space
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|virt
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;mac_drv_get_space (%d bytes), &quot;
comma
id|size
)paren
suffix:semicolon
id|virt
op_assign
(paren
r_void
op_star
)paren
(paren
id|smc-&gt;os.SharedMemAddr
op_plus
id|smc-&gt;os.SharedMemHeap
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|smc-&gt;os.SharedMemHeap
op_plus
id|size
)paren
OG
id|smc-&gt;os.SharedMemSize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unexpected SMT memory size requested: %d&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|smc-&gt;os.SharedMemHeap
op_add_assign
id|size
suffix:semicolon
singleline_comment|// Move heap pointer.
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;mac_drv_get_space end&bslash;n&quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;virt addr: %lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|virt
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;bus  addr: %lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
(paren
id|smc-&gt;os.SharedMemDMA
op_plus
(paren
(paren
r_char
op_star
)paren
id|virt
op_minus
(paren
r_char
op_star
)paren
id|smc-&gt;os.SharedMemAddr
)paren
)paren
)paren
suffix:semicolon
r_return
(paren
id|virt
)paren
suffix:semicolon
)brace
singleline_comment|// mac_drv_get_space
multiline_comment|/************************&n; *&n; *&t;mac_drv_get_desc_mem&n; *&n; *&t;This function is called by the hardware dependent module.&n; *&t;It allocates the memory for the RxD and TxD descriptors.&n; *&n; *&t;This memory must be non-cached, non-movable and non-swapable.&n; *&t;This memory should start at a physical page boundary.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;size - Size of memory in bytes to allocate.&n; * Out&n; *&t;!= 0&t;A pointer to the virtual address of the allocated memory.&n; *&t;== 0&t;Allocation error.&n; *&n; ************************/
DECL|function|mac_drv_get_desc_mem
r_void
op_star
id|mac_drv_get_desc_mem
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
r_int
id|size
)paren
(brace
r_char
op_star
id|virt
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;mac_drv_get_desc_mem&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Descriptor memory must be aligned on 16-byte boundary.
id|virt
op_assign
id|mac_drv_get_space
c_func
(paren
id|smc
comma
id|size
)paren
suffix:semicolon
id|size
op_assign
(paren
id|u_int
)paren
(paren
l_int|16
op_minus
(paren
(paren
(paren
r_int
r_int
)paren
id|virt
)paren
op_amp
l_int|15UL
)paren
)paren
suffix:semicolon
id|size
op_assign
id|size
op_mod
l_int|16
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Allocate %u bytes alignment gap &quot;
comma
id|size
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;for descriptor memory.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mac_drv_get_space
c_func
(paren
id|smc
comma
id|size
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fddi: Unable to align descriptor memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
(paren
id|virt
op_plus
id|size
)paren
suffix:semicolon
)brace
singleline_comment|// mac_drv_get_desc_mem
multiline_comment|/************************&n; *&n; *&t;mac_drv_virt2phys&n; *&n; *&t;Get the physical address of a given virtual address.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;virt - A (virtual) pointer into our &squot;shared&squot; memory area.&n; * Out&n; *&t;Physical address of the given virtual address.&n; *&n; ************************/
DECL|function|mac_drv_virt2phys
r_int
r_int
id|mac_drv_virt2phys
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_void
op_star
id|virt
)paren
(brace
r_return
(paren
id|smc-&gt;os.SharedMemDMA
op_plus
(paren
(paren
r_char
op_star
)paren
id|virt
op_minus
(paren
r_char
op_star
)paren
id|smc-&gt;os.SharedMemAddr
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// mac_drv_virt2phys
multiline_comment|/************************&n; *&n; *&t;dma_master&n; *&n; *&t;The HWM calls this function, when the driver leads through a DMA&n; *&t;transfer. If the OS-specific module must prepare the system hardware&n; *&t;for the DMA transfer, it should do it in this function.&n; *&n; *&t;The hardware module calls this dma_master if it wants to send an SMT&n; *&t;frame.  This means that the virt address passed in here is part of&n; *      the &squot;shared&squot; memory area.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;virt - The virtual address of the data.&n; *&n; *&t;len - The length in bytes of the data.&n; *&n; *&t;flag - Indicates the transmit direction and the buffer type:&n; *&t;&t;DMA_RD&t;(0x01)&t;system RAM ==&gt; adapter buffer memory&n; *&t;&t;DMA_WR&t;(0x02)&t;adapter buffer memory ==&gt; system RAM&n; *&t;&t;SMT_BUF (0x80)&t;SMT buffer&n; *&n; *&t;&gt;&gt; NOTE: SMT_BUF and DMA_RD are always set for PCI. &lt;&lt;&n; * Out&n; *&t;Returns the pyhsical address for the DMA transfer.&n; *&n; ************************/
DECL|function|dma_master
id|u_long
id|dma_master
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_void
op_star
id|virt
comma
r_int
id|len
comma
r_int
id|flag
)paren
(brace
r_return
(paren
id|smc-&gt;os.SharedMemDMA
op_plus
(paren
(paren
r_char
op_star
)paren
id|virt
op_minus
(paren
r_char
op_star
)paren
id|smc-&gt;os.SharedMemAddr
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// dma_master
multiline_comment|/************************&n; *&n; *&t;dma_complete&n; *&n; *&t;The hardware module calls this routine when it has completed a DMA&n; *&t;transfer. If the operating system dependant module has set up the DMA&n; *&t;channel via dma_master() (e.g. Windows NT or AIX) it should clean up&n; *&t;the DMA channel.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;descr - A pointer to a TxD or RxD, respectively.&n; *&n; *&t;flag - Indicates the DMA transfer direction / SMT buffer:&n; *&t;&t;DMA_RD&t;(0x01)&t;system RAM ==&gt; adapter buffer memory&n; *&t;&t;DMA_WR&t;(0x02)&t;adapter buffer memory ==&gt; system RAM&n; *&t;&t;SMT_BUF (0x80)&t;SMT buffer (managed by HWM)&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|dma_complete
r_void
id|dma_complete
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_union
id|s_fp_descr
op_star
id|descr
comma
r_int
id|flag
)paren
(brace
multiline_comment|/* For TX buffers, there are two cases.  If it is an SMT transmit&n;&t; * buffer, there is nothing to do since we use consistent memory&n;&t; * for the &squot;shared&squot; memory area.  The other case is for normal&n;&t; * transmit packets given to us by the networking stack, and in&n;&t; * that case we cleanup the PCI DMA mapping in mac_drv_tx_complete&n;&t; * below.&n;&t; *&n;&t; * For RX buffers, we have to unmap dynamic PCI DMA mappings here&n;&t; * because the hardware module is about to potentially look at&n;&t; * the contents of the buffer.  If we did not call the PCI DMA&n;&t; * unmap first, the hardware module could read inconsistent data.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DMA_WR
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
suffix:semicolon
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|r
op_assign
op_amp
id|descr-&gt;r
suffix:semicolon
multiline_comment|/* If SKB is NULL, we used the local buffer. */
r_if
c_cond
(paren
id|r-&gt;rxd_os.skb
op_logical_and
id|r-&gt;rxd_os.dma_addr
)paren
(brace
r_int
id|MaxFrameSize
op_assign
id|bp-&gt;MaxFrameSize
suffix:semicolon
id|pci_unmap_single
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|r-&gt;rxd_os.dma_addr
comma
id|MaxFrameSize
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|r-&gt;rxd_os.dma_addr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// dma_complete
multiline_comment|/************************&n; *&n; *&t;mac_drv_tx_complete&n; *&n; *&t;Transmit of a packet is complete. Release the tx staging buffer.&n; *&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;txd - A pointer to the last TxD which is used by the frame.&n; * Out&n; *&t;Returns nothing.&n; *&n; ************************/
DECL|function|mac_drv_tx_complete
r_void
id|mac_drv_tx_complete
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_txd
op_star
id|txd
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering mac_drv_tx_complete&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Check if this TxD points to a skb
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|txd-&gt;txd_os.skb
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;TXD with no skb assigned.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|txd-&gt;txd_os.skb
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// release the DMA mapping
id|pci_unmap_single
c_func
(paren
op_amp
id|smc-&gt;os.pdev
comma
id|txd-&gt;txd_os.dma_addr
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|txd-&gt;txd_os.dma_addr
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;os.MacStat.tx_packets
op_increment
suffix:semicolon
singleline_comment|// Count transmitted packets.
id|smc-&gt;os.MacStat.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
singleline_comment|// Count bytes
singleline_comment|// free the skb
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;leaving mac_drv_tx_complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// mac_drv_tx_complete
multiline_comment|/************************&n; *&n; * dump packets to logfile&n; *&n; ************************/
macro_line|#ifdef DUMPPACKETS
DECL|function|dump_data
r_void
id|dump_data
c_func
(paren
r_int
r_char
op_star
id|Data
comma
r_int
id|length
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_char
id|s
(braket
l_int|255
)braket
comma
id|sh
(braket
l_int|10
)braket
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|64
)paren
(brace
id|length
op_assign
l_int|64
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;---Packet start---&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
op_div
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
l_int|8
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%02x %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|Data
(braket
id|j
op_plus
l_int|0
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|1
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|2
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|3
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|4
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|5
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|6
)braket
comma
id|Data
(braket
id|j
op_plus
l_int|7
)braket
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
op_mod
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|sh
comma
l_string|&quot;%02x &quot;
comma
id|Data
(braket
id|j
op_plus
id|i
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|s
comma
id|sh
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// dump_data
macro_line|#else
DECL|macro|dump_data
mdefine_line|#define dump_data(data,len)
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// DUMPPACKETS
multiline_comment|/************************&n; *&n; *&t;mac_drv_rx_complete&n; *&n; *&t;The hardware module calls this function if an LLC frame is received&n; *&t;in a receive buffer. Also the SMT, NSA, and directed beacon frames&n; *&t;from the network will be passed to the LLC layer by this function&n; *&t;if passing is enabled.&n; *&n; *&t;mac_drv_rx_complete forwards the frame to the LLC layer if it should&n; *&t;be received. It also fills the RxD ring with new receive buffers if&n; *&t;some can be queued.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;rxd - A pointer to the first RxD which is used by the receive frame.&n; *&n; *&t;frag_count - Count of RxDs used by the received frame.&n; *&n; *&t;len - Frame length.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|mac_drv_rx_complete
r_void
id|mac_drv_rx_complete
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
comma
r_int
id|frag_count
comma
r_int
id|len
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|virt
comma
op_star
id|cp
suffix:semicolon
r_int
r_int
id|ri
suffix:semicolon
id|u_int
id|RifLength
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering mac_drv_rx_complete (len=%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag_count
op_ne
l_int|1
)paren
(brace
singleline_comment|// This is not allowed to happen.
id|printk
c_func
(paren
l_string|&quot;fddi: Multi-fragment receive!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|RequeueRxd
suffix:semicolon
singleline_comment|// Re-use the given RXD(s).
)brace
id|skb
op_assign
id|rxd-&gt;rxd_os.skb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;No skb in rxd&bslash;n&quot;
)paren
suffix:semicolon
id|smc-&gt;os.MacStat.rx_errors
op_increment
suffix:semicolon
r_goto
id|RequeueRxd
suffix:semicolon
)brace
id|virt
op_assign
id|skb-&gt;data
suffix:semicolon
singleline_comment|// The DMA mapping was released in dma_complete above.
id|dump_data
c_func
(paren
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FDDI Frame format:&n;&t; * +-------+-------+-------+------------+--------+------------+&n;&t; * | FC[1] | DA[6] | SA[6] | RIF[0..18] | LLC[3] | Data[0..n] |&n;&t; * +-------+-------+-------+------------+--------+------------+&n;&t; *&n;&t; * FC = Frame Control&n;&t; * DA = Destination Address&n;&t; * SA = Source Address&n;&t; * RIF = Routing Information Field&n;&t; * LLC = Logical Link Control&n;&t; */
singleline_comment|// Remove Routing Information Field (RIF), if present.
r_if
c_cond
(paren
(paren
id|virt
(braket
l_int|1
op_plus
l_int|6
)braket
op_amp
id|FDDI_RII
)paren
op_eq
l_int|0
)paren
id|RifLength
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_int
id|n
suffix:semicolon
singleline_comment|// goos: RIF removal has still to be tested
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;RIF found&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Get RIF length from Routing Control (RC) field.
id|cp
op_assign
id|virt
op_plus
id|FDDI_MAC_HDR_LEN
suffix:semicolon
singleline_comment|// Point behind MAC header.
id|ri
op_assign
id|ntohs
c_func
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|cp
)paren
)paren
suffix:semicolon
id|RifLength
op_assign
id|ri
op_amp
id|FDDI_RCF_LEN_MASK
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
(paren
r_int
)paren
(paren
id|FDDI_MAC_HDR_LEN
op_plus
id|RifLength
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fddi: Invalid RIF.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|RequeueRxd
suffix:semicolon
singleline_comment|// Discard the frame.
)brace
id|virt
(braket
l_int|1
op_plus
l_int|6
)braket
op_and_assign
op_complement
id|FDDI_RII
suffix:semicolon
singleline_comment|// Clear RII bit.
singleline_comment|// regions overlap
id|virt
op_assign
id|cp
op_plus
id|RifLength
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|FDDI_MAC_HDR_LEN
suffix:semicolon
id|n
suffix:semicolon
id|n
op_decrement
)paren
op_star
op_decrement
id|virt
op_assign
op_star
op_decrement
id|cp
suffix:semicolon
singleline_comment|// adjust sbd-&gt;data pointer
id|skb_pull
c_func
(paren
id|skb
comma
id|RifLength
)paren
suffix:semicolon
id|len
op_sub_assign
id|RifLength
suffix:semicolon
id|RifLength
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// Count statistics.
id|smc-&gt;os.MacStat.rx_packets
op_increment
suffix:semicolon
singleline_comment|// Count indicated receive packets.
id|smc-&gt;os.MacStat.rx_bytes
op_add_assign
id|len
suffix:semicolon
singleline_comment|// Count bytes
singleline_comment|// virt points to header again
r_if
c_cond
(paren
id|virt
(braket
l_int|1
)braket
op_amp
l_int|0x01
)paren
(brace
singleline_comment|// Check group (multicast) bit.
id|smc-&gt;os.MacStat.multicast
op_increment
suffix:semicolon
)brace
singleline_comment|// deliver frame to system
id|rxd-&gt;rxd_os.skb
op_assign
l_int|NULL
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|fddi_type_trans
c_func
(paren
id|skb
comma
id|bp-&gt;dev
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|bp-&gt;dev
suffix:semicolon
multiline_comment|/* pass up device pointer */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|HWM_RX_CHECK
c_func
(paren
id|smc
comma
id|RX_LOW_WATERMARK
)paren
suffix:semicolon
r_return
suffix:semicolon
id|RequeueRxd
suffix:colon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Rx: re-queue RXD.&bslash;n&quot;
)paren
suffix:semicolon
id|mac_drv_requeue_rxd
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
)paren
suffix:semicolon
id|smc-&gt;os.MacStat.rx_errors
op_increment
suffix:semicolon
singleline_comment|// Count receive packets not indicated.
)brace
singleline_comment|// mac_drv_rx_complete
multiline_comment|/************************&n; *&n; *&t;mac_drv_requeue_rxd&n; *&n; *&t;The hardware module calls this function to request the OS-specific&n; *&t;module to queue the receive buffer(s) represented by the pointer&n; *&t;to the RxD and the frag_count into the receive queue again. This&n; *&t;buffer was filled with an invalid frame or an SMT frame.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;rxd - A pointer to the first RxD which is used by the receive frame.&n; *&n; *&t;frag_count - Count of RxDs used by the received frame.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|mac_drv_requeue_rxd
r_void
id|mac_drv_requeue_rxd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
comma
r_int
id|frag_count
)paren
(brace
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|next_rxd
suffix:semicolon
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|src_rxd
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|MaxFrameSize
suffix:semicolon
r_int
r_char
op_star
id|v_addr
suffix:semicolon
id|dma_addr_t
id|b_addr
suffix:semicolon
r_if
c_cond
(paren
id|frag_count
op_ne
l_int|1
)paren
singleline_comment|// This is not allowed to happen.
id|printk
c_func
(paren
l_string|&quot;fddi: Multi-fragment requeue!&bslash;n&quot;
)paren
suffix:semicolon
id|MaxFrameSize
op_assign
(paren
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
)paren
op_member_access_from_pointer
id|MaxFrameSize
suffix:semicolon
id|src_rxd
op_assign
id|rxd
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|frag_count
OG
l_int|0
suffix:semicolon
id|frag_count
op_decrement
)paren
(brace
id|next_rxd
op_assign
id|src_rxd-&gt;rxd_next
suffix:semicolon
id|rxd
op_assign
id|HWM_GET_CURR_RXD
c_func
(paren
id|smc
)paren
suffix:semicolon
id|skb
op_assign
id|src_rxd-&gt;rxd_os.skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
singleline_comment|// this should not happen
id|PRINTK
c_func
(paren
l_string|&quot;Requeue with no skb in rxd!&bslash;n&quot;
)paren
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|MaxFrameSize
op_plus
l_int|3
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
singleline_comment|// we got a skb
id|rxd-&gt;rxd_os.skb
op_assign
id|skb
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|MaxFrameSize
)paren
suffix:semicolon
id|v_addr
op_assign
id|skb-&gt;data
suffix:semicolon
id|b_addr
op_assign
id|pci_map_single
c_func
(paren
op_amp
id|smc-&gt;os.pdev
comma
id|v_addr
comma
id|MaxFrameSize
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|rxd-&gt;rxd_os.dma_addr
op_assign
id|b_addr
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// no skb available, use local buffer
id|PRINTK
c_func
(paren
l_string|&quot;Queueing invalid buffer!&bslash;n&quot;
)paren
suffix:semicolon
id|rxd-&gt;rxd_os.skb
op_assign
l_int|NULL
suffix:semicolon
id|v_addr
op_assign
id|smc-&gt;os.LocalRxBuffer
suffix:semicolon
id|b_addr
op_assign
id|smc-&gt;os.LocalRxBufferDMA
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// we use skb from old rxd
id|rxd-&gt;rxd_os.skb
op_assign
id|skb
suffix:semicolon
id|v_addr
op_assign
id|skb-&gt;data
suffix:semicolon
id|b_addr
op_assign
id|pci_map_single
c_func
(paren
op_amp
id|smc-&gt;os.pdev
comma
id|v_addr
comma
id|MaxFrameSize
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|rxd-&gt;rxd_os.dma_addr
op_assign
id|b_addr
suffix:semicolon
)brace
id|hwm_rx_frag
c_func
(paren
id|smc
comma
id|v_addr
comma
id|b_addr
comma
id|MaxFrameSize
comma
id|FIRST_FRAG
op_or
id|LAST_FRAG
)paren
suffix:semicolon
id|src_rxd
op_assign
id|next_rxd
suffix:semicolon
)brace
)brace
singleline_comment|// mac_drv_requeue_rxd
multiline_comment|/************************&n; *&n; *&t;mac_drv_fill_rxd&n; *&n; *&t;The hardware module calls this function at initialization time&n; *&t;to fill the RxD ring with receive buffers. It is also called by&n; *&t;mac_drv_rx_complete if rx_free is large enough to queue some new&n; *&t;receive buffers into the RxD ring. mac_drv_fill_rxd queues new&n; *&t;receive buffers as long as enough RxDs and receive buffers are&n; *&t;available.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|mac_drv_fill_rxd
r_void
id|mac_drv_fill_rxd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
(brace
r_int
id|MaxFrameSize
suffix:semicolon
r_int
r_char
op_star
id|v_addr
suffix:semicolon
r_int
r_int
id|b_addr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering mac_drv_fill_rxd&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Walk through the list of free receive buffers, passing receive
singleline_comment|// buffers to the HWM as long as RXDs are available.
id|MaxFrameSize
op_assign
(paren
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
)paren
op_member_access_from_pointer
id|MaxFrameSize
suffix:semicolon
singleline_comment|// Check if there is any RXD left.
r_while
c_loop
(paren
id|HWM_GET_RX_FREE
c_func
(paren
id|smc
)paren
OG
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|rxd
op_assign
id|HWM_GET_CURR_RXD
c_func
(paren
id|smc
)paren
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|MaxFrameSize
op_plus
l_int|3
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
singleline_comment|// we got a skb
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|MaxFrameSize
)paren
suffix:semicolon
id|v_addr
op_assign
id|skb-&gt;data
suffix:semicolon
id|b_addr
op_assign
id|pci_map_single
c_func
(paren
op_amp
id|smc-&gt;os.pdev
comma
id|v_addr
comma
id|MaxFrameSize
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|rxd-&gt;rxd_os.dma_addr
op_assign
id|b_addr
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// no skb available, use local buffer
singleline_comment|// System has run out of buffer memory, but we want to
singleline_comment|// keep the receiver running in hope of better times.
singleline_comment|// Multiple descriptors may point to this local buffer,
singleline_comment|// so data in it must be considered invalid.
id|PRINTK
c_func
(paren
l_string|&quot;Queueing invalid buffer!&bslash;n&quot;
)paren
suffix:semicolon
id|v_addr
op_assign
id|smc-&gt;os.LocalRxBuffer
suffix:semicolon
id|b_addr
op_assign
id|smc-&gt;os.LocalRxBufferDMA
suffix:semicolon
)brace
id|rxd-&gt;rxd_os.skb
op_assign
id|skb
suffix:semicolon
singleline_comment|// Pass receive buffer to HWM.
id|hwm_rx_frag
c_func
(paren
id|smc
comma
id|v_addr
comma
id|b_addr
comma
id|MaxFrameSize
comma
id|FIRST_FRAG
op_or
id|LAST_FRAG
)paren
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;leaving mac_drv_fill_rxd&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// mac_drv_fill_rxd
multiline_comment|/************************&n; *&n; *&t;mac_drv_clear_rxd&n; *&n; *&t;The hardware module calls this function to release unused&n; *&t;receive buffers.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;rxd - A pointer to the first RxD which is used by the receive buffer.&n; *&n; *&t;frag_count - Count of RxDs used by the receive buffer.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|mac_drv_clear_rxd
r_void
id|mac_drv_clear_rxd
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_volatile
r_struct
id|s_smt_fp_rxd
op_star
id|rxd
comma
r_int
id|frag_count
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;entering mac_drv_clear_rxd&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag_count
op_ne
l_int|1
)paren
singleline_comment|// This is not allowed to happen.
id|printk
c_func
(paren
l_string|&quot;fddi: Multi-fragment clear!&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|frag_count
OG
l_int|0
suffix:semicolon
id|frag_count
op_decrement
)paren
(brace
id|skb
op_assign
id|rxd-&gt;rxd_os.skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skfddi_priv
op_star
id|bp
op_assign
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
suffix:semicolon
r_int
id|MaxFrameSize
op_assign
id|bp-&gt;MaxFrameSize
suffix:semicolon
id|pci_unmap_single
c_func
(paren
op_amp
id|bp-&gt;pdev
comma
id|rxd-&gt;rxd_os.dma_addr
comma
id|MaxFrameSize
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|rxd-&gt;rxd_os.skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|rxd
op_assign
id|rxd-&gt;rxd_next
suffix:semicolon
singleline_comment|// Next RXD.
)brace
)brace
singleline_comment|// mac_drv_clear_rxd
multiline_comment|/************************&n; *&n; *&t;mac_drv_rx_init&n; *&n; *&t;The hardware module calls this routine when an SMT or NSA frame of the&n; *&t;local SMT should be delivered to the LLC layer.&n; *&n; *&t;It is necessary to have this function, because there is no other way to&n; *&t;copy the contents of SMT MBufs into receive buffers.&n; *&n; *&t;mac_drv_rx_init allocates the required target memory for this frame,&n; *&t;and receives the frame fragment by fragment by calling mac_drv_rx_frag.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;len - The length (in bytes) of the received frame (FC, DA, SA, Data).&n; *&n; *&t;fc - The Frame Control field of the received frame.&n; *&n; *&t;look_ahead - A pointer to the lookahead data buffer (may be NULL).&n; *&n; *&t;la_len - The length of the lookahead data stored in the lookahead&n; *&t;buffer (may be zero).&n; * Out&n; *&t;Always returns zero (0).&n; *&n; ************************/
DECL|function|mac_drv_rx_init
r_int
id|mac_drv_rx_init
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|len
comma
r_int
id|fc
comma
r_char
op_star
id|look_ahead
comma
r_int
id|la_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;entering mac_drv_rx_init(len=%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
singleline_comment|// &quot;Received&quot; a SMT or NSA frame of the local SMT.
r_if
c_cond
(paren
id|len
op_ne
id|la_len
op_logical_or
id|len
OL
id|FDDI_MAC_HDR_LEN
op_logical_or
op_logical_neg
id|look_ahead
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;fddi: Discard invalid local SMT frame&bslash;n&quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;  len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.&bslash;n&quot;
comma
id|len
comma
id|la_len
comma
(paren
r_int
r_int
)paren
id|look_ahead
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|len
op_plus
l_int|3
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;fddi: Local SMT: skb memory exhausted.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|3
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|look_ahead
comma
id|len
)paren
suffix:semicolon
singleline_comment|// deliver frame to system
id|skb-&gt;protocol
op_assign
id|fddi_type_trans
c_func
(paren
id|skb
comma
(paren
(paren
id|skfddi_priv
op_star
)paren
op_amp
id|smc-&gt;os
)paren
op_member_access_from_pointer
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|// mac_drv_rx_init
multiline_comment|/************************&n; *&n; *&t;smt_timer_poll&n; *&n; *&t;This routine is called periodically by the SMT module to clean up the&n; *&t;driver.&n; *&n; *&t;Return any queued frames back to the upper protocol layers if the ring&n; *&t;is down.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|smt_timer_poll
r_void
id|smt_timer_poll
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
(brace
)brace
singleline_comment|// smt_timer_poll
multiline_comment|/************************&n; *&n; *&t;ring_status_indication&n; *&n; *&t;This function indicates a change of the ring state.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;status - The current ring status.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|ring_status_indication
r_void
id|ring_status_indication
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
id|u_long
id|status
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;ring_status_indication( &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_RES15
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_RES15 &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_HARDERROR
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_HARDERROR &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_SOFTERROR
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_SOFTERROR &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_BEACON
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_BEACON &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_PATHTEST
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_PATHTEST &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_SELFTEST
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_SELFTEST &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_RES9
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_RES9 &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_DISCONNECT
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_DISCONNECT &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_RES7
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_RES7 &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_DUPADDR
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_DUPADDR &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_NORINGOP
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_NORINGOP &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_VERSION
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_VERSION &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_STUCKBYPASSS
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_STUCKBYPASSS &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_EVENT
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_EVENT &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_RINGOPCHANGE
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_RINGOPCHANGE &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_RES0
)paren
id|PRINTK
c_func
(paren
l_string|&quot;RS_RES0 &quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// ring_status_indication
multiline_comment|/************************&n; *&n; *&t;smt_get_time&n; *&n; *&t;Gets the current time from the system.&n; * Args&n; *&t;None.&n; * Out&n; *&t;The current time in TICKS_PER_SECOND.&n; *&n; *&t;TICKS_PER_SECOND has the unit &squot;count of timer ticks per second&squot;. It is&n; *&t;defined in &quot;targetos.h&quot;. The definition of TICKS_PER_SECOND must comply&n; *&t;to the time returned by smt_get_time().&n; *&n; ************************/
DECL|function|smt_get_time
r_int
r_int
id|smt_get_time
c_func
(paren
r_void
)paren
(brace
r_return
id|jiffies
suffix:semicolon
)brace
singleline_comment|// smt_get_time
multiline_comment|/************************&n; *&n; *&t;smt_stat_counter&n; *&n; *&t;Status counter update (ring_op, fifo full).&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;stat -&t;= 0: A ring operational change occurred.&n; *&t;&t;= 1: The FORMAC FIFO buffer is full / FIFO overflow.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|smt_stat_counter
r_void
id|smt_stat_counter
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|stat
)paren
(brace
singleline_comment|//      BOOLEAN RingIsUp ;
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;smt_stat_counter&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|stat
)paren
(brace
r_case
l_int|0
suffix:colon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Ring operational change.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Receive fifo overflow.&bslash;n&quot;
)paren
suffix:semicolon
id|smc-&gt;os.MacStat.rx_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Unknown status (%d).&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
singleline_comment|// smt_stat_counter
multiline_comment|/************************&n; *&n; *&t;cfm_state_change&n; *&n; *&t;Sets CFM state in custom statistics.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;c_state - Possible values are:&n; *&n; *&t;&t;EC0_OUT, EC1_IN, EC2_TRACE, EC3_LEAVE, EC4_PATH_TEST,&n; *&t;&t;EC5_INSERT, EC6_CHECK, EC7_DEINSERT&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|cfm_state_change
r_void
id|cfm_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|c_state
)paren
(brace
macro_line|#ifdef DRIVERDEBUG
r_char
op_star
id|s
suffix:semicolon
r_switch
c_cond
(paren
id|c_state
)paren
(brace
r_case
id|SC0_ISOLATED
suffix:colon
id|s
op_assign
l_string|&quot;SC0_ISOLATED&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC1_WRAP_A
suffix:colon
id|s
op_assign
l_string|&quot;SC1_WRAP_A&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC2_WRAP_B
suffix:colon
id|s
op_assign
l_string|&quot;SC2_WRAP_B&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC4_THRU_A
suffix:colon
id|s
op_assign
l_string|&quot;SC4_THRU_A&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC5_THRU_B
suffix:colon
id|s
op_assign
l_string|&quot;SC5_THRU_B&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC7_WRAP_S
suffix:colon
id|s
op_assign
l_string|&quot;SC7_WRAP_S&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC9_C_WRAP_A
suffix:colon
id|s
op_assign
l_string|&quot;SC9_C_WRAP_A&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC10_C_WRAP_B
suffix:colon
id|s
op_assign
l_string|&quot;SC10_C_WRAP_B&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC11_C_WRAP_S
suffix:colon
id|s
op_assign
l_string|&quot;SC11_C_WRAP_S&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;cfm_state_change: unknown %d&bslash;n&quot;
comma
id|c_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;cfm_state_change: %s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// DRIVERDEBUG
)brace
singleline_comment|// cfm_state_change
multiline_comment|/************************&n; *&n; *&t;ecm_state_change&n; *&n; *&t;Sets ECM state in custom statistics.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;e_state - Possible values are:&n; *&n; *&t;&t;SC0_ISOLATED, SC1_WRAP_A (5), SC2_WRAP_B (6), SC4_THRU_A (12),&n; *&t;&t;SC5_THRU_B (7), SC7_WRAP_S (8)&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|ecm_state_change
r_void
id|ecm_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|e_state
)paren
(brace
macro_line|#ifdef DRIVERDEBUG
r_char
op_star
id|s
suffix:semicolon
r_switch
c_cond
(paren
id|e_state
)paren
(brace
r_case
id|EC0_OUT
suffix:colon
id|s
op_assign
l_string|&quot;EC0_OUT&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC1_IN
suffix:colon
id|s
op_assign
l_string|&quot;EC1_IN&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC2_TRACE
suffix:colon
id|s
op_assign
l_string|&quot;EC2_TRACE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC3_LEAVE
suffix:colon
id|s
op_assign
l_string|&quot;EC3_LEAVE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC4_PATH_TEST
suffix:colon
id|s
op_assign
l_string|&quot;EC4_PATH_TEST&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC5_INSERT
suffix:colon
id|s
op_assign
l_string|&quot;EC5_INSERT&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC6_CHECK
suffix:colon
id|s
op_assign
l_string|&quot;EC6_CHECK&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EC7_DEINSERT
suffix:colon
id|s
op_assign
l_string|&quot;EC7_DEINSERT&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|s
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;ecm_state_change: %s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
singleline_comment|//DRIVERDEBUG
)brace
singleline_comment|// ecm_state_change
multiline_comment|/************************&n; *&n; *&t;rmt_state_change&n; *&n; *&t;Sets RMT state in custom statistics.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; *&n; *&t;r_state - Possible values are:&n; *&n; *&t;&t;RM0_ISOLATED, RM1_NON_OP, RM2_RING_OP, RM3_DETECT,&n; *&t;&t;RM4_NON_OP_DUP, RM5_RING_OP_DUP, RM6_DIRECTED, RM7_TRACE&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|rmt_state_change
r_void
id|rmt_state_change
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
comma
r_int
id|r_state
)paren
(brace
macro_line|#ifdef DRIVERDEBUG
r_char
op_star
id|s
suffix:semicolon
r_switch
c_cond
(paren
id|r_state
)paren
(brace
r_case
id|RM0_ISOLATED
suffix:colon
id|s
op_assign
l_string|&quot;RM0_ISOLATED&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM1_NON_OP
suffix:colon
id|s
op_assign
l_string|&quot;RM1_NON_OP - not operational&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM2_RING_OP
suffix:colon
id|s
op_assign
l_string|&quot;RM2_RING_OP - ring operational&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM3_DETECT
suffix:colon
id|s
op_assign
l_string|&quot;RM3_DETECT - detect dupl addresses&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM4_NON_OP_DUP
suffix:colon
id|s
op_assign
l_string|&quot;RM4_NON_OP_DUP - dupl. addr detected&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM5_RING_OP_DUP
suffix:colon
id|s
op_assign
l_string|&quot;RM5_RING_OP_DUP - ring oper. with dupl. addr&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM6_DIRECTED
suffix:colon
id|s
op_assign
l_string|&quot;RM6_DIRECTED - sending directed beacons&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RM7_TRACE
suffix:colon
id|s
op_assign
l_string|&quot;RM7_TRACE - trace initiated&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|s
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;[rmt_state_change: %s]&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// DRIVERDEBUG
)brace
singleline_comment|// rmt_state_change
multiline_comment|/************************&n; *&n; *&t;drv_reset_indication&n; *&n; *&t;This function is called by the SMT when it has detected a severe&n; *&t;hardware problem. The driver should perform a reset on the adapter&n; *&t;as soon as possible, but not from within this function.&n; * Args&n; *&t;smc - A pointer to the SMT context struct.&n; * Out&n; *&t;Nothing.&n; *&n; ************************/
DECL|function|drv_reset_indication
r_void
id|drv_reset_indication
c_func
(paren
r_struct
id|s_smc
op_star
id|smc
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;entering drv_reset_indication&bslash;n&quot;
)paren
suffix:semicolon
id|smc-&gt;os.ResetRequested
op_assign
id|TRUE
suffix:semicolon
singleline_comment|// Set flag.
)brace
singleline_comment|// drv_reset_indication
singleline_comment|//--------------- functions for use as a module ----------------
macro_line|#ifdef MODULE
multiline_comment|/************************&n; *&n; * Note now that module autoprobing is allowed under PCI. The&n; * IRQ lines will not be auto-detected; instead I&squot;ll rely on the BIOSes&n; * to &quot;do the right thing&quot;.&n; *&n; ************************/
DECL|macro|LP
mdefine_line|#define LP(a) ((struct s_smc*)(a))
DECL|variable|mdev
r_static
r_struct
id|net_device
op_star
id|mdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/************************&n; *&n; * init_module&n; *&n; *  If compiled as a module, find&n; *  adapters and initialize them.&n; *&n; ************************/
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|p
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;FDDI init module&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mdev
op_assign
id|insert_device
c_func
(paren
l_int|NULL
comma
id|skfp_probe
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|mdev
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
id|LP
c_func
(paren
id|p-&gt;priv
)paren
op_member_access_from_pointer
id|os.next_module
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;device to register: %s&bslash;n&quot;
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|p
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skfddi init_module failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;+++++ exit with success +++++&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// init_module
multiline_comment|/************************&n; *&n; * cleanup_module&n; *&n; *  Release all resources claimed by this module.&n; *&n; ************************/
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;cleanup_module&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mdev
op_ne
l_int|NULL
)paren
(brace
id|mdev
op_assign
id|unlink_modules
c_func
(paren
id|mdev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
singleline_comment|// cleanup_module
multiline_comment|/************************&n; *&n; * unlink_modules&n; *&n; *  Unregister devices and release their memory.&n; *&n; ************************/
DECL|function|unlink_modules
r_static
r_struct
id|net_device
op_star
id|unlink_modules
c_func
(paren
r_struct
id|net_device
op_star
id|p
)paren
(brace
r_struct
id|net_device
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;priv
)paren
(brace
multiline_comment|/* Private areas allocated? */
r_struct
id|s_smc
op_star
id|lp
op_assign
(paren
r_struct
id|s_smc
op_star
)paren
id|p-&gt;priv
suffix:semicolon
id|next
op_assign
id|lp-&gt;os.next_module
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;os.SharedMemAddr
)paren
(brace
id|pci_free_consistent
c_func
(paren
op_amp
id|lp-&gt;os.pdev
comma
id|lp-&gt;os.SharedMemSize
comma
id|lp-&gt;os.SharedMemAddr
comma
id|lp-&gt;os.SharedMemDMA
)paren
suffix:semicolon
id|lp-&gt;os.SharedMemAddr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;os.LocalRxBuffer
)paren
(brace
id|pci_free_consistent
c_func
(paren
op_amp
id|lp-&gt;os.pdev
comma
id|MAX_FRAME_SIZE
comma
id|lp-&gt;os.LocalRxBuffer
comma
id|lp-&gt;os.LocalRxBufferDMA
)paren
suffix:semicolon
id|lp-&gt;os.LocalRxBuffer
op_assign
l_int|NULL
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|p-&gt;base_addr
comma
(paren
id|lp-&gt;os.bus_type
op_eq
id|SK_BUS_TYPE_PCI
ques
c_cond
id|FP_IO_LEN
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|unregister_netdev
c_func
(paren
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: unloaded&bslash;n&quot;
comma
id|p-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Free the device structure */
r_return
id|next
suffix:semicolon
)brace
singleline_comment|// unlink_modules
macro_line|#endif&t;&t;&t;&t;/* MODULE */
eof
