multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998,1999 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;See the file &quot;skfddi.c&quot; for further information.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/*&n; * FORMAC+ Driver for tag mode&n; */
macro_line|#include &quot;h/types.h&quot;
macro_line|#include &quot;h/fddi.h&quot;
macro_line|#include &quot;h/smc.h&quot;
macro_line|#include &quot;h/supern_2.h&quot;
macro_line|#include &quot;can.c&quot;
macro_line|#ifndef&t;lint
DECL|variable|ID_sccs
r_static
r_const
r_char
id|ID_sccs
(braket
)braket
op_assign
l_string|&quot;@(#)fplustm.c&t;1.32 99/02/23 (C) SK &quot;
suffix:semicolon
macro_line|#endif
macro_line|#ifndef UNUSED
macro_line|#ifdef  lint
DECL|macro|UNUSED
mdefine_line|#define UNUSED(x)&t;(x) = (x)
macro_line|#else
DECL|macro|UNUSED
mdefine_line|#define UNUSED(x)
macro_line|#endif
macro_line|#endif
DECL|macro|FM_ADDRX
mdefine_line|#define FM_ADDRX&t; (FM_ADDET|FM_EXGPA0|FM_EXGPA1)
DECL|macro|MS2BCLK
mdefine_line|#define MS2BCLK(x)&t;((x)*12500L)
DECL|macro|US2BCLK
mdefine_line|#define US2BCLK(x)&t;((x)*1250L)
multiline_comment|/*&n; * prototypes for static function&n; */
r_static
r_void
id|build_claim_beacon
c_func
(paren
)paren
suffix:semicolon
r_static
r_int
id|init_mac
c_func
(paren
)paren
suffix:semicolon
r_static
r_void
id|rtm_init
c_func
(paren
)paren
suffix:semicolon
r_static
r_void
id|smt_split_up_fifo
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (!defined(NO_SMT_PANIC) || defined(DEBUG))
DECL|variable|write_mdr_warning
r_static
r_char
id|write_mdr_warning
(braket
)braket
op_assign
l_string|&quot;E350 write_mdr() FM_SNPPND is set&bslash;n&quot;
suffix:semicolon
DECL|variable|cam_warning
r_static
r_char
id|cam_warning
(braket
)braket
op_assign
l_string|&quot;E_SMT_004: CAM still busy&bslash;n&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|DUMMY_READ
mdefine_line|#define&t;DUMMY_READ()&t;smc-&gt;hw.mc_dummy = (u_short) inp(ADDR(B0_RAP))
DECL|macro|CHECK_NPP
mdefine_line|#define&t;CHECK_NPP() {&t;unsigned k = 10000 ;&bslash;&n;&t;&t;&t;while ((inpw(FM_A(FM_STMCHN)) &amp; FM_SNPPND) &amp;&amp; k) k--;&bslash;&n;&t;&t;&t;if (!k) { &bslash;&n;&t;&t;&t;&t;SMT_PANIC(smc,SMT_E0130, SMT_E0130_MSG) ; &bslash;&n;&t;&t;&t;}&t;&bslash;&n;&t;&t;}
DECL|macro|CHECK_CAM
mdefine_line|#define&t;CHECK_CAM() {&t;unsigned k = 10 ;&bslash;&n;&t;&t;&t;while (!(inpw(FM_A(FM_AFSTAT)) &amp; FM_DONE) &amp;&amp; k) k--;&bslash;&n;&t;&t;&t;if (!k) { &bslash;&n;&t;&t;&t;&t;SMT_PANIC(smc,SMT_E0131, SMT_E0131_MSG) ; &bslash;&n;&t;&t;&t;}&t;&bslash;&n;&t;&t;}
DECL|variable|fddi_broadcast
r_const
r_struct
id|fddi_addr
id|fddi_broadcast
op_assign
(brace
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
)brace
suffix:semicolon
DECL|variable|null_addr
r_static
r_const
r_struct
id|fddi_addr
id|null_addr
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|dbeacon_multi
r_static
r_const
r_struct
id|fddi_addr
id|dbeacon_multi
op_assign
(brace
(brace
l_int|0x01
comma
l_int|0x80
comma
l_int|0xc2
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
)brace
)brace
suffix:semicolon
DECL|variable|my_said
r_static
r_const
id|u_short
id|my_said
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* short address (n.u.) */
DECL|variable|my_sagp
r_static
r_const
id|u_short
id|my_sagp
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* short group address (n.u.) */
multiline_comment|/*&n; * define my address&n; */
macro_line|#ifdef&t;USE_CAN_ADDR
DECL|macro|MA
mdefine_line|#define MA&t;smc-&gt;hw.fddi_canon_addr
macro_line|#else
DECL|macro|MA
mdefine_line|#define MA&t;smc-&gt;hw.fddi_home_addr
macro_line|#endif
multiline_comment|/*&n; * usefull interrupt bits&n; */
DECL|variable|mac_imsk1u
r_static
r_int
id|mac_imsk1u
op_assign
id|FM_STXABRS
op_or
id|FM_STXABRA0
op_or
id|FM_SXMTABT
suffix:semicolon
DECL|variable|mac_imsk1l
r_static
r_int
id|mac_imsk1l
op_assign
id|FM_SQLCKS
op_or
id|FM_SQLCKA0
op_or
id|FM_SPCEPDS
op_or
id|FM_SPCEPDA0
op_or
id|FM_STBURS
op_or
id|FM_STBURA0
suffix:semicolon
multiline_comment|/* delete FM_SRBFL after tests */
DECL|variable|mac_imsk2u
r_static
r_int
id|mac_imsk2u
op_assign
id|FM_SERRSF
op_or
id|FM_SNFSLD
op_or
id|FM_SRCVOVR
op_or
id|FM_SRBFL
op_or
id|FM_SMYCLM
suffix:semicolon
DECL|variable|mac_imsk2l
r_static
r_int
id|mac_imsk2l
op_assign
id|FM_STRTEXR
op_or
id|FM_SDUPCLM
op_or
id|FM_SFRMCTR
op_or
id|FM_SERRCTR
op_or
id|FM_SLSTCTR
op_or
id|FM_STRTEXP
op_or
id|FM_SMULTDA
op_or
id|FM_SRNGOP
suffix:semicolon
DECL|variable|mac_imsk3u
r_static
r_int
id|mac_imsk3u
op_assign
id|FM_SRCVOVR2
op_or
id|FM_SRBFL2
suffix:semicolon
DECL|variable|mac_imsk3l
r_static
r_int
id|mac_imsk3l
op_assign
id|FM_SRPERRQ2
op_or
id|FM_SRPERRQ1
suffix:semicolon
DECL|variable|mac_beacon_imsk2u
r_static
r_int
id|mac_beacon_imsk2u
op_assign
id|FM_SOTRBEC
op_or
id|FM_SMYBEC
op_or
id|FM_SBEC
op_or
id|FM_SLOCLM
op_or
id|FM_SHICLM
op_or
id|FM_SMYCLM
op_or
id|FM_SCLM
suffix:semicolon
DECL|function|mac_get_tneg
r_static
id|u_long
id|mac_get_tneg
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_long
id|tneg
suffix:semicolon
id|tneg
op_assign
(paren
id|u_long
)paren
(paren
(paren
r_int
)paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TNEG
)paren
)paren
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
(paren
(paren
id|u_long
)paren
(paren
(paren
id|tneg
op_plus
(paren
(paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TMRS
)paren
)paren
op_rshift
l_int|10
)paren
op_amp
l_int|0x1f
)paren
)paren
op_or
l_int|0xffe00000L
)paren
)paren
suffix:semicolon
)brace
DECL|function|mac_update_counter
r_void
id|mac_update_counter
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACFrame_Ct
op_assign
(paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACFrame_Ct
op_amp
l_int|0xffff0000L
)paren
op_plus
(paren
id|u_short
)paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_FCNTR
)paren
)paren
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACLost_Ct
op_assign
(paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACLost_Ct
op_amp
l_int|0xffff0000L
)paren
op_plus
(paren
id|u_short
)paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LCNTR
)paren
)paren
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACError_Ct
op_assign
(paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACError_Ct
op_amp
l_int|0xffff0000L
)paren
op_plus
(paren
id|u_short
)paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ECNTR
)paren
)paren
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACT_Neg
op_assign
id|mac_get_tneg
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#ifdef SMT_REAL_TOKEN_CT
multiline_comment|/*&n;&t; * If the token counter is emulated it is updated in smt_event.&n;&t; */
id|TBD
macro_line|#else
id|smt_emulate_token_ct
c_func
(paren
id|smc
comma
id|MAC0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * write long value into buffer memory over memory data register (MDR),&n; */
DECL|function|write_mdr
r_void
id|write_mdr
c_func
(paren
id|smc
comma
id|val
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_long
id|val
suffix:semicolon
(brace
id|CHECK_NPP
c_func
(paren
)paren
suffix:semicolon
id|MDRW
c_func
(paren
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * read long value from buffer memory over memory data register (MDR),&n; */
DECL|function|read_mdr
id|u_long
id|read_mdr
c_func
(paren
id|smc
comma
id|addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
(brace
r_int
id|p
suffix:semicolon
id|CHECK_NPP
c_func
(paren
)paren
suffix:semicolon
id|MARR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_IRMEMWO
)paren
suffix:semicolon
id|CHECK_NPP
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* needed for PCI to prevent from timeing violations */
multiline_comment|/*&t;p = MDRR() ; */
multiline_comment|/* bad read values if the workaround */
multiline_comment|/* smc-&gt;hw.mc_dummy = *((short volatile far *)(addr)))*/
multiline_comment|/* is used */
id|p
op_assign
(paren
id|u_long
)paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDRU
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|p
op_add_assign
(paren
id|u_long
)paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDRL
)paren
)paren
suffix:semicolon
r_return
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * clear buffer memory&n; */
DECL|function|init_ram
r_static
r_void
id|init_ram
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_short
id|i
suffix:semicolon
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_assign
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|RBC_MEM_SIZE
suffix:semicolon
id|CHECK_NPP
c_func
(paren
)paren
suffix:semicolon
id|MARW
c_func
(paren
id|smc-&gt;hw.fp.fifo.rbc_ram_start
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|smc-&gt;hw.fp.fifo.rbc_ram_start
suffix:semicolon
id|i
OL
(paren
id|u_short
)paren
(paren
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
id|write_mdr
c_func
(paren
id|smc
comma
l_int|0L
)paren
suffix:semicolon
multiline_comment|/* Erase the last byte too */
id|write_mdr
c_func
(paren
id|smc
comma
l_int|0L
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set receive FIFO pointer&n; */
DECL|function|set_recvptr
r_static
r_void
id|set_recvptr
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/*&n;&t; * initialize the pointer for receive queue 1&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPR1
)paren
comma
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
)paren
suffix:semicolon
multiline_comment|/* RPR1 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPR1
)paren
comma
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
)paren
suffix:semicolon
multiline_comment|/* SWPR1 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPR1
)paren
comma
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
)paren
suffix:semicolon
multiline_comment|/* WPR1 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EARV1
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_s_start
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* EARV1 */
multiline_comment|/*&n;&t; * initialize the pointer for receive queue 2&n;&t; */
r_if
c_cond
(paren
id|smc-&gt;hw.fp.fifo.rx2_fifo_size
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPR2
)paren
comma
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPR2
)paren
comma
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPR2
)paren
comma
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EARV2
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPR2
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPR2
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPR2
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EARV2
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_end
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * set transmit FIFO pointer&n; */
DECL|function|set_txptr
r_static
r_void
id|set_txptr
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG2
)paren
comma
id|FM_IRSTQ
)paren
suffix:semicolon
multiline_comment|/* reset transmit queues */
multiline_comment|/*&n;&t; * initialize the pointer for asynchronous transmit queue&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPXA0
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
)paren
suffix:semicolon
multiline_comment|/* RPXA0 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPXA0
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
)paren
suffix:semicolon
multiline_comment|/* SWPXA0 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPXA0
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
)paren
suffix:semicolon
multiline_comment|/* WPXA0 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EAA0
)paren
comma
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* EAA0 */
multiline_comment|/*&n;&t; * initialize the pointer for synchronous transmit queue&n;&t; */
r_if
c_cond
(paren
id|smc-&gt;hw.fp.fifo.tx_s_size
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPXS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_s_start
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPXS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_s_start
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPXS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_s_start
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EAS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPXS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPXS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPXS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EAS
)paren
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * init memory buffer management registers&n; */
DECL|function|init_rbc
r_static
r_void
id|init_rbc
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_short
id|rbc_ram_addr
suffix:semicolon
multiline_comment|/*&n;&t; * set unused pointers or permanent pointers&n;&t; */
id|rbc_ram_addr
op_assign
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
op_minus
l_int|1
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPXA1
)paren
comma
id|rbc_ram_addr
)paren
suffix:semicolon
multiline_comment|/* a1-send pointer */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPXA1
)paren
comma
id|rbc_ram_addr
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SWPXA1
)paren
comma
id|rbc_ram_addr
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EAA1
)paren
comma
id|rbc_ram_addr
)paren
suffix:semicolon
id|set_recvptr
c_func
(paren
id|smc
)paren
suffix:semicolon
id|set_txptr
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * init rx pointer&n; */
DECL|function|init_rx
r_static
r_void
id|init_rx
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_rx_queue
op_star
id|queue
suffix:semicolon
multiline_comment|/*&n;&t; * init all tx data structures for receive queue 1&n;&t; */
id|smc-&gt;hw.fp.rx
(braket
id|QUEUE_R1
)braket
op_assign
id|queue
op_assign
op_amp
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R1
)braket
suffix:semicolon
id|queue-&gt;rx_bmu_ctl
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_R1_CSR
)paren
suffix:semicolon
id|queue-&gt;rx_bmu_dsc
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B4_R1_DA
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * init all tx data structures for receive queue 2&n;&t; */
id|smc-&gt;hw.fp.rx
(braket
id|QUEUE_R2
)braket
op_assign
id|queue
op_assign
op_amp
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R2
)braket
suffix:semicolon
id|queue-&gt;rx_bmu_ctl
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_R2_CSR
)paren
suffix:semicolon
id|queue-&gt;rx_bmu_dsc
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B4_R2_DA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set the TSYNC register of the FORMAC to regulate synchronous transmission&n; */
DECL|function|set_formac_tsync
r_void
id|set_formac_tsync
c_func
(paren
id|smc
comma
id|sync_bw
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|sync_bw
suffix:semicolon
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TSYNC
)paren
comma
(paren
r_int
r_int
)paren
(paren
(paren
(paren
op_minus
id|sync_bw
)paren
op_rshift
l_int|5
)paren
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * init all tx data structures&n; */
DECL|function|init_tx
r_static
r_void
id|init_tx
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
multiline_comment|/*&n;&t; * init all tx data structures for the synchronous queue&n;&t; */
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_S
)braket
op_assign
id|queue
op_assign
op_amp
id|smc-&gt;hw.fp.tx_q
(braket
id|QUEUE_S
)braket
suffix:semicolon
id|queue-&gt;tx_bmu_ctl
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_XS_CSR
)paren
suffix:semicolon
id|queue-&gt;tx_bmu_dsc
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B5_XS_DA
)paren
suffix:semicolon
macro_line|#ifdef ESS
id|set_formac_tsync
c_func
(paren
id|smc
comma
id|smc-&gt;ess.sync_bw
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * init all tx data structures for the asynchronous queue 0&n;&t; */
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_A0
)braket
op_assign
id|queue
op_assign
op_amp
id|smc-&gt;hw.fp.tx_q
(braket
id|QUEUE_A0
)braket
suffix:semicolon
id|queue-&gt;tx_bmu_ctl
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_XA_CSR
)paren
suffix:semicolon
id|queue-&gt;tx_bmu_dsc
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B5_XA_DA
)paren
suffix:semicolon
id|llc_recover_tx
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
DECL|function|mac_counter_init
r_static
r_void
id|mac_counter_init
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|u_long
op_star
id|ec
suffix:semicolon
multiline_comment|/*&n;&t; * clear FORMAC+ frame-, lost- and error counter&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_FCNTR
)paren
comma
l_int|0
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LCNTR
)paren
comma
l_int|0
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ECNTR
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * clear internal error counter stucture&n;&t; */
id|ec
op_assign
(paren
id|u_long
op_star
)paren
op_amp
id|smc-&gt;hw.fp.err_stats
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
r_sizeof
(paren
r_struct
id|err_st
)paren
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
op_star
id|ec
op_increment
op_assign
l_int|0L
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACRingOp_Ct
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * set FORMAC address, and t_request&n; */
DECL|function|set_formac_addr
r_static
r_void
id|set_formac_addr
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_int
id|t_requ
op_assign
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACT_Req
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SAID
)paren
comma
id|my_said
)paren
suffix:semicolon
multiline_comment|/* set short address */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LAIL
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|smc-&gt;hw.fddi_home_addr.a
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
id|smc-&gt;hw.fddi_home_addr.a
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LAIC
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|smc-&gt;hw.fddi_home_addr.a
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|smc-&gt;hw.fddi_home_addr.a
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LAIM
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|smc-&gt;hw.fddi_home_addr.a
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|smc-&gt;hw.fddi_home_addr.a
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SAGP
)paren
comma
id|my_sagp
)paren
suffix:semicolon
multiline_comment|/* set short group address */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LAGL
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|smc-&gt;hw.fp.group_addr.a
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
id|smc-&gt;hw.fp.group_addr.a
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LAGC
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|smc-&gt;hw.fp.group_addr.a
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|smc-&gt;hw.fp.group_addr.a
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_LAGM
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|smc-&gt;hw.fp.group_addr.a
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|smc-&gt;hw.fp.group_addr.a
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* set r_request regs. (MSW &amp; LSW of TRT ) */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TREQ1
)paren
comma
(paren
r_int
)paren
(paren
id|t_requ
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TREQ0
)paren
comma
(paren
r_int
)paren
id|t_requ
)paren
suffix:semicolon
)brace
DECL|function|set_int
r_void
id|set_int
c_func
(paren
id|p
comma
id|l
)paren
r_char
op_star
id|p
suffix:semicolon
r_int
id|l
suffix:semicolon
(brace
id|p
(braket
l_int|0
)braket
op_assign
(paren
r_char
)paren
(paren
id|l
op_rshift
l_int|24
)paren
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
(paren
r_char
)paren
(paren
id|l
op_rshift
l_int|16
)paren
suffix:semicolon
id|p
(braket
l_int|2
)braket
op_assign
(paren
r_char
)paren
(paren
id|l
op_rshift
l_int|8
)paren
suffix:semicolon
id|p
(braket
l_int|3
)braket
op_assign
(paren
r_char
)paren
(paren
id|l
op_rshift
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * copy TX descriptor to buffer mem&n; * append FC field and MAC frame&n; * if more bit is set in descr&n; *&t;append pointer to descriptor (endless loop)&n; * else&n; *&t;append &squot;end of chain&squot; pointer&n; */
DECL|function|copy_tx_mac
r_static
r_void
id|copy_tx_mac
c_func
(paren
id|smc
comma
id|td
comma
id|mac
comma
id|off
comma
id|len
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_long
id|td
suffix:semicolon
multiline_comment|/* transmit descriptor */
r_struct
id|fddi_mac
op_star
id|mac
suffix:semicolon
multiline_comment|/* mac frame pointer */
r_int
id|off
suffix:semicolon
multiline_comment|/* start address within buffer memory */
r_int
id|len
suffix:semicolon
multiline_comment|/* lenght of the frame including the FC */
(brace
r_int
id|i
suffix:semicolon
id|u_int
op_star
id|p
suffix:semicolon
id|CHECK_NPP
c_func
(paren
)paren
suffix:semicolon
id|MARW
c_func
(paren
id|off
)paren
suffix:semicolon
multiline_comment|/* set memory address reg for writes */
id|p
op_assign
(paren
id|u_int
op_star
)paren
id|mac
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|len
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
(brace
multiline_comment|/* last word, set the tag bit */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG2
)paren
comma
id|FM_ISTTB
)paren
suffix:semicolon
)brace
id|write_mdr
c_func
(paren
id|smc
comma
id|MDR_REVERSE
c_func
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG2
)paren
comma
id|FM_ISTTB
)paren
suffix:semicolon
multiline_comment|/* set the tag bit */
id|write_mdr
c_func
(paren
id|smc
comma
id|td
)paren
suffix:semicolon
multiline_comment|/* write over memory data reg to buffer */
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(module;tests;3)&n;&t;How to test directed beacon frames&n;&t;----------------------------------------------------------------&n;&n;&t;o Insert a break point in the function build_claim_beacon()&n;&t;  before calling copy_tx_mac() for building the claim frame.&n;&t;o Modify the RM3_DETECT case so that the RM6_DETECT state&n;&t;  will always entered from the RM3_DETECT state (function rmt_fsm(),&n;&t;  rmt.c)&n;&t;o Compile the driver.&n;&t;o Set the parameter TREQ in the protocol.ini or net.cfg to a&n;&t;  small value to make sure your station will win the claim&n;&t;  process.&n;&t;o Start the driver.&n;&t;o When you reach the break point, modify the SA and DA address&n;&t;  of the claim frame (e.g. SA = DA = 10005affffff).&n;&t;o When you see RM3_DETECT and RM6_DETECT, observe the direct&n;&t;  beacon frames on the UPPSLANA.&n;&n;&t;END_MANUAL_ENTRY&n; */
DECL|function|directed_beacon
r_static
r_void
id|directed_beacon
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SK_LOC_DECL
c_func
(paren
id|u_int
comma
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set UNA in frame&n;&t; * enable FORMAC to send endless queue of directed beacon&n;&t; * important: the UNA starts at byte 1 (not at byte 0)&n;&t; */
op_star
(paren
r_char
op_star
)paren
id|a
op_assign
(paren
r_char
)paren
(paren
(paren
r_int
)paren
id|DBEACON_INFO
op_lshift
l_int|24L
)paren
suffix:semicolon
id|a
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|a
op_plus
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACUpstreamNbr
comma
l_int|6
)paren
suffix:semicolon
id|CHECK_NPP
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set memory address reg for writes */
id|MARW
c_func
(paren
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|DBEACON_FRAME_OFF
op_plus
l_int|4
)paren
suffix:semicolon
id|write_mdr
c_func
(paren
id|smc
comma
id|MDR_REVERSE
c_func
(paren
id|a
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG2
)paren
comma
id|FM_ISTTB
)paren
suffix:semicolon
multiline_comment|/* set the tag bit */
id|write_mdr
c_func
(paren
id|smc
comma
id|MDR_REVERSE
c_func
(paren
id|a
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SABC
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|DBEACON_FRAME_OFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;setup claim &amp; beacon pointer&n;&t;NOTE :&n;&t;&t;special frame packets end with a pointer to their own&n;&t;&t;descriptor, and the MORE bit is set in the descriptor&n;*/
DECL|function|build_claim_beacon
r_static
r_void
id|build_claim_beacon
c_func
(paren
id|smc
comma
id|t_request
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_long
id|t_request
suffix:semicolon
(brace
id|u_int
id|td
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|fddi_mac_sf
op_star
id|mac
suffix:semicolon
multiline_comment|/*&n;&t; * build claim packet&n;&t; */
id|len
op_assign
l_int|17
suffix:semicolon
id|td
op_assign
id|TX_DESCRIPTOR
op_or
(paren
(paren
(paren
(paren
id|u_int
)paren
id|len
op_minus
l_int|1
)paren
op_amp
l_int|3
)paren
op_lshift
l_int|27
)paren
suffix:semicolon
id|mac
op_assign
op_amp
id|smc-&gt;hw.fp.mac_sfb
suffix:semicolon
id|mac-&gt;mac_fc
op_assign
id|FC_CLAIM
suffix:semicolon
multiline_comment|/* DA == SA in claim frame */
id|mac-&gt;mac_source
op_assign
id|mac-&gt;mac_dest
op_assign
id|MA
suffix:semicolon
multiline_comment|/* 2&squot;s complement */
id|set_int
c_func
(paren
(paren
r_char
op_star
)paren
id|mac-&gt;mac_info
comma
(paren
r_int
)paren
id|t_request
)paren
suffix:semicolon
id|copy_tx_mac
c_func
(paren
id|smc
comma
id|td
comma
(paren
r_struct
id|fddi_mac
op_star
)paren
id|mac
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|CLAIM_FRAME_OFF
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* set CLAIM start pointer */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SACL
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|CLAIM_FRAME_OFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * build beacon packet&n;&t; */
id|len
op_assign
l_int|17
suffix:semicolon
id|td
op_assign
id|TX_DESCRIPTOR
op_or
(paren
(paren
(paren
(paren
id|u_int
)paren
id|len
op_minus
l_int|1
)paren
op_amp
l_int|3
)paren
op_lshift
l_int|27
)paren
suffix:semicolon
id|mac-&gt;mac_fc
op_assign
id|FC_BEACON
suffix:semicolon
id|mac-&gt;mac_source
op_assign
id|MA
suffix:semicolon
id|mac-&gt;mac_dest
op_assign
id|null_addr
suffix:semicolon
multiline_comment|/* DA == 0 in beacon frame */
id|set_int
c_func
(paren
(paren
r_char
op_star
)paren
id|mac-&gt;mac_info
comma
(paren
(paren
r_int
)paren
id|BEACON_INFO
op_lshift
l_int|24
)paren
op_plus
l_int|0
)paren
suffix:semicolon
id|copy_tx_mac
c_func
(paren
id|smc
comma
id|td
comma
(paren
r_struct
id|fddi_mac
op_star
)paren
id|mac
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|BEACON_FRAME_OFF
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* set beacon start pointer */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_SABC
)paren
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|BEACON_FRAME_OFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * build directed beacon packet&n;&t; * contains optional UNA&n;&t; */
id|len
op_assign
l_int|23
suffix:semicolon
id|td
op_assign
id|TX_DESCRIPTOR
op_or
(paren
(paren
(paren
(paren
id|u_int
)paren
id|len
op_minus
l_int|1
)paren
op_amp
l_int|3
)paren
op_lshift
l_int|27
)paren
suffix:semicolon
id|mac-&gt;mac_fc
op_assign
id|FC_BEACON
suffix:semicolon
id|mac-&gt;mac_source
op_assign
id|MA
suffix:semicolon
id|mac-&gt;mac_dest
op_assign
id|dbeacon_multi
suffix:semicolon
multiline_comment|/* multicast */
id|set_int
c_func
(paren
(paren
r_char
op_star
)paren
id|mac-&gt;mac_info
comma
(paren
(paren
r_int
)paren
id|DBEACON_INFO
op_lshift
l_int|24
)paren
op_plus
l_int|0
)paren
suffix:semicolon
id|set_int
c_func
(paren
(paren
r_char
op_star
)paren
id|mac-&gt;mac_info
op_plus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|set_int
c_func
(paren
(paren
r_char
op_star
)paren
id|mac-&gt;mac_info
op_plus
l_int|8
comma
l_int|0
)paren
suffix:semicolon
id|copy_tx_mac
c_func
(paren
id|smc
comma
id|td
comma
(paren
r_struct
id|fddi_mac
op_star
)paren
id|mac
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|DBEACON_FRAME_OFF
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* end of claim/beacon queue */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_EACB
)paren
comma
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
op_minus
l_int|1
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_WPXSF
)paren
comma
l_int|0
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_RPXSF
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|formac_rcv_restart
r_void
id|formac_rcv_restart
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/* enable receive function */
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|smc-&gt;hw.fp.rx_mode
comma
id|FM_ADDRX
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICLLR
)paren
suffix:semicolon
multiline_comment|/* clear receive lock */
)brace
DECL|function|formac_tx_restart
r_void
id|formac_tx_restart
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICLLS
)paren
suffix:semicolon
multiline_comment|/* clear s-frame lock */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICLLA0
)paren
suffix:semicolon
multiline_comment|/* clear a-frame lock */
)brace
DECL|function|enable_formac
r_static
r_void
id|enable_formac
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/* set formac IMSK : 0 enables irq */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
comma
op_complement
id|mac_imsk1u
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1L
)paren
comma
op_complement
id|mac_imsk1l
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK2U
)paren
comma
op_complement
id|mac_imsk2u
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK2L
)paren
comma
op_complement
id|mac_imsk2l
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK3U
)paren
comma
op_complement
id|mac_imsk3u
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK3L
)paren
comma
op_complement
id|mac_imsk3l
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;/* Removed because the driver should use the ASICs TX complete IRQ. */
multiline_comment|/* The FORMACs tx complete IRQ should be used any longer */
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;4)&n;&n;&t;void enable_tx_irq(smc, queue)&n;&t;struct s_smc *smc ;&n;&t;u_short&t;queue ;&n;&n;Function&t;DOWNCALL&t;(SMT, fplustm.c)&n;&t;&t;enable_tx_irq() enables the FORMACs transmit complete&n;&t;&t;interrupt of the queue.&n;&n;Para&t;queue&t;= QUEUE_S:&t;synchronous queue&n;&t;&t;= QUEUE_A0:&t;asynchronous queue&n;&n;Note&t;After any ring operational change the transmit complete&n;&t;interrupts are disabled.&n;&t;The operating system dependent module must enable&n;&t;the transmit complete interrupt of a queue,&n;&t;&t;- when it queues the first frame,&n;&t;&t;  because of no transmit resources are beeing&n;&t;&t;  available and&n;&t;&t;- when it escapes from the function llc_restart_tx&n;&t;&t;  while some frames are still queued.&n;&n;&t;END_MANUAL_ENTRY&n; */
r_void
id|enable_tx_irq
c_func
(paren
id|smc
comma
id|queue
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|queue
suffix:semicolon
multiline_comment|/* 0 = synchronous queue, 1 = asynchronous queue 0 */
(brace
id|u_short
id|imask
suffix:semicolon
id|imask
op_assign
op_complement
(paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue
op_eq
l_int|0
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
comma
op_complement
(paren
id|imask
op_or
id|FM_STEFRMS
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|queue
op_eq
l_int|1
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
comma
op_complement
(paren
id|imask
op_or
id|FM_STEFRMA0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;4)&n;&n;&t;void disable_tx_irq(smc, queue)&n;&t;struct s_smc *smc ;&n;&t;u_short&t;queue ;&n;&n;Function&t;DOWNCALL&t;(SMT, fplustm.c)&n;&t;&t;disable_tx_irq disables the FORMACs transmit complete&n;&t;&t;interrupt of the queue&n;&n;Para&t;queue&t;= QUEUE_S:&t;synchronous queue&n;&t;&t;= QUEUE_A0:&t;asynchronous queue&n;&n;Note&t;The operating system dependent module should disable&n;&t;the transmit complete interrupts if it escapes from the&n;&t;function llc_restart_tx and no frames are queued.&n;&n;&t;END_MANUAL_ENTRY&n; */
r_void
id|disable_tx_irq
c_func
(paren
id|smc
comma
id|queue
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|queue
suffix:semicolon
multiline_comment|/* 0 = synchronous queue, 1 = asynchronous queue 0 */
(brace
id|u_short
id|imask
suffix:semicolon
id|imask
op_assign
op_complement
(paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue
op_eq
l_int|0
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
comma
op_complement
(paren
id|imask
op_amp
op_complement
id|FM_STEFRMS
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|queue
op_eq
l_int|1
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
comma
op_complement
(paren
id|imask
op_amp
op_complement
id|FM_STEFRMA0
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|disable_formac
r_static
r_void
id|disable_formac
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/* clear formac IMSK : 1 disables irq */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1U
)paren
comma
id|MW
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK1L
)paren
comma
id|MW
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK2U
)paren
comma
id|MW
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK2L
)paren
comma
id|MW
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK3U
)paren
comma
id|MW
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK3L
)paren
comma
id|MW
)paren
suffix:semicolon
)brace
DECL|function|mac_ring_up
r_static
r_void
id|mac_ring_up
c_func
(paren
id|smc
comma
id|up
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|up
suffix:semicolon
(brace
r_if
c_cond
(paren
id|up
)paren
(brace
id|formac_rcv_restart
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* enable receive function */
id|smc-&gt;hw.mac_ring_is_up
op_assign
id|TRUE
suffix:semicolon
id|llc_restart_tx
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* TX queue */
)brace
r_else
(brace
multiline_comment|/* disable receive function */
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MDISRCV
comma
id|FM_ADDET
)paren
suffix:semicolon
multiline_comment|/* abort current transmit activity */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG2
)paren
comma
id|FM_IACTR
)paren
suffix:semicolon
id|smc-&gt;hw.mac_ring_is_up
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/*--------------------------- ISR handling ----------------------------------*/
multiline_comment|/*&n; * mac1_irq is in drvfbi.c&n; */
multiline_comment|/*&n; * mac2_irq:&t;status bits for the receive queue 1, and ring status&n; * &t;&t;ring status indication bits&n; */
DECL|function|mac2_irq
r_void
id|mac2_irq
c_func
(paren
id|smc
comma
id|code_s2u
comma
id|code_s2l
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|code_s2u
suffix:semicolon
id|u_short
id|code_s2l
suffix:semicolon
(brace
id|u_short
id|change_s2l
suffix:semicolon
id|u_short
id|change_s2u
suffix:semicolon
multiline_comment|/* (jd) 22-Feb-1999&n;&t; * Restart 2_DMax Timer after end of claiming or beaconing&n;&t; */
r_if
c_cond
(paren
id|code_s2u
op_amp
(paren
id|FM_SCLM
op_or
id|FM_SHICLM
op_or
id|FM_SBEC
op_or
id|FM_SOTRBEC
)paren
)paren
(brace
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_TX_STATE_CHANGE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|code_s2l
op_amp
(paren
id|FM_STKISS
)paren
)paren
(brace
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_TX_STATE_CHANGE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XOR current st bits with the last to avoid useless RMT event queuing&n;&t; */
id|change_s2l
op_assign
id|smc-&gt;hw.fp.s2l
op_xor
id|code_s2l
suffix:semicolon
id|change_s2u
op_assign
id|smc-&gt;hw.fp.s2u
op_xor
id|code_s2u
suffix:semicolon
r_if
c_cond
(paren
(paren
id|change_s2l
op_amp
id|FM_SRNGOP
)paren
op_logical_or
(paren
op_logical_neg
id|smc-&gt;hw.mac_ring_is_up
op_logical_and
(paren
(paren
id|code_s2l
op_amp
id|FM_SRNGOP
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SRNGOP
)paren
(brace
id|mac_ring_up
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_RING_OP
)paren
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACRingOp_Ct
op_increment
suffix:semicolon
)brace
r_else
(brace
id|mac_ring_up
c_func
(paren
id|smc
comma
l_int|0
)paren
suffix:semicolon
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_RING_NON_OP
)paren
suffix:semicolon
)brace
r_goto
id|mac2_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SMISFRM
)paren
(brace
multiline_comment|/* missed frame */
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACNotCopied_Ct
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code_s2u
op_amp
(paren
id|FM_SRCVOVR
op_or
multiline_comment|/* recv. FIFO overflow */
id|FM_SRBFL
)paren
)paren
(brace
multiline_comment|/* recv. buffer full */
id|smc-&gt;hw.mac_ct.mac_r_restart_counter
op_increment
suffix:semicolon
multiline_comment|/*&t;&t;formac_rcv_restart(smc) ;&t;*/
id|smt_stat_counter
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;&t;goto mac2_end ;&t;&t;&t;*/
)brace
r_if
c_cond
(paren
id|code_s2u
op_amp
id|FM_SOTRBEC
)paren
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_OTHER_BEACON
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code_s2u
op_amp
id|FM_SMYBEC
)paren
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_MY_BEACON
)paren
suffix:semicolon
r_if
c_cond
(paren
id|change_s2u
op_amp
id|code_s2u
op_amp
id|FM_SLOCLM
)paren
(brace
id|DB_RMTN
c_func
(paren
l_int|2
comma
l_string|&quot;RMT : lower claim received&bslash;n&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|code_s2u
op_amp
id|FM_SMYCLM
)paren
op_logical_and
op_logical_neg
(paren
id|code_s2l
op_amp
id|FM_SDUPCLM
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This is my claim and that claim is not detected as a&n;&t;&t; * duplicate one.&n;&t;&t; */
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_MY_CLAIM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SDUPCLM
)paren
(brace
multiline_comment|/*&n;&t;&t; * If a duplicate claim frame (same SA but T_Bid != T_Req)&n;&t;&t; * this flag will be set.&n;&t;&t; * In the RMT state machine we need a RM_VALID_CLAIM event&n;&t;&t; * to do the appropriate state change.&n;&t;&t; * RM(34c)&n;&t;&t; */
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_VALID_CLAIM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|change_s2u
op_amp
id|code_s2u
op_amp
id|FM_SHICLM
)paren
(brace
id|DB_RMTN
c_func
(paren
l_int|2
comma
l_string|&quot;RMT : higher claim received&bslash;n&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|code_s2l
op_amp
id|FM_STRTEXP
)paren
op_logical_or
(paren
id|code_s2l
op_amp
id|FM_STRTEXR
)paren
)paren
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_TRT_EXP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SMULTDA
)paren
(brace
multiline_comment|/*&n;&t;&t; * The MAC has found a 2. MAC with the same address.&n;&t;&t; * Signal dup_addr_test = failed to RMT state machine.&n;&t;&t; * RM(25)&n;&t;&t; */
id|smc-&gt;r.dup_addr_test
op_assign
id|DA_FAILED
suffix:semicolon
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_DUP_ADDR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code_s2u
op_amp
id|FM_SBEC
)paren
id|smc-&gt;hw.fp.err_stats.err_bec_stat
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|code_s2u
op_amp
id|FM_SCLM
)paren
id|smc-&gt;hw.fp.err_stats.err_clm_stat
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_STVXEXP
)paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACTvxExpired_Ct
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code_s2u
op_amp
(paren
id|FM_SBEC
op_or
id|FM_SCLM
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|change_s2l
op_amp
id|FM_SRNGOP
)paren
op_logical_and
(paren
id|smc-&gt;hw.fp.s2l
op_amp
id|FM_SRNGOP
)paren
)paren
(brace
id|mac_ring_up
c_func
(paren
id|smc
comma
l_int|0
)paren
suffix:semicolon
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_RING_NON_OP
)paren
suffix:semicolon
id|mac_ring_up
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
id|queue_event
c_func
(paren
id|smc
comma
id|EVENT_RMT
comma
id|RM_RING_OP
)paren
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACRingOp_Ct
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SPHINV
)paren
id|smc-&gt;hw.fp.err_stats.err_phinv
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SSIFG
)paren
id|smc-&gt;hw.fp.err_stats.err_sifg_det
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_STKISS
)paren
id|smc-&gt;hw.fp.err_stats.err_tkiss
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_STKERR
)paren
id|smc-&gt;hw.fp.err_stats.err_tkerr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SFRMCTR
)paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACFrame_Ct
op_add_assign
l_int|0x10000L
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SERRCTR
)paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACError_Ct
op_add_assign
l_int|0x10000L
suffix:semicolon
r_if
c_cond
(paren
id|code_s2l
op_amp
id|FM_SLSTCTR
)paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACLost_Ct
op_add_assign
l_int|0x10000L
suffix:semicolon
r_if
c_cond
(paren
id|code_s2u
op_amp
id|FM_SERRSF
)paren
(brace
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0114
comma
id|SMT_E0114_MSG
)paren
suffix:semicolon
)brace
id|mac2_end
suffix:colon
multiline_comment|/* notice old status */
id|smc-&gt;hw.fp.s2l
op_assign
id|code_s2l
suffix:semicolon
id|smc-&gt;hw.fp.s2u
op_assign
id|code_s2u
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK2U
)paren
comma
op_complement
id|mac_imsk2u
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mac3_irq:&t;receive queue 2 bits and address detection bits&n; */
DECL|function|mac3_irq
r_void
id|mac3_irq
c_func
(paren
id|smc
comma
id|code_s3u
comma
id|code_s3l
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|code_s3u
suffix:semicolon
id|u_short
id|code_s3l
suffix:semicolon
(brace
id|UNUSED
c_func
(paren
id|code_s3l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code_s3u
op_amp
(paren
id|FM_SRCVOVR2
op_or
multiline_comment|/* recv. FIFO overflow */
id|FM_SRBFL2
)paren
)paren
(brace
multiline_comment|/* recv. buffer full */
id|smc-&gt;hw.mac_ct.mac_r_restart_counter
op_increment
suffix:semicolon
id|smt_stat_counter
c_func
(paren
id|smc
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code_s3u
op_amp
id|FM_SRPERRQ2
)paren
(brace
multiline_comment|/* parity error receive queue 2 */
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0115
comma
id|SMT_E0115_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code_s3u
op_amp
id|FM_SRPERRQ1
)paren
(brace
multiline_comment|/* parity error receive queue 2 */
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0116
comma
id|SMT_E0116_MSG
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * take formac offline&n; */
DECL|function|formac_offline
r_static
r_void
id|formac_offline
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG2
)paren
comma
id|FM_IACTR
)paren
suffix:semicolon
multiline_comment|/* abort current transmit activity */
multiline_comment|/* disable receive function */
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MDISRCV
comma
id|FM_ADDET
)paren
suffix:semicolon
multiline_comment|/* FORMAC+ &squot;Initialize Mode&squot; */
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MINIT
comma
id|FM_MMODE
)paren
suffix:semicolon
id|disable_formac
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smc-&gt;hw.mac_ring_is_up
op_assign
id|FALSE
suffix:semicolon
id|smc-&gt;hw.hw_state
op_assign
id|STOPPED
suffix:semicolon
)brace
multiline_comment|/*&n; * bring formac online&n; */
DECL|function|formac_online
r_static
r_void
id|formac_online
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|enable_formac
c_func
(paren
id|smc
)paren
suffix:semicolon
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MONLINE
op_or
id|FM_SELRA
op_or
id|MDR1INIT
op_or
id|smc-&gt;hw.fp.rx_mode
comma
id|FM_MMODE
op_or
id|FM_SELRA
op_or
id|FM_ADDRX
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FORMAC+ full init. (tx, rx, timer, counter, claim &amp; beacon)&n; */
DECL|function|init_fplus
r_int
id|init_fplus
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|smc-&gt;hw.fp.nsa_mode
op_assign
id|FM_MRNNSAFNMA
suffix:semicolon
id|smc-&gt;hw.fp.rx_mode
op_assign
id|FM_MDAMA
suffix:semicolon
id|smc-&gt;hw.fp.group_addr
op_assign
id|fddi_broadcast
suffix:semicolon
id|smc-&gt;hw.fp.func_addr
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.fp.frselreg_init
op_assign
l_int|0
suffix:semicolon
id|init_driver_fplus
c_func
(paren
id|smc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;s.sas
op_eq
id|SMT_DAS
)paren
id|smc-&gt;hw.fp.mdr3init
op_or_assign
id|FM_MENDAS
suffix:semicolon
id|smc-&gt;hw.mac_ct.mac_nobuf_counter
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.mac_ct.mac_r_restart_counter
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.fp.fm_st1u
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_ST1U
)paren
suffix:semicolon
id|smc-&gt;hw.fp.fm_st1l
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_ST1L
)paren
suffix:semicolon
id|smc-&gt;hw.fp.fm_st2u
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_ST2U
)paren
suffix:semicolon
id|smc-&gt;hw.fp.fm_st2l
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_ST2L
)paren
suffix:semicolon
id|smc-&gt;hw.fp.fm_st3u
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_ST3U
)paren
suffix:semicolon
id|smc-&gt;hw.fp.fm_st3l
op_assign
(paren
id|HW_PTR
)paren
id|ADDR
c_func
(paren
id|B0_ST3L
)paren
suffix:semicolon
id|smc-&gt;hw.fp.s2l
op_assign
id|smc-&gt;hw.fp.s2u
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.mac_ring_is_up
op_assign
l_int|0
suffix:semicolon
id|mac_counter_init
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* convert BCKL units to symbol time */
id|smc-&gt;hw.mac_pa.t_neg
op_assign
(paren
id|u_long
)paren
l_int|0
suffix:semicolon
id|smc-&gt;hw.mac_pa.t_pri
op_assign
(paren
id|u_long
)paren
l_int|0
suffix:semicolon
multiline_comment|/* make sure all PCI settings are correct */
id|mac_do_pci_fix
c_func
(paren
id|smc
)paren
suffix:semicolon
r_return
(paren
id|init_mac
c_func
(paren
id|smc
comma
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* enable_formac(smc) ; */
)brace
DECL|function|init_mac
r_static
r_int
id|init_mac
c_func
(paren
id|smc
comma
id|all
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|all
suffix:semicolon
(brace
id|u_short
id|t_max
comma
id|x
suffix:semicolon
id|u_long
id|time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * clear memory&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MINIT
)paren
suffix:semicolon
multiline_comment|/* FORMAC+ init mode */
id|set_formac_addr
c_func
(paren
id|smc
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MMEMACT
)paren
suffix:semicolon
multiline_comment|/* FORMAC+ memory activ mode */
multiline_comment|/* Note: Mode register 2 is set here, incase parity is enabled. */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG2
)paren
comma
id|smc-&gt;hw.fp.mdr2init
)paren
suffix:semicolon
r_if
c_cond
(paren
id|all
)paren
(brace
id|init_ram
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * reset the HPI, the Master and the BMUs&n;&t;&t; */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_HPI_SET
)paren
suffix:semicolon
id|time
op_assign
id|hwt_quick_read
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set all pointers, frames etc&n;&t; */
id|smt_split_up_fifo
c_func
(paren
id|smc
)paren
suffix:semicolon
id|init_tx
c_func
(paren
id|smc
)paren
suffix:semicolon
id|init_rx
c_func
(paren
id|smc
)paren
suffix:semicolon
id|init_rbc
c_func
(paren
id|smc
)paren
suffix:semicolon
id|build_claim_beacon
c_func
(paren
id|smc
comma
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACT_Req
)paren
suffix:semicolon
multiline_comment|/* set RX threshold */
multiline_comment|/* see Errata #SN2 Phantom receive overflow */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_FRMTHR
)paren
comma
l_int|14
op_lshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* switch on */
multiline_comment|/* set formac work mode */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|MDR1INIT
op_or
id|FM_SELRA
op_or
id|smc-&gt;hw.fp.rx_mode
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG2
)paren
comma
id|smc-&gt;hw.fp.mdr2init
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG3
)paren
comma
id|smc-&gt;hw.fp.mdr3init
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_FRSELREG
)paren
comma
id|smc-&gt;hw.fp.frselreg_init
)paren
suffix:semicolon
multiline_comment|/* set timer */
multiline_comment|/*&n;&t; * errata #22 fplus:&n;&t; * T_MAX must not be FFFE&n;&t; * or one of FFDF, FFB8, FF91 (-0x27 etc..)&n;&t; */
id|t_max
op_assign
(paren
id|u_short
)paren
(paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACT_Max
op_div
l_int|32
)paren
suffix:semicolon
id|x
op_assign
id|t_max
op_div
l_int|0x27
suffix:semicolon
id|x
op_mul_assign
l_int|0x27
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t_max
op_eq
l_int|0xfffe
)paren
op_logical_or
(paren
id|t_max
op_minus
id|x
op_eq
l_int|0x16
)paren
)paren
id|t_max
op_decrement
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TMAX
)paren
comma
(paren
id|u_short
)paren
id|t_max
)paren
suffix:semicolon
multiline_comment|/* BugFix for report #10204 */
r_if
c_cond
(paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACTvxValue
OL
(paren
id|u_long
)paren
(paren
op_minus
id|US2BCLK
c_func
(paren
l_int|52
)paren
)paren
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TVX
)paren
comma
(paren
id|u_short
)paren
(paren
op_minus
id|US2BCLK
c_func
(paren
l_int|52
)paren
)paren
op_div
l_int|255
op_amp
id|MB
)paren
suffix:semicolon
)brace
r_else
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_TVX
)paren
comma
(paren
id|u_short
)paren
(paren
(paren
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACTvxValue
op_div
l_int|255
)paren
op_amp
id|MB
)paren
)paren
suffix:semicolon
)brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICLLS
)paren
suffix:semicolon
multiline_comment|/* clear s-frame lock */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICLLA0
)paren
suffix:semicolon
multiline_comment|/* clear a-frame lock */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICLLR
)paren
suffix:semicolon
multiline_comment|/* clear receive lock */
multiline_comment|/* Auto unlock receice threshold for receive queue 1 and 2 */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_UNLCKDLY
)paren
comma
(paren
l_int|0xff
op_or
(paren
l_int|0xff
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|rtm_init
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* RT-Monitor */
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
(brace
multiline_comment|/*&n;&t;&t; * after 10ms, reset the BMUs and repair the rings&n;&t;&t; */
id|hwt_wait_time
c_func
(paren
id|smc
comma
id|time
comma
id|MS2BCLK
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_R1_CSR
)paren
comma
id|CSR_SET_RESET
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XA_CSR
)paren
comma
id|CSR_SET_RESET
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XS_CSR
)paren
comma
id|CSR_SET_RESET
)paren
suffix:semicolon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_HPI_CLR
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_R1_CSR
)paren
comma
id|CSR_CLR_RESET
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XA_CSR
)paren
comma
id|CSR_CLR_RESET
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XS_CSR
)paren
comma
id|CSR_CLR_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;hw.hw_is_64bit
)paren
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_F
)paren
comma
id|RX_WATERMARK
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_F
)paren
comma
id|TX_WATERMARK
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_F
)paren
comma
id|TX_WATERMARK
)paren
suffix:semicolon
)brace
id|smc-&gt;hw.hw_state
op_assign
id|STOPPED
suffix:semicolon
id|mac_drv_repair_descr
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
id|smc-&gt;hw.hw_state
op_assign
id|STARTED
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * called by CFM&n; */
DECL|function|config_mux
r_void
id|config_mux
c_func
(paren
id|smc
comma
id|mux
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|mux
suffix:semicolon
(brace
id|plc_config_mux
c_func
(paren
id|smc
comma
id|mux
)paren
suffix:semicolon
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_SELRA
comma
id|FM_SELRA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * called by RMT&n; * enable CLAIM/BEACON interrupts&n; * (only called if these events are of interest, e.g. in DETECT state&n; * the interrupt must not be permanently enabled&n; * RMT calls this function periodically (timer driven polling)&n; */
DECL|function|sm_mac_check_beacon_claim
r_void
id|sm_mac_check_beacon_claim
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/* set formac IMSK : 0 enables irq */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_IMSK2U
)paren
comma
op_complement
(paren
id|mac_imsk2u
op_or
id|mac_beacon_imsk2u
)paren
)paren
suffix:semicolon
multiline_comment|/* the driver must receive the directed beacons */
id|formac_rcv_restart
c_func
(paren
id|smc
)paren
suffix:semicolon
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------- interface functions ----------------------------*/
multiline_comment|/*&n; * control ODL output&n; */
DECL|function|sm_pm_control
r_void
id|sm_pm_control
c_func
(paren
id|smc
comma
id|mode
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|mode
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if PCM logic has set LS_REQUEST = Transmit QUIET Line State&n;&t; *&t;/FOTOFF signal turn activ -&gt; ODL disable&n;&t; */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|PM_TRANSMIT_DISABLE
suffix:colon
r_break
suffix:semicolon
r_case
id|PM_TRANSMIT_ENABLE
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * control MAC layer&t;(called by RMT)&n; */
DECL|function|sm_ma_control
r_void
id|sm_ma_control
c_func
(paren
id|smc
comma
id|mode
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|mode
suffix:semicolon
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|MA_OFFLINE
suffix:colon
multiline_comment|/* Add to make the MAC offline in RM0_ISOLATED state */
id|formac_offline
c_func
(paren
id|smc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MA_RESET
suffix:colon
(paren
r_void
)paren
id|init_mac
c_func
(paren
id|smc
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MA_BEACON
suffix:colon
id|formac_online
c_func
(paren
id|smc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MA_DIRECTED
suffix:colon
id|directed_beacon
c_func
(paren
id|smc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MA_TREQ
suffix:colon
multiline_comment|/*&n;&t;&t; * no actions necessary, TREQ is already set&n;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
DECL|function|sm_mac_get_tx_state
r_int
id|sm_mac_get_tx_state
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_return
(paren
(paren
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_STMCHN
)paren
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|7
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * multicast functions&n; */
DECL|function|mac_get_mc_table
r_static
r_struct
id|s_fpmc
op_star
id|mac_get_mc_table
c_func
(paren
id|smc
comma
id|user
comma
id|own
comma
id|del
comma
id|can
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_struct
id|fddi_addr
op_star
id|user
suffix:semicolon
r_struct
id|fddi_addr
op_star
id|own
suffix:semicolon
r_int
id|del
suffix:semicolon
r_int
id|can
suffix:semicolon
(brace
r_struct
id|s_fpmc
op_star
id|tb
suffix:semicolon
r_struct
id|s_fpmc
op_star
id|slot
suffix:semicolon
id|u_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * set own = can(user)&n;&t; */
op_star
id|own
op_assign
op_star
id|user
suffix:semicolon
r_if
c_cond
(paren
id|can
)paren
(brace
id|p
op_assign
id|own-&gt;a
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
op_star
id|p
op_assign
id|canonical
(braket
op_star
id|p
)braket
suffix:semicolon
)brace
id|slot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|tb
op_assign
id|smc-&gt;hw.fp.mc.table
suffix:semicolon
id|i
OL
id|FPMAX_MULTICAST
suffix:semicolon
id|i
op_increment
comma
id|tb
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;n
)paren
(brace
multiline_comment|/* not used */
r_if
c_cond
(paren
op_logical_neg
id|del
op_logical_and
op_logical_neg
id|slot
)paren
multiline_comment|/* if !del save first free */
id|slot
op_assign
id|tb
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|tb-&gt;a
comma
(paren
r_char
op_star
)paren
id|own
comma
l_int|6
)paren
)paren
r_continue
suffix:semicolon
r_return
(paren
id|tb
)paren
suffix:semicolon
)brace
r_return
(paren
id|slot
)paren
suffix:semicolon
multiline_comment|/* return first free or NULL */
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;2)&n;&n;&t;void mac_clear_multicast(smc)&n;&t;struct s_smc *smc ;&n;&n;Function&t;DOWNCALL&t;(SMT, fplustm.c)&n;&t;&t;Clear all multicast entries&n;&n;&t;END_MANUAL_ENTRY()&n; */
DECL|function|mac_clear_multicast
r_void
id|mac_clear_multicast
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_fpmc
op_star
id|tb
suffix:semicolon
r_int
id|i
suffix:semicolon
id|smc-&gt;hw.fp.os_slots_used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* note the SMT addresses */
multiline_comment|/* will not be deleted */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|tb
op_assign
id|smc-&gt;hw.fp.mc.table
suffix:semicolon
id|i
OL
id|FPMAX_MULTICAST
suffix:semicolon
id|i
op_increment
comma
id|tb
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;perm
)paren
(brace
id|tb-&gt;n
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;2)&n;&n;&t;int mac_set_func_addr(smc,f_addr)&n;&t;struct s_smc *smc ;&n;&t;u_long f_addr ;&n;&n;Function&t;DOWNCALL&t;(SMT, fplustm.c)&n;&t;&t;Set a Token-Ring functional address, the address will&n;&t;&t;be activated after calling mac_update_multicast()&n;&n;Para&t;f_addr&t;functional bits in non-canonical format&n;&n;Returns&t;0: always success&n;&n;&t;END_MANUAL_ENTRY()&n; */
DECL|function|mac_set_func_addr
r_int
id|mac_set_func_addr
c_func
(paren
id|smc
comma
id|f_addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_long
id|f_addr
suffix:semicolon
(brace
id|smc-&gt;hw.fp.func_addr
op_assign
id|f_addr
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;2)&n;&n;&t;int mac_add_multicast(smc,addr,can)&n;&t;struct s_smc *smc ;&n;&t;struct fddi_addr *addr ;&n;&t;int can ;&n;&n;Function&t;DOWNCALL&t;(SMC, fplustm.c)&n;&t;&t;Add an entry to the multicast table&n;&n;Para&t;addr&t;pointer to a multicast address&n;&t;can&t;= 0:&t;the multicast address has the physical format&n;&t;&t;= 1:&t;the multicast address has the canonical format&n;&t;&t;| 0x80&t;permanent&n;&n;Returns&t;0: success&n;&t;1: address table full&n;&n;Note&t;After a &squot;driver reset&squot; or a &squot;station set address&squot; all&n;&t;entries of the multicast table are cleared.&n;&t;In this case the driver has to fill the multicast table again.&n;&t;After the operating system dependent module filled&n;&t;the multicast table it must call mac_update_multicast&n;&t;to activate the new multicast addresses!&n;&n;&t;END_MANUAL_ENTRY()&n; */
DECL|function|mac_add_multicast
r_int
id|mac_add_multicast
c_func
(paren
id|smc
comma
id|addr
comma
id|can
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_struct
id|fddi_addr
op_star
id|addr
suffix:semicolon
r_int
id|can
suffix:semicolon
(brace
id|SK_LOC_DECL
c_func
(paren
r_struct
id|fddi_addr
comma
id|own
)paren
suffix:semicolon
r_struct
id|s_fpmc
op_star
id|tb
suffix:semicolon
multiline_comment|/*&n;&t; * check if there are free table entries&n;&t; */
r_if
c_cond
(paren
id|can
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.fp.smt_slots_used
op_ge
id|SMT_MAX_MULTI
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.fp.os_slots_used
op_ge
id|FPMAX_MULTICAST
op_minus
id|SMT_MAX_MULTI
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * find empty slot&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tb
op_assign
id|mac_get_mc_table
c_func
(paren
id|smc
comma
id|addr
comma
op_amp
id|own
comma
l_int|0
comma
id|can
op_amp
op_complement
l_int|0x80
)paren
)paren
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|tb-&gt;n
op_increment
suffix:semicolon
id|tb-&gt;a
op_assign
id|own
suffix:semicolon
id|tb-&gt;perm
op_assign
(paren
id|can
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|can
op_amp
l_int|0x80
)paren
id|smc-&gt;hw.fp.smt_slots_used
op_increment
suffix:semicolon
r_else
id|smc-&gt;hw.fp.os_slots_used
op_increment
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;2)&n;&n;&t;void mac_del_multicast(smc,addr,can)&n;&t;struct s_smc *smc ;&n;&t;struct fddi_addr *addr ;&n;&t;int can ;&n;&n;Function&t;DOWNCALL&t;(SMT, fplustm.c)&n;&t;&t;Delete an entry from the multicast table&n;&n;Para&t;addr&t;pointer to a multicast address&n;&t;can&t;= 0:&t;the multicast address has the physical format&n;&t;&t;= 1:&t;the multicast address has the canonical format&n;&t;&t;| 0x80&t;permanent&n;&n;&t;END_MANUAL_ENTRY()&n; */
DECL|function|mac_del_multicast
r_void
id|mac_del_multicast
c_func
(paren
id|smc
comma
id|addr
comma
id|can
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_struct
id|fddi_addr
op_star
id|addr
suffix:semicolon
r_int
id|can
suffix:semicolon
(brace
id|SK_LOC_DECL
c_func
(paren
r_struct
id|fddi_addr
comma
id|own
)paren
suffix:semicolon
r_struct
id|s_fpmc
op_star
id|tb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tb
op_assign
id|mac_get_mc_table
c_func
(paren
id|smc
comma
id|addr
comma
op_amp
id|own
comma
l_int|1
comma
id|can
op_amp
op_complement
l_int|0x80
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * permanent addresses must be deleted with perm bit&n;&t; * and vice versa&n;&t; */
r_if
c_cond
(paren
(paren
id|tb-&gt;perm
op_logical_and
(paren
id|can
op_amp
l_int|0x80
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|tb-&gt;perm
op_logical_and
op_logical_neg
(paren
id|can
op_amp
l_int|0x80
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * delete it&n;&t;&t; */
r_if
c_cond
(paren
id|tb-&gt;n
)paren
(brace
id|tb-&gt;n
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;perm
)paren
(brace
id|smc-&gt;hw.fp.smt_slots_used
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;hw.fp.os_slots_used
op_decrement
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * mode&n; */
DECL|macro|RX_MODE_PROM
mdefine_line|#define RX_MODE_PROM&t;&t;0x1
DECL|macro|RX_MODE_ALL_MULTI
mdefine_line|#define RX_MODE_ALL_MULTI&t;0x2
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;2)&n;&n;&t;void mac_update_multicast(smc)&n;&t;struct s_smc *smc ;&n;&n;Function&t;DOWNCALL&t;(SMT, fplustm.c)&n;&t;&t;Update FORMAC multicast registers&n;&n;&t;END_MANUAL_ENTRY()&n; */
DECL|function|mac_update_multicast
r_void
id|mac_update_multicast
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_fpmc
op_star
id|tb
suffix:semicolon
id|u_char
op_star
id|fu
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * invalidate the CAM&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCMD
)paren
comma
id|FM_IINV_CAM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set the functional address&n;&t; */
r_if
c_cond
(paren
id|smc-&gt;hw.fp.func_addr
)paren
(brace
id|fu
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|smc-&gt;hw.fp.func_addr
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFMASK2
)paren
comma
l_int|0xffff
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFMASK1
)paren
comma
(paren
id|u_short
)paren
op_complement
(paren
(paren
id|fu
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|fu
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFMASK0
)paren
comma
(paren
id|u_short
)paren
op_complement
(paren
(paren
id|fu
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|fu
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFPERS
)paren
comma
id|FM_VALID
op_or
id|FM_DA
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCOMP2
)paren
comma
l_int|0xc000
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCOMP1
)paren
comma
l_int|0x0000
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCOMP0
)paren
comma
l_int|0x0000
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCMD
)paren
comma
id|FM_IWRITE_CAM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set the mask and the personality register(s)&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFMASK0
)paren
comma
l_int|0xffff
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFMASK1
)paren
comma
l_int|0xffff
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFMASK2
)paren
comma
l_int|0xffff
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFPERS
)paren
comma
id|FM_VALID
op_or
id|FM_DA
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|tb
op_assign
id|smc-&gt;hw.fp.mc.table
suffix:semicolon
id|i
OL
id|FPMAX_MULTICAST
suffix:semicolon
id|i
op_increment
comma
id|tb
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;n
)paren
(brace
id|CHECK_CAM
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * wirte the multicast addres into the CAM&n;&t;&t;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCOMP2
)paren
comma
(paren
id|u_short
)paren
(paren
(paren
id|tb-&gt;a.a
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|tb-&gt;a.a
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCOMP1
)paren
comma
(paren
id|u_short
)paren
(paren
(paren
id|tb-&gt;a.a
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|tb-&gt;a.a
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCOMP0
)paren
comma
(paren
id|u_short
)paren
(paren
(paren
id|tb-&gt;a.a
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
id|tb-&gt;a.a
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_AFCMD
)paren
comma
id|FM_IWRITE_CAM
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(if,func;others;3)&n;&n;&t;void mac_set_rx_mode(smc,mode)&n;&t;struct s_smc *smc ;&n;&t;int mode ;&n;&n;Function&t;DOWNCALL/INTERN&t;(SMT, fplustm.c)&n;&t;&t;This function enables / disables the selected receive.&n;&t;&t;Don&squot;t call this function if the hardware module is&n;&t;&t;used -- use mac_drv_rx_mode() instead of.&n;&n;Para&t;mode =&t;1&t;RX_ENABLE_ALLMULTI&t;enable all multicasts&n;&t;&t;2&t;RX_DISABLE_ALLMULTI&t;disable &quot;enable all multicasts&quot;&n;&t;&t;3&t;RX_ENABLE_PROMISC&t;enable promiscous&n;&t;&t;4&t;RX_DISABLE_PROMISC&t;disable promiscous&n;&t;&t;5&t;RX_ENABLE_NSA&t;&t;enable reception of NSA frames&n;&t;&t;6&t;RX_DISABLE_NSA&t;&t;disable reception of NSA frames&n;&n;Note&t;The selected receive modes will be lost after &squot;driver reset&squot;&n;&t;or &squot;set station address&squot;&n;&n;&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_set_rx_mode
r_void
id|mac_set_rx_mode
c_func
(paren
id|smc
comma
id|mode
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|mode
suffix:semicolon
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|RX_ENABLE_ALLMULTI
suffix:colon
id|smc-&gt;hw.fp.rx_prom
op_or_assign
id|RX_MODE_ALL_MULTI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_ALLMULTI
suffix:colon
id|smc-&gt;hw.fp.rx_prom
op_and_assign
op_complement
id|RX_MODE_ALL_MULTI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_ENABLE_PROMISC
suffix:colon
id|smc-&gt;hw.fp.rx_prom
op_or_assign
id|RX_MODE_PROM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_PROMISC
suffix:colon
id|smc-&gt;hw.fp.rx_prom
op_and_assign
op_complement
id|RX_MODE_PROM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_ENABLE_NSA
suffix:colon
id|smc-&gt;hw.fp.nsa_mode
op_assign
id|FM_MDAMA
suffix:semicolon
id|smc-&gt;hw.fp.rx_mode
op_assign
(paren
id|smc-&gt;hw.fp.rx_mode
op_amp
op_complement
id|FM_ADDET
)paren
op_or
id|smc-&gt;hw.fp.nsa_mode
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_NSA
suffix:colon
id|smc-&gt;hw.fp.nsa_mode
op_assign
id|FM_MRNNSAFNMA
suffix:semicolon
id|smc-&gt;hw.fp.rx_mode
op_assign
(paren
id|smc-&gt;hw.fp.rx_mode
op_amp
op_complement
id|FM_ADDET
)paren
op_or
id|smc-&gt;hw.fp.nsa_mode
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smc-&gt;hw.fp.rx_prom
op_amp
id|RX_MODE_PROM
)paren
(brace
id|smc-&gt;hw.fp.rx_mode
op_assign
id|FM_MLIMPROM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|smc-&gt;hw.fp.rx_prom
op_amp
id|RX_MODE_ALL_MULTI
)paren
(brace
id|smc-&gt;hw.fp.rx_mode
op_assign
id|smc-&gt;hw.fp.nsa_mode
op_or
id|FM_EXGPA0
suffix:semicolon
)brace
r_else
id|smc-&gt;hw.fp.rx_mode
op_assign
id|smc-&gt;hw.fp.nsa_mode
suffix:semicolon
id|SETMASK
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|smc-&gt;hw.fp.rx_mode
comma
id|FM_ADDRX
)paren
suffix:semicolon
id|mac_update_multicast
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(module;tests;3)&n;&t;How to test the Restricted Token Monitor&n;&t;----------------------------------------------------------------&n;&n;&t;o Insert a break point in the function rtm_irq()&n;&t;o Remove all stations with a restricted token monitor from the&n;&t;  network.&n;&t;o Connect a UPPS ISA or EISA station to the network.&n;&t;o Give the FORMAC of UPPS station the command to send&n;&t;  restricted tokens until the ring becomes instable.&n;&t;o Now connect your test test client.&n;&t;o The restricted token monitor should detect the restricted token,&n;&t;  and your break point will be reached.&n;&t;o You can ovserve how the station will clean the ring.&n;&n;&t;END_MANUAL_ENTRY&n; */
DECL|function|rtm_irq
r_void
id|rtm_irq
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|outpw
c_func
(paren
id|ADDR
c_func
(paren
id|B2_RTM_CRTL
)paren
comma
id|TIM_CL_IRQ
)paren
suffix:semicolon
multiline_comment|/* clear IRQ */
r_if
c_cond
(paren
id|inpw
c_func
(paren
id|ADDR
c_func
(paren
id|B2_RTM_CRTL
)paren
)paren
op_amp
id|TIM_RES_TOK
)paren
(brace
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_CMDREG1
)paren
comma
id|FM_ICL
)paren
suffix:semicolon
multiline_comment|/* force claim */
id|DB_RMT
c_func
(paren
l_string|&quot;RMT: fddiPATHT_Rmode expired&bslash;n&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|AIX_EVENT
c_func
(paren
id|smc
comma
(paren
id|u_long
)paren
id|FDDI_RING_STATUS
comma
(paren
id|u_long
)paren
id|FDDI_SMT_EVENT
comma
(paren
id|u_long
)paren
id|FDDI_RTT
comma
id|smt_get_event_word
c_func
(paren
id|smc
)paren
)paren
suffix:semicolon
)brace
id|outpw
c_func
(paren
id|ADDR
c_func
(paren
id|B2_RTM_CRTL
)paren
comma
id|TIM_START
)paren
suffix:semicolon
multiline_comment|/* enable RTM monitoring */
)brace
DECL|function|rtm_init
r_static
r_void
id|rtm_init
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B2_RTM_INI
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* timer = 0 */
id|outpw
c_func
(paren
id|ADDR
c_func
(paren
id|B2_RTM_CRTL
)paren
comma
id|TIM_START
)paren
suffix:semicolon
multiline_comment|/* enable IRQ */
)brace
DECL|function|rtm_set_timer
r_void
id|rtm_set_timer
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/*&n;&t; * MIB timer and hardware timer have the same resolution of 80nS&n;&t; */
id|DB_RMT
c_func
(paren
l_string|&quot;RMT: setting new fddiPATHT_Rmode, t = %d ns &bslash;n&quot;
comma
(paren
r_int
)paren
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHT_Rmode
comma
l_int|0
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B2_RTM_INI
)paren
comma
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHT_Rmode
)paren
suffix:semicolon
)brace
DECL|function|smt_split_up_fifo
r_static
r_void
id|smt_split_up_fifo
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(module;mem;1)&n;&t;-------------------------------------------------------------&n;&t;RECEIVE BUFFER MEMORY DIVERSION&n;&t;-------------------------------------------------------------&n;&n;&t;R1_RxD == SMT_R1_RXD_COUNT&n;&t;R2_RxD == SMT_R2_RXD_COUNT&n;&n;&t;SMT_R1_RXD_COUNT must be unequal zero&n;&n;&t;&t;   | R1_RxD R2_RxD |R1_RxD R2_RxD | R1_RxD R2_RxD&n;&t;&t;   |   x      0&t;   |  x&t;    1-3&t;  |   x     &lt; 3&n;&t;----------------------------------------------------------------------&n;&t;&t;   |   63,75 kB&t;   |    54,75&t;  |&t;R1_RxD&n;&t;rx queue 1 | RX_FIFO_SPACE | RX_LARGE_FIFO| ------------- * 63,75 kB&n;&t;&t;   |&t;&t;   |&t;&t;  | R1_RxD+R2_RxD&n;&t;----------------------------------------------------------------------&n;&t;&t;   |&t;&t;   |    9 kB&t;  |     R2_RxD&n;&t;rx queue 2 |&t;0 kB&t;   | RX_SMALL_FIFO| ------------- * 63,75 kB&n;&t;&t;   |  (not used)   |&t;&t;  | R1_RxD+R2_RxD&n;&n;&t;END_MANUAL_ENTRY&n;*/
r_if
c_cond
(paren
id|SMT_R1_RXD_COUNT
op_eq
l_int|0
)paren
(brace
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0117
comma
id|SMT_E0117_MSG
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|SMT_R2_RXD_COUNT
)paren
(brace
r_case
l_int|0
suffix:colon
id|smc-&gt;hw.fp.fifo.rx1_fifo_size
op_assign
id|RX_FIFO_SPACE
suffix:semicolon
id|smc-&gt;hw.fp.fifo.rx2_fifo_size
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
id|smc-&gt;hw.fp.fifo.rx1_fifo_size
op_assign
id|RX_LARGE_FIFO
suffix:semicolon
id|smc-&gt;hw.fp.fifo.rx2_fifo_size
op_assign
id|RX_SMALL_FIFO
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* this is not the real defaule */
id|smc-&gt;hw.fp.fifo.rx1_fifo_size
op_assign
id|RX_FIFO_SPACE
op_star
id|SMT_R1_RXD_COUNT
op_div
(paren
id|SMT_R1_RXD_COUNT
op_plus
id|SMT_R2_RXD_COUNT
)paren
suffix:semicolon
id|smc-&gt;hw.fp.fifo.rx2_fifo_size
op_assign
id|RX_FIFO_SPACE
op_star
id|SMT_R2_RXD_COUNT
op_div
(paren
id|SMT_R1_RXD_COUNT
op_plus
id|SMT_R2_RXD_COUNT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;BEGIN_MANUAL_ENTRY(module;mem;1)&n;&t;-------------------------------------------------------------&n;&t;TRANSMIT BUFFER MEMORY DIVERSION&n;&t;-------------------------------------------------------------&n;&n;&n;&t;&t; | no sync bw&t;| sync bw available and | sync bw available and&n;&t;&t; | available&t;| SynchTxMode = SPLIT&t;| SynchTxMode = ALL&n;&t;-----------------------------------------------------------------------&n;&t;sync tx&t; |     0 kB&t;|&t;32 kB&t;&t;|&t;55 kB&n;&t;queue&t; |&t;&t;|   TX_MEDIUM_FIFO&t;|   TX_LARGE_FIFO&n;&t;-----------------------------------------------------------------------&n;&t;async tx |    64 kB&t;|&t;32 kB&t;&t;|&t; 9 k&n;&t;queue&t; | TX_FIFO_SPACE|   TX_MEDIUM_FIFO&t;|   TX_SMALL_FIFO&n;&n;&t;END_MANUAL_ENTRY&n;*/
multiline_comment|/*&n;&t; * set the tx mode bits&n;&t; */
r_if
c_cond
(paren
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHSbaPayload
)paren
(brace
macro_line|#ifdef ESS
id|smc-&gt;hw.fp.fifo.fifo_config_mode
op_or_assign
id|smc-&gt;mib.fddiESSSynchTxMode
op_or
id|SYNC_TRAFFIC_ON
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|smc-&gt;hw.fp.fifo.fifo_config_mode
op_and_assign
op_complement
(paren
id|SEND_ASYNC_AS_SYNC
op_or
id|SYNC_TRAFFIC_ON
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * split up the FIFO&n;&t; */
r_if
c_cond
(paren
id|smc-&gt;hw.fp.fifo.fifo_config_mode
op_amp
id|SYNC_TRAFFIC_ON
)paren
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.fp.fifo.fifo_config_mode
op_amp
id|SEND_ASYNC_AS_SYNC
)paren
(brace
id|smc-&gt;hw.fp.fifo.tx_s_size
op_assign
id|TX_LARGE_FIFO
suffix:semicolon
id|smc-&gt;hw.fp.fifo.tx_a0_size
op_assign
id|TX_SMALL_FIFO
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;hw.fp.fifo.tx_s_size
op_assign
id|TX_MEDIUM_FIFO
suffix:semicolon
id|smc-&gt;hw.fp.fifo.tx_a0_size
op_assign
id|TX_MEDIUM_FIFO
suffix:semicolon
)brace
)brace
r_else
(brace
id|smc-&gt;hw.fp.fifo.tx_s_size
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.fp.fifo.tx_a0_size
op_assign
id|TX_FIFO_SPACE
suffix:semicolon
)brace
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
op_assign
id|smc-&gt;hw.fp.fifo.rbc_ram_start
op_plus
id|RX_FIFO_OFF
suffix:semicolon
id|smc-&gt;hw.fp.fifo.tx_s_start
op_assign
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
op_plus
id|smc-&gt;hw.fp.fifo.rx1_fifo_size
suffix:semicolon
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_assign
id|smc-&gt;hw.fp.fifo.tx_s_start
op_plus
id|smc-&gt;hw.fp.fifo.tx_s_size
suffix:semicolon
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
op_assign
id|smc-&gt;hw.fp.fifo.tx_a0_start
op_plus
id|smc-&gt;hw.fp.fifo.tx_a0_size
suffix:semicolon
id|DB_SMT
c_func
(paren
l_string|&quot;FIFO split: mode = %x&bslash;n&quot;
comma
id|smc-&gt;hw.fp.fifo.fifo_config_mode
comma
l_int|0
)paren
suffix:semicolon
id|DB_SMT
c_func
(paren
l_string|&quot;rbc_ram_start =&t;%x&t; rbc_ram_end = &t;%x&bslash;n&quot;
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_start
comma
id|smc-&gt;hw.fp.fifo.rbc_ram_end
)paren
suffix:semicolon
id|DB_SMT
c_func
(paren
l_string|&quot;rx1_fifo_start = %x&t; tx_s_start = &t;%x&bslash;n&quot;
comma
id|smc-&gt;hw.fp.fifo.rx1_fifo_start
comma
id|smc-&gt;hw.fp.fifo.tx_s_start
)paren
suffix:semicolon
id|DB_SMT
c_func
(paren
l_string|&quot;tx_a0_start =&t;%x&t; rx2_fifo_start = &t;%x&bslash;n&quot;
comma
id|smc-&gt;hw.fp.fifo.tx_a0_start
comma
id|smc-&gt;hw.fp.fifo.rx2_fifo_start
)paren
suffix:semicolon
)brace
DECL|function|formac_reinit_tx
r_void
id|formac_reinit_tx
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
multiline_comment|/*&n;&t; * Split up the FIFO and reinitialize the MAC if synchronous&n;&t; * bandwidth becomes available but no synchronous queue is&n;&t; * configured.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;hw.fp.fifo.tx_s_size
op_logical_and
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHSbaPayload
)paren
(brace
(paren
r_void
)paren
id|init_mac
c_func
(paren
id|smc
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
eof
