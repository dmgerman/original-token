multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998,1999 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;See the file &quot;skfddi.c&quot; for further information.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/*&n;&t;parser for SMT parameters&n;*/
macro_line|#include &quot;h/types.h&quot;
macro_line|#include &quot;h/fddi.h&quot;
macro_line|#include &quot;h/smc.h&quot;
macro_line|#include &quot;h/smt_p.h&quot;
DECL|macro|KERNEL
mdefine_line|#define KERNEL
macro_line|#include &quot;h/smtstate.h&quot;
macro_line|#ifndef&t;lint
DECL|variable|ID_sccs
r_static
r_const
r_char
id|ID_sccs
(braket
)braket
op_assign
l_string|&quot;@(#)smtparse.c&t;1.12 98/10/06 (C) SK &quot;
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;sun
DECL|macro|_far
mdefine_line|#define _far
macro_line|#endif
multiline_comment|/*&n; * convert to BCLK units&n; */
DECL|macro|MS2BCLK
mdefine_line|#define MS2BCLK(x)      ((x)*12500L)
DECL|macro|US2BCLK
mdefine_line|#define US2BCLK(x)      ((x/10)*125L)
multiline_comment|/*&n; * parameter table&n; */
DECL|struct|s_ptab
r_static
r_struct
id|s_ptab
(brace
DECL|member|pt_name
r_char
op_star
id|pt_name
suffix:semicolon
DECL|member|pt_num
id|u_short
id|pt_num
suffix:semicolon
DECL|member|pt_type
id|u_short
id|pt_type
suffix:semicolon
DECL|member|pt_min
id|u_long
id|pt_min
suffix:semicolon
DECL|member|pt_max
id|u_long
id|pt_max
suffix:semicolon
DECL|variable|ptab
)brace
id|ptab
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;PMFPASSWD&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_string|&quot;USERDATA&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;LERCUTOFFA&quot;
comma
l_int|2
comma
l_int|1
comma
l_int|4
comma
l_int|15
)brace
comma
(brace
l_string|&quot;LERCUTOFFB&quot;
comma
l_int|3
comma
l_int|1
comma
l_int|4
comma
l_int|15
)brace
comma
(brace
l_string|&quot;LERALARMA&quot;
comma
l_int|4
comma
l_int|1
comma
l_int|4
comma
l_int|15
)brace
comma
(brace
l_string|&quot;LERALARMB&quot;
comma
l_int|5
comma
l_int|1
comma
l_int|4
comma
l_int|15
)brace
comma
(brace
l_string|&quot;TMAX&quot;
comma
l_int|6
comma
l_int|1
comma
l_int|5
comma
l_int|165
)brace
comma
(brace
l_string|&quot;TMIN&quot;
comma
l_int|7
comma
l_int|1
comma
l_int|5
comma
l_int|165
)brace
comma
(brace
l_string|&quot;TREQ&quot;
comma
l_int|8
comma
l_int|1
comma
l_int|5
comma
l_int|165
)brace
comma
(brace
l_string|&quot;TVX&quot;
comma
l_int|9
comma
l_int|1
comma
l_int|2500
comma
l_int|10000
)brace
comma
macro_line|#ifdef ESS
(brace
l_string|&quot;SBAPAYLOAD&quot;
comma
l_int|10
comma
l_int|1
comma
l_int|0
comma
l_int|1562
)brace
comma
(brace
l_string|&quot;SBAOVERHEAD&quot;
comma
l_int|11
comma
l_int|1
comma
l_int|50
comma
l_int|5000
)brace
comma
(brace
l_string|&quot;MAXTNEG&quot;
comma
l_int|12
comma
l_int|1
comma
l_int|5
comma
l_int|165
)brace
comma
(brace
l_string|&quot;MINSEGMENTSIZE&quot;
comma
l_int|13
comma
l_int|1
comma
l_int|0
comma
l_int|4478
)brace
comma
(brace
l_string|&quot;SBACATEGORY&quot;
comma
l_int|14
comma
l_int|1
comma
l_int|0
comma
l_int|0xffff
)brace
comma
(brace
l_string|&quot;SYNCHTXMODE&quot;
comma
l_int|15
comma
l_int|0
)brace
comma
macro_line|#endif
macro_line|#ifdef SBA
(brace
l_string|&quot;SBACOMMAND&quot;
comma
l_int|16
comma
l_int|0
)brace
comma
(brace
l_string|&quot;SBAAVAILABLE&quot;
comma
l_int|17
comma
l_int|1
comma
l_int|0
comma
l_int|100
)brace
comma
macro_line|#endif
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Define maximum string size for values and keybuffer */
DECL|macro|MAX_VAL
mdefine_line|#define MAX_VAL&t;40
multiline_comment|/*&n; * local function declarations&n; */
r_static
id|u_long
id|parse_num
c_func
(paren
)paren
suffix:semicolon
r_static
r_int
id|parse_word
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef SIM
DECL|macro|DB_MAIN
mdefine_line|#define DB_MAIN(a,b,c)&t;printf(a,b,c)
macro_line|#else
DECL|macro|DB_MAIN
mdefine_line|#define DB_MAIN(a,b,c)
macro_line|#endif
multiline_comment|/*&n; * BEGIN_MANUAL_ENTRY()&n; *&n; *&t;int smt_parse_arg(struct s_smc *,char _far *keyword,int type,&n;&t;&t;char _far *value)&n; *&n; *&t;parse SMT parameter&n; *&t;*keyword&n; *&t;&t;pointer to keyword, must be &bslash;0, &bslash;n or &bslash;r terminated&n; *&t;*value&t;pointer to value, either char * or u_long *&n; *&t;&t;if char *&n; *&t;&t;&t;pointer to value, must be &bslash;0, &bslash;n or &bslash;r terminated&n; *&t;&t;if u_long *&n; *&t;&t;&t;contains binary value&n; *&n; *&t;type&t;0: integer&n; *&t;&t;1: string&n; *&t;return&n; *&t;&t;0&t;parameter parsed ok&n; *&t;&t;!= 0&t;error&n; *&t;NOTE:&n; *&t;&t;function can be called with DS != SS&n; *&n; *&n; * END_MANUAL_ENTRY()&n; */
DECL|function|smt_parse_arg
r_int
id|smt_parse_arg
c_func
(paren
id|smc
comma
id|keyword
comma
id|type
comma
id|value
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_char
id|_far
op_star
id|keyword
suffix:semicolon
r_int
id|type
suffix:semicolon
r_char
id|_far
op_star
id|value
suffix:semicolon
(brace
r_char
id|keybuf
(braket
id|MAX_VAL
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|valbuf
(braket
id|MAX_VAL
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|c
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|v
suffix:semicolon
r_char
op_star
id|d
suffix:semicolon
id|u_long
id|val
op_assign
l_int|0
suffix:semicolon
r_struct
id|s_ptab
op_star
id|pt
suffix:semicolon
r_int
id|st
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * parse keyword&n;&t; */
r_if
c_cond
(paren
(paren
id|st
op_assign
id|parse_word
c_func
(paren
id|keybuf
comma
id|keyword
)paren
)paren
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * parse value if given as string&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|parse_word
c_func
(paren
id|valbuf
comma
id|value
)paren
)paren
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * search in table&n;&t; */
id|st
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pt
op_assign
id|ptab
suffix:semicolon
(paren
id|v
op_assign
id|pt-&gt;pt_name
)paren
suffix:semicolon
id|pt
op_increment
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|keybuf
suffix:semicolon
(paren
id|c
op_assign
op_star
id|p
)paren
suffix:semicolon
id|p
op_increment
comma
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
op_star
id|v
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_and
op_logical_neg
op_star
id|v
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|v
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if&t;0
id|printf
c_func
(paren
l_string|&quot;=&gt;%s&lt;==&gt;%s&lt;=&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|valbuf
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * set value in MIB&n;&t; */
r_if
c_cond
(paren
id|pt-&gt;pt_type
)paren
id|val
op_assign
id|parse_num
c_func
(paren
id|type
comma
id|value
comma
id|valbuf
comma
id|pt-&gt;pt_min
comma
id|pt-&gt;pt_max
comma
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pt-&gt;pt_num
)paren
(brace
r_case
l_int|0
suffix:colon
id|v
op_assign
id|valbuf
suffix:semicolon
id|d
op_assign
(paren
r_char
op_star
)paren
id|smc-&gt;mib.fddiPRPMFPasswd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
r_sizeof
(paren
id|smc-&gt;mib.fddiPRPMFPasswd
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|d
op_increment
op_assign
op_star
id|v
op_increment
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %s&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|smc-&gt;mib.fddiPRPMFPasswd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|v
op_assign
id|valbuf
suffix:semicolon
id|d
op_assign
(paren
r_char
op_star
)paren
id|smc-&gt;mib.fddiSMTUserData
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
r_sizeof
(paren
id|smc-&gt;mib.fddiSMTUserData
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|d
op_increment
op_assign
op_star
id|v
op_increment
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %s&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|smc-&gt;mib.fddiSMTUserData
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|smc-&gt;mib.p
(braket
id|PA
)braket
dot
id|fddiPORTLer_Cutoff
op_assign
(paren
id|u_char
)paren
id|val
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|smc-&gt;mib.p
(braket
id|PA
)braket
dot
id|fddiPORTLer_Cutoff
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|smc-&gt;mib.p
(braket
id|PB
)braket
dot
id|fddiPORTLer_Cutoff
op_assign
(paren
id|u_char
)paren
id|val
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|smc-&gt;mib.p
(braket
id|PB
)braket
dot
id|fddiPORTLer_Cutoff
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|smc-&gt;mib.p
(braket
id|PA
)braket
dot
id|fddiPORTLer_Alarm
op_assign
(paren
id|u_char
)paren
id|val
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|smc-&gt;mib.p
(braket
id|PA
)braket
dot
id|fddiPORTLer_Alarm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|smc-&gt;mib.p
(braket
id|PB
)braket
dot
id|fddiPORTLer_Alarm
op_assign
(paren
id|u_char
)paren
id|val
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|smc-&gt;mib.p
(braket
id|PB
)braket
dot
id|fddiPORTLer_Alarm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* TMAX */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHT_MaxLowerBound
op_assign
(paren
id|u_long
)paren
op_minus
id|MS2BCLK
c_func
(paren
(paren
r_int
)paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
multiline_comment|/* TMIN */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACT_Min
op_assign
(paren
id|u_long
)paren
op_minus
id|MS2BCLK
c_func
(paren
(paren
r_int
)paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* TREQ */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHMaxT_Req
op_assign
(paren
id|u_long
)paren
op_minus
id|MS2BCLK
c_func
(paren
(paren
r_int
)paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
multiline_comment|/* TVX */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d &bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.a
(braket
id|PATH0
)braket
dot
id|fddiPATHTVXLowerBound
op_assign
(paren
id|u_long
)paren
op_minus
id|US2BCLK
c_func
(paren
(paren
r_int
)paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;ESS
r_case
l_int|10
suffix:colon
multiline_comment|/* SBAPAYLOAD */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;mib.fddiESSPayload
op_ne
id|val
)paren
(brace
id|smc-&gt;ess.raf_act_timer_poll
op_assign
id|TRUE
suffix:semicolon
id|smc-&gt;mib.fddiESSPayload
op_assign
id|val
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* SBAOVERHEAD */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.fddiESSOverhead
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* MAXTNEG */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.fddiESSMaxTNeg
op_assign
(paren
id|u_long
)paren
op_minus
id|MS2BCLK
c_func
(paren
(paren
r_int
)paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
multiline_comment|/* MINSEGMENTSIZE */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.fddiESSMinSegmentSize
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* SBACATEGORY */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.fddiESSCategory
op_assign
(paren
id|smc-&gt;mib.fddiESSCategory
op_amp
l_int|0xffff
)paren
op_or
(paren
(paren
id|u_long
)paren
(paren
id|val
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
multiline_comment|/* SYNCHTXMODE */
multiline_comment|/* do not use memcmp(valbuf,&quot;ALL&quot;,3) because DS != SS */
r_if
c_cond
(paren
id|valbuf
(braket
l_int|0
)braket
op_eq
l_char|&squot;A&squot;
op_logical_and
id|valbuf
(braket
l_int|1
)braket
op_eq
l_char|&squot;L&squot;
op_logical_and
id|valbuf
(braket
l_int|2
)braket
op_eq
l_char|&squot;L&squot;
)paren
(brace
id|smc-&gt;mib.fddiESSSynchTxMode
op_assign
id|TRUE
suffix:semicolon
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %s&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|valbuf
)paren
suffix:semicolon
)brace
multiline_comment|/* if (!memcmp(valbuf,&quot;SPLIT&quot;,5)) { */
r_if
c_cond
(paren
id|valbuf
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|valbuf
(braket
l_int|1
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|valbuf
(braket
l_int|2
)braket
op_eq
l_char|&squot;L&squot;
op_logical_and
id|valbuf
(braket
l_int|3
)braket
op_eq
l_char|&squot;I&squot;
op_logical_and
id|valbuf
(braket
l_int|4
)braket
op_eq
l_char|&squot;T&squot;
)paren
(brace
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %s&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|valbuf
)paren
suffix:semicolon
id|smc-&gt;mib.fddiESSSynchTxMode
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;SBA
r_case
l_int|16
suffix:colon
multiline_comment|/* SBACOMMAND */
multiline_comment|/* if (!memcmp(valbuf,&quot;START&quot;,5)) { */
r_if
c_cond
(paren
id|valbuf
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|valbuf
(braket
l_int|1
)braket
op_eq
l_char|&squot;T&squot;
op_logical_and
id|valbuf
(braket
l_int|2
)braket
op_eq
l_char|&squot;A&squot;
op_logical_and
id|valbuf
(braket
l_int|3
)braket
op_eq
l_char|&squot;R&squot;
op_logical_and
id|valbuf
(braket
l_int|4
)braket
op_eq
l_char|&squot;T&squot;
)paren
(brace
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %s&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|valbuf
)paren
suffix:semicolon
id|smc-&gt;mib.fddiSBACommand
op_assign
id|SB_START
suffix:semicolon
)brace
multiline_comment|/* if (!memcmp(valbuf,&quot;STOP&quot;,4)) { */
r_if
c_cond
(paren
id|valbuf
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|valbuf
(braket
l_int|1
)braket
op_eq
l_char|&squot;T&squot;
op_logical_and
id|valbuf
(braket
l_int|2
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|valbuf
(braket
l_int|3
)braket
op_eq
l_char|&squot;P&squot;
)paren
(brace
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %s&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|valbuf
)paren
suffix:semicolon
id|smc-&gt;mib.fddiSBACommand
op_assign
id|SB_STOP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|17
suffix:colon
multiline_comment|/* SBAAVAILABLE */
id|DB_MAIN
c_func
(paren
l_string|&quot;SET %s = %d&bslash;n&quot;
comma
id|pt-&gt;pt_name
comma
id|val
)paren
suffix:semicolon
id|smc-&gt;mib.fddiSBAAvailable
op_assign
(paren
id|u_char
)paren
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parse_word
r_static
r_int
id|parse_word
c_func
(paren
id|buf
comma
id|text
)paren
r_char
op_star
id|buf
suffix:semicolon
r_char
id|_far
op_star
id|text
suffix:semicolon
(brace
r_char
id|c
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|p_len
suffix:semicolon
r_int
id|quote
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ok
suffix:semicolon
multiline_comment|/*&n;&t; * skip leading white space&n;&t; */
id|p
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_VAL
suffix:semicolon
id|i
op_increment
)paren
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|p_len
op_assign
l_int|0
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|text
op_increment
)paren
op_logical_and
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
op_logical_and
(paren
id|c
op_ne
l_char|&squot;&bslash;r&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_ne
l_char|&squot; &squot;
)paren
op_logical_and
(paren
id|c
op_ne
l_char|&squot;&bslash;t&squot;
)paren
)paren
(brace
id|ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|quote
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|quote
op_assign
l_int|0
suffix:semicolon
id|text
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * parse valbuf&n;&t; */
id|ok
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ok
op_logical_and
id|p_len
OL
id|MAX_VAL
op_minus
l_int|1
op_logical_and
(paren
id|c
op_assign
op_star
id|text
op_increment
)paren
op_logical_and
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
op_logical_and
(paren
id|c
op_ne
l_char|&squot;&bslash;r&squot;
)paren
)paren
(brace
r_switch
c_cond
(paren
id|quote
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
(paren
id|c
op_eq
l_char|&squot; &squot;
)paren
op_logical_or
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
op_logical_or
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
)paren
(brace
id|ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
id|p_len
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
id|p_len
op_increment
suffix:semicolon
id|quote
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&quot;&squot;
suffix:colon
id|ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|quote
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
id|p_len
op_increment
suffix:semicolon
)brace
)brace
)brace
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|buf
suffix:semicolon
(paren
id|c
op_assign
op_star
id|p
)paren
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
op_star
id|p
op_assign
id|c
op_plus
l_char|&squot;A&squot;
op_minus
l_char|&squot;a&squot;
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parse_num
r_static
id|u_long
id|parse_num
c_func
(paren
id|type
comma
id|value
comma
id|v
comma
id|mn
comma
id|mx
comma
id|scale
)paren
r_int
id|type
suffix:semicolon
r_char
id|_far
op_star
id|value
suffix:semicolon
r_char
op_star
id|v
suffix:semicolon
id|u_long
id|mn
suffix:semicolon
id|u_long
id|mx
suffix:semicolon
r_int
id|scale
suffix:semicolon
(brace
id|u_long
id|x
op_assign
l_int|0
suffix:semicolon
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
l_int|0
)paren
(brace
multiline_comment|/* integer */
id|u_long
id|_far
op_star
id|l
suffix:semicolon
id|u_long
id|u1
suffix:semicolon
id|l
op_assign
(paren
id|u_long
id|_far
op_star
)paren
id|value
suffix:semicolon
id|u1
op_assign
op_star
id|l
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if the value is negative take the lower limit&n;&t;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
id|u1
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_minus
(paren
(paren
r_int
)paren
id|u1
)paren
OG
(paren
r_int
)paren
id|mx
)paren
(brace
id|u1
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|u1
op_assign
(paren
id|u_long
)paren
op_minus
(paren
(paren
r_int
)paren
id|u1
)paren
suffix:semicolon
)brace
)brace
id|x
op_assign
id|u1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* string */
r_int
id|sign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|v
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|sign
op_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|v
op_increment
)paren
op_logical_and
(paren
id|c
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|c
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
id|x
op_assign
id|x
op_star
l_int|10
op_plus
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scale
op_eq
l_int|10
)paren
(brace
id|x
op_mul_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
op_star
id|v
op_increment
)paren
op_logical_and
(paren
id|c
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|c
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
id|x
op_add_assign
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|sign
)paren
id|x
op_assign
(paren
id|u_long
)paren
op_minus
(paren
(paren
r_int
)paren
id|x
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if the value is negative&n;&t; *&t;and the absolute value is outside the limits&n;&t; *&t;&t;take the lower limit&n;&t; *&t;else&n;&t; *&t;&t;take the absoute value&n;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
id|x
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_minus
(paren
(paren
r_int
)paren
id|x
)paren
OG
(paren
r_int
)paren
id|mx
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|x
op_assign
(paren
id|u_long
)paren
op_minus
(paren
(paren
r_int
)paren
id|x
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|x
OL
id|mn
)paren
r_return
(paren
id|mn
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x
OG
id|mx
)paren
r_return
(paren
id|mx
)paren
suffix:semicolon
r_return
(paren
id|x
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_struct
id|s_smc
id|SMC
suffix:semicolon
id|main
c_func
(paren
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|v
suffix:semicolon
r_char
id|buf
(braket
l_int|100
)braket
suffix:semicolon
r_int
id|toggle
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|gets
c_func
(paren
id|buf
)paren
)paren
(brace
id|p
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
(paren
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
)paren
op_logical_or
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
)paren
)paren
id|p
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
(paren
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
)paren
op_logical_and
(paren
op_star
id|p
op_ne
l_char|&squot;&bslash;t&squot;
)paren
)paren
)paren
id|p
op_increment
suffix:semicolon
id|v
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|v
op_logical_and
(paren
(paren
op_star
id|v
op_eq
l_char|&squot; &squot;
)paren
op_logical_or
(paren
op_star
id|v
op_eq
l_char|&squot;&bslash;t&squot;
)paren
)paren
)paren
id|v
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|v
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
op_star
id|v
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
id|toggle
op_assign
op_logical_neg
id|toggle
suffix:semicolon
r_if
c_cond
(paren
id|toggle
)paren
(brace
id|u_long
id|l
suffix:semicolon
id|l
op_assign
id|atol
c_func
(paren
id|v
)paren
suffix:semicolon
id|smt_parse_arg
c_func
(paren
op_amp
id|SMC
comma
id|buf
comma
l_int|0
comma
(paren
r_char
id|_far
op_star
)paren
op_amp
id|l
)paren
suffix:semicolon
)brace
r_else
id|smt_parse_arg
c_func
(paren
op_amp
id|SMC
comma
id|buf
comma
l_int|1
comma
(paren
r_char
id|_far
op_star
)paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|smt_parse_arg
c_func
(paren
op_amp
id|SMC
comma
id|buf
comma
l_int|1
comma
(paren
r_char
id|_far
op_star
)paren
id|p
)paren
suffix:semicolon
)brace
)brace
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
