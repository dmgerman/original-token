multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998,1999 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;See the file &quot;skfddi.c&quot; for further information.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/*&n; * FBI board dependent Driver for SMT and LLC&n; */
macro_line|#include &quot;h/types.h&quot;
macro_line|#include &quot;h/fddi.h&quot;
macro_line|#include &quot;h/smc.h&quot;
macro_line|#include &quot;h/supern_2.h&quot;
macro_line|#include &quot;h/skfbiinc.h&quot;
macro_line|#ifndef&t;lint
DECL|variable|ID_sccs
r_static
r_const
r_char
id|ID_sccs
(braket
)braket
op_assign
l_string|&quot;@(#)drvfbi.c&t;1.63 99/02/11 (C) SK &quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * PCM active state&n; */
DECL|macro|PC8_ACTIVE
mdefine_line|#define PC8_ACTIVE&t;8
DECL|macro|LED_Y_ON
mdefine_line|#define&t;LED_Y_ON&t;0x11&t;/* Used for ring up/down indication */
DECL|macro|LED_Y_OFF
mdefine_line|#define&t;LED_Y_OFF&t;0x10
DECL|macro|MS2BCLK
mdefine_line|#define MS2BCLK(x)&t;((x)*12500L)
multiline_comment|/*&n; * valid configuration values are:&n; */
macro_line|#ifdef&t;ISA
DECL|variable|opt_ints
r_const
r_int
id|opt_ints
(braket
)braket
op_assign
(brace
l_int|8
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|15
)brace
suffix:semicolon
DECL|variable|opt_iops
r_const
r_int
id|opt_iops
(braket
)braket
op_assign
(brace
l_int|8
comma
l_int|0x100
comma
l_int|0x120
comma
l_int|0x180
comma
l_int|0x1a0
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x320
comma
l_int|0x340
)brace
suffix:semicolon
DECL|variable|opt_dmas
r_const
r_int
id|opt_dmas
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|3
comma
l_int|5
comma
l_int|6
comma
l_int|7
)brace
suffix:semicolon
DECL|variable|opt_eproms
r_const
r_int
id|opt_eproms
(braket
)braket
op_assign
(brace
l_int|15
comma
l_int|0xc0
comma
l_int|0xc2
comma
l_int|0xc4
comma
l_int|0xc6
comma
l_int|0xc8
comma
l_int|0xca
comma
l_int|0xcc
comma
l_int|0xce
comma
l_int|0xd0
comma
l_int|0xd2
comma
l_int|0xd4
comma
l_int|0xd6
comma
l_int|0xd8
comma
l_int|0xda
comma
l_int|0xdc
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;EISA
DECL|variable|opt_ints
r_const
r_int
id|opt_ints
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
)brace
suffix:semicolon
DECL|variable|opt_dmas
r_const
r_int
id|opt_dmas
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|5
comma
l_int|6
comma
l_int|7
)brace
suffix:semicolon
DECL|variable|opt_eproms
r_const
r_int
id|opt_eproms
(braket
)braket
op_assign
(brace
l_int|0xc0
comma
l_int|0xc2
comma
l_int|0xc4
comma
l_int|0xc6
comma
l_int|0xc8
comma
l_int|0xca
comma
l_int|0xcc
comma
l_int|0xce
comma
l_int|0xd0
comma
l_int|0xd2
comma
l_int|0xd4
comma
l_int|0xd6
comma
l_int|0xd8
comma
l_int|0xda
comma
l_int|0xdc
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;MCA
DECL|variable|opt_ints
r_int
id|opt_ints
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|11
comma
l_int|10
comma
l_int|9
)brace
suffix:semicolon
multiline_comment|/* FM1 */
DECL|variable|opt_eproms
r_int
id|opt_eproms
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0xc4
comma
l_int|0xc8
comma
l_int|0xcc
comma
l_int|0xd0
comma
l_int|0xd4
comma
l_int|0xd8
comma
l_int|0xdc
)brace
suffix:semicolon
macro_line|#endif&t;/* MCA */
multiline_comment|/*&n; *&t;xPOS_ID:xxxx&n; *&t;|&t;&bslash;  /&n; *&t;|&t; &bslash;/&n; *&t;|&t;  --------------------- the patched POS_ID of the Adapter&n; *&t;|&t;&t;&t;&t;xxxx = (Vendor ID low byte,&n; *&t;|&t;&t;&t;&t;&t;Vendor ID high byte,&n; *&t;|&t;&t;&t;&t;&t;Device ID low byte,&n; *&t;|&t;&t;&t;&t;&t;Device ID high byte)&n; *&t;+------------------------------ the patched oem_id must be&n; *&t;&t;&t;&t;&t;&squot;S&squot; for SK or &squot;I&squot; for IBM&n; *&t;&t;&t;&t;&t;this is a short id for the driver.&n; */
macro_line|#ifndef MULT_OEM
macro_line|#ifndef&t;OEM_CONCEPT
macro_line|#ifndef MCA
DECL|variable|oem_id
r_const
id|u_char
id|oem_id
(braket
)braket
op_assign
l_string|&quot;xPOS_ID:xxxx&quot;
suffix:semicolon
macro_line|#else
DECL|variable|oem_id
r_const
id|u_char
id|oem_id
(braket
)braket
op_assign
l_string|&quot;xPOSID1:xxxx&quot;
suffix:semicolon
multiline_comment|/* FM1 card id. */
macro_line|#endif
macro_line|#else&t;/* OEM_CONCEPT */
macro_line|#ifndef MCA
DECL|variable|oem_id
r_const
id|u_char
id|oem_id
(braket
)braket
op_assign
id|OEM_ID
suffix:semicolon
macro_line|#else
DECL|variable|oem_id
r_const
id|u_char
id|oem_id
(braket
)braket
op_assign
id|OEM_ID1
suffix:semicolon
multiline_comment|/* FM1 card id. */
macro_line|#endif&t;/* MCA */
macro_line|#endif&t;/* OEM_CONCEPT */
DECL|macro|ID_BYTE0
mdefine_line|#define&t;ID_BYTE0&t;8
DECL|macro|OEMID
mdefine_line|#define&t;OEMID(smc,i)&t;oem_id[ID_BYTE0 + i]
macro_line|#else&t;/* MULT_OEM */
DECL|variable|oem_ids
r_const
r_struct
id|s_oem_ids
id|oem_ids
(braket
)braket
op_assign
(brace
macro_line|#include &quot;oemids.h&quot;
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|OEMID
mdefine_line|#define&t;OEMID(smc,i)&t;smc-&gt;hw.oem_id-&gt;oi_id[i]
macro_line|#endif&t;/* MULT_OEM */
multiline_comment|/* Prototypes of external functions */
r_extern
r_void
id|hwt_restart
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef AIX
r_extern
r_int
id|AIX_vpdReadByte
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Prototypes of local functions. */
r_void
id|smt_stop_watchdog
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef MCA
r_static
r_int
id|read_card_id
c_func
(paren
)paren
suffix:semicolon
r_static
r_void
id|DisableSlotAccess
c_func
(paren
)paren
suffix:semicolon
r_static
r_void
id|EnableSlotAccess
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef AIX
r_extern
r_int
id|attach_POS_addr
c_func
(paren
)paren
suffix:semicolon
r_extern
r_int
id|detach_POS_addr
c_func
(paren
)paren
suffix:semicolon
r_extern
id|u_char
id|read_POS
c_func
(paren
)paren
suffix:semicolon
r_extern
r_void
id|write_POS
c_func
(paren
)paren
suffix:semicolon
r_extern
r_int
id|AIX_vpdReadByte
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
DECL|macro|read_POS
mdefine_line|#define&t;read_POS(smc,a1,a2)&t;((u_char) inp(a1))
DECL|macro|write_POS
mdefine_line|#define&t;write_POS(smc,a1,a2,a3)&t;outp((a1),(a3))
macro_line|#endif
macro_line|#endif&t;/* MCA */
multiline_comment|/*&n; * FDDI card reset&n; */
DECL|function|card_start
r_static
r_void
id|card_start
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef&t;PCI
id|u_char
id|rev_id
suffix:semicolon
id|u_short
id|word
suffix:semicolon
macro_line|#endif
id|smt_stop_watchdog
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#ifdef&t;ISA
id|outpw
c_func
(paren
id|CSR_A
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
r_for
c_loop
(paren
id|i
op_assign
l_int|10
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
multiline_comment|/* delay for PLC&squot;s */
(paren
r_void
)paren
id|inpw
c_func
(paren
id|ISR_A
)paren
suffix:semicolon
id|OUT_82c54_TIMER
c_func
(paren
l_int|3
comma
id|COUNT
c_func
(paren
l_int|2
)paren
op_or
id|RW_OP
c_func
(paren
l_int|3
)paren
op_or
id|TMODE
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* counter 2, mode 2 */
id|OUT_82c54_TIMER
c_func
(paren
l_int|2
comma
l_int|97
)paren
suffix:semicolon
multiline_comment|/* LSB */
id|OUT_82c54_TIMER
c_func
(paren
l_int|2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* MSB ( 15.6 us ) */
id|outpw
c_func
(paren
id|CSR_A
comma
id|CS_CRESET
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;EISA
id|outpw
c_func
(paren
id|CSR_A
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
r_for
c_loop
(paren
id|i
op_assign
l_int|10
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
multiline_comment|/* delay for PLC&squot;s */
(paren
r_void
)paren
id|inpw
c_func
(paren
id|ISR_A
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|CSR_A
comma
id|CS_CRESET
)paren
suffix:semicolon
id|smc-&gt;hw.led
op_assign
(paren
l_int|2
op_lshift
l_int|6
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|CSR_A
comma
id|CS_CRESET
op_or
id|smc-&gt;hw.led
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;MCA
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|CARD_DIS
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
r_for
c_loop
(paren
id|i
op_assign
l_int|10
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
multiline_comment|/* delay for PLC&squot;s */
(paren
r_void
)paren
id|inpw
c_func
(paren
id|ISR_A
)paren
suffix:semicolon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|CARD_EN
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* first I/O after reset must not be a access to FORMAC or PLC */
multiline_comment|/*&n;&t; * bus timeout (MCA)&n;&t; */
id|OUT_82c54_TIMER
c_func
(paren
l_int|3
comma
id|COUNT
c_func
(paren
l_int|2
)paren
op_or
id|RW_OP
c_func
(paren
l_int|3
)paren
op_or
id|TMODE
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* counter 2, mode 3 */
id|OUT_82c54_TIMER
c_func
(paren
l_int|2
comma
(paren
l_int|2
op_star
l_int|24
)paren
)paren
suffix:semicolon
multiline_comment|/* 3.9 us * 2 square wave */
id|OUT_82c54_TIMER
c_func
(paren
l_int|2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* MSB */
multiline_comment|/* POS 102 indicated an activ Check Line or Buss Error monitoring */
r_if
c_cond
(paren
id|inpw
c_func
(paren
id|CSA_A
)paren
op_amp
(paren
id|POS_EN_CHKINT
op_or
id|POS_EN_BUS_ERR
)paren
)paren
(brace
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|IRQ_CHCK_EN
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_assign
id|inpw
c_func
(paren
id|CSR_A
)paren
)paren
op_amp
id|CS_SAS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_amp
id|CS_BYSTAT
)paren
)paren
(brace
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|BYPASS
c_func
(paren
id|STAT_INS
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* insert station */
)brace
)brace
id|outpw
c_func
(paren
id|LEDR_A
comma
id|LED_1
)paren
suffix:semicolon
multiline_comment|/* yellow */
macro_line|#endif&t;/* MCA */
macro_line|#ifdef&t;PCI
multiline_comment|/*&n;&t; * make sure no transfer activity is pending&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MINIT
)paren
suffix:semicolon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_HPI_SET
)paren
suffix:semicolon
id|hwt_wait_time
c_func
(paren
id|smc
comma
id|hwt_quick_read
c_func
(paren
id|smc
)paren
comma
id|MS2BCLK
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now reset everything&n;&t; */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_RST_SET
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
id|i
op_assign
(paren
r_int
)paren
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
)paren
suffix:semicolon
multiline_comment|/* do dummy read */
id|SK_UNUSED
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Make LINT happy. */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_RST_CLR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset all bits in the PCI STATUS register&n;&t; */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_TST_CTRL
)paren
comma
id|TST_CFG_WRITE_ON
)paren
suffix:semicolon
multiline_comment|/* enable for writes */
id|word
op_assign
id|inpw
c_func
(paren
id|PCI_C
c_func
(paren
id|PCI_STATUS
)paren
)paren
suffix:semicolon
id|outpw
c_func
(paren
id|PCI_C
c_func
(paren
id|PCI_STATUS
)paren
comma
id|word
op_or
id|PCI_ERRBITS
)paren
suffix:semicolon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_TST_CTRL
)paren
comma
id|TST_CFG_WRITE_OFF
)paren
suffix:semicolon
multiline_comment|/* disable writes */
multiline_comment|/*&n;&t; * Release the reset of all the State machines&n;&t; * Release Master_Reset&n;&t; * Release HPI_SM_Reset&n;&t; */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_MRST_CLR
op_or
id|CTRL_HPI_CLR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * determine the adapter type&n;&t; * Note: Do it here, because some drivers may call card_start() once&n;&t; *&t; at very first before any other initialization functions is&n;&t; *&t; executed.&n;&t; */
id|rev_id
op_assign
id|inp
c_func
(paren
id|PCI_C
c_func
(paren
id|PCI_REV_ID
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rev_id
op_amp
l_int|0xf0
)paren
op_eq
id|SK_ML_ID_1
op_logical_or
(paren
id|rev_id
op_amp
l_int|0xf0
)paren
op_eq
id|SK_ML_ID_2
)paren
(brace
id|smc-&gt;hw.hw_is_64bit
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;hw.hw_is_64bit
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Watermark initialization&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;hw.hw_is_64bit
)paren
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_F
)paren
comma
id|RX_WATERMARK
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_F
)paren
comma
id|TX_WATERMARK
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_F
)paren
comma
id|TX_WATERMARK
)paren
suffix:semicolon
)brace
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* clear the reset chips */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_LED
)paren
comma
id|LED_GA_OFF
op_or
id|LED_MY_ON
op_or
id|LED_GB_OFF
)paren
suffix:semicolon
multiline_comment|/* ye LED on */
multiline_comment|/* init the timer value for the watch dog 2,5 minutes */
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B2_WDOG_INI
)paren
comma
l_int|0x6FC23AC0
)paren
suffix:semicolon
multiline_comment|/* initialize the ISR mask */
id|smc-&gt;hw.is_imask
op_assign
id|ISR_MASK
suffix:semicolon
id|smc-&gt;hw.hw_state
op_assign
id|STOPPED
suffix:semicolon
macro_line|#endif
id|GET_PAGE
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* necessary for BOOT */
)brace
DECL|function|card_stop
r_void
id|card_stop
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|smt_stop_watchdog
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smc-&gt;hw.mac_ring_is_up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ring down */
macro_line|#ifdef&t;ISA
id|outpw
c_func
(paren
id|CSR_A
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
macro_line|#endif
macro_line|#ifdef&t;EISA
id|outpw
c_func
(paren
id|CSR_A
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
macro_line|#endif
macro_line|#ifdef&t;MCA
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|CARD_DIS
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
macro_line|#endif
macro_line|#ifdef&t;PCI
multiline_comment|/*&n;&t; * make sure no transfer activity is pending&n;&t; */
id|outpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_MDREG1
)paren
comma
id|FM_MINIT
)paren
suffix:semicolon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_HPI_SET
)paren
suffix:semicolon
id|hwt_wait_time
c_func
(paren
id|smc
comma
id|hwt_quick_read
c_func
(paren
id|smc
)paren
comma
id|MS2BCLK
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now reset everything&n;&t; */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_RST_SET
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_CTRL
)paren
comma
id|CTRL_RST_CLR
)paren
suffix:semicolon
multiline_comment|/* reset for all chips */
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_LED
)paren
comma
id|LED_GA_OFF
op_or
id|LED_MY_OFF
op_or
id|LED_GB_OFF
)paren
suffix:semicolon
multiline_comment|/* all LEDs off */
id|smc-&gt;hw.hw_state
op_assign
id|STOPPED
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*--------------------------- ISR handling ----------------------------------*/
macro_line|#ifndef PCI
DECL|function|mac1_irq
r_void
id|mac1_irq
c_func
(paren
id|smc
comma
id|stu
comma
id|stl
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|stu
suffix:semicolon
id|u_short
id|stl
suffix:semicolon
(brace
r_int
id|restart_tx
op_assign
l_int|0
suffix:semicolon
id|again
suffix:colon
macro_line|#ifndef ISA
multiline_comment|/*&n; * FORMAC+ bug modified the queue pointer if many read/write accesses happens!?&n; */
r_if
c_cond
(paren
id|stl
op_amp
(paren
id|FM_SPCEPDS
op_or
multiline_comment|/* parit/coding err. syn.q.*/
id|FM_SPCEPDA0
op_or
multiline_comment|/* parit/coding err. a.q.0 */
id|FM_SPCEPDA1
op_or
multiline_comment|/* parit/coding err. a.q.1 */
id|FM_SPCEPDA2
)paren
)paren
(brace
multiline_comment|/* parit/coding err. a.q.2 */
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0132
comma
id|SMT_E0132_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stl
op_amp
(paren
id|FM_STBURS
op_or
multiline_comment|/* tx buffer underrun syn.q.*/
id|FM_STBURA0
op_or
multiline_comment|/* tx buffer underrun a.q.0 */
id|FM_STBURA1
op_or
multiline_comment|/* tx buffer underrun a.q.1 */
id|FM_STBURA2
)paren
)paren
(brace
multiline_comment|/* tx buffer underrun a.q.2 */
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0133
comma
id|SMT_E0133_MSG
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|stu
op_amp
(paren
id|FM_SXMTABT
op_or
multiline_comment|/* transmit abort */
macro_line|#ifdef&t;SYNC
id|FM_STXABRS
op_or
multiline_comment|/* syn. tx abort */
macro_line|#endif&t;/* SYNC */
id|FM_STXABRA0
)paren
)paren
op_logical_or
multiline_comment|/* asyn. tx abort */
(paren
id|stl
op_amp
(paren
id|FM_SQLCKS
op_or
multiline_comment|/* lock for syn. q. */
id|FM_SQLCKA0
)paren
)paren
)paren
(brace
multiline_comment|/* lock for asyn. q. */
id|formac_tx_restart
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* init tx */
id|restart_tx
op_assign
l_int|1
suffix:semicolon
id|stu
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST1U
)paren
)paren
suffix:semicolon
id|stl
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST1L
)paren
)paren
suffix:semicolon
id|stu
op_and_assign
op_complement
(paren
id|FM_STECFRMA0
op_or
id|FM_STEFRMA0
op_or
id|FM_STEFRMS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stu
op_logical_or
id|stl
)paren
r_goto
id|again
suffix:semicolon
)brace
macro_line|#ifndef&t;SYNC
r_if
c_cond
(paren
id|stu
op_amp
(paren
id|FM_STECFRMA0
op_or
multiline_comment|/* end of chain asyn tx */
id|FM_STEFRMA0
)paren
)paren
(brace
multiline_comment|/* end of frame asyn tx */
multiline_comment|/* free tx_queue */
id|smc-&gt;hw.n_a_send
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|smc-&gt;hw.fp.tx_free
OL
id|smc-&gt;hw.fp.tx_max
)paren
(brace
id|start_next_send
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
id|restart_tx
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#else&t;/* SYNC */
r_if
c_cond
(paren
id|stu
op_amp
(paren
id|FM_STEFRMA0
op_or
multiline_comment|/* end of asyn tx */
id|FM_STEFRMS
)paren
)paren
(brace
multiline_comment|/* end of sync tx */
id|restart_tx
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;/* SYNC */
r_if
c_cond
(paren
id|restart_tx
)paren
id|llc_restart_tx
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#else&t;/* PCI */
DECL|function|mac1_irq
r_void
id|mac1_irq
c_func
(paren
id|smc
comma
id|stu
comma
id|stl
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|stu
suffix:semicolon
id|u_short
id|stl
suffix:semicolon
(brace
r_int
id|restart_tx
op_assign
l_int|0
suffix:semicolon
id|again
suffix:colon
multiline_comment|/*&n;&t; * parity error: note encoding error is not possible in tag mode&n;&t; */
r_if
c_cond
(paren
id|stl
op_amp
(paren
id|FM_SPCEPDS
op_or
multiline_comment|/* parity err. syn.q.*/
id|FM_SPCEPDA0
op_or
multiline_comment|/* parity err. a.q.0 */
id|FM_SPCEPDA1
)paren
)paren
(brace
multiline_comment|/* parity err. a.q.1 */
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0134
comma
id|SMT_E0134_MSG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * buffer underrun: can only occur if a tx threshold is specified&n;&t; */
r_if
c_cond
(paren
id|stl
op_amp
(paren
id|FM_STBURS
op_or
multiline_comment|/* tx buffer underrun syn.q.*/
id|FM_STBURA0
op_or
multiline_comment|/* tx buffer underrun a.q.0 */
id|FM_STBURA1
)paren
)paren
(brace
multiline_comment|/* tx buffer underrun a.q.2 */
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|SMT_E0133
comma
id|SMT_E0133_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stu
op_amp
(paren
id|FM_SXMTABT
op_or
multiline_comment|/* transmit abort */
id|FM_STXABRS
op_or
multiline_comment|/* syn. tx abort */
id|FM_STXABRA0
)paren
)paren
op_logical_or
multiline_comment|/* asyn. tx abort */
(paren
id|stl
op_amp
(paren
id|FM_SQLCKS
op_or
multiline_comment|/* lock for syn. q. */
id|FM_SQLCKA0
)paren
)paren
)paren
(brace
multiline_comment|/* lock for asyn. q. */
id|formac_tx_restart
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* init tx */
id|restart_tx
op_assign
l_int|1
suffix:semicolon
id|stu
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST1U
)paren
)paren
suffix:semicolon
id|stl
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST1L
)paren
)paren
suffix:semicolon
id|stu
op_and_assign
op_complement
(paren
id|FM_STECFRMA0
op_or
id|FM_STEFRMA0
op_or
id|FM_STEFRMS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stu
op_logical_or
id|stl
)paren
r_goto
id|again
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stu
op_amp
(paren
id|FM_STEFRMA0
op_or
multiline_comment|/* end of asyn tx */
id|FM_STEFRMS
)paren
)paren
(brace
multiline_comment|/* end of sync tx */
id|restart_tx
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|restart_tx
)paren
id|llc_restart_tx
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* PCI */
multiline_comment|/*&n; * interrupt source= plc1&n; * this function is called in nwfbisr.asm&n; */
DECL|function|plc1_irq
r_void
id|plc1_irq
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_short
id|st
op_assign
id|inpw
c_func
(paren
id|PLC
c_func
(paren
id|PB
comma
id|PL_INTR_EVENT
)paren
)paren
suffix:semicolon
macro_line|#if&t;(defined(ISA) || defined(EISA))
multiline_comment|/* reset PLC Int. bits */
id|outpw
c_func
(paren
id|PLC1_I
comma
id|inpw
c_func
(paren
id|PLC1_I
)paren
)paren
suffix:semicolon
macro_line|#endif
id|plc_irq
c_func
(paren
id|smc
comma
id|PB
comma
id|st
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * interrupt source= plc2&n; * this function is called in nwfbisr.asm&n; */
DECL|function|plc2_irq
r_void
id|plc2_irq
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_short
id|st
op_assign
id|inpw
c_func
(paren
id|PLC
c_func
(paren
id|PA
comma
id|PL_INTR_EVENT
)paren
)paren
suffix:semicolon
macro_line|#if&t;(defined(ISA) || defined(EISA))
multiline_comment|/* reset PLC Int. bits */
id|outpw
c_func
(paren
id|PLC2_I
comma
id|inpw
c_func
(paren
id|PLC2_I
)paren
)paren
suffix:semicolon
macro_line|#endif
id|plc_irq
c_func
(paren
id|smc
comma
id|PA
comma
id|st
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * interrupt source= timer&n; */
DECL|function|timer_irq
r_void
id|timer_irq
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|hwt_restart
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smc-&gt;hw.t_stop
op_assign
id|smc-&gt;hw.t_start
suffix:semicolon
id|smt_timer_done
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * return S-port (PA or PB)&n; */
DECL|function|pcm_get_s_port
r_int
id|pcm_get_s_port
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
r_return
(paren
id|PS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Station Label = &quot;FDDI-XYZ&quot; where&n; *&n; *&t;X = connector type&n; *&t;Y = PMD type&n; *&t;Z = port type&n; */
DECL|macro|STATION_LABEL_CONNECTOR_OFFSET
mdefine_line|#define STATION_LABEL_CONNECTOR_OFFSET&t;5
DECL|macro|STATION_LABEL_PMD_OFFSET
mdefine_line|#define STATION_LABEL_PMD_OFFSET&t;6
DECL|macro|STATION_LABEL_PORT_OFFSET
mdefine_line|#define STATION_LABEL_PORT_OFFSET&t;7
DECL|function|read_address
r_void
id|read_address
c_func
(paren
id|smc
comma
id|mac_addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_char
op_star
id|mac_addr
suffix:semicolon
(brace
r_char
id|ConnectorType
suffix:semicolon
r_char
id|PmdType
suffix:semicolon
r_int
id|i
suffix:semicolon
r_extern
r_const
id|u_char
id|canonical
(braket
l_int|256
)braket
suffix:semicolon
macro_line|#if&t;(defined(ISA) || defined(MCA))
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* read mac address from board */
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
(paren
id|inpw
c_func
(paren
id|PR_A
c_func
(paren
id|i
op_plus
id|SA_MAC
)paren
)paren
op_amp
l_int|0xff
)paren
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
(paren
id|inpw
c_func
(paren
id|PR_A
c_func
(paren
id|i
op_plus
id|SA_MAC
op_plus
id|PRA_OFF
)paren
)paren
op_amp
l_int|0xff
)paren
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef&t;EISA
multiline_comment|/*&n;&t; * Note: We get trouble on an Alpha machine if we make a inpw()&n;&t; * instead of inp()&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* read mac address from board */
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
id|inp
c_func
(paren
id|PR_A
c_func
(paren
id|i
op_plus
id|SA_MAC
)paren
)paren
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
id|inp
c_func
(paren
id|PR_A
c_func
(paren
id|i
op_plus
id|SA_MAC
op_plus
id|PRA_OFF
)paren
)paren
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef&t;PCI
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* read mac address from board */
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B2_MAC_0
op_plus
id|i
)paren
)paren
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef&t;PCI
id|ConnectorType
op_assign
id|inpw
c_func
(paren
id|PR_A
c_func
(paren
id|SA_PMD_TYPE
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
id|PmdType
op_assign
id|inpw
c_func
(paren
id|PR_A
c_func
(paren
id|SA_PMD_TYPE
op_plus
l_int|1
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
macro_line|#else
id|ConnectorType
op_assign
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B2_CONN_TYP
)paren
)paren
suffix:semicolon
id|PmdType
op_assign
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B2_PMD_TYP
)paren
)paren
suffix:semicolon
macro_line|#endif
id|smc-&gt;y
(braket
id|PA
)braket
dot
id|pmd_type
(braket
id|PMD_SK_CONN
)braket
op_assign
id|smc-&gt;y
(braket
id|PB
)braket
dot
id|pmd_type
(braket
id|PMD_SK_CONN
)braket
op_assign
id|ConnectorType
suffix:semicolon
id|smc-&gt;y
(braket
id|PA
)braket
dot
id|pmd_type
(braket
id|PMD_SK_PMD
)braket
op_assign
id|smc-&gt;y
(braket
id|PB
)braket
dot
id|pmd_type
(braket
id|PMD_SK_PMD
)braket
op_assign
id|PmdType
suffix:semicolon
r_if
c_cond
(paren
id|mac_addr
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|smc-&gt;hw.fddi_canon_addr.a
(braket
id|i
)braket
op_assign
id|mac_addr
(braket
id|i
)braket
suffix:semicolon
id|smc-&gt;hw.fddi_home_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
id|mac_addr
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|smc-&gt;hw.fddi_home_addr
op_assign
id|smc-&gt;hw.fddi_phys_addr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|smc-&gt;hw.fddi_canon_addr.a
(braket
id|i
)braket
op_assign
id|canonical
(braket
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * FDDI card soft reset&n; */
DECL|function|init_board
r_void
id|init_board
c_func
(paren
id|smc
comma
id|mac_addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_char
op_star
id|mac_addr
suffix:semicolon
(brace
id|card_start
c_func
(paren
id|smc
)paren
suffix:semicolon
id|read_address
c_func
(paren
id|smc
comma
id|mac_addr
)paren
suffix:semicolon
macro_line|#ifndef&t;PCI
r_if
c_cond
(paren
id|inpw
c_func
(paren
id|CSR_A
)paren
op_amp
id|CS_SAS
)paren
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_DAS
)paren
)paren
op_amp
id|DAS_AVAIL
)paren
)paren
macro_line|#endif
id|smc-&gt;s.sas
op_assign
id|SMT_SAS
suffix:semicolon
multiline_comment|/* Single att. station */
r_else
id|smc-&gt;s.sas
op_assign
id|SMT_DAS
suffix:semicolon
multiline_comment|/* Dual att. station */
macro_line|#ifndef&t;PCI
r_if
c_cond
(paren
id|inpw
c_func
(paren
id|CSR_A
)paren
op_amp
id|CS_BYSTAT
)paren
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_DAS
)paren
)paren
op_amp
id|DAS_BYP_ST
)paren
)paren
macro_line|#endif
id|smc-&gt;mib.fddiSMTBypassPresent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* without opt. bypass */
r_else
id|smc-&gt;mib.fddiSMTBypassPresent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* with opt. bypass */
)brace
multiline_comment|/*&n; * insert or deinsert optical bypass (called by ECM)&n; */
DECL|function|sm_pm_bypass_req
r_void
id|sm_pm_bypass_req
c_func
(paren
id|smc
comma
id|mode
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|mode
suffix:semicolon
(brace
macro_line|#if&t;(defined(ISA) || defined(EISA))
r_int
id|csra_v
suffix:semicolon
macro_line|#endif
id|DB_ECMN
c_func
(paren
l_int|1
comma
l_string|&quot;ECM : sm_pm_bypass_req(%s)&bslash;n&quot;
comma
(paren
id|mode
op_eq
id|BP_INSERT
)paren
ques
c_cond
l_string|&quot;BP_INSERT&quot;
suffix:colon
l_string|&quot;BP_DEINSERT&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;s.sas
op_ne
id|SMT_DAS
)paren
r_return
suffix:semicolon
macro_line|#if&t;(defined(ISA) || defined(EISA))
id|csra_v
op_assign
id|inpw
c_func
(paren
id|CSR_A
)paren
op_amp
op_complement
id|CS_BYPASS
suffix:semicolon
macro_line|#ifdef&t;EISA
id|csra_v
op_or_assign
id|smc-&gt;hw.led
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|BP_INSERT
suffix:colon
id|outpw
c_func
(paren
id|CSR_A
comma
id|csra_v
op_or
id|CS_BYPASS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BP_DEINSERT
suffix:colon
id|outpw
c_func
(paren
id|CSR_A
comma
id|csra_v
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif&t;/* ISA / EISA */
macro_line|#ifdef&t;MCA
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|BP_INSERT
suffix:colon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|BYPASS
c_func
(paren
id|STAT_INS
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* insert station */
r_break
suffix:semicolon
r_case
id|BP_DEINSERT
suffix:colon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|BYPASS
c_func
(paren
id|STAT_BYP
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* bypass station */
r_break
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef&t;PCI
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|BP_INSERT
suffix:colon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_DAS
)paren
comma
id|DAS_BYP_INS
)paren
suffix:semicolon
multiline_comment|/* insert station */
r_break
suffix:semicolon
r_case
id|BP_DEINSERT
suffix:colon
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_DAS
)paren
comma
id|DAS_BYP_RMV
)paren
suffix:semicolon
multiline_comment|/* bypass station */
r_break
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * check if bypass connected&n; */
DECL|function|sm_pm_bypass_present
r_int
id|sm_pm_bypass_present
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
macro_line|#ifndef&t;PCI
r_return
(paren
(paren
id|inpw
c_func
(paren
id|CSR_A
)paren
op_amp
id|CS_BYSTAT
)paren
ques
c_cond
id|FALSE
suffix:colon
id|TRUE
)paren
suffix:semicolon
macro_line|#else
r_return
(paren
(paren
id|inp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_DAS
)paren
)paren
op_amp
id|DAS_BYP_ST
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|plc_clear_irq
r_void
id|plc_clear_irq
c_func
(paren
id|smc
comma
id|p
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|p
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#if&t;(defined(ISA) || defined(EISA))
r_switch
c_cond
(paren
id|p
)paren
(brace
r_case
id|PA
suffix:colon
multiline_comment|/* reset PLC Int. bits */
id|outpw
c_func
(paren
id|PLC2_I
comma
id|inpw
c_func
(paren
id|PLC2_I
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PB
suffix:colon
multiline_comment|/* reset PLC Int. bits */
id|outpw
c_func
(paren
id|PLC1_I
comma
id|inpw
c_func
(paren
id|PLC1_I
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#else
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * led_indication called by rmt_indication() and&n; * pcm_state_change()&n; *&n; * Input:&n; *&t;smc:&t;SMT context&n; *&t;led_event:&n; *&t;0&t;Only switch green LEDs according to their respective PCM state&n; *&t;LED_Y_OFF&t;just switch yellow LED off&n; *&t;LED_Y_ON&t;just switch yello LED on&n; */
DECL|function|led_indication
r_void
id|led_indication
c_func
(paren
id|smc
comma
id|led_event
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|led_event
suffix:semicolon
(brace
multiline_comment|/* use smc-&gt;hw.mac_ring_is_up == TRUE &n;&t; * as indication for Ring Operational&n;&t; */
id|u_short
id|led_state
suffix:semicolon
r_struct
id|s_phy
op_star
id|phy
suffix:semicolon
r_struct
id|fddi_mib_p
op_star
id|mib_a
suffix:semicolon
r_struct
id|fddi_mib_p
op_star
id|mib_b
suffix:semicolon
id|phy
op_assign
op_amp
id|smc-&gt;y
(braket
id|PA
)braket
suffix:semicolon
id|mib_a
op_assign
id|phy-&gt;mib
suffix:semicolon
id|phy
op_assign
op_amp
id|smc-&gt;y
(braket
id|PB
)braket
suffix:semicolon
id|mib_b
op_assign
id|phy-&gt;mib
suffix:semicolon
macro_line|#ifdef&t;EISA
multiline_comment|/* Ring up = yellow led OFF*/
r_if
c_cond
(paren
id|led_event
op_eq
id|LED_Y_ON
)paren
(brace
id|smc-&gt;hw.led
op_or_assign
id|CS_LED_1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|led_event
op_eq
id|LED_Y_OFF
)paren
(brace
id|smc-&gt;hw.led
op_and_assign
op_complement
id|CS_LED_1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Link at Port A or B = green led ON */
r_if
c_cond
(paren
id|mib_a-&gt;fddiPORTPCMState
op_eq
id|PC8_ACTIVE
op_logical_or
id|mib_b-&gt;fddiPORTPCMState
op_eq
id|PC8_ACTIVE
)paren
(brace
id|smc-&gt;hw.led
op_or_assign
id|CS_LED_0
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;hw.led
op_and_assign
op_complement
id|CS_LED_0
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef&t;MCA
id|led_state
op_assign
id|inpw
c_func
(paren
id|LEDR_A
)paren
suffix:semicolon
multiline_comment|/* Ring up = yellow led OFF*/
r_if
c_cond
(paren
id|led_event
op_eq
id|LED_Y_ON
)paren
(brace
id|led_state
op_or_assign
id|LED_1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|led_event
op_eq
id|LED_Y_OFF
)paren
(brace
id|led_state
op_and_assign
op_complement
id|LED_1
suffix:semicolon
)brace
r_else
(brace
id|led_state
op_and_assign
op_complement
(paren
id|LED_2
op_or
id|LED_0
)paren
suffix:semicolon
multiline_comment|/* Link at Port A = green led A ON */
r_if
c_cond
(paren
id|mib_a-&gt;fddiPORTPCMState
op_eq
id|PC8_ACTIVE
)paren
(brace
id|led_state
op_or_assign
id|LED_2
suffix:semicolon
)brace
multiline_comment|/* Link at Port B/S = green led B ON */
r_if
c_cond
(paren
id|mib_b-&gt;fddiPORTPCMState
op_eq
id|PC8_ACTIVE
)paren
(brace
id|led_state
op_or_assign
id|LED_0
suffix:semicolon
)brace
)brace
id|outpw
c_func
(paren
id|LEDR_A
comma
id|led_state
)paren
suffix:semicolon
macro_line|#endif&t;/* MCA */
macro_line|#ifdef&t;PCI
id|led_state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ring up = yellow led OFF*/
r_if
c_cond
(paren
id|led_event
op_eq
id|LED_Y_ON
)paren
(brace
id|led_state
op_or_assign
id|LED_MY_ON
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|led_event
op_eq
id|LED_Y_OFF
)paren
(brace
id|led_state
op_or_assign
id|LED_MY_OFF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PCM state changed */
multiline_comment|/* Link at Port A/S = green led A ON */
r_if
c_cond
(paren
id|mib_a-&gt;fddiPORTPCMState
op_eq
id|PC8_ACTIVE
)paren
(brace
id|led_state
op_or_assign
id|LED_GA_ON
suffix:semicolon
)brace
r_else
(brace
id|led_state
op_or_assign
id|LED_GA_OFF
suffix:semicolon
)brace
multiline_comment|/* Link at Port B = green led B ON */
r_if
c_cond
(paren
id|mib_b-&gt;fddiPORTPCMState
op_eq
id|PC8_ACTIVE
)paren
(brace
id|led_state
op_or_assign
id|LED_GB_ON
suffix:semicolon
)brace
r_else
(brace
id|led_state
op_or_assign
id|LED_GB_OFF
suffix:semicolon
)brace
)brace
id|outp
c_func
(paren
id|ADDR
c_func
(paren
id|B0_LED
)paren
comma
id|led_state
)paren
suffix:semicolon
macro_line|#endif&t;/* PCI */
)brace
DECL|function|pcm_state_change
r_void
id|pcm_state_change
c_func
(paren
id|smc
comma
id|plc
comma
id|p_state
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|plc
suffix:semicolon
r_int
id|p_state
suffix:semicolon
(brace
multiline_comment|/*&n;&t; * the current implementation of pcm_state_change() in the driver&n;&t; * parts must be renamed to drv_pcm_state_change() which will be called&n;&t; * now after led_indication.&n;&t; */
id|DRV_PCM_STATE_CHANGE
c_func
(paren
id|smc
comma
id|plc
comma
id|p_state
)paren
suffix:semicolon
id|led_indication
c_func
(paren
id|smc
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|rmt_indication
r_void
id|rmt_indication
c_func
(paren
id|smc
comma
id|i
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|i
suffix:semicolon
(brace
multiline_comment|/* Call a driver special function if defined */
id|DRV_RMT_INDICATION
c_func
(paren
id|smc
comma
id|i
)paren
suffix:semicolon
id|led_indication
c_func
(paren
id|smc
comma
id|i
ques
c_cond
id|LED_Y_OFF
suffix:colon
id|LED_Y_ON
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * llc_recover_tx called by init_tx (fplus.c)&n; */
DECL|function|llc_recover_tx
r_void
id|llc_recover_tx
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
macro_line|#ifdef&t;LOAD_GEN
r_extern
r_int
id|load_gen_flag
suffix:semicolon
id|load_gen_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifndef&t;SYNC
id|smc-&gt;hw.n_a_send
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*--------------------------- DMA init ----------------------------*/
macro_line|#ifdef&t;ISA
multiline_comment|/*&n; * init DMA&n; */
DECL|function|init_dma
r_void
id|init_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set cascade mode,&n;&t; * clear mask bit (enable DMA cannal)&n;&t; */
r_if
c_cond
(paren
id|dma
OG
l_int|3
)paren
(brace
id|outp
c_func
(paren
l_int|0xd6
comma
(paren
id|dma
op_amp
l_int|0x03
)paren
op_or
l_int|0xc0
)paren
suffix:semicolon
id|outp
c_func
(paren
l_int|0xd4
comma
id|dma
op_amp
l_int|0x03
)paren
suffix:semicolon
)brace
r_else
(brace
id|outp
c_func
(paren
l_int|0x0b
comma
(paren
id|dma
op_amp
l_int|0x03
)paren
op_or
l_int|0xc0
)paren
suffix:semicolon
id|outp
c_func
(paren
l_int|0x0a
comma
id|dma
op_amp
l_int|0x03
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * disable DMA&n; */
DECL|function|dis_dma
r_void
id|dis_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set mask bit (disable DMA cannal)&n;&t; */
r_if
c_cond
(paren
id|dma
OG
l_int|3
)paren
(brace
id|outp
c_func
(paren
l_int|0xd4
comma
(paren
id|dma
op_amp
l_int|0x03
)paren
op_or
l_int|0x04
)paren
suffix:semicolon
)brace
r_else
(brace
id|outp
c_func
(paren
l_int|0x0a
comma
(paren
id|dma
op_amp
l_int|0x03
)paren
op_or
l_int|0x04
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* ISA */
macro_line|#ifdef&t;EISA
multiline_comment|/*arrays with io adresses of dma controller length and adress registers*/
DECL|variable|cntr
r_static
r_const
r_int
id|cntr
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x001
comma
l_int|0x003
comma
l_int|0x005
comma
l_int|0x007
comma
l_int|0
comma
l_int|0x0c6
comma
l_int|0x0ca
comma
l_int|0x0ce
)brace
suffix:semicolon
DECL|variable|base
r_static
r_const
r_int
id|base
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x000
comma
l_int|0x002
comma
l_int|0x004
comma
l_int|0x006
comma
l_int|0
comma
l_int|0x0c4
comma
l_int|0x0c8
comma
l_int|0x0cc
)brace
suffix:semicolon
DECL|variable|page
r_static
r_const
r_int
id|page
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x087
comma
l_int|0x083
comma
l_int|0x081
comma
l_int|0x082
comma
l_int|0
comma
l_int|0x08b
comma
l_int|0x089
comma
l_int|0x08a
)brace
suffix:semicolon
DECL|function|init_dma
r_void
id|init_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
multiline_comment|/*&n;&t; * extended mode register&n;&t; * 32 bit IO&n;&t; * type c&n;&t; * TC output&n;&t; * disable stop&n;&t; */
multiline_comment|/* mode read (write) demand */
id|smc-&gt;hw.dma_rmode
op_assign
(paren
id|dma
op_amp
l_int|3
)paren
op_or
l_int|0x08
op_or
l_int|0x0
suffix:semicolon
id|smc-&gt;hw.dma_wmode
op_assign
(paren
id|dma
op_amp
l_int|3
)paren
op_or
l_int|0x04
op_or
l_int|0x0
suffix:semicolon
multiline_comment|/* 32 bit IO&squot;s, burst DMA mode (type &quot;C&quot;) */
id|smc-&gt;hw.dma_emode
op_assign
(paren
id|dma
op_amp
l_int|3
)paren
op_or
l_int|0x08
op_or
l_int|0x30
suffix:semicolon
id|outp
c_func
(paren
(paren
id|dma
OL
l_int|4
)paren
ques
c_cond
l_int|0x40b
suffix:colon
l_int|0x4d6
comma
id|smc-&gt;hw.dma_emode
)paren
suffix:semicolon
multiline_comment|/* disable chaining */
id|outp
c_func
(paren
(paren
id|dma
OL
l_int|4
)paren
ques
c_cond
l_int|0x40a
suffix:colon
l_int|0x4d4
comma
(paren
id|dma
op_amp
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/*load dma controller addresses for fast access during set dma*/
id|smc-&gt;hw.dma_base_word_count
op_assign
id|cntr
(braket
id|smc-&gt;hw.dma
)braket
suffix:semicolon
id|smc-&gt;hw.dma_base_address
op_assign
id|base
(braket
id|smc-&gt;hw.dma
)braket
suffix:semicolon
id|smc-&gt;hw.dma_base_address_page
op_assign
id|page
(braket
id|smc-&gt;hw.dma
)braket
suffix:semicolon
)brace
DECL|function|dis_dma
r_void
id|dis_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|outp
c_func
(paren
(paren
id|dma
OL
l_int|4
)paren
ques
c_cond
l_int|0x0a
suffix:colon
l_int|0xd4
comma
(paren
id|dma
op_amp
l_int|3
)paren
op_or
l_int|4
)paren
suffix:semicolon
multiline_comment|/* mask bit */
)brace
macro_line|#endif&t;/* EISA */
macro_line|#ifdef&t;MCA
DECL|function|init_dma
r_void
id|init_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|dma
)paren
suffix:semicolon
)brace
DECL|function|dis_dma
r_void
id|dis_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|dma
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef&t;PCI
DECL|function|init_dma
r_void
id|init_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|dma
)paren
suffix:semicolon
)brace
DECL|function|dis_dma
r_void
id|dis_dma
c_func
(paren
id|smc
comma
id|dma
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|dma
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|dma
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MULT_OEM
DECL|function|is_equal_num
r_static
r_int
id|is_equal_num
c_func
(paren
id|comp1
comma
id|comp2
comma
id|num
)paren
r_char
id|comp1
(braket
)braket
suffix:semicolon
r_char
id|comp2
(braket
)braket
suffix:semicolon
r_int
id|num
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|comp1
(braket
id|i
)braket
op_ne
id|comp2
(braket
id|i
)braket
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* is_equal_num */
multiline_comment|/*&n; * set the OEM ID defaults, and test the contents of the OEM data base&n; * The default OEM is the first ACTIVE entry in the OEM data base &n; *&n; * returns:&t;0&t;success&n; *&t;&t;1&t;error in data base&n; *&t;&t;2&t;data base empty&n; *&t;&t;3&t;no active entry&t;&n; */
DECL|function|set_oi_id_def
r_int
id|set_oi_id_def
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_int
id|sel_id
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|act_entries
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|sel_id
op_assign
op_minus
l_int|1
suffix:semicolon
id|act_entries
op_assign
id|FALSE
suffix:semicolon
id|smc-&gt;hw.oem_id
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.oem_min_status
op_assign
id|OI_STAT_ACTIVE
suffix:semicolon
multiline_comment|/* check OEM data base */
r_while
c_loop
(paren
id|oem_ids
(braket
id|i
)braket
dot
id|oi_status
)paren
(brace
r_switch
c_cond
(paren
id|oem_ids
(braket
id|i
)braket
dot
id|oi_status
)paren
(brace
r_case
id|OI_STAT_ACTIVE
suffix:colon
id|act_entries
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* we have active IDs */
r_if
c_cond
(paren
id|sel_id
op_eq
op_minus
l_int|1
)paren
id|sel_id
op_assign
id|i
suffix:semicolon
multiline_comment|/* save the first active ID */
r_case
id|OI_STAT_VALID
suffix:colon
r_case
id|OI_STAT_PRESENT
suffix:colon
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* entry ok */
r_default
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* invalid oi_status */
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|act_entries
)paren
r_return
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* ok, we have a valid OEM data base with an active entry */
id|smc-&gt;hw.oem_id
op_assign
(paren
r_struct
id|s_oem_ids
op_star
)paren
op_amp
id|oem_ids
(braket
id|sel_id
)braket
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* MULT_OEM */
macro_line|#ifdef&t;MCA
multiline_comment|/************************&n; *&n; * BEGIN_MANUAL_ENTRY()&n; *&n; *&t;exist_board&n; *&n; *&t;Check if an MCA board is present in the specified slot.&n; *&n; *&t;int exist_board(&n; *&t;&t;struct s_smc *smc,&n; *&t;&t;int slot) ;&n; * In&n; *&t;smc - A pointer to the SMT Context struct.&n; *&n; *&t;slot - The number of the slot to inspect.&n; * Out&n; *&t;0 = No adapter present.&n; *&t;1 = Found FM1 adapter.&n; *&n; * Pseudo&n; *      Read MCA ID&n; *&t;for all valid OEM_IDs&n; *&t;&t;compare with ID read&n; *&t;&t;if equal, return 1&n; *&t;return(0&n; *&n; * Note&n; *&t;The smc pointer must be valid now.&n; *&n; * END_MANUAL_ENTRY()&n; *&n; ************************/
DECL|macro|LONG_CARD_ID
mdefine_line|#define LONG_CARD_ID(lo, hi)&t;((((hi) &amp; 0xff) &lt;&lt; 8) | ((lo) &amp; 0xff))
DECL|function|exist_board
r_int
id|exist_board
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
macro_line|#ifdef MULT_OEM
id|SK_LOC_DECL
c_func
(paren
id|u_char
comma
id|id
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_int
id|idi
suffix:semicolon
macro_line|#endif&t;/* MULT_OEM */
multiline_comment|/* No longer valid. */
r_if
c_cond
(paren
id|smc
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#ifndef MULT_OEM
r_if
c_cond
(paren
id|read_card_id
c_func
(paren
id|smc
comma
id|slot
)paren
op_eq
id|LONG_CARD_ID
c_func
(paren
id|OEMID
c_func
(paren
id|smc
comma
l_int|0
)paren
comma
id|OEMID
c_func
(paren
id|smc
comma
l_int|1
)paren
)paren
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Found FM adapter. */
macro_line|#else&t;/* MULT_OEM */
id|idi
op_assign
id|read_card_id
c_func
(paren
id|smc
comma
id|slot
)paren
suffix:semicolon
id|id
(braket
l_int|0
)braket
op_assign
id|idi
op_amp
l_int|0xff
suffix:semicolon
id|id
(braket
l_int|1
)braket
op_assign
id|idi
op_rshift
l_int|8
suffix:semicolon
id|smc-&gt;hw.oem_id
op_assign
(paren
r_struct
id|s_oem_ids
op_star
)paren
op_amp
id|oem_ids
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|smc-&gt;hw.oem_id-&gt;oi_status
op_ne
id|OI_STAT_LAST
suffix:semicolon
id|smc-&gt;hw.oem_id
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.oem_id-&gt;oi_status
OL
id|smc-&gt;hw.oem_min_status
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|is_equal_num
c_func
(paren
op_amp
id|id
(braket
l_int|0
)braket
comma
op_amp
id|OEMID
c_func
(paren
id|smc
comma
l_int|0
)paren
comma
l_int|2
)paren
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* MULT_OEM */
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No adapter found. */
)brace
multiline_comment|/************************&n; *&n; *&t;read_card_id&n; *&n; *&t;Read the MCA card id from the specified slot.&n; * In&n; *&t;smc - A pointer to the SMT Context struct.&n; *&t;CAVEAT: This pointer may be NULL and *must not* be used within this&n; *&t;function. It&squot;s only purpose is for drivers that need some information&n; *&t;for the inp() and outp() macros.&n; *&n; *&t;slot - The number of the slot for which the card id is returned.&n; * Out&n; *&t;Returns the card id read from the specified slot. If an illegal slot&n; *&t;number is specified, the function returns zero.&n; *&n; ************************/
DECL|function|read_card_id
r_static
r_int
id|read_card_id
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
multiline_comment|/* Do not use. */
r_int
id|slot
suffix:semicolon
(brace
r_int
id|card_id
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* Make LINT happy. */
r_if
c_cond
(paren
(paren
id|slot
OL
l_int|1
)paren
op_logical_or
(paren
id|slot
OG
l_int|15
)paren
)paren
multiline_comment|/* max 16 slots, 0 = motherboard */
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Illegal slot number specified. */
id|EnableSlotAccess
c_func
(paren
id|smc
comma
id|slot
)paren
suffix:semicolon
id|card_id
op_assign
(paren
(paren
id|read_POS
c_func
(paren
id|smc
comma
id|POS_ID_HIGH
comma
id|slot
op_minus
l_int|1
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|read_POS
c_func
(paren
id|smc
comma
id|POS_ID_LOW
comma
id|slot
op_minus
l_int|1
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|DisableSlotAccess
c_func
(paren
id|smc
)paren
suffix:semicolon
r_return
(paren
id|card_id
)paren
suffix:semicolon
)brace
multiline_comment|/************************&n; *&n; * BEGIN_MANUAL_ENTRY()&n; *&n; *&t;get_board_para&n; *&n; *&t;Get adapter configuration information. Fill all board specific&n; *&t;parameters within the &squot;smc&squot; structure.&n; *&n; *&t;int get_board_para(&n; *&t;&t;struct s_smc *smc,&n; *&t;&t;int slot) ;&n; * In&n; *&t;smc - A pointer to the SMT Context struct, to which this function will&n; *&t;write some adapter configuration data.&n; *&n; *&t;slot - The number of the slot, in which the adapter is installed.&n; * Out&n; *&t;0 = No adapter present.&n; *&t;1 = Ok.&n; *&t;2 = Adapter present, but card enable bit not set.&n; *&n; * END_MANUAL_ENTRY()&n; *&n; ************************/
DECL|function|get_board_para
r_int
id|get_board_para
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check if adapter present &amp; get type of adapter. */
r_switch
c_cond
(paren
id|exist_board
c_func
(paren
id|smc
comma
id|slot
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Adapter not present. */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* FM Rev. 1 */
id|smc-&gt;hw.rev
op_assign
id|FM1_REV
suffix:semicolon
id|smc-&gt;hw.VFullRead
op_assign
l_int|0x0a
suffix:semicolon
id|smc-&gt;hw.VFullWrite
op_assign
l_int|0x05
suffix:semicolon
id|smc-&gt;hw.DmaWriteExtraBytes
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 2 extra words. */
r_break
suffix:semicolon
)brace
id|smc-&gt;hw.slot
op_assign
id|slot
suffix:semicolon
id|EnableSlotAccess
c_func
(paren
id|smc
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|read_POS
c_func
(paren
id|smc
comma
id|POS_102
comma
id|slot
op_minus
l_int|1
)paren
op_amp
id|POS_CARD_EN
)paren
)paren
(brace
id|DisableSlotAccess
c_func
(paren
id|smc
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Card enable bit not set. */
)brace
id|val
op_assign
id|read_POS
c_func
(paren
id|smc
comma
id|POS_104
comma
id|slot
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* I/O, IRQ */
macro_line|#ifndef MEM_MAPPED_IO&t;/* is defined by the operating system */
id|i
op_assign
id|val
op_amp
id|POS_IOSEL
suffix:semicolon
multiline_comment|/* I/O base addr. (0x0200 .. 0xfe00) */
id|smc-&gt;hw.iop
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_star
l_int|0x0400
op_minus
l_int|0x200
suffix:semicolon
macro_line|#endif
id|i
op_assign
(paren
(paren
id|val
op_amp
id|POS_IRQSEL
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
multiline_comment|/* IRQ &lt;0, 1&gt; */
id|smc-&gt;hw.irq
op_assign
id|opt_ints
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* FPROM base addr. */
id|i
op_assign
(paren
(paren
id|read_POS
c_func
(paren
id|smc
comma
id|POS_103
comma
id|slot
op_minus
l_int|1
)paren
op_amp
id|POS_MSEL
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x07
suffix:semicolon
id|smc-&gt;hw.eprom
op_assign
id|opt_eproms
(braket
id|i
)braket
suffix:semicolon
id|DisableSlotAccess
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* before this, the smc-&gt;hw.iop must be set !!! */
id|smc-&gt;hw.slot_32
op_assign
id|inpw
c_func
(paren
id|CSF_A
)paren
op_amp
id|SLOT_32
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable access to specified MCA slot. */
DECL|function|EnableSlotAccess
r_static
r_void
id|EnableSlotAccess
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|slot
)paren
suffix:semicolon
macro_line|#ifndef AIX
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* System mode. */
id|outp
c_func
(paren
id|POS_SYS_SETUP
comma
id|POS_SYSTEM
)paren
suffix:semicolon
multiline_comment|/* Select slot. */
id|outp
c_func
(paren
id|POS_CHANNEL_POS
comma
id|POS_CHANNEL_BIT
op_or
(paren
id|slot
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#else
id|attach_POS_addr
(paren
id|smc
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Disable access to MCA slot formerly enabled via EnableSlotAccess(). */
DECL|function|DisableSlotAccess
r_static
r_void
id|DisableSlotAccess
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
macro_line|#ifndef AIX
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|outp
c_func
(paren
id|POS_CHANNEL_POS
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|detach_POS_addr
(paren
id|smc
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/* MCA */
macro_line|#ifdef&t;EISA
macro_line|#ifndef&t;MEM_MAPPED_IO
DECL|macro|SADDR
mdefine_line|#define&t;SADDR(slot)&t;(((slot)&lt;&lt;12)&amp;0xf000)
macro_line|#else&t;/* MEM_MAPPED_IO */
DECL|macro|SADDR
mdefine_line|#define&t;SADDR(slot)&t;(smc-&gt;hw.iop)
macro_line|#endif&t;/* MEM_MAPPED_IO */
multiline_comment|/************************&n; *&n; * BEGIN_MANUAL_ENTRY()&n; *&n; *&t;exist_board&n; *&n; *&t;Check if an EISA board is present in the specified slot.&n; *&n; *&t;int exist_board(&n; *&t;&t;struct s_smc *smc,&n; *&t;&t;int slot) ;&n; * In&n; *&t;smc - A pointer to the SMT Context struct.&n; *&n; *&t;slot - The number of the slot to inspect.&n; * Out&n; *&t;0 = No adapter present.&n; *&t;1 = Found adapter.&n; *&n; * Pseudo&n; *      Read EISA ID&n; *&t;for all valid OEM_IDs&n; *&t;&t;compare with ID read&n; *&t;&t;if equal, return 1&n; *&t;return(0&n; *&n; * Note&n; *&t;The smc pointer must be valid now.&n; *&n; ************************/
DECL|function|exist_board
r_int
id|exist_board
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef MULT_OEM
id|SK_LOC_DECL
c_func
(paren
id|u_char
comma
id|id
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* MULT_OEM */
multiline_comment|/* No longer valid. */
r_if
c_cond
(paren
id|smc
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|slot
)paren
suffix:semicolon
macro_line|#ifndef MULT_OEM
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inp
c_func
(paren
id|SADDR
c_func
(paren
id|slot
)paren
op_plus
id|PRA
c_func
(paren
id|i
)paren
)paren
op_ne
id|OEMID
c_func
(paren
id|smc
comma
id|i
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#else&t;/* MULT_OEM */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|id
(braket
id|i
)braket
op_assign
id|inp
c_func
(paren
id|SADDR
c_func
(paren
id|slot
)paren
op_plus
id|PRA
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|smc-&gt;hw.oem_id
op_assign
(paren
r_struct
id|s_oem_ids
op_star
)paren
op_amp
id|oem_ids
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|smc-&gt;hw.oem_id-&gt;oi_status
op_ne
id|OI_STAT_LAST
suffix:semicolon
id|smc-&gt;hw.oem_id
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.oem_id-&gt;oi_status
OL
id|smc-&gt;hw.oem_min_status
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|is_equal_num
c_func
(paren
op_amp
id|id
(braket
l_int|0
)braket
comma
op_amp
id|OEMID
c_func
(paren
id|smc
comma
l_int|0
)paren
comma
l_int|4
)paren
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No adapter found. */
macro_line|#endif&t;/* MULT_OEM */
)brace
DECL|function|get_board_para
r_int
id|get_board_para
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exist_board
c_func
(paren
id|smc
comma
id|slot
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|smc-&gt;hw.slot
op_assign
id|slot
suffix:semicolon
macro_line|#ifndef&t;MEM_MAPPED_IO&t;&t;/* if defined by the operating system */
id|smc-&gt;hw.iop
op_assign
id|SADDR
c_func
(paren
id|slot
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|inp
c_func
(paren
id|C0_A
c_func
(paren
l_int|0
)paren
)paren
op_amp
id|CFG_CARD_EN
)paren
)paren
(brace
r_return
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* CFG_CARD_EN bit not set! */
)brace
id|smc-&gt;hw.irq
op_assign
id|opt_ints
(braket
(paren
id|inp
c_func
(paren
id|C1_A
c_func
(paren
l_int|0
)paren
)paren
op_amp
id|CFG_IRQ_SEL
)paren
)braket
suffix:semicolon
id|smc-&gt;hw.dma
op_assign
id|opt_dmas
(braket
(paren
(paren
id|inp
c_func
(paren
id|C1_A
c_func
(paren
l_int|0
)paren
)paren
op_amp
id|CFG_DRQ_SEL
)paren
op_rshift
l_int|3
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|inp
c_func
(paren
id|C2_A
c_func
(paren
l_int|0
)paren
)paren
op_amp
id|CFG_EPROM_SEL
)paren
op_ne
l_int|0x0f
)paren
id|smc-&gt;hw.eprom
op_assign
id|opt_eproms
(braket
id|i
)braket
suffix:semicolon
r_else
id|smc-&gt;hw.eprom
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;hw.DmaWriteExtraBytes
op_assign
l_int|8
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* EISA */
macro_line|#ifdef&t;ISA
macro_line|#ifndef MULT_OEM
DECL|variable|sklogo
r_const
id|u_char
id|sklogo
(braket
l_int|6
)braket
op_assign
id|SKLOGO_STR
suffix:semicolon
DECL|macro|SIZE_SKLOGO
mdefine_line|#define&t;SIZE_SKLOGO(smc)&t;sizeof(sklogo)
DECL|macro|SKLOGO
mdefine_line|#define&t;SKLOGO(smc,i)&t;&t;sklogo[i]
macro_line|#else&t;/* MULT_OEM */
DECL|macro|SIZE_SKLOGO
mdefine_line|#define&t;SIZE_SKLOGO(smc)&t;smc-&gt;hw.oem_id-&gt;oi_logo_len
DECL|macro|SKLOGO
mdefine_line|#define&t;SKLOGO(smc,i)&t;&t;smc-&gt;hw.oem_id-&gt;oi_logo[i]
macro_line|#endif&t;/* MULT_OEM */
DECL|function|exist_board
r_int
id|exist_board
c_func
(paren
id|smc
comma
id|port
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|HW_PTR
id|port
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef MULT_OEM
r_int
id|bytes_read
suffix:semicolon
id|u_char
id|board_logo
(braket
l_int|15
)braket
suffix:semicolon
id|SK_LOC_DECL
c_func
(paren
id|u_char
comma
id|id
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* MULT_OEM */
multiline_comment|/* No longer valid. */
r_if
c_cond
(paren
id|smc
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#ifndef MULT_OEM
r_for
c_loop
(paren
id|i
op_assign
id|SADDRL
suffix:semicolon
id|i
OL
(paren
r_int
)paren
(paren
id|SADDRL
op_plus
id|SIZE_SKLOGO
c_func
(paren
id|smc
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|u_char
)paren
id|inpw
c_func
(paren
(paren
id|PRA
c_func
(paren
id|i
)paren
op_plus
id|port
)paren
)paren
op_ne
id|SKLOGO
c_func
(paren
id|smc
comma
id|i
op_minus
id|SADDRL
)paren
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* check MAC address (S&amp;K or other) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|u_char
)paren
id|inpw
c_func
(paren
(paren
id|PRA
c_func
(paren
id|i
)paren
op_plus
id|port
)paren
)paren
op_ne
id|OEMID
c_func
(paren
id|smc
comma
id|i
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#else&t;/* MULT_OEM */
id|smc-&gt;hw.oem_id
op_assign
(paren
r_struct
id|s_oem_ids
op_star
)paren
op_amp
id|oem_ids
(braket
l_int|0
)braket
suffix:semicolon
id|board_logo
(braket
l_int|0
)braket
op_assign
(paren
id|u_char
)paren
id|inpw
c_func
(paren
(paren
id|PRA
c_func
(paren
id|SADDRL
)paren
op_plus
id|port
)paren
)paren
suffix:semicolon
id|bytes_read
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|smc-&gt;hw.oem_id-&gt;oi_status
op_ne
id|OI_STAT_LAST
suffix:semicolon
id|smc-&gt;hw.oem_id
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.oem_id-&gt;oi_status
OL
id|smc-&gt;hw.oem_min_status
)paren
r_continue
suffix:semicolon
multiline_comment|/* Test all read bytes with current OEM_entry */
multiline_comment|/* for (i=0; (i&lt;bytes_read) &amp;&amp; (i &lt; SIZE_SKLOGO(smc)); i++) { */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bytes_read
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|board_logo
(braket
id|i
)braket
op_ne
id|SKLOGO
c_func
(paren
id|smc
comma
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* If mismatch, switch to next OEM entry */
r_if
c_cond
(paren
(paren
id|board_logo
(braket
id|i
)braket
op_ne
id|SKLOGO
c_func
(paren
id|smc
comma
id|i
)paren
)paren
op_logical_and
(paren
id|i
OL
id|bytes_read
)paren
)paren
r_continue
suffix:semicolon
op_decrement
id|i
suffix:semicolon
r_while
c_loop
(paren
id|bytes_read
OL
id|SIZE_SKLOGO
c_func
(paren
id|smc
)paren
)paren
(brace
singleline_comment|//   inpw next byte SK_Logo
id|i
op_increment
suffix:semicolon
id|board_logo
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|inpw
c_func
(paren
(paren
id|PRA
c_func
(paren
id|SADDRL
op_plus
id|i
)paren
op_plus
id|port
)paren
)paren
suffix:semicolon
id|bytes_read
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|board_logo
(braket
id|i
)braket
op_ne
id|SKLOGO
c_func
(paren
id|smc
comma
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|id
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|inpw
c_func
(paren
(paren
id|PRA
c_func
(paren
id|i
)paren
op_plus
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|board_logo
(braket
id|i
)braket
op_eq
id|SKLOGO
c_func
(paren
id|smc
comma
id|i
)paren
)paren
op_logical_and
(paren
id|bytes_read
op_eq
id|SIZE_SKLOGO
c_func
(paren
id|smc
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_equal_num
c_func
(paren
op_amp
id|id
(braket
l_int|0
)braket
comma
op_amp
id|OEMID
c_func
(paren
id|smc
comma
l_int|0
)paren
comma
l_int|3
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* for */
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;/* MULT_OEM */
)brace
DECL|function|get_board_para
r_int
id|get_board_para
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|slot
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* for ISA not supported */
)brace
macro_line|#endif&t;/* ISA */
macro_line|#ifdef PCI
macro_line|#ifdef USE_BIOS_FUN
DECL|function|exist_board
r_int
id|exist_board
c_func
(paren
id|smc
comma
id|slot
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|slot
suffix:semicolon
(brace
id|u_short
id|dev_id
suffix:semicolon
id|u_short
id|ven_id
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|i
suffix:semicolon
id|found
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* make sure we returned with adatper not found*/
multiline_comment|/* if an empty oemids.h was included */
macro_line|#ifdef MULT_OEM
id|smc-&gt;hw.oem_id
op_assign
(paren
r_struct
id|s_oem_ids
op_star
)paren
op_amp
id|oem_ids
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|smc-&gt;hw.oem_id-&gt;oi_status
op_ne
id|OI_STAT_LAST
suffix:semicolon
id|smc-&gt;hw.oem_id
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smc-&gt;hw.oem_id-&gt;oi_status
OL
id|smc-&gt;hw.oem_min_status
)paren
r_continue
suffix:semicolon
macro_line|#endif
id|ven_id
op_assign
id|OEMID
c_func
(paren
id|smc
comma
l_int|0
)paren
op_plus
(paren
id|OEMID
c_func
(paren
id|smc
comma
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev_id
op_assign
id|OEMID
c_func
(paren
id|smc
comma
l_int|2
)paren
op_plus
(paren
id|OEMID
c_func
(paren
id|smc
comma
l_int|3
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|slot
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_find_device
c_func
(paren
id|i
comma
op_amp
id|smc-&gt;hw.pci_handle
comma
id|dev_id
comma
id|ven_id
)paren
op_ne
l_int|0
)paren
(brace
id|found
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|found
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* adapter was found */
)brace
macro_line|#ifdef MULT_OEM
)brace
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* adapter was not found */
)brace
macro_line|#endif&t;/* PCI */
macro_line|#endif&t;/* USE_BIOS_FUNC */
DECL|function|driver_get_bia
r_void
id|driver_get_bia
c_func
(paren
id|smc
comma
id|bia_addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_struct
id|fddi_addr
op_star
id|bia_addr
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_extern
r_const
id|u_char
id|canonical
(braket
l_int|256
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bia_addr-&gt;a
(braket
id|i
)braket
op_assign
id|canonical
(braket
id|smc-&gt;hw.fddi_phys_addr.a
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
)brace
DECL|function|smt_start_watchdog
r_void
id|smt_start_watchdog
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* Make LINT happy. */
macro_line|#ifndef&t;DEBUG
macro_line|#ifdef&t;PCI
r_if
c_cond
(paren
id|smc-&gt;hw.wdog_used
)paren
(brace
id|outpw
c_func
(paren
id|ADDR
c_func
(paren
id|B2_WDOG_CRTL
)paren
comma
id|TIM_START
)paren
suffix:semicolon
multiline_comment|/* Start timer. */
)brace
macro_line|#endif
macro_line|#endif&t;/* DEBUG */
)brace
DECL|function|smt_stop_watchdog
r_void
id|smt_stop_watchdog
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/* Make LINT happy. */
macro_line|#ifndef&t;DEBUG
macro_line|#ifdef&t;PCI
r_if
c_cond
(paren
id|smc-&gt;hw.wdog_used
)paren
(brace
id|outpw
c_func
(paren
id|ADDR
c_func
(paren
id|B2_WDOG_CRTL
)paren
comma
id|TIM_STOP
)paren
suffix:semicolon
multiline_comment|/* Stop timer. */
)brace
macro_line|#endif
macro_line|#endif&t;/* DEBUG */
)brace
macro_line|#ifdef&t;PCI
DECL|function|get_rom_byte
r_static
r_char
id|get_rom_byte
c_func
(paren
id|smc
comma
id|addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_short
id|addr
suffix:semicolon
(brace
id|GET_PAGE
c_func
(paren
id|addr
)paren
suffix:semicolon
r_return
(paren
id|READ_PROM
c_func
(paren
id|ADDR
c_func
(paren
id|B2_FDP
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ROM image defines&n; */
DECL|macro|ROM_SIG_1
mdefine_line|#define&t;ROM_SIG_1&t;0
DECL|macro|ROM_SIG_2
mdefine_line|#define ROM_SIG_2&t;1
DECL|macro|PCI_DATA_1
mdefine_line|#define PCI_DATA_1&t;0x18
DECL|macro|PCI_DATA_2
mdefine_line|#define PCI_DATA_2&t;0x19
multiline_comment|/*&n; * PCI data structure defines&n; */
DECL|macro|VPD_DATA_1
mdefine_line|#define&t;VPD_DATA_1&t;0x08
DECL|macro|VPD_DATA_2
mdefine_line|#define&t;VPD_DATA_2&t;0x09
DECL|macro|IMAGE_LEN_1
mdefine_line|#define IMAGE_LEN_1&t;0x10
DECL|macro|IMAGE_LEN_2
mdefine_line|#define IMAGE_LEN_2&t;0x11
DECL|macro|CODE_TYPE
mdefine_line|#define&t;CODE_TYPE&t;0x14
DECL|macro|INDICATOR
mdefine_line|#define&t;INDICATOR&t;0x15
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_vpd_read)&n; *&t;mac_drv_vpd_read(smc,buf,size,image)&n; *&n; * function&t;DOWNCALL&t;(FDDIWARE)&n; *&t;&t;reads the VPD data of the FPROM and writes it into the&n; *&t;&t;buffer&n; *&n; * para&t;buf&t;points to the buffer for the VPD data&n; *&t;size&t;size of the VPD data buffer&n; *&t;image&t;boot image; code type of the boot image&n; *&t;&t;image = 0&t;Intel x86, PC-AT compatible&n; *&t;&t;&t;1&t;OPENBOOT standard for PCI&n; *&t;&t;&t;2-FF&t;reserved&n; *&n; * returns&t;len&t;number of VPD data bytes read form the FPROM&n; *&t;&t;&lt;0&t;number of read bytes&n; *&t;&t;&gt;0&t;error: data invalid&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_vpd_read
r_int
id|mac_drv_vpd_read
c_func
(paren
id|smc
comma
id|buf
comma
id|size
comma
id|image
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
id|image
suffix:semicolon
(brace
id|u_short
id|ibase
suffix:semicolon
id|u_short
id|pci_base
suffix:semicolon
id|u_short
id|vpd
suffix:semicolon
r_int
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|ibase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * as long images defined&n;&t; */
r_while
c_loop
(paren
id|get_rom_byte
c_func
(paren
id|smc
comma
id|ibase
op_plus
id|ROM_SIG_1
)paren
op_eq
l_int|0x55
op_logical_and
(paren
id|u_char
)paren
id|get_rom_byte
c_func
(paren
id|smc
comma
id|ibase
op_plus
id|ROM_SIG_2
)paren
op_eq
l_int|0xaa
)paren
(brace
multiline_comment|/*&n;&t;&t; * get the pointer to the PCI data structure&n;&t;&t; */
id|pci_base
op_assign
id|ibase
op_plus
id|get_rom_byte
c_func
(paren
id|smc
comma
id|ibase
op_plus
id|PCI_DATA_1
)paren
op_plus
(paren
id|get_rom_byte
c_func
(paren
id|smc
comma
id|ibase
op_plus
id|PCI_DATA_2
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|image
op_eq
id|get_rom_byte
c_func
(paren
id|smc
comma
id|pci_base
op_plus
id|CODE_TYPE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * we have the right image, read the VPD data&n;&t;&t;&t; */
id|vpd
op_assign
id|ibase
op_plus
id|get_rom_byte
c_func
(paren
id|smc
comma
id|pci_base
op_plus
id|VPD_DATA_1
)paren
op_plus
(paren
id|get_rom_byte
c_func
(paren
id|smc
comma
id|pci_base
op_plus
id|VPD_DATA_2
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vpd
op_eq
id|ibase
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* no VPD data */
)brace
r_for
c_loop
(paren
id|len
op_assign
l_int|0
suffix:semicolon
id|len
OL
id|size
suffix:semicolon
id|len
op_increment
comma
id|buf
op_increment
comma
id|vpd
op_increment
)paren
(brace
op_star
id|buf
op_assign
id|get_rom_byte
c_func
(paren
id|smc
comma
id|vpd
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * try the next image&n;&t;&t;&t; */
r_if
c_cond
(paren
id|get_rom_byte
c_func
(paren
id|smc
comma
id|pci_base
op_plus
id|INDICATOR
)paren
op_amp
l_int|0x80
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* this was the last image */
)brace
id|ibase
op_assign
id|ibase
op_plus
id|get_rom_byte
c_func
(paren
id|smc
comma
id|ibase
op_plus
id|IMAGE_LEN_1
)paren
op_plus
(paren
id|get_rom_byte
c_func
(paren
id|smc
comma
id|ibase
op_plus
id|IMAGE_LEN_2
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
DECL|function|mac_drv_pci_fix
r_void
id|mac_drv_pci_fix
c_func
(paren
id|smc
comma
id|fix_value
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_long
id|fix_value
suffix:semicolon
(brace
id|smc-&gt;hw.pci_fix_value
op_assign
id|fix_value
suffix:semicolon
)brace
DECL|function|mac_do_pci_fix
r_void
id|mac_do_pci_fix
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* PCI */
eof
