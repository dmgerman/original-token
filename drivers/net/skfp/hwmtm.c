multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998,1999 SysKonnect,&n; *&t;a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.&n; *&n; *&t;See the file &quot;skfddi.c&quot; for further information.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
macro_line|#ifndef&t;lint
DECL|variable|ID_sccs
r_static
r_char
r_const
id|ID_sccs
(braket
)braket
op_assign
l_string|&quot;@(#)hwmtm.c&t;1.40 99/05/31 (C) SK&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|HWMTM
mdefine_line|#define&t;HWMTM
macro_line|#ifndef FDDI
DECL|macro|FDDI
mdefine_line|#define&t;FDDI
macro_line|#endif
macro_line|#include &quot;h/types.h&quot;
macro_line|#include &quot;h/fddi.h&quot;
macro_line|#include &quot;h/smc.h&quot;
macro_line|#include &quot;h/supern_2.h&quot;
macro_line|#include &quot;h/skfbiinc.h&quot;
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;DOCUMENTATION&n;&t;-------------------------------------------------------------&n;&t;BEGIN_MANUAL_ENTRY(DOCUMENTATION)&n;&n;&t;&t;&t;T B D&n;&n;&t;END_MANUAL_ENTRY&n;*/
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;LOCAL VARIABLES:&n;&t;-------------------------------------------------------------&n;*/
macro_line|#ifdef COMMON_MB_POOL
DECL|variable|mb_start
r_static
id|SMbuf
op_star
id|mb_start
op_assign
l_int|0
suffix:semicolon
DECL|variable|mb_free
r_static
id|SMbuf
op_star
id|mb_free
op_assign
l_int|0
suffix:semicolon
DECL|variable|mb_init
r_static
r_int
id|mb_init
op_assign
id|FALSE
suffix:semicolon
DECL|variable|call_count
r_static
r_int
id|call_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;EXTERNE VARIABLES:&n;&t;-------------------------------------------------------------&n;*/
macro_line|#ifdef&t;DEBUG
macro_line|#ifndef&t;DEBUG_BRD
r_extern
r_struct
id|smt_debug
id|debug
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef&t;NDIS_OS2
r_extern
id|u_char
id|offDepth
suffix:semicolon
r_extern
id|u_char
id|force_irq_pending
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;LOCAL FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
r_static
r_void
id|queue_llc_rx
c_func
(paren
)paren
comma
id|smt_to_llc
c_func
(paren
)paren
comma
id|init_txd_ring
c_func
(paren
)paren
comma
id|init_rxd_ring
c_func
(paren
)paren
comma
id|queue_txd_mb
c_func
(paren
)paren
suffix:semicolon
r_static
id|u_long
id|init_descr_ring
c_func
(paren
)paren
comma
id|repair_txd_ring
c_func
(paren
)paren
comma
id|repair_rxd_ring
c_func
(paren
)paren
suffix:semicolon
r_static
id|SMbuf
op_star
id|get_llc_rx
c_func
(paren
)paren
comma
op_star
id|get_txd_mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;EXTERNAL FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
multiline_comment|/*&t;The external SMT functions are listed in cmtdef.h */
r_extern
r_void
op_star
id|mac_drv_get_space
c_func
(paren
)paren
comma
op_star
id|mac_drv_get_desc_mem
c_func
(paren
)paren
comma
id|init_board
c_func
(paren
)paren
comma
id|mac_drv_fill_rxd
c_func
(paren
)paren
comma
id|plc1_irq
c_func
(paren
)paren
comma
id|mac_drv_tx_complete
c_func
(paren
)paren
comma
id|plc2_irq
c_func
(paren
)paren
comma
id|mac1_irq
c_func
(paren
)paren
comma
id|mac2_irq
c_func
(paren
)paren
comma
id|mac3_irq
c_func
(paren
)paren
comma
id|timer_irq
c_func
(paren
)paren
comma
id|mac_drv_rx_complete
c_func
(paren
)paren
comma
id|mac_drv_requeue_rxd
c_func
(paren
)paren
comma
id|init_plc
c_func
(paren
)paren
comma
id|mac_drv_clear_rxd
c_func
(paren
)paren
comma
id|llc_restart_tx
c_func
(paren
)paren
comma
id|ev_dispatcher
c_func
(paren
)paren
comma
id|smt_force_irq
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef&t;USE_OS_CPY
r_extern
r_void
id|hwm_cpy_rxd2mb
c_func
(paren
)paren
comma
id|hwm_cpy_txd2mb
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;ALL_RX_COMPLETE
r_extern
r_void
id|mac_drv_all_receives_complete
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_extern
id|u_long
id|mac_drv_virt2phys
c_func
(paren
)paren
comma
id|dma_master
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef&t;NDIS_OS2
r_extern
r_void
id|post_proc
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_extern
r_void
id|dma_complete
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|init_fplus
c_func
(paren
)paren
comma
id|mac_drv_rx_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;PUBLIC FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
r_void
id|process_receive
c_func
(paren
)paren
comma
id|smt_send_mbuf
c_func
(paren
)paren
comma
id|fddi_isr
c_func
(paren
)paren
comma
id|mac_drv_clear_txd
c_func
(paren
)paren
comma
id|smt_free_mbuf
c_func
(paren
)paren
comma
id|init_driver_fplus
c_func
(paren
)paren
comma
id|mac_drv_rx_mode
c_func
(paren
)paren
comma
id|init_fddi_driver
c_func
(paren
)paren
comma
id|mac_drv_clear_tx_queue
c_func
(paren
)paren
comma
id|mac_drv_clear_rx_queue
c_func
(paren
)paren
comma
id|hwm_tx_frag
c_func
(paren
)paren
comma
id|hwm_rx_frag
c_func
(paren
)paren
suffix:semicolon
r_int
id|mac_drv_rx_frag
c_func
(paren
)paren
comma
id|mac_drv_init
c_func
(paren
)paren
comma
id|hwm_tx_init
c_func
(paren
)paren
suffix:semicolon
id|u_int
id|mac_drv_check_space
c_func
(paren
)paren
suffix:semicolon
id|SMbuf
op_star
id|smt_get_mbuf
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_void
id|mac_drv_debug_lev
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;MACROS:&n;&t;-------------------------------------------------------------&n;*/
macro_line|#ifndef&t;UNUSED
macro_line|#ifdef&t;lint
DECL|macro|UNUSED
mdefine_line|#define UNUSED(x)&t;(x) = (x)
macro_line|#else
DECL|macro|UNUSED
mdefine_line|#define UNUSED(x)
macro_line|#endif
macro_line|#endif
macro_line|#ifdef&t;USE_CAN_ADDR
DECL|macro|MA
mdefine_line|#define MA&t;&t;smc-&gt;hw.fddi_canon_addr.a
DECL|macro|GROUP_ADDR_BIT
mdefine_line|#define&t;GROUP_ADDR_BIT&t;0x01
macro_line|#else
DECL|macro|MA
mdefine_line|#define&t;MA&t;&t;smc-&gt;hw.fddi_home_addr.a
DECL|macro|GROUP_ADDR_BIT
mdefine_line|#define&t;GROUP_ADDR_BIT&t;0x80
macro_line|#endif
DECL|macro|RXD_TXD_COUNT
mdefine_line|#define RXD_TXD_COUNT&t;(HWM_ASYNC_TXD_COUNT+HWM_SYNC_TXD_COUNT+&bslash;&n;&t;&t;&t;SMT_R1_RXD_COUNT+SMT_R2_RXD_COUNT)
macro_line|#ifdef&t;MB_OUTSIDE_SMC
DECL|macro|EXT_VIRT_MEM
mdefine_line|#define&t;EXT_VIRT_MEM&t;((RXD_TXD_COUNT+1)*sizeof(struct s_smt_fp_txd) +&bslash;&n;&t;&t;&t;MAX_MBUF*sizeof(SMbuf))
DECL|macro|EXT_VIRT_MEM_2
mdefine_line|#define&t;EXT_VIRT_MEM_2&t;((RXD_TXD_COUNT+1)*sizeof(struct s_smt_fp_txd))
macro_line|#else
DECL|macro|EXT_VIRT_MEM
mdefine_line|#define&t;EXT_VIRT_MEM&t;((RXD_TXD_COUNT+1)*sizeof(struct s_smt_fp_txd))
macro_line|#endif
multiline_comment|/*&n;&t; * define critical read for 16 Bit drivers&n;&t; */
macro_line|#if&t;defined(NDIS_OS2) || defined(ODI2)
DECL|macro|CR_READ
mdefine_line|#define CR_READ(var)&t;((var) &amp; 0xffff0000 | ((var) &amp; 0xffff))
macro_line|#else
DECL|macro|CR_READ
mdefine_line|#define CR_READ(var)&t;(u_long)(var)
macro_line|#endif
DECL|macro|IMASK_SLOW
mdefine_line|#define IMASK_SLOW&t;(IS_PLINT1 | IS_PLINT2 | IS_TIMINT | IS_TOKEN | &bslash;&n;&t;&t;&t; IS_MINTR1 | IS_MINTR2 | IS_MINTR3 | IS_R1_P | &bslash;&n;&t;&t;&t; IS_R1_C | IS_XA_C | IS_XS_C)
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;INIT- AND SMT FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_check_space)&n; *&t;u_int mac_drv_check_space()&n; *&n; *&t;function&t;DOWNCALL&t;(drvsr.c)&n; *&t;&t;&t;This function calculates the needed non virtual&n; *&t;&t;&t;memory for MBufs, RxD and TxD descriptors etc.&n; *&t;&t;&t;needed by the driver.&n; *&n; *&t;return&t;&t;u_int&t;memory in bytes&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_check_space
id|u_int
id|mac_drv_check_space
c_func
(paren
)paren
(brace
macro_line|#ifdef&t;MB_OUTSIDE_SMC
macro_line|#ifdef&t;COMMON_MB_POOL
id|call_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|call_count
op_eq
l_int|1
)paren
(brace
r_return
(paren
id|EXT_VIRT_MEM
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|EXT_VIRT_MEM_2
)paren
suffix:semicolon
)brace
macro_line|#else
r_return
(paren
id|EXT_VIRT_MEM
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_init)&n; *&t;void mac_drv_init(smc)&n; *&n; *&t;function&t;DOWNCALL&t;(drvsr.c)&n; *&t;&t;&t;In this function the hardware module allocates it&squot;s&n; *&t;&t;&t;memory.&n; *&t;&t;&t;The operating system dependent module should call&n; *&t;&t;&t;mac_drv_init once, after the adatper is detected.&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_init
r_int
id|mac_drv_init
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|s_smt_fp_rxd
)paren
op_mod
l_int|16
)paren
(brace
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0001
comma
id|HWM_E0001_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|s_smt_fp_txd
)paren
op_mod
l_int|16
)paren
(brace
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0002
comma
id|HWM_E0002_MSG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * get the required memory for the RxDs and TxDs&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|smc-&gt;os.hwm.descr_p
op_assign
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|mac_drv_get_desc_mem
c_func
(paren
id|smc
comma
(paren
id|u_int
)paren
(paren
id|RXD_TXD_COUNT
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|s_smt_fp_txd
)paren
)paren
)paren
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no space the hwm modul can&squot;t work */
)brace
multiline_comment|/*&n;&t; * get the memory for the SMT MBufs&n;&t; */
macro_line|#ifndef&t;MB_OUTSIDE_SMC
id|smc-&gt;os.hwm.mbuf_pool.mb_start
op_assign
(paren
id|SMbuf
op_star
)paren
(paren
op_amp
id|smc-&gt;os.hwm.mbuf_pool.mb
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#else
macro_line|#ifndef&t;COMMON_MB_POOL
r_if
c_cond
(paren
op_logical_neg
(paren
id|smc-&gt;os.hwm.mbuf_pool.mb_start
op_assign
(paren
id|SMbuf
op_star
)paren
id|mac_drv_get_space
c_func
(paren
id|smc
comma
id|MAX_MBUF
op_star
r_sizeof
(paren
id|SMbuf
)paren
)paren
)paren
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no space the hwm modul can&squot;t work */
)brace
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|mb_start
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mb_start
op_assign
(paren
id|SMbuf
op_star
)paren
id|mac_drv_get_space
c_func
(paren
id|smc
comma
id|MAX_MBUF
op_star
r_sizeof
(paren
id|SMbuf
)paren
)paren
)paren
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no space the hwm modul can&squot;t work */
)brace
)brace
macro_line|#endif
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(init_driver_fplus)&n; *&t;init_driver_fplus(smc)&n; *&n; * Sets hardware modul specific values for the mode register 2&n; * (e.g. the byte alignment for the received frames, the position of the&n; *&t; least significant byte etc.)&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|init_driver_fplus
r_void
id|init_driver_fplus
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|smc-&gt;hw.fp.mdr2init
op_assign
id|FM_LSB
op_or
id|FM_BMMODE
op_or
id|FM_ENNPRQ
op_or
id|FM_ENHSRQ
op_or
l_int|3
suffix:semicolon
macro_line|#ifdef&t;PCI
id|smc-&gt;hw.fp.mdr2init
op_or_assign
id|FM_CHKPAR
op_or
id|FM_PARITY
suffix:semicolon
macro_line|#endif
id|smc-&gt;hw.fp.mdr3init
op_assign
id|FM_MENRQAUNLCK
op_or
id|FM_MENRS
suffix:semicolon
macro_line|#ifdef&t;USE_CAN_ADDR
multiline_comment|/* enable address bit swapping */
id|smc-&gt;hw.fp.frselreg_init
op_assign
id|FM_ENXMTADSWAP
op_or
id|FM_ENRCVADSWAP
suffix:semicolon
macro_line|#endif
)brace
DECL|function|init_descr_ring
r_static
id|u_long
id|init_descr_ring
c_func
(paren
id|smc
comma
id|start
comma
id|count
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_union
id|s_fp_descr
r_volatile
op_star
id|start
suffix:semicolon
r_int
id|count
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_union
id|s_fp_descr
r_volatile
op_star
id|d1
suffix:semicolon
r_union
id|s_fp_descr
r_volatile
op_star
id|d2
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;descr ring starts at = %x &quot;
comma
(paren
r_void
op_star
)paren
id|start
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|count
op_minus
l_int|1
comma
id|d1
op_assign
id|start
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|d2
op_assign
id|d1
suffix:semicolon
id|d1
op_increment
suffix:semicolon
multiline_comment|/* descr is owned by the host */
id|d2-&gt;r.rxd_rbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|BMU_CHECK
)paren
suffix:semicolon
id|d2-&gt;r.rxd_next
op_assign
op_amp
id|d1-&gt;r
suffix:semicolon
id|phys
op_assign
id|mac_drv_virt2phys
c_func
(paren
id|smc
comma
(paren
r_void
op_star
)paren
id|d1
)paren
suffix:semicolon
id|d2-&gt;r.rxd_nrdadr
op_assign
id|AIX_REVERSE
c_func
(paren
id|phys
)paren
suffix:semicolon
)brace
id|DB_GEN
c_func
(paren
l_string|&quot;descr ring ends at = %x &quot;
comma
(paren
r_void
op_star
)paren
id|d1
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|d1-&gt;r.rxd_rbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|BMU_CHECK
)paren
suffix:semicolon
id|d1-&gt;r.rxd_next
op_assign
op_amp
id|start-&gt;r
suffix:semicolon
id|phys
op_assign
id|mac_drv_virt2phys
c_func
(paren
id|smc
comma
(paren
r_void
op_star
)paren
id|start
)paren
suffix:semicolon
id|d1-&gt;r.rxd_nrdadr
op_assign
id|AIX_REVERSE
c_func
(paren
id|phys
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|count
comma
id|d1
op_assign
id|start
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|DRV_BUF_FLUSH
c_func
(paren
op_amp
id|d1-&gt;r
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|d1
op_increment
suffix:semicolon
)brace
r_return
(paren
id|phys
)paren
suffix:semicolon
)brace
DECL|function|init_txd_ring
r_static
r_void
id|init_txd_ring
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|ds
suffix:semicolon
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the transmit descriptors&n;&t; */
id|ds
op_assign
(paren
r_struct
id|s_smt_fp_txd
r_volatile
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|smc-&gt;os.hwm.descr_p
op_plus
id|SMT_R1_RXD_COUNT
op_star
r_sizeof
(paren
r_struct
id|s_smt_fp_rxd
)paren
)paren
suffix:semicolon
id|queue
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_A0
)braket
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;Init async TxD ring, %d TxDs &quot;
comma
id|HWM_ASYNC_TXD_COUNT
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
(paren
r_void
)paren
id|init_descr_ring
c_func
(paren
id|smc
comma
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|ds
comma
id|HWM_ASYNC_TXD_COUNT
)paren
suffix:semicolon
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|ds-&gt;txd_ntdadr
)paren
suffix:semicolon
id|ds
op_increment
suffix:semicolon
id|queue-&gt;tx_curr_put
op_assign
id|queue-&gt;tx_curr_get
op_assign
id|ds
suffix:semicolon
id|ds
op_decrement
suffix:semicolon
id|queue-&gt;tx_free
op_assign
id|HWM_ASYNC_TXD_COUNT
suffix:semicolon
id|queue-&gt;tx_used
op_assign
l_int|0
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_DA
)paren
comma
id|phys
)paren
suffix:semicolon
id|ds
op_assign
(paren
r_struct
id|s_smt_fp_txd
r_volatile
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ds
op_plus
id|HWM_ASYNC_TXD_COUNT
op_star
r_sizeof
(paren
r_struct
id|s_smt_fp_txd
)paren
)paren
suffix:semicolon
id|queue
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_S
)braket
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;Init sync TxD ring, %d TxDs &quot;
comma
id|HWM_SYNC_TXD_COUNT
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
(paren
r_void
)paren
id|init_descr_ring
c_func
(paren
id|smc
comma
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|ds
comma
id|HWM_SYNC_TXD_COUNT
)paren
suffix:semicolon
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|ds-&gt;txd_ntdadr
)paren
suffix:semicolon
id|ds
op_increment
suffix:semicolon
id|queue-&gt;tx_curr_put
op_assign
id|queue-&gt;tx_curr_get
op_assign
id|ds
suffix:semicolon
id|queue-&gt;tx_free
op_assign
id|HWM_SYNC_TXD_COUNT
suffix:semicolon
id|queue-&gt;tx_used
op_assign
l_int|0
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_DA
)paren
comma
id|phys
)paren
suffix:semicolon
)brace
DECL|function|init_rxd_ring
r_static
r_void
id|init_rxd_ring
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|ds
suffix:semicolon
r_struct
id|s_smt_rx_queue
op_star
id|queue
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the receive descriptors&n;&t; */
id|ds
op_assign
(paren
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
)paren
id|smc-&gt;os.hwm.descr_p
suffix:semicolon
id|queue
op_assign
id|smc-&gt;hw.fp.rx
(braket
id|QUEUE_R1
)braket
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;Init RxD ring, %d RxDs &quot;
comma
id|SMT_R1_RXD_COUNT
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
(paren
r_void
)paren
id|init_descr_ring
c_func
(paren
id|smc
comma
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|ds
comma
id|SMT_R1_RXD_COUNT
)paren
suffix:semicolon
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|ds-&gt;rxd_nrdadr
)paren
suffix:semicolon
id|ds
op_increment
suffix:semicolon
id|queue-&gt;rx_curr_put
op_assign
id|queue-&gt;rx_curr_get
op_assign
id|ds
suffix:semicolon
id|queue-&gt;rx_free
op_assign
id|SMT_R1_RXD_COUNT
suffix:semicolon
id|queue-&gt;rx_used
op_assign
l_int|0
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_DA
)paren
comma
id|phys
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(init_fddi_driver)&n; *&t;void init_fddi_driver(smc,mac_addr)&n; *&n; * initializes the driver and it&squot;s variables&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|init_fddi_driver
r_void
id|init_fddi_driver
c_func
(paren
id|smc
comma
id|mac_addr
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_char
op_star
id|mac_addr
suffix:semicolon
multiline_comment|/* canonical address */
(brace
id|SMbuf
op_star
id|mb
suffix:semicolon
r_int
id|i
suffix:semicolon
id|init_board
c_func
(paren
id|smc
comma
id|mac_addr
)paren
suffix:semicolon
(paren
r_void
)paren
id|init_fplus
c_func
(paren
id|smc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the SMbufs for the SMT&n;&t; */
macro_line|#ifndef&t;COMMON_MB_POOL
id|mb
op_assign
id|smc-&gt;os.hwm.mbuf_pool.mb_start
suffix:semicolon
id|smc-&gt;os.hwm.mbuf_pool.mb_free
op_assign
(paren
id|SMbuf
op_star
)paren
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mb-&gt;sm_use_count
op_assign
l_int|1
suffix:semicolon
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
id|mb
op_increment
suffix:semicolon
)brace
macro_line|#else
id|mb
op_assign
id|mb_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mb_init
)paren
(brace
id|mb_free
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mb-&gt;sm_use_count
op_assign
l_int|1
suffix:semicolon
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
id|mb
op_increment
suffix:semicolon
)brace
id|mb_init
op_assign
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * initialize the other variables&n;&t; */
id|smc-&gt;os.hwm.llc_rx_pipe
op_assign
id|smc-&gt;os.hwm.llc_rx_tail
op_assign
(paren
id|SMbuf
op_star
)paren
l_int|NULL
suffix:semicolon
id|smc-&gt;os.hwm.txd_tx_pipe
op_assign
id|smc-&gt;os.hwm.txd_tx_tail
op_assign
l_int|NULL
suffix:semicolon
id|smc-&gt;os.hwm.pass_SMT
op_assign
id|smc-&gt;os.hwm.pass_NSA
op_assign
id|smc-&gt;os.hwm.pass_DB
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;os.hwm.pass_llc_promisc
op_assign
id|TRUE
suffix:semicolon
id|smc-&gt;os.hwm.queued_rx_frames
op_assign
id|smc-&gt;os.hwm.queued_txd_mb
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;os.hwm.detec_count
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;os.hwm.rx_break
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;os.hwm.rx_len_error
op_assign
l_int|0
suffix:semicolon
id|smc-&gt;os.hwm.isr_flag
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * make sure that the start pointer is 16 byte aligned&n;&t; */
id|i
op_assign
l_int|16
op_minus
(paren
(paren
r_int
)paren
id|smc-&gt;os.hwm.descr_p
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|16
)paren
(brace
id|DB_GEN
c_func
(paren
l_string|&quot;i = %d&quot;
comma
id|i
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|smc-&gt;os.hwm.descr_p
op_assign
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|smc-&gt;os.hwm.descr_p
op_plus
id|i
)paren
suffix:semicolon
)brace
id|DB_GEN
c_func
(paren
l_string|&quot;pt to descr area = %x&quot;
comma
(paren
r_void
op_star
)paren
id|smc-&gt;os.hwm.descr_p
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|init_txd_ring
c_func
(paren
id|smc
)paren
suffix:semicolon
id|init_rxd_ring
c_func
(paren
id|smc
)paren
suffix:semicolon
id|mac_drv_fill_rxd
c_func
(paren
id|smc
)paren
suffix:semicolon
id|init_plc
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
DECL|function|smt_get_mbuf
id|SMbuf
op_star
id|smt_get_mbuf
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_register
id|SMbuf
op_star
id|mb
suffix:semicolon
macro_line|#ifndef&t;COMMON_MB_POOL
id|mb
op_assign
id|smc-&gt;os.hwm.mbuf_pool.mb_free
suffix:semicolon
macro_line|#else
id|mb
op_assign
id|mb_free
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mb
)paren
(brace
macro_line|#ifndef&t;COMMON_MB_POOL
id|smc-&gt;os.hwm.mbuf_pool.mb_free
op_assign
id|mb-&gt;sm_next
suffix:semicolon
macro_line|#else
id|mb_free
op_assign
id|mb-&gt;sm_next
suffix:semicolon
macro_line|#endif
id|mb-&gt;sm_off
op_assign
l_int|8
suffix:semicolon
id|mb-&gt;sm_use_count
op_assign
l_int|1
suffix:semicolon
)brace
id|DB_GEN
c_func
(paren
l_string|&quot;get SMbuf: mb = %x&quot;
comma
(paren
r_void
op_star
)paren
id|mb
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
r_return
(paren
id|mb
)paren
suffix:semicolon
multiline_comment|/* May be NULL */
)brace
DECL|function|smt_free_mbuf
r_void
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
(brace
r_if
c_cond
(paren
id|mb
)paren
(brace
id|mb-&gt;sm_use_count
op_decrement
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;free_mbuf: sm_use_count = %d&quot;
comma
id|mb-&gt;sm_use_count
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the use_count is != zero the MBuf is queued&n;&t;&t; * more than once and must not queued into the&n;&t;&t; * free MBuf queue&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mb-&gt;sm_use_count
)paren
(brace
id|DB_GEN
c_func
(paren
l_string|&quot;free SMbuf: mb = %x&quot;
comma
(paren
r_void
op_star
)paren
id|mb
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
macro_line|#ifndef&t;COMMON_MB_POOL
id|mb-&gt;sm_next
op_assign
id|smc-&gt;os.hwm.mbuf_pool.mb_free
suffix:semicolon
id|smc-&gt;os.hwm.mbuf_pool.mb_free
op_assign
id|mb
suffix:semicolon
macro_line|#else
id|mb-&gt;sm_next
op_assign
id|mb_free
suffix:semicolon
id|mb_free
op_assign
id|mb
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0003
comma
id|HWM_E0003_MSG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_repair_descr)&n; *&t;void mac_drv_repair_descr(smc)&n; *&n; * function&t;called from SMT&t;(HWM / hwmtm.c)&n; *&t;&t;The BMU is idle when this function is called.&n; *&t;&t;Mac_drv_repair_descr sets up the physical address&n; *&t;&t;for all receive and transmit queues where the BMU&n; *&t;&t;should continue.&n; *&t;&t;It may be that the BMU was reseted during a fragmented&n; *&t;&t;transfer. In this case there are some fragments which will&n; *&t;&t;never completed by the BMU. The OWN bit of this fragments&n; *&t;&t;must be switched to be owned by the host.&n; *&n; *&t;&t;Give a start command to the receive BMU.&n; *&t;&t;Start the transmit BMUs if transmit frames pending.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_repair_descr
r_void
id|mac_drv_repair_descr
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_long
id|phys
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;hw.hw_state
op_ne
id|STOPPED
)paren
(brace
id|SK_BREAK
c_func
(paren
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0013
comma
id|HWM_E0013_MSG
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * repair tx queues: don&squot;t start&n;&t; */
id|phys
op_assign
id|repair_txd_ring
c_func
(paren
id|smc
comma
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_A0
)braket
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_DA
)paren
comma
id|phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;hw.fp.tx_q
(braket
id|QUEUE_A0
)braket
dot
id|tx_used
)paren
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XA_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
id|phys
op_assign
id|repair_txd_ring
c_func
(paren
id|smc
comma
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_S
)braket
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_DA
)paren
comma
id|phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;hw.fp.tx_q
(braket
id|QUEUE_S
)braket
dot
id|tx_used
)paren
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XS_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * repair rx queues&n;&t; */
id|phys
op_assign
id|repair_rxd_ring
c_func
(paren
id|smc
comma
id|smc-&gt;hw.fp.rx
(braket
id|QUEUE_R1
)braket
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_DA
)paren
comma
id|phys
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_R1_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
DECL|function|repair_txd_ring
r_static
id|u_long
id|repair_txd_ring
c_func
(paren
id|smc
comma
id|queue
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_int
id|tx_used
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
id|u_long
id|tbctrl
suffix:semicolon
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|t
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|t
op_assign
id|queue-&gt;tx_curr_get
suffix:semicolon
id|tx_used
op_assign
id|queue-&gt;tx_used
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|tx_used
op_plus
id|queue-&gt;tx_free
op_minus
l_int|1
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|t
op_assign
id|t-&gt;txd_next
suffix:semicolon
)brace
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|t-&gt;txd_ntdadr
)paren
suffix:semicolon
id|t
op_assign
id|queue-&gt;tx_curr_get
suffix:semicolon
r_while
c_loop
(paren
id|tx_used
)paren
(brace
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|tbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|t-&gt;txd_tbctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbctrl
op_amp
id|BMU_OWN
)paren
(brace
r_if
c_cond
(paren
id|tbctrl
op_amp
id|BMU_STF
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* exit the loop */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * repair the descriptor&n;&t;&t;&t;&t; */
id|t-&gt;txd_tbctrl
op_and_assign
id|AIX_REVERSE
c_func
(paren
op_complement
id|BMU_OWN
)paren
suffix:semicolon
)brace
)brace
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|t-&gt;txd_ntdadr
)paren
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|t
op_assign
id|t-&gt;txd_next
suffix:semicolon
id|tx_used
op_decrement
suffix:semicolon
)brace
r_return
(paren
id|phys
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Repairs the receive descriptor ring and returns the physical address&n; * where the BMU should continue working.&n; *&n; *&t;o The physical address where the BMU was stopped has to be&n; *&t;  determined. This is the next RxD after rx_curr_get with an OWN&n; *&t;  bit set.&n; *&t;o The BMU should start working at beginning of the next frame.&n; *&t;  RxDs with an OWN bit set but with a reset STF bit should be&n; *&t;  skipped and owned by the driver (OWN = 0). &n; */
DECL|function|repair_rxd_ring
r_static
id|u_long
id|repair_rxd_ring
c_func
(paren
id|smc
comma
id|queue
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_struct
id|s_smt_rx_queue
op_star
id|queue
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_int
id|rx_used
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
id|u_long
id|rbctrl
suffix:semicolon
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|r
suffix:semicolon
id|SK_UNUSED
c_func
(paren
id|smc
)paren
suffix:semicolon
id|r
op_assign
id|queue-&gt;rx_curr_get
suffix:semicolon
id|rx_used
op_assign
id|queue-&gt;rx_used
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|SMT_R1_RXD_COUNT
op_minus
l_int|1
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|r
op_assign
id|r-&gt;rxd_next
suffix:semicolon
)brace
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|r-&gt;rxd_nrdadr
)paren
suffix:semicolon
id|r
op_assign
id|queue-&gt;rx_curr_get
suffix:semicolon
r_while
c_loop
(paren
id|rx_used
)paren
(brace
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|rbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|r-&gt;rxd_rbctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbctrl
op_amp
id|BMU_OWN
)paren
(brace
r_if
c_cond
(paren
id|rbctrl
op_amp
id|BMU_STF
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* exit the loop */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * repair the descriptor&n;&t;&t;&t;&t; */
id|r-&gt;rxd_rbctrl
op_and_assign
id|AIX_REVERSE
c_func
(paren
op_complement
id|BMU_OWN
)paren
suffix:semicolon
)brace
)brace
id|phys
op_assign
id|AIX_REVERSE
c_func
(paren
id|r-&gt;rxd_nrdadr
)paren
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
suffix:semicolon
id|rx_used
op_decrement
suffix:semicolon
)brace
r_return
(paren
id|phys
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;INTERRUPT SERVICE ROUTINE:&n;&t;-------------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(fddi_isr)&n; *&t;void fddi_isr(smc)&n; *&n; * function&t;DOWNCALL&t;(drvsr.c)&n; *&t;&t;interrupt service routine, handles the interrupt requests&n; *&t;&t;generated by the FDDI adapter.&n; *&n; * NOTE:&t;The operating system dependent module must garantee that the&n; *&t;&t;interrupts of the adapter are disabled when it calls fddi_isr.&n; *&n; *&t;About the USE_BREAK_ISR mechanismn:&n; *&n; *&t;The main requirement of this mechanismn is to force an timer IRQ when&n; *&t;leaving process_receive() with leave_isr set. process_receive() may&n; *&t;be called at any time from anywhere!&n; *&t;To be sure we don&squot;t miss such event we set &squot;force_irq&squot; per default.&n; *&t;We have to force and Timer IRQ if &squot;smc-&gt;os.hwm.leave_isr&squot; AND&n; *&t;&squot;force_irq&squot; are set. &squot;force_irq&squot; may be reset if a receive complete&n; *&t;IRQ is pending.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|fddi_isr
r_void
id|fddi_isr
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|u_long
id|is
suffix:semicolon
multiline_comment|/* ISR source */
id|u_short
id|stu
comma
id|stl
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
macro_line|#ifdef&t;USE_BREAK_ISR
r_int
id|force_irq
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;ODI2
r_if
c_cond
(paren
id|smc-&gt;os.hwm.rx_break
)paren
(brace
id|mac_drv_fill_rxd
c_func
(paren
id|smc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R1
)braket
dot
id|rx_used
OG
l_int|0
)paren
(brace
id|smc-&gt;os.hwm.rx_break
op_assign
l_int|0
suffix:semicolon
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;os.hwm.detec_count
op_assign
l_int|0
suffix:semicolon
id|smt_force_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|smc-&gt;os.hwm.isr_flag
op_assign
id|TRUE
suffix:semicolon
macro_line|#ifdef&t;USE_BREAK_ISR
id|force_irq
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;os.hwm.leave_isr
)paren
(brace
id|smc-&gt;os.hwm.leave_isr
op_assign
id|FALSE
suffix:semicolon
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
(paren
id|is
op_assign
id|GET_ISR
c_func
(paren
)paren
op_amp
id|ISR_MASK
)paren
)paren
(brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;CH0B&quot;
comma
id|is
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;ISA = 0x%x&quot;
comma
id|is
comma
l_int|0
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is
op_amp
id|IMASK_SLOW
)paren
(brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;CH1b&quot;
comma
id|is
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is
op_amp
id|IS_PLINT1
)paren
(brace
multiline_comment|/* PLC1 */
id|plc1_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_PLINT2
)paren
(brace
multiline_comment|/* PLC2 */
id|plc2_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_MINTR1
)paren
(brace
multiline_comment|/* FORMAC+ STU1(U/L) */
id|stu
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST1U
)paren
)paren
suffix:semicolon
id|stl
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST1L
)paren
)paren
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;Slow transmit complete&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|mac1_irq
c_func
(paren
id|smc
comma
id|stu
comma
id|stl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_MINTR2
)paren
(brace
multiline_comment|/* FORMAC+ STU2(U/L) */
id|stu
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST2U
)paren
)paren
suffix:semicolon
id|stl
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST2L
)paren
)paren
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;Slow receive complete&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;stl = %x : stu = %x&quot;
comma
id|stl
comma
id|stu
comma
l_int|7
)paren
suffix:semicolon
id|mac2_irq
c_func
(paren
id|smc
comma
id|stu
comma
id|stl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_MINTR3
)paren
(brace
multiline_comment|/* FORMAC+ STU3(U/L) */
id|stu
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST3U
)paren
)paren
suffix:semicolon
id|stl
op_assign
id|inpw
c_func
(paren
id|FM_A
c_func
(paren
id|FM_ST3L
)paren
)paren
suffix:semicolon
id|DB_GEN
c_func
(paren
l_string|&quot;FORMAC Mode Register 3&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|mac3_irq
c_func
(paren
id|smc
comma
id|stu
comma
id|stl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_TIMINT
)paren
(brace
multiline_comment|/* Timer 82C54-2 */
id|timer_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#ifdef&t;NDIS_OS2
id|force_irq_pending
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t; * out of RxD detection&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_increment
id|smc-&gt;os.hwm.detec_count
OG
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * check out of RxD condition&n;&t;&t;&t;&t;&t; */
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_TOKEN
)paren
(brace
multiline_comment|/* Restricted Token Monitor */
id|rtm_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_R1_P
)paren
(brace
multiline_comment|/* Parity error rx queue 1 */
multiline_comment|/* clear IRQ */
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_CSR
)paren
comma
id|CSR_IRQ_CL_P
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0004
comma
id|HWM_E0004_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_R1_C
)paren
(brace
multiline_comment|/* Encoding error rx queue 1 */
multiline_comment|/* clear IRQ */
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_CSR
)paren
comma
id|CSR_IRQ_CL_C
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0005
comma
id|HWM_E0005_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_XA_C
)paren
(brace
multiline_comment|/* Encoding error async tx q */
multiline_comment|/* clear IRQ */
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_CSR
)paren
comma
id|CSR_IRQ_CL_C
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0006
comma
id|HWM_E0006_MSG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_amp
id|IS_XS_C
)paren
(brace
multiline_comment|/* Encoding error sync tx q */
multiline_comment|/* clear IRQ */
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_CSR
)paren
comma
id|CSR_IRQ_CL_C
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0007
comma
id|HWM_E0007_MSG
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Fast Tx complete Async/Sync Queue (BMU service)&n;&t;&t; */
r_if
c_cond
(paren
id|is
op_amp
(paren
id|IS_XS_F
op_or
id|IS_XA_F
)paren
)paren
(brace
id|DB_GEN
c_func
(paren
l_string|&quot;Fast tx complete queue&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * clear IRQ, Note: no IRQ is lost, because&n;&t;&t;&t; * &t;we always service both queues&n;&t;&t;&t; */
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_CSR
)paren
comma
id|CSR_IRQ_CL_F
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_CSR
)paren
comma
id|CSR_IRQ_CL_F
)paren
suffix:semicolon
id|mac_drv_clear_txd
c_func
(paren
id|smc
)paren
suffix:semicolon
id|llc_restart_tx
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Fast Rx Complete (BMU service)&n;&t;&t; */
r_if
c_cond
(paren
id|is
op_amp
id|IS_R1_F
)paren
(brace
id|DB_GEN
c_func
(paren
l_string|&quot;Fast receive complete&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* clear IRQ */
macro_line|#ifndef USE_BREAK_ISR
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_CSR
)paren
comma
id|CSR_IRQ_CL_F
)paren
suffix:semicolon
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#else
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;os.hwm.leave_isr
)paren
(brace
id|force_irq
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B4_R1_CSR
)paren
comma
id|CSR_IRQ_CL_F
)paren
suffix:semicolon
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifndef&t;NDIS_OS2
r_while
c_loop
(paren
(paren
id|mb
op_assign
id|get_llc_rx
c_func
(paren
id|smc
)paren
)paren
)paren
(brace
id|smt_to_llc
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|offDepth
)paren
id|post_proc
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|offDepth
op_logical_and
(paren
id|mb
op_assign
id|get_llc_rx
c_func
(paren
id|smc
)paren
)paren
)paren
(brace
id|smt_to_llc
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|offDepth
op_logical_and
id|smc-&gt;os.hwm.rx_break
)paren
(brace
id|process_receive
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|smc-&gt;q.ev_get
op_ne
id|smc-&gt;q.ev_put
)paren
(brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;CH2a&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ev_dispatcher
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;NDIS_OS2
id|post_proc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offDepth
)paren
(brace
multiline_comment|/* leave fddi_isr because */
r_break
suffix:semicolon
multiline_comment|/* indications not allowed */
)brace
macro_line|#endif
macro_line|#ifdef&t;USE_BREAK_ISR
r_if
c_cond
(paren
id|smc-&gt;os.hwm.leave_isr
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* leave fddi_isr */
)brace
macro_line|#endif
multiline_comment|/* NOTE: when the isr is left, no rx is pending */
)brace
multiline_comment|/* end of interrupt source polling loop */
macro_line|#ifdef&t;USE_BREAK_ISR
r_if
c_cond
(paren
id|smc-&gt;os.hwm.leave_isr
op_logical_and
id|force_irq
)paren
(brace
id|smt_force_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
macro_line|#endif
id|smc-&gt;os.hwm.isr_flag
op_assign
id|FALSE
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;CH0E&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;RECEIVE FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
macro_line|#ifndef&t;NDIS_OS2
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_rx_mode)&n; *&t;void mac_drv_rx_mode(smc,mode)&n; *&n; * function&t;DOWNCALL&t;(fplus.c)&n; *&t;&t;Corresponding to the parameter mode, the operating system&n; *&t;&t;dependent module can activate several receive modes.&n; *&n; * para&t;mode&t;= 1:&t;RX_ENABLE_ALLMULTI&t;enable all multicasts&n; *&t;&t;= 2:&t;RX_DISABLE_ALLMULTI&t;disable &quot;enable all multicasts&quot;&n; *&t;&t;= 3:&t;RX_ENABLE_PROMISC&t;enable promiscuous&n; *&t;&t;= 4:&t;RX_DISABLE_PROMISC&t;disable promiscuous&n; *&t;&t;= 5:&t;RX_ENABLE_NSA&t;&t;enable rec. of all NSA frames&n; *&t;&t;&t;(disabled after &squot;driver reset&squot; &amp; &squot;set station address&squot;)&n; *&t;&t;= 6:&t;RX_DISABLE_NSA&t;&t;disable rec. of all NSA frames&n; *&n; *&t;&t;= 21:&t;RX_ENABLE_PASS_SMT&t;( see description )&n; *&t;&t;= 22:&t;RX_DISABLE_PASS_SMT&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 23:&t;RX_ENABLE_PASS_NSA&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 24:&t;RX_DISABLE_PASS_NSA&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 25:&t;RX_ENABLE_PASS_DB&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 26:&t;RX_DISABLE_PASS_DB&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 27:&t;RX_DISABLE_PASS_ALL&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 28:&t;RX_DISABLE_LLC_PROMISC&t;(  &quot;&t;   &quot;&t;  )&n; *&t;&t;= 29:&t;RX_ENABLE_LLC_PROMISC&t;(  &quot;&t;   &quot;&t;  )&n; *&n; *&n; *&t;&t;RX_ENABLE_PASS_SMT / RX_DISABLE_PASS_SMT&n; *&n; *&t;&t;If the operating system dependent module activates the&n; *&t;&t;mode RX_ENABLE_PASS_SMT, the hardware module&n; *&t;&t;duplicates all SMT frames with the frame control&n; *&t;&t;FC_SMT_INFO and passes them to the LLC receive channel&n; *&t;&t;by calling mac_drv_rx_init.&n; *&t;&t;The SMT Frames which are sent by the local SMT and the NSA&n; *&t;&t;frames whose A- and C-Indicator is not set are also duplicated&n; *&t;&t;and passed.&n; *&t;&t;The receive mode RX_DISABLE_PASS_SMT disables the passing&n; *&t;&t;of SMT frames.&n; *&n; *&t;&t;RX_ENABLE_PASS_NSA / RX_DISABLE_PASS_NSA&n; *&n; *&t;&t;If the operating system dependent module activates the&n; *&t;&t;mode RX_ENABLE_PASS_NSA, the hardware module&n; *&t;&t;duplicates all NSA frames with frame control FC_SMT_NSA&n; *&t;&t;and a set A-Indicator and passed them to the LLC&n; *&t;&t;receive channel by calling mac_drv_rx_init.&n; *&t;&t;All NSA Frames which are sent by the local SMT&n; *&t;&t;are also duplicated and passed.&n; *&t;&t;The receive mode RX_DISABLE_PASS_NSA disables the passing&n; *&t;&t;of NSA frames with the A- or C-Indicator set.&n; *&n; * NOTE:&t;For fear that the hardware module receives NSA frames with&n; *&t;&t;a reset A-Indicator, the operating system dependent module&n; *&t;&t;has to call mac_drv_rx_mode with the mode RX_ENABLE_NSA&n; *&t;&t;before activate the RX_ENABLE_PASS_NSA mode and after every&n; *&t;&t;&squot;driver reset&squot; and &squot;set station address&squot;.&n; *&n; *&t;&t;RX_ENABLE_PASS_DB / RX_DISABLE_PASS_DB&n; *&n; *&t;&t;If the operating system dependent module activates the&n; *&t;&t;mode RX_ENABLE_PASS_DB, direct BEACON frames&n; *&t;&t;(FC_BEACON frame control) are passed to the LLC receive&n; *&t;&t;channel by mac_drv_rx_init.&n; *&t;&t;The receive mode RX_DISABLE_PASS_DB disables the passing&n; *&t;&t;of direct BEACON frames.&n; *&n; *&t;&t;RX_DISABLE_PASS_ALL&n; *&n; *&t;&t;Disables all special receives modes. It is equal to&n; *&t;&t;call mac_drv_set_rx_mode successively with the&n; *&t;&t;parameters RX_DISABLE_NSA, RX_DISABLE_PASS_SMT,&n; *&t;&t;RX_DISABLE_PASS_NSA and RX_DISABLE_PASS_DB.&n; *&n; *&t;&t;RX_ENABLE_LLC_PROMISC&n; *&n; *&t;&t;(default) all received LLC frames and all SMT/NSA/DBEACON&n; *&t;&t;frames depending on the attitude of the flags&n; *&t;&t;PASS_SMT/PASS_NSA/PASS_DBEACON will be delivered to the&n; *&t;&t;LLC layer&n; *&n; *&t;&t;RX_DISABLE_LLC_PROMISC&n; *&n; *&t;&t;all received SMT/NSA/DBEACON frames depending on the&n; *&t;&t;attitude of the flags PASS_SMT/PASS_NSA/PASS_DBEACON&n; *&t;&t;will be delivered to the LLC layer.&n; *&t;&t;all received LLC frames with a directed address, Multicast&n; *&t;&t;or Broadcast address will be delivered to the LLC&n; *&t;&t;layer too.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_rx_mode
r_void
id|mac_drv_rx_mode
c_func
(paren
id|smc
comma
id|mode
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|mode
suffix:semicolon
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|RX_ENABLE_PASS_SMT
suffix:colon
id|smc-&gt;os.hwm.pass_SMT
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_PASS_SMT
suffix:colon
id|smc-&gt;os.hwm.pass_SMT
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_ENABLE_PASS_NSA
suffix:colon
id|smc-&gt;os.hwm.pass_NSA
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_PASS_NSA
suffix:colon
id|smc-&gt;os.hwm.pass_NSA
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_ENABLE_PASS_DB
suffix:colon
id|smc-&gt;os.hwm.pass_DB
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_PASS_DB
suffix:colon
id|smc-&gt;os.hwm.pass_DB
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_PASS_ALL
suffix:colon
id|smc-&gt;os.hwm.pass_SMT
op_assign
id|smc-&gt;os.hwm.pass_NSA
op_assign
id|FALSE
suffix:semicolon
id|smc-&gt;os.hwm.pass_DB
op_assign
id|FALSE
suffix:semicolon
id|smc-&gt;os.hwm.pass_llc_promisc
op_assign
id|TRUE
suffix:semicolon
id|mac_set_rx_mode
c_func
(paren
id|smc
comma
id|RX_DISABLE_NSA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_DISABLE_LLC_PROMISC
suffix:colon
id|smc-&gt;os.hwm.pass_llc_promisc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_ENABLE_LLC_PROMISC
suffix:colon
id|smc-&gt;os.hwm.pass_llc_promisc
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_ENABLE_ALLMULTI
suffix:colon
r_case
id|RX_DISABLE_ALLMULTI
suffix:colon
r_case
id|RX_ENABLE_PROMISC
suffix:colon
r_case
id|RX_DISABLE_PROMISC
suffix:colon
r_case
id|RX_ENABLE_NSA
suffix:colon
r_case
id|RX_DISABLE_NSA
suffix:colon
r_default
suffix:colon
id|mac_set_rx_mode
c_func
(paren
id|smc
comma
id|mode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* ifndef NDIS_OS2 */
multiline_comment|/*&n; * process receive queue&n; */
DECL|function|process_receive
r_void
id|process_receive
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|frag_count
suffix:semicolon
multiline_comment|/* number of RxDs of the curr rx buf */
r_int
id|used_frags
suffix:semicolon
multiline_comment|/* number of RxDs of the curr frame */
r_struct
id|s_smt_rx_queue
op_star
id|queue
suffix:semicolon
multiline_comment|/* points to the queue ctl struct */
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|r
suffix:semicolon
multiline_comment|/* rxd pointer */
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|rxd
suffix:semicolon
multiline_comment|/* first rxd of rx frame */
id|u_long
id|rbctrl
suffix:semicolon
multiline_comment|/* receive buffer control word */
id|u_long
id|rfsw
suffix:semicolon
multiline_comment|/* receive frame status word */
id|u_short
id|rx_used
suffix:semicolon
id|u_char
id|far
op_star
id|virt
suffix:semicolon
r_char
id|far
op_star
id|data
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
id|u_char
id|fc
suffix:semicolon
multiline_comment|/* Frame control */
r_int
id|len
suffix:semicolon
multiline_comment|/* Frame length */
id|smc-&gt;os.hwm.detec_count
op_assign
l_int|0
suffix:semicolon
id|queue
op_assign
id|smc-&gt;hw.fp.rx
(braket
id|QUEUE_R1
)braket
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHxB&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|r
op_assign
id|queue-&gt;rx_curr_get
suffix:semicolon
id|rx_used
op_assign
id|queue-&gt;rx_used
suffix:semicolon
id|frag_count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;USE_BREAK_ISR
r_if
c_cond
(paren
id|smc-&gt;os.hwm.leave_isr
)paren
(brace
r_goto
id|rx_end
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef&t;NDIS_OS2
r_if
c_cond
(paren
id|offDepth
)paren
(brace
id|smc-&gt;os.hwm.rx_break
op_assign
l_int|1
suffix:semicolon
r_goto
id|rx_end
suffix:semicolon
)brace
id|smc-&gt;os.hwm.rx_break
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;ODI2
r_if
c_cond
(paren
id|smc-&gt;os.hwm.rx_break
)paren
(brace
r_goto
id|rx_end
suffix:semicolon
)brace
macro_line|#endif
id|n
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Check RxD %x for OWN and EOF&quot;
comma
(paren
r_void
op_star
)paren
id|r
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|rbctrl
op_assign
id|CR_READ
c_func
(paren
id|r-&gt;rxd_rbctrl
)paren
suffix:semicolon
id|rbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|rbctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbctrl
op_amp
id|BMU_OWN
)paren
(brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHxE&quot;
comma
id|r
comma
id|rfsw
comma
id|rbctrl
)paren
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;End of RxDs&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_goto
id|rx_end
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * out of RxD detection&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rx_used
)paren
(brace
id|SK_BREAK
c_func
(paren
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0009
comma
id|HWM_E0009_MSG
)paren
suffix:semicolon
multiline_comment|/* Either we don&squot;t have an RxD or all&n;&t;&t;&t;&t; * RxDs are filled. Therefore it&squot;s allowed&n;&t;&t;&t;&t; * for to set the STOPPED flag */
id|smc-&gt;hw.hw_state
op_assign
id|STOPPED
suffix:semicolon
id|mac_drv_clear_rx_queue
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smc-&gt;hw.hw_state
op_assign
id|STARTED
suffix:semicolon
id|mac_drv_fill_rxd
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smc-&gt;os.hwm.detec_count
op_assign
l_int|0
suffix:semicolon
r_goto
id|rx_end
suffix:semicolon
)brace
id|rfsw
op_assign
id|AIX_REVERSE
c_func
(paren
id|r-&gt;rxd_rfsw
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rbctrl
op_amp
id|BMU_STF
)paren
op_ne
(paren
(paren
id|rbctrl
op_amp
id|BMU_ST_BUF
)paren
op_lshift
l_int|5
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The BMU_STF bit is deleted, 1 frame is&n;&t;&t;&t;&t; * placed into more than 1 rx buffer&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * skip frame by setting the rx len to 0&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * if fragment count == 0&n;&t;&t;&t;&t; *&t;The missing STF bit belongs to the&n;&t;&t;&t;&t; *&t;current frame, search for the&n;&t;&t;&t;&t; *&t;EOF bit to complete the frame&n;&t;&t;&t;&t; * else&n;&t;&t;&t;&t; *&t;the fragment belongs to the next frame,&n;&t;&t;&t;&t; *&t;exit the loop and process the frame&n;&t;&t;&t;&t; */
id|SK_BREAK
c_func
(paren
)paren
suffix:semicolon
id|rfsw
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|frag_count
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|n
op_add_assign
id|rbctrl
op_amp
l_int|0xffff
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
suffix:semicolon
id|frag_count
op_increment
suffix:semicolon
id|rx_used
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|rbctrl
op_amp
id|BMU_EOF
)paren
)paren
suffix:semicolon
id|used_frags
op_assign
id|frag_count
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;EOF set in RxD, used_frags = %d &quot;
comma
id|used_frags
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* may be next 2 DRV_BUF_FLUSH() can be skipped, because */
multiline_comment|/* BMU_ST_BUF will not be changed by the ASIC */
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rx_used
op_logical_and
op_logical_neg
(paren
id|r-&gt;rxd_rbctrl
op_amp
id|AIX_REVERSE
c_func
(paren
id|BMU_ST_BUF
)paren
)paren
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Check STF bit in %x&quot;
comma
(paren
r_void
op_star
)paren
id|r
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|frag_count
op_increment
suffix:semicolon
id|rx_used
op_decrement
suffix:semicolon
)brace
id|DB_RX
c_func
(paren
l_string|&quot;STF bit found&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The received frame is finished for the process receive&n;&t;&t; */
id|rxd
op_assign
id|queue-&gt;rx_curr_get
suffix:semicolon
id|queue-&gt;rx_curr_get
op_assign
id|r
suffix:semicolon
id|queue-&gt;rx_free
op_add_assign
id|frag_count
suffix:semicolon
id|queue-&gt;rx_used
op_assign
id|rx_used
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ASIC Errata no. 7 (STF - Bit Bug)&n;&t;&t; */
id|rxd-&gt;rxd_rbctrl
op_and_assign
id|AIX_REVERSE
c_func
(paren
op_complement
id|BMU_STF
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|rxd
comma
id|i
op_assign
id|frag_count
suffix:semicolon
id|i
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
comma
id|i
op_decrement
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;dma_complete for RxD %x&quot;
comma
(paren
r_void
op_star
)paren
id|r
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|dma_complete
c_func
(paren
id|smc
comma
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|r
comma
id|DMA_WR
)paren
suffix:semicolon
)brace
id|smc-&gt;hw.fp.err_stats.err_valid
op_increment
suffix:semicolon
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACCopied_Ct
op_increment
suffix:semicolon
multiline_comment|/* the length of the data including the FC */
id|len
op_assign
(paren
id|rfsw
op_amp
id|RD_LENGTH
)paren
op_minus
l_int|4
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;frame length = %d&quot;
comma
id|len
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check the frame_lenght and all error flags&n;&t;&t; */
r_if
c_cond
(paren
id|rfsw
op_amp
(paren
id|RX_MSRABT
op_or
id|RX_FS_E
op_or
id|RX_FS_CRC
op_or
id|RX_FS_IMPL
)paren
)paren
(brace
r_if
c_cond
(paren
id|rfsw
op_amp
id|RD_S_MSRABT
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Frame aborted by the FORMAC&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smc-&gt;hw.fp.err_stats.err_abort
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * check frame status&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rfsw
op_amp
id|RD_S_SEAC2
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;E-Indicator set&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smc-&gt;hw.fp.err_stats.err_e_indicator
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rfsw
op_amp
id|RD_S_SFRMERR
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;CRC error&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smc-&gt;hw.fp.err_stats.err_crc
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rfsw
op_amp
id|RX_FS_IMPL
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Implementer frame&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smc-&gt;hw.fp.err_stats.err_imp_frame
op_increment
suffix:semicolon
)brace
r_goto
id|abort_frame
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|FDDI_RAW_MTU
op_minus
l_int|4
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Frame to long error&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smc-&gt;hw.fp.err_stats.err_too_long
op_increment
suffix:semicolon
r_goto
id|abort_frame
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * SUPERNET 3 Bug: FORMAC delivers status words&n;&t;&t; * of aborded frames to the BMU&n;&t;&t; */
r_if
c_cond
(paren
id|len
op_le
l_int|4
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Frame length = 0&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_goto
id|abort_frame
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_ne
(paren
id|n
op_minus
l_int|4
)paren
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;BMU: rx len differs: [%d:%d]&quot;
comma
id|len
comma
id|n
comma
l_int|4
)paren
suffix:semicolon
id|smc-&gt;os.hwm.rx_len_error
op_increment
suffix:semicolon
r_goto
id|abort_frame
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check SA == MA&n;&t;&t; */
id|virt
op_assign
(paren
id|u_char
id|far
op_star
)paren
id|rxd-&gt;rxd_virt
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;FC = %x&quot;
comma
op_star
id|virt
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|virt
(braket
l_int|12
)braket
op_eq
id|MA
(braket
l_int|5
)braket
op_logical_and
id|virt
(braket
l_int|11
)braket
op_eq
id|MA
(braket
l_int|4
)braket
op_logical_and
id|virt
(braket
l_int|10
)braket
op_eq
id|MA
(braket
l_int|3
)braket
op_logical_and
id|virt
(braket
l_int|9
)braket
op_eq
id|MA
(braket
l_int|2
)braket
op_logical_and
id|virt
(braket
l_int|8
)braket
op_eq
id|MA
(braket
l_int|1
)braket
op_logical_and
(paren
id|virt
(braket
l_int|7
)braket
op_amp
op_complement
id|GROUP_ADDR_BIT
)paren
op_eq
id|MA
(braket
l_int|0
)braket
)paren
(brace
r_goto
id|abort_frame
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * test if LLC frame&n;&t;&t; */
r_if
c_cond
(paren
id|rfsw
op_amp
id|RX_FS_LLC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * if pass_llc_promisc is disable&n;&t;&t;&t; *&t;if DA != Multicast or Broadcast or DA!=MA&n;&t;&t;&t; *&t;&t;abort the frame&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;os.hwm.pass_llc_promisc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|virt
(braket
l_int|1
)braket
op_amp
id|GROUP_ADDR_BIT
)paren
)paren
(brace
r_if
c_cond
(paren
id|virt
(braket
l_int|6
)braket
op_ne
id|MA
(braket
l_int|5
)braket
op_logical_or
id|virt
(braket
l_int|5
)braket
op_ne
id|MA
(braket
l_int|4
)braket
op_logical_or
id|virt
(braket
l_int|4
)braket
op_ne
id|MA
(braket
l_int|3
)braket
op_logical_or
id|virt
(braket
l_int|3
)braket
op_ne
id|MA
(braket
l_int|2
)braket
op_logical_or
id|virt
(braket
l_int|2
)braket
op_ne
id|MA
(braket
l_int|1
)braket
op_logical_or
id|virt
(braket
l_int|1
)braket
op_ne
id|MA
(braket
l_int|0
)braket
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;DA != MA and not multi- or broadcast&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_goto
id|abort_frame
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * LLC frame received&n;&t;&t;&t; */
id|DB_RX
c_func
(paren
l_string|&quot;LLC - receive&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|mac_drv_rx_complete
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mb
op_assign
id|smt_get_mbuf
c_func
(paren
id|smc
)paren
)paren
)paren
(brace
id|smc-&gt;hw.fp.err_stats.err_no_buf
op_increment
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;No SMbuf; receive terminated&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_goto
id|abort_frame
suffix:semicolon
)brace
id|data
op_assign
id|smtod
c_func
(paren
id|mb
comma
r_char
op_star
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * copy the frame into a SMT_MBuf&n;&t;&t;&t; */
macro_line|#ifdef USE_OS_CPY
id|hwm_cpy_rxd2mb
c_func
(paren
id|rxd
comma
id|data
comma
id|len
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|r
op_assign
id|rxd
comma
id|i
op_assign
id|used_frags
suffix:semicolon
id|i
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
comma
id|i
op_decrement
)paren
(brace
id|n
op_assign
id|AIX_REVERSE
c_func
(paren
id|r-&gt;rxd_rbctrl
)paren
op_amp
id|RD_LENGTH
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;cp SMT frame to mb: len = %d&quot;
comma
id|n
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
comma
id|r-&gt;rxd_virt
comma
id|n
)paren
suffix:semicolon
id|data
op_add_assign
id|n
suffix:semicolon
)brace
id|data
op_assign
id|smtod
c_func
(paren
id|mb
comma
r_char
op_star
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|fc
op_assign
op_star
(paren
r_char
op_star
)paren
id|mb-&gt;sm_data
op_assign
op_star
id|data
suffix:semicolon
id|mb-&gt;sm_len
op_assign
id|len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* len - fc */
id|data
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * SMT frame received&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|fc
)paren
(brace
r_case
id|FC_SMT_INFO
suffix:colon
id|smc-&gt;hw.fp.err_stats.err_smt_frame
op_increment
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;SMT frame received &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;os.hwm.pass_SMT
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;pass SMT frame &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_rx_complete
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|DB_RX
c_func
(paren
l_string|&quot;requeue RxD&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_requeue_rxd
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
)paren
suffix:semicolon
)brace
id|smt_received_pack
c_func
(paren
id|smc
comma
id|mb
comma
(paren
r_int
)paren
(paren
id|rfsw
op_rshift
l_int|25
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FC_SMT_NSA
suffix:colon
id|smc-&gt;hw.fp.err_stats.err_smt_frame
op_increment
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;SMT frame received &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* if pass_NSA set pass the NSA frame or */
multiline_comment|/* pass_SMT set and the A-Indicator */
multiline_comment|/* is not set, pass the NSA frame */
r_if
c_cond
(paren
id|smc-&gt;os.hwm.pass_NSA
op_logical_or
(paren
id|smc-&gt;os.hwm.pass_SMT
op_logical_and
op_logical_neg
(paren
id|rfsw
op_amp
id|A_INDIC
)paren
)paren
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;pass SMT frame &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_rx_complete
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|DB_RX
c_func
(paren
l_string|&quot;requeue RxD&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_requeue_rxd
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
)paren
suffix:semicolon
)brace
id|smt_received_pack
c_func
(paren
id|smc
comma
id|mb
comma
(paren
r_int
)paren
(paren
id|rfsw
op_rshift
l_int|25
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FC_BEACON
suffix:colon
r_if
c_cond
(paren
id|smc-&gt;os.hwm.pass_DB
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;pass DB frame &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_rx_complete
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|DB_RX
c_func
(paren
l_string|&quot;requeue RxD&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_requeue_rxd
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
)paren
suffix:semicolon
)brace
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * unknown FC abord the frame&n;&t;&t;&t;&t; */
id|DB_RX
c_func
(paren
l_string|&quot;unknown FC error&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;requeue RxD&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_requeue_rxd
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fc
op_amp
l_int|0xf0
)paren
op_eq
id|FC_MAC
)paren
id|smc-&gt;hw.fp.err_stats.err_mac_frame
op_increment
suffix:semicolon
r_else
id|smc-&gt;hw.fp.err_stats.err_imp_frame
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|DB_RX
c_func
(paren
l_string|&quot;next RxD is %x &quot;
comma
id|queue-&gt;rx_curr_get
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHx1&quot;
comma
id|queue-&gt;rx_curr_get
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------*/
id|abort_frame
suffix:colon
id|DB_RX
c_func
(paren
l_string|&quot;requeue RxD&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_requeue_rxd
c_func
(paren
id|smc
comma
id|rxd
comma
id|frag_count
)paren
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;next RxD is %x &quot;
comma
id|queue-&gt;rx_curr_get
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHx2&quot;
comma
id|queue-&gt;rx_curr_get
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|rx_end
suffix:colon
macro_line|#ifdef&t;ALL_RX_COMPLETE
id|mac_drv_all_receives_complete
c_func
(paren
id|smc
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
multiline_comment|/* lint bug: needs return detect end of function */
)brace
DECL|function|smt_to_llc
r_static
r_void
id|smt_to_llc
c_func
(paren
id|smc
comma
id|mb
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
(brace
id|u_char
id|fc
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;send a queued frame to the llc layer&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|smc-&gt;os.hwm.r.len
op_assign
id|mb-&gt;sm_len
suffix:semicolon
id|smc-&gt;os.hwm.r.mb_pos
op_assign
id|smtod
c_func
(paren
id|mb
comma
r_char
op_star
)paren
suffix:semicolon
id|fc
op_assign
op_star
id|smc-&gt;os.hwm.r.mb_pos
suffix:semicolon
(paren
r_void
)paren
id|mac_drv_rx_init
c_func
(paren
id|smc
comma
(paren
r_int
)paren
id|mb-&gt;sm_len
comma
(paren
r_int
)paren
id|fc
comma
id|smc-&gt;os.hwm.r.mb_pos
comma
(paren
r_int
)paren
id|mb-&gt;sm_len
)paren
suffix:semicolon
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(hwm_rx_frag)&n; *&t;void hwm_rx_frag(smc,virt,phys,len,frame_status)&n; *&n; * function&t;MACRO&t;&t;(hardware module, hwmtm.h)&n; *&t;&t;This function calls dma_master for preparing the&n; *&t;&t;system hardware for the DMA transfer and initializes&n; *&t;&t;the current RxD with the length and the physical and&n; *&t;&t;virtual address of the fragment. Furthermore, it sets the&n; *&t;&t;STF and EOF bits depending on the frame status byte,&n; *&t;&t;switches the OWN flag of the RxD, so that it is owned by the&n; *&t;&t;adapter and issues an rx_start.&n; *&n; * para&t;virt&t;virtual pointer to the fragment&n; *&t;len&t;the length of the fragment&n; *&t;frame_status&t;status of the frame, see design description&n; *&n; * NOTE:&t;It is possible to call this function with a fragment length&n; *&t;&t;of zero.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|hwm_rx_frag
r_void
id|hwm_rx_frag
c_func
(paren
id|smc
comma
id|virt
comma
id|phys
comma
id|len
comma
id|frame_status
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_char
id|far
op_star
id|virt
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
(brace
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|r
suffix:semicolon
id|u_int
id|rbctrl
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHfB&quot;
comma
id|virt
comma
id|len
comma
id|frame_status
)paren
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;hwm_rx_frag: len = %d, frame_status = %x&bslash;n&quot;
comma
id|len
comma
id|frame_status
comma
l_int|2
)paren
suffix:semicolon
id|r
op_assign
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R1
)braket
dot
id|rx_curr_put
suffix:semicolon
id|r-&gt;rxd_virt
op_assign
id|virt
suffix:semicolon
id|r-&gt;rxd_rbadr
op_assign
id|AIX_REVERSE
c_func
(paren
id|phys
)paren
suffix:semicolon
id|rbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
(paren
(paren
(paren
id|u_long
)paren
id|frame_status
op_amp
(paren
id|FIRST_FRAG
op_or
id|LAST_FRAG
)paren
)paren
op_lshift
l_int|26
)paren
op_or
(paren
(paren
(paren
id|u_long
)paren
id|frame_status
op_amp
id|FIRST_FRAG
)paren
op_lshift
l_int|21
)paren
op_or
id|BMU_OWN
op_or
id|BMU_CHECK
op_or
id|BMU_EN_IRQ_EOF
op_or
id|len
)paren
suffix:semicolon
id|r-&gt;rxd_rbctrl
op_assign
id|rbctrl
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_R1_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R1
)braket
dot
id|rx_free
op_decrement
suffix:semicolon
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R1
)braket
dot
id|rx_used
op_increment
suffix:semicolon
id|smc-&gt;hw.fp.rx_q
(braket
id|QUEUE_R1
)braket
dot
id|rx_curr_put
op_assign
id|r-&gt;rxd_next
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHfE&quot;
comma
id|r
comma
id|AIX_REVERSE
c_func
(paren
id|r-&gt;rxd_rbadr
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifndef&t;NDIS_OS2
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_rx_frag)&n; *&t;int mac_drv_rx_frag(smc,virt,len)&n; *&n; * function&t;DOWNCALL&t;(hwmtm.c)&n; *&t;&t;mac_drv_rx_frag fills the fragment with a part of the frame.&n; *&n; * para&t;virt&t;the virtual address of the fragment&n; *&t;len&t;the length in bytes of the fragment&n; *&n; * return 0:&t;success code, no errors possible&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_rx_frag
r_int
id|mac_drv_rx_frag
c_func
(paren
id|smc
comma
id|virt
comma
id|len
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_void
id|far
op_star
id|virt
suffix:semicolon
r_int
id|len
suffix:semicolon
(brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHSB&quot;
comma
id|virt
comma
id|len
comma
id|smc-&gt;os.hwm.r.mb_pos
)paren
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;receive from queue: len/virt: = %d/%x&quot;
comma
id|len
comma
id|virt
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
id|far
op_star
)paren
id|virt
comma
id|smc-&gt;os.hwm.r.mb_pos
comma
id|len
)paren
suffix:semicolon
id|smc-&gt;os.hwm.r.mb_pos
op_add_assign
id|len
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;RHSE&quot;
comma
id|smc-&gt;os.hwm.r.mb_pos
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;BEGINN_MANUAL_ENTRY(mac_drv_clear_rx_queue)&n; *&n; * void mac_drv_clear_rx_queue(smc)&n; * struct s_smc *smc ;&n; *&n; * function&t;DOWNCALL&t;(hardware module, hwmtm.c)&n; *&t;&t;mac_drv_clear_rx_queue is called by the OS-specific module&n; *&t;&t;after it has issued a card_stop.&n; *&t;&t;In this case, the frames in the receive queue are obsolete and&n; *&t;&t;should be removed. For removing mac_drv_clear_rx_queue&n; *&t;&t;calls dma_master for each RxD and mac_drv_clear_rxd for each&n; *&t;&t;receive buffer.&n; *&n; * NOTE:&t;calling sequence card_stop:&n; *&t;&t;CLI_FBI(), card_stop(),&n; *&t;&t;mac_drv_clear_tx_queue(), mac_drv_clear_rx_queue(),&n; *&n; * NOTE:&t;The caller is responsible that the BMUs are idle&n; *&t;&t;when this function is called.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_clear_rx_queue
r_void
id|mac_drv_clear_rx_queue
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|r
suffix:semicolon
r_struct
id|s_smt_fp_rxd
r_volatile
op_star
id|next_rxd
suffix:semicolon
r_struct
id|s_smt_rx_queue
op_star
id|queue
suffix:semicolon
r_int
id|frag_count
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;hw.hw_state
op_ne
id|STOPPED
)paren
(brace
id|SK_BREAK
c_func
(paren
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0012
comma
id|HWM_E0012_MSG
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|queue
op_assign
id|smc-&gt;hw.fp.rx
(braket
id|QUEUE_R1
)braket
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;clear_rx_queue&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dma_complete and mac_drv_clear_rxd for all RxDs / receive buffers&n;&t; */
id|r
op_assign
id|queue-&gt;rx_curr_get
suffix:semicolon
r_while
c_loop
(paren
id|queue-&gt;rx_used
)paren
(brace
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|DB_RX
c_func
(paren
l_string|&quot;switch OWN bit of RxD 0x%x &quot;
comma
id|r
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|r-&gt;rxd_rbctrl
op_and_assign
id|AIX_REVERSE
c_func
(paren
op_complement
id|BMU_OWN
)paren
suffix:semicolon
id|frag_count
op_assign
l_int|1
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
r_while
c_loop
(paren
id|r
op_ne
id|queue-&gt;rx_curr_put
op_logical_and
op_logical_neg
(paren
id|r-&gt;rxd_rbctrl
op_amp
id|AIX_REVERSE
c_func
(paren
id|BMU_ST_BUF
)paren
)paren
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;Check STF bit in %x&quot;
comma
(paren
r_void
op_star
)paren
id|r
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|r-&gt;rxd_rbctrl
op_and_assign
id|AIX_REVERSE
c_func
(paren
op_complement
id|BMU_OWN
)paren
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|r
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|frag_count
op_increment
suffix:semicolon
)brace
id|DB_RX
c_func
(paren
l_string|&quot;STF bit found&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|next_rxd
op_assign
id|r
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|queue-&gt;rx_curr_get
comma
id|i
op_assign
id|frag_count
suffix:semicolon
id|i
suffix:semicolon
id|r
op_assign
id|r-&gt;rxd_next
comma
id|i
op_decrement
)paren
(brace
id|DB_RX
c_func
(paren
l_string|&quot;dma_complete for RxD %x&quot;
comma
(paren
r_void
op_star
)paren
id|r
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|dma_complete
c_func
(paren
id|smc
comma
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|r
comma
id|DMA_WR
)paren
suffix:semicolon
)brace
id|DB_RX
c_func
(paren
l_string|&quot;mac_drv_clear_rxd: RxD %x frag_count %d &quot;
comma
(paren
r_void
op_star
)paren
id|queue-&gt;rx_curr_get
comma
id|frag_count
comma
l_int|5
)paren
suffix:semicolon
id|mac_drv_clear_rxd
c_func
(paren
id|smc
comma
id|queue-&gt;rx_curr_get
comma
id|frag_count
)paren
suffix:semicolon
id|queue-&gt;rx_curr_get
op_assign
id|next_rxd
suffix:semicolon
id|queue-&gt;rx_used
op_sub_assign
id|frag_count
suffix:semicolon
id|queue-&gt;rx_free
op_add_assign
id|frag_count
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;SEND FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(hwm_tx_init)&n; *&t;int hwm_tx_init(smc,fc,frag_count,frame_len,frame_status)&n; *&n; * function&t;DOWN_CALL&t;(hardware module, hwmtm.c)&n; *&t;&t;hwm_tx_init checks if the frame can be sent through the&n; *&t;&t;corresponding send queue.&n; *&n; * para&t;fc&t;the frame control. To determine through which&n; *&t;&t;send queue the frame should be transmitted.&n; *&t;&t;0x50 - 0x57:&t;asynchronous LLC frame&n; *&t;&t;0xD0 - 0xD7:&t;synchronous LLC frame&n; *&t;&t;0x41, 0x4F:&t;SMT frame to the network&n; *&t;&t;0x42:&t;&t;SMT frame to the network and to the local SMT&n; *&t;&t;0x43:&t;&t;SMT frame to the local SMT&n; *&t;frag_count&t;count of the fragments for this frame&n; *&t;frame_len&t;length of the frame&n; *&t;frame_status&t;status of the frame, the send queue bit is already&n; *&t;&t;&t;specified&n; *&n; * return&t;&t;frame_status&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|hwm_tx_init
r_int
id|hwm_tx_init
c_func
(paren
id|smc
comma
id|fc
comma
id|frag_count
comma
id|frame_len
comma
id|frame_status
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|u_char
id|fc
suffix:semicolon
r_int
id|frag_count
suffix:semicolon
r_int
id|frame_len
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
(brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;THiB&quot;
comma
id|fc
comma
id|frag_count
comma
id|frame_len
)paren
suffix:semicolon
id|smc-&gt;os.hwm.tx_p
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|frame_status
op_amp
id|QUEUE_A0
)braket
suffix:semicolon
id|smc-&gt;os.hwm.tx_descr
op_assign
id|TX_DESCRIPTOR
op_or
(paren
(paren
(paren
id|u_long
)paren
(paren
id|frame_len
op_minus
l_int|1
)paren
op_amp
l_int|3
)paren
op_lshift
l_int|27
)paren
suffix:semicolon
id|smc-&gt;os.hwm.tx_len
op_assign
id|frame_len
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;hwm_tx_init: fc = %x, len = %d&quot;
comma
id|fc
comma
id|frame_len
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fc
op_amp
op_complement
(paren
id|FC_SYNC_BIT
op_or
id|FC_LLC_PRIOR
)paren
)paren
op_eq
id|FC_ASYNC_LLC
)paren
(brace
id|frame_status
op_or_assign
id|LAN_TX
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|fc
)paren
(brace
r_case
id|FC_SMT_INFO
suffix:colon
r_case
id|FC_SMT_NSA
suffix:colon
id|frame_status
op_or_assign
id|LAN_TX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FC_SMT_LOC
suffix:colon
id|frame_status
op_or_assign
id|LOC_TX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FC_SMT_LAN_LOC
suffix:colon
id|frame_status
op_or_assign
id|LAN_TX
op_or
id|LOC_TX
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0010
comma
id|HWM_E0010_MSG
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;hw.mac_ring_is_up
)paren
(brace
id|frame_status
op_and_assign
op_complement
id|LAN_TX
suffix:semicolon
id|frame_status
op_or_assign
id|RING_DOWN
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;Ring is down: terminate LAN_TX&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frag_count
OG
id|smc-&gt;os.hwm.tx_p-&gt;tx_free
)paren
(brace
macro_line|#ifndef&t;NDIS_OS2
id|mac_drv_clear_txd
c_func
(paren
id|smc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag_count
OG
id|smc-&gt;os.hwm.tx_p-&gt;tx_free
)paren
(brace
id|DB_TX
c_func
(paren
l_string|&quot;Out of TxDs, terminate LAN_TX&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|frame_status
op_and_assign
op_complement
id|LAN_TX
suffix:semicolon
id|frame_status
op_or_assign
id|OUT_OF_TXD
suffix:semicolon
)brace
macro_line|#else
id|DB_TX
c_func
(paren
l_string|&quot;Out of TxDs, terminate LAN_TX&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|frame_status
op_and_assign
op_complement
id|LAN_TX
suffix:semicolon
id|frame_status
op_or_assign
id|OUT_OF_TXD
suffix:semicolon
macro_line|#endif
)brace
id|DB_TX
c_func
(paren
l_string|&quot;frame_status = %x&quot;
comma
id|frame_status
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;THiE&quot;
comma
id|frame_status
comma
id|smc-&gt;os.hwm.tx_p-&gt;tx_free
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|frame_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(hwm_tx_frag)&n; *&t;void hwm_tx_frag(smc,virt,phys,len,frame_status)&n; *&n; * function&t;DOWNCALL&t;(hardware module, hwmtm.c)&n; *&t;&t;If the frame should be sent to the LAN, this function calls&n; *&t;&t;dma_master, fills the current TxD with the virtual and the&n; *&t;&t;physical address, sets the STF and EOF bits dependent on&n; *&t;&t;the frame status, and requests the BMU to start the&n; *&t;&t;transmit.&n; *&t;&t;If the frame should be sent to the local SMT, an SMT_MBuf&n; *&t;&t;is allocated if the FIRST_FRAG bit is set in the frame_status.&n; *&t;&t;The fragment of the frame is copied into the SMT MBuf.&n; *&t;&t;The function smt_received_pack is called if the LAST_FRAG&n; *&t;&t;bit is set in the frame_status word.&n; *&n; * para&t;virt&t;virtual pointer to the fragment&n; *&t;len&t;the length of the fragment&n; *&t;frame_status&t;status of the frame, see design description&n; *&n; * return&t;nothing returned, no parameter is modified&n; *&n; * NOTE:&t;It is possible to invoke this macro with a fragment length&n; *&t;&t;of zero.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|hwm_tx_frag
r_void
id|hwm_tx_frag
c_func
(paren
id|smc
comma
id|virt
comma
id|phys
comma
id|len
comma
id|frame_status
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_char
id|far
op_star
id|virt
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
(brace
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|t
suffix:semicolon
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
id|u_int
id|tbctrl
suffix:semicolon
id|queue
op_assign
id|smc-&gt;os.hwm.tx_p
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;THfB&quot;
comma
id|virt
comma
id|len
comma
id|frame_status
)paren
suffix:semicolon
multiline_comment|/* Bug fix: AF / May 31 1999 (#missing)&n;&t; * snmpinfo problem reported by IBM is caused by invalid&n;&t; * t-pointer (txd) if LAN_TX is not set but LOC_TX only.&n;&t; * Set: t = queue-&gt;tx_curr_put  here !&n;&t; */
id|t
op_assign
id|queue-&gt;tx_curr_put
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;hwm_tx_frag: len = %d, frame_status = %x &quot;
comma
id|len
comma
id|frame_status
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
id|LAN_TX
)paren
(brace
multiline_comment|/* &squot;*t&squot; is already defined */
id|DB_TX
c_func
(paren
l_string|&quot;LAN_TX: TxD = %x, virt = %x &quot;
comma
id|t
comma
id|virt
comma
l_int|3
)paren
suffix:semicolon
id|t-&gt;txd_virt
op_assign
id|virt
suffix:semicolon
id|t-&gt;txd_txdscr
op_assign
id|AIX_REVERSE
c_func
(paren
id|smc-&gt;os.hwm.tx_descr
)paren
suffix:semicolon
id|t-&gt;txd_tbadr
op_assign
id|AIX_REVERSE
c_func
(paren
id|phys
)paren
suffix:semicolon
id|tbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
(paren
(paren
(paren
id|u_long
)paren
id|frame_status
op_amp
(paren
id|FIRST_FRAG
op_or
id|LAST_FRAG
op_or
id|EN_IRQ_EOF
)paren
)paren
op_lshift
l_int|26
)paren
op_or
id|BMU_OWN
op_or
id|BMU_CHECK
op_or
id|len
)paren
suffix:semicolon
id|t-&gt;txd_tbctrl
op_assign
id|tbctrl
suffix:semicolon
macro_line|#ifndef&t;AIX
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|queue-&gt;tx_bmu_ctl
comma
id|CSR_START
)paren
suffix:semicolon
macro_line|#else&t;/* ifndef AIX */
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
id|QUEUE_A0
)paren
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XA_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
r_else
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XS_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
)brace
macro_line|#endif
id|queue-&gt;tx_free
op_decrement
suffix:semicolon
id|queue-&gt;tx_used
op_increment
suffix:semicolon
id|queue-&gt;tx_curr_put
op_assign
id|t-&gt;txd_next
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
id|LAST_FRAG
)paren
(brace
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACTransmit_Ct
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|frame_status
op_amp
id|LOC_TX
)paren
(brace
id|DB_TX
c_func
(paren
l_string|&quot;LOC_TX: &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
id|FIRST_FRAG
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|smc-&gt;os.hwm.tx_mb
op_assign
id|smt_get_mbuf
c_func
(paren
id|smc
)paren
)paren
)paren
(brace
id|smc-&gt;hw.fp.err_stats.err_no_buf
op_increment
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;No SMbuf; transmit terminated&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;os.hwm.tx_data
op_assign
id|smtod
c_func
(paren
id|smc-&gt;os.hwm.tx_mb
comma
r_char
op_star
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef USE_OS_CPY
macro_line|#ifdef PASS_1ST_TXD_2_TX_COMP
id|hwm_cpy_txd2mb
c_func
(paren
id|t
comma
id|smc-&gt;os.hwm.tx_data
comma
id|smc-&gt;os.hwm.tx_len
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
id|smc-&gt;os.hwm.tx_mb
)paren
(brace
macro_line|#ifndef&t;USE_OS_CPY
id|DB_TX
c_func
(paren
l_string|&quot;copy fragment into MBuf &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|smc-&gt;os.hwm.tx_data
comma
id|virt
comma
id|len
)paren
suffix:semicolon
id|smc-&gt;os.hwm.tx_data
op_add_assign
id|len
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|frame_status
op_amp
id|LAST_FRAG
)paren
(brace
macro_line|#ifdef&t;USE_OS_CPY
macro_line|#ifndef PASS_1ST_TXD_2_TX_COMP
multiline_comment|/*&n;&t;&t;&t;&t; * hwm_cpy_txd2mb(txd,data,len) copies &squot;len&squot; &n;&t;&t;&t;&t; * bytes from the virtual pointer in &squot;rxd&squot;&n;&t;&t;&t;&t; * to &squot;data&squot;. The virtual pointer of the &n;&t;&t;&t;&t; * os-specific tx-buffer should be written&n;&t;&t;&t;&t; * in the LAST txd.&n;&t;&t;&t;&t; */
id|hwm_cpy_txd2mb
c_func
(paren
id|t
comma
id|smc-&gt;os.hwm.tx_data
comma
id|smc-&gt;os.hwm.tx_len
)paren
suffix:semicolon
macro_line|#endif&t;/* nPASS_1ST_TXD_2_TX_COMP */
macro_line|#endif&t;/* USE_OS_CPY */
id|smc-&gt;os.hwm.tx_data
op_assign
id|smtod
c_func
(paren
id|smc-&gt;os.hwm.tx_mb
comma
r_char
op_star
)paren
op_minus
l_int|1
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
id|smc-&gt;os.hwm.tx_mb-&gt;sm_data
op_assign
op_star
id|smc-&gt;os.hwm.tx_data
suffix:semicolon
id|smc-&gt;os.hwm.tx_data
op_increment
suffix:semicolon
id|smc-&gt;os.hwm.tx_mb-&gt;sm_len
op_assign
id|smc-&gt;os.hwm.tx_len
op_minus
l_int|1
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;pass LLC frame to SMT &quot;
comma
l_int|0
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
id|smt_received_pack
c_func
(paren
id|smc
comma
id|smc-&gt;os.hwm.tx_mb
comma
id|RD_FS_LOCAL
)paren
suffix:semicolon
)brace
)brace
)brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;THfE&quot;
comma
id|t
comma
id|queue-&gt;tx_free
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * queues a receive for later send&n; */
DECL|function|queue_llc_rx
r_static
r_void
id|queue_llc_rx
c_func
(paren
id|smc
comma
id|mb
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
(brace
id|DB_GEN
c_func
(paren
l_string|&quot;queue_llc_rx: mb = %x&quot;
comma
(paren
r_void
op_star
)paren
id|mb
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|smc-&gt;os.hwm.queued_rx_frames
op_increment
suffix:semicolon
id|mb-&gt;sm_next
op_assign
(paren
id|SMbuf
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;os.hwm.llc_rx_pipe
op_eq
l_int|0
)paren
(brace
id|smc-&gt;os.hwm.llc_rx_pipe
op_assign
id|mb
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;os.hwm.llc_rx_tail-&gt;sm_next
op_assign
id|mb
suffix:semicolon
)brace
id|smc-&gt;os.hwm.llc_rx_tail
op_assign
id|mb
suffix:semicolon
multiline_comment|/*&n;&t; * force an timer IRQ to receive the data&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;os.hwm.isr_flag
)paren
(brace
id|smt_force_irq
c_func
(paren
id|smc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * get a SMbuf from the llc_rx_queue&n; */
DECL|function|get_llc_rx
r_static
id|SMbuf
op_star
id|get_llc_rx
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SMbuf
op_star
id|mb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mb
op_assign
id|smc-&gt;os.hwm.llc_rx_pipe
)paren
)paren
(brace
id|smc-&gt;os.hwm.queued_rx_frames
op_decrement
suffix:semicolon
id|smc-&gt;os.hwm.llc_rx_pipe
op_assign
id|mb-&gt;sm_next
suffix:semicolon
)brace
id|DB_GEN
c_func
(paren
l_string|&quot;get_llc_rx: mb = 0x%x&quot;
comma
(paren
r_void
op_star
)paren
id|mb
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_return
(paren
id|mb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * queues a transmit SMT MBuf during the time were the MBuf is&n; * queued the TxD ring&n; */
DECL|function|queue_txd_mb
r_static
r_void
id|queue_txd_mb
c_func
(paren
id|smc
comma
id|mb
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
(brace
id|DB_GEN
c_func
(paren
l_string|&quot;_rx: queue_txd_mb = %x&quot;
comma
(paren
r_void
op_star
)paren
id|mb
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|smc-&gt;os.hwm.queued_txd_mb
op_increment
suffix:semicolon
id|mb-&gt;sm_next
op_assign
(paren
id|SMbuf
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;os.hwm.txd_tx_pipe
op_eq
l_int|0
)paren
(brace
id|smc-&gt;os.hwm.txd_tx_pipe
op_assign
id|mb
suffix:semicolon
)brace
r_else
(brace
id|smc-&gt;os.hwm.txd_tx_tail-&gt;sm_next
op_assign
id|mb
suffix:semicolon
)brace
id|smc-&gt;os.hwm.txd_tx_tail
op_assign
id|mb
suffix:semicolon
)brace
multiline_comment|/*&n; * get a SMbuf from the txd_tx_queue&n; */
DECL|function|get_txd_mb
r_static
id|SMbuf
op_star
id|get_txd_mb
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
id|SMbuf
op_star
id|mb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mb
op_assign
id|smc-&gt;os.hwm.txd_tx_pipe
)paren
)paren
(brace
id|smc-&gt;os.hwm.queued_txd_mb
op_decrement
suffix:semicolon
id|smc-&gt;os.hwm.txd_tx_pipe
op_assign
id|mb-&gt;sm_next
suffix:semicolon
)brace
id|DB_GEN
c_func
(paren
l_string|&quot;get_txd_mb: mb = 0x%x&quot;
comma
(paren
r_void
op_star
)paren
id|mb
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_return
(paren
id|mb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;SMT Send function&n; */
DECL|function|smt_send_mbuf
r_void
id|smt_send_mbuf
c_func
(paren
id|smc
comma
id|mb
comma
id|fc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
r_int
id|fc
suffix:semicolon
(brace
r_char
id|far
op_star
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|frag_count
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
id|SK_LOC_DECL
c_func
(paren
r_char
id|far
comma
op_star
id|virt
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_int
id|frag_len
(braket
l_int|3
)braket
suffix:semicolon
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|t
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
id|u_int
id|tbctrl
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;THSB&quot;
comma
id|mb
comma
id|fc
comma
l_int|0
)paren
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;smt_send_mbuf: mb = 0x%x, fc = 0x%x&quot;
comma
id|mb
comma
id|fc
comma
l_int|4
)paren
suffix:semicolon
id|mb-&gt;sm_off
op_decrement
suffix:semicolon
multiline_comment|/* set to fc */
id|mb-&gt;sm_len
op_increment
suffix:semicolon
multiline_comment|/* + fc */
id|data
op_assign
id|smtod
c_func
(paren
id|mb
comma
r_char
op_star
)paren
suffix:semicolon
op_star
id|data
op_assign
id|fc
suffix:semicolon
r_if
c_cond
(paren
id|fc
op_eq
id|FC_SMT_LOC
)paren
op_star
id|data
op_assign
id|FC_SMT_INFO
suffix:semicolon
multiline_comment|/*&n;&t; * determine the frag count and the virt addresses of the frags&n;&t; */
id|frag_count
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|mb-&gt;sm_len
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|n
op_assign
id|SMT_PAGESIZE
op_minus
(paren
(paren
r_int
)paren
id|data
op_amp
(paren
id|SMT_PAGESIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|len
)paren
(brace
id|n
op_assign
id|len
suffix:semicolon
)brace
id|DB_TX
c_func
(paren
l_string|&quot;frag: virt/len = 0x%x/%d &quot;
comma
(paren
r_void
op_star
)paren
id|data
comma
id|n
comma
l_int|5
)paren
suffix:semicolon
id|virt
(braket
id|frag_count
)braket
op_assign
id|data
suffix:semicolon
id|frag_len
(braket
id|frag_count
)braket
op_assign
id|n
suffix:semicolon
id|frag_count
op_increment
suffix:semicolon
id|len
op_sub_assign
id|n
suffix:semicolon
id|data
op_add_assign
id|n
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * determine the frame status&n;&t; */
id|queue
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|QUEUE_A0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fc
op_eq
id|FC_BEACON
op_logical_or
id|fc
op_eq
id|FC_SMT_LOC
)paren
(brace
id|frame_status
op_assign
id|LOC_TX
suffix:semicolon
)brace
r_else
(brace
id|frame_status
op_assign
id|LAN_TX
suffix:semicolon
r_if
c_cond
(paren
(paren
id|smc-&gt;os.hwm.pass_NSA
op_logical_and
(paren
id|fc
op_eq
id|FC_SMT_NSA
)paren
)paren
op_logical_or
(paren
id|smc-&gt;os.hwm.pass_SMT
op_logical_and
(paren
id|fc
op_eq
id|FC_SMT_INFO
)paren
)paren
)paren
id|frame_status
op_or_assign
id|LOC_TX
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|smc-&gt;hw.mac_ring_is_up
op_logical_or
id|frag_count
OG
id|queue-&gt;tx_free
)paren
(brace
r_if
c_cond
(paren
id|frame_status
op_and_assign
op_complement
id|LAN_TX
)paren
(brace
id|DB_TX
c_func
(paren
l_string|&quot;Ring is down: terminate LAN_TX&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
id|DB_TX
c_func
(paren
l_string|&quot;Ring is down: terminate transmission&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|DB_TX
c_func
(paren
l_string|&quot;frame_status = 0x%x &quot;
comma
id|frame_status
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|frame_status
op_amp
id|LAN_TX
)paren
op_logical_and
(paren
id|frame_status
op_amp
id|LOC_TX
)paren
)paren
(brace
id|mb-&gt;sm_use_count
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame_status
op_amp
id|LAN_TX
)paren
(brace
id|t
op_assign
id|queue-&gt;tx_curr_put
suffix:semicolon
id|frame_status
op_or_assign
id|FIRST_FRAG
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|frag_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DB_TX
c_func
(paren
l_string|&quot;init TxD = 0x%x&quot;
comma
(paren
r_void
op_star
)paren
id|t
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|frag_count
op_minus
l_int|1
)paren
(brace
id|frame_status
op_or_assign
id|LAST_FRAG
suffix:semicolon
id|t-&gt;txd_txdscr
op_assign
id|AIX_REVERSE
c_func
(paren
id|TX_DESCRIPTOR
op_or
(paren
(paren
(paren
id|u_long
)paren
(paren
id|mb-&gt;sm_len
op_minus
l_int|1
)paren
op_amp
l_int|3
)paren
op_lshift
l_int|27
)paren
)paren
suffix:semicolon
)brace
id|t-&gt;txd_virt
op_assign
id|virt
(braket
id|i
)braket
suffix:semicolon
id|phys
op_assign
id|dma_master
c_func
(paren
id|smc
comma
(paren
r_void
id|far
op_star
)paren
id|virt
(braket
id|i
)braket
comma
id|frag_len
(braket
id|i
)braket
comma
id|DMA_RD
op_or
id|SMT_BUF
)paren
suffix:semicolon
id|t-&gt;txd_tbadr
op_assign
id|AIX_REVERSE
c_func
(paren
id|phys
)paren
suffix:semicolon
id|tbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
(paren
(paren
(paren
id|u_long
)paren
id|frame_status
op_amp
(paren
id|FIRST_FRAG
op_or
id|LAST_FRAG
)paren
)paren
op_lshift
l_int|26
)paren
op_or
id|BMU_OWN
op_or
id|BMU_CHECK
op_or
id|BMU_SMT_TX
op_or
id|frag_len
(braket
id|i
)braket
)paren
suffix:semicolon
id|t-&gt;txd_tbctrl
op_assign
id|tbctrl
suffix:semicolon
macro_line|#ifndef&t;AIX
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|queue-&gt;tx_bmu_ctl
comma
id|CSR_START
)paren
suffix:semicolon
macro_line|#else
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B0_XA_CSR
)paren
comma
id|CSR_START
)paren
suffix:semicolon
macro_line|#endif
id|frame_status
op_and_assign
op_complement
id|FIRST_FRAG
suffix:semicolon
id|queue-&gt;tx_curr_put
op_assign
id|t
op_assign
id|t-&gt;txd_next
suffix:semicolon
id|queue-&gt;tx_free
op_decrement
suffix:semicolon
id|queue-&gt;tx_used
op_increment
suffix:semicolon
)brace
id|smc-&gt;mib.m
(braket
id|MAC0
)braket
dot
id|fddiMACTransmit_Ct
op_increment
suffix:semicolon
id|queue_txd_mb
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame_status
op_amp
id|LOC_TX
)paren
(brace
id|DB_TX
c_func
(paren
l_string|&quot;pass Mbuf to LLC queue&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|queue_llc_rx
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to unqueue the free SMT_MBUFs here, because it may&n;&t; * be that the SMT want&squot;s to send more than 1 frame for one down call&n;&t; */
id|mac_drv_clear_txd
c_func
(paren
id|smc
)paren
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;THSE&quot;
comma
id|t
comma
id|queue-&gt;tx_free
comma
id|frag_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;BEGIN_MANUAL_ENTRY(mac_drv_clear_txd)&n; *&t;void mac_drv_clear_txd(smc)&n; *&n; * function&t;DOWNCALL&t;(hardware module, hwmtm.c)&n; *&t;&t;mac_drv_clear_txd searches in both send queues for TxD&squot;s&n; *&t;&t;which were finished by the adapter. It calls dma_complete&n; *&t;&t;for each TxD. If the last fragment of an LLC frame is&n; *&t;&t;reached, it calls mac_drv_tx_complete to release the&n; *&t;&t;send buffer.&n; *&n; * return&t;nothing&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_clear_txd
r_void
id|mac_drv_clear_txd
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|t1
suffix:semicolon
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|t2
op_assign
l_int|0
suffix:semicolon
id|SMbuf
op_star
id|mb
suffix:semicolon
id|u_long
id|tbctrl
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|frag_count
suffix:semicolon
r_int
id|n
suffix:semicolon
id|NDD_TRACE
c_func
(paren
l_string|&quot;THcB&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|QUEUE_S
suffix:semicolon
id|i
op_le
id|QUEUE_A0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|queue
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|i
)braket
suffix:semicolon
id|t1
op_assign
id|queue-&gt;tx_curr_get
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;clear_txd: QUEUE = %d (0=sync/1=async)&quot;
comma
id|i
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|frag_count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|DRV_BUF_FLUSH
c_func
(paren
id|t1
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;check OWN/EOF bit of TxD 0x%x&quot;
comma
id|t1
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|tbctrl
op_assign
id|CR_READ
c_func
(paren
id|t1-&gt;txd_tbctrl
)paren
suffix:semicolon
id|tbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|tbctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbctrl
op_amp
id|BMU_OWN
op_logical_or
op_logical_neg
id|queue-&gt;tx_used
)paren
(brace
id|DB_TX
c_func
(paren
l_string|&quot;End of TxDs queue %d&quot;
comma
id|i
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
r_goto
id|free_next_queue
suffix:semicolon
multiline_comment|/* next queue */
)brace
id|t1
op_assign
id|t1-&gt;txd_next
suffix:semicolon
id|frag_count
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|tbctrl
op_amp
id|BMU_EOF
)paren
)paren
suffix:semicolon
id|t1
op_assign
id|queue-&gt;tx_curr_get
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|frag_count
suffix:semicolon
id|n
suffix:semicolon
id|n
op_decrement
)paren
(brace
id|tbctrl
op_assign
id|AIX_REVERSE
c_func
(paren
id|t1-&gt;txd_tbctrl
)paren
suffix:semicolon
id|dma_complete
c_func
(paren
id|smc
comma
(paren
r_union
id|s_fp_descr
r_volatile
op_star
)paren
id|t1
comma
(paren
r_int
)paren
(paren
id|DMA_RD
op_or
(paren
(paren
id|tbctrl
op_amp
id|BMU_SMT_TX
)paren
op_rshift
l_int|18
)paren
)paren
)paren
suffix:semicolon
id|t2
op_assign
id|t1
suffix:semicolon
id|t1
op_assign
id|t1-&gt;txd_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tbctrl
op_amp
id|BMU_SMT_TX
)paren
(brace
id|mb
op_assign
id|get_txd_mb
c_func
(paren
id|smc
)paren
suffix:semicolon
id|smt_free_mbuf
c_func
(paren
id|smc
comma
id|mb
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef PASS_1ST_TXD_2_TX_COMP
id|DB_TX
c_func
(paren
l_string|&quot;mac_drv_tx_comp for TxD 0x%x&quot;
comma
id|t2
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|mac_drv_tx_complete
c_func
(paren
id|smc
comma
id|t2
)paren
suffix:semicolon
macro_line|#else
id|DB_TX
c_func
(paren
l_string|&quot;mac_drv_tx_comp for TxD 0x%x&quot;
comma
id|queue-&gt;tx_curr_get
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|mac_drv_tx_complete
c_func
(paren
id|smc
comma
id|queue-&gt;tx_curr_get
)paren
suffix:semicolon
macro_line|#endif
)brace
id|queue-&gt;tx_curr_get
op_assign
id|t1
suffix:semicolon
id|queue-&gt;tx_free
op_add_assign
id|frag_count
suffix:semicolon
id|queue-&gt;tx_used
op_sub_assign
id|frag_count
suffix:semicolon
)brace
id|free_next_queue
suffix:colon
suffix:semicolon
)brace
id|NDD_TRACE
c_func
(paren
l_string|&quot;THcE&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BEGINN_MANUAL_ENTRY(mac_drv_clear_tx_queue)&n; *&n; * void mac_drv_clear_tx_queue(smc)&n; * struct s_smc *smc ;&n; *&n; * function&t;DOWNCALL&t;(hardware module, hwmtm.c)&n; *&t;&t;mac_drv_clear_tx_queue is called from the SMT when&n; *&t;&t;the RMT state machine has entered the ISOLATE state.&n; *&t;&t;This function is also called by the os-specific module&n; *&t;&t;after it has called the function card_stop().&n; *&t;&t;In this case, the frames in the send queues are obsolete and&n; *&t;&t;should be removed.&n; *&n; * note&t;&t;calling sequence:&n; *&t;&t;CLI_FBI(), card_stop(),&n; *&t;&t;mac_drv_clear_tx_queue(), mac_drv_clear_rx_queue(),&n; *&n; * NOTE:&t;The caller is responsible that the BMUs are idle&n; *&t;&t;when this function is called.&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_clear_tx_queue
r_void
id|mac_drv_clear_tx_queue
c_func
(paren
id|smc
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
(brace
r_struct
id|s_smt_fp_txd
r_volatile
op_star
id|t
suffix:semicolon
r_struct
id|s_smt_tx_queue
op_star
id|queue
suffix:semicolon
r_int
id|tx_used
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|smc-&gt;hw.hw_state
op_ne
id|STOPPED
)paren
(brace
id|SK_BREAK
c_func
(paren
)paren
suffix:semicolon
id|SMT_PANIC
c_func
(paren
id|smc
comma
id|HWM_E0011
comma
id|HWM_E0011_MSG
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|QUEUE_S
suffix:semicolon
id|i
op_le
id|QUEUE_A0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|queue
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|i
)braket
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;clear_tx_queue: QUEUE = %d (0=sync/1=async)&quot;
comma
id|i
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * switch the OWN bit of all pending frames to the host&n;&t;&t; */
id|t
op_assign
id|queue-&gt;tx_curr_get
suffix:semicolon
id|tx_used
op_assign
id|queue-&gt;tx_used
suffix:semicolon
r_while
c_loop
(paren
id|tx_used
)paren
(brace
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORCPU
)paren
suffix:semicolon
id|DB_TX
c_func
(paren
l_string|&quot;switch OWN bit of TxD 0x%x &quot;
comma
id|t
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|t-&gt;txd_tbctrl
op_and_assign
id|AIX_REVERSE
c_func
(paren
op_complement
id|BMU_OWN
)paren
suffix:semicolon
id|DRV_BUF_FLUSH
c_func
(paren
id|t
comma
id|DDI_DMA_SYNC_FORDEV
)paren
suffix:semicolon
id|t
op_assign
id|t-&gt;txd_next
suffix:semicolon
id|tx_used
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * release all TxD&squot;s for both send queues&n;&t; */
id|mac_drv_clear_txd
c_func
(paren
id|smc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|QUEUE_S
suffix:semicolon
id|i
op_le
id|QUEUE_A0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|queue
op_assign
id|smc-&gt;hw.fp.tx
(braket
id|i
)braket
suffix:semicolon
id|t
op_assign
id|queue-&gt;tx_curr_get
suffix:semicolon
multiline_comment|/*&n;&t;&t; * write the phys pointer of the NEXT descriptor into the&n;&t;&t; * BMU&squot;s current address descriptor pointer and set&n;&t;&t; * tx_curr_get and tx_curr_put to this position&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|QUEUE_S
)paren
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XS_DA
)paren
comma
id|AIX_REVERSE
c_func
(paren
id|t-&gt;txd_ntdadr
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|outpd
c_func
(paren
id|ADDR
c_func
(paren
id|B5_XA_DA
)paren
comma
id|AIX_REVERSE
c_func
(paren
id|t-&gt;txd_ntdadr
)paren
)paren
suffix:semicolon
)brace
id|queue-&gt;tx_curr_put
op_assign
id|queue-&gt;tx_curr_get-&gt;txd_next
suffix:semicolon
id|queue-&gt;tx_curr_get
op_assign
id|queue-&gt;tx_curr_put
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;-------------------------------------------------------------&n;&t;TEST FUNCTIONS:&n;&t;-------------------------------------------------------------&n;*/
macro_line|#ifdef&t;DEBUG
multiline_comment|/*&n; *&t;BEGIN_MANUAL_ENTRY(mac_drv_debug_lev)&n; *&t;void mac_drv_debug_lev(smc,flag,lev)&n; *&n; * function&t;DOWNCALL&t;(drvsr.c)&n; *&t;&t;To get a special debug info the user can assign a debug level&n; *&t;&t;to any debug flag.&n; *&n; * para&t;flag&t;debug flag, possible values are:&n; *&t;&t;&t;= 0:&t;reset all debug flags (the defined level is&n; *&t;&t;&t;&t;ignored)&n; *&t;&t;&t;= 1:&t;debug.d_smtf&n; *&t;&t;&t;= 2:&t;debug.d_smt&n; *&t;&t;&t;= 3:&t;debug.d_ecm&n; *&t;&t;&t;= 4:&t;debug.d_rmt&n; *&t;&t;&t;= 5:&t;debug.d_cfm&n; *&t;&t;&t;= 6:&t;debug.d_pcm&n; *&n; *&t;&t;&t;= 10:&t;debug.d_os.hwm_rx (hardware module receive path)&n; *&t;&t;&t;= 11:&t;debug.d_os.hwm_tx(hardware module transmit path)&n; *&t;&t;&t;= 12:&t;debug.d_os.hwm_gen(hardware module general flag)&n; *&n; *&t;lev&t;debug level&n; *&n; *&t;END_MANUAL_ENTRY&n; */
DECL|function|mac_drv_debug_lev
r_void
id|mac_drv_debug_lev
c_func
(paren
id|smc
comma
id|flag
comma
id|lev
)paren
r_struct
id|s_smc
op_star
id|smc
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_int
id|lev
suffix:semicolon
(brace
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
(paren
r_int
)paren
l_int|NULL
suffix:colon
id|DB_P.d_smtf
op_assign
id|DB_P.d_smt
op_assign
id|DB_P.d_ecm
op_assign
id|DB_P.d_rmt
op_assign
l_int|0
suffix:semicolon
id|DB_P.d_cfm
op_assign
l_int|0
suffix:semicolon
id|DB_P.d_os.hwm_rx
op_assign
id|DB_P.d_os.hwm_tx
op_assign
id|DB_P.d_os.hwm_gen
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;SBA
id|DB_P.d_sba
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef&t;ESS
id|DB_P.d_ess
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|DEBUG_SMTF
suffix:colon
id|DB_P.d_smtf
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEBUG_SMT
suffix:colon
id|DB_P.d_smt
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEBUG_ECM
suffix:colon
id|DB_P.d_ecm
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEBUG_RMT
suffix:colon
id|DB_P.d_rmt
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEBUG_CFM
suffix:colon
id|DB_P.d_cfm
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEBUG_PCM
suffix:colon
id|DB_P.d_pcm
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEBUG_SBA
suffix:colon
macro_line|#ifdef&t;SBA
id|DB_P.d_sba
op_assign
id|lev
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|DEBUG_ESS
suffix:colon
macro_line|#ifdef&t;ESS
id|DB_P.d_ess
op_assign
id|lev
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|DB_HWM_RX
suffix:colon
id|DB_P.d_os.hwm_rx
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DB_HWM_TX
suffix:colon
id|DB_P.d_os.hwm_tx
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DB_HWM_GEN
suffix:colon
id|DB_P.d_os.hwm_gen
op_assign
id|lev
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
